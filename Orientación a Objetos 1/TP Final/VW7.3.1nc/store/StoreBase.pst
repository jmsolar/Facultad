<?xml version="1.0"?><st-source><!-- Name: StoreBaseNotice: Copyright © 1999-2005 Cincom Systems, Inc.  All Rights Reserved.BundleName: StoreBaseComment: Store adds team development and version control tools and facilities to the VisualWorks development environment. To load this parcel, you should instead load one (or several) of the following parcels:	StoreForOracle8, StoreForSQLServer, StoreForPostgreSQLwhich will then load this parcel as a prerequisite.Further information on Store can be found in the "Source Code Management Guide" (located in the /doc subdirectory of the VisualWorks installation).PackageName: StoreParcel: #('StoreBase')ParcelName: StoreBasePreReadBlock: [  ( ( Parcel parcelNames, 	( CodeReader allInstances collect: [ :cr | cr parcelName ] )   ) contains:		[ :pn | 		pn notNil and: 			[ ( pn indexOfSubCollection: 'StoreFor' startingAt: 1 ) > 0 ]		]  ) ifTrue: [ true ]   ifFalse: 	[ | msg |	msg := 'StoreBase cannot be loaded.<n>Choose a parcel named: StoreFor...' expandMacros. 	Dialog warn: msg.	false	]]PrerequisiteParcels: #(#('BOSS' '') #('LDM-Framework' '') #('LoggingTool' ''))Version: 7.3.1Pre-Load Block: 	[ :pkg |  ]Post-Load Block: 	[ :pkg |  Store.PundleAccess postLoadActionFor: pkg.]Pre-Unload Block: 	[ :pkg |  Store.PundleAccess preUnloadActionFor: pkg.]Post-Unload Block: 	[]Pre-Read Block: 	[  ( ( Parcel parcelNames, 	( CodeReader allInstances collect: [ :cr | cr parcelName ] )   ) contains:		[ :pn | 		pn notNil and: 			[ ( pn indexOfSubCollection: 'StoreFor' startingAt: 1 ) > 0 ]		]  ) ifTrue: [ true ]   ifFalse: 	[ | msg |	msg := 'StoreBase cannot be loaded.<n>Choose a parcel named: StoreFor...' expandMacros. 	Dialog warn: msg.	false	]]Date: 5:50:25 pm April 10, 2005 --><time-stamp>From VisualWorks®, 7.3.1 of April 10, 2005 on April 10, 2005 at 5:50:25 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>MoveModification</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mod packageName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Merge</category><attributes><package>Store-Merge</package></attributes></class><class><name>FileModel</name><environment>Store</environment><super>Store.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name dbtrace bundle portableFilename </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreTags</category><attributes><package>Store-IMG-Configurations</package></attributes></class><comment><class-id>Store.FileModel</class-id><body>A FileModel is the in image model that represents a file that which is associated with a bundle.  A FileModel is stored in the database a portable filename.Instance Variables:	name		&lt;Object&gt; undocumented	dbtrace	&lt;Object&gt; undocumented	bundle		&lt;BundleModel&gt; The bundle that is associated with this model	portableFilename    &lt;PortableFilename&gt;  The portable filename</body></comment><class><name>CodeReaderForStore</name><environment>Store</environment><super>Kernel.CodeReader</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Storage</category><attributes><package>Store-Base</package></attributes></class><comment><class-id>Store.CodeReaderForStore</class-id><body>I am a special version of CodeReader for binary loading in StORE.  Specifically I suppress the preReadAction, which StORE runs itself.</body></comment><class><name>AbstractTool</name><environment>Store</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.AbstractTool</class-id><body>This was once the superclass of all Store browsers. Slowly, but surely, this guy is going obsolete.Subclasses must implement the following messages:	selection		pundles		pundleVersionsClass Variables:	DbBundleImage	&lt;CachedImage&gt;  comment	DbNonCodePackageImage	&lt;CachedImage&gt;  comment	DbPackageImage	&lt;CachedImage&gt;  comment	IsMonocrome	&lt;Boolean&gt;  comment	ModifiedBundleImage	&lt;OpaqueImage&gt;  comment	ModifiedNonCodePackageImage	&lt;OpaqueImage&gt;  comment	ModifiedPackageImage	&lt;OpaqueImage&gt;  comment	UnmodifiedBundleImage	&lt;CachedImage&gt;  comment	UnmodifiedNonCodePackageImage	&lt;CachedImage&gt;  comment	UnmodifiedPackageImage	&lt;CachedImage&gt;  commentThe comment should also explain any unobvious aspects of the implementation.</body></comment><class><name>GarbageCollectSpecEditor</name><environment>Store</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>availablePundles garbage date blessingLevel blessingLevelMenu pundleAvailability </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><class><name>Loader</name><environment>Store</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comment package data </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><class><name>TextDifferenceBrowser</name><environment>Store</environment><super>Store.AbstractTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text2 text1 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI-Comparitors</package></attributes></class><class><name>FileDifferenceBrowser</name><environment>Store</environment><super>Store.TextDifferenceBrowser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fileName2 fileName1 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI-Comparitors</package></attributes></class><class><name>MergeSelector</name><environment>Store</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packages </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Merge</category><attributes><package>Store-Merge</package></attributes></class><comment><class-id>Store.MergeSelector</class-id><body>Missing comment</body></comment><class><name>AbstractPublishSpecification</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>publish modified comment level version parentVersion description blessing object </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreTags</category><attributes><package>Store-IMG-Configurations</package></attributes></class><comment><class-id>Store.AbstractPublishSpecification</class-id><body>AbstractPublishSpecificationAbstract is generic publishing information. Specifications allow you to set up instructions for publishing to the Bundle/Package.Instance Variables:	blessing	&lt;Integer&gt;	 The blessing level 	comment	&lt;String&gt;	The blessing comment 	description	&lt;String&gt;	A dexcription of the pundle for display	level	&lt;SmallInteger&gt;  indent level		modified	&lt;Boolean&gt;	indicates wheter a component was modified	object	&lt;PundleModel&gt;	the pundle being published	parentVersion	&lt;String&gt; a version string for the published parent version	publish	&lt;Boolean&gt;	true if this component to be published	version	&lt;String&gt;	The version string to use use when publishing</body></comment><class><name>GarbageCollector</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packagesToRemove bundlesToRemove methodsToRemove dataToRemove definitionsToRemove binaryDefinitionsToRemove classesToRemove nameSpacesToRemove parcelRecordsToRemove packagesToAdopt bundlesToAdopt methodsToAdopt dataToAdopt classesToAdopt nameSpacesToAdopt </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Database</category><attributes><package>Store-Database</package></attributes></class><class><name>MismatchedDatabaseError</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><class><name>MergeData</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>trees modifications integratedVersions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Merge</category><attributes><package>Store-Merge</package></attributes></class><comment><class-id>Store.MergeData</class-id><body>Missing comment</body></comment><class><name>PundleChanges</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundle1 pundle2 changeSet1 changeSet2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><comment><class-id>Store.PundleChanges</class-id><body>A PackageChanges converts and holds the changes between two database package versions. Instance Variables:	pundle1	&lt;Pundle&gt;	First pundle	pundle2	&lt;Pundle&gt;	Second pundle.	changeSet1	&lt;XChangeSet&gt;	ChangeSet for converting pundle2 into pundle1	changeSet2	&lt;XChangeSet&gt;	ChangeSet for converting pundle1 into pundle2</body></comment><class><name>ClassLoader</name><environment>Store</environment><super>Store.Loader</super><private>false</private><indexed-type>none</indexed-type><inst-vars>class cmethods imethods cdefinition idefinition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><class><name>BundleChanges</name><environment>Store</environment><super>Store.PundleChanges</super><private>false</private><indexed-type>none</indexed-type><inst-vars>componentChanges </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><class><name>ElementProxy</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>element related cache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Graphs</category><attributes><package>Store-UI-Graphs</package></attributes></class><comment><class-id>Store.ElementProxy</class-id><body>Wraps an an item in a graph. For the LDM graphing tools.Instance Variables:	element	&lt;Object&gt;  an element in a graph.	related	&lt;IdentityDictionary&gt; saves key-&gt;relationships.	cache	&lt;Dictionary&gt;  passed in by the client.Used to cache all the items in the graph for sharing.</body></comment><class><name>GroupElement</name><environment>Store</environment><super>Store.ElementProxy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Graphs</category><attributes><package>Store-UI-Graphs</package></attributes></class><class><name>PundleChangeList</name><environment>Store</environment><super>Tools.AbstractChangeList</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>pundle conflictPundle dbIdentifier conflictCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Changes</category><attributes><package>Store-UI</package></attributes></class><class><name>VersionBrowser</name><environment>Store</environment><super>Store.AbstractTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>versions pundles labels offsets comment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.VersionBrowser</class-id><body>VersionBrowser is used by the PublishedPundlesTool to provide the list of versions a package or bundle.  When one of these versions is selected, VersionBrowser will display the blessing comment history for the selected version.Some attempt at trying to optimize queries to the database for versions has been made.  The labels dictionary contains the pre-computed labels for the sequence view.Instance Variables:	comment	&lt;ValueModel on: Text&gt;	The blessing level comment history for the selected version	labels		&lt;Dictionary of: Array&gt;	Each Array contains three elements.  Each element is a label.  These are used to display in the sequence view	offsets		&lt;(Array of: Number)&gt;	A three element array with a hint on where to display a label in the sequenceview's visual block	pundles		&lt;OrderedCollection of: Store.Bundle | Store.Package&gt;	The list of pundles that versions are being displayed for	versions		&lt;MultiSelectionInList&gt;	The list of versions for each item in pundles</body></comment><class><name>PublishFileSpecification</name><environment>Store</environment><super>Store.AbstractPublishSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>file </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreTags</category><attributes><package>Store-IMG-Configurations</package></attributes></class><class><name>StoreNotConnectedError</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-DB-BaseObjects</package></attributes></class><class><name>PackageEmphasizer</name><environment>Store</environment><super>Tools.Emphasizer</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>Store-UI-Browser</package></attributes></class><class><name>StoreLoggingTool</name><environment>Store</environment><super>Tools.LoggingTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><class><name>ConnectionDialog</name><environment>Store</environment><super>Database.ConnectionDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tableOwnerHolder tableOwnerListHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-DB-BaseObjects</package></attributes></class><comment><class-id>Store.ConnectionDialog</class-id><body>Store extension to the Datbase.ConnectionDialog.  Adds support for owner names.Instance Variables:	tableOwnerHolder	  &lt;ValueHolder&gt;	 Holds the current owner string.	tableOwnerListHolder &lt;ValueHolder&gt;	 Holds the list of existing owners.</body></comment><class><name>CachingPackageEmphasizer</name><environment>Store</environment><super>Store.PackageEmphasizer</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>cachedLeafItems </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>Store-UI-Browser</package></attributes></class><comment><class-id>Store.CachingPackageEmphasizer</class-id><body>CachingPackageEmphasizer is a specialized PackageEmphasizer used for browsing pundles in the database.  When one browses in-image pundles, the refactoring browser is used, i.e. the Emphasizer hierarchy is only used in a database context.Instance Variables:	cachedLeafItems	&lt;Dictionary&gt;	A pundle to leaf items map for leaf items.  Computing leaf items is database intensive (we go to the database each time leafItems is sent)</body></comment><class><name>BlessingLevel</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>name level type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-User Management</category><attributes><package>Store-User Management</package></attributes></class><class><name>PublishedPackagePropertiesDialog</name><environment>Store</environment><super>UI.PackagePropertiesDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>postProcessingBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.PublishedPackagePropertiesDialog</class-id><body>A variation of PackagePropertiesDialog that takes into account that the package it is editing does not exist in the image, but is a fake instantiated as a stand in for a db package. Also, supports post-dialog processing, since this is not a modal dialog.	postProcessingBlock &lt;ZeroArgumentBlock&gt; - evaluated after accept to allow the client to update the properties.</body></comment><class><name>PublishSpecificationList</name><environment>Store</environment><super>Core.List</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreTags</category><attributes><package>Store-IMG-Configurations</package></attributes></class><comment><class-id>Store.PublishSpecificationList</class-id><body>A List of PublishSpecifications. These are for the master bundle/package and all sub-components.</body></comment><class><name>SQLBroker</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Broker</category><attributes><package>Store-DB-Broker</package></attributes></class><comment><class-id>Store.SQLBroker</class-id><body>Abstract superclass responsible for processing database queries and error handling. The subclasses interface to a specific backend.Subclasses must implement the following messages:	Class protocol:		drop objects			dropDatabaseFor:			dropIndexForClass:			dropIndexForClass:index:			dropSequenceForClass:			dropTableForClass:			dropUser:			dropViewForClass:		grant statements			grant:on:columnList:to:			processGrantStatement:		private-accessing			dismissSession:		connection class			connectionClass		error handling			alreadyExistErrors			cannotCloseCursorErrorCode			doesNotExistErrors			invalidObjectErrorNumber			objectAlreadyExistisErrorNumber			objectAlreadyGoneErrorNumber			serverDiedErrorCodes		accessing			fullTableName:			getBlobData:			indexNameFor:			needsSequenceFor:		private			typeToStringMap		sql processing			safelyExecuteBlock:		create objects			allocateSpaceForObjectsIn:			createDatabaseSequence:			createDatabaseTable:			createPhysicalSpaces			createTablePrimaryKeySectionFor:keys:			createViewForClass:		queries			newSQLFor:			nextIDQuery:			sqlAssistClass</body></comment><class><name>TextLine</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourceString string startIndex stopIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><class><name>AbstractModification</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>package tag </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Merge</category><attributes><package>Store-Merge</package></attributes></class><class><name>Modification</name><environment>Store</environment><super>Store.AbstractModification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>record </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Merge</category><attributes><package>Store-Merge</package></attributes></class><class><name>LoadDialog</name><environment>Store</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.LoadDialog</class-id><body>Validates a bundle and displays possible reasons why a user may not wish to continue the load.</body></comment><class><name>PundleParent</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name trace </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Pundles</category><attributes><package>Store-IMG-Pundles</package></attributes></class><class><name>BundleParent</name><environment>Store</environment><super>Store.PundleParent</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Pundles</category><attributes><package>Store-IMG-Pundles</package></attributes></class><class><name>PackageParent</name><environment>Store</environment><super>Store.PundleParent</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Pundles</category><attributes><package>Store-IMG-Pundles</package></attributes></class><class><name>SQLAssist</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tableName tableClass sqlStream alias </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Broker</category><attributes><package>Store-DB-Broker</package></attributes></class><comment><class-id>Store.SQLAssist</class-id><body>Abstract superclass for sql statment generators. Subclasses support specfic backends.Instance Variables:	tableName	&lt;String&gt;  name of table being queried.	sqlStream	&lt;ReadWriteStream&gt;  used to build the query.	tableClass &lt;Class&gt; the class that represents the table being queried	alias &lt;String&gt; optional alias used for doing joins. Allows subclasses to optimize for specific backends.</body></comment><class><name>CommentPrompt</name><environment>Store</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text blessingLevel userName pundle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><class><name>RepositoryManager</name><environment>Store</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>repositoryListHolder connectedIcon </inst-vars><class-inst-vars></class-inst-vars><imports>			private XML.XMLParser			private XML.SAXWriter			private XML.Document			private XML.Element			</imports><category>Store-DB-BaseObjects</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.RepositoryManager</class-id><body>RepositoryManager is the standalone application for managing Store connections. It uses a dataset to list the known connections and allows one to manage connections, including saving to and loading from files.Instance Variables:	connectedIcon	&lt;Image&gt;	The image used by the dataset to mark the currenly connected repository, if any.	repositoryListHolder	&lt;SelectionInList&gt;	The model of the repository list.</body></comment><class><name>BasicMergePolicy</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-User Management</category><attributes><package>Store-User Management</package></attributes></class><class><name>BasicPublishPolicy</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>allowBinaryLoading </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-User Management</category><attributes><package>Store-User Management</package></attributes></class><comment><class-id>Store.BasicPublishPolicy</class-id><body>Missing comment</body></comment><class><name>ElementView</name><environment>Store</environment><super>Lens.LDMElementView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Graphs</category><attributes><package>Store-UI-Graphs</package></attributes></class><class><name>DBAccess</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>environmentString connection sequenceConnection connectedProfileHolder recentProfile isOnline tablePrefix debug log logFile databaseIdentifier storeBroker installScript debugger </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Database</category><attributes><package>Store-Database</package></attributes></class><class><name>AbstractWindowTool</name><environment>Store</environment><super>Store.AbstractTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar popupMenu windowTitle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><class><name>UnloadableDefinitionError</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>package </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-DB-BaseObjects</package></attributes></class><comment><class-id>Store.UnloadableDefinitionError</class-id><body>Raised when a db definition cannot be loaded into the image. Common problems covered here are methods and shared extensions with no class; class and namepsace defs with no enfivornment.Instance Variables:	package	&lt;PackageModel&gt;	The package this definition should load into.</body></comment><class><name>PackageBrowserHelper</name><environment>Store</environment><super>Tools.BrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Browser</category><attributes><package>Store-UI-Browser</package></attributes></class><class><name>PackageDifferences</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classes1 classes2 meta1 meta2 nameSpaces1 nameSpaces2 methods1 methods2 data1 data2 pkg1 pkg2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><class><name>LoadAnalyzer</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classes nameSpaces methodDict dataDict toPackage classesAreAlien wholePackage classesWithoutSuper classesWithNoEnvironment nameSpacesWithNoEnvironment withinBundle leafItems overrides </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Database</category><attributes><package>Store-Database</package></attributes></class><class><name>PackageProtocolBrowserHelper</name><environment>Store</environment><super>Tools.ProtocolBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sortBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Browser</category><attributes><package>Store-UI-Browser</package></attributes></class><class><name>MergeTool</name><environment>Store</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mergeData pkgList bundles displayText conflictText textMode modSetList show modSet conflictType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Merge</category><attributes><package>Store-Merge</package></attributes></class><class><name>PublishDirectorySpecification</name><environment>Store</environment><super>Store.PublishFileSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>directory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Configurations</category><attributes><package>Store-IMG-Configurations</package></attributes></class><class><name>IndentedListBuilder</name><environment>Store</environment><super>Lens.LDMIndentedListBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Graphs</category><attributes><package>Store-UI-Graphs</package></attributes></class><class><name>PackageClassesBrowserHelper</name><environment>Store</environment><super>Tools.NameSpaceCategoryBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Browser</category><attributes><package>Store-UI-Browser</package></attributes></class><class><name>PackageClassesVersionBrowserHelper</name><environment>Store</environment><super>Store.PackageClassesBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Browser</category><attributes><package>Store-UI-Browser</package></attributes></class><class><name>BasicOwnershipPolicy</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Ownership</category><attributes><package>Store-Ownership</package></attributes></class><class><name>OwnerOwnershipPolicy</name><environment>Store</environment><super>Store.BasicOwnershipPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Ownership</category><attributes><package>Store-Ownership</package></attributes></class><class><name>PackageConflicts</name><environment>Store</environment><super>Store.PackageDifferences</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><class><name>PseudoPackage</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>realPackage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Pundles</category><attributes><package>Store-IMG-Pundles</package></attributes></class><class><name>LostConnectionNotification</name><environment>Core</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-DB-BaseObjects</package></attributes></class><class><name>MultiSequenceController</name><environment>Store</environment><super>UI.SequenceController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><class><name>AbstractTag</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>symbol isMeta </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><class><name>NameSpaceTag</name><environment>Store</environment><super>Store.AbstractTag</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><class><name>ClassCommentTag</name><environment>Store</environment><super>Store.AbstractTag</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><class><name>NameSpaceCommentTag</name><environment>Store</environment><super>Store.NameSpaceTag</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><class><name>MethodTag</name><environment>Store</environment><super>Store.AbstractTag</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector protocol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><class><name>AbstractComponentTag</name><environment>Store</environment><super>Store.AbstractTag</super><private>false</private><indexed-type>none</indexed-type><inst-vars>package </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><class><name>PropertyTag</name><environment>Store</environment><super>Store.AbstractComponentTag</super><private>false</private><indexed-type>none</indexed-type><inst-vars>property </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><class><name>StoreLogEnvironment</name><environment>Store</environment><super>Tools.LogEnvironment</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Base</category><attributes><package>Store-Base</package></attributes></class><class><name>PublishSpecification</name><environment>Store</environment><super>Store.AbstractPublishSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mergeData binarySave parcelSave bundleStructure databaseLinks parcelDirectory parcelRepublish parcelBackup parcelOverwrite parcelSaveSource parcelHideSource parcelPadded </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreTags</category><attributes><package>Store-IMG-Configurations</package></attributes></class><comment><class-id>Store.PublishSpecification</class-id><body>PublishSpecification contains all the options used when publishing. #parcelX options are only used when a parcel is also being produced.Instance Variables:	binarySave	&lt;Boolean&gt;	Indicates whether to publish the pundle as binary	bundleStructure	&lt;Boolean&gt;	Indicates if bundle structure should be stored when producing a parcel. 	databaseLinks	&lt;Boolean&gt;	Indicates if trace links to the current database should be stored in the parcel. 	mergeData	&lt;MergeData&gt;	Information collected in the MergeTool	parcelBackup	&lt;Boolean&gt;	Indicates if the parcel (it it exists and we are overwriting it) should be backed up.	parcelDirectory	&lt;String&gt;	The directory to store the parcel in. 	parcelHideSource &lt;Boolean&gt; Indicates if the parcel should have its source hidden. 	parcelOverwrite	&lt;Boolean&gt;	Indicates if the parcel (if it already exists) should be overwritten. 	parcelPadded	&lt;Boolean&gt;	Indicates if the parcel's source file should be padded.  See the class comment for SourceFileManager for futher information on padding source files.	parcelRepublish	&lt;Boolean&gt;	Indicates if the parcel should be republished.  	parcelSave	&lt;Boolean&gt;	Indicates if a parcel should also be created when publishing	parcelSaveSource &lt;Boolean&gt; Indicates if the parcel should have its source file saved.  </body></comment><class><name>PublishFragmentSpecification</name><environment>Store</environment><super>Store.PublishSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreTags</category><attributes><package>Store-IMG-Configurations</package></attributes></class><comment><class-id>Store.PublishFragmentSpecification</class-id><body>A PublishFragmentSpecification is used when publishing changes based on a ChangeSet selected in the ChangeSetManager</body></comment><class><name>DataTag</name><environment>Store</environment><super>Store.AbstractTag</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dataKey forClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><class><name>Privileges</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Ownership</category><attributes><package>Store-Ownership</package></attributes></class><class><name>BundleDifferenceBrowser</name><environment>Store</environment><super>Store.TextDifferenceBrowser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bundle1 bundle2 </inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			</imports><category>Store-UI</category><attributes><package>Store-UI-Comparitors</package></attributes></class><class><name>TextModification</name><environment>Store</environment><super>Store.AbstractModification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Merge</category><attributes><package>Store-Merge</package></attributes></class><class><name>PackageOwnerElement</name><environment>Store</environment><super>Store.ElementProxy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Graphs</category><attributes><package>Store-UI-Graphs</package></attributes></class><class><name>PundleParentMap</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>descriptions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Pundles</category><attributes><package>Store-IMG-Pundles</package></attributes></class><class><name>ClassTag</name><environment>Store</environment><super>Store.AbstractTag</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><class><name>GraphTool</name><environment>Store</environment><super>Store.AbstractTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>graphView </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Graphs</category><attributes><package>Store-UI-Graphs</package></attributes></class><class><name>GroupGraph</name><environment>Store</environment><super>Store.GraphTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>userList groupList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Graphs</category><attributes><package>Store-UI-Graphs</package></attributes></class><class><name>PrivilegeGraph</name><environment>Store</environment><super>Store.GraphTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>userGroupList packageList privilegeText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Graphs</category><attributes><package>Store-UI-Graphs</package></attributes></class><class><name>PackageMethodsBrowserHelper</name><environment>Store</environment><super>Tools.SelectorBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Browser</category><attributes><package>Store-UI-Browser</package></attributes></class><class><name>PackageMethodListBrowserHelper</name><environment>Store</environment><super>Store.PackageMethodsBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Browser</category><attributes><package>Store-UI-Browser</package></attributes></class><class><name>PackageMethodsEditorHelper</name><environment>Store</environment><super>Store.PackageMethodListBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Browser</category><attributes><package>Store-UI-Browser</package></attributes></class><class><name>PackageComparisonEmphasizer</name><environment>Store</environment><super>Tools.Emphasizer</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Browser</category><attributes><package>Store-UI-Comparitors</package></attributes></class><class><name>BundleTabApplication</name><environment>Store</environment><super>Tools.BrowserTabApplication</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pkgDef packageFilter cachedItems </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Browser</category><attributes><package>Store-UI-Browser</package></attributes></class><class><name>PackageComparisonApplication</name><environment>Store</environment><super>Store.BundleTabApplication</super><private>false</private><indexed-type>none</indexed-type><inst-vars>changes invisibleSelection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Browser</category><attributes><package>Store-UI-Comparitors</package></attributes></class><class><name>DBObject</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>table nextIndex SequenceGeneratorSession </class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-DB-BaseObjects</package></attributes></class><class><name>DatabaseIdentifier</name><environment>Store</environment><super>Store.DBObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>identityName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-DB-BaseObjects</package></attributes></class><comment><class-id>Store.DatabaseIdentifier</class-id><body>Used to store the name of this Store database.Instance Variables:	identityName	&lt;string&gt;  a name that uniquely identifies this database within an organzation.</body></comment><class><name>DBUserGroup</name><environment>Store</environment><super>Store.DBObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>groupName userName type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Ownership</category><attributes><package>Store-Ownership</package></attributes></class><comment><class-id>Store.DBUserGroup</class-id><body>Users and groups. Logins are maintained by the datbase engine. The user name should be the same as the database login id. A group is not a database login, but a Store organization. Groups contain both users and groups.A package owner can be a user or a group. Rights granted to a group apply to all users within the group.Instance Variables:	groupName	&lt;String&gt;  group name. same as user name if this is for a user.	userName	&lt;String&gt;  user name	type	&lt;String&gt;  'U' for user, 'G' for group</body></comment><class><name>Association</name><environment>Store</environment><super>Store.DBObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-DB-BaseObjects</package></attributes></class><comment><class-id>Store.Association</class-id><body>Abstract superclass to model the many to many relationship tables.</body></comment><class><name>Data</name><environment>Store</environment><super>Store.Association</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packageRef dataRef </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Subdefs</category><attributes><package>Store-DB-Subdefs</package></attributes></class><comment><class-id>Store.Data</class-id><body>Package to DataElement talbe.Instance Variables:	packageRef	&lt;Integer&gt;	Package primaryKey	dataRef	&lt;Integer&gt;		DataElement primaryKey</body></comment><class><name>PkgNameSpaces</name><environment>Store</environment><super>Store.Association</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packageRef nameSpaceRef definitionOrder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Records</category><attributes><package>Store-DB-Records</package></attributes></class><comment><class-id>Store.PkgNameSpaces</class-id><body>Package to namespaces mapping.Instance Variables:	packageRef	&lt;Integer&gt;		Package primaryKey	nameSpaceRef	&lt;Integer&gt;	NameSpaceRecord primaryKey	definitionOrder	&lt;Integer&gt;	load order index</body></comment><class><name>Properties</name><environment>Store</environment><super>Store.Association</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundleRef propertyRef recType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Subdefs</category><attributes><package>Store-DB-Records</package></attributes></class><class><name>Methods</name><environment>Store</environment><super>Store.Association</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packageRef methodRef </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Subdefs</category><attributes><package>Store-DB-Subdefs</package></attributes></class><comment><class-id>Store.Methods</class-id><body>Package to Method talbe.Instance Variables:	packageRef	&lt;Integer&gt;	Package primaryKey	methodRef	&lt;Integer&gt;	Method primaryKey</body></comment><class><name>PkgClasses</name><environment>Store</environment><super>Store.Association</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packageRef classRef metaclassRef definitionOrder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Records</category><attributes><package>Store-DB-Records</package></attributes></class><comment><class-id>Store.PkgClasses</class-id><body>Package to classes mapping.Instance Variables:	packageRef	&lt;Integer&gt;	Package primaryKey	classRef	&lt;Integer&gt;	ClassRecord primaryKey	metaclassRef	&lt;Integer&gt;	meta ClassRecord primaryKey	definitionOrder	&lt;Integer&gt;	load order index</body></comment><class><name>DBRecord</name><environment>Store</environment><super>Store.DBObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>primaryKey name timeStamp version userName trace dbIdentifier </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-DB-BaseObjects</package></attributes></class><class><name>Record</name><environment>Store</environment><super>Store.DBRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>PrimaryKeySession </class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-DB-BaseObjects</package></attributes></class><class><name>Pundle</name><environment>Store</environment><super>Store.Record</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blessingLevel commentID propertiesID properties propertyRecords commentStr </inst-vars><class-inst-vars>Cache </class-inst-vars><imports></imports><category>Store-DB-Pundles</category><attributes><package>Store-DB-Pundles</package></attributes></class><class><name>Package</name><environment>Store</environment><super>Store.Pundle</super><private>false</private><indexed-type>none</indexed-type><inst-vars>namespaces classes metaclasses methods binFile data overrides parcelID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Pundles</category><attributes><package>Store-DB-Pundles</package></attributes></class><class><name>PseudoPseudo</name><environment>Store</environment><super>Store.Record</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-DB-BaseObjects</package></attributes></class><comment><class-id>Store.PseudoPseudo</class-id><body>Superclass for pseudo database records which serve as placeholders when a package does not contain a definition, but must display some representation of it.</body></comment><class><name>PseudoNameSpace</name><environment>Store</environment><super>Store.PseudoPseudo</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Records</category><attributes><package>Store-DB-Records</package></attributes></class><class><name>PseudoClass</name><environment>Store</environment><super>Store.PseudoPseudo</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Records</category><attributes><package>Store-DB-Records</package></attributes></class><class><name>DefinedRecord</name><environment>Store</environment><super>Store.Record</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definitionID commentID environmentString definitionStr commentStr package </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Records</category><attributes><package>Store-DB-Records</package></attributes></class><class><name>PropertyRecord</name><environment>Store</environment><super>Store.DefinedRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>searchString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Records</category><attributes><package>Store-DB-Records</package></attributes></class><comment><class-id>Store.PropertyRecord</class-id><body>PropertyRecord holds the database information for a pundle property.As with DefinedRecord subclasses (ClassRecord, DataElement, NameSpaceRecord),PropertyRecord objects live in their own table (TW_PROPERTY), and are referencedthrough an intermediate table (TW_PROPERTIES). Using the intermediate tableallows for multiple packages to reference a single property record. In this way,a property can be defined once and carried forward to subsequent versions ofthe same package, without being duplicated. Only the "reference" is duplicated.Alternatively, a property can be redefined with every published version.Each property record has a comment along with a property value.Instance Variables:	commentID	&lt;Integer&gt;	 the blob ID for the BOSSed comment.	commentStr	&lt;ByteArray&gt;	the BOSSed comment.	package	&lt;Package&gt;	the package this property is defined for.	propertyID	&lt;Integer&gt; 	the blob ID for the BOSSed property.	propertyStr	&lt;ByteArray&gt; 	the BOSSed property.	searchString&lt;String&gt;		the 1st 255 chars of property, if property isKindOf: String.Inherrited Instance Variables:	dbIdentifier	&lt;Object&gt;	Identifies which database this record is from.	name	&lt;String&gt;	Name of this property.	primaryKey	&lt;CharacterArray | CharacterBlock | Magnitude&gt;	PrimaryKey of this property record.	timeStamp	&lt;Object&gt;	description of timeStamp	trace	&lt;ArithmeticValue&gt;	description of trace	userName	&lt;Object&gt;	description of userName	version	&lt;Dialog | Object&gt;	description of version</body></comment><class><name>ClassRecord</name><environment>Store</environment><super>Store.DefinedRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Records</category><attributes><package>Store-DB-Records</package></attributes></class><comment><class-id>Store.ClassRecord</class-id><body>A ClassRecord represents the definition of a class that is stored in the database.Instance Variables:	superclass	&lt;String&gt;	The absolute name of the superclass for the class that this record represents</body></comment><class><name>Subdef</name><environment>Store</environment><super>Store.Record</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourceCodeID sourceCodeString creatorPackage creatorPackageVersion </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Subdefs</category><attributes><package>Store-DB-Subdefs</package></attributes></class><class><name>Method</name><environment>Store</environment><super>Store.Subdef</super><private>false</private><indexed-type>none</indexed-type><inst-vars>className meta metaString protocolName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Subdefs</category><attributes><package>Store-DB-Subdefs</package></attributes></class><class><name>FileRecord</name><environment>Store</environment><super>Store.Record</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fileID fileData fileSize components </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Pundles</category><attributes><package>Store-DB-Pundles</package></attributes></class><comment><class-id>Store.FileRecord</class-id><body>FileRecord represents the specification of a file (associated with a bundle) that is stored in the database.  To capture the filename in a platform portable way, FileRecord stores the components (#componentStrings) that make up the file. When being stored into the database, the components are first converted into the BOSS format (#convertBinaryData), then reverted back to the OrderedCollection of component strings after installation in the database.Instance Variables:	fileID	&lt;Integer&gt; description of fileID	fileData	&lt;ByteArray&gt; The data of the file	fileSize	&lt;Integer&gt; The size of the file	components	&lt;OrderedCollection of: String&gt; 	The components of the filename, i.e. the Portable filename.</body></comment><class><name>Blessing</name><environment>Store</environment><super>Store.DBObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>primaryKey timeStamp userName commentID blessingLevel trace pkgID commentString recType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-DB-BaseObjects</package></attributes></class><class><name>ViewRecord</name><environment>Store</environment><super>Store.Record</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-DB-BaseObjects</package></attributes></class><comment><class-id>Store.ViewRecord</class-id><body>ViewRecords represent database views that define a logical view of  joined tables.</body></comment><class><name>PkgNameSpacesView</name><environment>Store</environment><super>Store.ViewRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definitionID commentID environmentString packageRef definitionOrder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Records</category><attributes><package>Store-DB-Records</package></attributes></class><class><name>PkgDefinedRecordView</name><environment>Store</environment><super>Store.ViewRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definitionID commentID environmentString packageRef definitionOrder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Records</category><attributes><package>Store-DB-Records</package></attributes></class><class><name>PkgClassesView</name><environment>Store</environment><super>Store.ViewRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass definitionID environmentString commentID packageRef definitionOrder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Records</category><attributes><package>Store-DB-Records</package></attributes></class><comment><class-id>Store.PkgClassesView</class-id><body>Maps Packages to Classes.Instance Variables:	superclass	&lt;String&gt;  fully qualified superclass name. 	definitionID	&lt;Integer&gt;  link to blob table pointing to class definition	environmentString	&lt;String&gt; environment strng of class	commentID	&lt;Integer&gt;  link to blob table pointing to class comment	packageRef	&lt;Integer&gt;  link to package	definitionOrder	&lt;Integer&gt;  class orderShared Variables:	ClassesSession	&lt;ExternalDatabaseSession&gt;  cached session for all classes in a package.</body></comment><class><name>BundlesView</name><environment>Store</environment><super>Store.ViewRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bundleComment bundleRef expression seqNumber </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Pundles</category><attributes><package>Store-DB-Pundles</package></attributes></class><class><name>PkgNameSpacesAndSourcesView</name><environment>Store</environment><super>Store.PkgNameSpacesView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blobData blobType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Records</category><attributes><package>Store-DB-Records</package></attributes></class><comment><class-id>Store.PkgNameSpacesAndSourcesView</class-id><body>Extends PkgNameSpacesView to include sources, by linking the definitonID to the definition table.Instance Variables:	blobData	&lt;ByteArray&gt;  class definition raw data	blobType	&lt;Integer&gt;  	  postive number is blobData type, negative number is link to next chunk.Shared Variables:	NameSpacesWithSourcesSession	&lt;ExternalDatabaseSession&gt;  cached session with * query</body></comment><class><name>PropertiesView</name><environment>Store</environment><super>Store.ViewRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definitionID commentID environmentString searchString pundleRef recType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Records</category><attributes><package>Store-DB-Records</package></attributes></class><class><name>NameSpaceRecord</name><environment>Store</environment><super>Store.DefinedRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Records</category><attributes><package>Store-DB-Records</package></attributes></class><comment><class-id>Store.NameSpaceRecord</class-id><body>A NameSpaceRecord represents a NameSpace definition that is stored in a database.</body></comment><class><name>Bundle</name><environment>Store</environment><super>Store.Pundle</super><private>false</private><indexed-type>none</indexed-type><inst-vars>vanguardID rearguardID vanguardStr rearguardStr contents files </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Pundles</category><attributes><package>Store-DB-Pundles</package></attributes></class><class><name>PseudoSubdef</name><environment>Store</environment><super>Store.PseudoPseudo</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key isData </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Records</category><attributes><package>Store-DB-Subdefs</package></attributes></class><class><name>BundlePart</name><environment>Store</environment><super>Store.Association</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bundleRef expressionID seqNumber expressionStr </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Pundles</category><attributes><package>Store-DB-Pundles</package></attributes></class><comment><class-id>Store.BundlePart</class-id><body>Abstract superclass for the bundle contents. These are interface tables that contain bundle to sub-bundle/package refs.Instance Variables:	bundleRef	      &lt;Integer&gt;	primaryKey of owning bundle.	expressionID	&lt;Integer&gt;	key for expression string	seqNumber	      &lt;Integer&gt;	for ordering of bundle contents.	expressionStr	&lt;String&gt;	I have no idea.</body></comment><class><name>Files</name><environment>Store</environment><super>Store.BundlePart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fileRef </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Pundles</category><attributes><package>Store-DB-Pundles</package></attributes></class><class><name>Bundles</name><environment>Store</environment><super>Store.BundlePart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subBundleRef </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Pundles</category><attributes><package>Store-DB-Pundles</package></attributes></class><comment><class-id>Store.Bundles</class-id><body>Bundle to sub-bundle.Instance Variables:	subBundleRef	&lt;Integer&gt;	sub-bundle's primaryKey</body></comment><class><name>Blob</name><environment>Store</environment><super>Store.DBObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>primaryKey blobType blobData </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-DB-BaseObjects</package></attributes></class><class><name>BinaryBlob</name><environment>Store</environment><super>Store.Blob</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-DB-BaseObjects</package></attributes></class><comment><class-id>Store.BinaryBlob</class-id><body>BinaryBlob has no methods .... it exists to separate binary package store for easier clean up. And to keep the main file size down.</body></comment><class><name>SubdefView</name><environment>Store</environment><super>Store.ViewRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>className packageRef sourceCodeID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Subdefs</category><attributes><package>Store-DB-Subdefs</package></attributes></class><class><name>MethodsView</name><environment>Store</environment><super>Store.SubdefView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>protocolName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Subdefs</category><attributes><package>Store-DB-Subdefs</package></attributes></class><class><name>MethodsAndSourcesView</name><environment>Store</environment><super>Store.MethodsView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blobData blobType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Subdefs</category><attributes><package>Store-DB-Subdefs</package></attributes></class><comment><class-id>Store.MethodsAndSourcesView</class-id><body>Extends MethodsView to include sources, by linking the definitonID to the definition table.Instance Variables:	blobData	&lt;ByteArray&gt;  class definition raw data	blobType	&lt;Integer&gt;  	  postive number is blobData type, negative number is link to next chunk.Shared Variables:	MethodsWithSourcesSession	&lt;ExternalDatabaseSession&gt;  cached session with * query</body></comment><class><name>Packages</name><environment>Store</environment><super>Store.BundlePart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packageRef </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Pundles</category><attributes><package>Store-DB-Pundles</package></attributes></class><comment><class-id>Store.Packages</class-id><body>Bundle to Package.Instance Variables:	packageRef	&lt;Integer&gt;	package's primaryKey</body></comment><class><name>DataView</name><environment>Store</environment><super>Store.ViewRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packageRef definitionID commentID environmentString protocolName typeString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Subdefs</category><attributes><package>Store-DB-Subdefs</package></attributes></class><class><name>DataAndSourcesView</name><environment>Store</environment><super>Store.DataView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blobData blobType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Subdefs</category><attributes><package>Store-DB-Subdefs</package></attributes></class><comment><class-id>Store.DataAndSourcesView</class-id><body>Extends DataView to include sources, by linking the definitonID to the definition table.Instance Variables:	blobData	&lt;ByteArray&gt;  class definition raw data	blobType	&lt;Integer&gt;  	  postive number is blobData type, negative number is link to next chunk.Shared Variables:	DataWithSourcesSession	&lt;ExternalDatabaseSession&gt;  cached session with * query</body></comment><class><name>PkgClassesAndSourcesView</name><environment>Store</environment><super>Store.PkgClassesView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blobData blobType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Records</category><attributes><package>Store-DB-Records</package></attributes></class><comment><class-id>Store.PkgClassesAndSourcesView</class-id><body>Extends PkgClassesView to include sources, by linking the definitonID to the definition table.Instance Variables:	blobData	&lt;ByteArray&gt;  class definition raw data	blobType	&lt;Integer&gt;  	  postive number is blobData type, negative number is link to next chunk.Shared Variables:	ClassesWithSourcesSession	&lt;ExternalDatabaseSession&gt;  cached session with * query</body></comment><class><name>VersionNode</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent package children level </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Merge</category><attributes><package>Store-Merge</package></attributes></class><comment><class-id>Store.VersionNode</class-id><body>Missing comment</body></comment><class><name>BasicPrerequisitePolicy</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>searchOrder versionSelection blessingLevel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-User Management</category><attributes><package>Store-User Management</package></attributes></class><comment><class-id>Store.BasicPrerequisitePolicy</class-id><body>The policies for resolving which development prerequisite to load.Instance Variables:	searchOrder			&lt;Symbol&gt; #parcelsFirst or #pundlesFirst.  Flag to determine whether to first meet the							development prerequisite with a parcel or a bundle, when the prerequisite type is #any.	versionSelection		&lt;Symbol&gt;	#ask or #latest.  Flag to determine whether to ask the user, or use the latest							version with at least a blessing level of blessingLevel.	blessingLevel		&lt;Integer&gt;	The blessing level used if #latest is the versionSelection criteria</body></comment><class><name>ConnectionProfile</name><environment>Store</environment><super>Database.ConnectionProfile</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tableOwner </inst-vars><class-inst-vars></class-inst-vars><imports>			private XML.Element			private XML.Attribute			</imports><category>Store-DB-BaseObjects</category><attributes><package>Store-DB-BaseObjects</package></attributes></class><comment><class-id>Store.ConnectionProfile</class-id><body>Extends the base ConnectionProfile to include the Store database owner.Instance Variables:	tableOwner	&lt;String&gt;	the Store installation db owner name.</body></comment><class><name>StoreRepositoryListSetting</name><environment>Tools</environment><super>Tools.GenericSettingDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>profiles </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.RepositoryManager			private Store.ConnectionProfile			</imports><category>Tools-Settings-VW</category><attributes><package>Store-UI</package></attributes></class><class><name>BundlePrivilegeGraph</name><environment>Store</environment><super>Store.PrivilegeGraph</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Graphs</category><attributes><package>Store-UI-Graphs</package></attributes></class><comment><class-id>Store.BundlePrivilegeGraph</class-id><body>BundlePrivilegeGraph allows the image administrator to grant or revoke ownership to Bundles.</body></comment><class><name>PackageVersionBrowserHelper</name><environment>Store</environment><super>Store.PackageBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Browser</category><attributes><package>Store-UI-Browser</package></attributes></class><class><name>UnloadableExeceptionBrowserHelper</name><environment>Store</environment><super>Tools.BrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Browser</category><attributes><package>Store-UI-Browser</package></attributes></class><comment><class-id>Store.UnloadableExeceptionBrowserHelper</class-id><body>BrowserHelper for UnloadableDefinitionErrors. </body></comment><class><name>ParcelRecord</name><environment>Store</environment><super>Store.Record</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundleID blobID sourceID filename blobData sourceData pundle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Pundles</category><attributes><package>Store-DB-Pundles</package></attributes></class><class><name>VersionGraph</name><environment>Store</environment><super>Store.GraphTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Graphs</category><attributes><package>Store-UI-Graphs</package></attributes></class><class><name>PackageMethodsVersionBrowserHelper</name><environment>Store</environment><super>Store.PackageMethodListBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Browser</category><attributes><package>Store-UI-Browser</package></attributes></class><class><name>ComparisonBrowser</name><environment>Store</environment><super>Tools.TabApplicationSystemBrowser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text2 comparisonType differencesType invisibleId invisibleAttributes menuBarMenu </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Browser</category><attributes><package>Store-UI-Comparitors</package></attributes></class><class><name>BasicVersionPolicy</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-User Management</category><attributes><package>Store-User Management</package></attributes></class><comment><class-id>Store.BasicVersionPolicy</class-id><body>Missing comment</body></comment><class><name>BranchingVersionPolicy</name><environment>Store</environment><super>Store.BasicVersionPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-User Management</category><attributes><package>Store-User Management</package></attributes></class><class><name>MiniRepositoryManager</name><environment>Store</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>labelHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.MiniRepositoryManager</class-id><body>MiniRepositoryManager is the application model of the tiny one-line application intended for the launcher's status bar. It displays information about the current Store connection, allows to connect and disconnect, and do basic connection information management.Instance Variables:	labelHolder	&lt;ValueHolder with: String&gt;	ValueHolder with the current text displayed by the application.</body></comment><class><name>PundleComponent</name><environment>Store</environment><super>Store.AbstractTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundleModule listUpdateBlock updateInterests popupMenu cachedPundles </inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			</imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.PundleComponent</class-id><body>PundleComponent is used by PublishedPundlesTool and PundlesTool to display a list of pundles.  In the case of PublishedPundlesTool, it will display a list of Pundles that are in the database.  In the case of the PundlesTool, the list will be of loaded Pundles.Instance Variables:	cachedPundles	&lt;List of: (BundleModel|PackageModel|Bundle|Package)&gt;	Pundles last read from the database are cached to avoid re-querying when filtering the list of pundles	listUpdateBlock	&lt;BlockClosure&gt;		The block to be used to recompute what pundles are contained in the list	popupMenu	&lt;Menu&gt;		pundleModule	&lt;IncrementalSearchModule&gt;	 The tools module that provides the ability to filter the list of pundles	updateInterests	&lt;Array of: Symbol&gt;	The list of notification interests (change updates) this client is interested in, these are sent by </body></comment><class><name>BasicBlessingPolicy</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blessings defaultBlessing </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-User Management</category><attributes><package>Store-User Management</package></attributes></class><comment><class-id>Store.BasicBlessingPolicy</class-id><body>Defines the available blessing levels and the default blessing level. Provides a menu of blessings ease of use in dialogs.Instance Variables:	blessings	&lt;IdentityDictionary&gt;	maps symbol to BlessingLevel	defaultBlessing	&lt;BlessingLevel&gt; the default blessing for dialogs</body></comment><class><name>OwnerBlessingPolicy</name><environment>Store</environment><super>Store.BasicBlessingPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Ownership</category><attributes><package>Store-Ownership</package></attributes></class><class><name>EnvyStyleBlessingPolicy</name><environment>Store</environment><super>Store.OwnerBlessingPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Ownership</category><attributes><package>Store-Ownership</package></attributes></class><class><name>TEMPORARYOwnerBlessingPolicy</name><environment>Store</environment><super>Store.OwnerBlessingPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Ownership</category><attributes><package>Store-Ownership</package></attributes></class><class><name>UISettings</name><environment>Store</environment><super>UI.TabbedDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><class><name>PkgMetaclassesView</name><environment>Store</environment><super>Store.PkgClassesView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Records</category><attributes><package>Store-DB-Records</package></attributes></class><class><name>ChangeSetInspector</name><environment>Store</environment><super>Tools.DictionaryInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars>windowLabel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><class><name>NameSpaceLoader</name><environment>Store</environment><super>Store.Loader</super><private>false</private><indexed-type>none</indexed-type><inst-vars>namespace definition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><class><name>PundleLoadedChange</name><environment>Store</environment><super>Kernel.ComponentLoadedChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>databaseId primaryKey </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>Store-Change Management</package></attributes></class><comment><class-id>Store.PundleLoadedChange</class-id><body>Represents a package or bundle loaded event. Instance Variables:	databaseId  &lt;String&gt; - The database from which the pundle was loaded	primaryKey &lt;Integer&gt; - The primary key in the database that identifies the exact version.</body></comment><class><name>DefinitionBrowserApplication</name><environment>Store</environment><super>Store.BundleTabApplication</super><private>false</private><indexed-type>none</indexed-type><inst-vars>forcedList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Browser</category><attributes><package>Store-UI-Browser</package></attributes></class><class><name>PundleSavedChange</name><environment>Store</environment><super>Store.PundleLoadedChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>Store-Change Management</package></attributes></class><class><name>PackagesView</name><environment>Store</environment><super>Store.ViewRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>longField commentSize binFile bundleRef expression seqNumber </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Pundles</category><attributes><package>Store-DB-Pundles</package></attributes></class><class><name>BundleStructureTag</name><environment>Store</environment><super>Store.AbstractComponentTag</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><class><name>PundlesTool</name><environment>Store</environment><super>Store.AbstractWindowTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundleClientApp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><class><name>PublishedPundlesTool</name><environment>Store</environment><super>Store.PundlesTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>versionClientApp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.PublishedPundlesTool</class-id><body>PublishedPundlesTool is used to display a list of pundles that are published in the database.  When one of these pundles is selected (multi-selection is allowed), the versionClientApp (an instance of VersionBrowser) will display the list of versions for those selected pundles. Instance Variables:	versionClientApp	&lt;VersionBrowser&gt;	The object that knows how to display version and blessing comment history for selected pundles</body></comment><class><name>UnloadableExeceptionBrowserApplication</name><environment>Store</environment><super>Store.BundleTabApplication</super><private>false</private><indexed-type>none</indexed-type><inst-vars>exceptionList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Browser</category><attributes><package>Store-UI-Browser</package></attributes></class><comment><class-id>Store.UnloadableExeceptionBrowserApplication</class-id><body>Browser for displaying/editing UnloadableDefintionExceptions. This is triggered at the end package load. From here the user can load the definitions, remove them from the package or file them out.Instance Variables:	exceptionList	&lt;Colleciton of UnloadableDefinitionError&gt;	The list of exceptions being displayed.</body></comment><class><name>PundleHierarchyBrowserHelper</name><environment>Store</environment><super>Store.PackageBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Browser</category><attributes><package>Store-UI-Browser</package></attributes></class><class><name>PublishPundleDialog</name><environment>Store</environment><super>UI.TabbedDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>items blessingLevel blessingComment publish versionString binarySave parcelSave bundleStructure databaseLinks parcelDirectory parcelSaveSource parcelHideSource parcelPadded parcelRepublish parcelBackup parcelOverwrite parcelWarningMessage labelDict offsets callBackBlock retry files publishFile </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.PublishPundleDialog</class-id><body>Tabbed dialog for all publishing options.Instance Variables:	items	&lt;SelectionInList&gt; a collection of user data for each pundle		blessingLevel	&lt;ValueHolder&gt;	current item's blessing level	blessingComment	&lt;ValueHolder &lt;String&gt;	current item's comment	publish	&lt;ValueHolder &lt;Boolean&gt;&gt;	indicates if current selection is to be published	versionString	&lt;ValueHolder &lt;String&gt;&gt;	current item's version string.	binarySave	&lt;ValueHolder &lt;Boolean&gt;&gt; true if to also publish binary	parcelSave	&lt;ValueHolder &lt;Boolean&gt;&gt; true if to also publish as a parcel	bundleStructure	&lt;ValueHolder &lt;Boolean&gt;&gt; if true, save bundle structure in parcel.	databaseLinks	&lt;ValueHolder &lt;Boolean&gt;&gt; if true, save links to current db in parcel.	parcelDirectory	&lt;ValueHolder &lt;Filename&gt;&gt;	directory for parcel	parcelSaveSource	&lt;ValueHolder &lt;Boolean&gt;&gt; flag for parcels.	parcelHideSource	&lt;ValueHolder &lt;Boolean&gt;&gt; flag for parcels	parcelPadded	&lt;ValueHolder &lt;Boolean&gt;&gt; flag for parcels	parcelRepublish	&lt;ValueHolder &lt;Boolean&gt;&gt; flag for parcels	parcelBackup	&lt;ValueHolder &lt;Boolean&gt;&gt; flag for parcels	parcelOverwrite	&lt;ValueHolder &lt;Boolean&gt;&gt; flag for parcels	parcelWarningMessage	&lt;ValueHolder &lt;String&gt;&gt;	message that explains why a parcel cannot be published.	labelDict &lt;Dictionary&gt; Cache of item labels.	offsets	&lt;Array&gt;	 Cache of label offsets	callBackBlock &lt;OneArgumentBlock&gt; Block for post-processing after publish.	retry &lt;Boolean&gt; Flag that indicates wheter to close the dialog, or retry if publish was canceled.</body></comment><class><name>PublishFragmentDialog</name><environment>Store</environment><super>Store.PublishPundleDialog</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><class><name>PublishPackageDialog</name><environment>Store</environment><super>Store.PublishPundleDialog</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>package </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><class><name>BlessingDialog</name><environment>Store</environment><super>Store.PublishPundleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dialog </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.BlessingDialog</class-id><body>BlessingDialog is used by other Store tools to reset the blessing level for a package or a bundle.    The class side method protocol, #'interface opening' contains the protocol to invoke the dialog.    If the blessing is to be reset on a package, then BlessingDialog will instead open up a CommentPrompt dialog (see the class side method #setBlessingForPackage:).    If the blessing is to be reset on a bundle, then BlessingDialog is opened up as a SimpleDialog.Instance Variables:	dialog	&lt;SimpleDialog&gt;	The instance that provides the dialog behavior</body></comment><class><name>DatabaseMessageBox</name><environment>Store</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>errorMessage titleString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Database</category><attributes><package>Store-Database</package></attributes></class><class><name>RepositoryPropertiesDialog</name><environment>Store</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>profileHolder acceptTrigger databaseListHolder databaseHolder environmentHolder userNameHolder passwordHolder tableOwnerHolder nameHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-BaseObjects</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.RepositoryPropertiesDialog</class-id><body>RepositoryPropertiesDialog is used by RepositoryManager and MiniRepositoryManager to edit properties of individual Store connections.Most of the instance variables hold aspects of the dialog's widgets. The aspects are buffered value holders on aspect adaptors on the contents of 'profileHolder' variable.Instance Variables:	acceptTrigger	&lt;ValueHolder with: Boolean&gt;	Trigger channel of the buffered value	databaseHolder	&lt;BufferedValueHolder&gt;	databaseListHolder	&lt;List&gt;	environmentHolder	&lt;BufferedValueHolder&gt;	nameHolder	&lt;BufferedValueHolder&gt;	passwordHolder	&lt;BufferedValueHolder&gt;	profileHolder	&lt;ValueHolder&gt; Holds the profile whose properties are being edited.	tableOwnerHolder	&lt;BufferedValueHolder&gt;	userNameHolder	&lt;BufferedValueHolder&gt;</body></comment><class><name>StoreRepositoryListPage</name><environment>Tools</environment><super>Tools.SettingsManagerPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>setting repositoryManager repositoryListHolder repositoryHolder </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.RepositoryPropertiesDialog			private Store.ConnectionProfile			</imports><category>Tools-Settings-VW</category><attributes><package>Store-UI</package></attributes></class><class><name>DBPundlePrivileges</name><environment>Store</environment><super>Store.DBObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundleName pundleType userName userType privilege </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Ownership</category><attributes><package>Store-Ownership</package></attributes></class><class><name>PundleGraph</name><environment>Store</environment><super>Store.GraphTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>toolType menuBarHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Graphs</category><attributes><package>Store-UI-Graphs</package></attributes></class><class><name>DataElement</name><environment>Store</environment><super>Store.DefinedRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>protocolName typeString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Subdefs</category><attributes><package>Store-DB-Subdefs</package></attributes></class><class><name>RepublishBundleDialog</name><environment>Store</environment><super>Store.PublishPundleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Store-UI</package></attributes></class><comment><class-id>Store.RepublishBundleDialog</class-id><body>RepublishBundleDialog allows a user to modify a Bundle's properties or its contents and republish without having to first load the bundle.  </body></comment><class><name>ModificationSet</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tag mods duplicateMods preMoveMods initial resolution applied </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Merge</category><attributes><package>Store-Merge</package></attributes></class><class><name>PackageChanges</name><environment>Store</environment><super>Store.PundleChanges</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Change Management</category><attributes><package>Store-Change Management</package></attributes></class><comment><class-id>Store.PackageChanges</class-id><body>A PackageChanges computes the changes between two packages where one may be an image version..</body></comment><class><name>ClassViewTabApplication</name><environment>Store</environment><super>Store.BundleTabApplication</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI-Browser</category><attributes><package>Store-UI-Browser</package></attributes></class><shared-variable><name>PropertiesSession</name><environment>Store.PropertiesView</environment><private>false</private><constant>false</constant><category>sessions</category><attributes><package>Store-DB-Records</package></attributes></shared-variable><shared-variable><name>NameSpacesSession</name><environment>Store.PkgNameSpacesView</environment><private>false</private><constant>false</constant><category>sessions</category><attributes><package>Store-DB-Records</package></attributes></shared-variable><shared-variable><name>Repositories</name><environment>Store.RepositoryManager</environment><private>false</private><constant>false</constant><category>repository profiles</category><initializer>List new</initializer><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>LegalPublishingProperties</name><environment>Store.Pundle</environment><private>false</private><constant>false</constant><category>settings</category><initializer>#(#bossAndTable #tableOnly #bossOnly )</initializer><attributes><package>Store-DB-Pundles</package></attributes></shared-variable><shared-variable><name>ComponentNotFoundSignal</name><environment>Store.Pundle</environment><private>false</private><constant>false</constant><category>signals</category><attributes><package>Store-DB-Pundles</package></attributes></shared-variable><shared-variable><name>PropertiesPublishingPolicy</name><environment>Store.Pundle</environment><private>false</private><constant>false</constant><category>settings</category><initializer>#bossAndTable</initializer><attributes><package>Store-DB-Pundles</package></attributes></shared-variable><shared-variable><name>NameSpacesWithSourcesSession</name><environment>Store.PkgNameSpacesAndSourcesView</environment><private>false</private><constant>false</constant><category>session</category><attributes><package>Store-DB-Records</package></attributes></shared-variable><shared-variable><name>WriteSession</name><environment>Store.Blob</environment><private>false</private><constant>false</constant><category>sessions</category><attributes><package>Store-DB-BaseObjects</package></attributes></shared-variable><shared-variable><name>DefinitionSession</name><environment>Store.Blob</environment><private>false</private><constant>false</constant><category>sessions</category><attributes><package>Store-DB-BaseObjects</package></attributes></shared-variable><shared-variable><name>Session</name><environment>Store.DBObject</environment><private>false</private><constant>false</constant><category>sessions</category><attributes><package>Store-DB-BaseObjects</package></attributes></shared-variable><shared-variable><name>MethodInClassSession</name><environment>Store.MethodsView</environment><private>false</private><constant>false</constant><category>sessions</category><attributes><package>Store-DB-Subdefs</package></attributes></shared-variable><shared-variable><name>MethodsSession</name><environment>Store.MethodsView</environment><private>false</private><constant>false</constant><category>sessions</category><attributes><package>Store-DB-Subdefs</package></attributes></shared-variable><shared-variable><name>EmptyInArrow</name><environment>Store.ElementView</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Store-UI-Graphs</package></attributes></shared-variable><shared-variable><name>FullOutArrow</name><environment>Store.ElementView</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Store-UI-Graphs</package></attributes></shared-variable><shared-variable><name>FullInArrow</name><environment>Store.ElementView</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Store-UI-Graphs</package></attributes></shared-variable><shared-variable><name>EmptyOutArrow</name><environment>Store.ElementView</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Store-UI-Graphs</package></attributes></shared-variable><shared-variable><name>BundleSession</name><environment>Store.BundlesView</environment><private>false</private><constant>false</constant><category>sessions</category><attributes><package>Store-DB-Pundles</package></attributes></shared-variable><shared-variable><name>SortBlock</name><environment>Store.PackageProtocolBrowserHelper</environment><private>false</private><constant>false</constant><category>sorting</category><attributes><package>Store-UI-Browser</package></attributes></shared-variable><shared-variable><name>PackageSession</name><environment>Store.PackagesView</environment><private>false</private><constant>false</constant><category>sessions</category><attributes><package>Store-DB-Pundles</package></attributes></shared-variable><shared-variable><name>DataKeySession</name><environment>Store.DataView</environment><private>false</private><constant>false</constant><category>sessions</category><attributes><package>Store-DB-Subdefs</package></attributes></shared-variable><shared-variable><name>DataSession</name><environment>Store.DataView</environment><private>false</private><constant>false</constant><category>sessions</category><attributes><package>Store-DB-Subdefs</package></attributes></shared-variable><shared-variable><name>DbRegistry</name><environment>Store</environment><private>false</private><constant>false</constant><category>Store-Base</category><attributes><package>Store-Base</package></attributes></shared-variable><shared-variable><name>MetaclassesSession</name><environment>Store.PkgMetaclassesView</environment><private>false</private><constant>false</constant><category>sessions</category><attributes><package>Store-DB-Records</package></attributes></shared-variable><shared-variable><name>UserPreferences</name><environment>Store.UISettings</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>DataWithSourcesSession</name><environment>Store.DataAndSourcesView</environment><private>false</private><constant>false</constant><category>session</category><attributes><package>Store-DB-Subdefs</package></attributes></shared-variable><shared-variable><name>PundleTypes</name><environment>Store.PundleParent</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Store-IMG-Pundles</package></attributes></shared-variable><shared-variable><name>PundleMap</name><environment>Store.PundleParent</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Store-IMG-Pundles</package></attributes></shared-variable><shared-variable><name>ClassesWithSourcesSession</name><environment>Store.PkgClassesAndSourcesView</environment><private>false</private><constant>false</constant><category>session</category><attributes><package>Store-DB-Records</package></attributes></shared-variable><shared-variable><name>WriteSession</name><environment>Store.BinaryBlob</environment><private>false</private><constant>false</constant><category>sessions</category><attributes><package>Store-DB-BaseObjects</package></attributes></shared-variable><shared-variable><name>DefinitionSession</name><environment>Store.BinaryBlob</environment><private>false</private><constant>false</constant><category>sessions</category><attributes><package>Store-DB-BaseObjects</package></attributes></shared-variable><shared-variable><name>CannotStoreComponentSignal</name><environment>Store.ComponentDescription</environment><private>false</private><constant>false</constant><category>signals</category><attributes><package>Store-IMG-Pundles</package></attributes></shared-variable><shared-variable><name>CannotLoadComponentSignal</name><environment>Store.ComponentDescription</environment><private>false</private><constant>false</constant><category>signals</category><attributes><package>Store-IMG-Pundles</package></attributes></shared-variable><shared-variable><name>CannotUnloadComponentSignal</name><environment>Store.ComponentDescription</environment><private>false</private><constant>false</constant><category>signals</category><attributes><package>Store-IMG-Pundles</package></attributes></shared-variable><shared-variable><name>ModifiedPackageImage</name><environment>Store.AbstractTool</environment><private>false</private><constant>false</constant><category>images</category><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>IsMonocrome</name><environment>Store.AbstractTool</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>ModifiedNonCodePackageImage</name><environment>Store.AbstractTool</environment><private>false</private><constant>false</constant><category>images</category><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>DbBundleImage</name><environment>Store.AbstractTool</environment><private>false</private><constant>false</constant><category>images</category><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>DbNonCodePackageImage</name><environment>Store.AbstractTool</environment><private>false</private><constant>false</constant><category>images</category><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>UnmodifiedBundleImage</name><environment>Store.AbstractTool</environment><private>false</private><constant>false</constant><category>images</category><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>UnmodifiedPackageImage</name><environment>Store.AbstractTool</environment><private>false</private><constant>false</constant><category>images</category><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>DbPackageImage</name><environment>Store.AbstractTool</environment><private>false</private><constant>false</constant><category>images</category><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>UnmodifiedNonCodePackageImage</name><environment>Store.AbstractTool</environment><private>false</private><constant>false</constant><category>images</category><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>ModifiedBundleImage</name><environment>Store.AbstractTool</environment><private>false</private><constant>false</constant><category>images</category><attributes><package>Store-UI</package></attributes></shared-variable><shared-variable><name>ClassesSession</name><environment>Store.PkgClassesView</environment><private>false</private><constant>false</constant><category>sessions</category><attributes><package>Store-DB-Records</package></attributes></shared-variable><shared-variable><name>NoCommonAncestorSignal</name><environment>Store.MergeTool</environment><private>false</private><constant>false</constant><category>signals</category><attributes><package>Store-Merge</package></attributes></shared-variable><shared-variable><name>NoLoadedVersionSignal</name><environment>Store.MergeTool</environment><private>false</private><constant>false</constant><category>signals</category><attributes><package>Store-Merge</package></attributes></shared-variable><shared-variable><name>MethodsWithSourcesSession</name><environment>Store.MethodsAndSourcesView</environment><private>false</private><constant>false</constant><category>session</category><attributes><package>Store-DB-Subdefs</package></attributes></shared-variable><methods><class-id>Store.MoveModification</class-id> <category>testing</category><body package="Store-Merge" selector="isMoveModification">isMoveModification		^true</body><body package="Store-Merge" selector="isPublishedModification">isPublishedModification		^mod isPublishedModification</body><body package="Store-Merge" selector="isTextModification">isTextModification		^mod isTextModification</body></methods><methods><class-id>Store.MoveModification</class-id> <category>comparing</category><body package="Store-Merge" selector="=">= aMod 	^(aMod notNil and: [aMod isMoveModification])		ifTrue: [aMod desiredPackageName = self desiredPackageName and: [aMod modification = self modification]]		ifFalse: [false]</body></methods><methods><class-id>Store.MoveModification</class-id> <category>accessing</category><body package="Store-Merge" selector="description">description	^mod description, ' [in ' , packageName, ']'</body><body package="Store-Merge" selector="desiredPackageName">desiredPackageName	^packageName</body><body package="Store-Merge" selector="existsInPackage">existsInPackage	^mod existsInPackage</body><body package="Store-Merge" selector="key">key	^mod key</body><body package="Store-Merge" selector="modification">modification	^mod</body><body package="Store-Merge" selector="modification:packageName:">modification: aMod packageName: aPkgName	mod := aMod.	packageName := aPkgName.</body><body package="Store-Merge" selector="package">package	^mod package</body><body package="Store-Merge" selector="packageName">packageName	^mod packageName</body><body package="Store-Merge" selector="record">record 	^mod record</body><body package="Store-Merge" selector="source">source	^mod source</body><body package="Store-Merge" selector="tag">tag	^mod tag</body><body package="Store-Merge" selector="timeStampString">timeStampString	^mod timeStampString</body></methods><methods><class-id>Store.MoveModification</class-id> <category>printing</category><body package="Store-Merge" selector="printOn:">printOn: aStream	"Print tag first and then package."	aStream nextPutAll: '&lt;Move '.	mod notNil ifTrue: [mod printOn: aStream].	aStream nextPutAll: ' to '.	packageName printOn: aStream.	aStream nextPut: $&gt;</body></methods><methods><class-id>Store.MoveModification</class-id> <category>actions</category><body package="Store-Merge" selector="apply">apply	| result |	result := mod apply.	result		ifTrue: 			[| destPkg |			destPkg := Registry packageNamed: packageName.			destPkg isNil				ifTrue: 					["Create a package."					self error: 'Package ', packageName, ' missing from image - should not occur'.					destPkg := PackageModel named: packageName.					"destPkg trace: ???"].			self tag moveToPackage: destPkg].	^result</body></methods><methods><class-id>Store.FileModel</class-id> <category>testing</category><body package="Store-IMG-Configurations" selector="isBundle">isBundle	^false.</body><body package="Store-IMG-Configurations" selector="isForFile">isForFile	^true</body></methods><methods><class-id>Store.FileModel</class-id> <category>accessing</category><body package="Store-IMG-Configurations" selector="asDBDescription">asDBDescription	^self class partClass new		fileRef: self primaryKey;		"??"		bundleRef: bundle primaryKey;		yourself</body><body package="Store-IMG-Configurations" selector="bundle">bundle	^bundle</body><body package="Store-IMG-Configurations" selector="bundle:">bundle: ourBundle	bundle := ourBundle</body><body package="Store-IMG-Configurations" selector="classOfDbRecord">classOfDbRecord	"Answer a class which is used to represent this component type in the database."	^FileRecord</body><body package="Store-IMG-Configurations" selector="component">component	"Find a component named componentName and answer it."	^self</body><body package="Store-IMG-Configurations" selector="dbTrace">dbTrace	^dbtrace</body><body package="Store-IMG-Configurations" selector="dbTrace:">dbTrace: anIneger	dbtrace := anIneger</body><body package="Store-IMG-Configurations" selector="filename">filename	^name == nil		ifTrue: [ nil ]		ifFalse: [ LogicalFilename named: name ].</body><body package="Store-IMG-Configurations" selector="itemCount">itemCount	^1</body><body package="Store-IMG-Configurations" selector="name">name	^portableFilename asString	"^name asString"</body><body package="Store-IMG-Configurations" selector="name:">name: aString	name := aString asFilename.</body><body package="Store-IMG-Configurations" selector="portableFilename">portableFilename	^portableFilename</body><body package="Store-IMG-Configurations" selector="portableFilename:">portableFilename: anObject	portableFilename := anObject</body><body package="Store-IMG-Configurations" selector="primaryKey">primaryKey	^dbtrace</body><body package="Store-IMG-Configurations" selector="textForItem">textForItem	^name</body></methods><methods><class-id>Store.FileModel</class-id> <category>printing</category><body package="Store-IMG-Configurations" selector="printOn:">printOn: aStream	aStream nextPutAll: self class name, '(', self portableFilename asString, ')'.</body></methods><methods><class-id>Store.FileModel class</class-id> <category>constants</category><body package="Store-IMG-Configurations" selector="partClass">partClass	^Files</body></methods><methods><class-id>Store.FileModel class</class-id> <category>instance creation</category><body package="Store-IMG-Configurations" selector="from:">from: aFilename	^super new		name: aFilename;		portableFilename: aFilename asLogicalFileSpecification;		yourself.</body></methods><methods><class-id>Store.CodeReaderForStore</class-id> <category>private</category><body package="Store-Base" selector="runPreRead">runPreRead	"Overridden to suppress the action."</body></methods><methods><class-id>Store.AbstractTool</class-id> <category>menu enabling</category><body package="Store-UI" selector="are2VersionsOfAPundleSelected">are2VersionsOfAPundleSelected	| pundles |	self isDBConnected ifFalse: [^false].	pundles := self pundleVersions.	pundles size = 2 ifFalse: [^false].	pundles first isPackage = pundles last isPackage ifFalse: [^false].	pundles first name = pundles last name ifFalse: [^false].	^true</body><body package="Store-UI" selector="areBundlesSelected">areBundlesSelected	| pundles |	pundles := self pundleVersions.	pundles size &gt; 0 ifFalse: [^false].	pundles		do: 			[:pun | 			pun isBundle ifFalse: [^false].			(pun isLoaded or: [self isDBConnected])				ifFalse: [^false]].	^true</body><body package="Store-UI" selector="areDBPundlesSelected">areDBPundlesSelected	| pundles |	self isDBConnected ifFalse: [^false].	pundles := self pundleVersions.	pundles size &gt; 0 ifFalse: [^false].	pundles do: [:pun | pun isLoaded ifTrue: [^false]].	^true</body><body package="Store-UI" selector="areDBPundlesSelectedAndSomeVersionIsLoaded">areDBPundlesSelectedAndSomeVersionIsLoaded	| pundles |	self isDBConnected ifFalse: [^false].	pundles := self pundleVersions.	pundles size &gt; 0 ifFalse: [^false].	pundles		do: 			[:pun | 			pun isLoaded ifTrue: [^false].			((pun isPackage and: [Registry isPackageLoaded: pun name]) 					or: [pun isBundle and: [Registry isBundleLoaded: pun name]])				ifFalse: [^false]].	^true</body><body package="Store-UI" selector="areLoadedBundlesSelected">areLoadedBundlesSelected	| pundles |	pundles := self pundleVersions.	pundles size &gt; 0 ifFalse: [^false].	pundles		do: 			[:pun | 			pun isBundle ifFalse: [^false].			pun isLoaded ifFalse: [^false]].	^true</body><body package="Store-UI" selector="areLoadedPundlesSelected">areLoadedPundlesSelected	| pundles |	pundles := self pundleVersions.	pundles size &gt; 0 ifFalse: [^false].	pundles		do: 			[:pun | 			pun isLoaded ifFalse: [^false]].	^true</body><body package="Store-UI" selector="arePackagesSelected">arePackagesSelected	| pundles |	pundles := self pundleVersions.	pundles size &gt; 0 ifFalse: [^false].	pundles		do: 			[:pun | 			pun isPackage ifFalse: [^false].			(pun isLoaded or: [self isDBConnected])				ifFalse: [^false]].	^true</body><body package="Store-UI" selector="arePundlesSelected">arePundlesSelected	| pundles |	pundles := self pundleVersions.	pundles size &gt; 0 ifFalse: [^false].	pundles		do: 			[:pun | 			(pun isLoaded or: [self isDBConnected])				ifFalse: [^false]].	^true</body><body package="Store-UI" selector="areVersionableObjectsSelected">areVersionableObjectsSelected	self isDBConnected ifFalse: [^false].	^self pundles size &gt; 0</body><body package="Store-UI" selector="isDBConnected">isDBConnected	^DbRegistry isOnline</body><body package="Store-UI" selector="isImageAdministrator">isImageAdministrator	"Added by Philippe F. Monnet of Andersen Consulting"			^Policies ownershipPolicy isImageAdministrator</body><body package="Store-UI" selector="isLoadedPackageSelected">isLoadedPackageSelected	| pundles pun |	pundles := self pundleVersions.	pundles size = 1 ifFalse: [^false].	pun := pundles first.	pun isPackage ifFalse: [^false].	pun isLoaded ifFalse: [^false].	^true</body><body package="Store-UI" selector="isLoadedPundleSelected">isLoadedPundleSelected	| pundles |	pundles := self pundleVersions.	pundles size = 1 ifFalse: [ ^false ].	^pundles contains: [ :pun | pun isLoaded not ].</body><body package="Store-UI" selector="makePundleMenuDynamic:">makePundleMenuDynamic: menu 	"Add dynamic features to the menu. ALPHA ORDER" 	self makeDynamicItem: #browsePackageVersion selectionBlock: [self arePundlesSelected] inMenu: menu.	self makeDynamicItem: #browseVersions selectionBlock: [self areVersionableObjectsSelected] inMenu: menu.	self makeDynamicItem: #createAsParcel selectionBlock: [self areLoadedPundlesSelected] inMenu: menu.	self makeDynamicItem: #enclosingBundles selectionBlock: [self areLoadedPundlesSelected] inMenu: menu.	self makeDynamicItem: #deletePundle selectionBlock: [self areLoadedPundlesSelected] inMenu: menu.	self makeDynamicItem: #diffPundleWithImage selectionBlock: [self areDBPundlesSelectedAndSomeVersionIsLoaded] inMenu: menu.	self makeDynamicItem: #diffPundleWithParent selectionBlock: [self arePundlesSelected] inMenu: menu.	self makeDynamicItem: #diffTwoPundles selectionBlock: [self are2VersionsOfAPundleSelected] inMenu: menu.	self makeDynamicItem: #editBundleSpecification selectionBlock: [self areLoadedBundlesSelected] inMenu: menu.	self makeDynamicItem: #fileOutChanges selectionBlock: [self areLoadedPundlesSelected] inMenu: menu.	self makeDynamicItem: #fileOutPundle selectionBlock: [self arePundlesSelected] inMenu: menu.	self makeDynamicItem: #fileOutTwoPundleDiff selectionBlock: [self are2VersionsOfAPundleSelected] inMenu: menu.	self makeDynamicItem: #graphPundleVersions selectionBlock: [self areVersionableObjectsSelected] inMenu: menu.	self makeDynamicItem: #inspectChangesInPundle selectionBlock: [self areLoadedPundlesSelected] inMenu: menu.	self makeDynamicItem: #listBundleContents selectionBlock: [self areBundlesSelected] inMenu: menu.	self makeDynamicItem: #republish selectionBlock: [self areBundlesSelected &amp; self areLoadedBundlesSelected not ] inMenu: menu.	self makeDynamicItem: #loadPundle selectionBlock: [self areDBPundlesSelected] inMenu: menu.	self makeDynamicItem: #makeCurrentPackage selectionBlock: [self isLoadedPackageSelected] inMenu: menu.	self makeDynamicItem: #mergePundleVersion selectionBlock: [self areDBPundlesSelected] inMenu: menu.	self makeDynamicItem: #methodsChangesInPundle selectionBlock: [self areLoadedPundlesSelected] inMenu: menu.	self makeDynamicItem: #reloadVersions selectionBlock: [self isDBConnected] inMenu: menu.	self makeDynamicItem: #renamePundle selectionBlock: [self areLoadedPundlesSelected] inMenu: menu.	self makeDynamicItem: #setBlessingLevel selectionBlock: [self areDBPundlesSelected] inMenu: menu.	self makeDynamicItem: #showBundleStructure selectionBlock: [self areBundlesSelected] inMenu: menu.	self makeDynamicItem: #storePundleInDB selectionBlock: [self areLoadedPundlesSelected and: [self isDBConnected]] inMenu: menu.	self makeDynamicItem: #reconcile selectionBlock: [self isLoadedPundleSelected] inMenu: menu.	^menu</body></methods><methods><class-id>Store.AbstractTool</class-id> <category>pundle actions</category><body package="Store-UI" selector="addBlessingForPundle:">addBlessingForPundle: aDBPundle 	"Add a new record describing blessing for package."	BlessingDialog setBlessingFor: aDBPundle.</body><body package="Store-UI" selector="browseVersions">browseVersions	self doIfOnlineImage: 		[ self pundles do: 			[ :pundle | TabApplicationSystemBrowser browseVersionsOfPundle: pundle ]		]</body><body package="Store-UI" selector="createAsParcel">createAsParcel	self pundles do:		[ :pundle | self createAsParcel: pundle ].</body><body package="Store-UI" selector="createAsParcel:">createAsParcel: aPundle	| name |	[ name == nil ] whileTrue:		[ name := Dialog					request: 'Parcel name:'					initialAnswer: aPundle name					onCancel: [ ^self ].		name isEmpty 			ifTrue: [ ^self ].		( Parcel parcelNamed: name ) == nil 			ifFalse: 				[ ( Dialog confirm: 'Parcel named "' , name , '" exists - overwrite it?' )					ifTrue: [ Parcel destroyParcelNamed: name ]					ifFalse: [ name := nil ].				]		].	aPundle asParcel: name.</body><body package="Store-UI" selector="deletePundle">deletePundle	| pundles | 	pundles := self pundles.	(Dialog confirm: 'Unload', (pundles inject: '' into: [:str :pun | str , ' ' , pun name]) , '?')		ifTrue: [pundles do: [:pun | pun unloadLogged: false ]]</body><body package="Store-UI" selector="diffPundleWithImage">diffPundleWithImage	self		doIfOnlineImage: 			[self packages				do: 					[:pkg | 					| imPkg |					imPkg := Registry packageNamed: pkg name.					imPkg isNil						ifTrue: [Dialog warn: 'Package ' , pkg name , ' is not currently loaded into the image.']						ifFalse: [self diffPundle: imPkg with: pkg]].			self bundles				do: 					[:bun | 					| imBun |					imBun := Registry bundleNamed: bun name.					imBun isNil						ifTrue: [Dialog warn: 'Bundle ' , bun name , ' is not currently loaded into the image.']						ifFalse: [self diffPundle: imBun with: bun]]]</body><body package="Store-UI" selector="diffPundleWithParent">diffPundleWithParent	( self packages, self bundles ) do: 		[ :pkg |  | trPkg |		( ( trPkg := pkg tracePackage ) == nil ) 			ifTrue: [ trPkg := pkg selectVersion ].		trPkg == nil			ifFalse: [ self diffPundle: pkg with: trPkg ].		].</body><body package="Store-UI" selector="diffTwoPundles">diffTwoPundles	| puns |	puns := self pundles.	puns size = 2 ifFalse: [^Dialog warn: 'Choose exactly two versions to compare'].	self doIfOnlineImage: [self diffPundle: puns first with: puns last]</body><body package="Store-UI" selector="enclosingBundles">enclosingBundles	| titleStream updateBlock puns |	titleStream := WriteStream on: String new.	(puns := self pundles copy)		do: 			[:pun | 			titleStream nextPutAll: pun itemString.			titleStream nextPut: Character space].	updateBlock := 			[| encl |			encl := List new.			puns do: [:pun | pun isLoaded ifTrue: [encl addAll: pun enclosingComponents]].			encl].	updateBlock value isEmpty ifTrue: [^Dialog warn: titleStream contents , 'has no enclosing bundles'].	titleStream nextPutAll: 'Enclosing Bundles'.	PundlesTool		openOnLoadedBlock: updateBlock		sendUpdatesFor: #(#all)		windowTitle: titleStream contents</body><body package="Store-UI" selector="fileOutChanges">fileOutChanges	| puns fileName strm |	puns := self pundles.	puns size = 0 ifTrue: [^self].	fileName := puns size = 1		ifTrue: 			[ | oldSeparator pun |			pun := puns first.			fileName := pun name asString , '.st'.			oldSeparator := (fileName includes: UnixFilename separator)					ifTrue: [UnixFilename separator]					ifFalse: [(fileName includes: PCFilename separator)								ifTrue: [PCFilename separator]								ifFalse: [(fileName includes: MacFilename separator)			 								ifTrue: [MacFilename separator]											ifFalse: [nil]]].			fileName replaceAll: oldSeparator with: Filename separator.			fileName copyWithout: Character space			]		ifFalse: ['changes.st'].	fileName := Dialog requestNewFileName: 'File out as file named' default: fileName.	fileName isEmpty ifTrue: [ ^self ].	strm := SourceCodeStream  write: fileName.	Cursor write showWhile: 		[ [ strm timeStamp.		puns do: [ :pun | pun fileOutChangesOn: strm ]		  ]  ensure: [ strm close ]		]</body><body package="Store-UI" selector="fileOutPundle">fileOutPundle	self pundles do: [:pun | pun fileOut]</body><body package="Store-UI" selector="fileOutTwoPundleDiff">fileOutTwoPundleDiff	| puns |	puns := self pundles.	puns size = 2 ifFalse: [^Dialog warn: 'Choose exactly two versions to compare'].	( puns first pundleChangesClass with: puns first with: puns last ) fileOutChangesFor: 1."	self doIfOnlineImage: [self fileOutPundleDiff: puns first with: puns last]"</body><body package="Store-UI" selector="graphPundleVersions">graphPundleVersions	self doIfOnlineImage: [		self pundles do: [:pundle |			VersionGraph browseVersionsOfPundle: pundle]]</body><body package="Store-UI" selector="inspectChangesInPundle">inspectChangesInPundle	self pundles do: [:pun | pun inspectChangeSet]</body><body package="Store-UI" selector="loadPundle">loadPundle	| msg imgPundle |	msg := '&lt;1s&gt; is not linked to the current database.&lt;n&gt;It cannot be loaded until it has been reconciled.&lt;n&gt;Do you want to do that now?'.	self pundles do: 		[ :pundle |		( ( imgPundle := pundle getImagePundle ) notNil			and: [ ( imgPundle allDatabases includes: pundle dbIdentifier ) not ] 		)			ifTrue: 				[ ( Dialog confirm: ( msg expandMacrosWith: pundle name ) )					ifTrue: [ imgPundle reconcileWithDb: pundle ]					ifFalse: [ ^self ].				]			ifFalse: 					[ ( Dialog confirm: 'Do you want to load ' , pundle itemString , ' ?' )					ifFalse: [ ^self ]				].		Transcript cr; show: 'Loading ' ,  pundle name , ' . . .'.		pundle loadSrcWithImgPundle: imgPundle.		self reloadVersions.		Transcript show: 'Done'; cr		]</body><body package="Store-UI" selector="mergePundleVersion">mergePundleVersion	self doIfOnlineImage: [MergeTool openOnPundles: self pundles]</body><body package="Store-UI" selector="methodsChangesInPundle">methodsChangesInPundle	"Spawn method changes list on pundle(s)."		self storeBrowseChanges: self defaultDbId</body><body package="Store-UI" selector="pundleDoubleClickAction">pundleDoubleClickAction	"Does something reasonable for browsing a pundle. Currently 	opens a package browser on a package and opens a bundle 	structure viewer on a bundle. 	After the capability to browse bundle contents is added, this 	should be modified to browse the bundle contents instead."	self arePackagesSelected ifTrue: [self browsePackageVersion].	self areBundlesSelected ifTrue: [self listBundleContents]</body><body package="Store-UI" selector="reconcile">reconcile	| puns dbVersion imgVersion |	puns := self pundles.	puns size == 1 		ifFalse: [ ^Dialog warn: 'Choose one version to reconcile.' ].	dbVersion := puns first.	( imgVersion := dbVersion getImagePundle ) == nil		ifTrue: [ ^Dialog warn: 'There is no image version to reconcile.' ].		imgVersion reconcileWithDbVersion: dbVersion</body><body package="Store-UI" selector="renamePundle">renamePundle"----  SOON TO BE DEFUNCT ------	self pundles		do: 			[:pundle | 			| pundleName |			pundleName := Dialog						request: 'Rename to what?'						initialAnswer: pundle name						onCancel: [nil].			pundleName size = 0 ifTrue: [^self].			[((self storageForPundle: pundle)				entryNamed: pundleName) notNil]				whileTrue: 					[pundleName := Dialog								request: pundleName , ' is already in use.\Enter another name.' withCRs								initialAnswer: pundleName								onCancel: [nil].					pundleName isEmpty ifTrue: [^self]].			pundle name: pundleName].	self updatePundleVersion-------------------------"</body><body package="Store-UI" selector="setBlessingLevel">setBlessingLevel	"Add blessing level to the selected package."	self			doIfOnlineImage: 				[self pundles do: [:pundle | self addBlessingForPundle: pundle].				self updatePundleVersion]</body><body package="Store-UI" selector="setTrace">setTrace	self pundles do: 		[ :pundle | 		(Dialog confirm: 'Do you want to set the trace to ' , pundle itemString , ' ?')			ifTrue: 				[ | imPun |				imPun := pundle isPackage					ifTrue: [ Registry packageNamed: pundle name ]					ifFalse: [ Registry bundleNamed: pundle name ].				imPun isNil 					ifTrue: 						[ ^Dialog warn: 'No version of ' , pundle name , ' 							is loaded in the image.'						].				imPun dbTrace: pundle primaryKey.				]		]</body><body package="Store-UI" selector="storePundleInDB">storePundleInDB	self doIfOnlineImage: [Cursor wait showWhile: [self pundles do: [:pundle | pundle storeInDB]]]</body><body package="Store-UI" selector="updatePundleVersion">updatePundleVersion	"No-op unless over-ridden"</body></methods><methods><class-id>Store.AbstractTool</class-id> <category>selection</category><body package="Store-UI" selector="bundles">bundles	^self pundles select: [:aPundle | aPundle isBundle].</body><body package="Store-UI" selector="packages">packages	^self pundles select: [:aPundle | aPundle isPackage].</body><body package="Store-UI" selector="pundles">pundles	self subclassResponsibility</body><body package="Store-UI" selector="pundleVersions">pundleVersions	self subclassResponsibility</body></methods><methods><class-id>Store.AbstractTool</class-id> <category>bundle actions</category><body package="Store-UI" selector="addBundle">addBundle	BundleSpecEditor open</body><body package="Store-UI" selector="editBundleSpecification">editBundleSpecification	self bundles do: [:aBundle | BundleSpecEditor openOnBundle: aBundle]</body><body package="Store-UI" selector="listBundleContents">listBundleContents	| loaded titleStream buns updateBlock |	InputState default ctrlDown			ifTrue: [^self bundles first inspect].	titleStream := WriteStream on: String new.	loaded := false.	(buns := self bundles copy)		do: 			[:bun | 			bun isLoaded ifTrue: [loaded := true].			titleStream nextPutAll: bun itemString.			titleStream nextPut: Character space].	updateBlock := 			[| cont |			cont := List new.			buns				do: 					[:bun | 					cont addAll: bun containedItems].			cont].	updateBlock value isEmpty ifTrue: [^Dialog warn: titleStream contents , 'is empty'].	titleStream nextPutAll: 'Contents'.	loaded		ifTrue: [PundlesTool				openOnLoadedBlock: updateBlock				sendUpdatesFor: #(#changedBundleStructure #pundleModificationStatus #pundleTrace)				windowTitle: titleStream contents]		ifFalse: [PundlesTool				openOnPublishedBlock: updateBlock				sendUpdatesFor: #()				windowTitle: titleStream contents]</body><body package="Store-UI" selector="showBundleStructure">showBundleStructure	PundleGraph openBundleStructureViewOn: self bundles</body></methods><methods><class-id>Store.AbstractTool</class-id> <category>interface opening</category><body package="Store-UI" selector="shiftSelectInComponent:builder:">shiftSelectInComponent: aComponentSymbol builder: aBuilder	"Replace controller with one with more sanity."	| v mh cntrl dsp |  	v := (aBuilder componentAt: aComponentSymbol) widget.	cntrl := v controller.	mh :=  cntrl menuHolder.	dsp := cntrl dispatcher.		v setController: MultiSequenceController new.	(v controller) performer: self; menuHolder: mh; setDispatcher: dsp.	v controller keyboardProcessor: aBuilder keyboardProcessor.</body></methods><methods><class-id>Store.AbstractTool</class-id> <category>menus</category><body package="Store-UI" selector="menuBar">menuBar	"Add dynamic features to the menu bar."	| menu |	menu := self class menuBarSkeleton.	menu menuItems do: [:item | self makePundleMenuDynamic: item submenu].	^menu</body></methods><methods><class-id>Store.AbstractTool</class-id> <category>private</category><body package="Store-UI" selector="diffPundle:with:">diffPundle: pun1 with: pun2 	pun1 isBundle		ifTrue: [BundleDifferenceBrowser compare: pun1 with: pun2]		ifFalse: [ComparisonBrowser comparePackage: pun1 toPackage: pun2]</body><body package="Store-UI" selector="doIfOnlineImage:">doIfOnlineImage: aBlock 	^DbRegistry doIfOnlineImage: aBlock</body><body package="Store-UI" selector="fileOutPackageDiff:with:into:">fileOutPackageDiff: pkg1 with: pkg2 into: aStream 	pkg1 isNil		ifTrue: [self error: 'Can not file out differences against missing package']		ifFalse: 			[pkg2 isNil				ifTrue: [pkg1 fileOutOn: aStream]				ifFalse: [Notice show: 'Comparing versions of package ' , pkg1 name , '.'						while: 							[| pkgDiffs |							pkgDiffs := PackageDifferences with: pkg1 with: pkg2.							pkgDiffs fileDiffsOn: aStream]].			aStream cr]</body><body package="Store-UI" selector="fileOutPundleDiff:with:">fileOutPundleDiff: pundle1 with: pundle2 	| fileName diffs what pun1 pun2 |	what := Dialog				choose: 'File out transition of ', pundle1 name printString, ' from'				labels: (Array						with: pundle2 versionString , ' to ' , pundle1 versionString						with: pundle1 versionString , ' to ' , pundle2 versionString						with: 'Cancel')				values: #(#ok #reverse #cancel)				default: #cancel.	what == #cancel ifTrue: [^nil].	what == #reverse		ifTrue: 			[pun1 := pundle2.			pun2 := pundle1]		ifFalse: 			[pun1 := pundle1.			pun2 := pundle2].	fileName := Dialog requestNewFileName: 'File differences out on' default: 'diff.st'.	fileName isEmpty ifTrue: [^nil].	pun1 isBundle		ifTrue: 			[diffs := self class compareBundle: pun1 with: pun2.			diffs do: [:pair | pair first isNil ifTrue: [^Dialog warn: 'Comparing bundles with removed packages - not implemented']]]		ifFalse: [diffs := Array with: (Array with: pun1 with: pun2)].	Cursor write		showWhile: 			[| aStream |			aStream := SourceCodeStream on: fileName asFilename writeStream.						[aStream timeStamp.			diffs do: [:pair | self					fileOutPackageDiff: pair first					with: pair last					into: aStream]]				ensure: [aStream close]]</body><body package="Store-UI" selector="makeDynamicItem:selectionBlock:inMenu:">makeDynamicItem: actionSymbol selectionBlock: aBlock inMenu: aMenu	| mi |	mi := aMenu menuItemWithValue: actionSymbol ifNone: [nil].	mi notNil ifTrue: [mi enabled: aBlock].</body></methods><methods><class-id>Store.AbstractTool</class-id> <category>events</category><body package="Store-UI" selector="noticeOfWindowClose:">noticeOfWindowClose: aWindow	"The containing window is being closed -- release."	self release</body></methods><methods><class-id>Store.AbstractTool</class-id> <category>package actions</category><body package="Store-UI" selector="addPackage">addPackage		SmalltalkWorkbench requestNewPackageName		ifNotNil: [:name | PackageModel named: name].</body><body package="Store-UI" selector="browsePackageVersion">browsePackageVersion	self pundles do: 		[ :each | InputState default ctrlDown			ifTrue: [ each inspect ]			ifFalse: [ TabApplicationSystemBrowser openOnPackage: each ]		]</body><body package="Store-UI" selector="makeCurrentPackage">makeCurrentPackage	self packages size = 1 ifFalse: [^Dialog warn: 'Please select exactly one package.'].	Registry currentPackage: self packages first.</body></methods><methods><class-id>Store.AbstractTool</class-id> <category>class actions</category><body package="Store-UI" selector="loadClass:fromPackage:">loadClass: aClass fromPackage: aPackage 	| loader instSide classSide |	aClass isNil ifTrue: [^Dialog warn: 'No class is selected.'].	aPackage isNil ifTrue: [^Dialog warn: 'No package specified.'].	loader := ClassLoader new.	loader openForClass: aClass package: aPackage. 	loader accept value		ifTrue: 			[instSide := aClass isMeta ifFalse: [aClass]						ifTrue: [aClass instSideFrom: aPackage].			classSide := aClass isMeta						ifTrue: [aClass]						ifFalse: [aClass metaSideFrom: aPackage].			instSide loadFrom: aPackage using: loader.			classSide loadFrom: aPackage using: loader]</body></methods><methods><class-id>Store.AbstractTool</class-id> <category>actions</category><body package="Store-UI" selector="reloadVersions">reloadVersions	self unimplemented</body></methods><methods><class-id>Store.AbstractTool</class-id> <category>text differencing</category><body package="Store-UI" selector="linesFromString:">linesFromString: aString	| lines startIndex stopIndex |	lines := OrderedCollection new.	startIndex := 1.	[startIndex &lt;= aString size] whileTrue: [		stopIndex := aString nextIndexOf: Character cr from: startIndex to: aString size.		stopIndex isNil ifTrue: [stopIndex := aString size].		lines addLast: (TextLine from: startIndex to: stopIndex source: aString).		startIndex := stopIndex + 1].	^lines</body><body package="Store-UI" selector="showLineDifferencesBetweenView:andView:">showLineDifferencesBetweenView: view1 andView: view2	| loc1 loc2 lines1 lines2 string1 string2 nonZero index1 index2 interval |	index1 := 1.  index2 := 1.	view1 displayContents text emphasizeAllWith: #normal.	view2 displayContents text emphasizeAllWith: #normal.	string1 := view1 displayContents string.	string2 := view2 displayContents string.	string1 = string2 ifTrue: [^self].	lines1 := self linesFromString: string1.	lines2 := self linesFromString: string2.	[(index1 &lt;= lines1 size) and: [index2 &lt;= lines2 size]] whileTrue: [		((lines1 at: index1) isEmpty or: [(lines2 at: index2) isEmpty])			ifTrue: [				(lines1 at: index1) isEmpty ifTrue: [index1 := index1 + 1].				(lines2 at: index2) isEmpty ifTrue: [index2 := index2 + 1]]			ifFalse: [				(lines1 at: index1) = (lines2 at: index2)					ifTrue: [index1 := index1 + 1.  index2 := index2 + 1]					ifFalse: [						loc2 := lines1 nextIndexOf: (lines2 at: index2) from: index1 to: lines1 size.						loc2 notNil ifTrue: [loc2 := loc2 - index1].						loc1 := lines2 nextIndexOf: (lines1 at: index1) from: index2 to: lines2 size.						loc1 notNil ifTrue: [loc1 := loc1 - index2].						nonZero := loc1 notNil and: [loc2 notNil].						(loc1 isNil or: [nonZero and: [loc2 &lt;= loc1]]) ifTrue: [							interval := lines1 at: index1.							view1 displayContents text emphasizeFrom: interval startIndex to: interval stopIndex with: #bold.							index1 := index1 + 1].						(loc2 isNil or: [nonZero and: [loc1 &lt; loc2]]) ifTrue: [							interval := lines2 at: index2.							view2 displayContents text emphasizeFrom: interval startIndex to: interval stopIndex with: #bold.							index2 := index2 + 1]]]].	(index1 &lt;= lines1 size) ifTrue: [		view1 displayContents text emphasizeFrom: (lines1 at: index1) startIndex to: (lines1 at: lines1 size) stopIndex with: #bold].	(index2 &lt;= lines2 size) ifTrue: [		view2 displayContents text emphasizeFrom: (lines2 at: index2) startIndex to: (lines2 at: lines2 size) stopIndex with: #bold].</body></methods><methods><class-id>Store.AbstractTool class</class-id> <category>resources</category><body package="Store-UI" selector="dbNonCodePackageImage">dbNonCodePackageImage	^DbNonCodePackageImage</body><body package="Store-UI" selector="nonCodePackageImageModified">nonCodePackageImageModified	^ModifiedNonCodePackageImage</body><body package="Store-UI" selector="nonCodePackageImageUnmodified">nonCodePackageImageUnmodified	^UnmodifiedNonCodePackageImage</body></methods><methods><class-id>Store.AbstractTool class</class-id> <category>utilities</category><body package="Store-UI" selector="addPackageDialog">addPackageDialog	| pkgName newPkg |	pkgName := (Dialog				request: 'Enter a name for the package:'				initialAnswer: ''				onCancel: [String new]) 					trimBlanks.	pkgName isEmpty ifTrue: [^nil].	[Registry isPackageLoaded: pkgName]		whileTrue: 			[pkgName := Dialog						request: pkgName , ' is already in use.\Enter another name for the package.' withCRs						initialAnswer: pkgName						onCancel: [nil].			pkgName isNil ifTrue: [^nil]].	newPkg := PackageModel named: pkgName.	^newPkg</body><body package="Store-UI" selector="compareBundle:with:">compareBundle: aBundle1 with: aBundle2 	"Compare all packages that are in aBundle1 with 	packages that are contained by aBundle2. 	Answer a collection of pairs. First element of each pair 	is one of my packages or nil. Second element of each pair 	is one of packages belonging to aBundle or nil. 	Note that aBundle1 and aBundle2 may have different names"	^self compareHomogeneousItems: aBundle1 leafItems with: aBundle2 leafItems</body><body package="Store-UI" selector="compareItems:with:">compareItems: list1 with: list2 	"Compare two lists that contain pundles with 	Answer a collection of pairs. First element of each pair 	is one from list1 or nil. Second element of each pair 	is one from list2 or nil."	| l1 l2 diffs |	l1 := list1 select: [:i| i isBundle].	l2 := list2 select: [:i| i isBundle].	diffs := self compareHomogeneousItems: l1 with: l2.	l1 := list1 select: [:i| i isPackage].	l2 := list2 select: [:i| i isPackage].	diffs addAll: (self compareHomogeneousItems: l1 with: l2).	^diffs</body></methods><methods><class-id>Store.AbstractTool class</class-id> <category>label utilities</category><body package="Store-UI" selector="addCheckMarkToImage:">addCheckMarkToImage: anImage 	| cp |	cp := CompositePart new.	cp add: self checkMark at: 0 @ 0.	cp add: anImage at: self checkMarkWidth @ 0.	^cp</body><body package="Store-UI" selector="iconForPundle:">iconForPundle: aPundle 	| modified loaded |	modified := aPundle hasBeenModified.	loaded := aPundle isLoaded.	^aPundle isBundle		ifTrue: [loaded				ifTrue: [modified						ifTrue: [self bundleImageModified]						ifFalse: [self bundleImageUnmodified]]				ifFalse: [self dbBundleImage]]		ifFalse: [loaded				ifTrue: [modified						ifTrue: [self packageImageModified]						ifFalse: [self packageImageUnmodified]]				ifFalse: [self dbPackageImage]]</body><body package="Store-UI" selector="labelForPundle:reversed:inView:">labelForPundle: aPundle reversed: isReversed inView: aSelectionView 	^self		labelWithString: (aPundle stringKey: #())		icon: (self iconForPundle: aPundle)		disabled: false		reversed: isReversed		checked: false		inView: aSelectionView		offsetForCheckedView: false</body><body package="Store-UI" selector="labelWithString:icon:disabled:reversed:checked:inView:offsetForCheckedView:">labelWithString: aString icon: anImage disabled: isDisabled reversed: isReversed checked: isChecked inView: aSelectionView offsetForCheckedView: isOffset 	"If isOffset is true, the returned LabalAndIcon will be offset so that the icon 	will align with the icons of other labels preceeded by check marks."	| label disabledText |	label := LabelAndIcon with: aString attributes: aSelectionView textStyle.	isDisabled		ifTrue: 			[disabledText := aString asText.			disabledText emphasizeAllWith: #color -&gt; aSelectionView inactiveForegroundColor.			label text: disabledText].	label icon: (isChecked ifTrue: [self addCheckMarkToImage: anImage] ifFalse: [anImage]).	isOffset ifTrue: [label offset: self checkMarkWidth @ 0].	isReversed		ifTrue: 			[label := ReversingWrapper on: label.			label reverse setValue: true].	^label</body></methods><methods><class-id>Store.AbstractTool class</class-id> <category>private</category><body package="Store-UI" selector="checkMark">checkMark	^LabelAndIcon checkMark</body><body package="Store-UI" selector="checkMarkGap">checkMarkGap	^4</body><body package="Store-UI" selector="checkMarkWidth">checkMarkWidth	^self checkMark width + self checkMarkGap</body><body package="Store-UI" selector="compareHomogeneousItems:with:">compareHomogeneousItems: list1 with: list2 	"Compare two lists that contain pundles with 	Answer a collection of pairs. First element of each pair 	is one from list1 or nil. Second element of each pair 	is one from list2 or nil."	| dict diffs |	dict := Dictionary new.	diffs := OrderedCollection new.	list2 do: [:pndl | dict at: pndl name put: pndl].	list1		do: 			[:pndl | 			| other |			other := dict at: pndl name						ifAbsent: 							[diffs add: (Array with: pndl with: nil).							nil].			other notNil				ifTrue: 					[(other sameVersionAs: pndl)						ifFalse: [diffs add: (Array with: pndl with: other)].					dict at: pndl name put: nil]].	dict do: [:pndl | pndl notNil ifTrue: [diffs add: (Array with: nil with: pndl)]].	^diffs</body><body package="Store-UI" selector="install">install	self updateImages.</body><body package="Store-UI" selector="obsolete">obsolete	super obsolete.	ObjectMemory removeDependent: self</body><body package="Store-UI" selector="update:with:from:">update: anAspect with: arguments from: anObject	"Check for return from snapshot to install."	anAspect == #returnFromSnapshot		ifTrue: [self install]</body><body package="Store-UI" selector="updateImages">updateImages	| mono |	mono := Screen default colorDepth == 1.	IsMonocrome = mono ifTrue: [^self].	IsMonocrome := mono.	IsMonocrome		ifTrue: 			[ModifiedBundleImage := self bundleImageModifiedBW.			ModifiedPackageImage := self packageImageModifiedBW.			ModifiedNonCodePackageImage := self nonCodePackageImageModifiedBW]		ifFalse: 			[ModifiedBundleImage := OpaqueImage figure: (CachedImage on: self bundleImageModifiedC)						shape: (CachedImage on: self bundleImageModifiedBW).			ModifiedPackageImage := OpaqueImage figure: (CachedImage on: self packageImageModifiedC)						shape: (CachedImage on: self packageImageModifiedBW).			ModifiedNonCodePackageImage := OpaqueImage figure: (CachedImage on: self nonCodePackageImageModifiedC)						shape: (CachedImage on: self nonCodePackageImageModifiedBW)].	DbBundleImage := self dbBundleImageBW.	DbNonCodePackageImage := self dbNonCodePackageImageBW.	DbPackageImage := self dbPackageImageBW.	UnmodifiedBundleImage := self bundleImageUnmodifiedBW.	UnmodifiedPackageImage := self packageImageUnmodifiedBW.	UnmodifiedNonCodePackageImage := self nonCodePackageImageUnmodifiedBW</body></methods><methods><class-id>Store.AbstractTool class</class-id> <category>class initialization</category><body package="Store-UI" selector="initialize">initialize	"self initialize"	ObjectMemory removeDependent: self.	ObjectMemory addDependent: self.	self updateImages.</body></methods><methods><class-id>Store.AbstractTool class</class-id> <category>generated resources</category><body package="Store-UI" selector="bundleImageModified">bundleImageModified	^ListIconLibrary visualFor: #modifiedBundle</body><body package="Store-UI" selector="bundleImageUnmodified">bundleImageUnmodified	^ListIconLibrary visualFor: #bundle</body><body package="Store-UI" selector="dbBundleImage">dbBundleImage	^ListIconLibrary visualFor: #bundle</body><body package="Store-UI" selector="dbPackageImage">dbPackageImage	^ListIconLibrary visualFor: #package</body><body package="Store-UI" selector="packageImageModified">packageImageModified	^ListIconLibrary visualFor: #modifiedPackage</body><body package="Store-UI" selector="packageImageUnmodified">packageImageUnmodified	^ListIconLibrary visualFor: #package</body></methods><methods><class-id>Store.GarbageCollectSpecEditor</class-id> <category>aspects</category><body package="Store-UI" selector="availablePundles">availablePundles	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^availablePundles isNil		ifTrue: [ availablePundles := MultiSelectionInList new ]		ifFalse:	[ availablePundles ]</body><body package="Store-UI" selector="blessingLevel">blessingLevel	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^blessingLevel isNil		ifTrue: [ blessingLevel := nil asValue ]		ifFalse: [ blessingLevel ]</body><body package="Store-UI" selector="blessingLevelMenu">blessingLevelMenu	^blessingLevelMenu</body><body package="Store-UI" selector="date">date	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^date isNil		ifTrue: [ date := Date today asValue ]		ifFalse: [ date ]</body><body package="Store-UI" selector="garbage">garbage	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^garbage isNil		ifTrue: [ garbage := SelectionInList new ]		ifFalse: [ garbage ]</body></methods><methods><class-id>Store.GarbageCollectSpecEditor</class-id> <category>actions</category><body package="Store-UI" selector="accept">accept	"Accept has been selected- answer self to cancel."	| bundles packages |	packages := self calculateSelections.	packages isEmpty 		ifTrue: [ ^Dialog warn: 'No packages meet the criteria.' ].	bundles := GarbageCollector affectedBundles: packages.	( self confirmBundles: bundles packages: packages )		ifFalse: [ ^self ].	GarbageCollector removeBundles: bundles packages: packages.	self closeRequest.</body><body package="Store-UI" selector="addToGarbage">addToGarbage	| selectionIndexes |	selectionIndexes := self availablePundles selectionIndexes.	selectionIndexes isEmpty ifTrue: [ ^self ].	selectionIndexes do: 		[ :i | self garbage list add: ( self availablePundles list at: i ).		self pundleAtIndex: i isAvailable: false		].	self garbage selectionIndex: self garbage list size.	"Deselect all items in available pundle list view."	self availablePundles selectionIndexes: Set new.	self disturb.</body><body package="Store-UI" selector="cancel">cancel	self closeRequest</body><body package="Store-UI" selector="disturb">disturb	self setButtons.</body><body package="Store-UI" selector="removeItem">removeItem	| itemToRemove availablePundleIndex |		( itemToRemove := self garbage selection ) isNil 		ifTrue: [ ^self ].	availablePundleIndex := self availablePundles list indexOf: itemToRemove.	self pundleAtIndex: availablePundleIndex isAvailable: true.	( self builder componentAt: #availablePundlesView) widget updateAt: availablePundleIndex.	self garbage selection: nil.	self garbage list remove: itemToRemove.	self disturb.</body><body package="Store-UI" selector="undisturb">undisturb	self setButtons.</body></methods><methods><class-id>Store.GarbageCollectSpecEditor</class-id> <category>list visuals</category><body package="Store-UI" selector="initializeVisualBlocksForGarbageView">initializeVisualBlocksForGarbageView	| contentView |	contentView := ( self builder componentAt: #garbageView ) widget.	contentView selectedVisualBlock: 		[ :aView :index | 		self	makeGarbageListItemForIndex: index inView: aView selected: true 		].	contentView visualBlock: 		[ :aView :index | 		self makeGarbageListItemForIndex: index inView: aView selected: false		]</body><body package="Store-UI" selector="initializeVisualBlocksForPundleView">initializeVisualBlocksForPundleView	| pundleView |	pundleView := ( self builder componentAt: #availablePundlesView ) widget.	pundleView selectedVisualBlock: 		[ :aView :index | 		self	makePundleListItemForIndex: index inView: aView selected: true		].	pundleView visualBlock: 		[ :aView :index | 		self	makePundleListItemForIndex: index inView: aView selected: false 		]</body><body package="Store-UI" selector="makeGarbageListItemForIndex:inView:selected:">makeGarbageListItemForIndex: index inView: aView selected: isSelected	| label pundle |	pundle := self garbage list at: index.	label := AbstractTool labelWithString: pundle name		icon: (  AbstractTool iconForPundle: pundle )		disabled: false		reversed: isSelected		checked: false		inView: aView		offsetForCheckedView: false.	^BoundedWrapper on: label.</body><body package="Store-UI" selector="makePundleListItemForIndex:inView:selected:">makePundleListItemForIndex: index inView: aSelectionView selected: isSelected 	| label disable pundle check |	disable := ( self isPundleAvailableAtIndex: index ) not.	pundle := self availablePundles list at: index.	check := isSelected.	label := AbstractTool				labelWithString: pundle name				icon: (AbstractTool iconForPundle: pundle)				disabled: disable				reversed: false				checked: check				inView: aSelectionView				offsetForCheckedView: check not.	^BoundedWrapper on: label</body></methods><methods><class-id>Store.GarbageCollectSpecEditor</class-id> <category>initialize-release</category><body package="Store-UI" selector="getAvailablePundleList">getAvailablePundleList	^Package knownPackages list collect: [ :str | Package new name: str ]."	| list |	list := Bundle knownBundles list collect:	[ :str | Bundle new name: str ]. 	list addAll:		( Package knownPackages list collect: [ :str | Package new name: str ] ).	^list"</body><body package="Store-UI" selector="initialize">initialize	super initialize.	self availablePundles list: ( self getAvailablePundleList ).	pundleAvailability := Array new: self availablePundles list size withAll: true.	blessingLevelMenu := Policies blessingPolicy blessingLevelsMenu.</body><body package="Store-UI" selector="postBuildWith:">postBuildWith: aBuilder 	self initializeVisualBlocksForPundleView.	self initializeVisualBlocksForGarbageView.	self setButtons.</body></methods><methods><class-id>Store.GarbageCollectSpecEditor</class-id> <category>private</category><body package="Store-UI" selector="calculateSelections">calculateSelections	"Caclulate which bundles/packages are slated for GC."	| masterList timeStamp bless |	masterList := Set new.	timeStamp := DBObject timeStampFromDate: self date value.	bless := self blessingLevel value == nil		ifTrue: [ 99999 ]		ifFalse: [ self blessingLevel value ].	self garbage list do:		[ :pundle |		masterList addAll: 			( ( pundle class allVersionsWithName: pundle name ) select:				[ :p | |  img |				( ( img := p getImagePundle ) == nil or: [ img dbTrace ~~ p primaryKey ] ) and:					[ p timeStamp &lt; timeStamp and: [ p blessingLevelNumber &lt;= bless ] ]				] 			).		].	^masterList.</body><body package="Store-UI" selector="confirmBundles:packages:">confirmBundles: bundles packages: packages	"Ask the user to validate the actual bundles and packages selected" 	"Note: also verifies no bundle is currently loaded. Packages were	filtered by this already."	| bdict pdict str updateBlock |	bdict := Dictionary new.	bundles do:		[ :bundle |		( self isCurrentlyLoaded: bundle )			ifTrue: 				[ Dialog warn: bundle itemString, ' in the image would be invalidated.' .				^false 				].		( bdict at: bundle name ifAbsentPut: [ OrderedCollection new ] )			add: bundle		].	pdict := Dictionary new.	packages do:		[ :pkg |		( pdict at: pkg name ifAbsentPut: [ OrderedCollection new ] )			add: pkg		].	str := ( String new: 5000 ) writeStream.	updateBlock := 		[ :coll | str tab; nextPutAll: coll first name; tab.		coll do:	[ :pun | str nextPutAll: pun versionString ].		str cr.		].	str nextPutAll: 'Permanently remove the following from the database???'; cr; cr.	str nextPutAll: 'Bundles:'; cr.	bdict do: updateBlock.	str nextPutAll: 'Packages:'; cr.	pdict do: updateBlock.	^Dialog confirmReport: str contents.</body><body package="Store-UI" selector="isCurrentlyLoaded:">isCurrentlyLoaded: item	"Answer true if a db package/bundle is also currently active in the image."	| img |	^( img := item getImagePundle ) ~~ nil 		and: [ img dbTrace == item primaryKey ]</body><body package="Store-UI" selector="isPundleAvailableAtIndex:">isPundleAvailableAtIndex: anIndex	^pundleAvailability at: anIndex</body><body package="Store-UI" selector="okSelection:">okSelection: aController		"Don't let the selection change if the targeted item is disabled"	^self isPundleAvailableAtIndex: aController view targetIndex</body><body package="Store-UI" selector="pundleAtIndex:isAvailable:">pundleAtIndex: index isAvailable: aBoolean	pundleAvailability at: index put: aBoolean.</body><body package="Store-UI" selector="setButtons">setButtons	( self builder componentAt: #acceptButton ) isEnabled: 		( ( self garbage list size == 0 ) or: [ self date value == nil ] )  not.	( self builder componentAt: #addToGarbage ) isEnabled: 		( self availablePundles selections size &gt; 0 ).	( self builder componentAt: #removeItem ) isEnabled: 		( self garbage selection ~~ nil ).</body></methods><methods><class-id>Store.Loader</class-id> <category>aspects</category><body package="Store-UI" selector="comment">comment	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^comment isNil		ifTrue: [comment := false asValue]		ifFalse: [comment]</body><body package="Store-UI" selector="data">data	^data isNil 		ifTrue: [ data := false asValue ]		ifFalse: [ data ]</body></methods><methods><class-id>Store.Loader</class-id> <category>accessing</category><body package="Store-UI" selector="package:">package: aPackage	package :=  aPackage</body></methods><methods><class-id>Store.Loader</class-id> <category>actions</category><body package="Store-UI" selector="loadChoosen">loadChoosen	self accept value: true</body></methods><methods><class-id>Store.TextDifferenceBrowser</class-id> <category>menu messages</category><body package="Store-UI-Comparitors" selector="findDiffs">findDiffs	| view1 view2 |	self		showLineDifferencesBetweenView: (view1 := (self builder componentAt: #text1Widget) widget)		andView: (view2 := (self builder componentAt: #text2Widget) widget).	view1 simpleRedisplay.	view2 simpleRedisplay.</body></methods><methods><class-id>Store.TextDifferenceBrowser</class-id> <category>aspects</category><body package="Store-UI-Comparitors" selector="enableTextAccept">enableTextAccept	^false</body><body package="Store-UI-Comparitors" selector="postOpenWith:">postOpenWith: aBuilder 	(self text1 value isEmpty not and: [self text2 value isEmpty not])		ifTrue: [self findDiffs]</body><body package="Store-UI-Comparitors" selector="text1">text1	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^text1 isNil ifTrue: [text1 := String new asValue] ifFalse: [text1]</body><body package="Store-UI-Comparitors" selector="text2">text2	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^text2 isNil ifTrue: [text2 := String new asValue] ifFalse: [text2]</body></methods><methods><class-id>Store.TextDifferenceBrowser</class-id> <category>menus</category><body package="Store-UI-Comparitors" selector="customTextMenu">customTextMenu	"No accept from this browser."	| mb |	mb := MenuBuilder new.	mb 		addFindReplaceUndo;		line;		addCopyCutPaste;		line;		add: 'cancel'-&gt;#cancel.	^mb menu.</body></methods><methods><class-id>Store.TextDifferenceBrowser class</class-id> <category>instance creation</category><body package="Store-UI-Comparitors" selector="compare:with:">compare: text1 with: text2 		| diffBrowser |	diffBrowser := self new.	diffBrowser text1 value: text1.	diffBrowser text2 value: text2.	diffBrowser openInterface: #briefSpec</body></methods><methods><class-id>Store.FileDifferenceBrowser</class-id> <category>aspects</category><body package="Store-UI-Comparitors" selector="fileName1">fileName1	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^fileName1 isNil ifTrue: [fileName1 := String new asValue] ifFalse: [fileName1]</body><body package="Store-UI-Comparitors" selector="fileName2">fileName2	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^fileName2 isNil ifTrue: [fileName2 := String new asValue] ifFalse: [fileName2]</body></methods><methods><class-id>Store.FileDifferenceBrowser</class-id> <category>initialize-release</category><body package="Store-UI-Comparitors" selector="initialize">initialize	super initialize.	self fileName1 onChangeSend: #newFile1 to: self.	self fileName2 onChangeSend: #newFile2 to: self.</body></methods><methods><class-id>Store.FileDifferenceBrowser</class-id> <category>updating</category><body package="Store-UI-Comparitors" selector="newFile1">newFile1	| aFileName |	aFileName := Filename named: self fileName1 value.	self text1 value: aFileName contentsOfEntireFile</body><body package="Store-UI-Comparitors" selector="newFile2">newFile2	| aFileName |	aFileName := Filename named: self fileName2 value.	self text2 value: aFileName contentsOfEntireFile</body></methods><methods><class-id>Store.MergeSelector</class-id> <category>aspects</category><body package="Store-Merge" selector="packages">packages	^packages</body></methods><methods><class-id>Store.MergeSelector</class-id> <category>initialize-release</category><body package="Store-Merge" selector="initialize">initialize	"Get the list of all packages that have at least one versions marked as 	integration ready."	super initialize.	packages := MultiSelectionInList new.	self initializePackages.	self packages selectionIndexHolder onChangeSend: #packageSelectionChanged to: self</body><body package="Store-Merge" selector="initializePackages">initializePackages	"Get the list of all packages that have at least one versions marked as 	integration ready."	| names versions |	names := Set new.	versions := Policies mergePolicy selectVersionsReadyForIntegration: self dbRegistry allPackages.	versions do: [:v| names add: v name].	packages list: (names asSortedCollection asList).</body></methods><methods><class-id>Store.MergeSelector</class-id> <category>private</category><body package="Store-Merge" selector="dbRegistry">dbRegistry	^Package</body><body package="Store-Merge" selector="packageSelectionChanged">packageSelectionChanged	| mergeButton |	mergeButton := builder componentAt: #mergeID.	packages selectionIndexes size &gt; 0		ifTrue: [mergeButton enable]		ifFalse: [mergeButton disable]</body></methods><methods><class-id>Store.AbstractPublishSpecification</class-id> <category>accessing</category><body package="Store-IMG-Configurations" selector="blessing">blessing	^blessing</body><body package="Store-IMG-Configurations" selector="blessing:">blessing: anObject	blessing := anObject</body><body package="Store-IMG-Configurations" selector="comment">comment	^comment</body><body package="Store-IMG-Configurations" selector="comment:">comment: anObject	comment := anObject</body><body package="Store-IMG-Configurations" selector="description">description	^description</body><body package="Store-IMG-Configurations" selector="description:">description: anObject	description := anObject</body><body package="Store-IMG-Configurations" selector="level">level	^level</body><body package="Store-IMG-Configurations" selector="level:">level: anObject	level := anObject</body><body package="Store-IMG-Configurations" selector="modified">modified	^modified</body><body package="Store-IMG-Configurations" selector="modified:">modified: anObject	modified := anObject</body><body package="Store-IMG-Configurations" selector="parentVersion">parentVersion	^parentVersion</body><body package="Store-IMG-Configurations" selector="parentVersion:">parentVersion: anObject	parentVersion := anObject</body><body package="Store-IMG-Configurations" selector="publish">publish	^publish</body><body package="Store-IMG-Configurations" selector="publish:">publish: anObject	publish := anObject</body><body package="Store-IMG-Configurations" selector="pundle">pundle	^object</body><body package="Store-IMG-Configurations" selector="pundle:">pundle: aPundle	object := aPundle.	modified := object hasBeenModified or: [ object hasTrace not ].	publish := modified.	parentVersion := object parentVersionString.	version := parentVersion isEmpty		ifTrue: [ Policies versionPolicy initialVersionForPundle: aPundle ]		ifFalse: [ Policies versionPolicy nextVersion: parentVersion forPundle: aPundle ]</body><body package="Store-IMG-Configurations" selector="version">version	^version</body><body package="Store-IMG-Configurations" selector="version:">version: anObject	version := anObject</body></methods><methods><class-id>Store.AbstractPublishSpecification</class-id> <category>initialize-release</category><body package="Store-IMG-Configurations" selector="initialize">initialize	comment := ''.	version := ''.	description := nil.	level := 0.	publish := false.	modified := false.	blessing := Policies blessingPolicy defaultBlessing.</body></methods><methods><class-id>Store.GarbageCollector</class-id> <category>reporting</category><body package="Store-Database" selector="printFinalStatisticsTo:">printFinalStatisticsTo: aStream	aStream cr; nextPutAll: 'Garbage collection ended:    '.	Timestamp now printOn: aStream.	aStream cr; nextPutAll: 'Removed...'.	aStream cr; tab; nextPutAll: 'namespaces : '.	nameSpacesToRemove size printOn: aStream.	aStream cr; tab; nextPutAll: 'classes : '.	classesToRemove size printOn: aStream.	aStream cr; tab; nextPutAll: 'methods : '.	methodsToRemove size printOn: aStream.	aStream cr; tab; nextPutAll: 'shared variables : '.	dataToRemove size printOn: aStream.	aStream cr.</body><body package="Store-Database" selector="printInitialStatisticsTo:">printInitialStatisticsTo: aStream	aStream cr; nextPutAll: 'Garbage collection started:   '.	Timestamp now printOn: aStream.	aStream cr; nextPutAll: 'Number of bundles to remove: '.	bundlesToRemove size printOn: aStream.	aStream cr; nextPutAll: 'Number of packages to remove: '.	packagesToRemove size printOn: aStream.	aStream cr; nextPutAll: 'Examining...'.	aStream cr; tab; nextPutAll: 'namespaces: '.	( packagesToRemove inject: 0 into: [ :total :pkg | total + pkg allNameSpaces size ] ) printOn: aStream.	aStream cr; tab; nextPutAll: 'classes: '.	( packagesToRemove inject: 0 into: [ :total :pkg | total + pkg allClasses size ] ) printOn: aStream.	aStream cr; tab; nextPutAll: 'methods: '.	( packagesToRemove inject: 0 into: [ :total :pkg | total + pkg methods size ] ) printOn: aStream.	aStream cr; tab; nextPutAll: 'shared variables: '.	( packagesToRemove inject: 0 into: [ :total :pkg | total + pkg data size ] ) printOn: aStream.	aStream cr</body></methods><methods><class-id>Store.GarbageCollector</class-id> <category>initialize-release</category><body package="Store-Database" selector="bundlesToRemove:">bundlesToRemove: aCollectionOfBundles	bundlesToRemove := aCollectionOfBundles</body><body package="Store-Database" selector="cleanAfterGagbageCollection">cleanAfterGagbageCollection	"Remove indices created only for	the grabage collection process."	Methods dropIndex.	Method dropIndex.	Data dropIndex.	DataElement dropIndex.</body><body package="Store-Database" selector="collectGarbage">collectGarbage	| str ids bids |	str := (String new: 1000) writeStream.	self printInitialStatisticsTo: str.	Transcript cr; show: str contents. 	ids := (packagesToRemove collect: [ :pkg| pkg primaryKey ] ) asSet.	bids := (bundlesToRemove collect: [ :b | b primaryKey ] ) asSet.	self collectMethodsFrom: ids.	self collectNameSpacesFrom: ids.	self collectDataFrom: ids.	self collectClassesFrom: ids.	self collectBlessingsFrom: packagesToRemove.	self collectBlessingsFrom: bundlesToRemove.	self collectDefinitionsFrom: ids.	self collectBundleDefinitionsFrom: bids.	self collectDefinitions.	packagesToAdopt := self substituteParentsFor:  packagesToRemove.	bundlesToAdopt := self substituteParentsFor:  bundlesToRemove.	methodsToAdopt := self substituteParentsFor:  methodsToRemove.	dataToAdopt := self substituteParentsFor:  dataToRemove.	classesToAdopt := self substituteParentsFor:  classesToRemove.	nameSpacesToAdopt := self substituteParentsFor:  nameSpacesToRemove.	self removeRecords.	str := ( String new: 1000 ) writeStream.	self printFinalStatisticsTo: str.	Transcript cr; show: str contents</body><body package="Store-Database" selector="initialize">initialize		methodsToRemove := Set new: 1000.	dataToRemove := Set new: 1000.	definitionsToRemove := Set new: 1000.	classesToRemove := Set new: 500.	nameSpacesToRemove := Set new: 100.	parcelRecordsToRemove := Set new: 100.	binaryDefinitionsToRemove := Set new: 200.</body><body package="Store-Database" selector="packagesToRemove:">packagesToRemove: aCollectionOfPackages	packagesToRemove := aCollectionOfPackages</body><body package="Store-Database" selector="prepareForGagbageCollection">prepareForGagbageCollection	"Create necessary indices to speed up	the grabage collection process."	Methods createIndex.	Method createIndex.	Data createIndex.	DataElement createIndex.</body><body package="Store-Database" selector="release">release	"Remove indices used by the garbage collection process. 	and clean package cache."	self cleanAfterGagbageCollection.	Package initializeCache.	Bundle initializeCache.</body></methods><methods><class-id>Store.GarbageCollector</class-id> <category>private-db-utils</category><body package="Store-Database" selector="blessingsAttachedToPundle:">blessingsAttachedToPundle:  aPundle	^Blessing attachedToPundle: aPundle</body><body package="Store-Database" selector="bundlesContainingProperty:">bundlesContainingProperty: anID	^Properties bundlesContainingProperty: anID</body><body package="Store-Database" selector="bundlesReferingTo:">bundlesReferingTo:  aDefinitionID	"Answer a set of package IDS that refer to a given definition either as comment	or proterties dictionary."	^Bundle pundlesReferingTo: aDefinitionID</body><body package="Store-Database" selector="classesReferingTo:">classesReferingTo: aDefinitionID	^ClassRecord recordsReferingToDefinitionID: aDefinitionID</body><body package="Store-Database" selector="classesReferingToComment:">classesReferingToComment: aDefinitionID	^ClassRecord recordsReferingToCommentID: aDefinitionID</body><body package="Store-Database" selector="dataReferingTo:">dataReferingTo: aDefinitionID	^DataElement recordsReferingToDefinitionID: aDefinitionID</body><body package="Store-Database" selector="dataReferingToComment:">dataReferingToComment: aDefinitionID	^DataElement recordsReferingToCommentID: aDefinitionID</body><body package="Store-Database" selector="methodsReferingTo:">methodsReferingTo: aDefinitionID	^Method methodsReferingToDefinitionID: aDefinitionID</body><body package="Store-Database" selector="nameSpacesReferingTo:">nameSpacesReferingTo: aDefinitionID	^NameSpaceRecord recordsReferingToDefinitionID: aDefinitionID</body><body package="Store-Database" selector="nameSpacesReferingToComment:">nameSpacesReferingToComment: aDefinitionID	^NameSpaceRecord recordsReferingToCommentID: aDefinitionID</body><body package="Store-Database" selector="packagesContainingClass:">packagesContainingClass:  aClassID	^PkgClasses packagesContainingClass: aClassID</body><body package="Store-Database" selector="packagesContainingDatum:">packagesContainingDatum:  datumID	^Data packagesContainingDatum: datumID</body><body package="Store-Database" selector="packagesContainingMetaclass:">packagesContainingMetaclass:  aClassID	^PkgClasses packagesContainingMetaclass: aClassID</body><body package="Store-Database" selector="packagesContainingMethod:">packagesContainingMethod:  methodID	^Methods packagesContainingMethod: methodID</body><body package="Store-Database" selector="packagesContainingNameSpace:">packagesContainingNameSpace: anID	^PkgNameSpaces packagesContainingNameSpace: anID</body><body package="Store-Database" selector="packagesContainingProperty:">packagesContainingProperty: anID	^Properties packagesContainingProperty: anID</body><body package="Store-Database" selector="packagesReferingTo:">packagesReferingTo:  aDefinitionID	"Answer a set of package IDS that refer to a given definition either as comment	or a  property id."	^Package pundlesReferingTo: aDefinitionID</body><body package="Store-Database" selector="propertiesReferingTo:">propertiesReferingTo: aDefinitionID 	"Return a list of property records (their IDs) who's propertyIDs match aDefinitionID."	^PropertyRecord recordsReferingToDefinitionID: aDefinitionID</body><body package="Store-Database" selector="propertiesReferingToComment:">propertiesReferingToComment: aDefinitionID	^PropertyRecord recordsReferingToCommentID: aDefinitionID</body></methods><methods><class-id>Store.GarbageCollector</class-id> <category>private</category><body package="Store-Database" selector="collectBinaryDefinitions">collectBinaryDefinitions	"Collect parcelRecords and their binary data. 	There can only be one referece to a parcelRecord and it's data."	| rec |	packagesToRemove do: 		[ :pkg | 		( rec := pkg binaryVersion ) == nil			ifFalse: 				[ parcelRecordsToRemove add: rec.				binaryDefinitionsToRemove 					add: rec blobID;					add: rec sourceID.				]		].</body><body package="Store-Database" selector="collectBlessingsFrom:">collectBlessingsFrom: pundles	"Check blessings. Note that blessings are not shared among packages/bundles nor do 	blessings share definitions, so all blessings attached to removed packages should 	be removed.	We still want to collect records for comments."	pundles do: 		[ :pun | 		( self blessingsAttachedToPundle: pun ) do: 			[ :blessing |   | defID |			defID := blessing commentID.			defID isZero ifFalse: [ definitionsToRemove add: defID ]			]		]</body><body package="Store-Database" selector="collectBundleDefinitionsFrom:">collectBundleDefinitionsFrom: bundleIDs 	"Mark definitions used only by the removed packages."	bundlesToRemove do: 		[ :bundle | 		( Array with: bundle commentID with: bundle propertiesID "with: bundle parcelID" ) do: 			[ :defID | 			( ( defID == nil  or: [ defID isZero ] ) or: [ definitionsToRemove includes: defID ] ) 				ifFalse: 					[ | buns |					buns := self bundlesReferingTo: defID.					buns detect:  						[ :pID | ( bundleIDs includes: pID ) not ] ifNone: [ definitionsToRemove add: defID ].					]				]			]</body><body package="Store-Database" selector="collectClassDefinitions">collectClassDefinitions	"At this point we have all classes that we want to remove, so 	we can find out comments &amp; definitions that are used only by them."	| considered ids |	considered := Set new: ( classesToRemove size * 2 ).	ids := ( classesToRemove collect: [ :class | class primaryKey ] ) asSet.	classesToRemove do: 		[ :class | 	| definitionID classes |		definitionID := class commentID.		( definitionID isZero or: [ considered includes: definitionID ] )			ifFalse: 				[ considered add: definitionID.				classes := self classesReferingToComment: definitionID.				classes detect:  					[ :cID | ( ids includes: cID ) not ] ifNone: [ definitionsToRemove add: definitionID ].				].			definitionID := class definitionID.			( definitionID isZero or: [ considered includes: definitionID ] )				ifFalse: 					[ considered add: definitionID.					classes := self classesReferingTo: definitionID.					classes detect:  						[ :cID | ( ids includes: cID ) not ] ifNone: [ definitionsToRemove add: definitionID ].					]		]</body><body package="Store-Database" selector="collectClassesFrom:">collectClassesFrom: packageIDs	"First check all classes defined in packages. If a class is used only by packages 	that are to be removed then mark it for removal." 	classesToRemove :=		( PkgClasses allInstancesInAndOnlyIn: packageIDs ) collect: [ :id | ClassRecord aRecordWithID: id ].	classesToRemove addAll:		( ( PkgClasses allMetaclassesInAndOnlyIn: packageIDs ) collect: [ :id | ClassRecord aRecordWithID: id ] ).</body><body package="Store-Database" selector="collectDataDefinitions">collectDataDefinitions	"At this point we have all data that we want to remove, so 	we can find out definitions that are used only by these data."	| considered ids |	considered := Set new: dataToRemove size.	ids := ( dataToRemove collect: [ :datum | datum primaryKey ] ) asSet.	dataToRemove do: 		[ :datum |  | definitionID mthds |		definitionID := datum definitionID.		( definitionID isZero or: [ considered includes: definitionID ] )			ifFalse: 				[ considered add: definitionID.				mthds := self dataReferingTo: definitionID.				mthds detect:  					[ :mID | ( ids includes: mID ) not ] ifNone: [ definitionsToRemove add: definitionID ].				].		"DataElements don't have comments now, but they might later."		definitionID := datum commentID.		( definitionID isZero or: [ considered includes: definitionID ] )			ifFalse: 				[ considered add: definitionID.				mthds := self dataReferingToComment: definitionID.				mthds detect:  					[ :mID | ( ids includes: mID ) not ] ifNone: [ definitionsToRemove add: definitionID ].				]		].</body><body package="Store-Database" selector="collectDataFrom:">collectDataFrom: packageIDs 	"First check all data defined in a package. If a datum is used only by packages 	that are to be removed that are then mark it for removal."	dataToRemove :=		( Data allInstancesInAndOnlyIn: packageIDs ) collect: [ :id | DataElement aRecordWithID: id ].</body><body package="Store-Database" selector="collectDefinitions">collectDefinitions	"At this point we have all classes, methods and data that we want to remove, so 	we can find out definitions that are used only by these classes, methods and data."	self collectClassDefinitions.	self collectNameSpaceDefinitions.	self collectMethodDefinitions.	self collectDataDefinitions.	self collectBinaryDefinitions.</body><body package="Store-Database" selector="collectDefinitionsFrom:">collectDefinitionsFrom: packageIDs 	"Mark definitions used only by the removed packages."	packagesToRemove do: 		[ :package | 		( Array with: package commentID with: package propertiesID "with: package parcelID" ) do: 			[ :defID | 			( defID isZero or: [ definitionsToRemove includes: defID ] )				ifFalse: 					[ | pkgs |					pkgs := self packagesReferingTo: defID.					pkgs detect:  						[ :pID | ( packageIDs includes: pID ) not ] ifNone: [ definitionsToRemove add: defID ].					]				]			]</body><body package="Store-Database" selector="collectMethodDefinitions">collectMethodDefinitions	"At this point we have all methods that we want to remove, so add the definitions that	are not shared with other methods."	| considered ids |	considered := Set new: methodsToRemove size.   "so we examine each once"	ids := ( methodsToRemove collect: [ :method | method primaryKey ] ) asSet.	methodsToRemove do: 		[ :method |   | definitionID mthds |		definitionID := method sourceCodeID.		( definitionID isZero or: [ considered includes: definitionID ] )			ifFalse: 				[ considered add: definitionID.				mthds := self methodsReferingTo: definitionID.				mthds detect:  					[ :mID | ( ids includes: mID ) not ] ifNone: [ definitionsToRemove add: definitionID ].				]		].</body><body package="Store-Database" selector="collectMethodsFrom:">collectMethodsFrom: packageIDs 	"First check all methods defined in a package. If a method is used only by packages 	that are to be removed that are then mark it for removal." 	methodsToRemove := 		( Methods allInstancesInAndOnlyIn: packageIDs ) collect: [ :id | Method aRecordWithID: id ].</body><body package="Store-Database" selector="collectMethodsFromINTERM:">collectMethodsFromINTERM: packageIDs 	"First check all methods defined in a package. If a method is used only by packages 	that are to be removed that are then mark it for removal."	methodsToRemove := 		( Methods methodsInAndOnlyIn: packageIDs )			collect: [ :id | Method aRecordWithID: id ].</body><body package="Store-Database" selector="collectMethodsFromOLD:">collectMethodsFromOLD: packageIDs 	"First check all methods defined in a package. If a method is used only by packages 	that are to be removed that are then mark it for removal."	| considered |	considered := Set new: 5000.	packagesToRemove do: 		[ :package |   | pkgs |		"Transcript show: 'Processing methods from package: '; show: package itemString; cr."		package methods do: 			[ :method | 			( considered includes: method primaryKey )				ifFalse: 					[ considered add: method primaryKey.					pkgs := self packagesContainingMethod: method primaryKey.					pkgs detect:  						[ :pID | ( packageIDs includes: pID ) not ] ifNone: [ methodsToRemove add: method ].					]			]		]</body><body package="Store-Database" selector="collectNameSpaceDefinitions">collectNameSpaceDefinitions	"At this point we have all namespaces that we want to remove, so 	we can find out comments &amp; definitions that are used only by them."	| considered ids |	considered := Set new: ( nameSpacesToRemove size * 2 ).	ids := ( nameSpacesToRemove collect: [ :ns | ns primaryKey ] ) asSet.	nameSpacesToRemove do: 		[ :ns | 	| definitionID nameSpaces |		definitionID := ns commentID.		( definitionID isZero or: [ considered includes: definitionID ] )			ifFalse: 				[ considered add: definitionID.				nameSpaces := self nameSpacesReferingToComment: definitionID.				nameSpaces detect:  					[ :nID | ( ids includes: nID ) not ] ifNone: [ definitionsToRemove add: definitionID ].				].			definitionID := ns definitionID.			( definitionID isZero or: [ considered includes: definitionID ] )				ifFalse: 					[ considered add: definitionID.					nameSpaces := self nameSpacesReferingTo: definitionID.					nameSpaces detect:  						[ :cID | ( ids includes: cID ) not ] ifNone: [ definitionsToRemove add: definitionID ].					]		]</body><body package="Store-Database" selector="collectNameSpacesFrom:">collectNameSpacesFrom: packageIDs	"First check all namespaces defined in packages. If a namespace is used only by packages 	that are to be removed then mark it for removal." 	nameSpacesToRemove :=		( PkgNameSpaces allInstancesInAndOnlyIn: packageIDs ) collect: [ :id | NameSpaceRecord aRecordWithID: id ].</body><body package="Store-Database" selector="performAdoptionFor:class:">performAdoptionFor: aCollectionOfPairs class: aClass 	"Change parent relationship to reflect removed records"	aCollectionOfPairs do: 		[ :arr | 	| rec |		rec := aClass aRecordWithID: (arr at: 1).		rec updateTrace: (arr at: 2)		]</body><body package="Store-Database" selector="removeRecords">removeRecords	"Perform removes and updates."	| connection res |	connection := DBObject connection.	res := false.		[ connection begin.	definitionsToRemove do: [:defID | Blob removeAllDBRecordsForID: defID].	binaryDefinitionsToRemove do: [:defID | BinaryBlob removeAllDBRecordsForID: defID]."	methodsToRemove do: [ :rec | rec removeRecordFromDB].  	dataToRemove do: [ :rec | rec removeRecordFromDB]. 	classesToRemove do: [ :rec | rec removeRecordFromDB ].	nameSpacesToRemove do: [ :rec | rec removeRecordFromDB ].	parcelRecordsToRemove do: [ :rec | rec removeRecordFromDB ]."	Method removeRecordsFromDB: methodsToRemove.	DataElement removeRecordsFromDB: dataToRemove.	ClassRecord removeRecordsFromDB: classesToRemove.	NameSpaceRecord removeRecordsFromDB: nameSpacesToRemove.	ParcelRecord removeRecordsFromDB: parcelRecordsToRemove.	packagesToRemove do: 		[ :rec | 		rec removeRecordFromDB.		Methods removeAllConnectedTo: rec primaryKey.		Data removeAllConnectedTo: rec primaryKey.		PkgClasses removeAllConnectedTo: rec primaryKey.		PkgNameSpaces removeAllConnectedTo: rec primaryKey.		Blessing removeAllAttachedToPundle: rec 		].	bundlesToRemove do:		[ :rec |		rec removeRecordFromDB.		Bundles removeAllConnectedTo: rec primaryKey.		Packages removeAllConnectedTo: rec primaryKey.		Files removeAllConnectedTo: rec primaryKey.		Blessing removeAllAttachedToPundle: rec		].	self performAdoptionFor: packagesToAdopt class: Package.	self performAdoptionFor: bundlesToAdopt class: Bundle.	self performAdoptionFor: classesToAdopt class: ClassRecord.	self performAdoptionFor: nameSpacesToAdopt class: NameSpaceRecord.	self performAdoptionFor:  methodsToAdopt class: Method.	self performAdoptionFor:  dataToAdopt class: DataElement.	connection commit.	res := true	] ifCurtailed:	[ connection rollback ].	res 			ifTrue: 			[ "Remove files associated with binary packages."			packagesToRemove do: 				[ :pkg | 	| fn |				fn := pkg fileNameForBinVersion.				fn notNil ifTrue: [ fn delete ]				]			]</body><body package="Store-Database" selector="substituteParentsFor:">substituteParentsFor: removedRecords	"Given a collection of records to remove collect those that will	become orphans. 	Answer a list of pairs of  each orphan and new parent (childID, newParentID).."	| recordsToAdopt rIDs |	recordsToAdopt := List new.	rIDs := ( removedRecords collect: [ :r | r primaryKey ] ) asSet.	removedRecords do: 		[ :record |  | parentID children |		parentID := record dbTrace.		"Find a parent which is not going to be removed."		[ parentID notNil and: [ parentID isZero not and: [ rIDs includes: parentID ] ] ] whileTrue: 			[ | rec |			rec := record class aRecordWithID: parentID.			parentID := rec dbTrace			].		children := record children.		children do: 			[ :child | 			"If a child is going to be removed, skip it."			( rIDs includes: child primaryKey )				ifFalse: [ recordsToAdopt add: ( Array with: child primaryKey with: parentID ) ]			]		].	^recordsToAdopt</body></methods><methods><class-id>Store.GarbageCollector class</class-id> <category>instance creation</category><body package="Store-Database" selector="new">new	^super new initialize</body><body package="Store-Database" selector="removeBundles:packages:">removeBundles: bundles packages: packages	"Remove the bundles and packages from the physical store."		self new		bundlesToRemove: bundles;		packagesToRemove: packages;		collectGarbage.</body></methods><methods><class-id>Store.GarbageCollector class</class-id> <category>private</category><body package="Store-Database" selector="affectedBundles:">affectedBundles: items	"Answer a set of  bundles that  would be invalidated by the removal of items."		| affectedBundles |	affectedBundles := Set new.	items do:		[ :pundle |		affectedBundles addAll: 			( pundle allEnclosingComponents select:				[ :b | ( items includes: b ) not ]			)		].	^affectedBundles</body></methods><methods><class-id>Store.MismatchedDatabaseError</class-id> <category>printing</category><body package="Store-Base" selector="defaultMessageText">defaultMessageText	^parameter == nil		ifTrue:			[ 'The image is not reconciled with the current database.' ] 		ifFalse: 			[ '&lt;1s&gt; is in (&lt;2s&gt;). The current database is &lt;3s&gt;.'				expandMacrosWith: parameter name 				with: parameter allDatabases printString				with: DbRegistry databaseIdentifier			]</body></methods><methods><class-id>Store.MergeData</class-id> <category>accessing</category><body package="Store-Merge" selector="affectedPackages">affectedPackages	"Answer a collection of image packages that were affected by applying modifications."	"Meaning, that they have modifications that will be lost."	| pkgs |	trees isNil ifTrue: [^#()].	pkgs := Set new.	trees do: 		[ :tree |   | node imPkg |		node := tree at: 1.		imPkg := Registry packageNamed: node package name.		( imPkg notNil and: [ imPkg hasBeenModified ] )				ifTrue: [ pkgs add: imPkg ]		].	^pkgs asArray</body><body package="Store-Merge" selector="doMerge">doMerge	"For each tree divide nodes into level. For each level calculate the 	difference between the node and its parent."	1 to: trees size do: 		[ :anIndex |  | each root mLevel |		each := trees at: anIndex.		root := each at: 2.		mLevel := root maxLevel.		Notice show: 'Collecting changes for: ' , root package name , '			     (' , anIndex printString , '/' , trees size printString , ')' while: 			[ mLevel to: 1 by: -1 	do: 				[ :cLevel |  | coll |				coll := root nodesAtLevel: cLevel.				coll do: 	[ :pv | self modificationsFor: pv tree: root ]				]			]		].	self removeNoopModifications.	self initModificationSets</body><body package="Store-Merge" selector="initialModForTag:">initialModForTag: aTag 	| imods |	imods := OrderedCollection new.	trees do: 		[ :tree |  | init record |		init := ( self parentNode: tree ) package.		record := init ownRecordForTag: aTag.		record notNil 			ifTrue: [ imods add: ( Modification tag: aTag package: init record: record ) ]		].	^imods size = 0		ifTrue: [ Modification tag: aTag package: nil record: nil ]		ifFalse: 			[ imods size = 1				ifTrue: [ imods first ]				ifFalse: 					[ imods detect: [:imod | imod package isLoaded ]							ifNone: 								[ | least |								imods inject: imods first key + 1 into: [:lkey :imod | imod key &lt; lkey									ifTrue: 										[ least := imod.										imod key]									ifFalse: [ lkey ]								].					least					]				]		]</body><body package="Store-Merge" selector="integratedVersions">integratedVersions	^integratedVersions</body><body package="Store-Merge" selector="mergeIntegrationReadyOfPackageNames:">mergeIntegrationReadyOfPackageNames: aCollectionOfPackageNames 	self reset.	aCollectionOfPackageNames		do: 			[:pkgName | 			| integrationReady |			integrationReady := Policies mergePolicy versionsReadyForIntegration: pkgName.			self addPackageNamed: pkgName mergeVersions: integrationReady]</body><body package="Store-Merge" selector="mergePackageVersions:">mergePackageVersions: aCollectionOfPackageVersions 	| map |	self reset.	map := Dictionary new.	aCollectionOfPackageVersions do: 		[ :pkg | ( map at: pkg name ifAbsent: [ map at: pkg name put: Set new ] ) add: pkg ].	map keysAndValuesDo: 		[ :pkgName :pkgs |  | versions |		"added to catch bundle/package with same name"		( versions := pkgs select: [ :pkg | pkg isPackage ] ) isEmpty			ifFalse: [ self addPackageNamed: pkgName mergeVersions: versions ].		( versions := pkgs select: [ :pkg | pkg isBundle ] ) isEmpty			ifFalse: [ self addPackageNamed: pkgName mergeVersions: versions ].		]</body><body package="Store-Merge" selector="modificationSets">modificationSets	| ms mods |	ms := OrderedCollection new.	AbstractTag classTagIndices, AbstractTag nameSpaceTagIndices do: 		[:inx | 		modifications keysAndValuesDo: 			[:sym :changes | 			mods := changes at: inx.			(mods notNil and: [mods isEmpty not]) 				ifTrue: [ ms add: mods ]			]		].	AbstractTag subdefTagIndices do: 		[:inx |  		modifications keysAndValuesDo: 			[:classSym :classMods | 			mods := classMods at: inx.			mods keysAndValuesDo: 				[ :selector :methMods | 				(methMods notNil and: [methMods isEmpty not]) 					ifTrue: [ ms add: (methMods) ]				]			]		].	^ms</body><body package="Store-Merge" selector="packages">packages	"Answer a collection of image packages that 	are included in this set of merge data"	| pkgs |	pkgs := Set new.	trees isNil ifTrue: [^#()].	trees		do: 			[:tree | 			| node imPkg |			node := tree at: 1.			imPkg := Registry packageNamed: node package name.			imPkg notNil				ifTrue: [pkgs add: imPkg]].	^pkgs asArray</body><body package="Store-Merge" selector="resolutionForTag:">resolutionForTag: aTag 	"Return a record from the resolution for aTag. 	If there is no modification or no resoultion entry return nil."	| modSet |	modSet := self modsForTag: aTag create: false.	^modSet isNil		ifTrue: [nil]		ifFalse: [modSet resolution]</body><body package="Store-Merge" selector="resolutionRecordForTag:packageNamed:">resolutionRecordForTag: aTag packageNamed: aName 	"Answer a record describing resolution for aTag. 	Answer nil if the resolution package in not a varsion 	of package named aName."	| res |	res := self resolutionForTag: aTag.	^(res isNil or: [res packageName ~= aName])		ifTrue: [nil]		ifFalse: [res record]</body><body package="Store-Merge" selector="trees">trees	^trees</body></methods><methods><class-id>Store.MergeData</class-id> <category>initialize-release</category><body package="Store-Merge" selector="initialize">initialize	self reset</body><body package="Store-Merge" selector="reset">reset	modifications := IdentityDictionary new: 500.	integratedVersions := OrderedCollection new.	trees := OrderedCollection new.</body></methods><methods><class-id>Store.MergeData</class-id> <category>private</category><body package="Store-Merge" selector="addMod:node:">addMod: aMod node: aNode 	| mods |	mods := self modsForTag: aMod tag create: true.	(self conflictsWith: mods node: aNode)		ifTrue: [mods addMod: aMod]</body><body package="Store-Merge" selector="addPackageNamed:mergeVersions:">addPackageNamed: aPackageName mergeVersions: aPackageVersionCollection 	"Reverted to 12.4 - for image changes in merge tool merge with 14.6"	"Specify that 'aPackageVersionCollection' are the package 	versions of 'aPackageName' to be merged."	"Implemented as follows: 	Add these versions to the list of those integrated. 	Compute the in DB initial version of the package, 	and the it into a version node. 	If the package is not in the image add the whole 	contents as modifications, then create the image	package (with the initial package as the trace). 	Build the tree of packages to be merged. 	And add the the trees to integrate."	| imPkg initPkg initNode readyNode |	integratedVersions addAll: aPackageVersionCollection.	imPkg := ( aPackageVersionCollection asOrderedCollection first ) getImagePundle.	( imPkg == nil or: [ imPkg validateDatabaseId ] )		ifFalse: [ imPkg raiseMismatchedSignal ].	initPkg := imPkg isNil				ifTrue: [ self mostRecentlyPublished: aPackageVersionCollection ]				ifFalse: [ imPkg tracePackage ].	initPkg isNil ifTrue: [self error: 'Package version of ' , aPackageName printString , ' does not exist'].	initNode := VersionNode on: initPkg.	imPkg isNil		ifTrue: 			[ "why? self class noLoadedVersionSignal raiseRequestWith:  initPkg"			( initPkg class imageClass emptyFrom:  initPkg) do: 				[ :mod | self addMod: mod node: initNode ]			].	readyNode := initNode buildTree: aPackageVersionCollection.	trees add: (Array with: initNode with: readyNode)</body><body package="Store-Merge" selector="conflictsWith:node:">conflictsWith: mods node: aNode 	"If any of the modifications are from a child 	of aNode then there is no new conflict."	mods modificationsDo: [:mod | (mod isPublishedModification and: [(aNode nodeContainingVersion: mod key) notNil]) ifTrue: [^false]].	^true</body><body package="Store-Merge" selector="initModificationSets">initModificationSets	| ms mods |	ms := OrderedCollection new.	AbstractTag classTagIndices, AbstractTag nameSpaceTagIndices do: 		[ :inx | 		modifications keysAndValuesDo: 			[:sym : changes | 			mods := changes at: inx.			mods notNil  ifTrue: [ mods analyzeMods ]			]		].	AbstractTag subdefTagIndices do: 		[:inx | 		modifications keysAndValuesDo: 			[:sym :changes | 			mods := changes at: inx.			mods keysAndValuesDo: 				[ :selector :methMods | 				methMods notNil  ifTrue: [ methMods analyzeMods ]				]			]		].	^ms</body><body package="Store-Merge" selector="modificationsFor:tree:">modificationsFor: aNode tree: root 	"Register all the differences between 'aNode' and 'root'."	| diff  |	diff := PackageDifferences with: aNode package with: aNode parent package.	diff basicModifications do: [:mod | self addMod: mod node: aNode].</body><body package="Store-Merge" selector="modsForTag:create:">modsForTag: aTag create: createBoolean 	"Return modification information for the tag 'aTag'. 	If there is no modification entry, create entry if 	'createBoolean' is true and return nil if it is false."	| cmods mods index |	cmods := modifications at: aTag symbol ifAbsent: 		[ createBoolean			ifFalse: [ ^nil ]			ifTrue: 				[ | xx |				xx := Array new: AbstractTag maxTagIndex.				AbstractTag subdefTagIndices do: 					[ :inx | xx at: inx put: IdentityDictionary new ].				modifications at: aTag symbol put: xx.				xx				]		].	index := aTag tagIndex.	mods := cmods at: index.	^aTag isSubdefTag		ifTrue: 			[ mods at: aTag symbolKey ifAbsent: 				[ createBoolean					ifTrue: 						[ | xx |						xx := ModificationSet tag: aTag initial: ( self initialModForTag: aTag ).						mods at: aTag symbolKey put: xx.						xx						]					ifFalse: [ nil ]				]			]		ifFalse: [mods isNil				ifTrue: [createBoolean						ifTrue: 							[| xx |							xx := ModificationSet tag: aTag initial: (self initialModForTag: aTag).							cmods at: index put: xx.							xx]						ifFalse: [nil]]				ifFalse: [mods]]</body><body package="Store-Merge" selector="mostRecentlyPublished:">mostRecentlyPublished: aCollectionOfDbVersions	"Answer the most recently published of a from the collection."	"NOTE: image versions are not allowed in the list."	| max |	max := aCollectionOfDbVersions asOrderedCollection first.	aCollectionOfDbVersions do:		[ :ver | 		ver primaryKey &gt; max primaryKey			ifTrue: [ max := ver ]		].	^max.</body><body package="Store-Merge" selector="parentNode:">parentNode: list	"Answer the parent from a collection of trees."	^list 		detect: [ :tree | tree parent == nil ]		ifNone: [ trees first ]</body><body package="Store-Merge" selector="removeNoopModifications">removeNoopModifications	| toRemoveClass toRemoveMeth |	toRemoveClass := Set new.	modifications keysAndValuesDo: 			[ :cName :cmods | 			AbstractTag classTagIndices, AbstractTag nameSpaceTagIndices do: 				[ :inx | 	| modSet |				modSet := cmods at: inx.				( modSet notNil and: [ modSet isNoop ] )					ifTrue: [ cmods at: inx put: nil ]				].			AbstractTag subdefTagIndices do: 				[ :inx |  | modDict |				toRemoveMeth := Set new.				modDict := cmods at: inx.				modDict keysAndValuesDo: 					[ :sym :mmods | ( mmods notNil and: [ mmods isNoop ] )							ifTrue: [ toRemoveMeth add: sym ]					].					toRemoveMeth do: [ :sym | modDict removeKey: sym ]				].			cmods detect: [ :mod | mod notNil and: [ mod isEmpty not ] ]				ifNone: [ toRemoveClass add: cName ]			].	toRemoveClass do: [ :cName | modifications removeKey: cName ]</body></methods><methods><class-id>Store.MergeData class</class-id> <category>instance-creation</category><body package="Store-Merge" selector="new">new		^super new initialize</body></methods><methods><class-id>Store.MergeData class</class-id> <category>Signal constants</category><body package="Store-Merge" selector="noLoadedVersionSignal">noLoadedVersionSignal		^MergeTool noLoadedVersionSignal</body></methods><methods><class-id>Store.PundleChanges</class-id> <category>printing</category><body package="Store-Change Management" selector="printOn:">printOn: aStream	aStream nextPutAll: 		( 'Changes for &lt;1s&gt; (&lt;2s&gt;/&lt;3s&gt;)' expandMacrosWithArguments: 			( Array 				with: pundle1  name				with: pundle1 version				with: pundle2 version			)		)</body></methods><methods><class-id>Store.PundleChanges</class-id> <category>private</category><body package="Store-Change Management" selector="addOtherChanges">addOtherChanges	"Add other changes to the changesets."	| props1 props2 |	props1 := pundle1 propertiesForFileOut.	props2 := pundle2 propertiesForFileOut.	props1 associationsDo:		[ :assoc |		( ( props2 includesKey: assoc key ) and: [ assoc value = ( props2 at: assoc key ) ] )			ifFalse: 				[ changeSet1 addPropertyChange: assoc key. 				 changeSet2 addPropertyChange: assoc key. 				]		].	props2 associationsDo:		[ :assoc |		( props1 includesKey: assoc key )			ifFalse: 				[ changeSet1 addPropertyChange: assoc key. 				 changeSet2 addPropertyChange: assoc key.				]		].	IncrementNotification raiseSignal.</body></methods><methods><class-id>Store.PundleChanges</class-id> <category>accessing</category><body package="Store-Change Management" selector="changeSet1">changeSet1	"Answer the change set 'belonging' to  package1. That is, changes that	when applied to package2 will result in package1."	^changeSet1</body><body package="Store-Change Management" selector="changeSet2">changeSet2	"Answer the change set 'belonging' to  package2. That is, changes that	when applied to package1 will result in package2."	^changeSet2</body><body package="Store-Change Management" selector="changeSetFor:">changeSetFor: anInteger	^anInteger == 1		ifTrue: [ changeSet1 ]		ifFalse: [ changeSet2 ].</body><body package="Store-Change Management" selector="otherPackageFor:">otherPackageFor: anInteger	^anInteger == 1		ifTrue: [ pundle2 ]		ifFalse: [ pundle1 ].</body><body package="Store-Change Management" selector="otherPundleFor:">otherPundleFor: anInteger	^anInteger == 1		ifTrue: [ pundle2 ]		ifFalse: [ pundle1 ].</body><body package="Store-Change Management" selector="pundle1">pundle1	^pundle1</body><body package="Store-Change Management" selector="pundle2">pundle2	^pundle2</body><body package="Store-Change Management" selector="pundleFor:">pundleFor: anInteger	^anInteger == 1		ifTrue: [ pundle1 ]		ifFalse: [ pundle2 ].</body></methods><methods><class-id>Store.PundleChanges</class-id> <category>initialization</category><body package="Store-Change Management" selector="fromPackageDifferences:">fromPackageDifferences: pkgDiffs	pundle1 := pkgDiffs pkgSide: 1.	pundle2 := pkgDiffs pkgSide: 2.	changeSet2 := pkgDiffs changeSet.	changeSet1 := changeSet2 reflection.	self addOtherChanges.</body><body package="Store-Change Management" selector="recurseChanges">recurseChanges	"Only required for bundles"</body><body package="Store-Change Management" selector="reflectChangesFrom:">reflectChangesFrom: changeSet	"Answer a changeSet that reflects the changes in changeSet."	^changeSet reflection.</body><body package="Store-Change Management" selector="with:parent:">with: aPackage parent: bPackage	"Initialize the receiver for comparing aPackage with bPackage where it can be assumed	that aPackage's changeset reflects all the changes between them."	pundle1 := aPackage.	pundle2 := bPackage.	changeSet1 := aPackage changeSet.	changeSet2 := self reflectChangesFrom: changeSet1.</body><body package="Store-Change Management" selector="with:with:">with: aPackage with: bPackage	"Initialize the receiver for comparing aPackage with bPackage."	pundle1 := aPackage.	pundle2 := bPackage.	changeSet1 := XChangeSet new.	changeSet2 := XChangeSet new.	( pundle1 sameVersionAs: pundle2 )		ifFalse:			[ [ self requiresFullCompare				ifTrue:					[ Notice 						showProgress:  ( 'Comparing versions of package &lt;1s&gt;.'  											expandMacrosWith: pundle1 name )						complete: self calcItemCount 						while: [ self calcuateChanges ]						title: 'Store'.					]				ifFalse: [ self calcuateChanges ].			  ] on: DbRegistry errorSignals do: [ :ex | ex outer ].			]</body></methods><methods><class-id>Store.PundleChanges</class-id> <category>fileout</category><body package="Store-Change Management" selector="changedPropertiesFor:">changedPropertiesFor: id	| props all |	props := IdentityDictionary new.	all := ( self pundleFor: id ) properties.	( self changeSetFor: id ) properties do:		[ :key | props at: key put: ( all at: key ifAbsent: [ ] ) ].	^props.</body><body package="Store-Change Management" selector="fileOutChangesFor:">fileOutChangesFor: id	| fileName stream |	fileName := ( self pundleFor: id ) name.	fileName := Dialog			requestNewFileName: 'File out changes on'			default: (Filename filterFilename: fileName, '-diffs.st'). 	fileName isEmpty ifTrue: [ ^nil ].	stream := SourceCodeStream  write: fileName.	self recurseChanges.		"ensure we get the whole thing."	[ Notice 		showProgress:  ( 'Filing out &lt;1s&gt; changes.'  expandMacrosWith: pundle1 name )		complete: self itemCount 		while:			[ stream timeStamp. 			stream addComment: 				( 'Changes from: &lt;1s&gt;  to: &lt;2s&gt;' 					expandMacrosWith: ( self otherPundleFor: id ) displayString 					with: ( self pundleFor: id ) displayString ).			stream deferInitializations.			self fileOutChangesFor: id on: stream.			stream finishInitializations] 		title: 'Store'	] ensure: [ stream close ].</body><body package="Store-Change Management" selector="fileOutChangesFor:on:">fileOutChangesFor: id on: stream	self fileOutChangesFor: id within: nil on: stream</body></methods><methods><class-id>Store.PundleChanges</class-id> <category>testing</category><body package="Store-Change Management" selector="requiresFullCompare">requiresFullCompare	"Answer true if a source code comparison is neccessary, false if a db compare is good enough."		( pundle1 isLoaded and: 			[ pundle1 hasTrace not or: [ pundle1 userWantsFullCompare ] ] 	)		ifTrue: [ ^true ].	( pundle2 isLoaded and:			[ pundle2 hasTrace not or: [ pundle2 userWantsFullCompare ] ]	)		ifTrue: [ ^true ].		^false</body></methods><methods><class-id>Store.PundleChanges class</class-id> <category>instance creation</category><body package="Store-Change Management" selector="fromPackageDifferences:">fromPackageDifferences: pkgDiffs	^self basicNew fromPackageDifferences: pkgDiffs.</body><body package="Store-Change Management" selector="new">new	"Use #with:with: "	^self shouldNotImplement</body><body package="Store-Change Management" selector="with:parent:">with: pkg1 parent: pkg2	^self basicNew		with: pkg1 parent: pkg2;		yourself.</body><body package="Store-Change Management" selector="with:with:">with: pkg1 with: pkg2	^( pkg1 isLoaded and: [ pkg1 dbTrace == pkg2 primaryKey ] )		ifTrue: [ self  with: pkg1 parent: pkg2 ]		ifFalse: [ self basicNew with: pkg1 with: pkg2 ]</body></methods><methods><class-id>Store.ClassLoader</class-id> <category>interface opening</category><body package="Store-UI" selector="openForClass:package:">openForClass: aClass package: aPackage	self class: aClass; package: aPackage.	self openInterface: #loadDialog</body><body package="Store-UI" selector="postOpenWith:">postOpenWith: aBuilder 	aBuilder window label: 'Loader For: ', class fullName.</body></methods><methods><class-id>Store.ClassLoader</class-id> <category>aspects</category><body package="Store-UI" selector="cdefinition">cdefinition	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^cdefinition isNil		ifTrue:			[cdefinition := false asValue]		ifFalse:			[cdefinition]</body><body package="Store-UI" selector="cmethods">cmethods	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^cmethods isNil		ifTrue:			[cmethods := false asValue]		ifFalse:			[cmethods]</body><body package="Store-UI" selector="idefinition">idefinition	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^idefinition isNil		ifTrue:			[idefinition := false asValue]		ifFalse:			[idefinition]</body><body package="Store-UI" selector="imethods">imethods	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^imethods isNil		ifTrue:			[imethods := false asValue]		ifFalse:			[imethods]</body></methods><methods><class-id>Store.ClassLoader</class-id> <category>accessing</category><body package="Store-UI" selector="class:">class: aClass	class := aClass</body><body package="Store-UI" selector="componentsToLoadOnSide:">componentsToLoadOnSide: aBoolean	"If aBoolean is true answer the instance side."	| comp |	comp := Set new.	aBoolean 		ifTrue: 			[ self cmethods value 				ifTrue: [ comp add: #methods ] 			]		ifFalse: 			[ self idefinition value ifTrue: [ comp add: #definition ].			self imethods value ifTrue: [ comp add: #methods ].			self comment value ifTrue: [ comp add: #comment ].			self data value ifTrue: [ comp add: #data ].			].	^comp</body></methods><methods><class-id>Store.ClassLoader</class-id> <category>actions</category><body package="Store-UI" selector="loadAll">loadAll	self idefinition value: true.	self comment value: true.	self imethods value: true.	self cdefinition value: true.	self cmethods value: true.	self data value: true.	self loadChoosen</body></methods><methods><class-id>Store.ClassLoader class</class-id> <category>interface opening</category><body package="Store-UI" selector="openForClass:package:">openForClass: aClass package: aPackage	| baby |	baby := self new.	baby class: aClass; package: aPackage.	self openOn: baby withSpec: #loadDialog</body></methods><methods><class-id>Store.BundleChanges</class-id> <category>private</category><body package="Store-Change Management" selector="addComponentChanges">addComponentChanges	componentChanges := self compareComponents collect:		[ :array |		array first pundleChangesClass			with: array first with: array last.		]</body><body package="Store-Change Management" selector="addComponentChangesNonRecursive">addComponentChangesNonRecursive	| items1 items2 |	items1 := pundle1 	containedItems.	items2 := pundle2 	containedItems.	items1 do:		[ :pundle |		items2 detect: 			[ :i | ( i isBundle == pundle isBundle ) and: [ i name = pundle name ] ]				ifNone: 					[ changeSet1 addOtherChange: BundleModel structureMark.					changeSet2 addOtherChange: BundleModel structureMark.					]			].	items2 do:		[ :pundle |		items1 detect: 			[ :i | ( i isBundle == pundle isBundle ) and: [ i name = pundle name ] ] 				ifNone: 					[ changeSet2 addOtherChange: BundleModel structureMark.					changeSet1 addOtherChange: BundleModel structureMark.					]		].</body><body package="Store-Change Management" selector="addOtherChanges">addOtherChanges	"Add other changes to the changesets."	super addOtherChanges.	self addStructureChanges.</body><body package="Store-Change Management" selector="addStructureChanges">addStructureChanges	pundle1 structure = pundle2 structure		ifFalse:			[ changeSet1 addOtherChange: BundleModel structureMark.			changeSet2 addOtherChange: BundleModel structureMark.			].</body><body package="Store-Change Management" selector="calcuateChanges">calcuateChanges	self addComponentChanges.	self addOtherChanges.</body><body package="Store-Change Management" selector="calculateChangesNonRecursive">calculateChangesNonRecursive"	self addComponentChangesNonRecursive. "	self addOtherChanges.</body><body package="Store-Change Management" selector="compareComponents">compareComponents	"Compare the packages contained in the two bundles. Answer a collection of paired packages."	| diffs pdict bdict |	pdict := Dictionary new.	bdict := Dictionary new.	diffs := OrderedCollection new.	pundle2 allItems do: 		[ :pkg | pkg isPackage 					ifTrue: [ pdict at: pkg name put: pkg ]					ifFalse: [ bdict at: pkg name put: pkg ]		].	pundle1 allItems do: 		[ :pkg | 	| other dict |		dict := pkg isPackage ifTrue: [ pdict ] ifFalse: [ bdict ].		other := dict at: pkg name ifAbsent: [ PseudoPackage fromPackage: pkg ].		( other sameVersionAs: pkg )			ifFalse: [ diffs add: ( Array with: pkg with: other ) ].		dict removeKey: pkg  name ifAbsent: [ ].		].	pdict do: [ :pkg | diffs add: ( Array with: ( PseudoPackage fromPackage: pkg ) with: pkg ) ].	bdict do: [ :pkg | diffs add: ( Array with: ( PseudoPackage fromPackage: pkg ) with: pkg ) ].	^diffs</body><body package="Store-Change Management" selector="comparePackages">comparePackages	"Compare the packages contained in the two bundles. Answer a collection of paired packages."	| dict diffs |	dict := Dictionary new.	diffs := OrderedCollection new.	pundle2 allItems do: [ :pkg | dict at: pkg name put: pkg ].	pundle1 allItems do: 		[ :pkg | 	| other |		other := dict at: pkg name					ifAbsent:						[ diffs add: ( Array with: pkg with: nil ).						nil						].		other notNil			ifTrue: 				[ ( other sameVersionAs: pkg )					ifFalse: [ diffs add: ( Array with: pkg with: other ) ].				dict at: pkg name put: nil				]		].	dict do: [ :pkg | pkg notNil ifTrue: [ diffs add: ( Array with: nil with: pkg ) ] ].	^diffs</body></methods><methods><class-id>Store.BundleChanges</class-id> <category>initialization</category><body package="Store-Change Management" selector="recurseChanges">recurseChanges	"Calculate the changes for the bundle's subcomponents. Not always neccessary."	componentChanges == nil		ifFalse: [ ^self ].	self requiresFullCompare		ifTrue: [ self addComponentChanges ]		ifFalse:			[ Notice 				showProgress:  					( 'Comparing &lt;1s&gt; with &lt;2s&gt;.'  							expandMacrosWith: pundle1 displayString 							with: pundle2 displayString 					 )				complete: self calcItemCount 				while: [ self addComponentChanges ]				title: 'Store'.			].</body><body package="Store-Change Management" selector="with:with:">with: aBundle with: bBundle	pundle1 := aBundle.	pundle2 := bBundle.	changeSet1 := XChangeSet new.	changeSet2 := XChangeSet new.	[ self calculateChangesNonRecursive ] 		on: DbRegistry errorSignals do: [ :ex | ex outer ].</body></methods><methods><class-id>Store.BundleChanges</class-id> <category>fileout</category><body package="Store-Change Management" selector="fileOutChangesFor:on:">fileOutChangesFor: id on: stream	self fileOutChangesFor: id within: ( self pundleFor: id ) on: stream</body><body package="Store-Change Management" selector="fileOutChangesFor:within:on:">fileOutChangesFor: id within: aBundle on: stream	| bundle |	bundle := self pundleFor: id.	componentChanges == nil		ifFalse: 			[ | block |			block := [ componentChanges do: 							[ :comp | comp fileOutChangesFor: id within: aBundle on: stream ] ].			self requiresFullCompare				ifTrue: [ block value ]				ifFalse:					[ Notice showProgress:  ( 'Filing out &lt;1s&gt; changes.'  expandMacrosWith: pundle1 name )						complete: self itemCount 						while: block						title: 'Store'.					].			].	( ( UISettings preferenceFor: #fileoutOption ) == #never )		ifFalse: 			[ bundle fileOutProperties: ( self changedPropertiesFor: id ) on: stream.			( ( self changeSetFor: id ) otherChangesInclude: BundleModel structureMark ) 				ifTrue: [ ( BundleStructureChange new component: bundle ) fileOutOn: stream ].			].</body></methods><methods><class-id>Store.BundleChanges</class-id> <category>accessing</category><body package="Store-Change Management" selector="calcItemCount">calcItemCount	^self requiresFullCompare		ifTrue: 			[ componentChanges inject: componentChanges size into: 				[ :count  :cc | count + cc calcItemCount ]				]		ifFalse: [ pundle1 leafItems size * 2 + 1 ].</body><body package="Store-Change Management" selector="itemCount">itemCount	componentChanges == nil		ifTrue: [ ^1 ].	^componentChanges 		inject: componentChanges size		into: [ :count :cc | count + cc itemCount ].</body></methods><methods><class-id>Store.ElementProxy</class-id> <category>relationships</category><body package="Store-UI-Graphs" selector="elementRelatedBy:">elementRelatedBy: relToken 	^element relatedBy: relToken</body><body package="Store-UI-Graphs" selector="relatedBy:">relatedBy: relToken 	^related at: relToken		ifAbsent: 			[| bag relElems |			relElems := self elementRelatedBy: relToken.			bag := Set new.			relElems do: [:elem | bag add: (self class element: elem cache: cache)].			related at: relToken put: bag]</body><body package="Store-UI-Graphs" selector="stringKey:">stringKey: hints	^element stringKey: hints</body></methods><methods><class-id>Store.ElementProxy</class-id> <category>initialize-release</category><body package="Store-UI-Graphs" selector="element:cache:">element: anElement cache: aCache	element := anElement.	cache := aCache.	related := IdentityDictionary new.</body></methods><methods><class-id>Store.ElementProxy</class-id> <category>accessing</category><body package="Store-UI-Graphs" selector="element">element	^element</body><body package="Store-UI-Graphs" selector="itemString">itemString	^element itemString</body></methods><methods><class-id>Store.ElementProxy</class-id> <category>printing</category><body package="Store-UI-Graphs" selector="printOn:">printOn: aStream	aStream nextPut: ${.	element printOn: aStream.	aStream nextPut: $}.	^self</body></methods><methods><class-id>Store.ElementProxy class</class-id> <category>instance creation</category><body package="Store-UI-Graphs" selector="element:cache:">element: anElement cache: aCache 	^aCache at: anElement ifAbsent: [aCache at: anElement put: (self new element: anElement cache: aCache)]</body></methods><methods><class-id>Store.GroupElement</class-id> <category>relationships</category><body package="Store-UI-Graphs" selector="elementRelatedBy:">elementRelatedBy: relToken 	"self halt: element, ' -', relToken.""	Transcript show: 'GroupElement token: ', relToken, ' element: ', element printString; cr."	relToken == #tt_containsRel		ifTrue: [ ^DBUserGroup userNamesInGroupNamed: element ].	relToken == #tt_containsRRel		ifTrue: [ ^DBUserGroup groupNamesForUserNamed: element ].	^super relatedBy: relToken.</body><body package="Store-UI-Graphs" selector="stringKey:">stringKey: hints	^element</body></methods><methods><class-id>Store.GroupElement</class-id> <category>accessing</category><body package="Store-UI-Graphs" selector="itemString">itemString	^element</body></methods><methods><class-id>Store.PundleChangeList</class-id> <category>fileIn/Out</category><body package="Store-UI" selector="fileOutOn:">fileOutOn: aSourceCodeStream	| sublist |	sublist := list reject: [ :mod | removed includes: mod ].	aSourceCodeStream deferInitializations.	sublist do: [ :next | next fileOutOn: aSourceCodeStream ].	aSourceCodeStream checkMethodChunkClass: nil protocol: nil.	aSourceCodeStream finishInitializations.</body><body package="Store-UI" selector="includesFileName:">includesFileName: aString	"Answer true if any of the non-removed changes in the list is 	from a file named aString."	^false</body></methods><methods><class-id>Store.PundleChangeList</class-id> <category>private</category><body package="Store-UI" selector="conflictObjectFor:">conflictObjectFor: anItem	"Answer the object to compare to. nil if there is none."	^( self conflictPundle == nil ) 		ifFalse: 			[ conflictCache at: anItem ifAbsentPut:				[ conflictPundle recordForTag: anItem tag ]			]</body><body package="Store-UI" selector="doFrom:">doFrom: firstIndex	"replay all the changes from the supplied index. Reset selection each time through the loop,	 so that if an error occurs, the selection is left at the item which caused it."	DbRegistry isOnlineImage		ifFalse: [ ^Dialog warn: 'Not connected to the database.' ].	super doFrom: firstIndex.</body><body package="Store-UI" selector="doThis:">doThis: listIndex	"Revert the change at listIndex to it's parent and update the entry."	| rec mod |	DbRegistry isOnlineImage		ifFalse: [ ^Dialog warn: 'Not connected to the database.' ].	mod := list at: listIndex.	( rec := self conflictObjectFor: mod ) == nil		ifTrue: [ ^Dialog warn: mod tag name, ' cannot be reverted.' ].	mod isCommentChange		ifTrue: [ rec loadCommentFor: mod tag actual ]		ifFalse:			[ rec loadSrcIntoPackage: mod package confirm: false.			mod package changeSet forgetTag: mod tag.		"just the current one"			mod text: rec definition.			].		self updateSelection: listIndex</body><body package="Store-UI" selector="fieldTemplates">fieldTemplates	"return the templates for the fields (show file etc)"	^#(	#( showComponent showProtocol showConflicts )		#( componentString category conflicts))</body><body package="Store-UI" selector="filterTemplates">filterTemplates	"return the templates for the filters"	^#(	#( filterByPackage filterByType filterByClass filterByProtocol filterBySelector )		#( packageName type className category selector )        )</body></methods><methods><class-id>Store.PundleChangeList</class-id> <category>aspects</category><body package="Store-UI" selector="labelFor:">labelFor: aKey	"Return a label for the existingText view."	| mod protocol conflictString |	aKey == #windowLabel		ifTrue: [ ^self windowLabel ].		conflictString := self conflictPundle == nil		ifTrue: [ 'not connected' ] ifFalse: [ self conflictPundle versionString ]. 	selectionIndex &gt; 0 		ifTrue:			[ mod := self selection.			( aKey == #imageLabel				and: [ mod tag isForMethod				and: [ ( protocol := mod protocol ) notNil ] ]			)				ifTrue: [ '&lt;1s&gt; (', protocol, ')' expandMacrosWith: conflictString ].			].	aKey == #imageLabel 		ifTrue: [ ^'From database: &lt;1s&gt;: &lt;2s&gt;' 					expandMacrosWith: dbIdentifier					with: conflictString 				].	aKey == #changeLabel 		ifTrue: 			[ ^selectionIndex &gt; 0				ifTrue: [ 'From ', mod componentString ]				ifFalse: [ 'Selected Change' ]			].	^nil</body><body package="Store-UI" selector="windowLabel">windowLabel	^pundle == nil		ifTrue: [ 'Pundle Changes List' ]		ifFalse: [ '&lt;1s&gt; &lt;2s&gt; Change List from &lt;3s&gt;' 					expandMacrosWith: pundle name 					with: ( pundle versionStringFor: dbIdentifier ) 					with: dbIdentifier asString				].</body></methods><methods><class-id>Store.PundleChangeList</class-id> <category>accessing</category><body package="Store-UI" selector="conflictPundle">conflictPundle	"Answer the pundle used for comparisons. Defualt is pundle's parent."	conflictPundle == nil		ifTrue: 			[ conflictPundle := pundle parentRecord.			conflictCache := IdentityDictionary new.			 ]		ifFalse: 			[ conflictPundle isInCurrentDatabase				ifFalse:  					[ conflictPundle := pundle parentRecord.	"try to rehook"					conflictCache := IdentityDictionary new.					].			].	^conflictPundle</body><body package="Store-UI" selector="conflictTextFor:">conflictTextFor: anItem	"Asnwer the text to display in the conflict text window."	| obj |	obj := self conflictObjectFor: anItem.	^anItem tag isCommentTag		ifTrue: [ obj comment ]		ifFalse: [ obj text ]</body><body package="Store-UI" selector="dbIdentifier">dbIdentifier	^dbIdentifier</body><body package="Store-UI" selector="dbIdentifier:">dbIdentifier: aSymbol	^dbIdentifier := aSymbol asSymbol</body><body package="Store-UI" selector="noConflictTextFor:">noConflictTextFor: mod 	"Answer a Text corresponding to the conflicting text of the selected item in the system.	This is in fact, the reason why there is no text to compare to. Answer nil if okay to compare."	DbRegistry isOnlineImage		ifFalse: [ ^'Not connected to the database.' ].	( pundle validateDatabaseId not and: [ self conflictPundle == nil ] )		ifTrue: [ ^'Not connected to database: ', dbIdentifier ].	( self conflictPundle isInCurrentDatabase )		ifFalse: [ ^'No longer connected to database: ', conflictPundle dbIdentifier ].		( self conflictObjectFor: mod ) == nil		ifTrue: [ ^( 'not in ', self conflictPundle displayString ) asText emphasizeAllWith: #italic ].	^nil</body><body package="Store-UI" selector="pundle">pundle	^pundle</body><body package="Store-UI" selector="pundle:">pundle: aPundle	pundle := aPundle</body><body package="Store-UI" selector="selectionText">selectionText	"Answer the text of the item currently selected, or nil if none."	| txt |	( txt := super selectionText ) == nil		ifTrue: 			[ txt := ( self selection == nil or: [ self selection existsInPackage ] )				ifFalse: [ 'not in ', self pundle displayString ]				ifTrue: [ '' ]			].	^txt</body></methods><methods><class-id>Store.PundleChangeList</class-id> <category>menu messages</category><body package="Store-UI" selector="findPackage">findPackage	"Prompt and search for all changes of a given package. Select these changes"	self find: #packageName prompt: #package filter: #packageName</body><body package="Store-UI" selector="removeConflictsWithParent">removeConflictsWithParent	"Remove those changes that conflict with the parent."	checkSystem := #exact.	Cursor execute showWhile: 		[ removed addAll: 			( list select: 				[ :mod | | rec |				( removed includes: mod ) not					and: [ ( ( rec := self conflictObjectFor: mod ) == nil							or: [ ( ( rec textRepresentationForTag: mod tag ) = mod text ) not ] )						]				]			)		].	self redisplayList</body><body package="Store-UI" selector="removeEverythingNotInParent">removeEverythingNotInParent	"Remove those changes in methods not in the parent."	checkSystem := #exact.	Cursor execute showWhile: 		[ removed addAll: 			( list select: 				[ :mod | 				( removed includes: mod ) not and: 					[ ( self conflictObjectFor: mod ) == nil ] 				]			)		].	self redisplayList</body><body package="Store-UI" selector="removeMethodsNotInParent">removeMethodsNotInParent	"Remove those changes in methods not in the parent."	checkSystem := #exact.	Cursor execute showWhile: 		[ removed addAll: 			( list select: 				[ :mod | 				( removed includes: mod ) not and: 					[ mod isMethodRelated and: [ ( self conflictObjectFor: mod ) == nil ] ]				]			)		].	self redisplayList</body><body package="Store-UI" selector="removeSameSourceAsParent">removeSameSourceAsParent	"Remove those changes that are exactly the same as the conflict."	checkSystem := #exact.	Cursor execute showWhile: 		[ removed addAll: 			( list reject: 				[ :mod | | rec |				( removed includes: mod )					or: [ ( ( rec := self conflictObjectFor: mod ) == nil							or: [ ( ( rec textRepresentationForTag: mod tag ) = mod text ) not ] )						]				]			)		].	self redisplayList</body></methods><methods><class-id>Store.PundleChangeList</class-id> <category>menu bar actions</category><body package="Store-UI" selector="toggleShowComponent">toggleShowComponent	self fieldMessage: #showComponent</body></methods><methods><class-id>Store.PundleChangeList class</class-id> <category>instance creation</category><body package="Store-UI" selector="openOn:">openOn: aPundle	^self new		pundle: aPundle;		openOn: aPundle modifications</body><body package="Store-UI" selector="openOn:for:">openOn: aPundle for: dbid	^self new		pundle: aPundle;		dbIdentifier: dbid;		openOn: ( aPundle modificationsFor: dbid )</body></methods><methods><class-id>Store.VersionBrowser</class-id> <category>initialize-release</category><body package="Store-UI" selector="initialize">initialize	super initialize.	Registry addDependent: self.</body><body package="Store-UI" selector="release">release	super release.	Registry removeDependent: self.</body></methods><methods><class-id>Store.VersionBrowser</class-id> <category>updating</category><body package="Store-UI" selector="update:with:">update: anAspect with: aParameter 	super update: anAspect with: aParameter.	((anAspect == #removedPundle)		and: [(pundles detect: [:pun | 					pun isBundle = aParameter isBundle and: [pun name = aParameter name]]				ifNone: [nil]) notNil])		ifTrue: [self reloadVersions]</body></methods><methods><class-id>Store.VersionBrowser</class-id> <category>aspects</category><body package="Store-UI" selector="comment">comment	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^comment isNil		ifTrue:			[comment := String new asValue]		ifFalse:			[comment]</body><body package="Store-UI" selector="pundles:">pundles: somePundles	pundles := somePundles</body><body package="Store-UI" selector="setVersionsListFrom:">setVersionsListFrom: aCollectionOfPundles	"Sort list accordingly to the primary key. Make sure 	that image pundle is the first one."	self versions list: aCollectionOfPundles.	labels := nil.</body><body package="Store-UI" selector="versions">versions	"This method was generated by UIDefiner. Any edits made here 	may be lost whenever methods are automatically defined. The 	initialization provided below may have been preempted by an 	initialize method."	versions isNil		ifTrue: 			[versions := MultiSelectionInList new.			versions listHolder onChangeSend: #updateComment to: self].	^versions</body></methods><methods><class-id>Store.VersionBrowser</class-id> <category>selection</category><body package="Store-UI" selector="pundles">pundles	"Answer the selected versions"	^self versions selections</body><body package="Store-UI" selector="pundleVersions">pundleVersions	"Answer the selected versions"	^self versions selections</body></methods><methods><class-id>Store.VersionBrowser</class-id> <category>private-visual blocks</category><body package="Store-UI" selector="blessingLabelForItem:view:">blessingLabelForItem: anItem view: view 	| label |	label := Label with: anItem blessingLevelString.	label attributes: view textStyle.	^label</body><body package="Store-UI" selector="compositeForItem:view:">compositeForItem: anItem view: view 	| cp labelArray |	cp := CompositePart new.	labels isNil ifTrue: [self computeLabelsForView: view].	labelArray := labels at: anItem				ifAbsent: 					[Processor yield.					self computeLabelsForView: view.					labels at: anItem ifAbsent: [^cp]].	1 to: labelArray size do: [:index | cp add: (labelArray at: index)			at: (offsets at: index)					@ 0].	^cp</body><body package="Store-UI" selector="computeLabelsForView:">computeLabelsForView: view 	"Compute all the labels right away so that we know	what offsets to use.  Store the labels so that extra	database accesses are not needed to recompute them."	| max1 max2 |	max1 := max2 := 0.	labels := Dictionary new: self versions list size.	self versions list		do: 			[:anItem | 			| labelArray label |			anItem isLoaded				ifTrue: 					[label := Label with: 'image from: ' , anItem traceVersionString.					label attributes: view textStyle.					labelArray := Array with: label]				ifFalse: 					[labelArray := Array new: 3.					label := self nameLabelForItem: anItem view: view.					labelArray at: 1 put: label.					max1 := max1 max: label width.					label := self blessingLabelForItem: anItem view: view.					labelArray at: 2 put: label.					max2 := max2 max: label width.					label := self timeStampLabelForItem: anItem view: view.					labelArray at: 3 put: label].			labels at: anItem put: labelArray].	offsets := Array with: 6 with: max1 + 16 with: max2 + max1 + 26</body><body package="Store-UI" selector="nameLabelForItem:view:">nameLabelForItem: anItem view: view 	| label text pundle |	text := ( pundles size &gt; 1				ifTrue: [anItem stringKey: #() ]				ifFalse: [ anItem versionString ]			).	anItem isLoaded  not 		ifTrue: 			[ pundle := anItem isPackage				ifTrue: [ Registry packageNamed: anItem name ]				ifFalse: [ Registry bundleNamed: anItem name ].			pundle == nil 				ifFalse: 					[ ( pundle dbTrace ~~ nil and: [ anItem primaryKey &gt; pundle dbTrace ] )						ifTrue: [ text := text asText allBold ]					].			].	label := Label with: text.	label attributes: view textStyle.	^label</body><body package="Store-UI" selector="timeStampLabelForItem:view:">timeStampLabelForItem: anItem view: view 	| label |	label := Label with: anItem timeStampString.	label attributes: view textStyle.	^label</body><body package="Store-UI" selector="versionSelectedVisualBlock">versionSelectedVisualBlock	^	[:view :index | 	| cp pkg rw |	pkg := view sequence at: index.	cp := self compositeForItem: pkg  view: view.	"lb := (LabelAndIcon with: '' attributes: view textStyle) beCheckMark.	cp add: lb at: 0@0."	rw := ReversingWrapper on: cp.	rw reverse setValue: true.	BoundedWrapper on: rw]</body><body package="Store-UI" selector="versionVisualBlock">versionVisualBlock	^	[:view :index | 	| cp pkg |	pkg := view sequence at: index.	cp := self compositeForItem: pkg  view: view.	BoundedWrapper on: cp]</body></methods><methods><class-id>Store.VersionBrowser</class-id> <category>actions</category><body package="Store-UI" selector="reloadVersions">reloadVersions	self		doIfOnlineImage: 			[| list |			list := List new.			pundles				do: 					[:pundle | 					| pm |					pm := pundle isPackage								ifTrue: [Registry packageNamed: pundle name]								ifFalse: [Registry bundleNamed: pundle name].					pm notNil ifTrue: [list add: pm].					list addAll: ((pundle isPackage							ifTrue: [Package]							ifFalse: [Bundle])							allVersionsWithName: pundle name)].			self setVersionsListFrom: list]</body><body package="Store-UI" selector="updatePundleVersion">updatePundleVersion	"Update the selected versions."	| sequenceWidget |	self updateComment.	labels := nil.	sequenceWidget := self widgetAt: #versionList.	self versions selectionIndexes 		do: [:selection | sequenceWidget updateAt: selection].	sequenceWidget invalidate</body></methods><methods><class-id>Store.VersionBrowser</class-id> <category>private</category><body package="Store-UI" selector="listMenu">listMenu	"Add dynamic features to the list menu."	^ self makePundleMenuDynamic: self class listMenuSkeleton.</body></methods><methods><class-id>Store.VersionBrowser</class-id> <category>interface opening</category><body package="Store-UI" selector="postBuildWith:">postBuildWith: aBuilder 	"Replace controller with one with more sanity."	self shiftSelectInComponent: #versionList builder: aBuilder.	(aBuilder componentAt: #versionList) widget visualBlock: self versionVisualBlock.	(aBuilder componentAt: #versionList) widget selectedVisualBlock: self versionSelectedVisualBlock.</body><body package="Store-UI" selector="postOpenWith:">postOpenWith: aBuilder 	"This message is sent by the builder after it has opened a completed 	window."	aBuilder window label: 'Versions of', (pundles inject: '' into: [:name :pun| name, ' ', pun name]).</body></methods><methods><class-id>Store.VersionBrowser</class-id> <category>comment</category><body package="Store-UI" selector="italicText:">italicText: aString	^aString asText emphasizeAllWith: #italic</body><body package="Store-UI" selector="lastPundleVersionComment">lastPundleVersionComment	| lastComment |	versions list isEmpty ifTrue:		[^String new].	lastComment := versions list first comment asString trimBlanks.	^lastComment isEmpty		ifTrue: [self italicText: 'Last published version of this component has no comment.']		ifFalse: [lastComment]</body><body package="Store-UI" selector="updateComment">updateComment	| currentVersion blessings |	DbRegistry isOnline		ifFalse: 			[self comment value: (self italicText: 'Not connected to repository.').			^self].	versions selectionIndexes size &gt; 1		ifTrue: [self comment value: (self italicText: 'Multiple versions are selected.')]		ifFalse: 			[versions selections isEmpty ifTrue: [^self comment value: self lastPundleVersionComment].			currentVersion := versions selections first.			blessings := Blessing blessingsForRecordID: currentVersion primaryKey type: currentVersion typeStringForBlessing.			comment value: ((blessings isNil or: [blessings isEmpty])					ifTrue: [self italicText: 'No blessings.']					ifFalse: [Policies blessingPolicy describeBlessings: blessings])]</body></methods><methods><class-id>Store.VersionBrowser</class-id> <category>pundle actions</category><body package="Store-UI" selector="reconcile">reconcile	super reconcile.	"Ensure that the views are updated."	self updatePundleVersion</body></methods><methods><class-id>Store.VersionBrowser class</class-id> <category>instance creation</category><body package="Store-UI" selector="browseVersionsOfPundle:">browseVersionsOfPundle: pundle	self browseVersionsOfPundles: (Array with: pundle)</body><body package="Store-UI" selector="browseVersionsOfPundles:">browseVersionsOfPundles: pundles 	| tool |	pundles size = 0 ifTrue: [^self error: 'No package or bundle specified'].	DbRegistry doIfOnlineImage: [Cursor wait			showWhile: 				[tool := self new.				tool pundles: pundles.				tool reloadVersions.				self openOn: tool withSpec: 					((UISettings preferenceFor: #ttShowPackageComments)						ifTrue: [#windowSpec]						ifFalse: [#simpleWindowSpec])]]</body></methods><methods><class-id>Store.PublishFileSpecification</class-id> <category>accessing</category><body package="Store-IMG-Configurations" selector="file">file	^object</body><body package="Store-IMG-Configurations" selector="file:">file: aFileName	object := aFileName.</body><body package="Store-IMG-Configurations" selector="name">name	^file name</body><body package="Store-IMG-Configurations" selector="publishFile">publishFile	^self publish</body><body package="Store-IMG-Configurations" selector="publishFile:">publishFile: aBoolean	super publish: aBoolean</body></methods><methods><class-id>Store.PublishFileSpecification</class-id> <category>actions</category><body package="Store-IMG-Configurations" selector="publishSilently">publishSilently	"Publish. Answer false if aborted."	self publish		ifFalse: [ ^true ].	^[ ( self pundle classOfDbRecord newFrom: self pundle userData: self ) == nil		ifTrue: [ ^false ].	true	] on: Store.DbRegistry errorSignals do: [ :ex | ex return: false ].</body></methods><methods><class-id>Store.PublishFileSpecification class</class-id> <category>instance creation</category><body package="Store-IMG-Configurations" selector="new">new	^self basicNew initialize.</body></methods><methods><class-id>Store.PackageEmphasizer</class-id> <category>private-status</category><body package="Store-UI-Browser" selector="classOrNameSpaceStatus:criteria:">classOrNameSpaceStatus: aClassOrNameSpace  criteria: package	| overs set |	package == nil ifTrue: [ ^#( #definedByOther ) ].	set := ( package includesDefinitionOf: aClassOrNameSpace absoluteName )		ifTrue: 			[ ( self manager extensionModelsForSymbol: aClassOrNameSpace absoluteSymbol ) isEmpty				ifTrue: [ #( #entirelyDefined ) ]				ifFalse: [ #( #defined ) ]			]		ifFalse: [  #( definedByOther ) ].	aClassOrNameSpace isLoaded		ifFalse: [ ^set ].	overs := Override overridesForClassOrNameSpace: aClassOrNameSpace actual.	^self addStatus: set asSet overrideList: overs for: package.</body><body package="Store-UI-Browser" selector="dataDefinitionStatus:criteria:">dataDefinitionStatus: aStaticDef  criteria: package 	| overs set |	set := ( package includesDataKey: aStaticDef dataKey ownerName: aStaticDef environmentString ) 				ifTrue: [ #( defined ) ]				ifFalse: [ #( #definedByOther ) ].	aStaticDef isLoaded		ifFalse: [ ^set ].	overs := Override overridesForDataKey: aStaticDef dataKey in: aStaticDef owner.	^self addStatus: set asSet overrideList: overs for: package.</body><body package="Store-UI-Browser" selector="dataKeyStatus:owner:criteria:">dataKeyStatus: aKey owner: anOwner criteria: package	"Compute the status for a data key in a given class/namespace with respect to 	the parcels in manager and aParcelOrNil."	| overs set |	set := ( package includesDataKey: aKey ownerName: anOwner absoluteName )		ifTrue: [ #( defined ) ]		ifFalse: [ #( definedByOther ) ].	anOwner isLoaded		ifFalse: [ ^set ].	overs := Override overridesForDataKey: aKey in: anOwner.	^self addStatus: set asSet overrideList: overs for: package.</body><body package="Store-UI-Browser" selector="dataProtocolStatus:model:criteria:">dataProtocolStatus: protocol model: model criteria: package	"Compute the status for a message protocol in a class."	| owner list statics set |	( model == nil ) 		ifTrue: [ ^#( ) ].	model isLoaded			ifFalse: [ ^#( #entirelyDefined )  ].	( owner := model actual ) == nil		ifTrue: [ ^#( ) ].	( list := owner organization listAtCategoryNamed: protocol ) == 0		ifTrue: [ ^#( ) ].		"nothing there"	statics :=  package dataForNamed: owner absoluteName andProtocol: protocol. 	set := ( ( statics size = list size )		ifTrue:  [ #( #entirelyDefined ) ]		ifFalse: 			[ statics size &gt; 0 				ifTrue: [ #( #defined ) ]				ifFalse: [ #( ) ] 			] ) asSet.	list do:		[ :key |   | overs |		overs := Override overridesForDataKey: key in: owner.		self addStatus: set overrideList: overs for: package.		].	^set.</body><body package="Store-UI-Browser" selector="methodDefinitionStatus:criteria:">methodDefinitionStatus: aMethodDef  criteria: package 	"Compute the status for a method with respect to the package."	| overs set |	set := ( package includesSelector: aMethodDef selector 			className: aMethodDef className asClassNameOnly meta: aMethodDef isMeta 		    )		ifTrue: [ #( defined ) ]	   	ifFalse: [ #( definedByOther ) ].	aMethodDef isLoaded		ifFalse: [ ^set ].	overs := Override overridesForSelector: aMethodDef selector class: aMethodDef implementingClass.	^self addStatus: set asSet overrideList: overs for: package.</body><body package="Store-UI-Browser" selector="methodProtocolStatus:classModel:criteria:">methodProtocolStatus: protocol classModel: model criteria: package	"Compute the status for a message protocol in a class."	| owner list set methods |	( model == nil )  		ifTrue: [ ^#( ) ].	model isLoaded		ifFalse: [ ^#( #entirelyDefined )  ].	( owner := model actual ) == nil		ifTrue: [ ^#( ) ].		"no longer in image"	( list := owner organization listAtCategoryNamed: protocol ) size == 0		ifTrue: [ ^#( ) ].		"no methods"	methods := package methodsForClassNamed: owner absoluteName 					andProtocol: protocol meta: model isMeta. 	set := ( ( methods size = list size )		ifTrue:  [ #( #entirelyDefined ) ]		ifFalse: 			[ methods size &gt; 0 				ifTrue: [ #( #defined ) ]				ifFalse: [ #( ) ] 			] ) asSet.	list do:		[ :sel |   | overs |		overs := Override overridesForSelector: sel class: owner.		self addStatus: set overrideList: overs for: package.		].	^set.</body><body package="Store-UI-Browser" selector="methodProtocolStatus:classModel:meta:criteria:">methodProtocolStatus: protocol classModel: model meta: isMeta criteria: package	"Compute the status for a message protocol in a class."	| owner list set methods |	( model == nil )  		ifTrue: [ ^#( ) ].	model isLoaded		ifFalse: [ ^#( #entirelyDefined )  ].	( owner := model actual ) == nil		ifTrue: [ ^#( ) ].		"no longer in image"	isMeta ifTrue: [ owner := owner classBehavior ]. 	( list := owner organization listAtCategoryNamed: protocol ) size == 0		ifTrue: [ ^#( ) ].		"no methods"	methods := package methodsForClassNamed: owner absoluteName 					andProtocol: protocol meta: isMeta. 	set := ( ( methods size = list size )		ifTrue:  [ #( #entirelyDefined ) ]		ifFalse: 			[ methods size &gt; 0 				ifTrue: [ #( #defined ) ]				ifFalse: [ #( ) ] 			] ) asSet.	list do:		[ :sel |   | overs |		overs := Override overridesForSelector: sel class: owner.		self addStatus: set overrideList: overs for: package.		].	^set.</body><body package="Store-UI-Browser" selector="selectorStatus:class:criteria:">selectorStatus: aSelector class: aClass  criteria: package 	"Compute the status for a selector in a given class"	| overs set |	set := ( package includesSelector: aSelector className: aClass absoluteName meta: aClass isMeta )		ifTrue: [ #( defined ) ]		ifFalse: [ #( definedByOther ) ].	aClass isLoaded		ifFalse: [ ^set ].	overs := Override overridesForSelector: aSelector class: aClass.	^self addStatus: set asSet overrideList: overs for: package.</body></methods><methods><class-id>Store.PackageEmphasizer</class-id> <category>private</category><body package="Store-UI-Browser" selector="addStatus:overrideList:for:">addStatus: statusSet overrideList: overrides for: aPackage	overrides == nil		ifTrue: [ ^statusSet ].		statusSet add: #conflict.	( overrides contains: [ :o | o includesSource: aPackage ] ) 		ifTrue: [ statusSet add: #defined ].	^statusSet.</body><body package="Store-UI-Browser" selector="currentCriteria:id:">currentCriteria: aBrowser id: selectionId	"Answer what we are highlighting based on."		^aBrowser selectedPackageFor: selectionId</body><body package="Store-UI-Browser" selector="emphasisForAttribute:">emphasisForAttribute: status	"Answer an array of emphasis for status. Default mapping is:		#entirelyDefined 	bold &amp; underline		#defined			bold		#extended			norm *		#conflict			red "	( #extended ==  status )  		ifTrue: [ ^#( norm ) ].	^super emphasisForAttribute: status.</body><body package="Store-UI-Browser" selector="manager">manager	^Registry</body></methods><methods><class-id>Store.PackageEmphasizer</class-id> <category>api</category><body package="Store-UI-Browser" selector="emphasisForProtocol:for:id:">emphasisForProtocol: aProtocol for: aBrowser id: selectionId	"Answer the emphasis set for aProtocol displayed in aBrowser with a selectionId."	| criteria owner status |	( criteria := self currentCriteria: aBrowser id: selectionId ) == nil		ifTrue: [ ^#( #norm ) ].	( owner := aBrowser selectedModelFor: selectionId ) == nil		ifTrue: [ ^#( #norm ) ].	status := ( owner isForNameSpace or: [ aBrowser isData ] )		ifTrue: [ self dataProtocolStatus: aProtocol model: owner criteria: criteria ]		ifFalse: 			[ self 				methodProtocolStatus: aProtocol 				classModel: owner 				meta: aBrowser isMeta				criteria: criteria 			].	^self  mapStatusToEmphasis: status.</body></methods><methods><class-id>Store.StoreLoggingTool</class-id> <category>menu messages</category><body package="Store-Base" selector="executeAll">executeAll	"Execute SQL from the text collector"	self environment executeAll: self textCollector value string readStream.</body><body package="Store-Base" selector="executeSelection">executeSelection	"Execute selected SQL from the text collector"	| component |	component := builder componentAt: #collector.	component isNil		ifFalse: [ self environment executeSelection: component widget controller selection string ]</body><body package="Store-Base" selector="installInfo">installInfo		self environment installInfo</body></methods><methods><class-id>Store.StoreLoggingTool</class-id> <category>views</category><body package="Store-Base" selector="collector">collector	| textCollectorView |	textCollectorView := TextCollectorView model: self textCollector.	textCollectorView editText: self textCollector value.	textCollectorView controller: TextEditorController new.	textCollectorView controller keyboardProcessor: builder keyboardProcessor.	^textCollectorView</body></methods><methods><class-id>Store.ConnectionDialog</class-id> <category>initialize-release</category><body package="Store-DB-BaseObjects" selector="initialize">initialize	super initialize.	self tableOwnerListHolder value: 		self knownTableOwners asSortedCollection.</body><body package="Store-DB-BaseObjects" selector="initializeAspects">initializeAspects	super initializeAspects.	tableOwnerHolder := self profileAspect: #tableOwner.</body><body package="Store-DB-BaseObjects" selector="postBuildWith:">postBuildWith: aBuilder	super postBuildWith: aBuilder.	( builder componentAt: #tableOwnerCombo ) 			widget controller continuousAccept: true.	self profileChanged "cause update"</body></methods><methods><class-id>Store.ConnectionDialog</class-id> <category>notifications</category><body package="Store-DB-BaseObjects" selector="profileSelected">profileSelected	| profile name |	name := self connectionProfileHolder value.	name isNil ifTrue: [^self].	profile := self class profiles detect: [:some | some name = name] ifNone: [^self].	currentProfileHolder value: profile copy.	DbRegistry tablePrefix: profile tableOwner.	(UISettings preferenceModelFor: #tablePrefix) value: profile tableOwner</body><body package="Store-DB-BaseObjects" selector="tableOwnerChanged">tableOwnerChanged	self resetProfileName</body></methods><methods><class-id>Store.ConnectionDialog</class-id> <category>private</category><body package="Store-DB-BaseObjects" selector="createNewProfile">createNewProfile	| profile databaseNames |	profile := ConnectionProfile new.	databaseNames := self knownDatabases.	databaseNames isEmpty ifFalse:		[profile driverClassName: databaseNames first].	profile tableOwner: 'BERN'.	^profile</body><body package="Store-DB-BaseObjects" selector="knownDatabases">knownDatabases	"Only include those for which Store is available."	| coll |	coll := OrderedCollection new.	SQLBroker allSubclasses do:		[ :sb | 		( sb class includesSelector: #connectionClass )			ifTrue: [ coll add: sb connectionClass name ]		].	^coll</body><body package="Store-DB-BaseObjects" selector="knownTableOwners">knownTableOwners	"Collect tableOwners used in the existing connection profiles."	^(self allProfiles collect: [:each | each tableOwner]) asSet</body></methods><methods><class-id>Store.ConnectionDialog</class-id> <category>aspects</category><body package="Store-DB-BaseObjects" selector="tableOwnerHolder">tableOwnerHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^tableOwnerHolder isNil		ifTrue:[ tableOwnerHolder := String new asValue ]		ifFalse:	[ tableOwnerHolder ]</body><body package="Store-DB-BaseObjects" selector="tableOwnerListHolder">tableOwnerListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^tableOwnerListHolder isNil		ifTrue: [ tableOwnerListHolder := List new asValue ]		ifFalse: 	[ tableOwnerListHolder ]</body></methods><methods><class-id>Store.ConnectionDialog class</class-id> <category>store</category><body package="Store-DB-BaseObjects" selector="connection">connection	"Answer the opened connection or nil if the dialog was cancelled."	LastUsedProfile == nil		ifTrue: [ LastUsedProfile := ConnectionProfile new ].	^self openConnectionUsing: LastUsedProfile.</body><body package="Store-DB-Broker" selector="openConnectionUsing:">openConnectionUsing: aProfile	"Open the dialog with aProfile and then open the database connection that was selected.	Answer the opened connection or nil if the dialog was cancelled."	| profile connection |	profile := aProfile.	[ ( profile := self openProfile: profile ) == nil		ifTrue: [ ^nil ].	connection := self connect: profile.	connection == nil.	] whileTrue.	DbRegistry updateTablePrefix: profile tableOwner.	^connection.</body></methods><methods><class-id>Store.ConnectionDialog class</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="profiles">profiles	^RepositoryManager repositories</body></methods><methods><class-id>Store.CachingPackageEmphasizer</class-id> <category>accessing</category><body package="Store-UI-Browser" selector="cachedLeafItems">cachedLeafItems	^cachedLeafItems ifNil: [cachedLeafItems := Dictionary new]</body></methods><methods><class-id>Store.CachingPackageEmphasizer</class-id> <category>private-status</category><body package="Store-UI-Browser" selector="classOrNameSpaceStatus:criteria:">classOrNameSpaceStatus: aClassOrNameSpace criteria: package 	| overs set |	package == nil ifTrue: [^#(#definedByOther)].	set := (self fasterIncludesDefinitionOf: aClassOrNameSpace for: package) 				ifTrue: 					[(self manager extensionModelsForSymbol: aClassOrNameSpace absoluteSymbol) 						isEmpty ifTrue: [#(#entirelyDefined)] ifFalse: [#(#defined)]]				ifFalse: [#(#definedByOther)].	aClassOrNameSpace isLoaded ifFalse: [^set].	overs := Override overridesForClassOrNameSpace: aClassOrNameSpace actual.	^self 		addStatus: set asSet		overrideList: overs		for: package</body><body package="Store-UI-Browser" selector="methodDefinitionStatus:criteria:">methodDefinitionStatus: aMethodDef criteria: package 	"Compute the status for a method with respect to the package."	| overs set |	set := (self fasterIncludesSelector: aMethodDef for: package) 				ifTrue: [#(#defined)]				ifFalse: [#(#definedByOther)].	aMethodDef isLoaded ifFalse: [^set].	overs := Override overridesForSelector: aMethodDef selector				class: aMethodDef implementingClass.	^self 		addStatus: set asSet		overrideList: overs		for: package</body></methods><methods><class-id>Store.CachingPackageEmphasizer</class-id> <category>private</category><body package="Store-UI-Browser" selector="fasterIncludesDefinitionOf:for:">fasterIncludesDefinitionOf: aClassOrNameSpace for: package 	| leafItems absoluteName |	"Just hard code the selector so we can find it in senders."	#includesDefinitionOf:.	leafItems := self cachedLeafItems at: package				ifAbsentPut: [package leafItems].	absoluteName := aClassOrNameSpace absoluteName.	^leafItems isEmpty 		ifTrue: [package includesDefinitionOf: absoluteName]		ifFalse: 			[leafItems anySatisfy: [:pkg | pkg includesDefinitionOf: absoluteName]]</body><body package="Store-UI-Browser" selector="fasterIncludesSelector:for:">fasterIncludesSelector: aMethodDef for: pundle 	| leafItems |	leafItems := self cachedLeafItems at: pundle				ifAbsentPut: [pundle leafItems].	"Hard code so we can find it in senders."	#includesSelector:className:meta:.	pundle isPackage 		ifTrue: 			[pundle 				includesSelector: aMethodDef selector				className: aMethodDef className asClassNameOnly				meta: aMethodDef isMeta].	^leafItems anySatisfy: 			[:pkg | 			"Force the caching of the methods."			pkg methodsWithSource.			pkg 				includesSelector: aMethodDef selector				className: aMethodDef className asClassNameOnly				meta: aMethodDef isMeta]</body></methods><methods><class-id>Store.BlessingLevel</class-id> <category>comparing</category><body package="Store-User Management" selector="&lt;">&lt; aBlessing	^level &lt; aBlessing level</body><body package="Store-User Management" selector="&lt;=">&lt;= aBlessing	^level &lt;= aBlessing level</body><body package="Store-User Management" selector="=">= aBlessing	^level = aBlessing level</body><body package="Store-User Management" selector="hash">hash	^level</body></methods><methods><class-id>Store.BlessingLevel</class-id> <category>types</category><body package="Store-User Management" selector="beAdminOnly">beAdminOnly	type := #admin</body><body package="Store-User Management" selector="beNormal">beNormal	"Remove any type restrictions."	type := nil</body><body package="Store-User Management" selector="beOwnerOnly">beOwnerOnly	type := #owner</body><body package="Store-User Management" selector="beQaOnly">beQaOnly	type := #qa</body></methods><methods><class-id>Store.BlessingLevel</class-id> <category>testing</category><body package="Store-User Management" selector="isAdminOnly">isAdminOnly	^type == #admin</body><body package="Store-User Management" selector="isOwnerOnly">isOwnerOnly	^type == #owner</body><body package="Store-User Management" selector="isQaOnly">isQaOnly	^type == #qa</body></methods><methods><class-id>Store.BlessingLevel</class-id> <category>printing</category><body package="Store-User Management" selector="printOn:">printOn: aStream	aStream nextPutAll: name.	type == nil		ifFalse: [ aStream nextPut: $-; nextPutAll: type ].	aStream 		nextPut: $(;		nextPutAll: level printString;		nextPut: $).</body></methods><methods><class-id>Store.BlessingLevel</class-id> <category>accessing</category><body package="Store-User Management" selector="level">level	^level</body><body package="Store-User Management" selector="level:">level: anInteger	level := anInteger</body><body package="Store-User Management" selector="name">name	^name</body><body package="Store-User Management" selector="name:">name: aString	name := aString</body></methods><methods><class-id>Store.BlessingLevel class</class-id> <category>instance creation</category><body package="Store-User Management" selector="name:level:">name: aString level: anInteger	^self new		name: aString;		level: anInteger;		yourself.</body></methods><methods><class-id>Store.PublishedPackagePropertiesDialog</class-id> <category>properties</category><body package="Store-UI" selector="generalPropertiesAccept">generalPropertiesAccept	"Update the properties to the package/parcel with the modified properties."	self package startLoad.		"so no events triggered"	[ super generalPropertiesAccept ]		ensure: [ self package endLoad ].	postProcessingBlock value.	self generalProperties inspect: self package properties.		"refresh or #loading will show up"</body><body package="Store-UI" selector="loadAccept">loadAccept	"Update the properties to the package/parcel with the modified properties."	self package startLoad.		"so no events triggered"	[ super loadAccept ]		ensure: [ self package endLoad ].	postProcessingBlock value.</body><body package="Store-UI" selector="loadOptionsAccept">loadOptionsAccept	"Update the properties to the package/parcel with the modified properties."	self package startLoad.		"so no events triggered"	[ super loadOptionsAccept ]		ensure: [ self package endLoad ].	postProcessingBlock value.</body><body package="Store-UI" selector="preReadAccept">preReadAccept	"Update the properties to the package/parcel with the modified properties."	self package startLoad.		"so no events triggered"	[ super preReadAccept ]		ensure: [ self package endLoad ].	postProcessingBlock value.</body><body package="Store-UI" selector="prerequisitesAccept">prerequisitesAccept	"Update the properties to the package/parcel with the modified properties."	self package startLoad.		"so no events triggered"	[ super prerequisitesAccept ]		ensure: [ self package endLoad ].	postProcessingBlock value.</body><body package="Store-UI" selector="saveAccept">saveAccept	"Update the properties to the package/parcel with the modified properties."	self package startLoad.		"so no events triggered"	[ super saveAccept ]		ensure: [ self package endLoad ].	postProcessingBlock value.</body><body package="Store-UI" selector="unloadAccept">unloadAccept	"Update the properties to the package/parcel with the modified properties."	self package startLoad.		"so no events triggered"	[ super unloadAccept ]		ensure: [ self package endLoad ].	postProcessingBlock value.</body></methods><methods><class-id>Store.PublishedPackagePropertiesDialog</class-id> <category>accessing</category><body package="Store-UI" selector="postProcessingBlock:">postProcessingBlock: aZeroArgumentBlock	"block to call after every update"	postProcessingBlock := aZeroArgumentBlock</body></methods><methods><class-id>Store.PublishedPackagePropertiesDialog</class-id> <category>private</category><body package="Store-UI" selector="removeAction:">removeAction: actionSymbol	self package startLoad.		"so no events triggered"	[ super removeAction: actionSymbol ]		ensure: [ self package endLoad ].	postProcessingBlock value.</body></methods><methods><class-id>Store.PublishedPackagePropertiesDialog class</class-id> <category>initialization</category><body package="Store-UI" selector="initialize">initialize	"self initialize"	"because the supclass need initialization too. not sure why."	super initialize</body><body package="Store-UI" selector="on:">on: aPackage	"Open  a properties dialog  on aPackage. Answer the dialog"	self invalidUseWarning</body><body package="Store-UI" selector="on:postProcessingBlock:">on: aPackage postProcessingBlock: aZeroArgumentBlock	"Open  a properties dialog  on aPackage."	^self openOn: 		( self new 			package: aPackage; 			postProcessingBlock: aZeroArgumentBlock;			yourself 		)</body></methods><methods><class-id>Store.PublishedPackagePropertiesDialog class</class-id> <category>interface opening</category><body package="Store-UI" selector="invalidUseWarning">invalidUseWarning	"Raise a Dialog to warn the client of the receiver that they are not	using the correct protocol to open an instance."	Dialog warn: ((#invalidDialogUsePostProcessingWarning &lt;&lt; #dialogs &gt;&gt; 'You must open up &lt;1s&gt; with #on:postProcessingBlock:&lt;n&gt;&lt;1s&gt; requires a subclass of&lt;n&gt;CodeComponent to be properly initialized.') expandMacrosWith: self name)</body></methods><methods><class-id>Store.PublishSpecificationList</class-id> <category>accessing</category><body package="Store-IMG-Configurations" selector="binarySave">binarySave	^self first binarySave</body><body package="Store-IMG-Configurations" selector="parcelSave">parcelSave	^self first parcelSave</body><body package="Store-IMG-Configurations" selector="pundle">pundle	^self first pundle</body><body package="Store-IMG-Configurations" selector="version">version	^self first version</body></methods><methods><class-id>Store.PublishSpecificationList</class-id> <category>testing</category><body package="Store-IMG-Configurations" selector="canPublish">canPublish	"Answer true if every item marked for publication can be published."	| binary |	binary := self binarySave.	self reverseDo: 		[ :spec | 		spec publish			ifTrue: 				[ spec canPublish					ifFalse: [ ^false ].				spec binarySave: binary.  "copy global attribute to item"				]			].	^true</body></methods><methods><class-id>Store.PublishSpecificationList</class-id> <category>publishing</category><body package="Store-IMG-Configurations" selector="publishBlessing">publishBlessing	"Create new blessing/comment records for each item marked for publication."	| published |	published := IdentitySet new.		[ self reverseDo:		[ :spec | | pundle |		pundle := spec pundle.		( published includes: pundle ) 			ifFalse:				[ published add: pundle.				spec publishBlessing					ifFalse: [ ^false ].				].		].	] on: Store.DbRegistry errorSignals do: [ :ex | ex return: false ].	^true.</body><body package="Store-IMG-Configurations" selector="publishFiles">publishFiles	"Publish the list. Answer false if aborted."	self isEmpty | ( DbRegistry isDb73Enabled not )		ifTrue: [ ^self ].	Notice showNotice: 'Publishing Files...'  complete: self size while: 		[ self publishSilently			ifFalse: [ ^false ].		self pundle bundle fileDescriptions: ( self collect: [ :ps | ps pundle ] ) asList.		 ].	^true</body><body package="Store-IMG-Configurations" selector="publishFragments">publishFragments	| frags |	frags := ( ( self select: [ :spec | spec publish ] ) 				collect: [ :spec | spec pundle ] ).	Notice showNotice: 'Publishing fragments' complete: 1 while:  		[		self reverseDo: 			[ :spec | 			spec publish				ifTrue: 					[ spec pundle classOfDbRecord 						newFrom: spec pundle 						userData: spec 						pundleFragments: frags					].			].		].	^true</body><body package="Store-IMG-Configurations" selector="publishPundle">publishPundle	"Publish the list. Answer false if aborted."	Notice showNotice: 'Publishing ' , self pundle name complete: 1 while: 		[ self publishSilently			ifFalse: [ ^false ]		 ].	^true</body><body package="Store-IMG-Configurations" selector="publishSilently">publishSilently	"Publish the list in reverse order. Answer true if all went well."	| published |	published := IdentitySet new.		[ self reverseDo:		[ :spec | | pundle |		pundle := spec pundle.		( published includes: pundle ) 			ifFalse:				[ published add: pundle.				spec publishSilently					ifFalse: [ ^false ].				].		].	] on: Store.DbRegistry errorSignals do: [ :ex | ex return: false ].	^true.</body></methods><methods><class-id>Store.PublishSpecificationList class</class-id> <category>instance creation</category><body package="Store-IMG-Configurations" selector="filesFromBundle:">filesFromBundle: anImageBundle  	| list specs |	list := self new.	anImageBundle fileDescriptions do: 		[ :fileRec | 			specs := PublishFileSpecification new file: fileRec.		specs level: 2.		list add: specs		].	^list</body><body package="Store-IMG-Configurations" selector="fromBundle:">fromBundle: anImageBundle  	| master list |	( master := self specClass pundle: anImageBundle )		publish: true; 		modified: true.	list := self with: master.	anImageBundle descriptionsAndLevels do: 		[ :pair | 	| pndl descr specs |		descr := pair at: 1.		pndl := descr component.		specs := self specClass pundle: pndl.		specs description: descr.		specs level: pair last.		list add: specs		].	^list</body><body package="Store-IMG-Configurations" selector="fromDbBundle:">fromDbBundle: aDbBundle  	| list trace traceItems master |	list := self with: ( master := self specClass pundle: aDbBundle ).	master		publish: true;		modified: true.	( trace := aDbBundle parentRecord ) == nil		ifTrue: [ traceItems := Set new ]		ifFalse: [ traceItems := trace allItems ].	aDbBundle uniqueItemsAndLeveles do: 		[ :pair | 	| comp spec |		comp := pair first.		spec := self specClass pundle: comp.		spec 			modified: ( traceItems contains: [ :p | p primaryKey = aDbBundle primaryKey ] );			description: comp;			version: comp version;			parentVersion: comp version;			level: pair last;			yourself.		list add: spec.		].	^list</body></methods><methods><class-id>Store.PublishSpecificationList class</class-id> <category>constants</category><body package="Store-IMG-Configurations" selector="specClass">specClass	^PublishSpecification</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>private-utilities</category><body package="Store-DB-Broker" selector="answerFromQuery:bindInput:">answerFromQuery: aSQLString bindInput: anObject	^self process: aSQLString bindInput: anObject.</body><body package="Store-DB-Broker" selector="existsInDatabase:">existsInDatabase: anObj	| res |	res := self process: 				(( self newSQLFor: anObj class)					selectCountAll;					whereSqlString)  bindInput: anObj.	^res first first &gt; 0</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>drop objects</category><body package="Store-DB-Broker" selector="dropDatabaseFor:">dropDatabaseFor: aClass	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="dropIndexForClass:">dropIndexForClass: aClass	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="dropIndexForClass:index:">dropIndexForClass: aClass index: aName	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="dropSequenceForClass:">dropSequenceForClass: aClass	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="dropTable:">dropTable: aTable 		Transcript cr; show: 'Dropping table ' , aTable.	self performDrop: [self processSQL: 'DROP TABLE ' , aTable]		for: aTable.</body><body package="Store-DB-Broker" selector="dropTableForClass:">dropTableForClass: aClass 	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="dropUser:">dropUser: aName	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="dropView:">dropView: aViewName	self performDrop: [self processSQL:  ('DROP VIEW ' , aViewName) asString]		for: aViewName</body><body package="Store-DB-Broker" selector="dropViewForClass:">dropViewForClass: aClass	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="performDrop:for:">performDrop: aBlock for: aName 	[		aBlock value	]	on: Error	do: [ :exception | 		(self doesNotExistErrors includes: exception parameter first dbmsErrorCode)			ifTrue: 				[ Transcript cr; show:  exception parameter first dbmsErrorString.				exception return ]			ifFalse: 				[ DatabaseMessageBox openOnMessage: (self messageFor: exception). 				DbRegistry goOffLine.				exception pass]	].</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>grant statements</category><body package="Store-DB-Broker" selector="grant:on:columnList:to:">grant: aPermissionList on: aTableName columnList: aColumnList  to: aUserNameList	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="grant:on:to:">grant: aPermissionList on: aTableName to: aUserNameList	| aStream  |	aStream := (String new: 100) writeStream.	aStream nextPutAll:  'GRANT ' .	aPermissionList do: [ :each | aStream nextPutAll: (each, ', ')].	aStream position: (aStream position - 2).	aStream nextPutAll:  (' ON ' , aTableName, ' TO ').	aUserNameList do: [ :each | aStream nextPutAll: (each, ', ')].	aStream skip: -2.		self processGrantStatement: aStream contents.</body><body package="Store-DB-Broker" selector="grant:to:">grant: aStatementList to: aNameList	|  aStream |		aStream := (String new: 100) writeStream.	aStream nextPutAll:  'GRANT ' .	aStatementList do: [ :each | aStream nextPutAll: (each, ', ')].	aStream position: (aStream position - 2).	aStream nextPutAll:  ' TO ' .	aNameList do: [ :each | aStream nextPutAll: (each, ', ')].	aStream skip: -2.	self processGrantStatement: aStream contents.</body><body package="Store-DB-Broker" selector="grantAllForClass:to:">grantAllForClass: aClass to: aUserName	self processGrantStatement:  'GRANT ALL ON ',  (self tableNameWithPrefix: aClass), ' TO ', aUserName.</body><body package="Store-DB-Broker" selector="grantAllTo:">grantAllTo: aName	self processGrantStatement:  'GRANT ALL TO ', aName.</body><body package="Store-DB-Broker" selector="grantForClass:permissions:columns:toUsers:">grantForClass: aClass permissions: aPermissionList columns: aColumnList toUsers: aUserNameList	self grant:aPermissionList		on: (self tableNameWithPrefix: aClass)		columnList: (self columnList: aColumnList for: aClass)		to: aUserNameList</body><body package="Store-DB-Broker" selector="grantForClass:permissions:toUsers:">grantForClass: aClass permissions: aPermissionList toUsers: aUserNameList	self grant: aPermissionList on: (self tableNameWithPrefix: aClass) to: aUserNameList.</body><body package="Store-DB-Broker" selector="grantForSeqClass:permissions:toUsers:">grantForSeqClass: aClass permissions: aPermissionList toUsers: aUserNameList	self grant: aPermissionList on: (self sequenceNameWithPrefix: aClass) to: aUserNameList.</body><body package="Store-DB-Broker" selector="processGrantStatement:">processGrantStatement: aString	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="processRevokeStatement:">processRevokeStatement: aString	[		self processSQL:  aString	]	on: Error 	do: [ :exception | DatabaseMessageBox openOnMessage: (self messageFor: exception)]</body><body package="Store-DB-Broker" selector="revoke:on:from:">revoke: aPermissionList on: aTableName from: aUserNameList	| aStream  |	aStream := (String new: 100) writeStream.	aStream nextPutAll:  'REVOKE ' .	aPermissionList do: [ :each | aStream nextPutAll: (each, ', ')].	aStream position: (aStream position - 2).	aStream nextPutAll:  (' ON ' , aTableName, ' FROM ').	aUserNameList do: [ :each | aStream nextPutAll: (each, ', ')].	aStream skip: -2.		self processRevokeStatement: aStream contents.</body><body package="Store-DB-Broker" selector="revokeForClass:permissions:fromUsers:">revokeForClass: aClass permissions: aPermissionList fromUsers: aUserNameList	self revoke: aPermissionList on: (self tableNameWithPrefix: aClass) from: aUserNameList.</body><body package="Store-DB-Broker" selector="setDatabasePrivilegesForTable:">setDatabasePrivilegesForTable: aClass	"Defines who can do what wtih the table"	| aColl |	self grantForClass: aClass permissions: #('INSERT' 'SELECT' ) toUsers: #('PUBLIC').	aColl := self allUpdatableColumnsFor: aClass.	aColl isEmpty 		ifFalse: [ self grantForClass: aClass permissions: #('UPDATE') columns: aColl toUsers: #('PUBLIC').].</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>private-accessing</category><body package="Store-DB-Broker" selector="closeConnection">closeConnection	DbRegistry closeConnection</body><body package="Store-DB-Broker" selector="dismissSession:">dismissSession: aSession	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="getNewSession">getNewSession	^ self connection getSession</body><body package="Store-DB-Broker" selector="reconnect">reconnect	DbRegistry reconnect</body><body package="Store-DB-Broker" selector="resetSessionCursorFor:">resetSessionCursorFor: aSession</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>connection class</category><body package="Store-DB-Broker" selector="connectionClass">connectionClass	^self subclassResponsibility</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>error handling</category><body package="Store-DB-Broker" selector="alreadyExistErrors">alreadyExistErrors	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="cannotCloseCursorErrorCode">cannotCloseCursorErrorCode	"Answer a number that database uses in case whe the cursor cannot be closed."		^self subclassResponsibility</body><body package="Store-DB-Broker" selector="currentlyNotConnectedSignal">currentlyNotConnectedSignal	^DbRegistry currentlyNotConnectedSignal</body><body package="Store-DB-Broker" selector="doesNotExistErrors">doesNotExistErrors	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="errorSignals">errorSignals		^DbRegistry errorSignals</body><body package="Store-DB-Broker" selector="indexConflictSignal">indexConflictSignal	^ self connectionClass indexConflictSignal</body><body package="Store-DB-Broker" selector="invalidObjectErrorNumber">invalidObjectErrorNumber	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="notConnectedSignal">notConnectedSignal	^DbRegistry notConnectedSignal</body><body package="Store-DB-Broker" selector="objectAlreadyExistisErrorNumber">objectAlreadyExistisErrorNumber	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="objectAlreadyGoneErrorNumber">objectAlreadyGoneErrorNumber	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="serverDiedErrorCodes">serverDiedErrorCodes	"Answer a number that database uses in case of 	server going away while we are connected."	^self subclassResponsibility</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>accessing</category><body package="Store-DB-Broker" selector="connection">connection	^ DbRegistry connection</body><body package="Store-DB-Broker" selector="connectionOrNil">connectionOrNil	^ DbRegistry connectionOrNil</body><body package="Store-DB-Broker" selector="databaseName">databaseName	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="fullTableName:">fullTableName: aClass	"Override as required -	 Answer the full, database qualified table name for aClass."	^ self tableNameWithPrefix: aClass</body><body package="Store-DB-Broker" selector="getBlobData:">getBlobData: aData		^self subclassResponsibility</body><body package="Store-DB-Broker" selector="indexNameFor:">indexNameFor: aClass	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="isConnectionAlive">isConnectionAlive	^ DbRegistry isConnectionAlive</body><body package="Store-DB-Broker" selector="maxLongBytes">maxLongBytes	^32000</body><body package="Store-DB-Broker" selector="maxPropertySearchStringSize">maxPropertySearchStringSize	"Return the mazimum length of property record search string. Should be &lt;= 255.	Override this value in subclasses if the searchable varchars are shorter on your DB."	^255</body><body package="Store-DB-Broker" selector="maxSqlString">maxSqlString	"Answer the maximum length of a sql string.	Subclasses should implement platform specific limitations."	^8000</body><body package="Store-DB-Broker" selector="needsSequenceFor:">needsSequenceFor: aClass	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="permissionsForSequence">permissionsForSequence	"Answer an array of permissions to grant to sequence tables."	^#( 'SELECT' ).</body><body package="Store-DB-Broker" selector="sequenceNameWithPrefix:">sequenceNameWithPrefix: aClass		^(self tableNameWithPrefix: aClass), 'Seq'</body><body package="Store-DB-Broker" selector="tableName:">tableName: aClass	^'TW_', aClass name asString</body><body package="Store-DB-Broker" selector="tableNameWithPrefix:">tableNameWithPrefix: aClass	^(self tablePrefix isNil or: [self tablePrefix isEmpty])		ifTrue: [self tableName: aClass]		ifFalse: [self tablePrefix, '.', (self tableName: aClass)]</body><body package="Store-DB-Broker" selector="tablePrefix">tablePrefix	^DbRegistry tablePrefix</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>private</category><body package="Store-DB-Broker" selector="messageFor:">messageFor: exception	| errs msg |	exception signal == self connectionClass authenticationFailureSignal 		ifTrue: [ ^exception errorString ].	(errs := exception parameter) notNil 		ifTrue: 			[ errs isSignalledException ifTrue: [ ^ errs errorString].			(errs isEmpty not				and: [ (msg := (exception parameter at: 1) dbmsErrorString) notNil				and: [ msg isEmpty not ] ] )				ifTrue: [ ^msg ]				ifFalse:  [ ^exception errorString ]			]		ifFalse: [ ^exception errorString ]</body><body package="Store-DB-Broker" selector="sessionFromOutputObject:">sessionFromOutputObject: anObject	^[ anObject class session ] 		on: MessageNotUnderstood 		do: [ : ex | ex return: DBObject session ].</body><body package="Store-DB-Broker" selector="typeToStringMap">typeToStringMap	^self subclassResponsibility</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>sql processing</category><body package="Store-DB-Broker" selector="getAnswerFromSession:bindInput:">getAnswerFromSession: getSessionBlock bindInput: bindInputBlock 		^self safelyExecuteBlock: 		[ | session ans res |		session := getSessionBlock value.		bindInputBlock value: session.		session execute.		[ ans := session answer.		ans == #noMoreAnswers		] whileFalse: 			[ ans == #noAnswerStream 				ifFalse: [ res := ans upToEnd ]			].		DbRegistry printDebug: 'Output'; printDebug: res.		^ res.		]</body><body package="Store-DB-Broker" selector="nextIDForClass:">nextIDForClass: aClass	"Answer the next number in the sequence established for artifact. "	| res ans sess |	^ [ self  safelyExecuteBlock: 		[ ( sess := aClass sequenceGeneratorSession ) execute.			[ ans := sess answer.			ans == #noMoreAnswers			] whileFalse: 				[ ans == #noAnswerStream 					ifFalse: [ res := ans upToEnd ]				].		res first first	] ] on: UnhandledException do: [ :ex | ^nil ]</body><body package="Store-DB-Broker" selector="process:">process: sqlString	"Return the result not the answer stream."	^DbRegistry goToScript 		ifTrue: [	self log: sqlString  level: #SQLBroker ]		ifFalse: 	[ self process: sqlString bindInput: nil  bindOutput: nil.]</body><body package="Store-DB-Broker" selector="process:bindInput:">process: sqlString bindInput: anObject	"Return the result not the answer stream."	^self process: sqlString bindInput: anObject bindOutput: nil</body><body package="Store-DB-Broker" selector="process:bindInput:bindOutput:">process: sqlString bindInput: inputObj bindOutput: outputObj 	"Return the result not the answer stream. 	Watch for the server going away."	^self safelyExecuteBlock: 		[ self			process: sqlString			bindInput: inputObj			bindOutput: outputObj			usingSession: ( self sessionFromOutputObject: outputObj )		]</body><body package="Store-DB-Broker" selector="process:bindInput:bindOutput:onError:do:">process: sqlString bindInput: anObj bindOutput: anObject onError: aSignal do: aBlock	"Return the result not the answer stream."	^self process: sqlString 		bindInput: anObj 		bindOutput: anObject 		usingSession: ( self sessionFromOutputObject: anObject )		onError: aSignal 		do: aBlock</body><body package="Store-DB-Broker" selector="process:bindInput:bindOutput:usingSession:">process: sqlString bindInput: inputObj bindOutput: outputObj usingSession: session	| res ans |	"Return the result not the answer stream."	self isConnectionAlive ifFalse: [self currentlyNotConnectedSignal raise].	self log: sqlString  level: #SQLBroker.	session bindInput: inputObj.	session bindOutput: outputObj.	session prepare: sqlString. 	session execute.	[ans := session answer.	ans == #noMoreAnswers]		whileFalse: [ans == #noAnswerStream ifFalse: [res := ans upToEnd]].	self log: 'Done ! '  level: #SQLBroker.	^ res</body><body package="Store-DB-Broker" selector="process:bindInput:bindOutput:usingSession:onError:do:">process: sqlString bindInput: inputObj bindOutput: outputObj usingSession: session onError: aSignal do: aBlock	^[		self process: sqlString bindInput: inputObj bindOutput: outputObj usingSession: session 	] 	on: aSignal	do: [ :exception | 			aBlock notNil 				ifTrue: [ aBlock value: exception ]				ifFalse: [ exception pass]		]</body><body package="Store-DB-Broker" selector="process:bindOutput:">process: sqlString bindOutput: anObject 	"Return the result not the answer stream."	^self process: sqlString bindInput: nil bindOutput: anObject</body><body package="Store-DB-Broker" selector="process:bindOutput:onError:do:">process: sqlString bindOutput: anObject onError: aSignal do: aBlock	"Return the result not the answer stream."	^self process: sqlString 		bindInput: nil 		bindOutput: anObject 		usingSession: ( self sessionFromOutputObject: anObject )		onError: aSignal 		do: aBlock</body><body package="Store-DB-Broker" selector="process:onError:do:">process: sqlString onError: aSignal do: aBlock	"Return the result not the answer stream."	^self process: sqlString 		bindInput: nil 		bindOutput: nil		usingSession: DBObject session 		onError: aSignal 		do: aBlock</body><body package="Store-DB-Broker" selector="processPublishException:note:">processPublishException: exception  note: aNote	| str | 	str := (String new: 100) writeStream."	str nextPutAll: aNote, '  operation was not completed'; cr.  "	str nextPutAll: ' ERROR:  ', (self messageFor: exception) asString.	DatabaseMessageBox openOnMessage: str contents title: aNote, '  Operation was not completed.'.	DbRegistry goOffLine.</body><body package="Store-DB-Broker" selector="processSQL:">processSQL: sqlString	^DbRegistry goToScript 		ifTrue: [	self log: sqlString  level: #SQLBroker ]		ifFalse:  [ self processSQL: sqlString bindInput: nil bindOutput: nil.]</body><body package="Store-DB-Broker" selector="processSQL:bindInput:">processSQL: sqlString bindInput: anObject	^ self 	processSQL: sqlString bindInput: anObject bindOutput: nil</body><body package="Store-DB-Broker" selector="processSQL:bindInput:bindOutput:">processSQL: sqlString bindInput: anObjectInp bindOutput: anObjectOut	^self  process: sqlString		bindInput: anObjectInp		bindOutput: anObjectOut		usingSession: ( self sessionFromOutputObject: anObjectOut )</body><body package="Store-DB-Broker" selector="processSQL:bindOutput:">processSQL: sqlString bindOutput: anObject	^ self processSQL: sqlString bindInput: nil bindOutput: anObject</body><body package="Store-DB-Broker" selector="publishTransaction:">publishTransaction: aBlock	"If not already in transaction mode then start one. Assumes progress dialog already up.	Answer either a value returned by aBlock or nil if the transaction fails."	^[ | res connection |	 ( connection := self connection ) isNil		ifTrue: [ ^nil ].	connection inTransactionMode 		ifTrue: [ res := aBlock value	"We are already inside a transaction." ]		ifFalse: 			[ [ connection begin.				  res := aBlock value.				  connection commit			   ] ifCurtailed:				[ DbRegistry isOnline ifTrue: [ connection rollback ].				res := nil				]			].		res	] on: ( ExceptionSet			with: self errorSignals			with: self connectionClass connectionClass transactionPhase2FatalSignal)	do: [ :ex |  			self processPublishException: ex  note: ''. 			ex outer. 			^nil]</body><body package="Store-DB-Broker" selector="publishTransaction:showing:">publishTransaction: aBlock showing: aNote 	"If not already in transaction mode than put a notice on the screen and start 	transaction. Answer either a value returned by aBlock or nil if the transaction fails."	^ [| res |		self connection inTransactionMode 			ifTrue: [ res := aBlock value	"We are already inside a transaction." ]			ifFalse: 				[ Notice show: aNote while: 					[ [ self connection begin.					  res := aBlock value.					  self connection commit					  ] ifCurtailed:						[ DbRegistry isOnline ifTrue: [self connection rollback].						res := nil						]					]				].		res	] 	on: (ExceptionSet			with: self errorSignals			with: self connectionClass connectionClass transactionPhase2FatalSignal)	do: [ :ex | self processPublishException: ex  note: aNote.				ex outer.			^nil.]</body><body package="Store-DB-Broker" selector="publishTransaction:showing:count:">publishTransaction: aBlock showing: aNote count: anInteger	"If not already in transaction mode than put a progress dialog on the screen and start 	transaction. Answer either a value returned by aBlock or nil if the transaction fails."	^[ | res connection |	 ( connection := self connection ) isNil		ifTrue: [ ^nil ].	connection inTransactionMode 		ifTrue: [ res := aBlock value	"We are already inside a transaction." ]		ifFalse: 			[Notice 				showProgress: aNote 				complete: anInteger 				while: 					[[connection begin.					  res := aBlock value.					  connection commit] ifCurtailed:						[DbRegistry isOnline ifTrue: [connection rollback].						res := nil]]				title: 'Store'].		res	] 	on: (ExceptionSet			with: self errorSignals			with: self connectionClass connectionClass transactionPhase2FatalSignal)	do: [ :ex |  			self processPublishException: ex  note: aNote. 			ex outer. 			^nil]</body><body package="Store-DB-Broker" selector="safelyExecuteBlock:">safelyExecuteBlock: aBlock 	^self subclassResponsibility</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>create objects</category><body package="Store-DB-Broker" selector="addIdentityFor:">addIdentityFor: aColumn	^ String new.</body><body package="Store-DB-Broker" selector="allocateSpaceForObjectsIn:">allocateSpaceForObjectsIn: fileName		^self subclassResponsibility</body><body package="Store-DB-Broker" selector="createDatabaseSequence:">createDatabaseSequence: aClass	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="createDatabaseTable:">createDatabaseTable:  aClass		^self subclassResponsibility</body><body package="Store-DB-Broker" selector="createDatabaseTableColumnsFor:keyNames:">createDatabaseTableColumnsFor: aClass keyNames: aKeyCollection	"Creates column list for a new table."	| fdTypes stringMap aStream aType |	stringMap := self typeToStringMap.	fdTypes := aClass fieldTypes.	aStream := (String new: 100) writeStream.	aStream cr.	aClass columnNames		do: 			[:each | 			"Need default column names 				(which must be String for compatibility with #fieldTypes)				in order to find associated type."			aType := fdTypes at: each ifAbsent: [#String].			(self isPrimaryKeyType: aType) ifTrue: [aKeyCollection addLast: each].			aStream nextPutAll: '     ', (self columnName: each for: aClass),				'  ', (stringMap at: aType).			aStream nextPutAll: ( self addIdentityFor: each).			aStream nextPutAll:  ', '; cr].	aKeyCollection isEmpty 		ifTrue:			[aStream skip: -2.			aStream nextPut: $ .].	^ aStream contents.</body><body package="Store-DB-Broker" selector="createIndex:onTable:columns:">createIndex: indName onTable: aTable columns: aNameCollection	| aStream |	aStream := (String new: 100) writeStream.	aStream nextPutAll: 'CREATE INDEX ' , indName, ' ON ' , aTable, ' ( '.	aNameCollection 		do: [ :each | aStream nextPutAll: each, ', ' ].	aStream skip: -2.	aStream nextPutAll: ' )'.	self performCreate: [ self processSQL: aStream contents. ]		for: (aTable, '  ', indName)</body><body package="Store-DB-Broker" selector="createIndexForClass:">createIndexForClass: aClass 	self createIndexForClass: aClass 				index: (self tableName: aClass),  aClass indexName 				columns: aClass indexColumnNames</body><body package="Store-DB-Broker" selector="createIndexForClass:index:columns:">createIndexForClass: aClass index: indName columns: aNameCollection	"Creates an index on a given table that either 		changes the physical ordering of the table or		provides the optimizer with a logical ordering of the table to increase efficiency for queries."	self createIndex: indName 			onTable: (self tableNameWithPrefix: aClass) 			columns: (self columnList: aNameCollection for: aClass)</body><body package="Store-DB-Broker" selector="createSourcesViewForClass:">createSourcesViewForClass: aClass	self createView: (self tableName: aClass)		selectStatement: (self createViewSelectWithSourcesSQLForClass: aClass).	self grantForClass: aClass  permissions: #('SELECT')  toUsers: #('PUBLIC').</body><body package="Store-DB-Broker" selector="createTable:columns:">createTable: aTableName columns: columnString	"Creates a new table."	| aStream |	Transcript cr; show: 'Creating table for ' , aTableName.	aStream := (String new: 100) writeStream.	aStream nextPutAll: 'CREATE TABLE ' , aTableName,  columnString.	self performCreate: [	self processSQL: aStream contents]		for: aTableName</body><body package="Store-DB-Broker" selector="createTablePrimaryKeySectionFor:keys:">createTablePrimaryKeySectionFor: aClass keys: aKeyCollection		^self subclassResponsibility</body><body package="Store-DB-Broker" selector="createView:selectStatement:">createView: aViewName selectStatement: aSelectString	| aStream |	aStream := (String new: 100) writeStream.	aStream nextPutAll: 'CREATE VIEW ' ,  aViewName , ' as	SELECT ', aSelectString.	self performCreate: [	self processSQL: aStream contents ]		for: aViewName</body><body package="Store-DB-Broker" selector="createViewForClass:">createViewForClass: aClass	self createView: (self tableName: aClass)		selectStatement: (self createViewSelectSQLForClass: aClass).</body><body package="Store-DB-Broker" selector="createViewSelectSQLForClass:">createViewSelectSQLForClass: aClass	|  aStream collClass refClass refColumnNames |	aStream := (String new: 100) writeStream.	collClass := aClass subCollectionClass.	refClass := aClass referencedClass.	refColumnNames := (self allColumnsFor: refClass) asSet.	(self allColumnsFor: aClass) do: [:each |			| tName | 			tName := (refColumnNames includes: each) 				ifTrue: [ self tableNameWithPrefix: refClass ]				ifFalse: [ self tableNameWithPrefix: collClass ].			aStream nextPutAll: tName , '.' , each , ', '].	aStream skip: -2.	aStream nextPutAll: '	FROM ' , (self tableNameWithPrefix: collClass), ', ' , (self tableNameWithPrefix: refClass), '	WHERE '.	aStream nextPutAll: 		( self tableNameWithPrefix: collClass), '.', (self columnName: (aClass childReference) for: collClass),			 ' = ',			(self tableNameWithPrefix: refClass), '.', (self columnName: 'primaryKey' for: refClass).	^ aStream contents</body><body package="Store-DB-Broker" selector="createViewSelectWithSourcesSQLForClass:">createViewSelectWithSourcesSQLForClass: aClass	|  aStream collClass refClass refColumnNames defClass defRef defColumnNames |	aStream := (String new: 100) writeStream.	collClass := aClass subCollectionClass.	refClass := aClass referencedClass.	refColumnNames := (self allColumnsFor: refClass) asSet.	defClass := aClass definitionClass.	defRef := aClass definitionReferenceColumn.	defColumnNames := defClass defReferenceColumnNames. 	(self allColumnsFor: aClass) do: 		[ :each | | tName | 		tName := ( refColumnNames includes: each ) 			ifTrue: [ self tableNameWithPrefix: refClass ]			ifFalse: 				[ ( defColumnNames includes: each )					ifTrue: [ self tableNameWithPrefix: defClass ]					ifFalse: [ self tableNameWithPrefix: collClass ].				].		aStream nextPutAll: tName , '.' , each , ', '		].	aStream skip: -2.	aStream nextPutAll: '	FROM ' , (self tableNameWithPrefix: collClass), ', ' , 			  (self tableNameWithPrefix: refClass), ', ', 			  ( self tableNameWithPrefix: defClass ), '	WHERE '.	aStream nextPutAll: 		( self tableNameWithPrefix: collClass), '.', (self columnName: (aClass childReference) for: collClass),			 ' = ', (self tableNameWithPrefix: refClass), '.', (self columnName: 'primaryKey' for: refClass), ' 	AND ',		( self tableNameWithPrefix: refClass), '.', (self columnName: defRef for: defClass), 			' = ', ( self tableNameWithPrefix: defClass ), '.', ( self columnName: 'primaryKey' for: defClass ).	^ aStream contents</body><body package="Store-DB-Broker" selector="fileNameForBlobs">fileNameForBlobs	^'NEWBERN1' asString</body><body package="Store-DB-Broker" selector="fileNameForClasses">fileNameForClasses	^'NEWBERN2' asString</body><body package="Store-DB-Broker" selector="installPhysicalSpaces">installPhysicalSpaces	"Create the physical table spaces/device spaces   used by Store."	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="isPrimaryKeyType:">isPrimaryKeyType: aType	"Returns whether or not aType is a primary key type"	"Added by Philippe F. Monnet of Andersen Consulting"		^self primaryKeyTypes includes: aType</body><body package="Store-DB-Broker" selector="performCreate:for:">performCreate: aBlock for: aName	[		aBlock value.	]	on:  Error	do: [ :exception |		(self alreadyExistErrors includes: exception parameter first dbmsErrorCode)			ifTrue: 				[ Transcript cr; show:  exception parameter first dbmsErrorString.				exception return ]			ifFalse: 				[ DatabaseMessageBox openOnMessage: (self messageFor: exception). 				DbRegistry goOffLine.				exception pass ]	].</body><body package="Store-DB-Broker" selector="primaryKeyTypes">primaryKeyTypes	"Returns the primary key types"	^#( #PrimaryKey #PrimaryKeyInteger #PrimaryKeyString 		#PrimaryKeyChar #PrimaryKeyShortString)</body><body package="Store-DB-Broker" selector="spaceForBlobs">spaceForBlobs"MB"	^ '16'</body><body package="Store-DB-Broker" selector="spaceForClasses">spaceForClasses"MB"	^'32'</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>queries</category><body package="Store-DB-Broker" selector="alterTableFor:addColumn:">alterTableFor: aClass addColumn: aString	"Column name must be a String for compatibility with #fieldTypes"	| aType |	aType := aClass fieldTypes at: aString asString ifAbsent: [#String].	self process: 		((self newSQLFor: aClass)			addColumn: (self columnName: aString for: aClass) dbType: (self typeToStringMap at: aType))</body><body package="Store-DB-Broker" selector="alterTableFor:pctIncreaseBy:">alterTableFor: aClass  pctIncreaseBy: aNumber	| sql |	sql :=  (self newSQLFor: aClass)			alterPstincrease: aNumber printString.	self process: sql.	Transcript cr; show: sql, '-- Done!'.</body><body package="Store-DB-Broker" selector="newSQLFor:">newSQLFor: aClass	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="nextIDQuery:">nextIDQuery: aClass	^self subclassResponsibility</body><body package="Store-DB-Broker" selector="sqlAssistClass">sqlAssistClass	^self subclassResponsibility</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>debugging</category><body package="Store-DB-Broker" selector="debugLabelsAndValues">debugLabelsAndValues	^List new		add: ('Sql Statements'-&gt;#SQLBroker);		yourself</body><body package="Store-DB-Broker" selector="log:level:">log: aString level: aLevel	[ DbRegistry debugger log: aString  level: aLevel ] on: Error do: [ :ex | nil ]</body><body package="Store-DB-Broker" selector="menuItemName">menuItemName	^'Store Messages'</body><body package="Store-DB-Broker" selector="registerToDebug">registerToDebug	[DbRegistry debugger addToDebug: self] on: Error do: [ :ex | ]</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>class initialization</category><body package="Store-DB-Broker" selector="initialize">initialize	self registerToDebug</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>private-column names</category><body package="Store-DB-Broker" selector="allColumnsFor:">allColumnsFor: aClass	"Control access to column names for class because 		some databases are unable to use attribute names for columns.	To override method, invoke super #allColumnsFor: 		and then convert names as required by specific database"	^aClass columnNames.</body><body package="Store-DB-Broker" selector="allUpdatableColumnsFor:">allUpdatableColumnsFor: aClass	"Control access to column names for class because 		some databases are unable to use attribute names for columns.	To override method, invoke super #allUpdatableColumnsFor: 		and then convert names as required by specific database"	| aColl |	aColl := OrderedCollection new.	#( 'version'  'versionComment'  'blessingLevel' )  do: [ :each  |		(aClass columnNames includes:	each) ifTrue: [ aColl add: each ]	].	^aColl</body><body package="Store-DB-Broker" selector="columnList:for:">columnList: aCollection for: aClass	"Control access to column names for class because 		some databases are unable to use attribute names for columns.	Override method to convert names as required by specific database table."	^ aCollection.</body><body package="Store-DB-Broker" selector="columnName:for:">columnName: aStringOrSymbol for: aClass	"Control access to column names for class because 		some databases are unable to use attribute names for columns.	Override method to convert name as required by specific database table."	^aStringOrSymbol.</body></methods><methods><class-id>Store.TextLine</class-id> <category>testing</category><body package="Store-UI" selector="=">= aTextLine	^string = aTextLine string</body><body package="Store-UI" selector="isEmpty">isEmpty	^string isEmpty or: [string size = 1 and: [(string at: 1) = Character cr]]</body></methods><methods><class-id>Store.TextLine</class-id> <category>accessing</category><body package="Store-UI" selector="sourceString">sourceString	^sourceString</body><body package="Store-UI" selector="sourceString:">sourceString: aString	sourceString := aString</body><body package="Store-UI" selector="startIndex">startIndex	^startIndex</body><body package="Store-UI" selector="startIndex:">startIndex: anInteger	startIndex := anInteger</body><body package="Store-UI" selector="stopIndex">stopIndex	^stopIndex</body><body package="Store-UI" selector="stopIndex:">stopIndex: anInteger	stopIndex := anInteger</body><body package="Store-UI" selector="string">string	^string</body><body package="Store-UI" selector="string:">string: aString	string := aString</body></methods><methods><class-id>Store.TextLine class</class-id> <category>instance creation</category><body package="Store-UI" selector="from:to:source:">from: startIndex to: stopIndex source: aString	| aLine |	aLine := self new.	aLine sourceString: aString.	aLine string: (aString copyFrom: startIndex to: stopIndex).	aLine startIndex: startIndex.	aLine stopIndex: stopIndex.	^aLine</body></methods><methods><class-id>Store.AbstractModification</class-id> <category>testing</category><body package="Store-Merge" selector="existsInImage">existsInImage	^tag existsInImage</body><body package="Store-Merge" selector="isMoveModification">isMoveModification		^false</body><body package="Store-Merge" selector="isPublishedModification">isPublishedModification		^false</body><body package="Store-Merge" selector="isTextModification">isTextModification		^false</body></methods><methods><class-id>Store.AbstractModification</class-id> <category>comparing</category><body package="Store-Merge" selector="=">= aMod 	self subclassResponsibility</body></methods><methods><class-id>Store.AbstractModification</class-id> <category>accessing</category><body package="Store-Merge" selector="description">description	self subclassResponsibility</body><body package="Store-Merge" selector="existsInPackage">existsInPackage	self subclassResponsibility</body><body package="Store-Merge" selector="package">package	^package</body><body package="Store-Merge" selector="package:">package: aPackage	package := aPackage.	tag == nil		ifFalse: [ tag package: aPackage ].</body><body package="Store-Merge" selector="packageName">packageName	^package isNil		ifTrue: ['']		ifFalse: [package name]</body><body package="Store-Merge" selector="record">record	"Added by Philippe F. Monnet of Andersen Consulting	Added for compatibity with TT_Modification. 	This is called by: TT_MergeData &gt; resolutionRecordForTag: aTag packageNamed: aName"		^nil</body><body package="Store-Merge" selector="source">source	"Answer the source code or nil if not there."	self subclassResponsibility</body><body package="Store-Merge" selector="tag">tag	^tag</body><body package="Store-Merge" selector="tag:">tag: aTag	tag := aTag</body><body package="Store-Merge" selector="timeStampString">timeStampString	self subclassResponsibility</body></methods><methods><class-id>Store.AbstractModification</class-id> <category>printing</category><body package="Store-Merge" selector="printOn:">printOn: aStream	"Print tag first and then package."	aStream nextPut: $&lt;.	tag printOn: aStream.	aStream nextPut: $@.	self package printOn: aStream.	aStream nextPut: $&gt;</body></methods><methods><class-id>Store.AbstractModification</class-id> <category>actions</category><body package="Store-Merge" selector="apply">apply	"Apply a modification to the image. 	Answer true if the application is successful."	self subclassResponsibility</body><body package="Store-Merge" selector="moveFromPackage:to:">moveFromPackage: oldPkg to: newPkg	"*** inspired by Philippe F. Monnet ***"	"Ask if this modification should be moved to the package	it was loaded from."	(oldPkg isNil or: [Dialog confirm: 'Do you wish to move ' , tag printString , 'from its current package [' , oldPkg name , '] to the package it was loaded from [' , newPkg name , '] ?' initialAnswer: true])		ifTrue: [tag moveToPackage: newPkg]</body></methods><methods><class-id>Store.AbstractModification</class-id> <category>change list support</category><body package="Store-Merge" selector="browseSystemVersionIfExists">browseSystemVersionIfExists	"Open a browser on the system version of this override if possible.	 Answer if it was possible."	^tag browseSystemVersionIfExists</body><body package="Store-Merge" selector="className">className	^tag className</body><body package="Store-Merge" selector="cleanSourceFrom:">cleanSourceFrom: aString	"Return a version of aString which has a cr line-end convention imposed upon it."	#revisitBeforeRelease.	^Kernel.Change new cleanSourceFrom: aString</body><body package="Store-Merge" selector="componentString">componentString	^'&lt;1s&gt;: &lt;2s&gt;'		expandMacrosWith: package classDescription with: package name.</body><body package="Store-Merge" selector="fileOutOn:">fileOutOn: aStream	"Fileout the change onto aStream."	tag fileOutOn: aStream from: self record in: package</body><body package="Store-Merge" selector="hasVersionInSystem">hasVersionInSystem	^self existsInImage</body><body package="Store-Merge" selector="isClassRelated">isClassRelated	^tag isForClass</body><body package="Store-Merge" selector="isCommentChange">isCommentChange	^tag isCommentChange</body><body package="Store-Merge" selector="isMethodRelated">isMethodRelated	^tag isForMethod</body><body package="Store-Merge" selector="name">name	"Answer a name for the list."	^tag name</body><body package="Store-Merge" selector="nonMetaClassName">nonMetaClassName	^tag nonMetaClassName</body><body package="Store-Merge" selector="protocol">protocol	^[ tag protocol ] on: MessageNotUnderstood do:		[ :ex | ex return: nil ].</body><body package="Store-Merge" selector="sameAsSystem">sameAsSystem	self subclassResponsibility</body><body package="Store-Merge" selector="sameAsSystem:">sameAsSystem: list	^self sameAsSystem</body><body package="Store-Merge" selector="selector">selector	^tag isForMethod		ifTrue: [ tag selector ]</body><body package="Store-Merge" selector="text">text	"Asnwer the text to display in a text window."	^tag sourceTextForImage</body><body package="Store-Merge" selector="type">type	"Answer a symbol representing the sub-type of this kind of modification." 	^tag type</body></methods><methods><class-id>Store.Modification</class-id> <category>testing</category><body package="Store-Merge" selector="isPublishedModification">isPublishedModification		^true</body></methods><methods><class-id>Store.Modification</class-id> <category>comparing</category><body package="Store-Merge" selector="=">= aMod 	^( aMod notNil and: [ record notNil ] ) and: 		[ aMod isPublishedModification and: 			[ aMod isMoveModification not and: [ aMod record = self record ] ]		]</body></methods><methods><class-id>Store.Modification</class-id> <category>accessing</category><body package="Store-Merge" selector="description">description	self package isNil ifTrue: [^''].	^self packageName, self package versionStringAlternate, ' '</body><body package="Store-Merge" selector="existsInPackage">existsInPackage	^record notNil</body><body package="Store-Merge" selector="key">key	^package isNil		ifTrue: [nil]		ifFalse: [package primaryKey]</body><body package="Store-Merge" selector="record">record	^record</body><body package="Store-Merge" selector="record:">record: aRecord	record := aRecord</body><body package="Store-Merge" selector="source">source	"Answer the source code or nil if not there."	^record isNil		ifTrue: [nil]		ifFalse: [record textRepresentationForTag: tag ]</body><body package="Store-Merge" selector="timeStampString">timeStampString	^self package timeStampString</body></methods><methods><class-id>Store.Modification</class-id> <category>actions</category><body package="Store-Merge" selector="apply">apply	"Apply a modification to the image. 	Answer true if the application is successful."	| imPkg  result |	(tag existsInImage not and: [record isNil])		ifTrue: [^true].	( tag existsInImage and: [ record isNil &amp; package isNil ] )		ifTrue: [ tag removeFromSystem.  ^true "must be a removal" ]. 	imPkg := package getImagePundle.	imPkg isNil		ifTrue: 			["Create a package."			self error: 'Package ', package name, ' missing from image - should not occur'.			imPkg := PackageModel named: package name.			imPkg dbTrace: package primaryKey.			].	result := tag loadIntoPackage: imPkg from: record.	^result</body></methods><methods><class-id>Store.Modification</class-id> <category>change list support</category><body package="Store-Merge" selector="category">category	^record isForMethod		ifTrue: [ record protocolName ]</body><body package="Store-Merge" selector="name">name	"Answer a name for the list."	record name</body><body package="Store-Merge" selector="sameAsSystem">sameAsSystem	"No record, so this is the system."	^record sameAsImage</body><body package="Store-Merge" selector="systemCategory">systemCategory	"Return the category of the corresponding change in the system, if any"	^record isForMethod		ifTrue: [ record systemCategory ]</body></methods><methods><class-id>Store.Modification class</class-id> <category>instance creation</category><body package="Store-Merge" selector="tag:package:record:">tag: aTag package: aPackage record: aRecord	|baby|	baby := self new.	baby tag: aTag; package: aPackage; record: aRecord.	^baby</body></methods><methods><class-id>Store.LoadDialog class</class-id> <category>public utilities</category><body package="Store-UI" selector="okToLoadBundle:">okToLoadBundle: aDBBundle	"Answer true if it is acceptable to lose changes to modified	 pundles in aDBBundle."	^self okToLoadLeafItems: aDBBundle allUniqueItems.</body></methods><methods><class-id>Store.LoadDialog class</class-id> <category>private</category><body package="Store-UI" selector="okToLoadLeafItems:">okToLoadLeafItems: pundleCollection	| modifiedPundleModels imPundle |	modifiedPundleModels := OrderedCollection new.	pundleCollection do: [:aPundle |		((imPundle := aPundle getImagePundle) notNil 				and: [imPundle hasItselfBeenModified])			ifTrue: [modifiedPundleModels add: imPundle]].	^self okToReplaceModifiedPundles: modifiedPundleModels</body><body package="Store-UI" selector="okToReplaceModifiedPundles:">okToReplaceModifiedPundles: pundleModelCollection	| dialog builder |	pundleModelCollection isEmpty ifTrue: [^true].	dialog := SimpleDialog new.	builder := dialog builder.	builder aspectAt: #text put: (self warningForModifiedPundles: pundleModelCollection) asValue.	^dialog openFrom: (self interfaceSpecFor: #loadDialogSpec).</body><body package="Store-UI" selector="warningForModifiedPundles:">warningForModifiedPundles: aPundleCollection	| warnStream writeItemList |	warnStream := WriteStream on: (String new: 300).	warnStream nextPutAll: 'The following items have been modified.  Replace them with new versions?';		cr; cr.	writeItemList := [:label :pundles |		pundles isEmpty ifFalse: [			warnStream tab;				nextPutAll: label;				cr.			pundles do: [:aPundle |				warnStream tab; tab;					nextPutAll: aPundle name;					cr]]].	writeItemList value: 'Modified Packages:' value: (aPundleCollection select: [:aPundle | aPundle isPackage]).	writeItemList value: 'Modified Bundles:' value: (aPundleCollection select: [:aPundle | aPundle isBundle]).	^warnStream contents</body></methods><methods><class-id>Store.PundleParent</class-id> <category>file out</category><body package="Store-IMG-Pundles" selector="writeOn:">writeOn: aStream	aStream nextPut: self typeDescription.	aStream tab.	name storeOn:  aStream.	aStream tab.	trace storeOn:  aStream.	aStream cr.</body></methods><methods><class-id>Store.PundleParent</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="initFrom:">initFrom: aPundle	name := aPundle name.	trace := aPundle dbTrace.</body><body package="Store-IMG-Pundles" selector="initFromDB:">initFromDB: aPundle	name := aPundle name.	trace := aPundle primaryKey.</body><body package="Store-IMG-Pundles" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream nextPut: $[.	name printOn: aStream.	aStream space.	trace printOn: aStream.	aStream nextPut: $].</body><body package="Store-IMG-Pundles" selector="pundleKind">pundleKind	^self class pundleKind</body><body package="Store-IMG-Pundles" selector="readFrom:">readFrom: aStream	name := String readFrom: aStream.	aStream skipSeparators.	trace := Integer readFrom: aStream.	aStream skipThrough: Character cr.</body><body package="Store-IMG-Pundles" selector="reconnect">reconnect	"Answer true if a pundle is loaded and has the same parent."	| pndl aStream str |	aStream := (String new: 50) writeStream.	aStream nextPutAll: 'Cannot reconnect the '.	pndl := self pundle.	str := self pundleKind.	aStream nextPutAll: str; space.	name printOn: aStream.	aStream nextPutAll: ' because:'; cr.	name printOn: aStream.	pndl isNil		ifTrue: 			[aStream nextPutAll: ' is not loaded'.			Dialog warn: aStream contents]		ifFalse: [pndl hasTrace				ifTrue: [trace = pndl dbTrace						ifFalse: 							[aStream nextPutAll: ' has different parent.Parent specified on the map is :'.							trace printOn: aStream.							aStream cr; nextPutAll: 'Existing parent is: '.							pndl dbTrace printOn: aStream.							Dialog warn: aStream contents]]				ifFalse: [self setTraceFor: pndl]]</body><body package="Store-IMG-Pundles" selector="setTraceFor:">setTraceFor: aPundle	aPundle dbTrace: trace</body><body package="Store-IMG-Pundles" selector="testParent">testParent	"Answer true if a pundle is loaded and has the same parent."	| pndl |	pndl := self pundle.	^pndl notNil and: [trace = pndl dbTrace]</body><body package="Store-IMG-Pundles" selector="typeDescription">typeDescription	^self class typeDescription</body></methods><methods><class-id>Store.PundleParent class</class-id> <category>instance creation</category><body package="Store-IMG-Pundles" selector="newFrom:">newFrom: aPundle	| baby |	baby := self new.	baby initFrom: aPundle.	^baby</body><body package="Store-IMG-Pundles" selector="newFromDB:">newFromDB: aPundle	| baby |	baby := self new.	baby initFromDB: aPundle.	^baby</body><body package="Store-IMG-Pundles" selector="readFrom:">readFrom: aStream	| typeDescr dClass descr |	typeDescr := aStream next.	dClass := self descriptionClassForType: typeDescr.	descr := dClass new.	aStream next.	descr  readFrom: aStream.	^descr</body></methods><methods><class-id>Store.PundleParent class</class-id> <category>utilities</category><body package="Store-IMG-Pundles" selector="descriptionClassForPundle:">descriptionClassForPundle: aPundle	^PundleMap at: aPundle class</body><body package="Store-IMG-Pundles" selector="descriptionClassForType:">descriptionClassForType: aType	^PundleTypes at: aType</body></methods><methods><class-id>Store.PundleParent class</class-id> <category>class initialization</category><body package="Store-IMG-Pundles" selector="initialize">initialize	PundleTypes := IdentityDictionary new.	PundleMap := IdentityDictionary new.</body></methods><methods><class-id>Store.BundleParent</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="pundle">pundle	^Registry bundleNamed: name</body></methods><methods><class-id>Store.BundleParent class</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="pundleKind">pundleKind	^'bundle'</body><body package="Store-IMG-Pundles" selector="typeDescription">typeDescription	^$B</body></methods><methods><class-id>Store.BundleParent class</class-id> <category>class initialization</category><body package="Store-IMG-Pundles" selector="initialize">initialize	"self initialize"	PundleTypes isNil ifTrue: [super initialize].	PundleTypes at: self typeDescription put: self.	PundleMap at: BundleModel put: self.</body></methods><methods><class-id>Store.PackageParent</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="pundle">pundle	^Registry packageNamed: name</body><body package="Store-IMG-Pundles" selector="setTraceFor:">setTraceFor: aPundle	aPundle markNotModified.	super setTraceFor: aPundle.</body></methods><methods><class-id>Store.PackageParent class</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="pundleKind">pundleKind	^'package'</body><body package="Store-IMG-Pundles" selector="typeDescription">typeDescription	^$P</body></methods><methods><class-id>Store.PackageParent class</class-id> <category>class initialization</category><body package="Store-IMG-Pundles" selector="initialize">initialize	"self initialize"	PundleTypes isNil ifTrue: [super initialize].	PundleTypes at: self typeDescription put: self.	PundleMap at: PackageModel put: self.</body></methods><methods><class-id>Store.SQLAssist</class-id> <category>private</category><body package="Store-DB-Broker" selector="allColumnNames">allColumnNames	"Answer array of all column names from instance variables of aClass. 	Implemented here so we can re-map column names, if necessary."	^alias notNil		ifTrue: [self tableClass columnNames collect: [:name | alias , '.' , name]]		ifFalse: [self tableClass columnNames]</body><body package="Store-DB-Broker" selector="allHostVariableNames">allHostVariableNames 	"Answer array of all column names from instance variables of aClass.		These will be used as accessors."	^ self tableClass columnNames collect: [ :each | ':', each ]</body><body package="Store-DB-Broker" selector="columnName:">columnName: aStringOrSymbol 	"Answer the column name. 		Implemented here so we can re-map column names, as necessary.		Override for conversions as required by specific Database Table."	^alias notNil ifTrue: [alias , '.', aStringOrSymbol] ifFalse: [aStringOrSymbol]</body><body package="Store-DB-Broker" selector="removePrimaryKeyColumn:">removePrimaryKeyColumn: anArray	"Some databases do not allow CREATE and/or INSERT statements		to specify columns whose values are auto-generated.	 Override this method to exclude column 'primaryKey', as required.		This method is invoked before any column name re-mapping."	^anArray</body><body package="Store-DB-Broker" selector="removePrimaryKeyValue:">removePrimaryKeyValue: anArray	"Some databases do not allow CREATE and/or INSERT statements		to specify columns whose values are auto-generated.	 Override this method to exclude host variable ':primaryKey', as required."	^anArray</body></methods><methods><class-id>Store.SQLAssist</class-id> <category>accessing</category><body package="Store-DB-Broker" selector="alias">alias	^alias</body><body package="Store-DB-Broker" selector="alias:">alias: aString	alias := aString</body><body package="Store-DB-Broker" selector="newSQLStream">newSQLStream	^ sqlStream := (String new: 150) writeStream.</body><body package="Store-DB-Broker" selector="sqlString">sqlString	^ sqlStream contents</body><body package="Store-DB-Broker" selector="tableClass">tableClass	^ tableClass</body><body package="Store-DB-Broker" selector="tableClass:">tableClass: aClass	tableClass := aClass</body><body package="Store-DB-Broker" selector="tableName">tableName	^ alias notNil ifTrue: [tableName, ' ', alias] ifFalse: [tableName]</body><body package="Store-DB-Broker" selector="tableName:">tableName: aString	tableName := aString</body></methods><methods><class-id>Store.SQLAssist</class-id> <category>utility</category><body package="Store-DB-Broker" selector="smalltalkWildcardToSql:">smalltalkWildcardToSql: aString	"Translates a smalltalk wild card string to a sql wildcard string."	"* becomes % and ? becomes _"	| string index |	string := aString copy.	[ ( index := string indexOfSubCollection: '*' startingAt: 1 ) == 0 ]		whileFalse: [ string at: index put: $% ].	[ ( index := string indexOfSubCollection: '?' startingAt: 1 ) == 0 ]		whileFalse: [ string at: index put: $_ ].	^string</body></methods><methods><class-id>Store.SQLAssist</class-id> <category>queries</category><body package="Store-DB-Broker" selector="addColumn:dbType:">addColumn: aString dbType: aColType	sqlStream nextPutAll: 'ALTER TABLE ', self tableName, ' ADD '.	self column: aString.	sqlStream nextPutAll: aColType.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="addString:">addString: aString	sqlStream nextPutAll: aString.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="alterPstincrease:">alterPstincrease: aNumber	sqlStream nextPutAll: 'ALTER TABLE ', self tableName, ' STORAGE (  PCTINCREASE ', aNumber, ' )'.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="and">and	sqlStream nextPutAll: ' AND '</body><body package="Store-DB-Broker" selector="beginClause">beginClause 	sqlStream nextPutAll: ' ( '</body><body package="Store-DB-Broker" selector="column:">column: column	sqlStream nextPutAll: ' ', (self columnName: column), ' '.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="column:equalTo:">column: column equalTo: value	self column: column.	sqlStream nextPutAll: '= ',  value.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="column:equalToArray:">column: column equalToArray: values	"Add a where clause that selects the value equal to one in an array of values."	self column: column; in.	self beginClause.	values 		do: [ :each | sqlStream nextPutAll: each ]		separatedBy:[ sqlStream nextPutAll: ', ' ].	self endClause.	^sqlStream contents</body><body package="Store-DB-Broker" selector="column:greaterThan:">column: column greaterThan: value	self column: column.	sqlStream nextPutAll:  '&gt; ' ,  value.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="column:lessThan:">column: column lessThan: value	self column: column. 	sqlStream nextPutAll: '&lt; ' , value.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="column:like:">column: column like: value	self column: column. 	sqlStream nextPutAll: 'like ' ,  value.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="column:notEqualTo:">column: column  notEqualTo: value	sqlStream nextPutAll: ' ', column, ' &lt;&gt; ',  value.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="column:notEqualToArray:">column: column notEqualToArray: values	"Add a where clause that selects the value not equal to one in an array of values."	self beginClause.	values 		do: [ :each | self column: column notEqualTo: each ]		separatedBy:[ self and ].	self endClause.	^sqlStream contents</body><body package="Store-DB-Broker" selector="column:wildcard:">column: column wildcard: string	| param |	param := self smalltalkWildcardToSql: string.	self column: column.	sqlStream nextPutAll: 'like ',  param.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="columnSAVE:equalToArray:">columnSAVE: column equalToArray: values	"Add a where clause that selects the value equal to one in an array of values."	self column: column; in.	self beginClause.	values 		do: [ :each | sqlStream nextPutAll: each ]		separatedBy:[ sqlStream nextPutAll: ', ' ].	self endClause.	^sqlStream contents</body><body package="Store-DB-Broker" selector="delete">delete	sqlStream nextPutAll: 'DELETE FROM ', self tableName.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="endClause">endClause 	sqlStream nextPutAll: ' ) '.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="equal">equal	sqlStream nextPutAll: ' = '.</body><body package="Store-DB-Broker" selector="in">in	sqlStream nextPutAll: ' IN '</body><body package="Store-DB-Broker" selector="in:">in: aString	sqlStream nextPutAll: ' IN (', aString, ' ) '.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="innerJoin:">innerJoin: joinSql 		^ self join: joinSql  type: ' INNER JOIN '</body><body package="Store-DB-Broker" selector="insert:">insert: aColumnArray	| arr |	arr := self removePrimaryKeyColumn: aColumnArray.	sqlStream nextPutAll: 'INSERT INTO ', self tableName, ' ('.	arr do:		[ :col | 		self column: col.		sqlStream nextPutAll: ',' ].	sqlStream skip: -1.	sqlStream nextPutAll: ' ) '.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="insertColumns:values:">insertColumns: aColumnArray values: aValueArray	self insert: aColumnArray.	self insertValues: aValueArray.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="insertColumnsValues:">insertColumnsValues: aColumnArray	"Column names are used as host variables / accessors"	self insertColumns: aColumnArray 		values: (aColumnArray collect: [ :each | ':' , each ] ).	^ sqlStream contents</body><body package="Store-DB-Broker" selector="insertValues:">insertValues: aValueArray	| arr |	" aValueArray is a list of host variable names (each preceeded by a colon).		Colon is stripped and the name is used as accessor. "	arr := self removePrimaryKeyValue: aValueArray.	sqlStream nextPutAll: ' VALUES ('.	arr do: 		[ :col | sqlStream nextPutAll: col , ', ' ].	sqlStream skip: -2.	sqlStream nextPut: $).	^ sqlStream contents</body><body package="Store-DB-Broker" selector="isNull">isNull	sqlStream nextPutAll: ' IS NULL '</body><body package="Store-DB-Broker" selector="join:type:">join: joinSql type: aType	"insert join statement"	sqlStream nextPutAll: aType ;		nextPutAll: joinSql tableName;		nextPutAll: ' ON '.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="joinedColumn:">joinedColumn: column"Like column: but without modifying of sqlStream"	^' ', (self columnName: column), ' '.</body><body package="Store-DB-Broker" selector="leftJoin:">leftJoin: joinSql 		^ self join: joinSql  type: ' LEFT OUTER JOIN '</body><body package="Store-DB-Broker" selector="notEqual">notEqual	sqlStream nextPutAll: ' &lt;&gt; '.</body><body package="Store-DB-Broker" selector="notIn">notIn	sqlStream nextPutAll: ' NOT IN '</body><body package="Store-DB-Broker" selector="notIn:">notIn: aString	sqlStream nextPutAll: ' NOT IN (', aString, ')'.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="notNull">notNull	sqlStream nextPutAll: ' NOT NULL '</body><body package="Store-DB-Broker" selector="or">or	sqlStream nextPutAll: ' OR '</body><body package="Store-DB-Broker" selector="orderBy:">orderBy: column	sqlStream nextPutAll: ' ORDER BY ', (self columnName: column). 	^ sqlStream contents</body><body package="Store-DB-Broker" selector="rightJoin:">rightJoin: joinSql 		^ self join: joinSql  type: ' RIGHT OUTER JOIN '</body><body package="Store-DB-Broker" selector="select:">select: aColumnArray	sqlStream nextPutAll: 'SELECT '.	aColumnArray do: 		[ :col | 		self column: col.		sqlStream nextPutAll: ',' ].	sqlStream skip: -1.	sqlStream nextPutAll: ' FROM ', self tableName.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="selectAll">selectAll	sqlStream nextPutAll: 'SELECT 	'.	alias notNil ifTrue: [	sqlStream nextPutAll: alias, '.' ].	sqlStream nextPutAll: '* FROM ', self tableName.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="selectCountAll">selectCountAll	sqlStream nextPutAll: 'SELECT COUNT (*) FROM ', self tableName.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="selectDistinct:">selectDistinct: aColumnArray	sqlStream nextPutAll: 'SELECT  DISTINCT '.	aColumnArray do: 		[ :col | 		self column: col.		sqlStream nextPutAll: ',' ].	sqlStream skip: -1.	sqlStream nextPutAll: ' FROM ', self tableName.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="selectMax:">selectMax: aColumnArray	sqlStream nextPutAll: 'SELECT MAX ('.	aColumnArray do: 		[ :col | 		self column: col.		sqlStream nextPutAll: ',' ].	sqlStream skip: -1. 	sqlStream nextPutAll: ') FROM ', self tableName.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="setColumns:equalTo:">setColumns: columnArray equalTo: valueArray	"For set commands. Sets each column equal to cooresponding value in valueArray"	self update.	columnArray with: valueArray do:		[ :column :value |		self column: column.		sqlStream nextPutAll: '= ',  value.		sqlStream nextPutAll: ', '.		].	sqlStream skip: -2.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="update">update	sqlStream nextPutAll: 'UPDATE ', self tableName, ' SET '.	^ sqlStream contents</body><body package="Store-DB-Broker" selector="where">where	sqlStream nextPutAll: ' WHERE '</body><body package="Store-DB-Broker" selector="whereSqlString">whereSqlString	| columns values |	" Column names might need to be re-mapped 		but host variables for values must be the attribute names (accessors).		Therefore, we need to iterate over both lists concurrently. "	self where.	columns := self allColumnNames.		values := self allHostVariableNames.	columns with: values do: 		[ : column :value |		sqlStream 			cr; tab;			nextPutAll: column;			nextPutAll: ' = ';			nextPutAll: value;			nextPutAll: ' AND '.		].	sqlStream skip: -4.	sqlStream cr.	^sqlStream contents</body></methods><methods><class-id>Store.SQLAssist</class-id> <category>special</category><body package="Store-DB-Broker" selector="classNamesInPackages:">classNamesInPackages: pkgIds"copied from Method class&gt;&gt;classNamesInPackages:"	^self 	  selectDistinct: #( #className );	  where;	  column: #primaryKey;	  in:  ( MethodsView newSQL		select: #( #primaryKey );		where;		column: #packageRef equalToArray: 				( pkgIds collect: [ :pkg | pkg primaryKey printString ] )  	 	);	sqlString</body><body package="Store-DB-Broker" selector="recordsWithSourcesIn:butNotIn:">recordsWithSourcesIn:  aPrimaryKey butNotIn: bPrimaryKey "copied from ViewRecord&gt;&gt;recordsWithSourcesIn: butNotIn: "	self selectAll;		where;		column: #packageRef equalTo: aPrimaryKey printString;		and;  column: #primaryKey; notIn;		beginClause;		addString:			( tableClass subCollectionClass newSQL			select: ( Array with: tableClass childReference );			where;			column: #packageRef equalTo: bPrimaryKey printString;			endClause			);		yourself.</body></methods><methods><class-id>Store.SQLAssist class</class-id> <category>instance creation</category><body package="Store-DB-Broker" selector="newSQLFor:table:">newSQLFor: aClass table: aTableName	^ super new 		newSQLStream;		tableName: aTableName;		tableClass: aClass</body></methods><methods><class-id>Store.CommentPrompt</class-id> <category>interface opening</category><body package="Store-UI" selector="preBuildWith:">preBuildWith: aBuilder 	"Get the blessing names."	aBuilder aspectAt: #blessingLevelMenu put: (Policies blessingPolicy blessingLevelsMenuForPundle: self pundle)</body></methods><methods><class-id>Store.CommentPrompt</class-id> <category>aspects</category><body package="Store-UI" selector="addComment:">addComment: aString	self text value: self defaultComment, self text value.	(aString isNil or: [aString isEmpty]) ifTrue: [^self].	self text value: aString, '', self text value.</body><body package="Store-UI" selector="blessingLevel">blessingLevel	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^blessingLevel isNil		ifTrue:			[blessingLevel := 0 asValue]		ifFalse:			[blessingLevel]</body><body package="Store-UI" selector="defaultComment">defaultComment	^'Version created by: ', self userName, ' on: ', Date today printString,  ' ', Time now printString, ''</body><body package="Store-UI" selector="text">text	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^text isNil		ifTrue:			[text := String new asValue]		ifFalse:			[text]</body></methods><methods><class-id>Store.CommentPrompt</class-id> <category>initialize-release</category><body package="Store-UI" selector="initialize">initialize	super initialize.	text := '' asValue.</body></methods><methods><class-id>Store.CommentPrompt</class-id> <category>accessing</category><body package="Store-UI" selector="pundle">pundle	^pundle</body><body package="Store-UI" selector="pundle:">pundle: aPundle	pundle := aPundle</body><body package="Store-UI" selector="userName">userName	^userName isNil ifTrue: ['Unknown'] ifFalse: [userName]</body><body package="Store-UI" selector="userName:">userName: aString		userName := aString</body></methods><methods><class-id>Store.CommentPrompt class</class-id> <category>instance creation</category><body package="Store-UI" selector="forPundle:">forPundle: aPundle	^self new pundle: aPundle</body></methods><methods><class-id>Store.RepositoryManager</class-id> <category>actions</category><body package="Store-UI" selector="fileClose">fileClose	self closeRequest</body><body package="Store-UI" selector="fileLoad">fileLoad	self class loadRepositoriesFromFile</body><body package="Store-UI" selector="fileSave">fileSave	self class saveRepositoriesToFile</body><body package="Store-UI" selector="helpAbout">helpAbout	AboutVisualWorksDialog open</body><body package="Store-UI" selector="repositoryMoreRecentlyPublishedItems">repositoryMoreRecentlyPublishedItems	| list list2 |	DbRegistry doIfOnlineImage: 		[ list := (Registry allPackagesWithNewerInDB collect: [ :pkg | pkg name ]) asSet.		list2  := (Registry allBundlesWithNewerInDB collect: [ :bundle | bundle name ]) asSet.		Store.PublishedPundlesTool openOnBundles: list2 packages: list title: 'More Recently Published Items'		]</body><body package="Store-UI" selector="repositoryNew">repositoryNew	RepositoryManager addProfileFromUser ifNotNil: 		[:newProfile | self repositoryListHolder selection: newProfile]</body><body package="Store-UI" selector="repositoryProperties">repositoryProperties	self repositoryListHolder selectionDo:		[:selection |		RepositoryPropertiesDialog openOn: selection.		self class updateRepository: selection]</body><body package="Store-UI" selector="repositoryPublishedItems">repositoryPublishedItems	DbRegistry 		doIfOnlineImage: [Store.PublishedPundlesTool openOnAllPublishedPundles]</body><body package="Store-UI" selector="repositoryRemove">repositoryRemove	self repositoryListHolder selectionDo:		[:selection |		(Dialog confirm: #repmanRemoveRepositoryQuestion &lt;&lt; #labels &gt;&gt; 'Remove the selected repository?') 			ifTrue: [self class removeRepository: selection]]</body><body package="Store-UI" selector="repositoryToggleConnection">repositoryToggleConnection	Cursor wait showWhile:		[self repositoryListHolder selectionDo:			[:profile |			profile isConnected				ifTrue: [DbRegistry disconnect]				ifFalse: [DbRegistry connectTo: profile]]]</body></methods><methods><class-id>Store.RepositoryManager</class-id> <category>initialize-release</category><body package="Store-UI" selector="initialize">initialize	super initialize.	DbRegistry connectedProfileHolder		onChangeSend: #connectedProfileChanged		to: self</body><body package="Store-UI" selector="on:">on: aProfileCollection	self setRepositoryList: aProfileCollection</body><body package="Store-UI" selector="postBuildWith:">postBuildWith: aBuilder	| descriptors |	descriptors := (self widgetAt: #repositoryDataset) columnDescriptors.	descriptors first rendererSpec: self statusColumnSpec.</body><body package="Store-UI" selector="release">release	super release.	DbRegistry connectedProfileHolder		retractInterestsFor: self</body></methods><methods><class-id>Store.RepositoryManager</class-id> <category>notifications</category><body package="Store-UI" selector="connectedProfileChanged">connectedProfileChanged	self refreshRepositoryView</body><body package="Store-UI" selector="noticeOfWindowClose:">noticeOfWindowClose: aWindow	self release.	^super noticeOfWindowClose: aWindow</body><body package="Store-UI" selector="repositoryListDoubleClicked">repositoryListDoubleClicked	self repositoryToggleConnection</body><body package="Store-UI" selector="repositorySelected">repositorySelected	self updateToolbar</body></methods><methods><class-id>Store.RepositoryManager</class-id> <category>aspects</category><body package="Store-UI" selector="repositoryListHolder">repositoryListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^repositoryListHolder isNil		ifTrue:			[repositoryListHolder :=  SelectionInList new]		ifFalse:			[repositoryListHolder]</body><body package="Store-UI" selector="selectedRepositoryHolder">selectedRepositoryHolder	^self repositoryListHolder selectionHolder</body></methods><methods><class-id>Store.RepositoryManager</class-id> <category>menus</category><body package="Store-UI" selector="menuBar">menuBar	| menu |	menu := self class menuBar.	menu		augmentFrom: self class		to: RepositoryManager		menuName: #menuBar		for: self.	(menu atNameKey: #repositoryToggleConnection) 		rawLabel: [self repositoryToggleConnectionItemLabel].	^menu</body><body package="Store-UI" selector="repositoryListMenu">repositoryListMenu	| menu |	menu := self class repositoryListMenu.	menu 		augmentFrom: self class		to: RepositoryManager		menuName: #listMenu		for: self.	(menu atNameKey: #repositoryToggleConnection) 		rawLabel: [self repositoryToggleConnectionItemLabel].	^menu</body><body package="Store-UI" selector="repositoryToggleConnectionItemLabel">repositoryToggleConnectionItemLabel	^self repositoryListHolder selection		ifNil: [#repmanConnectItem &lt;&lt; #labels &gt;&gt; '&amp;Connect']		ifNotNil: [:profile |			profile isConnected 				ifTrue: [#repmanDisconnectItem &lt;&lt; #labels &gt;&gt; '&amp;Disconnect'] 				ifFalse: [#repmanConnectItem &lt;&lt; #labels &gt;&gt; '&amp;Connect']]</body></methods><methods><class-id>Store.RepositoryManager</class-id> <category>private</category><body package="Store-UI" selector="connectedRepositoryIcon">connectedRepositoryIcon	^connectedIcon ifNil: 		[connectedIcon := ToolbarIconLibrary visualFor: #store]</body><body package="Store-UI" selector="refreshRepositoryView">refreshRepositoryView	(self widgetAt: #repositoryDataset) invalidate</body><body package="Store-UI" selector="setRepositoryList:">setRepositoryList: aList	self repositoryListHolder list: Repositories</body><body package="Store-UI" selector="statusColumnSpec">statusColumnSpec	^ArbitraryViewSpec new		source: #statusColumnVisual:;		flags: 0</body><body package="Store-UI" selector="statusColumnVisual:">statusColumnVisual: isConnected 	^isConnected 		ifTrue: [self connectedRepositoryIcon]		ifFalse: [VisualPart new]</body><body package="Store-UI" selector="updateToolbar">updateToolbar	(self widgetAt: #toolbarMenu) updateMenu</body></methods><methods><class-id>Store.RepositoryManager</class-id> <category>testing</category><body package="Store-UI" selector="isRepositorySelected">isRepositorySelected	^self repositoryListHolder selectionIndex ~= 0</body></methods><methods><class-id>Store.RepositoryManager class</class-id> <category>accessing</category><body package="Store-UI" selector="addRepository:">addRepository: aProfile	Repositories 		add: aProfile;		sortWith: [:a :b | a name &lt; b name]</body><body package="Store-UI" selector="removeRepository:">removeRepository: aProfile	Repositories remove: aProfile</body><body package="Store-UI" selector="repositories">repositories	^Repositories</body><body package="Store-UI" selector="sortRepositoryList">sortRepositoryList	Repositories sortWith: [:a :b | a name &lt; b name]</body><body package="Store-UI" selector="updateRepository:">updateRepository: aProfile	| index |	index := Repositories indexOf: aProfile.	index = 0 ifFalse: [Repositories changed: #at: with: index].	DbRegistry connectedProfileHolder value = aProfile		ifTrue: [DbRegistry connectedProfileHolder changed: #value]</body></methods><methods><class-id>Store.RepositoryManager class</class-id> <category>private</category><body package="Store-UI" selector="loadRepositoriesFromXmlOn:">loadRepositoriesFromXmlOn: aStream	| parser document loadedRepositories |	parser := XMLParser new.	parser validate: false.	document :=parser parse: aStream.	document root tag type = 'store-repositories' ifFalse: 		[self error: 'invalid file format'].	loadedRepositories := document root children collect:		[:each | ConnectionProfile fromXmlElement: each].	self replaceRepositoriesWith: loadedRepositories</body><body package="Store-UI" selector="printRepositoriesAsXmlOn:">printRepositoriesAsXmlOn: aStream	| writer |	aStream nextPutAll: '&lt;?xml version="1.0"?&gt;'; cr.	writer := SAXWriter new output: aStream.	self repositoriesAsXmlDocument saxDo: writer</body><body package="Store-UI" selector="replaceRepositoriesWith:">replaceRepositoriesWith: aCollection	Repositories 		removeAllSuchThat: [:anything | true];		addAll: aCollection;		sortWith: [:a :b | a name &lt; b name]</body><body package="Store-UI" selector="repositoriesAsXmlDocument">repositoriesAsXmlDocument	| document root |	document := Document new.	root := Element tag: 'store-repositories'.	document addNode: root.	Repositories do:		[:each | root addNode: each asXmlNode].	^document</body></methods><methods><class-id>Store.RepositoryManager class</class-id> <category>instance creation</category><body package="Store-UI" selector="new">new	^super new on: self repositories</body><body package="Store-UI" selector="open">open	"Override to use the currently-open manager, if one exists."	^self raiseSingleInstance ifNil: [super open]</body></methods><methods><class-id>Store.RepositoryManager class</class-id> <category>utilities</category><body package="Store-UI" selector="addProfileFromUser">addProfileFromUser	| newProfile |	newProfile := Store.ConnectionProfile new.	newProfile name: 'Repository ', (Repositories size + 1) printString.	^(RepositoryPropertiesDialog openOn: newProfile) 		ifTrue:			[self addRepository: newProfile.			newProfile]		ifFalse:			[nil]</body><body package="Store-UI" selector="loadRepositoriesFromFile">loadRepositoriesFromFile	| filenameString input |	filenameString := Dialog 		requestFileName: 'Open repositories file named:'		default: 'repositories.xml'.	filenameString isEmpty ifTrue: [^self].	input := filenameString asFilename readStream.	[self loadRepositoriesFromXmlOn: input]		ensure: [input close]</body><body package="Store-UI" selector="saveRepositoriesToFile">saveRepositoriesToFile	| filenameString output |	filenameString := Dialog 		requestFileName: 'Save repositories to file named:'		default: 'repositories.xml'.	filenameString isEmpty ifTrue: [^self].	output := filenameString asFilename writeStream.	[self printRepositoriesAsXmlOn: output]		ensure: [output close]</body></methods><methods><class-id>Store.BasicMergePolicy</class-id> <category>testing</category><body package="Store-User Management" selector="isReadyForIntegration:">isReadyForIntegration: aPackageVersion	"Answer true if aPackageVersion is ready for integration."	^aPackageVersion blessingLevelNumber = self blessingForReadyForIntegration</body></methods><methods><class-id>Store.BasicMergePolicy</class-id> <category>accessing</category><body package="Store-User Management" selector="selectVersionsReadyForIntegration:">selectVersionsReadyForIntegration: aCollectionOfVersion	"Given a collection of versions select only integration ready versions."	^aCollectionOfVersion select: [:each| self isReadyForIntegration: each]</body><body package="Store-User Management" selector="shouldPublishAll">shouldPublishAll	^true</body><body package="Store-User Management" selector="versionsReadyForIntegration:">versionsReadyForIntegration: aName	| coll |	coll := Package allVersionsWithName: aName.	^self selectVersionsReadyForIntegration: coll</body></methods><methods><class-id>Store.BasicMergePolicy</class-id> <category>blessings</category><body package="Store-User Management" selector="blessingForIntegrated">blessingForIntegrated	^Policies blessingPolicy integratedBlessing</body><body package="Store-User Management" selector="blessingForMerged">blessingForMerged	^Policies blessingPolicy mergedBlessing</body><body package="Store-User Management" selector="blessingForReadyForIntegration">blessingForReadyForIntegration	^Policies blessingPolicy integrationReadyBlessing</body><body package="Store-User Management" selector="blessingsForReadyForIntegration">blessingsForReadyForIntegration	"Use the array so  this can be extended to use other blessings if desired."		^Array with: ( self blessingForReadyForIntegration )</body></methods><methods><class-id>Store.BasicPublishPolicy</class-id> <category>publishing</category><body package="Store-User Management" selector="basicCanPublish:atBlessing:">basicCanPublish: aPundle atBlessing: aBlessing	^Policies blessingPolicy basicCanPublish: aPundle atBlessing: aBlessing</body><body package="Store-User Management" selector="objectionsToPublishingBundle:atBlessingLevel:">objectionsToPublishingBundle: aBundle atBlessingLevel: aLevel 	"Return a string specifying why this bundle may 	not be published.  Return nil if it may."	^Policies blessingPolicy objectionsToPublishingBundle: aBundle atBlessingLevel: aLevel</body><body package="Store-User Management" selector="objectionsToPublishingPackage:atBlessingLevel:">objectionsToPublishingPackage: aPackage atBlessingLevel: aLevel 	"Return a string specifying why this package may 	not be published.  Return nil if it may."	^Policies blessingPolicy objectionsToPublishingPackage: aPackage atBlessingLevel: aLevel</body><body package="Store-User Management" selector="objectionsToPublishingParcel:atBlessingLevel:">objectionsToPublishingParcel: aParcel  atBlessingLevel: aLevel 	"Return a string specifying why this package may 	not be published.  Return nil if it may."	^Policies blessingPolicy objectionsToPublishingParcel: aParcel  atBlessingLevel: aLevel</body></methods><methods><class-id>Store.BasicPublishPolicy</class-id> <category>accessing</category><body package="Store-User Management" selector="allowBinaryLoading">allowBinaryLoading	allowBinaryLoading == nil		ifTrue: [ allowBinaryLoading := true ].	^allowBinaryLoading</body><body package="Store-User Management" selector="allowBinaryLoading:">allowBinaryLoading: aBoolean	allowBinaryLoading := aBoolean</body></methods><methods><class-id>Store.ElementView</class-id> <category>initialize-release</category><body package="Store-UI-Graphs" selector="inButton">inButton	"creates the button for opening and closing the incoming 	relationships. cyev is self"	| v pa |	pa := PluggableAdaptor on: self.	pa		getBlock: [:cyev | cyev hasIn == true]		putBlock: self inButtonPutBlock		updateBlock: [:m :a :p | false].	v := Lens.LDMArrowView model: pa fullImage: FullInArrow emptyImage: EmptyInArrow.	v controller beToggle.	v label: ''.	^v</body><body package="Store-UI-Graphs" selector="outButton">outButton	"same as inButton but for outgoing relationships"	| v pa |	pa := PluggableAdaptor on: self.	pa		getBlock: [:cyev | cyev hasOut == true]		putBlock: self outButtonPutBlock		updateBlock: [:m :a :p | false].	v := Lens.LDMArrowView model: pa fullImage: FullOutArrow emptyImage: EmptyOutArrow.	v controller beToggle.	v label: ''.	^v</body></methods><methods><class-id>Store.ElementView</class-id> <category>private</category><body package="Store-UI-Graphs" selector="doLayout">doLayout	| pt  |	pt := 0.	self hasIn == 0		ifTrue:			[pt := pt + 9 + 2]		ifFalse: 			[| inBut inLf inWid |			inBut := self inButton.			inWid := inBut preferredBounds width + 2.			inLf := LayoutFrame new.			inLf bottomFraction: 1; topOffset: 1; leftOffset: pt; rightOffset: pt + inWid.			self add: inBut in: inLf.			pt := pt + inWid].	label := self elLabelFor: element at: pt @ 0.	label := self findTopmostWrapperFor: label.	pt := label bounds corner x.	firstPovIconX := pt + 2.	self hasOut == 0		ifFalse: 			[| outBut outLf outWid |			outBut := self outButton.			outWid := outBut preferredBounds width.			outLf := LayoutFrame new.			outLf bottomFraction: 1; topOffset: 1; leftOffset: [self outButtonXPosition]; rightOffset: [self outButtonXPosition + outWid].			self add: outBut in: outLf]</body></methods><methods><class-id>Store.ElementView class</class-id> <category>class initialization</category><body package="Store-UI-Graphs" selector="initialize">initialize	"self initialize"	EmptyInArrow := self emptyInImage.	EmptyOutArrow := self emptyOutImage.	FullInArrow := self fullInImage.	FullOutArrow := self fullOutImage.</body></methods><methods><class-id>Store.DBAccess</class-id> <category>list-text</category><body package="Store-Database" selector="list:includes:">list: list includes: anObject 		list do: [:each | (anObject sameAs: each) ifTrue: [^true]].	^false</body><body package="Store-Database" selector="textForItem:">textForItem: item	^self textForItem: item list: nil</body><body package="Store-Database" selector="textForItem:list:">textForItem: item list: aList 	| nameText |	nameText := item itemString asText.	(aList notNil and: [(self list: aList includes: item) not])		ifTrue: [nameText allBold].	^nameText</body></methods><methods><class-id>Store.DBAccess</class-id> <category>accessing</category><body package="Store-Database" selector="connectedProfile">connectedProfile	^connectedProfileHolder value</body><body package="Store-Database" selector="connectedProfileHolder">connectedProfileHolder	"A ValueHolder which always contains a ConnectionProfile for the	currently connected repository, or nil if there is no connection."	^connectedProfileHolder</body><body package="Store-Database" selector="connectionClass">connectionClass	^connection notNil 		ifTrue: [ connection class]		ifFalse: 	[ExternalDatabaseConnection].</body><body package="Store-Database" selector="currentUserName">currentUserName	^self userName</body><body package="Store-Database" selector="databaseIdentifier">databaseIdentifier	( ( databaseIdentifier isNil &amp; ( self isOnline ) ) &amp; ( storeBroker ~~ nil ) ) 		ifTrue: [ databaseIdentifier := DatabaseIdentifier databaseIdentifier].	^ databaseIdentifier</body><body package="Store-Database" selector="databaseIdentifier:">databaseIdentifier: aString	databaseIdentifier := aString.</body><body package="Store-Database" selector="dbIdentifier">dbIdentifier	| id |	^( id := self databaseIdentifier ) == nil		ifFalse: [ id asSymbol ]</body><body package="Store-Database" selector="dbObject">dbObject	^#{DBObject} valueOrDo: 		[ self error: 'Attempt to access unloaded database code' ]</body><body package="Store-Database" selector="debugger">debugger	^debugger isNil		ifTrue: [ debugger := StoreLogEnvironment new ]		ifFalse: [ debugger ]</body><body package="Store-Database" selector="doIfImageAdministrator:label:">doIfImageAdministrator: aBlock label: aString	"Evaluate aBlock if we are online and the current user has admistration rights.	Otherwise display an error message"	self doIfOnlineImage:		[ self isSystemAdministrator			ifTrue: [ aBlock value ]			ifFalse: [ Dialog warn: 'Only the image administrator can ', aString, '.' ]		]</body><body package="Store-Database" selector="doIfOnlineImage:">doIfOnlineImage: aBlock 	| choice |	self isOnlineImage ifTrue: [^aBlock value].	choice := Dialog confirm: 'The image is disconnected from the Database.&lt;n&gt;Would you like to reconnect?' expandMacros.	choice ifFalse: [^self].	self restoreConnection.	self isOnlineImage ifFalse: [^self].	^aBlock value</body><body package="Store-Database" selector="isOnline:">isOnline: aValue 	isOnline := aValue</body><body package="Store-Database" selector="isSystemAdministrator">isSystemAdministrator	^[ ^self isOnline		ifFalse: [ false ]		ifTrue: 			[ DBUserGroup dbHasAdmin not or: 				[ DBUserGroup isInAdmin: self currentUserName ].			]	]	on: self errorSignals	do: [ :ex | Transcript cr; show: ex description.		ex return: false	]</body><body package="Store-Database" selector="resetConnection">resetConnection	connection := nil.	connectedProfileHolder value: nil</body><body package="Store-Database" selector="storeBroker">storeBroker	storeBroker isNil 		ifTrue: 			[ Dialog warn: 'Broker: Disconnected from DB'. 			^StoreError raiseSignal].	^ storeBroker</body><body package="Store-Database" selector="storeBroker:">storeBroker: aBroker	storeBroker := aBroker</body><body package="Store-Database" selector="tableOwner">tableOwner	^ self tablePrefix</body><body package="Store-Database" selector="tablePrefix">tablePrefix	tablePrefix isNil ifTrue: [tablePrefix := self defaultTablePrefix].	^tablePrefix</body><body package="Store-Database" selector="tablePrefix:">tablePrefix: aString	tablePrefix := aString</body></methods><methods><class-id>Store.DBAccess</class-id> <category>initialize-release</category><body package="Store-Database" selector="cloneFrom:">cloneFrom: x	connectedProfileHolder := x connectedProfileHolder.	self isOnline: x isOnline.	(x tablePrefix last == $.) 		ifTrue: [ self tablePrefix: ( x tablePrefix copyUpTo: $.)]		ifFalse: [ self tablePrefix: x  tablePrefix].	self tablePrefix: x tablePrefix.	self storeBroker: x storeBroker.</body><body package="Store-Database" selector="initialize">initialize	connectedProfileHolder := nil asValue</body></methods><methods><class-id>Store.DBAccess</class-id> <category>actions</category><body package="Store-Database" selector="createInstallScript">createInstallScript	installScript := true.	self selectBroker.	self openLogTool.	[self installDatabaseTables	] ensure: 		[ installScript := nil.		self debugger traceOff. ].</body><body package="Store-Database" selector="createInstallScriptFor:">createInstallScriptFor: aBlock	installScript := true.	self selectBroker.	self openLogTool.	[ aBlock value ] 		ensure: 			[ installScript := nil.			self debugger traceOff. 			].</body><body package="Store-Database" selector="createTableSpaces">createTableSpaces	"Create the physical table spaces used by Store."	^ DBObject createPhysicalSpaces.</body><body package="Store-Database" selector="deinstallDatabaseTables">deinstallDatabaseTables	[		self reconnect: false.		Package deinstallPkgs.		Privileges dropTables.		( Dialog confirm: 'Do you want to drop tablespaces/databases ?' )			ifTrue: [  DBObject dropDatabases ].		self goOffLine.	] 	on: Error	do: [ :ex | self goOffLine. ex return].</body><body package="Store-Database" selector="goToScript">goToScript	^installScript notNil</body><body package="Store-Database" selector="installDatabaseTables">installDatabaseTables	self reconnect: false.	DBObject installPhysicalSpaces isNil		ifTrue: 			[self goOffLine.			^false].	Package installPkgs.	self goToScript ifFalse: [DatabaseIdentifier installInDatabase].	Privileges installUserManagementTables.	self goToScript ifFalse: [(Dialog confirm: 'Install management policies?')			ifTrue: [Privileges installUserManagement]			ifFalse: 				[Dialog warn: 'To add user management later execute: ''Privileges installUserManagement'''.				self printDebug: 'You did not created user management tables. To add user management later execute: ''Privileges installUserManagement''']].	"Disconnect to ensure a commit point is reached."	self goOffLine.</body><body package="Store-Database" selector="installManagementInfo">installManagementInfo	"Make sure we disconnect any connection we make here."	| onlineState |	onlineState := self isOnline.	onlineState ifFalse: [ self reconnect: false ].	DatabaseIdentifier installInDatabase.	Privileges installUserManagement.	onlineState ifFalse: [ self goOffLine ].</body><body package="Store-Database" selector="openLogTool">openLogTool	self debugger reset.	self debugger addToDebug: SQLBroker.	self debugger addDebugCategory: #SQLBroker.	self debugger traceOn.	StoreLoggingTool  clear.	self debugger dependents isEmpty		ifTrue: [ StoreLoggingTool openWith: self debugger ]</body><body package="Store-Database" selector="selectBroker">selectBroker	| brs dbs |	brs := SQLBroker allSubclasses.	(dbs := SQLBroker allSubclasses collect: [ :br | br databaseName ]) size &gt; 1 		ifTrue: 			[	brs := Dialog 						choose: 'What database to use?' 						fromList: dbs						values: brs						lines: 8 						cancel: [#noChoice].					brs = #noChoice ifTrue: [ ^nil ].					self storeBroker: brs ]		ifFalse: [ self storeBroker: brs first ]</body><body package="Store-Database" selector="update5i2">update5i2	Store.DatabaseIdentifier createDatabaseTable.     ( Store.UISettings preferenceModelFor: #databaseIdentifier ) value: self databaseIdentifier.	Store.Package update5i2.</body><body package="Store-Database" selector="update5i3">update5i3	"Fix for databases created with 5i.2. Alter STORAGE PSTINCREASE from 0 to 1"	Package alterTablesPctincrease.	Privileges alterTablesPctincrease</body><body package="Store-Database" selector="update7">update7	"Adds sourceViews."	DBObject broker 		createSourcesViewForClass: MethodsAndSourcesView;		createSourcesViewForClass: DataAndSourcesView;		createSourcesViewForClass: PkgClassesAndSourcesView;		createSourcesViewForClass: PkgNameSpacesAndSourcesView.</body><body package="Store-Database" selector="update73">update73	"Adds tables and views for properties, files and column for SmalltalkDoc."	"merges in update7 for those who didn't upgrade last time."	Store.Properties createDatabaseTable.	Store.PropertyRecord createDatabaseTable.	Store.PropertiesView createViewForClass: Store.PropertiesView.	FileRecord createDatabaseTable.	Files createDatabaseTable.	MethodsView tableExists ifTrue: 		[self storeBroker dropViewForClass: MethodsView].	MethodsAndSourcesView tableExists ifTrue: 		[self storeBroker dropViewForClass: MethodsAndSourcesView].	self storeBroker		createSourcesViewForClass: MethodsView;		createSourcesViewForClass: MethodsAndSourcesView.	PkgClassesAndSourcesView tableExists		ifFalse: 			[ self storeBroker  				createSourcesViewForClass: DataAndSourcesView;				createSourcesViewForClass: PkgClassesAndSourcesView;				createSourcesViewForClass: PkgNameSpacesAndSourcesView.			].</body></methods><methods><class-id>Store.DBAccess</class-id> <category>defaults</category><body package="Store-Database" selector="defaultEnvironmentString">defaultEnvironmentString	^''</body><body package="Store-Database" selector="defaultTablePrefix">defaultTablePrefix	^'BERN'</body></methods><methods><class-id>Store.DBAccess</class-id> <category>debug</category><body package="Store-Database" selector="debug">debug		^ debug == nil		ifTrue: [ debug := false]		ifFalse: [ debug].</body><body package="Store-Database" selector="debug:">debug: aBoolean		debug := aBoolean</body><body package="Store-Database" selector="debugOff">debugOff		self debug: false.</body><body package="Store-Database" selector="debugOn">debugOn		self debug: true.</body><body package="Store-Database" selector="log">log		^ log == nil		ifTrue: [ log := false]		ifFalse: [ log ].</body><body package="Store-Database" selector="log:">log: aBoolean		log := aBoolean</body><body package="Store-Database" selector="logFile">logFile	^ logFile isNil 		ifTrue: [ logFile := (Filename named: 'StoreLog.txt') readAppendStream]		ifFalse: [ logFile]</body><body package="Store-Database" selector="logOff">logOff		self log: false.</body><body package="Store-Database" selector="logOn">logOn		self log: true.</body><body package="Store-Database" selector="printDebug:">printDebug: anObj	self debug		ifTrue: [ Transcript cr; show: (self printString: anObj)].	self printLog: anObj.</body><body package="Store-Database" selector="printLog:">printLog: anObj	self log		ifTrue: 			[				self logFile nextPutAll: (self printString: anObj); cr.				self logFile flush.				self logFile close.			]</body><body package="Store-Database" selector="printString:">printString: anObj	| stream |	stream := ( String new: 50) writeStream.		anObj printOn: stream.	^ stream contents.</body></methods><methods><class-id>Store.DBAccess</class-id> <category>utilities</category><body package="Store-Database" selector="checkForUpdates">checkForUpdates	"For rel7 - check for sources view."	| msg |	msg := '&lt;t&gt; You need to update your database.&lt;n&gt;Please, ask your DBA to evaluate the expression:&lt;ntt&gt;Store.DbRegistry &lt;1s&gt;'.	DbRegistry isImage73Enabled		ifTrue: 			[ DbRegistry isDb73Enabled				ifFalse:  [ Dialog warn: ( msg expandMacrosWith: 'update73' ) ]			].</body><body package="Store-Database" selector="duplicateMethodReport">duplicateMethodReport	"Search the most recent version of all packages. Answer a stream- empty if no duplicates ."	"Transcript show: DbRegistry duplicateMethodReport"	| packages count report |	count := Store.Package allNames size.	packages := Store.Package allNames.	report := ( String new: 1000 ) writeStream.	Notice  		showProgress: 'Finding Duplicate methods' 		complete: count 		while: 			[ packages do:				[ :name | 				IncrementNotification raiseSignal.				( Store.Package newestVersionWithName: name ) duplicateMethodReportOn: report				]			]		title: 'Store'.	^report contents.</body><body package="Store-Database" selector="duplicateStaticReport">duplicateStaticReport	"Search the most recent version of all packages. Answer a stream- empty if no duplicates ."	"Transcript show: DbRegistry duplicateStaticReport"	| packages count report |	count := Store.Package allNames size.	packages := Store.Package allNames.	report := ( String new: 1000 ) writeStream.	Notice  		showProgress: 'Finding Duplicate Shared Variables' 		complete: count 		while: 			[ packages do:				[ :name | |  |				IncrementNotification raiseSignal.				( Store.Package newestVersionWithName: name ) duplicateStaticReportOn: report					]			]		title: 'Store'.	^report contents.</body></methods><methods><class-id>Store.DBAccess</class-id> <category>private-utilities</category><body package="Store-Database" selector="connectedImageMessage">connectedImageMessage	^'Since this image cannot be used without the database connection if you choose "Cancel" you will not be able to see sources.'</body><body package="Store-Database" selector="detachedImageMessage">detachedImageMessage	^'Since this image can be used without the database connection you can choose "Detach" if you do not wish to be connected to the database at this moment.'</body><body package="Store-Database" selector="userName">userName	^connection == nil		ifTrue: [ String new ]		ifFalse: [ connection username ].</body></methods><methods><class-id>Store.DBAccess</class-id> <category>signal constants</category><body package="Store-Database" selector="currentlyNotConnectedSignal">currentlyNotConnectedSignal	^LostConnectionNotification</body><body package="Store-Database" selector="errorSignals">errorSignals	^self currentlyNotConnectedSignal</body><body package="Store-Database" selector="notConnectedSignal">notConnectedSignal	^StoreNotConnectedError</body></methods><methods><class-id>Store.DBAccess</class-id> <category>connecting</category><body package="Store-Database" selector="connectTo:">connectTo: aProfile	| result |	aProfile isConnectable ifFalse: 		[Dialog warn: ('Unable to connect to "&lt;1s&gt;" because the database driver class&lt;n&gt;"&lt;2s&gt;" is not present in the image.'			expandMacrosWith: aProfile displayString			with: aProfile driverClassName).		^self].	self isConnected ifTrue: [self disconnect].	connection := aProfile asConnection.	result := [connection connect: aProfile password]			on: Error			do: [:ex |				Dialog warn: ('Unable to connect to "&lt;1s&gt;" because of the following error:&lt;n&gt;&lt;2s&gt;' 									expandMacrosWith: aProfile displayString 									with: (ex messageText isEmpty ifTrue: [ex defaultMessageText] ifFalse: [ex messageText])).				ex return: nil].	result isNil ifTrue: [^self].	self 	 	isOnline: true;		storeBroker: connection storeBroker;		updateTablePrefix: aProfile tableOwner;		updateDatabaseIdentifier: true;		checkForUpdates.	self connectedProfileHolder value: aProfile.	recentProfile := aProfile</body><body package="Store-Database" selector="disconnect">disconnect	self isOnline: false.	self closeConnection.	self connectedProfileHolder value: nil</body><body package="Store-Database" selector="restoreConnection">restoreConnection	self isConnected ifTrue: [^self].	self closeConnectionIfNewOrPaused.	connection isNil 		ifTrue: 			[| profile |			profile := Store.ConnectionDialog chooseProfileInitially: recentProfile.			[profile isNil ifTrue: [self disconnect] ifFalse: [self connectTo: profile]] 				ifCurtailed: [self disconnect]].	^self isConnected</body></methods><methods><class-id>Store.DBAccess</class-id> <category>private-accessing</category><body package="Store-Database" selector="isThereAnyTableInstalled">isThereAnyTableInstalled" This method is used only to prevent the database identifier request if there is no tables installed"	^[self storeBroker processSQL: 		((self storeBroker newSQLFor: Package)			selectAll;			where;			column: #primaryKey equalTo: '1').	true	] 	on: Error do: [ :ex | false ]</body><body package="Store-Database" selector="nilOutConnection">nilOutConnection	"self nilOutConnection"	"This method is sent when we cannot close connection, 	and we can do is to nuke them."	self resetSessions.	connection notNil 		ifTrue:			[connection nilParams.			connection := nil].</body><body package="Store-Database" selector="resetDatabaseIdentifier">resetDatabaseIdentifier	self databaseIdentifier: nil.     [( Store.UISettings preferenceModelFor: #databaseIdentifier ) value: nil.]	on: Error	do: [ :ex | ].</body><body package="Store-Database" selector="resetSequenceGeneratorSessions">resetSequenceGeneratorSessions	"Reset all the session used to generate the primary keys."	DBObject withAllSubclasses do: [:x | x resetSequenceGeneratorSession]</body><body package="Store-Database" selector="resetSessions">resetSessions	DBObject resetSession.	Package resetSessions.	Record resetPrimaryKeySessions.	self resetSequenceGeneratorSessions.</body><body package="Store-Database" selector="updateDatabaseIdentifier">updateDatabaseIdentifier	self updateDatabaseIdentifier: true</body><body package="Store-Database" selector="updateDatabaseIdentifier:">updateDatabaseIdentifier: repositoryShouldHaveIdentifier 	"Update the database identifier from information held in the repository. 	If repositoryShouldHaveIdentifier is false, just ignore (swallow) certain exceptions."	| id |	[ id := DatabaseIdentifier getDatabaseIdentifier.	self databaseIdentifier: id.	[ ( Store.UISettings preferenceModelFor: #databaseIdentifier ) value: id ] on: Error do: [ :ex | ] 	] on: Error do: 		[ :exception | 		repositoryShouldHaveIdentifier 			ifTrue: 				[ self isThereAnyTableInstalled					ifTrue: 						[ DatabaseIdentifier tableExists 							ifFalse: [ DatabaseIdentifier installInDatabase ]							ifTrue:								[ Dialog warn: '&lt;tt&gt;You need to update your database.&lt;n&gt;Please, ask DBA to evaluate (Do It) the expression:&lt;nt&gt;"Store.DbRegistry update5i2".&lt;n&gt;&lt;tt&gt; or if you just install database using installation script &lt;n&gt; run PostInstall from Log Window' expandMacros								]						]					ifFalse: [ exception pass ]				]		]</body><body package="Store-Database" selector="updateTablePrefix:">updateTablePrefix: aString	self tablePrefix: aString.     ( Store.UISettings preferenceModelFor: #tablePrefix ) value: aString</body></methods><methods><class-id>Store.DBAccess</class-id> <category>privileged-connecting</category><body package="Store-Database" selector="closeConnection">closeConnection	"Close and forget the datebase connection if it exists."	"DbRegistry closeConnection"	connection notNil ifTrue: 		[self resetSessions.		[connection disconnect] 			on: Error			do: 				[:ex | 				Transcript cr; show: ex description.				ex return].		connection := nil]</body><body package="Store-Database" selector="closeConnectionIfNewOrPaused">closeConnectionIfNewOrPaused	connection notNil 		ifTrue: 			[(connection state == #paused or: [connection state == #new]) 				ifTrue: [self closeConnection]]</body><body package="Store-Database" selector="connection">connection	"Connection disconnect. Connection := nil. Session := nil"	self closeConnectionIfNewOrPaused.	connection isNil ifTrue: [self restoreConnection].	^connection</body><body package="Store-Database" selector="connection:">connection: aDbConnection		connection := aDbConnection.</body><body package="Store-Database" selector="connectionOrNil">connectionOrNil	self closeConnectionIfNewOrPaused.	connection == nil ifTrue: [self goOffLine].	^connection</body><body package="Store-Database" selector="goOffLine">goOffLine	"This message is used when we want to go off line."	"self goOffLine"	self isOnline: false.	self closeConnection.	self connectedProfileHolder value: nil</body><body package="Store-Database" selector="goOnLine">goOnLine	"This message is used when we want to go back on line."	"self goOnLine"	self isOnline: true.	[ self connection ]		ensure: 	[ self isOnline: ( self  isConnectionAlive ) ]</body><body package="Store-Database" selector="reconnect">reconnect	^self restoreConnection</body><body package="Store-Database" selector="reconnect:">reconnect: storeTablesShouldExist	"Reconnect to the database after returning from a snapshot."	self goToScript ifTrue: [^nil].	self  setConnection. 	connection notNil 		ifTrue: 			[ self isOnline: true.			self updateDatabaseIdentifier: storeTablesShouldExist.			storeTablesShouldExist ifTrue: [ self checkForUpdates ].			]		ifFalse: [ self isOnline: false].	^ self isOnline</body><body package="Store-Database" selector="setConnection">setConnection	self resetSessions.	connection := ConnectionDialog connection.	self storeBroker: 		( connection == nil			ifTrue: [ nil ]			ifFalse: [ connection storeBroker ]		).</body></methods><methods><class-id>Store.DBAccess</class-id> <category>testing</category><body package="Store-Database" selector="is73Enabled">is73Enabled	^( DbRegistry isDb73Enabled ) &amp; ( DbRegistry isImage73Enabled )</body><body package="Store-Database" selector="isConnected">isConnected	^connectedProfileHolder value notNil</body><body package="Store-Database" selector="isConnectionAlive">isConnectionAlive	"Checks if at this moment we are connected to the database."	"self isConnectionAlive"	^connection notNil</body><body package="Store-Database" selector="isDb73Enabled">isDb73Enabled	^#{Store.Properties} 		ifDefinedDo: [ :cls | cls tableExists.]		elseDo: [ false ]</body><body package="Store-Database" selector="isImage73Enabled">isImage73Enabled	^#{Store.FileRecord} isDefined.</body><body package="Store-Database" selector="isOnline">isOnline	isOnline isNil ifTrue: [isOnline := false].	^isOnline</body><body package="Store-Database" selector="isOnlineImage">isOnlineImage		"Answer true if we are attached to the database."	^self isOnline</body></methods><methods><class-id>Store.DBAccess class</class-id> <category>class initialization</category><body package="Store-Database" selector="initialize">initialize	"Need only be executed on first installation or on change in definition."	"self initialize"	DbRegistry := DbRegistry == nil		ifTrue: [ self new ]		ifFalse: [ self new cloneFrom: DbRegistry ].	"Make myself dependent on ObjectMemory so I'm	notified when the image returns from snapshot."	( ExternalDatabaseConnection dependents includes: self )		ifFalse:	[ ExternalDatabaseConnection addDependent: self ]</body><body package="Store-Database" selector="obsolete">obsolete	"Remove dependancies"	ExternalDatabaseConnection removeDependent: self.	super obsolete.</body></methods><methods><class-id>Store.DBAccess class</class-id> <category>private</category><body package="Store-Database" selector="update:with:from:">update: anAspect with: arguments from: anObject 	"Check for return from snapshot to install."	anAspect == #returnFromSnapshot 		ifTrue: 			[DbRegistry resetSessions.			DbRegistry isOnline				ifTrue: [DbRegistry resetConnection. DbRegistry restoreConnection]		].</body></methods><methods><class-id>Store.DBAccess class</class-id> <category>instance creation</category><body package="Store-Database" selector="new">new	^super new initialize</body></methods><methods><class-id>Store.AbstractWindowTool</class-id> <category>initialize-release</category><body package="Store-UI" selector="menuBar:popupMenu:windowTitle:">menuBar: aMenuBar popupMenu: aPopupMenu windowTitle: aTitle	"Set all of the initial condition."	menuBar := aMenuBar.	menuBar menuItems do: [:item | self makePundleMenuDynamic: item submenu].	popupMenu := aPopupMenu.	self makePundleMenuDynamic: popupMenu.	windowTitle := aTitle.</body></methods><methods><class-id>Store.AbstractWindowTool</class-id> <category>interface opening</category><body package="Store-UI" selector="postOpenWith:">postOpenWith: aBuilder 	super postOpenWith: aBuilder.	windowTitle notNil ifTrue: [aBuilder window label: windowTitle].</body></methods><methods><class-id>Store.AbstractWindowTool</class-id> <category>menus</category><body package="Store-UI" selector="menuBar">menuBar	^menuBar</body><body package="Store-UI" selector="popupMenu">popupMenu	^popupMenu</body></methods><methods><class-id>Store.AbstractWindowTool</class-id> <category>actions</category><body package="Store-UI" selector="reloadVersions">reloadVersions	^self subclassResponsibility</body></methods><methods><class-id>Store.AbstractWindowTool class</class-id> <category>interface opening</category><body package="Store-UI" selector="openOnAllLoadedPundles">openOnAllLoadedPundles	self		openOnBlock: [Registry allPundlesSorted asList]		sendUpdatesFor: #(#removedPundle #addedPundle #renamedPundle #pundleModificationStatus #pundleTrace)		menu: self loadedMenuBarSkeleton		popup: self loadedPopupSkeleton		windowTitle: 'Loaded Items'</body><body package="Store-UI" selector="openOnAllPublishedPundles">openOnAllPublishedPundles	| updateBlock |	updateBlock := 			[| list |			list := List new.			list addAll: (Bundle allNames asSortedCollection asOrderedCollection collect: [:bname | Bundle new name: bname]).			list addAll: (Package allNames asSortedCollection asOrderedCollection collect: [:pname | Package new name: pname]).			list].	self		openOnBlock: updateBlock		sendUpdatesFor: #()		menu: self publishedMenuBarSkeleton		popup: self publishedPopupSkeleton		windowTitle: 'Published Items'</body><body package="Store-UI" selector="openOnBlock:sendUpdatesFor:menu:popup:windowTitle:">openOnBlock: aBlock sendUpdatesFor: aSymbolCollection menu: aMenuBar popup: aPopupMenu windowTitle: aTitle 	self openOn: (self new			listUpdateBlock: aBlock			sendUpdatesFor: aSymbolCollection			menuBar: aMenuBar			popupMenu: aPopupMenu			windowTitle: aTitle)</body><body package="Store-UI" selector="openOnLoadedBlock:sendUpdatesFor:windowTitle:">openOnLoadedBlock: aBlock sendUpdatesFor: aSymbolCollection windowTitle: aTitle 	self		openOnBlock: aBlock		sendUpdatesFor: aSymbolCollection		menu: self loadedContentsMenuBarSkeleton		popup: self loadedPopupSkeleton		windowTitle: aTitle</body><body package="Store-UI" selector="openOnPublishedBlock:sendUpdatesFor:windowTitle:">openOnPublishedBlock: aBlock sendUpdatesFor: aSymbolCollection windowTitle: aTitle 	self		openOnBlock: aBlock		sendUpdatesFor: aSymbolCollection		menu: self publishedContentsMenuBarSkeleton		popup: self publishedContentsPopupSkeleton		windowTitle: aTitle</body></methods><methods><class-id>Store.UnloadableDefinitionError</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="definitionRecord">definitionRecord	^parameter</body><body package="Store-DB-BaseObjects" selector="definitionRecord:">definitionRecord: aDbRecord	parameter := aDbRecord</body><body package="Store-DB-BaseObjects" selector="package">package 	^package</body><body package="Store-DB-BaseObjects" selector="package:">package: aPackage	package := aPackage</body></methods><methods><class-id>Store.UnloadableDefinitionError</class-id> <category>private - actions</category><body package="Store-DB-BaseObjects" selector="defaultAction">defaultAction	"What to do when the exception is unhandled."	Dialog warn:		( self definitionRecord isForMethod			ifTrue: [  ( #DefIsNotLoadable &lt;&lt; #store &gt;&gt; '&lt;1s&gt; is not loadable.' ) expandMacrosWith: self definitionRecord printString ]			ifFalse: [ ( #DefIsNotLoadable &lt;&lt; #store &gt;&gt;  '&lt;1s&gt; is not loadable. ' ) expandMacrosWith: self definitionRecord name ]		)</body></methods><methods><class-id>Store.UnloadableDefinitionError</class-id> <category>actions</category><body package="Store-DB-BaseObjects" selector="fileoutOutOn:">fileoutOutOn: aSourceCodeStream	self definitionRecord fileOutOn: aSourceCodeStream.</body><body package="Store-DB-BaseObjects" selector="loadRecord">loadRecord	self definitionRecord loadSrcIntoPackage: package confirm: false.</body><body package="Store-DB-BaseObjects" selector="removeRecord">removeRecord	"Mark this record as removed - so it shows up in the package's changeset."	package == nil		ifFalse: [ self definitionRecord removeFromPackage: package ]</body></methods><methods><class-id>Store.UnloadableDefinitionError</class-id> <category>printing</category><body package="Store-DB-BaseObjects" selector="displayString">displayString	^self definitionRecord fullDisplayString</body><body package="Store-DB-BaseObjects" selector="printOn:">printOn: aStream	aStream nextPutAll: 'Unloadable Error: '.	self definitionRecord printOn: aStream.</body></methods><methods><class-id>Store.UnloadableDefinitionError class</class-id> <category>testing</category><body package="Store-DB-BaseObjects" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Store.PackageBrowserHelper</class-id> <category>accessing</category><body package="Store-UI-Browser" selector="allSelectedDatabases">allSelectedDatabases	"Answer all the ids for all the currently selected pacakges."	"Sorts the current db to the top"	| ids current |	ids := ( PundleModel databaseListFor: self selections ) asOrderedCollection.	ids size &gt; 1		ifTrue:			[ current := DbRegistry dbIdentifier.			( ids contains: [ :id | id == current ] )				ifTrue: [ 	ids addFirst: ( ids remove: current ) ].			].	^ids.</body><body package="Store-UI-Browser" selector="list">list	| list |	list := self module list.	^list class  == IndentedTreeSelectionInList		ifTrue: [ list cachedObjects collect: [ :a | a key ] ] 		ifFalse: [ list list collect: [ :item | item value ] ]</body><body package="Store-UI-Browser" selector="pkgDef">pkgDef	^self browser pkgDef value</body><body package="Store-UI-Browser" selector="windowLabel">windowLabel		| label |	label := 'Package Browser'.	^self  package == nil		ifTrue: [ label ]		ifFalse: [ label, ' on ', self package itemString ].</body></methods><methods><class-id>Store.PackageBrowserHelper</class-id> <category>menus accessing</category><body package="Store-UI-Browser" selector="actionsForMultiSelect">actionsForMultiSelect	^#( #newPackage #updateList #storePackageInDB #spawn		#fileOutPackages  #fileOutChanges #deletePackage #mergePundleVersion )</body><body package="Store-UI-Browser" selector="actionsForNoSelect">actionsForNoSelect	^#( #newPackage #newBundle #updateList #find #findPackage )</body><body package="Store-UI-Browser" selector="actionsForUnloadedPackages">actionsForUnloadedPackages	"Answer an array of menu selectors that are appropiate for unloaded packages."	^#( #fileOut #fileOutPackages #fileOutDifferences #browseVersions 		#graphVersions 	#enclosingComponents #diffPackageWithParent  		#diffWithVersion #packageProperties #spawn #loadPundle )</body><body package="Store-UI-Browser" selector="addDatabaseSelectionSubmenuTo:">addDatabaseSelectionSubmenuTo: aMenuItem	"Answer a submenu that allows the choice of a db"	| dbs submenu |	( dbs :=  self allDatabasesFor: self selections ) size &gt; 1		ifFalse: [ ^self ].		"don't bother adding menu if only one choice"	submenu := Menu new.	dbs do:		[ :db | 		submenu addItem: 			( MenuItem labeled: ( db contractTo: MaxMenuEntryWidth ) ) value: db		].	^submenu</body><body package="Store-UI-Browser" selector="buildViewMenu:">buildViewMenu: aMenu	| menu |	menu := self class defTypeMenu.	menu menuItems do: 		[ :i |		i indication: ( self browser pkgDef value = i value )		].	aMenu addPart: menu</body><body package="Store-UI-Browser" selector="getListMenu:">getListMenu: forMenuBar	| menu dbids submenu smenu |	menu := forMenuBar			ifTrue: [self  getStoreMenuBarMenu]			ifFalse: [self getListMenu].	menu == nil ifTrue: [menu := Menu new].	self setEnablement: menu.	dbids := self allSelectedDatabases.	( smenu := menu atNameKey: #browse ) == nil		ifFalse:			[ submenu := smenu submenu.			self storeEnhance: submenu submenu: #browseChanges items: dbids sending: #browseChanges:.			self storeEnhance: submenu submenu: #inspectChanges items: dbids sending: #inspectChanges:.			self storeEnhance: submenu submenu: #changeListOnChanges items: dbids sending: #changeListOnChanges:.			].	( smenu := menu atNameKey: #fileOut ) == nil		ifFalse: [ self storeEnhance: smenu submenu submenu: #fileOutChanges items: dbids sending: #fileOutChanges: ].	^menu</body><body package="Store-UI-Browser" selector="menuHeader">menuHeader	^selectionId isInteger		ifTrue: [ self class menuHeader, selectionId printString ]		ifFalse: [ self class menuHeader ]</body><body package="Store-UI-Browser" selector="setEnablement:">setEnablement: menu	"Set the menu's items enabled/disabled state."	"Since loaded and unloaded not in the same browser we only have to disable things."	"Don't override a menu item's particular enablement"	menu enablementSelector == nil		ifFalse: [ ^menu ].	super setEnablement: menu.	self  selection == nil		ifTrue: [ ^menu ].	( self package == nil or: [ self package isLoaded ] ) 		ifTrue: [ ^menu ].	self menu: menu do: 		[ :item | 		( self actionsForUnloadedPackages includes: item nameKey )			ifFalse: [ item disable ]		].</body><body package="Store-UI-Browser" selector="storeEnhance:submenu:items:sending:">storeEnhance: menu submenu: nameKey items: subitems sending: msg	"Adds a submenu for selecting databases"	| item submenu |	( item := menu atNameKey: nameKey ) == nil		ifTrue: [ ^self ].	subitems isEmpty		ifTrue: 			[ item enabled: false; value: nil; submenu: nil.			^nil			].	item value: 		[ :cont | cont performer module: self menuHeader	action: msg	with: subitems first ].	subitems size &gt; 1		ifFalse: [ item submenu: nil. ^nil ].	submenu := Menu new.	subitems do:		[ :db | | subitem |		submenu addItem: 			( subitem := MenuItem labeled: ( db contractTo: MaxMenuEntryWidth ) ) value: db.			subitem value: 				[ :cont | cont performer module: self menuHeader	action: msg	with: db ].		].	item submenu: submenu.	^submenu</body></methods><methods><class-id>Store.PackageBrowserHelper</class-id> <category>list accessing</category><body package="Store-UI-Browser" selector="howManySelections">howManySelections	| cnt |	^( cnt := super howManySelections ) == 0		ifFalse: [ cnt ]		ifTrue: 			[ module forcedValue == nil				ifTrue: [ 0 ]				ifFalse: [ 1 ].			].</body><body package="Store-UI-Browser" selector="intializeListFull">intializeListFull	self module setNewListSilently: self browser allPackages.</body><body package="Store-UI-Browser" selector="selection">selection	| sel |	^( sel := super selection ) == nil		ifTrue: [ module forcedValue ]		ifFalse: [ sel ].</body><body package="Store-UI-Browser" selector="selectionChanged">selectionChanged	self nextModule == nil ifTrue: [ ^super selectionChanged ].	self browser batchUpdates:		[ self  setSelection.		self nextModule updateList		]</body><body package="Store-UI-Browser" selector="selections">selections	| sels val |	^( sels := super selections ) isEmpty		ifTrue: 			[ ( val := module forcedValue ) == nil				ifTrue: [ sels ]				ifFalse: [ OrderedCollection with: val ]			 ]		ifFalse: [ sels ].</body><body package="Store-UI-Browser" selector="updateListFull">updateListFull	self setNewList: self browser allPackages.</body></methods><methods><class-id>Store.PackageBrowserHelper</class-id> <category>selections</category><body package="Store-UI-Browser" selector="defaultAttribute">defaultAttribute	"Answer the default attribute that this helper is responsible for selecting."	^#package</body><body package="Store-UI-Browser" selector="package">package	^self selection</body><body package="Store-UI-Browser" selector="packages">packages	^self selections</body></methods><methods><class-id>Store.PackageBrowserHelper</class-id> <category>actions</category><body package="Store-UI-Browser" selector="browseChanges">browseChanges	"Spawn method changes list on package(s)."	self browseChanges: DbRegistry dbIdentifier</body><body package="Store-UI-Browser" selector="browseChanges:">browseChanges: dbid	"Spawn method changes list on package(s)."	self browseChanges: self packages in: dbid</body><body package="Store-UI-Browser" selector="browseChanges:in:">browseChanges: packages in: dbIdentifier	"Spawn method changes list on package(s)."	| meths name label |	meths := Array new.	name := ''.	packages do: 		[ :package | 		package leafItems do: 			[ :pkg | meths := meths , ( pkg changedMessageListFor: dbIdentifier ) ].			name := name , ' ' , package name			].	meths isEmpty		ifTrue: [ Dialog warn: 'No added or changed methods in', name ] 		ifFalse: 			[ meths := ( meths asSortedCollection:  						[ :a :b | a ownerName = b ownerName									ifTrue: [ a selector &lt; b selector ]									ifFalse: [ a ownerName &lt; b ownerName ]						] ) asOrderedCollection.			label := 'changed methods in: &lt;1s&gt; db: &lt;2s&gt;' expandMacrosWith: name with: dbIdentifier.			meths size == 1				ifTrue: [ label := label, '  ', meths first ownerName ].			self spawningBrowserClass				openOnPackage: self package methods: meths				label: label			].</body><body package="Store-UI-Browser" selector="browseOverridden">browseOverridden	| overs |	self selection isBundle		ifTrue:			[ overs := OrderedCollection new.			self selection leafItems do:				[ :pkg | overs addAll: pkg overrides ]			]		ifFalse: [ overs := self selection overrides ].	overs isEmpty		ifTrue: [ ^Dialog warn: 'No overriden code' ].	OverrideList new openOn: overs.</body><body package="Store-UI-Browser" selector="browseOverrides">browseOverrides	| overs |	self selection isBundle		ifTrue:			[ overs := OrderedCollection new.			self selection leafItems do:				[ :pkg | overs addAll: ( Override overriddenByComponent: pkg ) ]			]		ifFalse: [ overs := Override overriddenByComponent: self selection ].	overs isEmpty		ifTrue: [ ^Dialog warn: 'No overrides' ].	OverrideList new openOn: overs.</body><body package="Store-UI-Browser" selector="browseVersions">browseVersions	self dbManager doIfOnlineImage: 		[ self packages do: 			[:package | self spawningBrowserClass browseVersionsOfPundle: package ]		]</body><body package="Store-UI-Browser" selector="changeListOnChanges">changeListOnChanges	Store.PundleChangeList openOn: self selection for: DbRegistry dbIdentifier.</body><body package="Store-UI-Browser" selector="changeListOnChanges:">changeListOnChanges: dbid	Store.PundleChangeList openOn: self selection for: dbid.</body><body package="Store-UI-Browser" selector="deletePackage">deletePackage	| packages | 	packages := self packages.	( Dialog confirm: 			'Unload', (packages inject: '' into: [:str :pun | str , ' ' , pun name]) , '?')		ifTrue: [ packages do: [:pkg | pkg unloadLogged: false ]]</body><body package="Store-UI-Browser" selector="diffPackageWithParent">diffPackageWithParent	"Spawn a difference browser on a selected package and 	on its trace."	self dbManager doIfOnlineImage: 		[ self packages do: 			[ :each |  	| pkg trace |			pkg := each hasBeenModified | each isLoaded not				ifTrue: [ each ]				ifFalse: [ each parentRecord == nil							ifTrue: [ each ]							ifFalse: [ each parentRecord ]						].			( trace := pkg parentRecord ) isNil 				ifTrue: [ trace := pkg selectVersion ].			trace == nil 	ifTrue: [ ^self ].			pkg isPackage				ifTrue: [ ComparisonBrowser comparePackage: pkg toPackage: trace ]				ifFalse: [ BundleDifferenceBrowser compare: pkg with: trace ]			]		]</body><body package="Store-UI-Browser" selector="diffWithVersion">diffWithVersion	"Spawn a difference browser on the selected package and a selected version."	| pkg |	pkg := self selection.	self dbManager doIfOnlineImage: 		[  | trPkg |		trPkg := pkg selectVersion.		trPkg == nil 	ifTrue: [ ^self ].		self isForPackage 			ifTrue: [ ComparisonBrowser comparePackage: pkg toPackage: trPkg ]			ifFalse: [ BundleDifferenceBrowser compare: pkg with: trPkg ]		]</body><body package="Store-UI-Browser" selector="enclosingComponents">enclosingComponents	| comps str |	( comps := self package enclosingComponents ) isEmpty		ifTrue: [ Dialog warn: 'No enclosing bundles.' ]		ifFalse:			[ str := ( String new: 50 ) writeStream.			comps do:	[ :comp  | str nextPutAll: comp itemString; cr ].			Dialog warn: str contents			].</body><body package="Store-UI-Browser" selector="fileIntoPackage">fileIntoPackage	| fileName |	self package == nil ifTrue: [ ^self ].	self isForPackage		ifFalse: [ ^Dialog warn: 'Can not filein to a bundle.' ].	self changeRequest ifFalse: [ ^self ].	fileName := Dialog		requestFileName: 'File in from file named'		default: '*.st'		version: #mustBeOld		ifFail: [nil]		for: self interfaceWindow.	( fileName isNil or: [ fileName isEmpty ] ) ifTrue: [ ^self ].	[ self forceIfForPackage: [ ( fileName asFilename withEncoding: #Source ) fileIn ] ]		on: RedefinitionNotification do:			[ :note |			note currentPackage = self package 				ifFalse: [ note override install ]. 			note resume.			].				module nextModule updateList.</body><body package="Store-UI-Browser" selector="fileOutChanges">fileOutChanges	self fileOutChanges: DbRegistry dbIdentifier</body><body package="Store-UI-Browser" selector="fileOutChanges:">fileOutChanges: dbid	| packages fileName strm |	packages := self packages.	packages size = 0 ifTrue: [ ^self ].	fileName := packages size = 1		ifTrue: [ self package name asString ]		ifFalse: [ 'changes' ].	fileName := Dialog			requestNewFileName: 'File out changes on'			default: (Filename filterFilename: fileName, '.st'). 	fileName isEmpty ifTrue: [ ^nil ].	strm := SourceCodeStream  write: fileName.	Cursor write showWhile: 		[ [ strm timeStamp.		  packages do: [ :pun | pun fileOutChangesForDb: dbid on: strm ]		  ] ensure: [ strm close ]		]</body><body package="Store-UI-Browser" selector="fileOutDifferences">fileOutDifferences	| pkg other |	( pkg := self selection ) == nil	ifTrue: [ ^self ].	( other := pkg selectVersion ) == nil		ifTrue: [ ^self ].	( pkg pundleChangesClass with: other with: pkg ) fileOutChangesFor: 2.</body><body package="Store-UI-Browser" selector="fileOutPackages">fileOutPackages	self packages do: [:package | package fileOut]</body><body package="Store-UI-Browser" selector="find">find	"Prompt for a name and position myself there."	| obj pkg mod warnString model protocol data |	self changeRequest ifFalse: [ ^self ].	obj := self findASomething: 'Find:'.	obj == nil ifTrue: [ ^self ].	warnString := obj fullName, ' not in registered package'.	obj isBindingReference		ifTrue: 			[ pkg := Registry containingPackageForDataKey: obj name						symbol: obj environment absoluteSymbol.			obj environment isForClass				ifTrue: [ self browser metaShowData  ].			model := pkg modelAtSymbol: obj environment absoluteSymbol 							ifAbsent: [ ^Dialog warn: warnString].			protocol :=  obj environment asNameSpace categoryFor: obj name.			data := model isForNameSpace				ifTrue: 					[ DatumDescriptor fromDataKey: obj name 						nameSpaceName: model absoluteName					]				ifFalse: 	[ DatumDescriptor fromDataKey: obj name 							className: model absoluteName 						].			]				ifFalse:			[ pkg := self choosePackage: ( Registry packagesContaining: obj ).			pkg == nil ifTrue: [ ^self ].			model := pkg modelAtSymbol: obj absoluteSymbol ifAbsent: [ ^Dialog warn: warnString ].			].	self module selection: pkg.	( mod := module nextModule ) selection: model.	obj isBindingReference 		ifTrue:			[ ( mod := mod nextModule ) selection: protocol.			mod nextModule selection: data			].	module nextModule updateList.</body><body package="Store-UI-Browser" selector="findPackage">findPackage	| pkg |	( pkg := self findAPackage ) == nil		ifFalse: [ self module selection: pkg ].</body><body package="Store-UI-Browser" selector="graphVersions">graphVersions	DbRegistry doIfOnlineImage: 		[		self packages do: 			[ :pkg | VersionGraph browseVersionsOfPundle: pkg ]		]</body><body package="Store-UI-Browser" selector="inspectChanges">inspectChanges	self inspectChanges: DbRegistry dbIdentifier</body><body package="Store-UI-Browser" selector="inspectChanges:">inspectChanges: dbid	| ctrl |	ctrl := InputState default ctrlDown.	self packages do: 		[ :package | | cs |		cs := package changeSetFor: dbid.		cs == nil			ifTrue: [ ^Dialog warn: 'No change set for ', dbid ].		ctrl 			ifTrue: [ cs basicInspect ]			ifFalse: [ cs inspect ]		].</body><body package="Store-UI-Browser" selector="newBundle">newBundle	BundleSpecEditor open</body><body package="Store-UI-Browser" selector="newPackage">newPackage	| pkg |	pkg := SmalltalkWorkbench requestNewPackageName			ifNil: [^self]			ifNotNil: [:name | PackageModel named: name].	self isForBundle 		ifTrue: [ 	self selection addItem: pkg ].	self module selection: pkg.</body><body package="Store-UI-Browser" selector="packageProperties">packageProperties	self selection == nil		ifFalse: [ PackagePropertiesDialog on: self selection ]</body><body package="Store-UI-Browser" selector="publishAsParcel">publishAsParcel	self selection == nil		ifTrue: [ ^self ].	self selection isLoaded		ifFalse: [ ^Dialog warn: 'Only loaded packages can be published.' ].	Store.PublishAsParcelDialog publishAsParcel: self selection.</body><body package="Store-UI-Browser" selector="reconcile">reconcile	| pkg |	pkg := self package.	( ( pkg hasTrace not 		or: [ pkg validateDatabaseId not ] )		or: [ InputState default ctrlDown ]  	)		ifFalse: [ ( Dialog confirm: 'Package already has a parent.&lt;nt&gt;Select a new parent?' expandMacros )					ifFalse: [ ^self ] 				].	self dbManager doIfOnlineImage: [ pkg reconcileWithDb ].</body><body package="Store-UI-Browser" selector="spawn">spawn	InputState default ctrlDown ifTrue: [ ^self selection inspect ].	self selections do:		[ :selection | self spawningClass openOnPackage: selection ].</body><body package="Store-UI-Browser" selector="storePackageInDB">storePackageInDB	self dbManager doIfOnlineImage: 		[ Cursor wait showWhile: 			[ self packages do: [ :package | package storeInDB ] ]		]</body><body package="Store-UI-Browser" selector="updateList">updateList	self updateListFull.</body></methods><methods><class-id>Store.PackageBrowserHelper</class-id> <category>private</category><body package="Store-UI-Browser" selector="addBlessingForPundle:">addBlessingForPundle: aDBPundle 	"Add a new record describing blessing for package."	BlessingDialog setBlessingFor: aDBPundle.</body><body package="Store-UI-Browser" selector="compile:from:">compile: text from: aController	"Compile text and answer the result"	^self definitionCompilerClass new		evaluate: text string		in: nil		allowReceiver: false		receiver: nil		environment: self doItEnvironment		notifying: aController		ifFail: [ false ]</body><body package="Store-UI-Browser" selector="fileOutPackageDifferences:with:into:">fileOutPackageDifferences: pkg1 with: pkg2 into: aStream 	pkg2 == nil		ifTrue: [ pkg1 fileOutOn: aStream ]		ifFalse: [ Notice 	show: 'Comparing versions of package ' , pkg1 name , '.' while: 					[ | pkgDiffs |					pkgDiffs := PackageDifferences with: pkg1 with: pkg2.					pkgDiffs fileDiffsOn: aStream					]				].	aStream cr.</body><body package="Store-UI-Browser" selector="findAPackage">findAPackage	"Repeatedly prompt the user for a name or pattern. Answer a package or nil"	| string pkgs |	string := ''.	[ string := Dialog request: 'Enter package name' initialAnswer: string for: self interfaceWindow.	string isEmpty 		ifTrue: [ ^nil ].	( pkgs := Registry allBundles, Registry allPackages select: [ :pkg | string match: pkg name ] ) isEmpty		ifTrue: 			[ ( Dialog confirm: 'No matching packages. Try Again?' )					ifFalse: [ ^nil ].			].	pkgs isEmpty	] whileTrue.	^self choosePackage: pkgs.</body><body package="Store-UI-Browser" selector="spawningClass">spawningClass	^TabApplicationSystemBrowser</body></methods><methods><class-id>Store.PackageBrowserHelper</class-id> <category>text processing</category><body package="Store-UI-Browser" selector="acceptDefinition:from:">acceptDefinition: aText from: aController	^self browser isClassCentric		ifTrue: [ self browser classPane acceptDefinition: aText from: aController ]		ifFalse: 			[ [ self forceIfForPackage: [ super acceptDefinition: aText from: aController ] ]				on: RedefinitionNotification 				do: [ :note | RedefinitionNotification interactiveHandler: note forcedPackage: self package].			].</body><body package="Store-UI-Browser" selector="acceptText:from:">acceptText: text from: textController	self selection == nil  ifTrue: [ ^nil ].	self pkgDef == #showPackageProperties		ifTrue: [ ^self ].	self isPackageLoaded ifFalse: [ ^self warnPackageNotLoaded ].	self pkgDef == #showPackageComment		ifTrue: [ self selection comment: text string. ^true ].	^self acceptDefinition: text from: textController.</body><body package="Store-UI-Browser" selector="explainerClass">explainerClass	^nil</body><body package="Store-UI-Browser" selector="showPackageProperties">showPackageProperties	| pkg text |	( pkg :=  self package ) == nil		ifTrue: [ ^'' asText ].	pkg propertiesForSave isEmpty		ifTrue: [ ^'no properties' asText emphasizeAllWith: #italic ].	text := '' asText.	pkg propertiesForSave associations asSortedCollection do:		[ :assoc |		text := text, ( assoc key asText, ': ' ) allBold.		text := text, ( ( assoc value printString, '\\' ) withCRs ).		].	^text</body><body package="Store-UI-Browser" selector="text">text	^self selection == nil		ifTrue: [module selections isEmpty			ifTrue: [nil]			ifFalse: [Text new]]		ifFalse:			[self textWhenSelected]</body><body package="Store-UI-Browser" selector="textWhenSelected">textWhenSelected	| text pkg |	self browser isClassCentric		ifTrue: [ ^nil ].	( pkg := self package ) == nil   ifTrue: [ ^'' asText ].	self browser pkgDef value == #showPackageComment 		ifTrue: [ ^pkg comment asText ].	self browser pkgDef value == #showPackageProperties		ifTrue: [ ^self showPackageProperties ].	"showDefinition"	text := pkg textForItem.	pkg isLoaded not &amp; DbRegistry isOnline &amp; pkg isInCurrentDatabase		ifTrue: 			[ text := text, '			', ( Blessing blessingHistoryForPundle:  pkg ) printString			].	^text asText.</body><body package="Store-UI-Browser" selector="updateListForDefinedThing:">updateListForDefinedThing: class	module nextModule updateListForDefinedThing: class</body></methods><methods><class-id>Store.PackageBrowserHelper</class-id> <category>drag and drop</category><body package="Store-UI-Browser" selector="acceptableDCKeys">acceptableDCKeys	^Set new		add: self classOrNamespaceKey;		add: self selectorOrStaticKey;		add: self storeStaticKey;		add: self protocolKey;		yourself.</body><body package="Store-UI-Browser" selector="canAcceptDropFrom:">canAcceptDropFrom: aDC	^self acceptableDCKeys includes: aDC key.</body><body package="Store-UI-Browser" selector="drop:">drop: aDragContext	"A drop has occured in the category list of the browser. see if we can accept and if so move the class(es)."	| ctrl idx |	( self canAcceptDropFrom: aDragContext ) ifFalse:[ ^#dragEffectNone ].	self browser changeRequest ifFalse: [^#dropEffectNone].	"Locate the target category's index"	ctrl := aDragContext clientData at: #ctrl.	idx := ctrl view targetIndex.	idx = 0 ifTrue: [^#dropEffectNone].	^( self processData: aDragContext sourceData clientData 			key: aDragContext key			forPackage: ( self list at: idx )	) ifTrue: [ module nextModule updateList. #dropEffectMove ]	  ifFalse: [ #dropEffectNone ].</body><body package="Store-UI-Browser" selector="getDragDropKey">getDragDropKey	"return the data key for the drag"	^self storePackageKey.</body><body package="Store-UI-Browser" selector="processData:key:forPackage:">processData: clientData  key: aKey forPackage: aPackage	| fromPkg classesOrNameSpaces |	aPackage isBundle ifTrue: [ ^false ].	fromPkg := clientData at: self storePackageKey ifAbsent: [ nil ].	classesOrNameSpaces := clientData at: self classOrNamespaceKey ifAbsent: [ nil ].	( aKey == self storeStaticKey )		ifTrue: [ ^self processDragStoreStatics: clientData toPackage: aPackage].	( aKey == self selectorOrStaticKey )		ifTrue: [ ^self processDragStatics: clientData toPackage: aPackage ].	( aKey == self protocolKey )		ifTrue: [ ^self processDragProtocols: clientData toPackage: aPackage ].	( aKey == self classOrNamespaceKey )		ifTrue: [ ^self processDragClassOrNameSpaces: classesOrNameSpaces							fromPackage: fromPkg toPackage: aPackage			   ].	^false.</body><body package="Store-UI-Browser" selector="processDragClassOrNameSpaces:fromPackage:toPackage:">processDragClassOrNameSpaces: list fromPackage: fromPackage toPackage: toPackage	( list == nil or: [ list isEmpty ] )		ifTrue: [ ^false ].	list do:		[ :obj | 		fromPackage == nil			ifTrue: [ XChangeSet current moveWholeObject: obj toPackage: toPackage ]			ifFalse:	[ XChangeSet current moveObject: obj from: fromPackage to: toPackage ]		].	^true</body><body package="Store-UI-Browser" selector="processDragProtocols:toPackage:">processDragProtocols: clientData toPackage: toPackage	| list cls meta keys |	( list := clientData at: #protocol ) isEmpty ifTrue: [ ^false ].	( cls := clientData at: #class ) == nil ifTrue: [ ^false ].	( meta := clientData at: #meta ) == nil ifTrue: [ ^false ].	keys := OrderedCollection new.	list do: [ :protocol | keys addAll: ( cls organization listAtCategoryNamed: protocol ) ].	( ( meta == #data ) or: [ cls isForNameSpace ] )		ifTrue:			[ cls := cls asNameSpace namedReferent.		"just to make sure" 			keys do: [ :key | XChangeSet current moveDataKey: key owner: cls toPackage: toPackage ]			]		ifFalse:			[ keys do: [ :key | XChangeSet current moveSelector: key class: cls toPackage: toPackage ] ].	^true</body><body package="Store-UI-Browser" selector="processDragStatics:toPackage:">processDragStatics: clientData toPackage: toPackage	| list cls meta |	( list := clientData at: #selector ) isEmpty ifTrue: [ ^false ].	( cls := clientData at: #class ) == nil ifTrue: [ ^false ].	( meta := clientData at: #meta ) == nil ifTrue: [ ^false ].	list do:		[ :sym | 		( ( meta == #data ) or: [ cls isForNameSpace ] )			ifTrue: [ XChangeSet current moveDataKey: sym owner: cls toPackage: toPackage ]			ifFalse:	[ XChangeSet current moveSelector: sym class: cls toPackage: toPackage ]		].	^true</body><body package="Store-UI-Browser" selector="processDragStoreStatics:toPackage:">processDragStoreStatics: clientData toPackage: pkg	| list |	( list := clientData at: self storeMethodKey ) isEmpty ifTrue: [ ^false ].	list do:		[ :sel | 		sel isForData			ifTrue: [ XChangeSet current moveDataKey: sel dataKey owner: sel owner toPackage: pkg ]			ifFalse: [ XChangeSet current moveSelector: sel selector class: sel myClass toPackage: pkg ].		].		^true</body></methods><methods><class-id>Store.PackageBrowserHelper class</class-id> <category>menus accessing</category><body package="Store-UI-Browser" selector="menuHeader">menuHeader	^'Package'</body></methods><methods><class-id>Store.PackageDifferences</class-id> <category>testing</category><body package="Store-Change Management" selector="isEmpty">isEmpty		^classes1 isEmpty and: 		[classes2 isEmpty and: 		[meta1 isEmpty and: 		[meta2 isEmpty and: 		[ nameSpaces1 isEmpty and:		[ nameSpaces2 isEmpty and:		[methods1 isEmpty and: 		[methods2 isEmpty and: 		[data1 isEmpty and: 		[data2 isEmpty]]]]]]]]]</body><body package="Store-Change Management" selector="isNewClassDefinition:">isNewClassDefinition: aClass	"Anser true if aClass is in one of the class lists."	^(IdentitySet withAll: (classes1, classes2, meta1, meta2)) includes: aClass</body><body package="Store-Change Management" selector="isNewNameSpaceDefinition:">isNewNameSpaceDefinition: aNameSpace	"Anser true if aNameSpace is in one of the nameSpace lists."	^(IdentitySet withAll: (nameSpaces1, nameSpaces2)) includes: aNameSpace</body></methods><methods><class-id>Store.PackageDifferences</class-id> <category>filing out</category><body package="Store-Change Management" selector="classesToRemove">classesToRemove	^classes2 select: 		[ :each | 		( classes1 detect: [:cl1 | cl1 absoluteName = each absoluteName] ifNone: [ nil] ) 				isNil		]</body><body package="Store-Change Management" selector="dataToRemove">dataToRemove	^data2 		select: [:each | 			(data1 detect: [:m1 | m1 name = each name 							and: [m1 environmentString = each environmentString]]						ifNone: [nil]) isNil]</body><body package="Store-Change Management" selector="fileDiffsOn:">fileDiffsOn: fileManager	"Create a file containing differences between package1 and package2. 	If the package2 is currently loaded into an image, filing in the 	differences will change it into package1"	| class2  nameSpace2 toFileOut  classNamesToRemove nameSpacesToRemove |	fileManager deferInitializations.	"New namespaces or namespaces with new definitions."	nameSpaces1 do: 		[ :each | 		nameSpace2 := nameSpaces2 			detect: [ :ns2 | ns2 absoluteName = each absoluteName] ifNone: [ nil ].		each fileOutDifferencesBetween: nameSpace2 on: fileManager		].	"New classes or classes with new definitions."	classes1 do: 		[ :each | 		class2 := classes2 detect: [:cl2 | cl2 absoluteName = each absoluteName] ifNone: [nil].		each fileOutDifferencesBetween: class2 on: fileManager		].	"Removed classes."	classNamesToRemove := self classesToRemove collect: [ :cls | cls absoluteName ].	classNamesToRemove reverseDo: 		[ :className | fileManager removeObject: className type: #class ].	classNamesToRemove := classNamesToRemove, 		( classNamesToRemove collect: [ :cn | cn fullMetaName ] ).		"Removed namespaces."	nameSpacesToRemove := self nameSpacesToRemove collect: [ :ns | ns absoluteName ].	nameSpacesToRemove reverseDo:		[ :nsname | fileManager removeObject: nsname type: #nameSpace	].	"New method definitions."	toFileOut := self modifiedMethods.	toFileOut keysAndValuesDo: 		[ :k :v | fileManager fileOutTTMessages: v for: k logging: true ].	"Removed methods."	self methodsToRemove do: 		[ :method | 		( classNamesToRemove includes: method className )			ifFalse: [ fileManager storeExpression: 						method className , ' removeSelector: ' , method selector storeString 					  ]		].</body><body package="Store-Change Management" selector="loadFromDBWithin:">loadFromDBWithin: parentBundle	"Convert a loaded package2 into package1 Don't remove anything defined in parentBundle."	| toLoad affected toInit parentLeafItems |	"New namespaces or namespaces with new definitions."	nameSpaces1 do: [ :each | each loadSrcInto: pkg2 ].	"New classes or classes with new definitions."	toLoad := Package superclassOrder: classes1.	toLoad do: [ :each | each loadSrcInto: pkg2 ].	"Inline Bundle&gt;&gt;#includesDefinitionOf: for speed. Compute the leaf items just once and inline the Bundle queries."	parentLeafItems := parentBundle ifNil: [ Array new ] ifNotNil: [ :b | b leafItems ].	"Removed classes."	( self classesToRemove, self nameSpacesToRemove ) do: 		[ :each |  | obj |            ( obj := each actual ) == nil 			ifFalse: 				[ ( ( parentLeafItems anySatisfy: [ :pkg | pkg includesDefinitionOf: obj absoluteName ] ) not )					ifTrue: [ Override unloadClassOrNameSpace: obj from: pkg2 ]				]		].	"Load new data."	data1 do: [ :each | each loadSrc ].	"Load new methods"	toInit := Set new.		methods1 do: 		[ :each | 		each loadAsNew.		( each isMeta and: [ each selector == #initialize ] )			ifTrue: [ toInit add: each myClass instanceBehavior ].		].	"Removed methods."	affected := Set new.		self methodsToRemove do: 		[ :each | 	| cls |		( cls := each myClass ) == nil			ifFalse:				[ ( ( parentLeafItems anySatisfy: [ :pkg | pkg includesSelector: each selector  class: cls ] ) not )					ifTrue: 						[ Override unloadSelector: each selector class: cls from: pkg2 logged: true.						affected add: cls.						]					ifFalse: [ pkg2 relinquishSelector: each selector class: cls ]				]		].	"Removed data."	self dataToRemove do: 		[:each | | owner |		( owner := each owner ) notNil 			ifTrue:				[ ( ( parentLeafItems anySatisfy: [ :pkg | pkg includesDataKey: each dataKey owner: owner ] ) not )					ifTrue: 						[ Override unloadStatic: each in: owner from: pkg2 logged: #(#changes #file).						affected add: owner						]				]		].	 ( DataElement sortStaticsForLoading: data1 ) do:		[ :datum |  ( datum owner asNameSpace bindingFor: datum dataKey ) reinitializeValue ].	classes1 do:		[ :cls | | obj |		( ( obj := cls object ) class includesSelector: #initialize )			ifTrue: 				[ ( classes2 includes: cls )					ifTrue: [	toInit add: obj ]					ifFalse: [ obj postLoad: pkg1 ]				]		].	toInit do: [ :cls | cls initialize ].	"remove empty protocols perhaps created by removing and moving methods"	affected do: [ :owner | owner organization removeEmptyCategories].	pkg2 removeEmptyProtocols.</body><body package="Store-Change Management" selector="methodsToRemove">methodsToRemove	^methods2 select: 		[ :each | 		( methods1 detect: 			[ :m1 | 			( ( m1 isMeta = each isMeta ) and:				[ m1 name = each name ] ) and:				[ m1 className asClassNameOnly = each className asClassNameOnly ] 			] ifNone: [ nil] ) isNil		]</body><body package="Store-Change Management" selector="nameSpacesToRemove">nameSpacesToRemove	^nameSpaces2 select: 		[:each | (nameSpaces1 					detect: [:ns1 | ns1 absoluteName = each absoluteName ]					ifNone: [nil]					) isNil 		]</body><body package="Store-Change Management" selector="preLoadCheck">preLoadCheck	^LoadAnalyzer		preDBLoadOverlapCheckOf: pkg2		classes: classes1		nameSpaces: nameSpaces1		methods: methods1		data: data1</body><body package="Store-Change Management" selector="preLoadCheckWithin:">preLoadCheckWithin: aBundle	^LoadAnalyzer		preDBLoadOverlapCheckOf: pkg2		within: aBundle		classes: classes1		nameSpaces: nameSpaces1		methods: methods1		data: data1</body><body package="Store-Change Management" selector="storeDataIntoPackage:">storeDataIntoPackage: newDBPackage 	"Store the data from the loaded package2 	into the database as a difference to package1"	^self storeDataIntoPackage: newDBPackage using: nil</body><body package="Store-Change Management" selector="storeDataIntoPackage:using:">storeDataIntoPackage: newDBPackage using: mergeData 	"Store the data from the loaded package2 	into the database as a difference to package1"	| oldData newData |	newData := List new.		"Copy data from package1 to newDBPackage ."	Data copyDataFromTrace: pkg1 primaryKey to: newDBPackage primaryKey.	oldData := data1 copy.	data2 do: 		[:each | 	| indx oldDBDatum newDBDatum |		oldDBDatum := nil.		indx := oldData findFirst: 			[:m1 |  m1 name = each name 						and: [ m1 environmentString = each environmentString ]			].		indx &gt; 0			ifTrue: 				[ oldDBDatum := oldData at: indx.				oldData removeAtIndex: indx				].		newDBDatum := mergeData isNil			ifTrue: [ nil ]			ifFalse: [ mergeData resolutionRecordForTag: 						each asTag packageNamed: newDBPackage name ].		( ( newDBDatum == nil ) and: [ each binding ~~ nil ] )			ifTrue: 				[ newDBDatum := 					DataElement 						recordFromDescriptor: each 						trace: oldDBDatum							package: newDBPackage				].		newData add: newDBDatum.		 newDBDatum == nil 			ifFalse:				[ 				oldDBDatum == nil					ifTrue: [ newDBPackage addNewDBDatum: newDBDatum ]					ifFalse: 						[ "The static could have been reverted."						oldDBDatum primaryKey = newDBDatum primaryKey 							ifFalse: [ newDBPackage replaceDBDatum: oldDBDatum with: newDBDatum]						]				].		].	"At this point oldData contains only data that have been removed."	oldData do: 	[ :each |  newDBPackage removeDBDatum: each ].	^newData</body><body package="Store-Change Management" selector="storeMethodsIntoPackage:">storeMethodsIntoPackage: newDBPackage 	"Store the methods from the loaded package2 	into the database as a difference to package1"	^self storeMethodsIntoPackage: newDBPackage using: nil</body><body package="Store-Change Management" selector="storeMethodsIntoPackage:using:">storeMethodsIntoPackage: newDBPackage using: mergeData 	"Store the methods from the loaded package2 	into the database as a difference to package1"	| oldMethods newMethods |	newMethods := List new.		"Copy methods from package1 to newDBPackage ."	Methods copyMethodsFromTrace: pkg1 primaryKey to: newDBPackage primaryKey.	oldMethods := methods1 copy.	methods2 do: 		[ :each |   | indx oldDBMethod newDBMethod |		oldDBMethod := nil.		indx := oldMethods findFirst: 			[ :m1 | 			m1 selector = each selector and: 				[ m1 classNameWithMeta = each classNameWithMeta ] 			].		indx &gt; 0			ifTrue: 				[ oldDBMethod := oldMethods at: indx.				oldMethods removeAtIndex: indx				].		newDBMethod := mergeData isNil			ifTrue: [ nil ]			ifFalse: [ mergeData resolutionRecordForTag: 						each asTag packageNamed: newDBPackage name ].		( ( newDBMethod == nil ) and: [ each method ~~ nil ] )			ifTrue: 				[ newDBMethod := 					Method recordFromDescription: each 					trace: oldDBMethod 					package: newDBPackage 				].		newMethods add: newDBMethod.		 newDBMethod == nil 			ifFalse:				[ 				oldDBMethod == nil					ifTrue: [ newDBPackage addNewDBMethod: newDBMethod ]					ifFalse: 						[ "The method could have been reverted."						oldDBMethod primaryKey = newDBMethod primaryKey 							ifFalse: [ newDBPackage replaceDBMethod: oldDBMethod with: newDBMethod ]						]				]		].	"At this point oldMethods contains only methods that have been removed."	oldMethods do: [ :each | newDBPackage removeDBMethod: each ].	^newMethods</body></methods><methods><class-id>Store.PackageDifferences</class-id> <category>accessing - diff browser</category><body package="Store-Change Management" selector="diffClasses">diffClasses	"Answer an array contianing collection of classes that are either modified in one package	or contain methods that are modified.  Note that meta side is included in the answer."	| names1 aditionalClasses1 names2 aditionalClasses2 allClasses answ1 answ2 names |	names1 := Set new.	methods1 do: [ :m| names1 add: m className ].	data1 do: [ :m | m  isInClass ifTrue: [ names1 add: m ownerName ] ].	allClasses := classes1, meta1.	(allClasses) do: [:cl| names1 remove: cl absoluteName ifAbsent: []].	aditionalClasses1 := pkg1 classesNamed: names1.	answ1 := (allClasses, aditionalClasses1) asSortedCollection: [:x :y | x name &lt; y name].	names2 := Set new.	methods2 do: [:m| names2 add: m classNameWithMeta].	data2 do: [ :m| m  isInClass ifTrue: [names2 add: m ownerName] ].	allClasses := classes2, meta2.	(allClasses) do: [:cl| names2 remove: cl absoluteName ifAbsent: []].	aditionalClasses2 := pkg2 classesNamed: names2.	answ2 := (allClasses, aditionalClasses2) asSortedCollection: [:x :y | x name &lt; y name].	"Check if additional classes are in both packages."	names := names1 - names2.	answ2 do: [:cd| names remove: cd absoluteName ifAbsent: []].	answ2 addAll: (pkg2 classesNamed: names).	names := names2 - names1.	answ1 do: [:cd| names remove: cd absoluteName ifAbsent: []].	answ1 addAll: (pkg1 classesNamed: names).	^Array with: answ1 with: answ2</body><body package="Store-Change Management" selector="diffNameSpaces">diffNameSpaces	"Answer an array contianing collection of namespaces that are either modified in one package	or contain methods that are modified. "	| names1 aditional1 names2 aditional2 allNameSpaces answ1 answ2 names |	names1 := Set new.	data1 do: [ :m| m  isInNameSpace ifTrue: [ names1 add: m ownerName ] ].	allNameSpaces := nameSpaces1.	allNameSpaces do: [:ns | names1 remove: ns absoluteName ifAbsent: []].	aditional1 := pkg1 nameSpacesNamed: names1.	answ1 := (allNameSpaces, aditional1) asSortedCollection: [:x :y | x absoluteName &lt; y absoluteName].	names2 := Set new.	data2 do: [:m| m  isInNameSpace ifTrue: [ names2 add: m ownerName] ].	allNameSpaces := nameSpaces2.	(allNameSpaces) do: [:ns| names2 remove: ns absoluteName ifAbsent: []].	aditional2 := pkg2 nameSpacesNamed: names2.	answ2 := (allNameSpaces, aditional2) asSortedCollection: [:x :y | x name &lt; y name].	"Check if additional namespaces are in both packages."	names := names1 - names2.	answ2 do: [:cd| names remove: cd absoluteName ifAbsent: []].	answ2 addAll: (pkg2 nameSpacesNamed: names).	names := names2 - names1.	answ1 do: [:cd| names remove: cd absoluteName ifAbsent: []].	answ1 addAll: (pkg1 nameSpacesNamed: names).	^Array with: answ1 with: answ2</body><body package="Store-Change Management" selector="methodsAndDataSide:forClassNamed:andProtocol:">methodsAndDataSide: side forClassNamed: cName andProtocol: pName 	"If 'pName' is a method protocol select from methods	only those that are from a class named 'cName' and 	classified under protocol 'pName'.  If 'pName' is a data	protocol (*data*) select from data only those that	are from a class named 'cName'."	^(pName = '*data*'		ifTrue: [(self dataSide: side) 				select: [:datum | datum ownerName = cName]]		ifFalse: [(self methodsSide: side) 				select: [:method | method className = cName 					and: [method protocolName = pName]]])		asSortedCollection: [:x :y | x name &lt; y name]</body><body package="Store-Change Management" selector="methodsSide:remove:">methodsSide: side remove: aMethodDescriptor		(self methodsSide: side) remove: aMethodDescriptor</body><body package="Store-Change Management" selector="newMethods">newMethods	^methods1 asList, methods2 asList</body><body package="Store-Change Management" selector="protocolsSide:forClassNamed:">protocolsSide: side forClassNamed: cName 	"Answer a collection of protocol names (strings)	that are from a class named cName"	| protocols mthds |	protocols := Set new: (self methodsSide: side) size.	mthds := (self methodsSide: side) select: [:method | method classNameWithMeta = cName].	mthds do: [:method| protocols add: method protocolName].	((self dataSide: side) 		detect: [:datum | datum ownerName = cName] 		ifNone: [nil]) notNil ifTrue: [			protocols add: '*data*'].	^protocols asSortedCollection</body><body package="Store-Change Management" selector="reverse">reverse	"Swap pkg1 with pkg2"	| tmp |	tmp := pkg1.	pkg1 := pkg2.	pkg2 := tmp.	tmp := classes1.	classes1 := classes2.	classes2 := tmp.	tmp := meta1.	meta1 := meta2.	meta2 := tmp.	tmp := methods1.	methods1 := methods2.	methods2 := tmp.	tmp := data1.	data1 := data2.	data2 := tmp.</body></methods><methods><class-id>Store.PackageDifferences</class-id> <category>accessing</category><body package="Store-Change Management" selector="classesSide:">classesSide: side	^side = 1 		ifTrue: [classes1] 		ifFalse: [classes2]</body><body package="Store-Change Management" selector="classesSide:put:">classesSide: side put: aValue 	side = 1		ifTrue: [classes1 := aValue asOrderedCollection]		ifFalse: [classes2 := aValue asOrderedCollection]</body><body package="Store-Change Management" selector="dataSide:">dataSide: side	^side = 1 ifTrue: [data1] ifFalse: [data2]</body><body package="Store-Change Management" selector="dataSide:put:">dataSide: side put: aValue 	side = 1		ifTrue: [data1 := aValue asOrderedCollection]		ifFalse: [data2 := aValue asOrderedCollection]</body><body package="Store-Change Management" selector="hasDifferences">hasDifferences	"*** adapted from 17 November 1994 at 1:35:56 pm by IA (Image Administrator	) in b940919 ***"	"Returns a boolean indicating whether or not some differences were found"	^(self classesSide: 1)	isEmpty not or: [	 (self classesSide: 2) 	isEmpty not or: [	 (self metaSide: 1) 		isEmpty not or: [	 (self metaSide: 2)		isEmpty not or: [	(self nameSpacesSide:  1) isEmpty not or: [	(self nameSpacesSide:  2) isEmpty not or: [	 (self methodsSide: 1) 	isEmpty not or: [	 (self methodsSide: 2) 	isEmpty not or: [	 (self dataSide: 1) 	isEmpty not or: [	 (self dataSide: 2) 	isEmpty not]]]]]]]]]</body><body package="Store-Change Management" selector="itemCount">itemCount	^classes1 size + nameSpaces1 size + methods1 size +  data1 size</body><body package="Store-Change Management" selector="metaSide:">metaSide: side	^side = 1 ifTrue: [meta1] ifFalse: [meta2]</body><body package="Store-Change Management" selector="metaSide:put:">metaSide: side put: aValue 	side = 1		ifTrue: [meta1 := aValue asOrderedCollection]		ifFalse: [meta2 := aValue asOrderedCollection]</body><body package="Store-Change Management" selector="methodsSide:">methodsSide: side	^side = 1 ifTrue: [methods1] ifFalse: [methods2]</body><body package="Store-Change Management" selector="methodsSide:put:">methodsSide: side put: aValue 	side = 1		ifTrue: [methods1 := aValue asOrderedCollection]		ifFalse: [methods2 := aValue asOrderedCollection]</body><body package="Store-Change Management" selector="nameSpacesSide:">nameSpacesSide: side	^side = 1 		ifTrue: [ nameSpaces1 ] 		ifFalse: [ nameSpaces2 ]</body><body package="Store-Change Management" selector="nameSpacesSide:put:">nameSpacesSide: side put: aValue 	side = 1		ifTrue: [nameSpaces1 := aValue asOrderedCollection]		ifFalse: [nameSpaces2 := aValue asOrderedCollection]</body><body package="Store-Change Management" selector="pkgSide:">pkgSide: side	^side = 1 ifTrue: [pkg1] ifFalse: [pkg2]</body><body package="Store-Change Management" selector="pkgSide:put:">pkgSide: side put: aValue 	side = 1		ifTrue: [pkg1 := aValue]		ifFalse: [pkg2 := aValue]</body></methods><methods><class-id>Store.PackageDifferences</class-id> <category>private</category><body package="Store-Change Management" selector="asConflictHolder">asConflictHolder	| baby |	baby := PackageConflicts new.	baby fromDiffHolder: self.	^baby</body><body package="Store-Change Management" selector="cleanUpClassDiffsIn:and:">cleanUpClassDiffsIn: cls1 and: cls2	"Check if classes are really 	different or just came from different sources."	| toRemove1 |	toRemove1 := List new.	cls1 do: 		[:cl1 |		| idx cl2 |		idx := cls2 findFirst: [:cl| cl absoluteName = cl1 absoluteName].		idx isZero 			ifFalse:				[cl2 := cls2 at: idx.				cl2 definitionAndComment = cl1 definitionAndComment					ifTrue: 						[toRemove1 add: cl1.						cls2 removeAtIndex: idx]]].	cls1 removeAll: toRemove1.</body><body package="Store-Change Management" selector="cleanUpDiffs">cleanUpDiffs	"Check if method and classes are really 	different or just came from different sources."	methods1 := methods1 asOrderedCollection.	methods2 := methods2 asOrderedCollection.	self cleanUpSubdefDiffsIn: methods1 and: methods2.	data1 := data1 asOrderedCollection.	data2 := data2 asOrderedCollection.	self cleanUpSubdefDiffsIn: data1 and: data2.	classes1 := classes1 asOrderedCollection.	classes2 := classes2 asOrderedCollection.	self cleanUpClassDiffsIn: classes1 and: classes2.	meta1 := meta1 asOrderedCollection.	meta2 := meta2 asOrderedCollection.	self cleanUpClassDiffsIn: meta1 and: meta2.	nameSpaces1 := nameSpaces1 asOrderedCollection.	nameSpaces2 := nameSpaces2 asOrderedCollection.	self cleanUpNameSpaceDiffsIn: nameSpaces1 and: nameSpaces2.</body><body package="Store-Change Management" selector="cleanUpNameSpaceDiffsIn:and:">cleanUpNameSpaceDiffsIn: namespaces1 and: namespaces2	"Check if namespaces are really different or just came from different sources."	| toRemove1 |	toRemove1 := List new.	namespaces1 do: 		[ :ns1 |		| idx ns2 |		idx := namespaces2 findFirst: [ :ns | ns absoluteName = ns1 absoluteName ].		idx isZero 			ifFalse:				[ ns2 := namespaces2 at: idx.				ns2 definitionAndComment = ns1 definitionAndComment					ifTrue: 						[ toRemove1 add: ns1.						namespaces2 removeAtIndex: idx						]				]		].	namespaces1 removeAll: toRemove1.</body><body package="Store-Change Management" selector="cleanUpSubdefDiffsIn:and:">cleanUpSubdefDiffsIn: subdefs1 and: subdefs2	"Check if method/data are really 	different or just came from different sources."	| toRemove1 |	toRemove1 := List new.	subdefs1 do: 		[:m1 | 		| idx m2|		idx := m1 isForData			ifTrue: [ subdefs2 findFirst: [:m | m absoluteName = m1 absoluteName ] ]			ifFalse: 				[ subdefs2 findFirst: 					[ :d | d selector = m1 selector and: 							[ d classNameWithMeta = m1 classNameWithMeta ] 					]				].		idx isZero ifFalse: 			[m2 := subdefs2 at: idx.			(m2 sourceMatches: m1)				ifTrue: 					[toRemove1 add: m1.					subdefs2 removeAtIndex: idx]]].	subdefs1 removeAll: toRemove1.</body><body package="Store-Change Management" selector="combineDiffsFrom:">combineDiffsFrom: aDiffHolder	"Add differences from aDiffHolder into my differences."	1 to: 2 do: 		[ :side | 		self methodsSide: side 			put: ((self methodsSide: side) , (aDiffHolder methodsSide: side)).		self dataSide: side 			put: ((self dataSide: side) , (aDiffHolder dataSide: side)).		self classesSide: side 			put: ((self classesSide: side) , (aDiffHolder classesSide: side)).		self metaSide: side 			put: ((self metaSide: side) , (aDiffHolder metaSide: side)).		self nameSpacesSide: side 			put: ((self nameSpacesSide: side) , (aDiffHolder nameSpacesSide: side))		].	"Remove differences that are in both."	self removeDuplicateDifferencesIn: methods1 and: methods2.	self removeDuplicateDifferencesIn: data1 and: data2.	self removeDuplicateDifferencesIn: classes1 and: classes2.	self removeDuplicateDifferencesIn: meta1 and: meta2.	self removeDuplicateDifferencesIn: nameSpaces1 and: nameSpaces2.</body><body package="Store-Change Management" selector="computeDiffs">computeDiffs		pkg1 computeDiffsBetween: pkg2 into: self. 	pkg2 pseudoPackage ifFalse: [self cleanUpDiffs].</body><body package="Store-Change Management" selector="removeDuplicateDifferencesIn:and:">removeDuplicateDifferencesIn: defs1 and: defs2 	"Remove differences that are in both."	| toRemove |	toRemove := List new.	defs1 do: 		[:each | 		| idx |		(idx := defs2 indexOf: each ifAbsent: [nil]) notNil			ifTrue: 				[defs2 removeAtIndex: idx.				toRemove add: each]].	defs1 removeAll: toRemove</body></methods><methods><class-id>Store.PackageDifferences</class-id> <category>change set</category><body package="Store-Change Management" selector="changeSet">changeSet	"Answer a change set reflecting differences between package1 and package2. 	If package2 is currently loaded into an image, this change set reflects changes since	package1."	| cset |	cset := XChangeSet new.	self defClassChanges do:		[ :change | cset doClassChange: change ].	self defNameSpaceChanges do:		[ :change | cset doNameSpaceChange: change ].	self subdefChanges do:		[ :change | cset doSubdefChange: change ].	self propertyChanges do:		[ :change | cset addPropertyChange: change ].	self otherChanges do:		[ :change | cset addOtherChange: change ].	^cset.</body><body package="Store-Change Management" selector="defClassChanges">defClassChanges	"Answer a collection of definition changes for all Classes."	"The changes should move from pkg1 to pkg2"	| changes |	changes := OrderedCollection new.	classes1 do:		[ :cls |  | sym c2 |		sym := cls absoluteName.		( c2 := classes2 detect: [ :c | c comparesTo: cls ] ifNone: nil ) notNil			ifTrue: 				[ cls definition = c2 definition  					ifFalse: [ changes add: ( Change new classSymbol: sym ) change ].				( cls comment string equalsAcrossPlatforms:  c2 comment string )					ifFalse: [ changes add: ( Change new classSymbol: sym ) comment ]				]			ifFalse: 				[ changes add: ( Change new classSymbol: sym ) removeDefinition ].		].	classes2 do:		[ :cls | 		( classes1 contains: [ :c | c comparesTo: cls ] )			ifFalse: 				[ changes add: ( Change new classSymbol: cls absoluteName ) add.				cls comment isEmpty					ifFalse: [ changes add: ( Change new classSymbol: cls absoluteName ) comment ]				].		].	^changes</body><body package="Store-Change Management" selector="defNameSpaceChanges">defNameSpaceChanges	"Answer a collection of definition changes for all NameSpaces."	"The changes should move from pkg1 to pkg2"	| changes |	changes := OrderedCollection new.	nameSpaces1 do:		[ :ns |  | sym n2 |		sym := ns absoluteName.		( n2 := nameSpaces2 detect: [ :c | c comparesTo: ns ] ifNone: nil ) notNil			ifTrue: 				[ ns definition = n2 definition  					ifFalse: [ changes add: ( Change new nameSpaceSymbol: sym ) change ].				( ns comment string equalsAcrossPlatforms:  n2 comment string )					ifFalse: [ changes add: ( Change new nameSpaceSymbol: sym ) comment ]				]			ifFalse: [ changes add: ( Change new nameSpaceSymbol: sym ) removeDefinition ].		].	nameSpaces2 do:		[ :ns | 		( nameSpaces1 contains: [ :c | c comparesTo: ns ] )			ifFalse: 				[ changes add: ( Change new nameSpaceSymbol: ns absoluteName ) add.				ns comment isEmpty					ifFalse: [ changes add: ( Change new nameSpaceSymbol: ns absoluteName ) comment ]				].		].	^changes</body><body package="Store-Change Management" selector="otherChanges">otherChanges	"Answer a collection of 'other' changes. Compare bundle structures"	"The changes should move from pkg1 to pkg2"	pkg1 isBundle		ifFalse: [ ^#() ].	^pkg1 structure = pkg2 structure		ifTrue: [ #() ]		ifFalse: [ BundleModel structureMark ]." nice thought, but not what we need right now		ifFalse: [ Array with: ( BundleStructureChange new component: pkg1 ) ]."</body><body package="Store-Change Management" selector="propertyChanges">propertyChanges	"Answer a collection of 'other' changes. Compare properties."	"The changes should move from pkg1 to pkg2"	| changes props1 props2 |	changes := Set new.	props1 := pkg1 propertiesForFileOut.	props2 := pkg2 propertiesForFileOut.	props1 associationsDo:		[ :assoc |		( props2 includesKey: assoc key )			ifTrue: 				[ ( assoc value = ( props2 at: assoc key ) )					ifFalse: [ changes add: assoc key ]				]			ifFalse: [ changes add: assoc key ].		].	props2 associationsDo:		[ :assoc |		( props1 includesKey: assoc key )			ifTrue: 				[ ( assoc value = ( props1 at: assoc key ) )					ifFalse: [ changes add: assoc key ]				]			ifFalse: [ changes add: assoc key ].		].	^changes asOrderedCollection.</body><body package="Store-Change Management" selector="subdefChanges">subdefChanges	"Answer a collection of subdef changes."	"The changes should move from pkg1 to pkg2"	| changes |	changes := OrderedCollection new.	methods1 do:		[ :meth |  | chg |		chg := Change new classSymbol: meth className; selector: meth selector.		( methods2 includes: meth )			ifTrue: [ chg change ]			ifFalse: [ chg remove ].		changes add: chg.		].	methods2 do:		[ :meth |  | chg |		chg := Change new classSymbol: meth className; selector: meth selector.		( methods1 includes: meth )			ifTrue: [ chg change ]			ifFalse: [ chg add ].		changes add: chg.		].	data1 do:		[ :data |  | chg |		chg := Change new.		data isInClass			ifTrue: [ chg classSymbol: data ownerName asSymbol ]			ifFalse: [ chg nameSpaceSymbol: data ownerName asSymbol ].		chg dataKey: data dataKey.		( data2 includes: data )			ifTrue: [ chg change ]			ifFalse: [ chg remove ].		changes add: chg.		].	data2 do:		[ :data |  | chg |		chg := Change new.		data isInClass			ifTrue: [ chg classSymbol: data ownerName asSymbol ]			ifFalse: [ chg nameSpaceSymbol: data ownerName asSymbol ].		chg dataKey: data dataKey.		( data1 includes: data )			ifTrue: [ chg change ]			ifFalse: [ chg add ].		changes add: chg.		].	^changes</body></methods><methods><class-id>Store.PackageDifferences</class-id> <category>accessing-merge tool</category><body package="Store-Change Management" selector="basicModifications">basicModifications	"Answer a collection of tags. This collection includes all modifications but does not recurse bundles."	^pkg1 isPackage		ifTrue: [ self modifications ]		ifFalse: [ self componentModifications ].</body><body package="Store-Change Management" selector="componentModifications">componentModifications	"Answer a collection of tags. Includes those that apply to the component itself.	For now, properties and bundle structure."	| mods |	mods := List new.	self modifiedProperties do:		[ :each | mods add: ( Modification tag: ( PropertyTag package: pkg1 property: each ) 									package: pkg1 record: pkg1 ) 		].	self modifiedStructures do:		[ :each | mods add: ( Modification tag: ( BundleStructureTag bundle: each ) 									package: pkg1 record: pkg1 )		].	^mods</body><body package="Store-Change Management" selector="modifications">modifications	"Answer a collection of tags. This collection 	includes all modifications."	| mods |	mods := self modificationsByClass: methods1.	mods addAll: ( self modificationsByOwner: data1 ).	self methodsToRemove do: 		[ :each | mods add: ( Modification tag: each asTag package: pkg1 record: nil ) ].	self dataToRemove do: 		[ :each | mods add: ( Modification tag: each asTag package: pkg1 record: nil ) ].	self modifiedClassDefinitions do: 		[ :each | mods add: ( Modification tag: each asTag package: pkg1 record: each ) ].	self modifiedClassComment do: 		[ :each | mods add: ( Modification tag: each asCommentTag package: pkg1 record: each ) ].	self modifiedNameSpaceDefinitions do: 		[ :each | mods add: (Modification 	tag: each asTag package: pkg1 record: each ) ].	self modifiedNameSpaceComment do: 		[ :each | mods add: ( Modification tag: each asCommentTag package: pkg1 record: each ) ].	self classesToRemove do: 		[ :each | mods add: ( Modification tag: each asTag package: pkg1 record: nil ) ].	self nameSpacesToRemove do:		[ :each | mods add: ( Modification tag: each asTag package: pkg1 record: nil ) ].	mods addAll: self componentModifications.	^mods</body><body package="Store-Change Management" selector="modificationsByClass:">modificationsByClass: subdef1Collection 	"Answer a collection of Modifications organized by class."	| modified mods |	modified := Dictionary new.	subdef1Collection do: 		[:each |  | byClass |		byClass := modified at: each className 			ifAbsent: [modified at: each className put: OrderedCollection new].		byClass add: each		].	mods := List new.	modified keysAndValuesDo: 		[:className :defs | 		defs do: 			[ :mt | mods add: (Modification					tag: mt asTag					package: pkg1					record: mt)			]		].	^mods</body><body package="Store-Change Management" selector="modificationsByOwner:">modificationsByOwner: subdef1Collection 	"Answer a collection of TT_Modifications organized by owning namespace/class."	| modified mods |	modified := Dictionary new.	subdef1Collection do: 		[:each |  | byOwner |		byOwner := modified at: each environmentString 			ifAbsent: [modified at: each environmentString put: OrderedCollection new].		byOwner add: each		].	mods := List new.	modified keysAndValuesDo: 		[ :nsName :defs | 		defs do: 			[ :mt | mods add: (Modification					tag: mt asTag					package: pkg1					record: mt)			]		].	^mods</body><body package="Store-Change Management" selector="modifiedClassComment">modifiedClassComment	"Answer a collection of classes that have modified comment."	|coll class2|	coll := List new.	classes1 do: 		[:each | 		class2 := classes2 			detect: [ :cl2 | cl2 name = each name ] ifNone: [ nil ].		( class2 isNil or: [ each comment ~= class2 comment ] )			ifTrue: [coll add: each]].	^coll</body><body package="Store-Change Management" selector="modifiedClassDefinitions">modifiedClassDefinitions	"Answer a collection of classes that have modified definition."	| coll class2 |	coll := List new.	classes1 do: 		[ :each | 		class2 := classes2 			detect: [:cl2 | cl2 name = each name ] ifNone: [ nil ].		(class2 isNil or: [ each definition ~= class2 definition ] )				ifTrue: [ coll add: each ]		]." we don't do metaclasses no more ....	meta1		do: 			[:each | 			class2 := meta2 detect: [:cl2 | cl2 name = each name]						ifNone: [nil].			(class2 isNil or: [each definition ~= class2 definition])				ifTrue: [coll add: each]]."	^coll</body><body package="Store-Change Management" selector="modifiedData">modifiedData	"Added by Philippe F. Monnet of Andersen Consulting 	New data definitions."	| modified byClass |	modified := Dictionary new.	data1 		do: 			[:each | 			byClass := modified at: each className ifAbsent: [Set new].			byClass add: each.			modified at: each className put: byClass].	^modified</body><body package="Store-Change Management" selector="modifiedMethods">modifiedMethods	"New method definitions."	| modified byClass byProtocol |	modified := Dictionary new.	methods1		do: 			[:each | 			byClass := modified at: each className ifAbsent: [Dictionary new].			byProtocol := byClass at: each protocolName ifAbsent: [Set new].			byProtocol add: each.			byClass at: each protocolName put: byProtocol.			modified at: each className put: byClass].	^modified</body><body package="Store-Change Management" selector="modifiedNameSpaceComment">modifiedNameSpaceComment	"Answer a collection of namespaces that have modified comment."	|coll namespace2|	coll := List new.	nameSpaces1 do: 		[:each | 		namespace2 := nameSpaces2 			detect: [ :ns2 | ns2 absoluteName = each absoluteName ] ifNone: [ nil ].		( namespace2 isNil or: [ each comment ~= namespace2 comment ] )			ifTrue: [coll add: each]].	^coll</body><body package="Store-Change Management" selector="modifiedNameSpaceDefinitions">modifiedNameSpaceDefinitions	"Answer a collection of namespaces that have modified definitions."	| coll namespace2 |	coll := List new.	nameSpaces1 do: 		[ :each | 		namespace2 := nameSpaces2 			detect: [ :ns2 | ns2 absoluteName = each absoluteName ] ifNone: [ nil ].		( namespace2 isNil or: [ each definition ~= namespace2 definition ] )				ifTrue: [ coll add: each ]		].	^coll</body><body package="Store-Change Management" selector="modifiedProperties">modifiedProperties	"Answer a collection of property symbols that have been modified."	| coll  |	coll := Set new.	pkg1 propertiesForSave keys asOrderedCollection, 		pkg2 propertiesForSave keys asOrderedCollection do:		[ :prop |		( ( pkg1 propertyAt: prop ifAbsent: nil ) = ( pkg2 propertyAt: prop ifAbsent: nil ) )			ifFalse: [ coll add: prop ].		].	^coll asOrderedCollection asList</body><body package="Store-Change Management" selector="modifiedStructures">modifiedStructures	"Answer a collection of bundles whose structure has changed."	| list |	list := OrderedCollection new.	pkg1 isBundle		ifFalse: [ ^list ].	pkg1 structure = pkg2 structure		ifFalse: [ list add: pkg1 ].	^list</body></methods><methods><class-id>Store.PackageDifferences class</class-id> <category>instance creation</category><body package="Store-Change Management" selector="with:with:">with: pkg1 with: pkg2	^(self new) pkgSide: 1 put: pkg1; pkgSide: 2 put: pkg2; computeDiffs; yourself</body></methods><methods><class-id>Store.LoadAnalyzer</class-id> <category>initialize-release</category><body package="Store-Database" selector="initialize">initialize	classes := IdentitySet new.	nameSpaces := IdentitySet new.	methodDict := IdentityDictionary new.	classesWithoutSuper := IdentitySet new.	classesWithNoEnvironment := IdentitySet new.	overrides := OrderedCollection new.	nameSpacesWithNoEnvironment := IdentitySet new.	wholePackage := true.	classesAreAlien := false.   "classesAreAlien is only true for bin load- why i don't know"</body></methods><methods><class-id>Store.LoadAnalyzer</class-id> <category>load preparation</category><body package="Store-Database" selector="removeClasses">removeClasses	classes do: [:cls | cls removeFromSystem]</body></methods><methods><class-id>Store.LoadAnalyzer</class-id> <category>dialog</category><body package="Store-Database" selector="classEnvironmentProblemWarning:">classEnvironmentProblemWarning: warnStream 	classesWithNoEnvironment isEmpty ifTrue: [^self].	warnStream 		nextPutAll: 'Warning: Package "'; nextPutAll: toPackage name; nextPutAll: '" cannot be loaded.'; cr; cr;		nextPutAll: 'The following classes cannot be loaded because their environment';		nextPutAll: ' is not in the image nor in the package being loaded:  '; 		cr.	classesWithNoEnvironment do: 		[:cls | 		warnStream 			nextPutAll: '    ';			nextPutAll: cls name;			nextPutAll: ' (environment path: '; 			nextPutAll: cls environmentString;			nextPutAll: ')';			cr].	warnStream cr.</body><body package="Store-Database" selector="classWarning:">classWarning: warnStream 	classes isEmpty ifTrue: [ ^self  ].	classes	do: 		[:cls | | pkg |		pkg := Registry containingPackageForClass: cls.		warnStream 			nextPutAll: '    ';			nextPutAll: cls name.		pkg isNil			ifTrue: [ warnStream nextPutAll: ' (already loaded but not packaged)' ]			ifFalse: 				[ warnStream 					nextPutAll: ' (defined in package "'; 					nextPutAll: pkg name;					nextPutAll: '")'				].			warnStream cr		].	warnStream cr.</body><body package="Store-Database" selector="dataWarning:">dataWarning: warnStream 	"Write to the warnStream a message describing which data overlap."	| writeHeader |	writeHeader := true.	dataDict keysAndValuesDo: 		[ :ns :meths | 		( classesAreAlien and: [nameSpaces includes: ns ] )			ifFalse: 				[| pkgDict unpkg |				writeHeader					ifTrue: 						[warnStream nextPutAll: 'Affected Data'; cr; nextPutAll: '-------------'; cr.						writeHeader := false].				pkgDict := IdentityDictionary new.				unpkg := OrderedCollection new.				meths					do: 						[:dataKey | 						| pkg keys |						pkg := Registry containingPackageForDataKey: dataKey nameSpace: ns.						keys := pkg isNil									ifTrue: [unpkg]									ifFalse: [pkgDict at: pkg ifAbsent: [pkgDict at: pkg put: OrderedCollection new]].						keys add: dataKey].				warnStream nextPutAll: '    data from class '; nextPutAll: ns printString; nextPutAll: ':'; cr.				pkgDict keysAndValuesDo: [:pkg :keys |					keys						do: 							[:aKey | 							warnStream nextPutAll: '        '; nextPutAll: aKey.							warnStream nextPutAll: ' (defined in package "'; nextPutAll: pkg name; nextPutAll: '")'.							warnStream cr]].				unpkg					do: 						[:aKey | 						warnStream nextPutAll: '        '; nextPutAll: aKey.						warnStream nextPutAll: ' (already loaded but not packaged)'.						warnStream cr]]].	writeHeader ifFalse: [warnStream cr]</body><body package="Store-Database" selector="methodWarning:">methodWarning: warnStream 	"Write to the warnStream a message describing which methods overlap."	| writeHeader |	writeHeader := true.	methodDict keysAndValuesDo: [:cls :meths | (classesAreAlien and: [classes includes: (cls isMeta					ifTrue: [cls soleInstance]					ifFalse: [cls])])			ifFalse: 				[| pkgDict unpkg |				writeHeader					ifTrue: 						[warnStream nextPutAll: 'Affected Methods'; cr; nextPutAll: '----------------'; cr.						writeHeader := false].				pkgDict := IdentityDictionary new.				unpkg := OrderedCollection new.				meths					do: 						[:selector | 						| pkg sels |						pkg := Registry containingPackageForSelector: selector class: cls.						sels := ( pkg == nil or: [ pkg isNullPackage ] )									ifTrue: [unpkg]									ifFalse: [pkgDict at: pkg ifAbsent: [pkgDict at: pkg put: OrderedCollection new]].						sels add: selector].				warnStream nextPutAll: '    methods from class '; nextPutAll: cls printString; nextPutAll: ':'; cr.				pkgDict keysAndValuesDo: [:pkg :sels | 					sels						do: 							[:aSel | 							warnStream nextPutAll: '        '; nextPutAll: aSel.							warnStream nextPutAll: ' (defined in package "'; nextPutAll: pkg name; nextPutAll: '")'.							warnStream cr]].				unpkg					do: 						[:aSel | 						warnStream nextPutAll: '        '; nextPutAll: aSel.						warnStream nextPutAll: ' (already loaded but not packaged)'.						warnStream cr]]].	methodDict isEmpty ifFalse: [warnStream cr]</body><body package="Store-Database" selector="nameSpaceEnvironmentProblemWarning:">nameSpaceEnvironmentProblemWarning: warnStream 	nameSpacesWithNoEnvironment isEmpty ifTrue: [^self].	warnStream 		nextPutAll: 'Warning: Package "'; nextPutAll: toPackage name; nextPutAll: '" cannot be loaded.'; cr; cr;		nextPutAll: 'The following namespaces cannot be loaded because their environment';		nextPutAll: ' is not in the image nor in the package being loaded:  '; 		cr.	nameSpacesWithNoEnvironment do: 		[:ns | 		warnStream 			nextPutAll: '    ';			nextPutAll: ns name;			nextPutAll: ' (environment of '; 			nextPutAll: ns environmentString;			nextPutAll: ')';			cr].	warnStream cr.</body><body package="Store-Database" selector="nameSpaceWarning:">nameSpaceWarning: warnStream 	nameSpaces isEmpty 		ifTrue: [ ^self ].	nameSpaces	do: 		[ :ns | | pkg |		pkg := Registry containingPackageForNameSpace: ns.		warnStream 			nextPutAll: '    ';			nextPutAll: ns fullName.		pkg == nil			ifTrue: [ warnStream nextPutAll: ' (already loaded but not packaged)' ]			ifFalse: 				[ warnStream 					nextPutAll: ' (defined in package "'; 					nextPutAll: pkg name;					nextPutAll: '")'				].			warnStream cr		].	warnStream cr.</body><body package="Store-Database" selector="overlapWarning:">overlapWarning: warnStream	warnStream nextPutAll: 'Warning: Overlapping packages'; cr;		nextPutAll: '-----------------------'; cr.	warnStream		nextPutAll: '"';		nextPutAll: toPackage name;		nextPutAll: '", the package to be loaded, contains method and/or class definitions ';		nextPutAll: 'which already exist in the image, but in packages other than "';		nextPutAll: toPackage name;		nextPutAll: '".'; cr; cr.	classesAreAlien 		ifTrue: [warnStream 					nextPutAll: 'Proceeding will delete the overlapping classes along with their methods ';					nextPutAll: 'and load the classes and methods from package "';					nextPutAll: toPackage name;					nextPutAll: '".  ']		ifFalse: [warnStream 					nextPutAll: 'Proceeding will remove the current definitions and load the versions of those definitions from the package being loaded.  '].	warnStream		nextPutAll: 'The packages currently containing the definitions will be modified and the newly loaded definitions will be in package "';		nextPutAll: toPackage name;		nextPutAll: '".'; cr; 		cr.</body><body package="Store-Database" selector="stopDialog">stopDialog	| warnStream theText dialog |	warnStream := WriteStream on: (String new: 300).	self superclassProblemWarning: warnStream.	self classEnvironmentProblemWarning: warnStream.	self nameSpaceEnvironmentProblemWarning: warnStream.	theText := warnStream contents asValue.	dialog := SimpleDialog new.	dialog builder aspectAt: #text put: theText.	^dialog openFrom: (UISpecification from: self class stopSpec)</body><body package="Store-Database" selector="superclassProblemWarning:">superclassProblemWarning: warnStream 	classesWithoutSuper isEmpty ifTrue: [^self].	warnStream 		nextPutAll: 'Warning: Package "'; nextPutAll: toPackage name; nextPutAll: '" cannot be loaded.'; cr; cr;		nextPutAll: 'The following classes cannot be loaded because their superclasses';		nextPutAll: ' are neither in the image nor in the package being loaded:  '; 		cr.	classesWithoutSuper		do: 			[:cls | 			warnStream 				nextPutAll: '    ';				nextPutAll: cls name;				nextPutAll: ' (subclass of '; 				nextPutAll: cls superclass;				nextPutAll: ')';				cr].	warnStream cr.</body><body package="Store-Database" selector="warnDialog">warnDialog	| warnStream theText dialog |	warnStream := WriteStream on: (String new: 300).	self overlapWarning: warnStream.	self nameSpaceWarning: warnStream.	self classWarning: warnStream.	self methodWarning: warnStream.	self dataWarning: warnStream.	theText := warnStream contents asValue.	dialog := SimpleDialog new.	dialog builder aspectAt: #text put: theText.	^dialog openFrom: (UISpecification from: self class warningSpec)</body></methods><methods><class-id>Store.LoadAnalyzer</class-id> <category>accessing</category><body package="Store-Database" selector="classes:">classes: aClassList 	"Given a list of non-meta class definitions to be loaded (in the form of classes 	not  connected to the system (alien classes) or ClassDescriptions). 	Filter this list for classes which are loaded and in a different package. 	Set 'classes' to be these loaded classes. 	Also, into classesWithoutSuper put all classes to be loaded whose 	superclass is not in the image and is not in the package to be loaded."	"Contains hack 	Contrary to the comment, this method is sometimes given a list 	of MetaClasses. In this case we check if the class side is in the 	image."	self needsMoreWork.	classes := IdentitySet new.	classesWithoutSuper := IdentitySet new.	aClassList do: 		[ :each | 		self checkClassOrNameSpace: each absoluteName asClassNameOnly asSymbol.		each isMeta			ifFalse: 				[ self checkSuperClass: each against: aClassList.				self checkEnvironment: each against: #()				]			].</body><body package="Store-Database" selector="classes:nameSpaces:">classes: aClassList nameSpaces: aNameSpaceList	"Given a list of non-meta class definitions to be loaded (in the form of classes 	not  connected to the system (alien classes) or ClassDescriptions).  And	NameSpaceDescriptions.	Filter these lists for classes/namespaces which are loaded and in a different package. 	Set 'classes' / 'namespaces' to be these loaded classes. 	Also, into classesWithoutSuper put all classes to be loaded whose 	superclass is not in the image and is not in the package to be loaded.	Into classesWithoutNameSpaces, namespaceWithoutNameSpaces-	all the classes/namespaces whose namespace is not in the image or the	package to be loaded."	"Contains hack 	Contrary to the comment, this method is sometimes given a list 	of MetaClasses. In this case we check if the class side is in the 	image. (??)"	self needsMoreWork. 	aClassList do: 		[ :each |		self checkClassOrNameSpace: each absoluteName asClassNameOnly asSymbol.		each isMeta			ifFalse: 				[ self checkSuperClass: each against: aClassList.				self checkEnvironment: each against: aNameSpaceList.				]		].	aNameSpaceList do:		[ : each | 			self checkClassOrNameSpace: each absoluteSymbol.		self checkEnvironment: each against: aNameSpaceList		].</body><body package="Store-Database" selector="classesAreAlien:">classesAreAlien: aBoolean	classesAreAlien := aBoolean</body><body package="Store-Database" selector="dataTT:">dataTT: aCollectionOfDBData 	"Given a list of data definitions to be loaded (in the form of 	a collection of DataElements).	Set 'dataDict' to be a dictionary mapping classes to	a collection of dataKeys which are already loaded. We already 	know they are in a different package, since this one is empty."self needsMoreWork. "ripple clone"	dataDict := IdentityDictionary new.	aCollectionOfDBData do: 		[:each | 		| dataKey ownerName |		dataKey := each dataKey.		ownerName := each environmentString.		( toPackage includesDataKey: dataKey ownerName: ownerName )			ifFalse: 				[ | owner |				owner := each owner.				owner notNil ifTrue: [self add: owner dataKey: dataKey ]				]		].</body><body package="Store-Database" selector="datumArrays:">datumArrays: aCollectionOfDatumArrays 	self needsMoreWork.  "ripple clone"</body><body package="Store-Database" selector="leafItems">leafItems	leafItems == nil		ifTrue: 			[ leafItems := withinBundle == nil				ifTrue: [ Set new ]				ifFalse: [ withinBundle leafItems collect: [ :p | p name ] ]			].	^leafItems</body><body package="Store-Database" selector="methodArrays:">methodArrays: aCollectionOfMethodArrays 	"Given a list of method definitions to be loaded (in the form of 	selector/compiledMethod/protocol triples).	Set 'methodDict' to be a dictionary mapping classes to	a collection of selectors which are already loaded. We already 	know they are in a different package, since this one is empty."	aCollectionOfMethodArrays do: 		[ :each |   | selector cName cls tcls |		selector := each at: 1.		tcls := (each at: 2) mclass.		cName := ( tcls isMeta						ifTrue: [ tcls soleInstance ]						ifFalse: [ tcls ]					) name.		cls := cName asStrictReference valueOrDo: [nil].		cls notNil			ifTrue: 				[ cls := tcls isMeta							ifTrue: [ cls class ]							ifFalse: [ cls ].				( cls includesSelector: selector )					ifTrue: 						[ | meths |						meths := methodDict at: cls ifAbsent: [ methodDict at: cls put: OrderedCollection new ].						meths add: selector						]				]		]</body><body package="Store-Database" selector="methodsTT:">methodsTT: aCollectionOfDBMethods 	"Given a list of method definitions to be loaded (in the form of 	a collection of Method).	Set 'methodDict' to be a dictionary mapping classes to	a collection of selectors which are already loaded. We already 	know they are in a different package, since this one is empty."	aCollectionOfDBMethods		do: 			[:each | 			| selector cName |			selector := each selector.			cName := each className.			(toPackage				includesSelector: selector				className: cName				meta: each isMeta)				ifFalse: 					[| cls |					cls := each myClass.					cls notNil ifTrue: [self addClass: cls selector: selector ]]].</body><body package="Store-Database" selector="nameSpaces:">nameSpaces: aNameSpaceList	"Given a list of namespaces to be loaded produce a list of alien ns 	NameSpaceDescriptions.	Filter this list for namespaces which are loaded and in a different package. 	Set 'namespaces' to be these loaded namespaces. 	Also, into namespaceWithoutNameSpaces-	all the namespaces whose namespace is not in the image or the	package to be loaded."	aNameSpaceList do: 		[ : each | 	self checkEnvironment: each against: aNameSpaceList ].</body><body package="Store-Database" selector="toPackage:">toPackage: aPackageModel	toPackage := aPackageModel</body><body package="Store-Database" selector="wholePackage:">wholePackage: aBoolean	wholePackage := aBoolean</body><body package="Store-Database" selector="withinBundle:">withinBundle: aBundle	withinBundle := aBundle</body></methods><methods><class-id>Store.LoadAnalyzer</class-id> <category>public</category><body package="Store-Database" selector="loadCanProceed">loadCanProceed	^self loadCanProceed: false.</body><body package="Store-Database" selector="loadCanProceed:">loadCanProceed: queryBoolean	( classesWithoutSuper isEmpty ) &amp; ( classesWithNoEnvironment isEmpty ) &amp;				( nameSpacesWithNoEnvironment isEmpty )		ifFalse: 	[ self stopDialog.  ^false ].	^self checkOverrides: queryBoolean</body><body package="Store-Database" selector="loadWarnings">loadWarnings	"Answer true if user appoved load depite warnings."	"obsoleted  by overrides"	| result |	( ( classes isEmpty ) &amp; ( nameSpaces isEmpty )			&amp; ( methodDict isEmpty ) &amp; ( dataDict isEmpty ) )		ifTrue: [ ^true ].	result := self warnDialog.	( result &amp; classesAreAlien )   "classesAreAlien is only true for bin load- why i don't know"		ifTrue: [ self removeClasses ]. 	^result</body></methods><methods><class-id>Store.LoadAnalyzer</class-id> <category>private</category><body package="Store-Database" selector="add:dataKey:">add: owner dataKey: dataKey 	( owner includesDataKey: dataKey )		ifTrue: 			[ | data |			data := dataDict at: owner ifAbsent: [ dataDict at: owner put: OrderedCollection new ].			data add: dataKey			]</body><body package="Store-Database" selector="addClass:selector:">addClass: cls selector: selector 	 | meths pkg |	( cls includesSelector: selector )		ifTrue: 			[ pkg := Registry containingPackageForSelector: selector class: cls.			( ( pkg == nil ) or: [ self leafItems includes: pkg name ] )				ifFalse:					[ meths := methodDict at: cls ifAbsent: 						[ methodDict at: cls put: OrderedCollection new ].					meths add: selector					].			]</body><body package="Store-Database" selector="checkClassOrNameSpace:">checkClassOrNameSpace: aName		"Add classes to classes (and namespaces namespaces ) that: 		1) are not contained in toPackage and 2) are in the image"	( toPackage includesDefinitionOf: aName )		ifFalse: 			[ | obj pkg |			pkg := Registry containingPackageForSymbol: aName asSymbol.			pkg == nil				ifFalse: [ ( self leafItems includes: pkg name ) ifTrue: [ ^self ] ].			obj := aName asStrictReference valueOrDo: [ nil ].			obj == nil 				ifFalse: 	[ obj isForNameSpace ifTrue: [ nameSpaces add: obj ] ifFalse: [ classes add: obj ] ]			].</body><body package="Store-Database" selector="checkEnvironment:against:">checkEnvironment: model against: aNameSpaceList		"Check the superclass of the class. If it exists, or is in the image, ok.		Otherwise put the class into classesWithoutSuper."	| envName |	envName := model environmentString.	( envName == nil or: [ envName isEmpty ] )		ifTrue: [ ^self ].	( toPackage includesNameSpaceNamed: envName )		ifTrue: [ ^self ].	( ( envName asStrictReference isDefined ) or: 		[ aNameSpaceList contains: [ :ns | ns absoluteName = envName ] ]	) ifFalse: 		[ model isForNameSpace			ifTrue: [  nameSpacesWithNoEnvironment add: model ]			ifFalse: [ classesWithNoEnvironment add: model ].		].</body><body package="Store-Database" selector="checkSuperClass:against:">checkSuperClass: classModel against: aClassList		"Check the superclass of the class. If it exists, or is in the image, ok.		Otherwise put the class into classesWithoutSuper."	| superName |	superName := classModel superclass.	( superName = 'nil' or: 			[ ( superName asStrictReference isDefined ) or: 				[ aClassList contains: [ : clsRecord | clsRecord absoluteName = superName ] ]			] )  ifFalse: [ classesWithoutSuper add: classModel ].</body></methods><methods><class-id>Store.LoadAnalyzer</class-id> <category>overrides</category><body package="Store-Database" selector="checkOverrides:">checkOverrides: queryBoolean	"Answer true if ok to continue, or false if the user canceled.	If queryBoolean is true,  the user will be queried, otherwise, all will be overriden.""	( self validateClassAndNameSpaceOverlaps: queryBoolean )		ifFalse: [ ^false ].	( self validateMethodOverlaps: queryBoolean )		ifFalse: [ ^false ].	( self validateStaticOverlaps: queryBoolean )		ifFalse: [ ^false ].	self registerOverrides."	^true</body><body package="Store-Database" selector="registerOverrides">registerOverrides	"Load is continuing.... register the packages overrides."	overrides do:		[ :assoc | Override installOverride: assoc value for: assoc key ].</body><body package="Store-Database" selector="validateClassAndNameSpaceOverlaps:">validateClassAndNameSpaceOverlaps: queryBoolean	"Answer true if user validates class redefinitions."	| coll pname |	( coll := nameSpaces copy ) addAll: classes.     	coll do: 		[ :obj | |  action |		action := queryBoolean			ifTrue: 				[ | pkg message |				pkg := Registry containingPackageForSymbol: obj absoluteSymbol.				pname := pkg == nil ifTrue: [ Registry nullPackageName ] ifFalse: [ pkg name ].				message := '&lt;1s&gt; is already defined in &lt;2s&gt;'					expandMacrosWith: obj fullName with: pname.				Override overrideReplaceOrCancel: message 				]			ifFalse: 				[ pname = Registry nullPackageName 							ifTrue: [ #replace ] ifFalse: [ #override ].				].		action == #cancel  			ifTrue: [ ^false ].		action == #override			ifTrue: [ overrides add: ( obj -&gt; ( Override forClassOrNameSpace: obj ) ) ]		].	^true.</body><body package="Store-Database" selector="validateMethodOverlaps:">validateMethodOverlaps: queryBoolean	"Answer true if user validates method redefinitions."	| action |	methodDict keysAndValuesDo: 		[ :cls :meths | 		( classesAreAlien and: [classes includes: ( cls instanceBehavior ) ] )			ifFalse: 				[ | pkgDict pname |				pkgDict := IdentityDictionary new.				meths do: 					[ :selector | 	| pkg sels |					pkg := Registry containingPackageForSelector: selector class: cls.					pname := pkg == nil ifTrue: [ Registry nullPackageName ] ifFalse: [ pkg name ].					sels := pkgDict at: pname ifAbsent: [ pkgDict at: pname put: OrderedCollection new ].					sels add: selector					].				pkgDict keysAndValuesDo: 					[ :pkgName :sels | 					sels do: 						[:aSel | 						action := queryBoolean							ifTrue: 								[ | message |								message := '&lt;1s&gt;&gt;&gt;&lt;2s&gt; is already defined in &lt;3s&gt;'									expandMacrosWith: cls fullName with: aSel with: pkgName.								Override overrideReplaceOrCancel: message 								]							ifFalse: 								[ pkgName = Registry nullPackageName 										ifTrue: [ #replace ] ifFalse: [ #override ].								].					action == #cancel  						ifTrue: [ ^false ].					action == #override						ifTrue: [ overrides add: ( aSel -&gt; ( Override forSelector: aSel class: cls ) ) ].						 ]					].			]		].	^true</body><body package="Store-Database" selector="validateStaticOverlaps:">validateStaticOverlaps: queryBoolean	"Answer true if user validates method redefinitions."	| action |	dataDict keysAndValuesDo: 		[ :owner :keys |  | pkgDict pname |		pkgDict := IdentityDictionary new.		keys do: 			[ :key | 	| pkg coll |			pkg := Registry containingPackageForDataKey: key symbol: owner absoluteSymbol.			pname := pkg == nil ifTrue: [ Registry nullPackageName ] ifFalse: [ pkg name ].			coll := pkgDict at: pname ifAbsent: [ pkgDict at: pname put: OrderedCollection new ].			coll add: key			].		pkgDict keysAndValuesDo: 			[ :pkgName :coll | 			coll do: 				[:key | 				action := queryBoolean					ifTrue: 						[ | message |						message := '&lt;1s&gt;.&lt;2s&gt; is already defined in &lt;3s&gt;'							expandMacrosWith: owner fullName with: key with: pkgName.						Override overrideReplaceOrCancel: message 						]					ifFalse: 						[ pkgName = Registry nullPackageName 								ifTrue: [ #replace ] ifFalse: [ #override ].						].			action == #cancel  				ifTrue: [ ^false ].				action == #override			ifTrue: [ overrides add: ( key -&gt; ( Override forDataKey: key in: owner ) ) ].				 ]			].		].	^true</body></methods><methods><class-id>Store.LoadAnalyzer class</class-id> <category>analysis</category><body package="Store-Database" selector="canLoadClass:from:">canLoadClass: aClassRecord from: aPackage	| la |	la := self new.	la 	toPackage: aPackage; 		classesAreAlien: false;		wholePackage: false;		classes: ( Array with: aClassRecord );		nameSpaces: Array new;		methodsTT: Array new;		dataTT: Array new.	^la loadCanProceed</body><body package="Store-Database" selector="canLoadClass:methods:data:from:">canLoadClass: aClass methods: aTTMethodList data: aTTDatumList from: aPackage	| la |	la := self new.	la 	toPackage: aPackage; 		classesAreAlien: false;		wholePackage: false;		classes: (aClass isNil ifTrue: [Array new] ifFalse: [Array with: aClass]);		methodsTT: aTTMethodList;		dataTT: aTTDatumList.	^la loadCanProceed</body><body package="Store-Database" selector="canLoadDatum:from:">canLoadDatum: aTTDatum from: aPackage	| la |	la := self new.	la 	toPackage: aPackage; 		classesAreAlien: false;		wholePackage: false;		classes: (Array new);		methodsTT: (Array new);		dataTT: (Array with: aTTDatum).	^la loadCanProceed</body><body package="Store-Database" selector="canLoadMethod:from:">canLoadMethod: aTTMethod from: aPackage	| la |	la := self new.	la 	toPackage: aPackage; 		classesAreAlien: false;		wholePackage: false;		classes: (Array new);		methodsTT: (Array with: aTTMethod);		dataTT: (Array new).	^la loadCanProceed</body><body package="Store-Database" selector="canLoadNameSpace:data:from:">canLoadNameSpace: aNameSpace data: aTTDatumList from: aPackage	| la |	la := self new.	la 	toPackage: aPackage; 		classesAreAlien: false;		wholePackage: false;		nameSpaces: (aNameSpace isNil ifTrue: [Array new] ifFalse: [Array with: aNameSpace]);		dataTT: aTTDatumList.	^la loadCanProceed</body><body package="Store-Database" selector="canLoadNameSpace:from:">canLoadNameSpace: aNameSpaceRecord from: aPackage	| la |	la := self new.	la 	toPackage: aPackage; 		classesAreAlien: false;		wholePackage: false;		classes: Array new;		nameSpaces: ( Array with: aNameSpaceRecord );		methodsTT: Array new;		dataTT: Array new.	^la loadCanProceed</body><body package="Store-Database" selector="checkUninstalledForPackage:classes:methods:data:">checkUninstalledForPackage: aPackage classes: uninstalledClasses methods: uninstalledMethods data: uninstalledData	"Determine why the uninstalled can't be installed and display a message box informing the user."	| la |	la := self new.	la 	toPackage: aPackage; 		classesAreAlien: false;		wholePackage: false;		classes: uninstalledClasses;		nameSpaces: Array new;		methodsTT: uninstalledMethods;		dataTT: uninstalledData.	^la loadCanProceed</body><body package="Store-Database" selector="preBinLoadOverlapCheckOf:classes:nameSpaces:methods:">preBinLoadOverlapCheckOf: aPackage classes: aClassList nameSpaces: aTTNameSpaceList methods: aMethodArrayList	| la |	la := self new.	la 	toPackage: aPackage; 		classesAreAlien: true;		classes:  aClassList nameSpaces: aTTNameSpaceList; 		methodArrays: aMethodArrayList.	^la loadCanProceed</body><body package="Store-Database" selector="preDBLoadOverlapCheckOf:classes:nameSpaces:methods:data:">preDBLoadOverlapCheckOf: aPackage classes: aTTClassList nameSpaces: aTTNameSpaceList methods: aTTMethodList data: aTTDatumList	^self new		toPackage: aPackage; 		classesAreAlien: false;		classes:  aTTClassList nameSpaces: aTTNameSpaceList; 		methodsTT: aTTMethodList;		dataTT: aTTDatumList;		loadCanProceed</body><body package="Store-Database" selector="preDBLoadOverlapCheckOf:within:classes:nameSpaces:methods:data:">preDBLoadOverlapCheckOf: aPackage within: aBundle classes: aTTClassList nameSpaces: aTTNameSpaceList methods: aTTMethodList data: aTTDatumList	^self new	 	toPackage: aPackage; 		withinBundle: aBundle;		classesAreAlien: false;		classes:  aTTClassList nameSpaces: aTTNameSpaceList; 		methodsTT: aTTMethodList;		dataTT: aTTDatumList;		loadCanProceed</body></methods><methods><class-id>Store.LoadAnalyzer class</class-id> <category>instance creation</category><body package="Store-Database" selector="new">new	^super new initialize</body></methods><methods><class-id>Store.PackageProtocolBrowserHelper</class-id> <category>list accessing</category><body package="Store-UI-Browser" selector="updateListFull">updateListFull	self setNewList: 		( self sort: ( self browser generateProtocolsFor: self selectionId ) )</body></methods><methods><class-id>Store.PackageProtocolBrowserHelper</class-id> <category>selections</category><body package="Store-UI-Browser" selector="selectedClassOrNameSpace">selectedClassOrNameSpace	| env |	self isPackageLoaded ifFalse: [ ^nil ].	"selected class/namespace not in image."	^env := ( env := self selected: #model ) == nil		ifTrue: [ ^nil ]		ifFalse: 			[ env isDataModel 				ifTrue: [ env actual ]				ifFalse: [ env ]			].</body><body package="Store-UI-Browser" selector="selectedModel">selectedModel	^self selected: #model </body><body package="Store-UI-Browser" selector="targetClass">targetClass	| env |	^( env := self selectedModel ) == nil		ifTrue: [ nil ]		ifFalse: 			[ env isForNameSpace ifTrue: [ ^nil ].			env isDataModel 				ifTrue: [ env actual ]				ifFalse: [ env ]			]</body><body package="Store-UI-Browser" selector="targetClassOrNameSpace">targetClassOrNameSpace	| env |	env := ( env := self selectedClassOrNameSpace ) == nil		ifTrue: [ ^nil ]		ifFalse: 			[ env isDataModel 				ifTrue: [ env actual ]				ifFalse: [ env ]			].	^self isData		ifTrue: [ env asNameSpace ]		ifFalse: [ env ]</body></methods><methods><class-id>Store.PackageProtocolBrowserHelper</class-id> <category>templates</category><body package="Store-UI-Browser" selector="templateBinding:category:">templateBinding: nameSpace category: category	^'&lt;1p&gt; defineSharedVariable: #NameOfBinding&lt;n&gt;&lt;t&gt;private: false&lt;n&gt;&lt;t&gt;constant: false&lt;n&gt;&lt;t&gt;category: &lt;2p&gt;&lt;n&gt;&lt;t&gt;initializer: nil'		expandMacrosWith: nameSpace		with: (category == nil ifTrue: [nil] ifFalse: [category asString])</body></methods><methods><class-id>Store.PackageProtocolBrowserHelper</class-id> <category>text processing</category><body package="Store-UI-Browser" selector="explainerClass">explainerClass	^self targetClassOrNameSpace</body><body package="Store-UI-Browser" selector="text">text	^self selection == nil		ifTrue: 			[ self selections isEmpty				ifTrue: [ nil ]				ifFalse: [ Text new ]			]		ifFalse: [ self textForMode ]</body><body package="Store-UI-Browser" selector="textForMode">textForMode		"Answer the appropiate template for the current mode."	| target |	target := self targetClassOrNameSpace.	target == nil ifTrue: [ ^Text new ].	^( target isForClass		ifTrue: [ target sourceCodeTemplate ]		ifFalse: [ self templateBinding: target category: self selection ]	)  asText</body></methods><methods><class-id>Store.PackageProtocolBrowserHelper</class-id> <category>actions</category><body package="Store-UI-Browser" selector="fileOut">fileOut	"Reimplement to deal with file-out of protocols in the database."	| item fileName suggestion fileManager items |	self isPackageLoaded ifTrue: [ ^super fileOut ]. "generic fileout works for in-image."		item := self selectedModel.	suggestion := self selection isNil					ifTrue: [ '-protocols.st' ]					ifFalse: [ '-', self selection, '.st' ].	fileName := item name, suggestion.	fileName := Dialog					requestNewFileName: (#FileOutAs &lt;&lt; #dialogs &gt;&gt; 'File out as')					default: ( Filename filterFilename: fileName ). 	fileName isEmpty ifTrue: [ ^nil ].	items := OrderedCollection new.	"We do not need to worry about multiple selections over multiple classes,	 because that is impossible (you can only select on class at a time)."	self selections do: 		[ :symbol |		items addAll: 			( ( item isForNameSpace or: [ self isData ] )					ifTrue: [ self package dataForNamed: item absoluteName andProtocol: symbol ] 					ifFalse: [ self package								methodsForClassNamed: item absoluteName 								andProtocol: symbol								meta: item isMeta 							]			)		].	fileManager := SourceCodeStream write: fileName encoding: self fileEncoding.	[ fileManager timeStamp.	 fileManager deferInitializations.	 items do: [ :i | i fileOutOn: fileManager ].	 fileManager finishInitializations	] ensure: [ fileManager close ]</body><body package="Store-UI-Browser" selector="findMethod">findMethod	"Show a menu of the methods implemented by this class.  	Select the chosen one."	| coll chosen prompt target |	target := self selectedModel.	( self isData or: [ target isForNameSpace  ] )		ifTrue: 			[ coll := self isFilteredByPackage 				ifTrue: [ ( self package dataForNamed: target absoluteName ) asSortedCollection: [ :x :y | x name &lt; y name ] ]				ifFalse: [ target value datumDescriptors ].			prompt := 'Find which shared variable?'			]		ifFalse: 			[ coll := self isFilteredByPackage  				ifTrue: [ ( self package methodsForClassNamed: target absoluteName meta: self isMeta ) asSortedCollection: [ :x :y | x name &lt; y name ] ]				ifFalse: [ target value methodDescriptors ].			prompt := 'Find which method?'			].	coll size == 0 ifTrue: [ ^self ].	chosen := Dialog choose: prompt fromList: coll values: coll lines: 20 					cancel: [ nil ] for: self interfaceWindow.	chosen == nil ifTrue: [ ^self ].	module select: chosen protocolName asSymbol whenFinished: 		[ module nextModule select: chosen whenFinished: [ module updateList ] ].</body><body package="Store-UI-Browser" selector="remove">remove	^self package isLoaded 		ifTrue: [ super remove ]		ifFalse: [ self warnPackageNotLoaded. false ].</body><body package="Store-UI-Browser" selector="rename">rename	| aString newProtocol owner |	self package isLoaded 		ifFalse: [ self warnPackageNotLoaded. ^false ].	self changeRequest ifFalse: [ ^self ].	aString := self prompt: 'Enter new category name' initially: self selection.	aString isEmpty ifTrue: [ ^self ].	newProtocol := aString asSymbol.	owner := self targetClassOrNameSpace.	( owner renameCategory: module selection to: newProtocol)		ifTrue:			[self logProtocolChange: ('&lt;1p&gt; organization renameCategory: &lt;2p&gt; to: &lt;3p&gt;'						expandMacrosWith: owner						with: module selection						with: newProtocol).			module select: newProtocol whenFinished: [module updateList]]</body><body package="Store-UI-Browser" selector="spawn">spawn	self spawningBrowserClass		openOnPackage: self package		owner: self selectedModel		protocols: self selections		isData: self isData</body></methods><methods><class-id>Store.PackageProtocolBrowserHelper</class-id> <category>initialization</category><body package="Store-UI-Browser" selector="postBuildWith:">postBuildWith: aBuilder		self setVisualBlocksWith: aBuilder</body></methods><methods><class-id>Store.PackageProtocolBrowserHelper</class-id> <category>visual blocks</category><body package="Store-UI-Browser" selector="textEmphasisForItem:">textEmphasisForItem: protocol 	^self emphasizer		emphasisForProtocol: protocol		for: self browser		id: self selectionId</body></methods><methods><class-id>Store.PackageProtocolBrowserHelper</class-id> <category>menus</category><body package="Store-UI-Browser" selector="actionsForMultiSelect">actionsForMultiSelect	^super actionsForMultiSelect, #( #spawn #sort #sortAlpha #sortSystem #sortPublicPrivate )</body><body package="Store-UI-Browser" selector="actionsForUnloadedPackages">actionsForUnloadedPackages	^#( fileOut #spawn #findMethod #sort #sortAlpha #sortSystem #sortPublicPrivate )</body><body package="Store-UI-Browser" selector="getListMenu:">getListMenu: forMenuBar	| menu |	menu := forMenuBar			ifTrue: [self  getStoreMenuBarMenu]			ifFalse: [self getListMenu].	menu == nil ifTrue: [menu := Menu new].	self setEnablement: menu.	^menu</body><body package="Store-UI-Browser" selector="isSortAlpha">isSortAlpha	^self class defaultSort == ( self class sortBlockFor: #alpha )</body><body package="Store-UI-Browser" selector="isSortPublicPrivate">isSortPublicPrivate	^self class defaultSort == ( self class sortBlockFor: #publicPrivate )</body><body package="Store-UI-Browser" selector="isSortSystem">isSortSystem	^self class defaultSort == ( self class sortBlockFor: #system )</body><body package="Store-UI-Browser" selector="menuHeader">menuHeader	^selectionId isInteger		ifTrue: [ self class menuHeader, selectionId printString ]		ifFalse: [ self class menuHeader ]</body><body package="Store-UI-Browser" selector="setEnablement:">setEnablement: menu	"Set the menu's items enabled/disabled state."	"Since loaded and unloaded not in the same browser we only have to disable things."	"Don't override a menu items particular enablement"	menu enablementSelector == nil		ifFalse: [ ^menu ].	super setEnablement: menu.	self isPackageLoaded ifTrue: [ ^menu ].	self menu: menu do: 		[ :item | 		( self actionsForUnloadedPackages includes: item nameKey )			ifFalse: [ item disable ]		].</body></methods><methods><class-id>Store.PackageProtocolBrowserHelper</class-id> <category>accessing</category><body package="Store-UI-Browser" selector="windowLabel">windowLabel	^module hasList		ifTrue: ['&lt;1p&gt; Browser'					expandMacrosWith: self selectedModel itemString ]		ifFalse: ['&lt;1p&gt; {&lt;2s&gt;} Package Message Category Browser'					expandMacrosWith: self selectedModel name					with: self selection]</body></methods><methods><class-id>Store.PackageProtocolBrowserHelper</class-id> <category>drag and drop</category><body package="Store-UI-Browser" selector="addClientDataTo:">addClientDataTo: anIdentityDict	self isPackageLoaded ifFalse: [ ^false ].		"don't drag from unloaded packages."	^super addClientDataTo: anIdentityDict</body><body package="Store-UI-Browser" selector="canAcceptDropFrom:">canAcceptDropFrom: aDC	^aDC key == self selectorOrStaticKey		|  ( aDC key == self storeStaticKey )</body></methods><methods><class-id>Store.PackageProtocolBrowserHelper</class-id> <category>sorting</category><body package="Store-UI-Browser" selector="sort:">sort: aList	"Sort the protocol list based on the current sort."	self sortBlock == nil		ifTrue: [ ^aList ].			"use system default sort"	aList sortWith: self sortBlock.	^aList</body><body package="Store-UI-Browser" selector="sortBlock">sortBlock	sortBlock == nil		ifTrue: [ sortBlock := self class defaultSort ].	^sortBlock</body></methods><methods><class-id>Store.PackageProtocolBrowserHelper</class-id> <category>menus accessing</category><body package="Store-UI-Browser" selector="actionsForNoSelect">actionsForNoSelect	^#( #sort #sortAlpha #sortSystem #sortPublicPrivate ) asOrderedCollection addAll:		( self selectedModel == nil			ifTrue: [ #() ]			ifFalse: [ #( #add #findMethod ) ]		); yourself</body><body package="Store-UI-Browser" selector="getListMenu">getListMenu	"Items in the list are either method protocols or static	categories. We need to be sure the label of the 'Find...' 	menu item makes sense. (So the label of that item in	the resource spec on the class side does not actually matter.)"	| menu target |	menu := super getListMenu.	target := self selectedModel.	(menu menuItemWithValue: #findMethod) label:		((self isData or: [target isNil or: [target isForNameSpace]])			ifTrue: ['Find Variable...']			ifFalse: ['Find Method...']).	^menu</body></methods><methods><class-id>Store.PackageProtocolBrowserHelper class</class-id> <category>sorting</category><body package="Store-UI-Browser" selector="alphaSort">alphaSort	^[ :a :b | a &lt; b ].</body><body package="Store-UI-Browser" selector="defaultSort">defaultSort	"Answer the default sorting block."	^SortBlock</body><body package="Store-UI-Browser" selector="publicPrivateSort">publicPrivateSort	"Don't sort for system"	"FullSystemBrowser organization categories asSortedCollection: self publicPrivateSort"	^[ :a :b | | x |	( x := a indexOfSubCollection: 'private'  startingAt: 1 ) == 			( b indexOfSubCollection: 'private'  startingAt: 1 )		ifTrue: [ a &lt; b ]		ifFalse: [ x == 0 ]	  ]</body><body package="Store-UI-Browser" selector="setSortTo:">setSortTo: aSymbol	"Answer the sortBlock for a protocol sort and set it as the default"	^SortBlock := self sortBlockFor: aSymbol.</body><body package="Store-UI-Browser" selector="sortBlockFor:">sortBlockFor: aSymbol	"Answer the sortBlock for a protocol sort"	aSymbol == #system		ifTrue: [ ^nil ].		"don't need to sort for system"	aSymbol == #alpha		ifTrue: [ ^self alphaSort ].	aSymbol == #publicPrivate		ifTrue: [ ^self publicPrivateSort ].		"To prevent some bogus argument from breaking the system, return nil."	^nil</body></methods><methods><class-id>Store.PackageProtocolBrowserHelper class</class-id> <category>class initialization</category><body package="Store-UI-Browser" selector="initialize">initialize	self setSortTo: #alpha.</body></methods><methods><class-id>Store.MergeTool</class-id> <category>initialize-release</category><body package="Store-Merge" selector="initialize">initialize	mergeData := MergeData new.	modSetList := SelectionInList new.	pkgList := MultiSelectionInList new.	bundles := OrderedCollection new.	displayText := Text new asValue.	conflictText := Text new asValue.	textMode := #external.	show := #all.	conflictType := #none.	self modSetList selectionIndexHolder onChangeSend: #modSetSelectionChanged to: self.	self pkgList selectionIndexHolder onChangeSend: #packageSelectionChanged to: self.	self displayText onChangeSend: #textChanged to: self.</body><body package="Store-Merge" selector="mergeIntegrationReadyOfPackageNames:">mergeIntegrationReadyOfPackageNames: aCollectionOfPackageNames	self doMergeBy: [mergeData mergeIntegrationReadyOfPackageNames: aCollectionOfPackageNames]</body><body package="Store-Merge" selector="mergePundleVersions:">mergePundleVersions: aCollectionOfPundleVersions 	| pkgs msg |	pkgs := self collectPackageVersionsFrom: aCollectionOfPundleVersions.	( msg := self verifyAgainstImage: pkgs ) == nil		ifFalse: 			[ Dialog warn: msg. 			self reset. 			^self 			].	self doMergeBy: [ mergeData mergePackageVersions: pkgs ]</body><body package="Store-Merge" selector="reset">reset	mergeData := MergeData new.	modSetList list: List new.	pkgList list: List new.	self updateModSets</body></methods><methods><class-id>Store.MergeTool</class-id> <category>menus</category><body package="Store-Merge" selector="compareMenu">compareMenu	| items values groupSizes lastSize |	items := OrderedCollection new.	values := OrderedCollection new.	groupSizes := OrderedCollection new.	lastSize := items size.	items add: ((MenuItem labeled: 'Compare with Resolution') 		enabled: [ self versionSelected and: [ modSet resolution notNil ] ]).	values add: #compareWithResolution.	items add: ((MenuItem labeled: 'Compare with Base') 		enabled: [self versionSelected]).	values add: #compareWithBase.	items add: ((MenuItem labeled: 'Compare with Image') 		enabled: [self versionSelected]).	values add: #compareWithImage.	items add: ((MenuItem labeled: 'Compare') 		enabled: [self twoVersionsSelected]).	values add: #compare.	groupSizes add: items size - lastSize.	lastSize := items size.	items add: ( ( MenuItem labeled: 'Show Conflicts with Resolution' )					indication: [ conflictType == #conflictsWithResolution ] ).	values add: #conflictsWithResolution.	items add: ( ( MenuItem labeled: 'Show Conflicts with Base' )					indication: [ conflictType == #conflictsWithBase ] ).	values add: #conflictsWithBase.	items add: ( ( MenuItem labeled: 'Show Conflicts with Image' )					indication: [ conflictType == #conflictsWithImage ] ).	values add: #conflictsWithImage.	groupSizes add: items size - lastSize.	lastSize := items size.	^Menu new menuItems: items menuItemGroups: groupSizes values: values</body><body package="Store-Merge" selector="editMenu">editMenu	| items values groupSizes lastSize |	items := OrderedCollection new.	values := OrderedCollection new.	groupSizes := OrderedCollection new.	lastSize := items size.	items add: ((MenuItem labeled: 'Choose as Resolution') 		enabled: [self versionSelected]).	values add: #chooseAsResolution.	items add: ((MenuItem labeled: 'Unresolve') 		enabled: [self modSetIsSelected]).	values add: #unresolve.	groupSizes add: items size - lastSize.	lastSize := items size.	items add: ((MenuItem labeled: 'Spawn') 		enabled: [self canSpawn]).	values add: #spawnVersion.	items add: ((MenuItem labeled: 'Browse Versions') 		enabled: [self modSetIsSelected]).	values add: #browseVersions.	groupSizes add: items size - lastSize.	lastSize := items size.	items add: ((MenuItem labeled: 'Browse Senders') 		enabled: [self methodSelected]).	values add: #browseSenders.	items add: ((MenuItem labeled: 'Browse Implementors') 		enabled: [self methodSelected]).	values add: #browseImplementors.	groupSizes add: items size - lastSize.	lastSize := items size.	^Menu new menuItems: items menuItemGroups: groupSizes values: values</body><body package="Store-Merge" selector="fileMenu">fileMenu	| items values menu item|	menu := Menu new.	items := OrderedCollection new.	values := OrderedCollection new.	item := MenuItem labeled: 'Select Packages...'.	items add: (item).	values add: #selectPackages.	item := MenuItem labeled: 'Apply Resolved'.	item enabled: [self containsResolvedAndNotApplied].	items add: item.	values add: #applyResolved.	item := MenuItem labeled: 'Publish Packages...'.	item enabled: [self couldPublishPackages].	items add: item.	values add: #publishPackages.	menu addItemGroup: items values: values.	items := OrderedCollection new.	values := OrderedCollection new.	items add: (MenuItem labeled: 'Status...').	values add: #showStatus.	menu addItemGroup: items values: values.	items := OrderedCollection new.	values := OrderedCollection new.	items add: (MenuItem labeled: 'Exit').	values add: #closeRequest.	menu addItemGroup: items values: values.	^menu</body><body package="Store-Merge" selector="menuBar">menuBar	| menuBar |	menuBar := (Menu new)		addItem: ((MenuItem labeled: '&amp;File') submenu: self fileMenu);		addItem: ((MenuItem labeled: '&amp;View') submenu: self viewMenu);		addItem: ((MenuItem labeled: '&amp;Edit') submenu: self editMenu);		addItem: ((MenuItem labeled: '&amp;Compare') submenu: self compareMenu).	^menuBar</body><body package="Store-Merge" selector="packageMenu">packageMenu	| items values groupSizes |	items := OrderedCollection new.	values := OrderedCollection new.	groupSizes := OrderedCollection new.	items add: ((MenuItem labeled: 'choose as resolution') 		enabled: [self versionSelected]).	values add: #chooseAsResolution.	items add: ((MenuItem labeled: 'unresolve') 		enabled: [self modSetIsSelected]).	values add: #unresolve.	items add: ((MenuItem labeled: 'apply as resolution') 		enabled: [self modSetIsSelected]).	values add: #applySelection.	items add: ((MenuItem labeled: 'compare with resolution') 		enabled: [ self versionSelected and: [ modSet resolution notNil ] ]).	values add: #compareWithResolution.	items add: ((MenuItem labeled: 'compare with image') 		enabled: [self versionSelected]).	values add: #compareWithImage.	items add: ((MenuItem labeled: 'compare') 		enabled: [self twoVersionsSelected]).	values add: #compare.	groupSizes add: items size.	items add: ((MenuItem labeled: 'spawn') 		enabled: [self canSpawn]).	values add: #spawnVersion.	items add: ((MenuItem labeled: 'browse versions') 		enabled: [self modSetIsSelected]).	values add: #browseVersions.	groupSizes add: items size - groupSizes last.	^Menu new menuItems: items menuItemGroups: groupSizes values: values</body><body package="Store-Merge" selector="viewMenu">viewMenu	| items values |	items := OrderedCollection new.	values := OrderedCollection new.	items add: ((MenuItem labeled: 'Show Conflicts') 		indication: [show == #conflicts]).	values add: #showConflicts.	items add: ((MenuItem labeled: 'Show Unresolved') 		indication: [show == #unresolved]).	values add: #showUnresolved.	items add: ((MenuItem labeled: 'Show All') 		indication: [show == #all]).	values add: #showAll.	^Menu menuItems: items values: values</body></methods><methods><class-id>Store.MergeTool</class-id> <category>menu actions</category><body package="Store-Merge" selector="applyResolved">applyResolved	"Load into the image all resolved 	definitions. 	Update the status of modification set when the resolution has been successfuly loaded."	| toApply iDictionary errors |	iDictionary := IdentityDictionary new: self allModSets size.	toApply := self allModSets select: [:mSet | mSet isResolved and: [mSet hasBeenApplied not]].	toApply isEmpty ifTrue: [^self].	toApply := toApply				collect: 					[:mSet | 					| res |					res := mSet resolution.					iDictionary at: res put: mSet.					res].	toApply := ModificationSet sortForLoading: toApply.	errors := false.	Cursor execute showWhile: [toApply do: [:mod | mod apply				ifTrue: [(iDictionary at: mod) markApplied]				ifFalse: [errors := true]]].	errors ifTrue: [Dialog warn: 'Some of the resolved definitions have not been applied. See the Transcript for details.'].	self updateModSets</body><body package="Store-Merge" selector="applySelection">applySelection	"Apply the selection as a resolution"	| sel |	sel := modSetList selectionIndex.	self chooseAsResolution.	modSet resolution apply		ifTrue: 			[ modSet markApplied.			self updateModSets.			modSetList selectionIndex: sel.			].</body><body package="Store-Merge" selector="browseImplementors">browseImplementors	| mc |	mc := MethodCollector new.	mc browseSelect:  (mc referencesTo: modSet tag selector )</body><body package="Store-Merge" selector="browseSenders">browseSenders	| mc |	mc := MethodCollector new.	mc browseSelect:  (mc referencesTo: modSet tag selector)"	Browser browseAllSendersOf: modSet tag selector "</body><body package="Store-Merge" selector="browseVersions">browseVersions	modSet notNil ifTrue: [modSet tag browseVersions]</body><body package="Store-Merge" selector="chooseAsResolution">chooseAsResolution	| inx |	inx := self pkgIndexes first.	(modSet isIndexForResolution: inx) ifTrue: [^self].	self resolveTo: (modSet at: inx)</body><body package="Store-Merge" selector="compare">compare	| indexes |	indexes := self pkgIndexes.	TextDifferenceBrowser 		compare: (modSet textForIndex: indexes first)		with: (modSet textForIndex: indexes last)</body><body package="Store-Merge" selector="compareWithBase">compareWithBase	TextDifferenceBrowser 		compare: self selectedPackageText		with: self baseText</body><body package="Store-Merge" selector="compareWithImage">compareWithImage	TextDifferenceBrowser 		compare: self selectedPackageText 		with: self imageText</body><body package="Store-Merge" selector="compareWithResolution">compareWithResolution	TextDifferenceBrowser 		compare: ( self selectedPackageText )		with: ( self resolutionText )</body><body package="Store-Merge" selector="conflictsWithBase">conflictsWithBase	self toggleConflicts: #conflictsWithBase</body><body package="Store-Merge" selector="conflictsWithImage">conflictsWithImage	self toggleConflicts: #conflictsWithImage</body><body package="Store-Merge" selector="conflictsWithResolution">conflictsWithResolution	self toggleConflicts: #conflictsWithResolution</body><body package="Store-Merge" selector="publishPackages">publishPackages	self allAreApplied ifFalse: [(Dialog confirm: 'All definitions do not have applied resolutions.Publish anyway?') ifFalse: [^self]].	self publishModified.</body><body package="Store-Merge" selector="selectPackages">selectPackages	| sel |	self areModsPublished ifFalse: [(Dialog confirm: 'Some of the modification have not been published and will be removed from the Merge Tool if you select a new set of packages.Are you sure that you want to proceed?' for: builder window)			ifFalse: [^self]].	self reset.	sel := MergeSelector new.	sel open.	sel accept value ifTrue: [Cursor wait showWhile: [self mergeIntegrationReadyOfPackageNames: sel packages selections]]</body><body package="Store-Merge" selector="showAll">showAll	show := #all.	self updateModSets</body><body package="Store-Merge" selector="showConflicts">showConflicts	show := #conflicts.	self updateModSets</body><body package="Store-Merge" selector="showStatus">showStatus	Dialog warn: self statusString</body><body package="Store-Merge" selector="showUnresolved">showUnresolved	show := #unresolved.	self updateModSets</body><body package="Store-Merge" selector="spawnVersion">spawnVersion	"NEEDS HELP"	| mod |	mod := pkgList selections first.	mod isNil ifTrue: [^Dialog warn: 'No resolution to spawn'.].	ComposedTextView		open: self selectedPackageText asValue		label: modSet name , ' in ' , mod description		icon: nil		extent: 400 @ 200</body><body package="Store-Merge" selector="unresolve">unresolve	self resolveTo: nil</body></methods><methods><class-id>Store.MergeTool</class-id> <category>aspects</category><body package="Store-Merge" selector="conflictText">conflictText	"Answer the text to display in the conflict text pane."	^conflictText</body><body package="Store-Merge" selector="displayText">displayText	^displayText</body><body package="Store-Merge" selector="modSetList">modSetList	^modSetList</body><body package="Store-Merge" selector="pkgList">pkgList	^pkgList</body><body package="Store-Merge" selector="setConflictText">setConflictText	"Answer the text to display in the conflict text pane."	| text ctext |	text := self displayText value.	( ( ( conflictType == #none )  or: [ modSet == nil ] ) or: [ self pkgIndexes isEmpty ] )		ifTrue: 			[ text emphasizeAllWith: #normal.			conflictText value: Text new.			^self			].	conflictType == #conflictsWithImage		ifTrue: [ ctext := self imageText ].	conflictType == #conflictsWithBase		ifTrue: [ ctext := self baseText ].	conflictType == #conflictsWithResolution		ifTrue: [ ctext := self resolutionText ].	DiffList compare: text with: ctext.	displayText value: text.	conflictText value: ctext.</body></methods><methods><class-id>Store.MergeTool</class-id> <category>private</category><body package="Store-Merge" selector="allAreApplied">allAreApplied	mergeData isNil ifTrue: [^false].	^(self allModSets detect: [:mSet | mSet hasBeenApplied not]		ifNone: [nil]) isNil</body><body package="Store-Merge" selector="allModSets">allModSets	^mergeData modificationSets</body><body package="Store-Merge" selector="areModsPublished">areModsPublished	"Check if all the modifications has been applied and the packages published."	mergeData isNil ifTrue: [^true].	(self allModSets detect: [:mSet | mSet hasBeenApplied not]		ifNone: [nil]) notNil ifTrue: [^false].	self hasPackagesToPublish ifTrue: [^false].	^true</body><body package="Store-Merge" selector="askIfOkToDiscard">askIfOkToDiscard	^Dialog confirm: 'The text showing has been altered.Do you wish to discard these changes?'</body><body package="Store-Merge" selector="baseText">baseText	^modSet == nil		ifTrue: [ Text new ]		ifFalse: [ ( modSet textForIndex: 1 ) asText ]</body><body package="Store-Merge" selector="canSpawn">canSpawn	"Answer true if there is a version selected. 	and the modification is not removal."	^self versionSelected		and: 			[| mod |			mod := pkgList selections first.			mod notNil and: [mod existsInPackage]]</body><body package="Store-Merge" selector="changeRequest">changeRequest	^super changeRequest and: [self areModsPublished			ifTrue: [true]			ifFalse: [Dialog confirm: 'Some of the modifications have not been published.Are you sure that you want to quit the Merge Tool?' for: builder window]]</body><body package="Store-Merge" selector="collectPackageVersionsFrom:">collectPackageVersionsFrom: aCollectionOfPundleVersions 	"Answer a collection of package versions generated by expanding the bundles in the collecion.	Add bundles to bundles inst var."	| pkgs |	pkgs := OrderedCollection new.	aCollectionOfPundleVersions do: 		[ :pun | 		pun isBundle			ifTrue: 				[ bundles add: pun.				pkgs addAll: ( self collectPackageVersionsFrom: pun containedItems ).				pkgs add: pun.				]			ifFalse: [ pkgs add: pun ]		].	^pkgs</body><body package="Store-Merge" selector="containsResolvedAndNotApplied">containsResolvedAndNotApplied	mergeData isNil ifTrue: [^false].	^(self allModSets detect: [:mSet | mSet isResolved and: [mSet hasBeenApplied not]]		ifNone: [nil]) notNil</body><body package="Store-Merge" selector="couldPublishPackages">couldPublishPackages	^mergeData notNil and: [mergeData packages isEmpty not]</body><body package="Store-Merge" selector="doMergeBy:">doMergeBy: aBlock	"Execute 'aBlock' to set the versions to merge.	If there are no errors proceed to do the merge	and update the modification sets.	Otherwise report the error."	| notConnectedPackages |	notConnectedPackages := OrderedCollection new.	aBlock on: self class noCommonAncestorSignal do:		[ :ex| 		notConnectedPackages add: ex parameter.		ex proceed		].	notConnectedPackages isEmpty		ifTrue: 			[ mergeData doMerge.			self updateModSets			]		ifFalse: 			[ notConnectedPackages size &gt; 1 			ifTrue: 				[ Transcript cr; show: 'The following pairs of packages do not have a common ancestor.'; cr.				notConnectedPackages do: [:pair|					Transcript show: (pair at: 1) itemString; 					show: ' and '; show: (pair at: 2) itemString; cr				].			Transcript show: '-------------'.			Dialog warn: 'Multiple cases of the following problem have been detected:a package with two integration ready versions which are not derived from a common ancestor.The merge has been aborted.One of each of the following pairs should have its blessing level set to a value other than integration ready.  These versions may first be merged using the Differences Tool.  After this is done the merge may be retried.', (notConnectedPackages inject: '' into: [:str :pair | str, '     ', (pair at: 1) itemString, ' and ', (pair at: 2) itemString]), 'This list is repeated in the transcript.'.]			ifFalse: 				[  | pair |				pair := notConnectedPackages first.				Transcript cr; show: 'The two packages ' , (pair at: 1) itemString , 					' and ' , (pair at: 2) itemString , ' do not have a common ancestor.'.				Dialog warn: 					('The two packages ' , (pair at: 1) itemString , 	' and ' , (pair at: 2) itemString , 					'\do not have a common ancestor. The merge has been aborted.' , 					'\These versions may be merged using the Differences Tool.') withCRs.				].		self reset		]</body><body package="Store-Merge" selector="hasPackagesToPublish">hasPackagesToPublish	^mergeData notNil and: [mergeData affectedPackages isEmpty not]</body><body package="Store-Merge" selector="imageBundles">imageBundles	"Answer a collection of bundles as loaded into the image."	^( bundles collect: [ :b | Registry bundleNamed: b name ] )		reject: [ :b | b == nil ].</body><body package="Store-Merge" selector="imageText">imageText	| text |	modSet == nil		ifTrue: [ ^Text new ].	text := modSet sourceTextForImage.	^text isNil		ifTrue: [ '*** Not in image ***'  asText ]		ifFalse: [ text asText ]</body><body package="Store-Merge" selector="mergeStringForPackage:">mergeStringForPackage: package	| strm coll |	strm := WriteStream on: String new.	strm nextPutAll: 'Merged by Merge Tool.'; cr.	strm nextPutAll: 'Versions integrated: '; cr.	coll := package isBundle		ifTrue: [ bundles ]		ifFalse: [ mergeData integratedVersions ].	coll do: 		[ :pkg |		pkg name = package name 			ifTrue: [ strm nextPutAll: '   ', pkg itemString; cr ]		].	^strm contents</body><body package="Store-Merge" selector="methodSelected">methodSelected	"Answer true if a mod set of a method has been selected"	^modSet notNil and: [modSet tag isMethodTag]</body><body package="Store-Merge" selector="modSetIsSelected">modSetIsSelected	"Answer true if a mod set has been selected"	^modSet notNil</body><body package="Store-Merge" selector="modSetSelectionChanged">modSetSelectionChanged	modSet := modSetList selection.	pkgList list: (modSet isNil ifTrue: [#()] ifFalse: [modSet])</body><body package="Store-Merge" selector="packageForAccept">packageForAccept	| pkgs pkg pname |	pkg := modSet tag containingPackage.	pkg notNil ifTrue: [^pkg].	pkgs := OrderedCollection new.	modSet modificationsDo: 		[:sel | 		| pn |		(sel notNil and: [(pn := sel packageName) notNil and: [(pkgs includes: pn) not]])			ifTrue: [pkgs add: pn]].	pkgs isEmpty ifTrue: [^PackageChooser chooseOrAdd].	pname := pkgs size = 1				ifTrue: [pkgs first]				ifFalse: [Dialog						choose: 'Select package:'						fromList: pkgs						values: pkgs						lines: 8						cancel: []						for: builder window].	pname isNil ifTrue: [^nil].	^Registry packageNamedOrCreate: pname.</body><body package="Store-Merge" selector="packageSelectionChanged">packageSelectionChanged	| indexes |	indexes := pkgList selectionIndexes.	self text: (indexes isEmpty			ifTrue: [modSetList selectionIndex = 0					ifTrue: [self statusString]					ifFalse: [modSet explanationTrees: mergeData trees]]			ifFalse: [indexes size = 1					ifTrue: [modSet textForIndex: indexes asArray first]					ifFalse: ['*** Multiple packages selected ***']])</body><body package="Store-Merge" selector="pkgIndexes">pkgIndexes	^pkgList selectionIndexes asArray</body><body package="Store-Merge" selector="publishModified">publishModified	"Publish all modified package and other merged	packages the user selects that are mentioned 	in the merge data. 	Change blessing level from integration-ready to integrated."	| affected |	affected := self imageBundles, mergeData packages.	PublishPundleDialog		publishPackages: affected		comments: (affected collect: [:pkg | self mergeStringForPackage: pkg])		defaultBlessing: Policies mergePolicy blessingForMerged		mergeData: mergeData		ifSuccessfulDo:			[ :pud | 	mergeData integratedVersions do: 				[ :irPnd |  | ud comment |				irPnd isLoaded					ifFalse:						[ ud := pud 							detect: [ :pndUD | (pndUD at: #pundle) name = irPnd name ] 							ifNone: nil.						comment := ud isNil							ifTrue: [ 'Integrated by the Merge Tool.' ]							ifFalse: [ 'Integrated by Merge Tool into version ' , (ud at: #version), '.' ].						irPnd addBlessingLevel: Policies mergePolicy blessingForIntegrated andComment: comment 						]				].			bundles do:				[ :b | | bundle |				bundle := Registry bundleNamed: b name.				bundle updateFrom: pud.				]			]</body><body package="Store-Merge" selector="resolutionText">resolutionText	^modSet == nil		ifTrue: [ Text new ]		ifFalse: [ modSet resolutionText asText ]</body><body package="Store-Merge" selector="resolveTo:">resolveTo: aModOrNil	modSet resolution: aModOrNil.	(self builder componentAt: #modSetListID) widget 				updateAt: modSetList selectionIndex.	(self builder componentAt: #pkgListID) widget 				updateAt: modSet size.</body><body package="Store-Merge" selector="resolveToText">resolveToText	modSet isNil		ifFalse: 			[| pkg mod cntr compResult | 			pkg := self packageForAccept.			pkg isNil ifTrue: [^self].			cntr := (self builder componentAt: #displayTextID) widget controller.			Policies packagePolicy forcePackage: pkg 				while: [compResult := modSet tag compileText: cntr text from: cntr].			self text: cntr text copy.			compResult ifFalse: [^self].			mod := TextModification						tag: modSet tag						package: pkg						text: cntr text copy.			self resolveTo: mod]</body><body package="Store-Merge" selector="selectedPackageText">selectedPackageText	^modSet textForIndex: self pkgIndexes first</body><body package="Store-Merge" selector="statusString">statusString	| strm |	strm := WriteStream on: String new.	strm nextPutAll: 'Versions being integrated: '; cr; cr.	mergeData integratedVersions do: [:pkg|		strm nextPutAll: pkg itemString; cr].	^strm contents</body><body package="Store-Merge" selector="text:">text: someText	"For our use only"	| oldTextMode |	oldTextMode := textMode.	textMode := #internal.	displayText value: someText asText.	self setConflictText.	textMode := oldTextMode.</body><body package="Store-Merge" selector="textChanged">textChanged 	textMode = #external ifTrue: [self resolveToText]</body><body package="Store-Merge" selector="textHasChanged">textHasChanged	"Answer true if the text view contains a definition 	and the definition has been modified. 	We distinguish definition from by the ***."	^(self builder componentAt: #displayTextID) widget controller textHasChanged		and: 			[| str |			str := displayText value asString.			str isEmpty not and: [str size &lt; 3 or: [(str copyFrom: 1 to: 3)						~= '***']]]</body><body package="Store-Merge" selector="toggleConflicts:">toggleConflicts: aSymbol	"Change the conflicts after aSymbol was selected."	conflictType == aSymbol	"was on... turn it off"		ifTrue: 			[ conflictType := #none.			^self toggleShowDifferences.			].	conflictType == #none		"turn on"		ifTrue: 			[ conflictType := aSymbol.			self toggleShowDifferences 			].			conflictType := aSymbol.	self setConflictText.</body><body package="Store-Merge" selector="toggleShowDifferences">toggleShowDifferences	| widget spec |	builder notNil		ifTrue:			[ widget := ( builder componentAt: #textCanvas ) widget.			spec := conflictType == #none						ifTrue: [ #standardText ]						ifFalse: [ #twoDifferencesText ].			widget client: self spec: spec builder: builder			].	self modSetSelectionChanged.		"to force the text to update"</body><body package="Store-Merge" selector="twoVersionsSelected">twoVersionsSelected	"Answer true if there are	exactly two packages selected"	^self pkgList selectionIndexes size = 2</body><body package="Store-Merge" selector="updateModSets">updateModSets	modSetList list: (show == #conflicts			ifTrue: [self allModSets select: [:ms | ms hasConflict]]			ifFalse: [show == #unresolved					ifTrue: [self allModSets select: [:ms | ms isUnresolved]]					ifFalse: [self allModSets]])</body><body package="Store-Merge" selector="validateTextOnExit:">validateTextOnExit: aController	^self textHasChanged not or: [self askIfOkToDiscard]</body><body package="Store-Merge" selector="verifyAgainstImage:">verifyAgainstImage: pundles	"Verify that each pundle in the list has an image version (that we are merging into)	 and that there are no image changes.	Answers an error message or nil if okay."	pundles do:		[ :pundle | | imgVersion |		imgVersion := pundle isLoaded			ifTrue: [ pundle ]			ifFalse: [ pundle getImagePundle ].		imgVersion == nil			ifTrue: [ ^nil ]."			ifTrue: [ ^'&lt;1s&gt; not loaded.&lt;n&gt;Merge aborted.' expandMacrosWith: pundle name ].   "		imgVersion hasBeenModified			ifTrue: [ pundles addLast: imgVersion ]."			ifTrue: [ ^'&lt;1s&gt; has unpublished changes.&lt;n&gt;Please publish before merging.' 							expandMacrosWith: pundle name. ]."		].	^nil.</body><body package="Store-Merge" selector="versionSelected">versionSelected	"Answer true if there are	exactly one packages selected"	^self pkgList selectionIndexes size = 1</body><body package="Store-Merge" selector="warnAboutNotLoadedPackages:">warnAboutNotLoadedPackages: aCollectionOfPackages 	| warningStream |	warningStream := (String new: 100) writeStream.	aCollectionOfPackages size = 1		ifTrue: 			[| pkg |			pkg := aCollectionOfPackages first.			warningStream nextPut: $"; nextPutAll: pkg name; nextPut: $".			warningStream nextPutAll: ' is being merged but is not loaded in the image.  A newempty package named "'.			warningStream nextPutAll: pkg name; nextPut: $".			warningStream nextPutAll: ' has been created, and theresolutions you apply will be placed in this package.']		ifFalse: 			[warningStream nextPutAll: 'The following packages:'.			aCollectionOfPackages do: [:pkg | warningStream tab; nextPut: $"; nextPutAll: pkg name; nextPut: $"; cr].			warningStream nextPutAll: 'are being merged but are not loaded in the image.  A new empty package has been created for each of these packages, and the resolutionsyou apply will be placed in these newly created packages.'].	warningStream cr.	Dialog warn: warningStream contents</body></methods><methods><class-id>Store.MergeTool</class-id> <category>interface opening</category><body package="Store-Merge" selector="labelForConflictAtIndex:inView:">labelForConflictAtIndex: anIndex inView: aView 	^(modSetList list at: anIndex)		labelInView: aView</body><body package="Store-Merge" selector="labelForPackageAtIndex:inView:">labelForPackageAtIndex: anIndex inView: aView 	^LabelAndIcon with: (modSet isNil ifTrue: [''] ifFalse: [modSet labelTextForIndex: anIndex])		attributes: aView textStyle</body><body package="Store-Merge" selector="postBuildWith:">postBuildWith: aBuilder 	"Replace controller with one with more sanity."	| v mh cwidget pwidget |	super  postBuildWith: aBuilder.	v := ( aBuilder componentAt: #pkgListID ) widget.	mh := v controller menuHolder.	v setController: MultiSequenceController new.	(v controller) performer: self; menuHolder: mh.	v controller keyboardProcessor: aBuilder keyboardProcessor.	(aBuilder componentAt: #displayTextID) widget controller autoAccept: false.	cwidget := (builder componentAt: #modSetListID) widget.	cwidget selectedVisualBlock: 		[ :view :index | self reverseLabel: ( self labelForConflictAtIndex: index inView: view ) ].	cwidget visualBlock: 		[ :view :index | BoundedWrapper on: (self labelForConflictAtIndex: index inView: view ) ].	pwidget := (builder componentAt: #pkgListID ) widget.	pwidget selectedVisualBlock: 		[ :view :index | self reverseLabel: (self labelForPackageAtIndex: index inView: view ) ].	pwidget visualBlock: 		[ :view :index | BoundedWrapper on: (self labelForPackageAtIndex: index inView: view ) ]</body><body package="Store-Merge" selector="reverseLabel:">reverseLabel: aLabel 	"Build the wrappers needed to reverse the label to show it selected."	| rw |	rw := ReversingWrapper on: aLabel.	rw reverse setValue: true.	^BoundedWrapper on: rw</body></methods><methods><class-id>Store.MergeTool class</class-id> <category>interface opening</category><body package="Store-Merge" selector="openOnPundles:">openOnPundles: aPundles	Cursor wait showWhile: 		[ | mtool odd |		odd := aPundles detect: [ :pundle | pundle getImagePundle == nil ] ifNone: nil.		odd == nil			ifFalse: [ ^Dialog warn: ( '&lt;1s&gt; has no image version to merge into.' 							expandMacrosWith: odd name ) ].		mtool := self new.		[ mtool mergePundleVersions:  aPundles ]			on: PundleModel mismatchedDatabaseSignal do:				[ :ex |				Dialog warn: ( 'Aborting merge.&lt;n&gt;&lt;1s&gt;' expandMacrosWith: ex description ).				^self.				].		self openOn: mtool		]</body><body package="Store-Merge" selector="openOnPundlesTEST:">openOnPundlesTEST: aPundles	"self openOnPundlesTEST: ( Array with: ( Bundle newestVersionWithName: 'zzTTopper' ) )"	Cursor wait showWhile: 		[ | mtool |		mtool := self new.		[ mtool mergePundleVersions:  aPundles ]			on: PundleModel mismatchedDatabaseSignal do:				[ :ex |				Dialog warn: ( 'Aborting merge.&lt;n&gt;&lt;1s&gt;' expandMacrosWith: ex description ).				^self.				].		self openOn: mtool withSpec: #newSpec		]</body></methods><methods><class-id>Store.MergeTool class</class-id> <category>Signal constants</category><body package="Store-Merge" selector="noCommonAncestorSignal">noCommonAncestorSignal	^NoCommonAncestorSignal</body><body package="Store-Merge" selector="noLoadedVersionSignal">noLoadedVersionSignal	^NoLoadedVersionSignal</body></methods><methods><class-id>Store.MergeTool class</class-id> <category>class initialization</category><body package="Store-Merge" selector="initialize">initialize	self initSignals</body><body package="Store-Merge" selector="initSignals">initSignals	"Initialize signals."	NoCommonAncestorSignal := (Object notFoundSignal newSignalMayProceed: true)				nameClass: self message: #noCommonAncestorSignal.	NoLoadedVersionSignal := (Object notFoundSignal newSignalMayProceed: true)				nameClass: self message: #noLoadedVersionSignal</body></methods><methods><class-id>Store.PublishDirectorySpecification</class-id> <category>accessing</category><body package="Store-IMG-Configurations" selector="directory">directory	^directory</body><body package="Store-IMG-Configurations" selector="directory:">directory: anObject	directory := anObject</body></methods><methods><class-id>Store.IndentedListBuilder</class-id> <category>initialize-release</category><body package="Store-UI-Graphs" selector="initializeVisualComponentAsCFList">initializeVisualComponentAsCFList	"Return a node for the object, always return a new one."	self visualComponentBlock: 		[ :bldr :object | 		Lens.LDMListElementWrapper				on: (ElementView for: object model: bldr viewModel)				at: 0 @ 0		]</body><body package="Store-UI-Graphs" selector="reset">reset	bottom := 0.	spacing := 16@0</body></methods><methods><class-id>Store.PackageClassesBrowserHelper</class-id> <category>accessing</category><body package="Store-UI-Browser" selector="category">category	^self package name"	^self selectedClassOrNameSpace == nil		ifTrue: [ nil ]		ifFalse: [ self selectedClassOrNameSpace category ]"</body><body package="Store-UI-Browser" selector="windowLabel">windowLabel	self package isNil ifTrue: [ ^'Package Browser' ].	module hasList ifFalse: [ ^module nextModule windowLabel ].	^( self package isLoaded		ifFalse: [ self package itemString ]		ifTrue: [ self package name ]	), '   Package Browser'</body></methods><methods><class-id>Store.PackageClassesBrowserHelper</class-id> <category>list accessing</category><body package="Store-UI-Browser" selector="actualItem">actualItem	"Answer the actual selected class or namespace."	| selection |	( selection := self selection ) == nil   ifTrue: [ ^nil ].	self package isLoaded ifFalse: [ ^nil ].	^selection actual			"answers nil if no longer exists."</body><body package="Store-UI-Browser" selector="generateNewList">generateNewList	"Answer the current package's classes and namespaces."	^( self browser generateNameSpaceClassListFor: selectionId )		asSortedCollection: [ :a :b | a name &lt; b name ].</body><body package="Store-UI-Browser" selector="howManySelections">howManySelections	| cnt |	^( cnt := super howManySelections ) == 0		ifFalse: [ cnt ]		ifTrue: 			[ module forcedValue == nil				ifTrue: [ 0 ]				ifFalse: [ 1 ].			].</body><body package="Store-UI-Browser" selector="selectedItem">selectedItem	^self selection</body><body package="Store-UI-Browser" selector="selectedItemName">selectedItemName	| selection |	( selection := self selection ) == nil   ifTrue: [ ^nil ].	^selection absoluteName</body><body package="Store-UI-Browser" selector="selection">selection	| sel |	^( sel := super selection ) == nil		ifTrue: [ module forcedValue ]		ifFalse: [ sel ].</body><body package="Store-UI-Browser" selector="selectionChanged">selectionChanged	self nextModule == nil ifTrue: [ ^self ].	self setSelection.	self browser batchUpdates: [ self nextModule updateList	]</body><body package="Store-UI-Browser" selector="selectionIsClass">selectionIsClass	^self selection notNil and: [ self selection isForClass ]</body><body package="Store-UI-Browser" selector="selectionIsDefined">selectionIsDefined		"?"	^self package isLoaded		ifTrue: [ self selection notNil and: [ self selection existsInImage ] ]		ifFalse: [ true ].		"it exists to ask questions of"</body><body package="Store-UI-Browser" selector="selections">selections	| sels val |	^( sels := super selections ) isEmpty		ifTrue: 			[ ( val := module forcedValue ) == nil				ifTrue: [ sels ]				ifFalse: [ OrderedCollection with: val ]			 ]		ifFalse: [ sels ].</body><body package="Store-UI-Browser" selector="updateListFull">updateListFull		"Fill the list with the current package's classes and namespaces."	self setNewList: self generateNewList"	self setNewList: 		( self package == nil			ifTrue: [ List new ]			ifFalse: [ self generateNewList ]		)."</body></methods><methods><class-id>Store.PackageClassesBrowserHelper</class-id> <category>actions</category><body package="Store-UI-Browser" selector="addBinding">addBinding	| env category |	self browser defType value: #showDefinition.	self selection == nil		ifTrue: 			[ env := Smalltalk. 			category := ( self  package == nil ifTrue: [ '' ] ifFalse: [ self package name ] ).			]		ifFalse: 			[ env := self selection actual environment.  			category := self selection actual category 			].	module deselect.	self browser text value: 		( self templateBinding: env category: category ).</body><body package="Store-UI-Browser" selector="browseClassVariables">browseClassVariables	"Show a menu of all class variables of the currently selected class  	and its superclasses.  Browse all methods which refer to the variable selected."	| binding selectedClass mc |	self selections == nil ifTrue: [ ^self ].	self selection isLoaded 		ifFalse: [ self warnPackageNotLoaded. ^false ].	selectedClass := self selection actual.	binding := self forClass: selectedClass instanceBehavior		showVariableMenu: [:class | class localBindings asSortedCollection]		collect: [:bnd | bnd key].	binding notNil ifTrue:		[mc := self methodCollector.		mc browseSelect: (mc searchClassHierarchy: selectedClass )							&amp; (mc referencesTo: binding)]</body><body package="Store-UI-Browser" selector="browseFieldReferences">browseFieldReferences	"Show a menu of all instance variables of the currently selected class 	and its superclasses. Browse all methods which refer to the variable 	selected."	| name mc cls |	cls := self selection actual.	name := self forClass: cls			showVariableMenu: [:class | class instVarNames]			collect: [:cname | cname].	name isNil ifTrue: [^self].	mc := self methodCollector.	mc browseSelect:			(mc searchBehaviorHierarchy: cls)			&amp; (mc instVarUse: name access: #readWrite).</body><body package="Store-UI-Browser" selector="listMenu">listMenu	"Add dynamic features to the class menu."		| menu mi |	^[	menu := self getListMenu: false.	#( #browseVersions ) do: 			[ :sym | 			mi := ( menu someMenuItemWithValue: sym ).			mi enabled: [ ( self isDBConnected ) and: [ self selection notNil ] ]			].	#( #compareWithImage #loadSelection ) do: 			[:sym | 			mi := menu someMenuItemWithValue: sym.			mi enabled: [ self selection notNil and:					[ self package isLoaded not and: [ self isClassInPackage: self selection ] ] ] 			].	menu	]</body><body package="Store-UI-Browser" selector="moveNameSpace">moveNameSpace	| newSpace |	newSpace := 		NameSpaceNavigator				searchFrom: ( self defaultEnvironment isNil							ifTrue: [ Smalltalk ]							ifFalse: [ self defaultEnvironment ])					label: 'Move to which environment?'.	newSpace == nil ifTrue: [ ^self ].	module selections do:		[:sel | sel actual instanceBehavior relocateTo: newSpace].	module updateList</body><body package="Store-UI-Browser" selector="moveNewParcel">moveNewParcel	self notYetImplemented</body><body package="Store-UI-Browser" selector="remove">remove	"Prompt the user to remove the selection. 	 Answer if it was removed or not."	| vars result | 	self package == nil ifTrue: [ ^false ].	self package isLoaded 		ifFalse: [ self warnPackageNotLoaded. ^false ].	self changeRequest ifFalse: [ ^false ].	vars := module selections asArray collect: 		[ :var | var valueOrDo: 			[ Dialog warn: var asString, ' no longer exists.'.  nil ]		].	vars := vars copyWithout: nil.	vars isEmpty ifTrue: [ ^false ].	vars := vars collect: 		[ :v | v isBehavior ifTrue: [ v instanceBehavior ] ifFalse: [ v ] ].	result := false.	vars := SystemUtils sortForLoading: vars.	vars reverseDo: 		[ :var | 		( self removeClassOrNameSpace: var ) 			ifTrue: [ result := true ].		].	module updateList.	^result</body><body package="Store-UI-Browser" selector="removeClassOrNameSpace:">removeClassOrNameSpace: anObject	"Remove anObject from the system or  a Package, or restore an override for anObject.	Answer true if removed. Why, I don't know."	| overs choice |	( overs := Override overridesForClassOrNameSpace: anObject ) == nil		ifTrue: [ ^self verifiedClassOrNameSpaceRemoval: anObject ]. 	choice := self overrideActionDialog: overs.	choice == false ifTrue: [ ^false ].	choice == true ifTrue: [ ^self verifiedClassOrNameSpaceRemoval: anObject ].	choice isOverride		ifTrue: [ Override reinstall: choice list: overs ]		ifFalse: [ Override removeOverridesForClassOrNameSpace: anObject in: choice ].	^false</body><body package="Store-UI-Browser" selector="spawn">spawn	| sel |	( sel := self selection ) == nil ifTrue: [ ^self ].	sel isLoaded		ifFalse: 			[ sel isPseudo ifTrue: [ ^Dialog warn: 'Package does not contain definition' ].			self spawningBrowserClass 				openOnPackage: sel package 				classOrNameSpace: sel			]		ifTrue: 			[ sel isForClass				ifTrue: [ 	self spawningBrowserClass openOnClass: self selection actual instanceBehavior ]				ifFalse: [  self browser spawnOnNameSpace:   self selection actual ]			]</body><body package="Store-UI-Browser" selector="spawnHierarchy">spawnHierarchy	self selection == nil		ifTrue: [ ^self ].	self selectionIsClass		ifFalse: [ ^self ].	self selection isLoaded		ifFalse: [ ^Dialog warn: 'Cannot view hierarchy of unloaded class.' ].	self browser spawnOnClassHierarchy: self actualItem instanceBehavior</body></methods><methods><class-id>Store.PackageClassesBrowserHelper</class-id> <category>text processing</category><body package="Store-UI-Browser" selector="acceptDefinition:from:">acceptDefinition: aText from: aController	[ self forceIfForPackage: [ super acceptDefinition: aText from: aController ] ]			on: RedefinitionNotification 			do: [ :note | RedefinitionNotification interactiveHandler: note forcedPackage: self package].	^true	"??"</body><body package="Store-UI-Browser" selector="acceptText:from:">acceptText: text from: textController	self isPackageLoaded ifFalse: [ self warnPackageNotLoaded. ^false ].	^super acceptText: text from: textController</body><body package="Store-UI-Browser" selector="explainerClass">explainerClass	| act |	^( self selectionIsClass and: [ ( act := self actualItem ) ~~ nil ] )		ifTrue: [ act ]		ifFalse: [ nil ]</body><body package="Store-UI-Browser" selector="textForItem:">textForItem: aListEntry	"Answer the text for the item in the list."	"Restores default overriden by superclass."	^( aListEntry isLoaded		ifTrue: [ aListEntry name ]		ifFalse: [ aListEntry displayString ]	) asText</body><body package="Store-UI-Browser" selector="textWhenSelected">textWhenSelected	| str |	( self defType == #showHierarchy )		ifTrue: [ ^( ( self selection isForClass  and: [ self  isPackageLoaded ] )					ifTrue: 						[ self isData							ifTrue: [ self selection actual printHierarchyWithStatics ]							ifFalse: [ self selection actual printHierarchy ]						]					ifFalse: [ '' ]				) asText.			   ].	( self defType == #showComment )		ifTrue: 			[ ^( ( ( str := self selection comment ) isEmpty and: [ self isPackageLoaded ] )					ifTrue: [ | act |							act := self selection actual.							act isBehavior ifTrue: [ act := act instanceBehavior ].							act == nil 								ifTrue: [ str ]  ifFalse: [ act commentTemplateString ] 						   ]					ifFalse: [ str ] 			   ) asText 			].	^self nonMetaSelection definition asText.</body></methods><methods><class-id>Store.PackageClassesBrowserHelper</class-id> <category>initialization</category><body package="Store-UI-Browser" selector="postBuildWith:">postBuildWith: aBuilder		self setVisualBlocksWith: aBuilder</body></methods><methods><class-id>Store.PackageClassesBrowserHelper</class-id> <category>visual blocks</category><body package="Store-UI-Browser" selector="textEmphasisForItem:">textEmphasisForItem: anItem	^self emphasizer 		emphasisForClassOrNameSpace: anItem		for: self browser 		id: self selectionId</body></methods><methods><class-id>Store.PackageClassesBrowserHelper</class-id> <category>private</category><body package="Store-UI-Browser" selector="decorate:">decorate: item	^item isSymbol  		"can be when setting selection"		ifTrue: [ super decorate: ( ClassDescriptor fullName: item asString meta: self isMeta ) ]		ifFalse: [ super decorate: item ].</body><body package="Store-UI-Browser" selector="defaultFileName">defaultFileName	"Answer a string as a suggested filename"	^self selection == nil		ifTrue: [ 'Definitions' ]		ifFalse: [ self selection name asString ].</body><body package="Store-UI-Browser" selector="environment">environment	| env |	^( env := super environment ) == nil		ifTrue: [ Smalltalk ]		ifFalse: [ env ].</body><body package="Store-UI-Browser" selector="isClassInPackage:">isClassInPackage: aClass 	"Test if a class defined in the selected package."	self package == nil 	ifTrue: [ ^false ].	^self package includesDefinitionOf: aClass absoluteName</body><body package="Store-UI-Browser" selector="itemForPackage:">itemForPackage: aDescriptor	^self browser recordFor: aDescriptor inPackage: self package</body><body package="Store-UI-Browser" selector="load:fromPackage:">load: aDescriptor fromPackage: aPackage 	aDescriptor isForClass 		ifTrue: [ self loadClass: aDescriptor fromPackage: aPackage ]		ifFalse: [ self loadNameSpace: aDescriptor fromPackage: aPackage ].</body><body package="Store-UI-Browser" selector="loadClass:fromPackage:">loadClass: aDescriptor fromPackage: aPackage 	| loader classRecord |	loader := ClassLoader new.	loader openForClass: aDescriptor package: aPackage. 	loader accept value		ifTrue: 			[ classRecord := aDescriptor instSideFrom: aPackage.			classRecord loadFrom: aPackage using: loader.			]</body><body package="Store-UI-Browser" selector="loadNameSpace:fromPackage:">loadNameSpace: aDescriptor fromPackage: aPackage 	| loader |	loader := NameSpaceLoader new.	loader openForNameSpace: aDescriptor package: aPackage. 	loader accept value		ifTrue: [ aDescriptor loadFrom: aPackage using: loader ]</body><body package="Store-UI-Browser" selector="nonMetaSelection">nonMetaSelection	| cls |	( self selectionIsClass and: [ self selection isMeta ] )		ifFalse: [ ^self selection ].	^self selection isLoaded		ifTrue: [ self selection instanceBehavior ]		ifFalse: 			[ cls := self package classInPackageNamed: self selection absoluteName meta: false.			cls == nil				ifTrue: [ PseudoClass named: self selection absoluteName meta: false ]				ifFalse:[ cls ]			]</body><body package="Store-UI-Browser" selector="selectedThingsWithOrder:">selectedThingsWithOrder: aBlock	"Answer the currently selected classes/namespace sorted."	"NOTE: what they really want is all the matching classes w/metaclasses. 	So.... at the moment broken for db packages."	| namespaces classes things |	self isPackageLoaded 		ifTrue: 			[ things := self selections collect: [ :sel | sel actual ].			things do:				[ :thing | 				thing isBehavior 					ifTrue: [ things add: ( thing isMeta ifTrue: [ thing instanceBehavior ] ifFalse: [ thing class ] ) ].				].			^aBlock value: ( SystemUtils sortForLoading: things )			].	"Psuedo sort for things not in the image."	namespaces := self selections select: [ :sel | sel isForNameSpace ].	classes := self selections select: [ :sel | sel isForClass ].	aBlock value:		( ( Package nameSpaceOrder: namespaces ), ( Package superclassOrder: classes ) )</body><body package="Store-UI-Browser" selector="selectVersion:">selectVersion: aClassOrNameSpace	aClassOrNameSpace == nil		ifTrue: [ ^nil ].	^aClassOrNameSpace isForClass		ifTrue: [ ClassRecord selectVersionNamed: aClassOrNameSpace name ]		ifFalse: [ NameSpaceRecord  selectVersionNamed: aClassOrNameSpace name ].</body><body package="Store-UI-Browser" selector="verifiedClassOrNameSpaceRemoval:">verifiedClassOrNameSpaceRemoval: anObject	"Verify removal and dependents. Answer true if removed."	| verifyText dependentText |	verifyText := 'Are you certain that you&lt;n&gt;want to remove &lt;1s&gt;?'					expandMacrosWith: anObject displayString.	dependentText := '&lt;1s&gt; has dependent objects. Remove it anyway?'						expandMacrosWith: anObject fullName.	( Dialog confirm: verifyText for: self interfaceWindow )		ifFalse: [ ^false ].	 ^( anObject subrequisites size = 0				or: [ Dialog confirm: dependentText for: self interfaceWindow ] ) 		ifTrue: 			[ anObject removeFromSystem.			true			]		ifFalse: [ false ].</body></methods><methods><class-id>Store.PackageClassesBrowserHelper</class-id> <category>templates</category><body package="Store-UI-Browser" selector="templateBinding:category:">templateBinding: nameSpace category: category	^'&lt;1s&gt; defineSharedVariable: #NameOfBinding&lt;n&gt;&lt;t&gt;private: false&lt;n&gt;&lt;t&gt;constant: false&lt;n&gt;&lt;t&gt;category: &lt;2p&gt;&lt;n&gt;&lt;t&gt;initializer: nil'		expandMacrosWith: (nameSpace namedReferent unambiguousName)		with: (category == nil ifTrue: [nil] ifFalse: [category asString])</body></methods><methods><class-id>Store.PackageClassesBrowserHelper</class-id> <category>selections</category><body package="Store-UI-Browser" selector="defaultAttribute">defaultAttribute	"Answer the default attribute that this helper is responsible for selecting."	^#model</body><body package="Store-UI-Browser" selector="setSelection">setSelection	super setSelection.		"sets model"	"now set class/namespace for other panes."	( ( self selection ~~ nil ) and: [ self selection isLoaded ] )		ifTrue: [ self setSelection: #classOrNameSpace 					for: selectionId 					to: self selection actual 				].</body></methods><methods><class-id>Store.PackageClassesBrowserHelper</class-id> <category>drag and drop</category><body package="Store-UI-Browser" selector="acceptableDCKeys">acceptableDCKeys	^Array		with: self staticKey		with: self selectorOrStaticKey		with: self storeStaticKey</body><body package="Store-UI-Browser" selector="addClientDataTo:">addClientDataTo: anIdentityDict	| selections |	self isPackageLoaded ifFalse: [ ^false ].		"don't drag from unloaded packages."	self selections isEmpty ifTrue: [ ^false ].	selections := self selections collect: [ :sel | sel actual ].	anIdentityDict		at: self storePackageKey put: self package;		at: self classOrNamespaceKey put: selections;		yourself.	^true</body><body package="Store-UI-Browser" selector="canAcceptDropFrom:">canAcceptDropFrom: aDC	^self acceptableDCKeys includes: aDC key.</body></methods><methods><class-id>Store.PackageClassesBrowserHelper</class-id> <category>menus accessing</category><body package="Store-UI-Browser" selector="actionsForMultiSelect">actionsForMultiSelect	^self package == nil		ifTrue: [ #( #classesView ) ]		ifFalse: 			[ super actionsForMultiSelect asOrderedCollection				addAll: #( #moveToPackage #moveAllToPackage #classesView );				yourself			]</body><body package="Store-UI-Browser" selector="actionsForNoSelect">actionsForNoSelect	^self package == nil		ifTrue: [#()]		ifFalse: [#(#add #addNameSpace )]</body><body package="Store-UI-Browser" selector="actionsForUnloadedPackages">actionsForUnloadedPackages	^#( #fileOut #spawn #loadSelection #browseVersions #compareWithImage #compareWithVersion #findPackage)</body><body package="Store-UI-Browser" selector="getListMenu:">getListMenu: forMenuBar	| menu |	menu := forMenuBar			ifTrue: [self  getStoreMenuBarMenu]			ifFalse: [self getListMenu].	menu == nil ifTrue: [menu := Menu new].	self setEnablement: menu.	^menu</body><body package="Store-UI-Browser" selector="menuHeader">menuHeader	^selectionId isInteger		ifTrue: [ self class menuHeader, selectionId printString ]		ifFalse: [ self class menuHeader ]</body><body package="Store-UI-Browser" selector="setEnablement:">setEnablement: menu	"Set the menu's items enabled/disabled state."	"Since loaded and unloaded not in the same browser we only have to disable things."	"Don't override a menu items particular enablement"	menu enablementSelector == nil		ifFalse: [ ^menu ].	super setEnablement: menu.	self selection == nil		ifTrue: [ ^menu ].	self selection isLoaded 		ifTrue: [ ^menu ].	self menu: menu do: 		[ :item | 		( self actionsForUnloadedPackages includes: item nameKey )			ifFalse: [ item disable ]		].</body></methods><methods><class-id>Store.PackageClassesVersionBrowserHelper</class-id> <category>list accessing</category><body package="Store-UI-Browser" selector="selectionChanged">selectionChanged	self browser updateText.</body><body package="Store-UI-Browser" selector="textForItem:">textForItem: aListEntry	"Answer the text for the item in the list."	^aListEntry fullDisplayString asText</body><body package="Store-UI-Browser" selector="updateListFull">updateListFull		"Fill the list with the active list of classes and namespaces."	self package == nil		"fixed list..."		ifFalse: [ self setNewList: self generateNewList ].</body></methods><methods><class-id>Store.PackageClassesVersionBrowserHelper</class-id> <category>menus</category><body package="Store-UI-Browser" selector="actionsForUnloadedPackages">actionsForUnloadedPackages	^#( #fileOut #loadSelection #compareWithImage #compareWithVersion #findPackage )</body></methods><methods><class-id>Store.PackageClassesVersionBrowserHelper</class-id> <category>private</category><body package="Store-UI-Browser" selector="selectedThingsWithOrder:">selectedThingsWithOrder: aBlock	aBlock value: ( Array with: self selection ).</body></methods><methods><class-id>Store.PackageClassesVersionBrowserHelper</class-id> <category>actions</category><body package="Store-UI-Browser" selector="spawn">spawn	"can't, so lets avoid the walkback by doing nothing."</body><body package="Store-UI-Browser" selector="spawnHierarchy">spawnHierarchy	"can't, so lets avoid the walkback by doing nothing."</body></methods><methods><class-id>Store.BasicOwnershipPolicy</class-id> <category>accessing</category><body package="Store-Ownership" selector="currentUserIsOwner:">currentUserIsOwner: aPundle	"Answer true if the current user has ownership rights over a pundle."	^true		"not looking"</body><body package="Store-Ownership" selector="currentUserName">currentUserName	^DbRegistry currentUserName</body><body package="Store-Ownership" selector="isImageAdministrator">isImageAdministrator	"Returns a boolean indicating whether or not the user is the Image Administrator"	^DbRegistry isSystemAdministrator</body><body package="Store-Ownership" selector="ownerOfPundle:">ownerOfPundle: aPundle	^nil."	^self currentUserName "</body></methods><methods><class-id>Store.OwnerOwnershipPolicy</class-id> <category>accessing</category><body package="Store-Ownership" selector="currentUser">currentUser	^DBUserGroup userNamed: self currentUserName</body><body package="Store-Ownership" selector="currentUserHasOwnershipPrivilegesFor:">currentUserHasOwnershipPrivilegesFor: aPundle	"Answer true if the current user has ownership rights over a pundle."	( self ownerOfPundle: aPundle ) == nil		ifTrue:[ ^true ].		"no owner = everybody does"	^DBPundlePrivileges user: self currentUser hasPrivilege: #owner to: aPundle.</body><body package="Store-Ownership" selector="currentUserHasPublishingPrivilegesFor:">currentUserHasPublishingPrivilegesFor: aPundle	"Answer true if the current user has publishing rights over a pundle."	^DBPundlePrivileges user: self currentUser hasPrivilege: #publish to: aPundle.</body><body package="Store-Ownership" selector="currentUserIsOwner:">currentUserIsOwner: aPundle	"Answer true if the current user has ownership rights over a pundle."	^DBPundlePrivileges user: self currentUser hasPrivilege: #owner to: aPundle.</body><body package="Store-Ownership" selector="ownerOfPundle:">ownerOfPundle: aPundle	^( #{DBPundlePrivileges} valueOrDo: [ ^super ownerOfPundle: aPundle ] ) 			ownerOfPundle: aPundle</body></methods><methods><class-id>Store.PackageConflicts</class-id> <category>initialization</category><body package="Store-Change Management" selector="fromDiffHolder:">fromDiffHolder: aDiffHolder	"Inialize receiver from a difference holder."	self pkgSide: 1 put: (aDiffHolder pkgSide: 1).	self pkgSide: 2 put: (aDiffHolder pkgSide: 2).	self conflictingNameSpacesFrom: aDiffHolder.	self conflictingClassesFrom: aDiffHolder.	self conflictiongMetaclassesFrom: aDiffHolder.	self conflictingMethodsFrom: aDiffHolder.	self conflictingDataFrom: aDiffHolder.	self conflictingNameSpacesFrom: aDiffHolder</body></methods><methods><class-id>Store.PackageConflicts</class-id> <category>private</category><body package="Store-Change Management" selector="conflictingClassesFrom:">conflictingClassesFrom: aDiffHolder	"Given a difference holder compute collections of conflicting classes.  	Each collection contains classes that are modified in both pkg1 and pkg2."	classes2 := SortedCollection sortBlock: [:x :y | x name &lt; y name].	classes1 := ( aDiffHolder classesSide: 1 ) 	select: 		[:cl |   | cc |		cc := ( aDiffHolder classesSide: 2 ) 					detect: [:x | x absoluteName = cl absoluteName] ifNone: [nil].		cc notNil			ifTrue: [ classes2 add: cc.					true]			ifFalse: [ false ] 		].	classes1 := classes1 asSortedCollection: [ :x :y | x name &lt; y name ].</body><body package="Store-Change Management" selector="conflictingDataFrom:">conflictingDataFrom: aDiffHolder	"Given a difference holder compute collections of conflicting data elements.  	Each collection contains data that are modified in both pkg1 and pkg2."	data2 := SortedCollection sortBlock: [ :x :y | x name &lt; y name].	data1 := ( aDiffHolder dataSide: 1 ) select: 		[ :datum |  | conflict |		conflict := ( aDiffHolder dataSide: 2 ) detect: 				[ :x | x name = datum name and: [ x ownerName = datum ownerName ] ]				ifNone: [ nil ].		conflict notNil			ifTrue: 				[ data2 add: conflict.				true]			ifFalse: [false]].	data1 := data1 asSortedCollection: [ :x :y | x name &lt; y name ].</body><body package="Store-Change Management" selector="conflictingMethodsFrom:">conflictingMethodsFrom: aDiffHolder	"Given a difference holder compute collections of conflicting methods.  	Each collection contains classes that are modified in both pkg1 and pkg2."	methods2 := SortedCollection sortBlock: [:x :y | x name &lt; y name].	methods1 := ( aDiffHolder methodsSide: 1 ) select: 		[ :cl |  | cc |		cc := ( aDiffHolder methodsSide: 2 ) detect: 				[ :x | x name = cl name and: [ x className = cl className ] ]				ifNone: [ nil ].		cc notNil			ifTrue: 				[methods2 add: cc.				true]			ifFalse: [false]].	methods1 := methods1 asSortedCollection: [ :x :y | x name &lt; y name ].</body><body package="Store-Change Management" selector="conflictingNameSpacesFrom:">conflictingNameSpacesFrom: aDiffHolder	"Given a difference holder compute collections of conflicting namespaces.  	Each collection contains classes that are modified in  both pkg1 and pkg2."	nameSpaces2 := SortedCollection sortBlock: [:x :y | x name &lt; y name].	nameSpaces1 := (aDiffHolder nameSpacesSide: 1) select: 		[:ns |   | cc |		cc := ( aDiffHolder nameSpacesSide: 2 ) 					detect: [:x | x absoluteName = ns absoluteName] ifNone: [nil].		cc notNil			ifTrue: [ nameSpaces2 add: cc.					true]			ifFalse: [ false ] 		].	nameSpaces1 := nameSpaces1 asSortedCollection: [ :x :y | x name &lt; y name ].</body></methods><methods><class-id>Store.PseudoPackage</class-id> <category>comparing</category><body package="Store-IMG-Pundles" selector="computeDiffsBetween:into:">computeDiffsBetween: aPackage into: diffHolder	"Since the receiver is a loaded package an argument aPackage 	has to be a DB packagge."		[diffHolder reverse.	aPackage computeDiffsBetween: self into: diffHolder]		ensure: [diffHolder reverse].	^diffHolder</body><body package="Store-IMG-Pundles" selector="computeDiffsBetweenDBPackage:into:">computeDiffsBetweenDBPackage: aDBPackage into: diffHolder	"Since the receiver is a loaded package an argument aPackage 	has to be a DB packagge."	diffHolder methodsSide: 2 put: OrderedCollection new.	diffHolder methodsSide: 1 put: aDBPackage methods.	diffHolder dataSide: 2 put: OrderedCollection new.	diffHolder dataSide: 1 put: aDBPackage data.	diffHolder classesSide: 2 put: OrderedCollection new.	diffHolder classesSide: 1 put: aDBPackage classes.	diffHolder metaSide: 2 put: OrderedCollection new.	diffHolder metaSide: 1 put: aDBPackage metaclasses.	diffHolder nameSpacesSide: 2 put: OrderedCollection new.	diffHolder nameSpacesSide: 1 put: aDBPackage nameSpaces.	^diffHolder</body><body package="Store-IMG-Pundles" selector="sameAs:">sameAs: aPackage	^false</body><body package="Store-IMG-Pundles" selector="sameVersionAs:">sameVersionAs: aPackage	^false.</body><body package="Store-IMG-Pundles" selector="sameVersionAsLoadedPundle:">sameVersionAsLoadedPundle: aPundle	^false</body><body package="Store-IMG-Pundles" selector="sameVersionAsPublished:">sameVersionAsPublished: aPundle	^false</body></methods><methods><class-id>Store.PseudoPackage</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="allClasses">allClasses	^#()</body><body package="Store-IMG-Pundles" selector="allDatabases">allDatabases	^#()</body><body package="Store-IMG-Pundles" selector="allNameSpaces">allNameSpaces	^#()</body><body package="Store-IMG-Pundles" selector="classesAndNameSpacesFromChanges:meta:">classesAndNameSpacesFromChanges: changeSet meta: isMeta	^self classesNamed: 		( changeSet keys collect: [ :key | key asString ] )</body><body package="Store-IMG-Pundles" selector="classesDefinedInPackage">classesDefinedInPackage	^#()</body><body package="Store-IMG-Pundles" selector="classesNamed:">classesNamed: aSetOfNames 	"Convert aSetOfnames into a collection of ClassRecord"	"sorts a list of nils..."	^(aSetOfNames collect: [:aName| self classInPackageNamed: aName])			asSortedCollection: [:x :y | x name &lt; y name]</body><body package="Store-IMG-Pundles" selector="classesNamed:meta:">classesNamed: aSetOfNames meta: aBoolean	"Convert aSetOfnames into a collection of ClassRecords"	^( aSetOfNames collect: 		[ :aName | self classInPackageNamed: aName meta: aBoolean ]	) asSortedCollection: [ :x :y | x name &lt; y name ]</body><body package="Store-IMG-Pundles" selector="classesWithSource">classesWithSource	"For image model, same as defined classes."	^self classesDefinedInPackage.</body><body package="Store-IMG-Pundles" selector="classInPackageNamed:">classInPackageNamed: cName 	"See if the class is new and answer nil or the class descriptor."	^nil</body><body package="Store-IMG-Pundles" selector="classInPackageNamed:meta:">classInPackageNamed: cName meta: isMeta	"See if the class is new and answer nil or the class descriptor."	^nil</body><body package="Store-IMG-Pundles" selector="data">data	^#()</body><body package="Store-IMG-Pundles" selector="dataWithSource">dataWithSource	"For the image model this is the same as data."	^self data.</body><body package="Store-IMG-Pundles" selector="datum:forNamed:">datum: dataKey forNamed: aFullName	^#()</body><body package="Store-IMG-Pundles" selector="datum:forOwnerNamed:">datum: dataKey forOwnerNamed: cName 	^nil</body><body package="Store-IMG-Pundles" selector="dbTrace">dbTrace	^nil</body><body package="Store-IMG-Pundles" selector="hasTrace">hasTrace 	^false</body><body package="Store-IMG-Pundles" selector="isLoaded">isLoaded 	^true</body><body package="Store-IMG-Pundles" selector="itemCount">itemCount	"Answer a count of work to be done. Not much."	^realPackage == nil		ifTrue: [ 1 ]		ifFalse: [ realPackage itemCount ]</body><body package="Store-IMG-Pundles" selector="method:forClassNamed:meta:">method: aSelector forClassNamed: cName meta: isMeta 	^nil</body><body package="Store-IMG-Pundles" selector="methods">methods	^#()</body><body package="Store-IMG-Pundles" selector="methodsForClassNamed:">methodsForClassNamed: cName	^#()</body><body package="Store-IMG-Pundles" selector="methodsWithSource">methodsWithSource	"For image model same as methods since sources are already loaded."	^self methods.</body><body package="Store-IMG-Pundles" selector="name">name	^realPackage name</body><body package="Store-IMG-Pundles" selector="nameSpaceInPackageNamed:">nameSpaceInPackageNamed: aName 	^nil</body><body package="Store-IMG-Pundles" selector="nameSpacesDefinedInPackage">nameSpacesDefinedInPackage	^#()</body><body package="Store-IMG-Pundles" selector="nameSpacesNamed:">nameSpacesNamed: aSetOfNames 	"Convert aSetOfnames into a collection of ClassRecord"	"sorts a list of nils...."	^(aSetOfNames collect: [:aName| self classInPackageNamed: aName])			asSortedCollection: [:x :y | x name &lt; y name]</body><body package="Store-IMG-Pundles" selector="nameSpacesWithSource">nameSpacesWithSource	"For image model same as defined NameSpace."	^self nameSpacesDefinedInPackage.</body><body package="Store-IMG-Pundles" selector="primaryKey">primaryKey	^nil</body><body package="Store-IMG-Pundles" selector="properties">properties	^IdentityDictionary new.</body><body package="Store-IMG-Pundles" selector="propertiesForFileOut">propertiesForFileOut	^IdentityDictionary new.</body><body package="Store-IMG-Pundles" selector="propertiesForSave">propertiesForSave	^IdentityDictionary new.</body><body package="Store-IMG-Pundles" selector="pseudoPackage">pseudoPackage	"Answer true since I'm a fake."	^true</body><body package="Store-IMG-Pundles" selector="pundleChangesClass">pundleChangesClass	^PackageChanges</body><body package="Store-IMG-Pundles" selector="version">version	^'--'</body></methods><methods><class-id>Store.PseudoPackage</class-id> <category>testing</category><body package="Store-IMG-Pundles" selector="includesClassNamed:">includesClassNamed: aName 	^false</body><body package="Store-IMG-Pundles" selector="includesDataKey:ownerName:">includesDataKey: dataKey ownerName: aName	^false</body><body package="Store-IMG-Pundles" selector="includesDatum:">includesDatum: datum	^false</body><body package="Store-IMG-Pundles" selector="includesMethod:">includesMethod: method	^false</body><body package="Store-IMG-Pundles" selector="includesNameSpaceNamed:">includesNameSpaceNamed: aName 	^false</body><body package="Store-IMG-Pundles" selector="isBundle">isBundle	^realPackage isBundle</body><body package="Store-IMG-Pundles" selector="isPackage">isPackage	^realPackage isPackage</body></methods><methods><class-id>Store.PseudoPackage</class-id> <category>private-accessing</category><body package="Store-IMG-Pundles" selector="realPackage:">realPackage: aPackage	realPackage := aPackage</body></methods><methods><class-id>Store.PseudoPackage</class-id> <category>printing</category><body package="Store-IMG-Pundles" selector="fileOutProperties:on:">fileOutProperties: props on: aFileManager	^self.</body><body package="Store-IMG-Pundles" selector="textForItem">textForItem	^'*****'</body></methods><methods><class-id>Store.PseudoPackage class</class-id> <category>instance-creation</category><body package="Store-IMG-Pundles" selector="fromPackage:">fromPackage: aPackage		^self new realPackage: aPackage</body></methods><methods><class-id>Core.LostConnectionNotification class</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="description">description	^'The database connection is lost'</body></methods><methods><class-id>Store.MultiSequenceController</class-id> <category>private</category><body package="Store-UI" selector="toggleTarget">toggleTarget	| index |	searchString := nil.	index := view targetIndex.	index = view zeroIndex ifTrue: [^self].	self requestValueChange		ifTrue: 			[(view isSelected: index)				ifTrue: [view retractSelectionIndex: index]				ifFalse: 					[self sensor shiftDown ifFalse: [view resetSelections].					view useSelectionIndex: index].			self valueChange]</body></methods><methods><class-id>Store.AbstractTag</class-id> <category>testing</category><body package="Store-Change Management" selector="existsInImage">existsInImage	^self subclassResponsibility</body><body package="Store-Change Management" selector="isClassCommentTag">isClassCommentTag	^false</body><body package="Store-Change Management" selector="isClassTag">isClassTag	^false</body><body package="Store-Change Management" selector="isCommentChange">isCommentChange		^self isClassCommentTag | self isNameSpaceCommentTag</body><body package="Store-Change Management" selector="isCommentTag">isCommentTag		^self isClassCommentTag | self isNameSpaceCommentTag</body><body package="Store-Change Management" selector="isComponentTag">isComponentTag	^false</body><body package="Store-Change Management" selector="isDataTag">isDataTag	^false</body><body package="Store-Change Management" selector="isForClass">isForClass	^false</body><body package="Store-Change Management" selector="isForData">isForData	^false</body><body package="Store-Change Management" selector="isForMethod">isForMethod	^false</body><body package="Store-Change Management" selector="isForNameSpace">isForNameSpace	^false</body><body package="Store-Change Management" selector="isMethodTag">isMethodTag	^false</body><body package="Store-Change Management" selector="isNameSpaceCommentTag">isNameSpaceCommentTag	^false</body><body package="Store-Change Management" selector="isNameSpaceTag">isNameSpaceTag	^false</body><body package="Store-Change Management" selector="isPropertyTag">isPropertyTag	^false</body><body package="Store-Change Management" selector="isStructureTag">isStructureTag	^false</body><body package="Store-Change Management" selector="isSubdefTag">isSubdefTag	^false</body></methods><methods><class-id>Store.AbstractTag</class-id> <category>private-loading</category><body package="Store-Change Management" selector="applyDefinitionFrom:">applyDefinitionFrom: aRecord	"Load the change. Answer true is the operation is successful."	self subclassResponsibility</body><body package="Store-Change Management" selector="canLoad">canLoad	"Answer true if a record with my tag	can be load into the image.	For methods and meta classes the class has to be already	loaded."	^self actualClass notNil</body><body package="Store-Change Management" selector="loadIntoPackage:from:">loadIntoPackage: aPackage from: aRecord 	"Make sure that modification goes to the proper package."	self canLoad		ifFalse: 			[ Dialog warn: ( 'Definition for &lt;1s&gt; cannot be loaded since &lt;2s&gt; is not loaded.' 				expandMacrosWith: self printString with: symbol ).			^false 			].	Policies packagePolicy forcePackage: aPackage while: 		[ ^aRecord == nil			ifTrue: 				[ self existsInImage 					ifTrue: [ self removeFromSystemTolerant: false fromPackage: aPackage ].				true				]			ifFalse: [ self applyDefinitionFrom: aRecord ]		].</body><body package="Store-Change Management" selector="removeFromSystem">removeFromSystem	self removeFromSystemTolerant: true fromPackage: self containingPackage</body><body package="Store-Change Management" selector="removeFromSystemTolerant:fromPackage:">removeFromSystemTolerant: tolerantBoolean fromPackage: aPackage	self subclassResponsibility</body></methods><methods><class-id>Store.AbstractTag</class-id> <category>accessing</category><body package="Store-Change Management" selector="absoluteName">absoluteName	^self name</body><body package="Store-Change Management" selector="actual">actual	^self actualClass</body><body package="Store-Change Management" selector="actualClass">actualClass	"Answer the class in the image that the reciever applies to. nil if none."	^symbol asStrictReference ifDefinedDo: 		[ :cls | self isMeta 					ifTrue: [ cls class ]					ifFalse: [ cls ].		].</body><body package="Store-Change Management" selector="class:">class: aClass	isMeta := aClass isMeta.	symbol := 		( isMeta 			ifTrue: [ aClass soleInstance ] 			ifFalse: [aClass]		) absoluteName</body><body package="Store-Change Management" selector="className">className	"Return the name as a string, in 'Foo' or 'Foo class' form."	^self isMeta ifTrue: [symbol asString, ' class'] ifFalse: [symbol asString]</body><body package="Store-Change Management" selector="className:">className: aClassName 	"Set the class from a name string."	symbol := aClassName asClassNameOnly asSymbol</body><body package="Store-Change Management" selector="classSymbol">classSymbol	^symbol</body><body package="Store-Change Management" selector="classSymbol:">classSymbol: aSymbol	symbol := aSymbol asClassNameOnly asSymbol</body><body package="Store-Change Management" selector="containingPackage">containingPackage	"Answer a packge that contians the defintion described by me."	^self subclassResponsibility</body><body package="Store-Change Management" selector="fullClassName">fullClassName	^symbol</body><body package="Store-Change Management" selector="isMeta">isMeta	^isMeta</body><body package="Store-Change Management" selector="isMeta:">isMeta: aBoolean	isMeta := aBoolean</body><body package="Store-Change Management" selector="meta:">meta: aBoolean	isMeta := aBoolean</body><body package="Store-Change Management" selector="name">name	"Return the name as a string."	^symbol asString</body><body package="Store-Change Management" selector="name:">name: aName 	"Set the class/namespace from a name string."	symbol := aName asSymbol.</body><body package="Store-Change Management" selector="nonMetaClassName">nonMetaClassName	^symbol asClassNameOnly asSymbol</body><body package="Store-Change Management" selector="package:">package: aPackage	"most of us don't need this"</body><body package="Store-Change Management" selector="sourceTextForImage">sourceTextForImage	^self subclassResponsibility</body><body package="Store-Change Management" selector="sourceTextForImage:">sourceTextForImage: aPackage	^self sourceTextForImage</body><body package="Store-Change Management" selector="sourceTextForPackage:">sourceTextForPackage: aPackage	^aPackage sourceForTag: self</body><body package="Store-Change Management" selector="sourceTextForPackageID:">sourceTextForPackageID: anID	^self sourceTextForPackage: (Package aRecordWithID: anID)</body><body package="Store-Change Management" selector="symbol">symbol	^symbol</body><body package="Store-Change Management" selector="symbol:">symbol: aSymbol	symbol := aSymbol</body><body package="Store-Change Management" selector="tagBaseIndex">tagBaseIndex	^self class tagBaseIndex</body><body package="Store-Change Management" selector="tagIndex">tagIndex	^self tagBaseIndex + 		( self isMeta			ifTrue: [self class metaOffset ]			ifFalse: [0]		)</body></methods><methods><class-id>Store.AbstractTag</class-id> <category>printing</category><body package="Store-Change Management" selector="printOn:">printOn: aStream	aStream nextPut: $[.	aStream nextPutAll: self name.	aStream nextPut: $].</body></methods><methods><class-id>Store.AbstractTag</class-id> <category>actions</category><body package="Store-Change Management" selector="browseVersions">browseVersions	Dialog warn: 'Not yet implemented'</body><body package="Store-Change Management" selector="compileText:from:">compileText: someText from: aController 	"Compile new source for this tag. Return True if 	sucessful and False on failure."	self subclassResponsibility.	^nil</body><body package="Store-Change Management" selector="moveToPackage:">moveToPackage: newPackage 	self moveToPackage: newPackage ifNotLoaded: 		[self error: 'Attempting to move a definition that is not loaded.']</body><body package="Store-Change Management" selector="moveToPackage:ifNotLoaded:">moveToPackage: newPackage ifNotLoaded: aBlock  	self subclassResponsibility</body></methods><methods><class-id>Store.AbstractTag</class-id> <category>change list support</category><body package="Store-Change Management" selector="browseSystemVersion">browseSystemVersion	^self subclassResponsibility</body><body package="Store-Change Management" selector="browseSystemVersionIfExists">browseSystemVersionIfExists	"Open a browser on the system version of this override if possible.	 Answer if it was possible."	self existsInImage		ifFalse: [ ^false ].	self browseSystemVersion.	^true</body><body package="Store-Change Management" selector="fileOutOn:">fileOutOn: aStream 	"Fileout the system version onto aStream."	^self subclassResponsibility</body><body package="Store-Change Management" selector="fileOutOn:from:">fileOutOn: aStream from: aRecord	"Fileout the change onto aStream."	^self subclassResponsibility</body><body package="Store-Change Management" selector="fileOutOn:from:in:">fileOutOn: aStream from: aRecord in: aPackage	"Fileout the change onto aStream."	( aRecord == nil and: [ self existsInImage not ] )		ifTrue: [ ^self fileOutRemovalOn: aStream ].	( ( UISettings preferenceFor: #fileoutOption ) == #never )		ifFalse:			[ aStream sourceFormatter				attributeFor: #package compute: [ : obj | aPackage name ];				attributeForMethods: #package compute: [ :cls :sel | aPackage name ]			].	aRecord == nil		ifTrue: [ self fileOutOn: aStream ]		ifFalse: [ self fileOutOn: aStream from: aRecord ].</body><body package="Store-Change Management" selector="fileOutRemovalOn:">fileOutRemovalOn: aStream 	"Fileout a removal of the object from the system onto aStream."	^self subclassResponsibility</body><body package="Store-Change Management" selector="type">type	"Answer a symbol representing the sub-type of this kind of modification.	By default return #'other'."	^#other</body></methods><methods><class-id>Store.AbstractTag</class-id> <category>converting</category><body package="Store-Change Management" selector="asChange">asChange	"Answer the receiver as an instance of Change."	^Change new classSymbol: self classSymbol.		"good enough for most"</body><body package="Store-Change Management" selector="recordForPackage:">recordForPackage: aPackage	"Answer a db record from aPackage."	"double dispatch."	self subclassResponsibility</body></methods><methods><class-id>Store.AbstractTag class</class-id> <category>accessing</category><body package="Store-Change Management" selector="classTagIndices">classTagIndices	"The indices for class like things (no subsequent key)."	"Class, Class comment, Meta-Class, Meta-Class comment"	^Array 		with: ClassTag tagBaseIndex		with: ClassCommentTag tagBaseIndex		with: ClassTag tagBaseIndex + self metaOffset		with: ClassCommentTag tagBaseIndex + self metaOffset.</body><body package="Store-Change Management" selector="componentTagIndices">componentTagIndices	"The indices for component related things, like properties 	and bundle structure."	^Array 		with: PropertyTag tagBaseIndex		with: BundleStructureTag tagBaseIndex</body><body package="Store-Change Management" selector="maxTagIndex">maxTagIndex	^11</body><body package="Store-Change Management" selector="metaOffset">metaOffset	"Offset added to class and class methods to get meta side"	^4</body><body package="Store-Change Management" selector="nameSpaceTagIndices">nameSpaceTagIndices	"The indices for namespace like things (no subsequent key)."	"NameSpace, NameSpace comment (?)"	^Array 		with: NameSpaceTag tagBaseIndex		with: NameSpaceCommentTag tagBaseIndex</body><body package="Store-Change Management" selector="subdefTagIndices">subdefTagIndices	"The indices for method like things (subsequent key)."	"instance methods, data, class methods"	^( OrderedCollection 			with: MethodTag tagBaseIndex			with: DataTag tagBaseIndex				with: MethodTag tagBaseIndex + self metaOffset	  ) addAll: self componentTagIndices;	    asArray</body><body package="Store-Change Management" selector="tagBaseIndex">tagBaseIndex	"Answer the unique index for each subclass."	^self subclassResponsibility</body></methods><methods><class-id>Store.AbstractTag class</class-id> <category>instance creation</category><body package="Store-Change Management" selector="newClass:">newClass: aClass	^self new class: aClass</body><body package="Store-Change Management" selector="newClassName:">newClassName: aString	^self new className: aString</body><body package="Store-Change Management" selector="newClassName:isMeta:">newClassName: aString  isMeta: aBoolean	^self new className: aString;  isMeta: aBoolean</body><body package="Store-Change Management" selector="newClassSymbol:isMeta:">newClassSymbol: aSymbol isMeta: aBoolean	^self new classSymbol: aSymbol; isMeta: aBoolean</body></methods><methods><class-id>Store.NameSpaceTag</class-id> <category>testing</category><body package="Store-Change Management" selector="existsInImage">existsInImage	^self nameSpace notNil</body><body package="Store-Change Management" selector="isForNameSpace">isForNameSpace	^true</body><body package="Store-Change Management" selector="isNameSpaceTag">isNameSpaceTag	^true</body></methods><methods><class-id>Store.NameSpaceTag</class-id> <category>private-loading</category><body package="Store-Change Management" selector="applyDefinitionFrom:">applyDefinitionFrom: aRecord 	"Load the new namespace from a definition contained in 	aRecord. Return true is the operation is successful."	^(aRecord loadDefinition: aRecord definition logged: false) notNil</body><body package="Store-Change Management" selector="canLoad">canLoad	"Answer true if a record with my tag can be load into the image."	^symbol asStrictReference environment ~~ nil</body></methods><methods><class-id>Store.NameSpaceTag</class-id> <category>accessing</category><body package="Store-Change Management" selector="actual">actual	"Answer the namespace in the image that the reciever applies to. nil if none."	^symbol asStrictReference ifDefinedDo: 		[ :ns | ns ].</body><body package="Store-Change Management" selector="containingPackage">containingPackage	"Answer a packge that contians the defintion described by me."	^Registry containingPackageForSymbol: symbol</body><body package="Store-Change Management" selector="nameSpace">nameSpace	^symbol asStrictReference valueOrDo: [ nil ].</body><body package="Store-Change Management" selector="nameSpace:">nameSpace: aNameSpace	symbol := aNameSpace absoluteSymbol</body><body package="Store-Change Management" selector="sourceTextForImage">sourceTextForImage	| ns |	ns := self nameSpace.	^ns == nil		ifTrue: [ nil ]		ifFalse: [ ns definition ]</body><body package="Store-Change Management" selector="tagIndex">tagIndex	^self tagBaseIndex</body></methods><methods><class-id>Store.NameSpaceTag</class-id> <category>actions</category><body package="Store-Change Management" selector="browseVersions">browseVersions  	TabApplicationSystemBrowser browseVersionsOfNamespaceOrClass: self</body><body package="Store-Change Management" selector="compileText:from:">compileText: someText from: aController 	"Compile new source for this tag.  Return True if	sucessful and False on failure."	| changed |	Cursor execute showWhile: 		[ changed := Object evaluatorClass 				evaluate: someText string				notifying: aController				logged: true		].	^changed ~~ nil</body><body package="Store-Change Management" selector="moveToPackage:ifNotLoaded:">moveToPackage: newPackage ifNotLoaded: aBlock 	| actual | 	actual := self nameSpace.	actual notNil		ifTrue: [ XChangeSet current				moveNameSpaceDefinition: actual				toPackage: newPackage				]		ifFalse: [ aBlock value ]</body><body package="Store-Change Management" selector="removeFromSystemTolerant:fromPackage:">removeFromSystemTolerant: tolerantBoolean fromPackage: aPackage	"Remove the receiver's definition from the image if aPackage owns it. If tolerantBoolean is false, 	display an error if the definition doesn't exist."	| ns |	ns := self nameSpace.	ns isNil		ifTrue: 			[ tolerantBoolean 				ifFalse: [ self error: 'NameSpace "' , self name , '" does not exist in the image.' ]			]		ifFalse: 			[ ( aPackage hasDefinitionFor: ns )				ifTrue: [ Override unloadClassOrNameSpace: ns from: aPackage ]			]</body></methods><methods><class-id>Store.NameSpaceTag</class-id> <category>change list support</category><body package="Store-Change Management" selector="browseSystemVersion">browseSystemVersion	"Private- Open a browser on the system version of this override."	"Assumes system version exists."	SmalltalkWorkbench browseNameSpace: self nameSpace.</body><body package="Store-Change Management" selector="fileOutObjectType">fileOutObjectType	^#nameSpace</body><body package="Store-Change Management" selector="fileOutOn:">fileOutOn: aStream 	"Fileout the system version onto aStream."	| obj |	( obj := self nameSpace ) == nil		ifFalse: 	[ obj fileOutDefinitionOn: aStream ]</body><body package="Store-Change Management" selector="fileOutOn:from:">fileOutOn: aStream from: aRecord	"Fileout the change onto aStream."	aRecord fileOutDefinitionOn: aStream.</body><body package="Store-Change Management" selector="fileOutRemovalOn:">fileOutRemovalOn: aStream 	"Fileout a removal of the object from the system onto aStream."	self isMeta		ifFalse: [ aStream removeObject: symbol type: self fileOutObjectType ]</body><body package="Store-Change Management" selector="type">type	"Answer a symbol representing the sub-type of this kind of modification.	By default return #'other'."	^#'namespace definition'</body></methods><methods><class-id>Store.NameSpaceTag</class-id> <category>converting</category><body package="Store-Change Management" selector="recordForPackage:">recordForPackage: aPackage	"Answer a db record from aPackage."	"double dispatch."	^aPackage recordForNameSpaceTag: self.</body></methods><methods><class-id>Store.NameSpaceTag class</class-id> <category>instance creation</category><body package="Store-Change Management" selector="newClass:">newClass: aClass	^self shouldNotImplement</body><body package="Store-Change Management" selector="newClassName:">newClassName: aString	^self shouldNotImplement</body><body package="Store-Change Management" selector="newClassSymbol:isMeta:">newClassSymbol: aSymbol isMeta: aBoolean	^self shouldNotImplement</body><body package="Store-Change Management" selector="newNameSpace:">newNameSpace: aNameSpace	^self new nameSpace: aNameSpace</body><body package="Store-Change Management" selector="newNameSpaceName:">newNameSpaceName: aString	^self new name: aString</body><body package="Store-Change Management" selector="newNameSpaceSymbol:">newNameSpaceSymbol: aSymbol	^self new symbol: aSymbol</body></methods><methods><class-id>Store.NameSpaceTag class</class-id> <category>accessing</category><body package="Store-Change Management" selector="tagBaseIndex">tagBaseIndex	^8</body></methods><methods><class-id>Store.ClassCommentTag</class-id> <category>testing</category><body package="Store-Change Management" selector="existsInImage">existsInImage	^self actualClass notNil</body><body package="Store-Change Management" selector="isClassCommentTag">isClassCommentTag	^true</body></methods><methods><class-id>Store.ClassCommentTag</class-id> <category>private-loading</category><body package="Store-Change Management" selector="applyDefinitionFrom:">applyDefinitionFrom: aRecord 	"Load the new class comment from a definition contained in 	aRecord. 	Return true is the operation is successful."	| cl |	cl := aRecord myClass.	^cl isNil		ifTrue: 			[self error: 'Class "' , aRecord className , '" does not exist in the image.'.			false			]		ifFalse: 			[ aRecord loadCommentFor: cl.			true			]</body></methods><methods><class-id>Store.ClassCommentTag</class-id> <category>accessing</category><body package="Store-Change Management" selector="containingPackage">containingPackage	"Answer a packge that contians the defintion described by me."	"(ClassCommentTag newClassName: 'MethodTag class') containingPackage"	^Registry containingPackageForClassNamed: self className</body><body package="Store-Change Management" selector="isMeta">isMeta	^false</body><body package="Store-Change Management" selector="name">name	^self className, ' comment'</body><body package="Store-Change Management" selector="sourceTextForImage">sourceTextForImage	| cl |	cl := self actualClass.	^cl isNil		ifTrue: [nil]		ifFalse: [cl comment]</body></methods><methods><class-id>Store.ClassCommentTag</class-id> <category>actions</category><body package="Store-Change Management" selector="compileText:from:">compileText: someText from: aController 	"Compile new source for this tag. Return True if 	sucessful and False on failure."	| actualClass |	actualClass := self actualClass.	actualClass isNil		ifTrue: 			[Dialog warn: 'The class "' , self classSymbol asString , '" must be loaded intothe image before you can accept an edited comment.Resolve conflicts in the class definition, if any,and "Apply Resolved".'.			^false].	actualClass comment: someText.	^true</body><body package="Store-Change Management" selector="moveToPackage:ifNotLoaded:">moveToPackage: newPackage ifNotLoaded: aBlock 	| actual | 	actual := self actualClass.	actual notNil		ifTrue: [XChangeSet current				moveClassDefinition: actual				toPackage: newPackage]		ifFalse: [aBlock value]</body><body package="Store-Change Management" selector="removeFromSystemTolerant:fromPackage:">removeFromSystemTolerant: tolerantBoolean fromPackage: aPackage	tolerantBoolean ifFalse: [self error: 'I do not know how to remove comments']</body></methods><methods><class-id>Store.ClassCommentTag</class-id> <category>change list support</category><body package="Store-Change Management" selector="browseSystemVersion">browseSystemVersion	"Private- Open a browser on the system version of this override."	"Assumes system version exists."	SmalltalkWorkbench browseClass: self actualClass.</body><body package="Store-Change Management" selector="fileOutOn:">fileOutOn: aStream 	"Fileout the system version onto aStream."	| obj |	^( obj := self actualClass ) == nil		ifFalse: [ obj fileOutCommentOn: aStream ]</body><body package="Store-Change Management" selector="fileOutOn:from:">fileOutOn: aStream from: aRecord	"Fileout the change onto aStream."	aRecord fileOutCommentOn: aStream.</body><body package="Store-Change Management" selector="fileOutRemovalOn:">fileOutRemovalOn: aStream 	"Fileout a removal of the object from the system onto aStream."	"don't bother to remove the comment"</body><body package="Store-Change Management" selector="type">type	"Answer a symbol representing the sub-type of this kind of modification.	By default return #'other'."	^#'class comment'</body></methods><methods><class-id>Store.ClassCommentTag</class-id> <category>converting</category><body package="Store-Change Management" selector="recordForPackage:">recordForPackage: aPackage	"Answer a db record from aPackage."	"double dispatch."	^aPackage recordForClassTag: self.</body></methods><methods><class-id>Store.ClassCommentTag class</class-id> <category>accessing</category><body package="Store-Change Management" selector="tagBaseIndex">tagBaseIndex	^2</body></methods><methods><class-id>Store.NameSpaceCommentTag</class-id> <category>testing</category><body package="Store-Change Management" selector="isNameSpaceCommentTag">isNameSpaceCommentTag	^true</body><body package="Store-Change Management" selector="isNameSpaceTag">isNameSpaceTag	^false</body></methods><methods><class-id>Store.NameSpaceCommentTag</class-id> <category>private-loading</category><body package="Store-Change Management" selector="applyDefinitionFrom:">applyDefinitionFrom: aRecord 	"Load the new class comment from a definition contained in 	aRecord. 	Return true is the operation is successful."	| ns |	ns := aRecord nameSpace.	^ns == nil		ifTrue: 			[ self error: 'NameSpace "' , aRecord absoluteName , '" does not exist in the image.'.			false 			]		ifFalse: 			[ aRecord loadCommentFor: ns.			true			]</body></methods><methods><class-id>Store.NameSpaceCommentTag</class-id> <category>accessing</category><body package="Store-Change Management" selector="name">name	"Return the name as a string.."	^super name, ' comment'</body><body package="Store-Change Management" selector="sourceTextForImage">sourceTextForImage	| ns |	ns := self nameSpace.	^ns == nil		ifTrue: [ nil ]		ifFalse: [ ns comment ]</body></methods><methods><class-id>Store.NameSpaceCommentTag</class-id> <category>actions</category><body package="Store-Change Management" selector="compileText:from:">compileText: someText from: aController 	"Compile new source for this tag. Return True if 	sucessful and False on failure."	| namespace |	namespace := self nameSpace.	namespace isNil		ifTrue: 			[Dialog warn: 'The NameSpace "' , self symbol asString , '" must be loaded intothe image before you can accept an edited comment.Resolve conflicts in the NameSpace definition, if any,and "Apply Resolved".'.			^false].	namespace comment: someText.	^true</body><body package="Store-Change Management" selector="removeFromSystemTolerant:fromPackage:">removeFromSystemTolerant: tolerantBoolean fromPackage: aPackage	tolerantBoolean 		ifFalse: [self error: 'I do not know how to remove comments']</body></methods><methods><class-id>Store.NameSpaceCommentTag</class-id> <category>change list support</category><body package="Store-Change Management" selector="fileOutOn:">fileOutOn: aStream 	"Fileout the system version onto aStream."	| obj |	^( obj := self namespace ) == nil		ifFalse: [ obj fileOutCommentOn: aStream ]</body><body package="Store-Change Management" selector="fileOutOn:from:">fileOutOn: aStream from: aRecord	"Fileout the change onto aStream."	aRecord fileOutCommentOn: aStream.</body><body package="Store-Change Management" selector="fileOutRemovalOn:">fileOutRemovalOn: aStream 	"Fileout a removal of the object from the system onto aStream."	"don't bother to remove the comment"</body><body package="Store-Change Management" selector="type">type	"Answer a symbol representing the sub-type of this kind of modification.	By default return #'other'."	^#'namespace comment'</body></methods><methods><class-id>Store.NameSpaceCommentTag class</class-id> <category>accessing</category><body package="Store-Change Management" selector="tagBaseIndex">tagBaseIndex	^9</body></methods><methods><class-id>Store.MethodTag</class-id> <category>testing</category><body package="Store-Change Management" selector="existsInImage">existsInImage	^self compiledMethod notNil</body><body package="Store-Change Management" selector="isForMethod">isForMethod	^true</body><body package="Store-Change Management" selector="isMethodTag">isMethodTag	^true</body><body package="Store-Change Management" selector="isSubdefTag">isSubdefTag	^true</body></methods><methods><class-id>Store.MethodTag</class-id> <category>private-loading</category><body package="Store-Change Management" selector="applyDefinitionFrom:">applyDefinitionFrom: aRecord 	"Load the new method from a definition contained in 	aPackage."	^aRecord loadAsNew</body></methods><methods><class-id>Store.MethodTag</class-id> <category>accessing</category><body package="Store-Change Management" selector="actual">actual	^self compiledMethod</body><body package="Store-Change Management" selector="compiledMethod">compiledMethod	| cl |	cl := self actualClass.	^cl isNil		ifTrue: [nil]		ifFalse: [cl compiledMethodAt: selector ifAbsent: [nil]]</body><body package="Store-Change Management" selector="containingPackage">containingPackage	"Answer a packge that contains the 	defintion described by me."	"(MethodTag newClass: MethodTag selector: #containingPackage) 	containingPackage" 	^Registry		quickContainingPackageForSelector: self selector		classSymbol: self classSymbol		meta: self isMeta</body><body package="Store-Change Management" selector="name">name	^self className, '&gt;&gt;', selector asString</body><body package="Store-Change Management" selector="protocol">protocol	protocol == nil		ifTrue: [ protocol := self actualClass organization categoryOfElement: self selector ].	^protocol.</body><body package="Store-Change Management" selector="protocol:">protocol: aSymbol	protocol := aSymbol</body><body package="Store-Change Management" selector="selector">selector	^selector</body><body package="Store-Change Management" selector="selector:">selector: aSymbol	selector := aSymbol</body><body package="Store-Change Management" selector="sourceTextForImage">sourceTextForImage	| cm |	cm := self compiledMethod.	^cm isNil		ifTrue: [nil]		ifFalse: [cm getSource]</body><body package="Store-Change Management" selector="symbolKey">symbolKey	^selector</body></methods><methods><class-id>Store.MethodTag</class-id> <category>actions</category><body package="Store-Change Management" selector="browseVersions">browseVersions  	TabApplicationSystemBrowser browseVersionsOfMethodOrStatic: self</body><body package="Store-Change Management" selector="compileText:from:">compileText: someText from: aController 	"Compile new source for this tag. Return True if 	sucessful and False on failure."	| actualClass newSelector |	actualClass := self actualClass.	actualClass isNil		ifTrue: 			[Dialog warn: 'The class "' , self classSymbol asString , '" must be loaded intothe image before you can accept edited code.Resolve conflicts in the class definition, if any,and "Apply Resolved".'.			^false].	newSelector := actualClass parserClass new parseSelector: someText.	newSelector isNil		ifTrue: 			[Dialog warn: 'Parse failure'.			^false].	newSelector ~~ self selector		ifTrue: 			[Dialog warn: 'selector must not change'.			^false].	self protocol size = 0		ifTrue: [ protocol := Dialog request: 'Use what protocol?' ].	protocol size = 0		ifTrue: [ 	protocol := ClassOrganizer defaultProtocol ].	Cursor execute showWhile: [newSelector := actualClass					compile: someText					classified: protocol					notifying: aController].	^newSelector ~~ nil</body><body package="Store-Change Management" selector="moveToPackage:ifNotLoaded:">moveToPackage: newPackage ifNotLoaded: aBlock 	| actual | 	actual := self actualClass.	(actual notNil and: [actual includesSelector: self selector])		ifTrue: [XChangeSet current				moveSelector: self selector				class: actual				toPackage: newPackage]		ifFalse: [aBlock value]</body><body package="Store-Change Management" selector="removeFromSystemTolerant:fromPackage:">removeFromSystemTolerant: tolerantBoolean fromPackage: aPackage	| cls |	cls := self actualClass.	cls isNil		ifTrue: 			[ tolerantBoolean 				ifFalse: [ self error: 'Class "' , self className , '" does not exist in the image.' ]			]		ifFalse: 			[ ( aPackage hasSelector: self selector in: cls )				ifTrue: 					[ ( ( Override unloadSelector: self selector class: cls from: aPackage logged: true ) not								and: [ tolerantBoolean not ] ) 						ifTrue: 							[  ( cls includesSelector: self selector )								ifFalse: [ self error: '"' , self name , '" does not exist in the image.' ]							]					]			]</body></methods><methods><class-id>Store.MethodTag</class-id> <category>change list support</category><body package="Store-Change Management" selector="browseSystemVersion">browseSystemVersion	"Private- Open a browser on the system version of this override."	"Assumes system version exists."	MethodCollector new		openListBrowserOn: 			( Array with: ( MethodDefinition class: self actualClass selector: selector ) )		label: 'Current Definition'.</body><body package="Store-Change Management" selector="category">category	^protocol == nil		ifTrue: [ self systemCategory ]		ifFalse: [ protocol ].</body><body package="Store-Change Management" selector="classProxy">classProxy 	^( Kernel.ChangeSupportClassProxy pathString: self fullClassName asClassNameOnly ) 			meta: self isMeta</body><body package="Store-Change Management" selector="fileOutOn:">fileOutOn: aStream 	"Fileout the system version onto aStream."	| cls |	( cls := self actualClass ) == nil		ifTrue: [ ^nil ].	aStream		saveSource: self sourceTextForImage		class: cls		protocol: self category		attributes: nil.	"to add the &lt;/methods&gt; tag, according to steve"	aStream checkMethodChunkClass: nil protocol: nil.</body><body package="Store-Change Management" selector="fileOutOn:from:">fileOutOn: aStream from: aRecord	"Fileout the change onto aStream."	aRecord fileOutOn: aStream.</body><body package="Store-Change Management" selector="fileOutRemovalOn:">fileOutRemovalOn: aStream 	"Fileout a removal of the object from the system onto aStream."	aStream removeSelector: selector from: self classProxy</body><body package="Store-Change Management" selector="systemCategory">systemCategory	"Return the category of the corresponding method the system, if any"	| class |	^( class := self actualClass ) == nil		ifFalse: [ class whichCategoryIncludesSelector: self selector ]</body><body package="Store-Change Management" selector="type">type	"Answer a symbol representing the sub-type of this kind of modification.	By default return #'other'."	^#'method definition'</body></methods><methods><class-id>Store.MethodTag</class-id> <category>converting</category><body package="Store-Change Management" selector="recordForPackage:">recordForPackage: aPackage	"Answer a db record from aPackage."	"double dispatch."	^aPackage recordForMethodTag: self.</body></methods><methods><class-id>Store.MethodTag class</class-id> <category>instance creation</category><body package="Store-Change Management" selector="newClass:selector:">newClass: aClass selector: aSelector		^self new class: aClass; selector: aSelector</body><body package="Store-Change Management" selector="newClassName:meta:selector:protocol:">newClassName: aString meta: aBoolean selector: aSelector protocol: protocol	^self new 		className: aString;		isMeta: aBoolean;  		selector: aSelector;		protocol: protocol</body><body package="Store-Change Management" selector="newClassName:selector:meta:">newClassName: aString selector: aSelector meta: isMeta		^self new className: aString; meta: isMeta; selector: aSelector</body><body package="Store-Change Management" selector="newClassSymbol:isMeta:selector:">newClassSymbol: aSymbol isMeta: aBoolean selector: aSelector		^self new classSymbol: aSymbol; isMeta: aBoolean;  selector: aSelector</body></methods><methods><class-id>Store.MethodTag class</class-id> <category>accessing</category><body package="Store-Change Management" selector="tagBaseIndex">tagBaseIndex	^3		"also reserves 7 for the meta-class methods"</body></methods><methods><class-id>Store.AbstractComponentTag</class-id> <category>accessing</category><body package="Store-Change Management" selector="containingPackage">containingPackage	"Answer a packge that contians the defintion described by me, nil if none."	^package == nil		ifTrue: [ Registry pundleNamed: symbol asString ]		ifFalse: 			[ package isPackage				ifTrue: [ Registry packageNamed: package name ]				ifFalse: [ Registry bundleNamed: package name ]			].</body><body package="Store-Change Management" selector="package">package	"Answer the package/bundle from whence we came"	^package</body><body package="Store-Change Management" selector="package:">package: aPackage	"Set the package"	package := aPackage.	package == nil		ifFalse: [ symbol := aPackage name asSymbol ].</body><body package="Store-Change Management" selector="packageName">packageName	^package == nil		ifTrue: [ '' ]		ifFalse: [ package name ].</body></methods><methods><class-id>Store.AbstractComponentTag</class-id> <category>actions</category><body package="Store-Change Management" selector="moveToPackage:">moveToPackage: newPackage	"meaningless in this context."	self shouldNotImplement.</body><body package="Store-Change Management" selector="moveToPackage:ifNotLoaded:">moveToPackage: newPackage ifNotLoaded: aBlock  	"meaningless in this context."	self shouldNotImplement.</body></methods><methods><class-id>Store.AbstractComponentTag</class-id> <category>testing</category><body package="Store-Change Management" selector="isComponentTag">isComponentTag	^true</body><body package="Store-Change Management" selector="isMeta">isMeta	^false</body><body package="Store-Change Management" selector="isSubdefTag">isSubdefTag	^true</body></methods><methods><class-id>Store.AbstractComponentTag</class-id> <category>private-loading</category><body package="Store-Change Management" selector="canLoad">canLoad	"Answer true if a record with my tag can be load into the image."	^self shouldNotImplement</body><body package="Store-Change Management" selector="loadIntoPackage:from:">loadIntoPackage: imgPackage from: dbPackage	"Make sure that modification goes to the proper package."	( imgPackage == nil ) | ( dbPackage == nil )		ifTrue: 			[ Dialog warn: ( '&lt;1s&gt; cannot be loaded since the package is not loaded.' 				expandMacrosWith: self printString ).			^false 			].	self applyDefinitionFrom: dbPackage into: imgPackage.	^true</body></methods><methods><class-id>Store.AbstractComponentTag</class-id> <category>converting</category><body package="Store-Change Management" selector="asChange">asChange	"Answer the receiver as an instance of Change."	^ComponentRelatedChange new tag: self</body></methods><methods><class-id>Store.PropertyTag</class-id> <category>accessing</category><body package="Store-Change Management" selector="name">name	^'&lt;1s&gt; propertyAt: &lt;2s&gt;' 		expandMacrosWith: symbol		with: self property printString</body><body package="Store-Change Management" selector="property">property	"Answer the property symbol represented by this tag"	^property</body><body package="Store-Change Management" selector="property:">property: aSymbol	"Set the property symbol represented by this tag"	property := aSymbol</body><body package="Store-Change Management" selector="sourceTextForImage">sourceTextForImage	^self sourceTextForImage: self containingPackage</body><body package="Store-Change Management" selector="sourceTextForImage:">sourceTextForImage: aPackage	| value |	aPackage == nil		ifTrue: [ ^nil  ].	value := aPackage propertyAt: self property.	value == nil		ifTrue: [ ^nil ].	^( self convertValue: value ) asText</body><body package="Store-Change Management" selector="symbolKey">symbolKey	^property</body><body package="Store-Change Management" selector="text">text	^self convertValue: ( package propertyAt: self property ifAbsent: [ '' ] ).</body><body package="Store-Change Management" selector="textRepresentationForTag:">textRepresentationForTag: aTag 	| value |	value := package propertyAt: aTag property ifAbsent: nil. 	^self convertValue: value.</body></methods><methods><class-id>Store.PropertyTag</class-id> <category>testing</category><body package="Store-Change Management" selector="existsInImage">existsInImage	| pkg |	^( pkg := self containingPackage ) ~~ nil 		and: [ ( pkg propertyAt: self property ifAbsent: nil ) ~~ nil ]</body><body package="Store-Change Management" selector="isPropertyTag">isPropertyTag	^true</body></methods><methods><class-id>Store.PropertyTag</class-id> <category>private-loading</category><body package="Store-Change Management" selector="applyDefinitionFrom:into:">applyDefinitionFrom: dbPackage into: imgPackage	"Load the change. Answer true is the operation is successful."	| dbp value |	"special case because of merge tool/changelist incompat"	"for changelist properties, the tag is needed to correctly filein"	dbp := dbPackage class == self class 			ifTrue: [ dbp := dbPackage package ]		ifFalse: [ dbPackage ].	dbp isLoaded		ifTrue: [ ^true ].		"already the in image version"	value :=  dbp propertyAt: self property ifAbsent: nil. 	[ imgPackage perform: ( self property, ':' ) asSymbol with: value ] on: MessageNotUnderstood 			do: [ :e | imgPackage propertyAt: self property put: value. e return ].	^true.</body><body package="Store-Change Management" selector="removeFromSystemTolerant:fromPackage:">removeFromSystemTolerant: tolerantBoolean fromPackage: aPackage	aPackage propertyAt: property put: nil</body></methods><methods><class-id>Store.PropertyTag</class-id> <category>actions</category><body package="Store-Change Management" selector="compileText:from:">compileText: someText from: aController 	"Compile new source for this tag. Return True if 	sucessful and False on failure."	| pkg |	^( pkg := self containingPackage ) == nil		ifTrue: [ false ]		ifFalse: [ pkg propertyAt: self property put: someText. true ].</body></methods><methods><class-id>Store.PropertyTag</class-id> <category>converting</category><body package="Store-Change Management" selector="convertValue:">convertValue: value	^value isString		ifTrue: [ value ]		ifFalse: 			[ ( value isKindOf: BlockClosure )				ifTrue: [ CodeComponent stringFromAction: value ] 				ifFalse: [ value printString ]			].</body><body package="Store-Change Management" selector="recordForPackage:">recordForPackage: aPackage	"Answer a db record from aPackage."	"double dispatch. Answer nil if it's someone elses property"	^( ( package isNil ) or: [ package comparesTo: aPackage ] )		ifTrue: [ aPackage recordForPropertyTag: self ]</body></methods><methods><class-id>Store.PropertyTag</class-id> <category>change list support</category><body package="Store-Change Management" selector="browseSystemVersion">browseSystemVersion	( package propertyAt: property ifAbsent: nil ) inspect.</body><body package="Store-Change Management" selector="definition">definition	^self text</body><body package="Store-Change Management" selector="fileOutOn:">fileOutOn: aStream 	"Fileout the system version onto aStream."	package == nil		ifFalse: 			[ aStream				component: package componentType				named: package name				property: property				value: ( package propertyAt: property ifAbsent: nil )			].</body><body package="Store-Change Management" selector="fileOutOn:from:">fileOutOn: aStream from: aRecord	"Fileout the change onto aStream."	aStream		component: aRecord componentType		named: aRecord name		property: property		value: ( aRecord propertyAt: property ifAbsent: nil )</body><body package="Store-Change Management" selector="fileOutRemovalOn:">fileOutRemovalOn: aStream 	"Fileout a removal of the object from the system onto aStream."	package == nil		ifFalse: 			[ aStream				component: package componentType				named: package name				property: property				value: ( package propertyAt: property ifAbsent: nil )			].</body><body package="Store-Change Management" selector="loadSrcIntoPackage:confirm:">loadSrcIntoPackage: aPackage confirm: aBoolean	"Load the receiver by setting the property value."	| value |	aBoolean 		ifTrue: 			[ ( Dialog confirm: ( 'Reset property &lt;1s&gt;?' expandMacrosWith: property ) )				ifFalse: [ ^self ].			].	value :=   package propertyAt: property ifAbsent: nil.	[ aPackage perform: ( property, ':' ) asSymbol with: value ] on: MessageNotUnderstood 			do: [ :e | aPackage propertyAt: property put: value. e return ].</body></methods><methods><class-id>Store.PropertyTag class</class-id> <category>instance creation</category><body package="Store-Change Management" selector="package:property:">package: aPackage property: aSymbol	"Answer a tag that represents a change  in a property."	"Note - needs the package to be complete."	^self new		package: aPackage;		property: aSymbol;		yourself.</body></methods><methods><class-id>Store.PropertyTag class</class-id> <category>accessing</category><body package="Store-Change Management" selector="tagBaseIndex">tagBaseIndex	^10</body></methods><methods><class-id>Store.StoreLogEnvironment</class-id> <category>execute</category><body package="Store-Base" selector="executeAll:">executeAll: aStream" Execute SQL statements from the stream. Statements should be separated by two cr's" 	| string  pattern |	DbRegistry isOnline ifFalse: [ DbRegistry reconnect: false].	pattern := '\\'  withCRs. 	[aStream peekFor: Character cr]		whileTrue: [].	self safelyExecuteBlock: 				[[ aStream atEnd ]					whileFalse:						[ string := aStream upToAll: pattern. 						DbRegistry storeBroker processSQL: string. 						aStream  atEnd ifFalse: [ aStream skip: 2] ].				DbRegistry goOffLine]		note: 'Execute All: '</body><body package="Store-Base" selector="executeSelection:">executeSelection: aString	self safelyExecuteBlock: 			[ | onlineState |				aString isEmpty not 				ifTrue:					[onlineState := DbRegistry isOnline.					onlineState ifFalse: [ DbRegistry reconnect: false ].					DbRegistry storeBroker processSQL: aString ].					onlineState ifFalse: [ DbRegistry goOffLine ]]		note: 'Execute Selection: '</body></methods><methods><class-id>Store.StoreLogEnvironment</class-id> <category>actions</category><body package="Store-Base" selector="installInfo"> installInfo	DbRegistry installManagementInfo</body></methods><methods><class-id>Store.StoreLogEnvironment</class-id> <category>accessing</category><body package="Store-Base" selector="logFileName">logFileName	logFileName isNil		ifTrue: [ logFileName  := 'StoreLog.txt'].	^ logFileName</body></methods><methods><class-id>Store.StoreLogEnvironment</class-id> <category>debugging</category><body package="Store-Base" selector="log:level:">log: aStringOrBlock level: aLevel	| stream aMsg |	self 		debug:			[(stream := self debugStream) == nil ifTrue: [^self].			(aStringOrBlock isKindOf: BlockClosure)				ifTrue: [ aMsg := aStringOrBlock value]				ifFalse: [ aMsg := aStringOrBlock ].			stream cr; nextPutAll: aMsg; cr; flush]		level: aLevel</body><body package="Store-Base" selector="traceOff">traceOff	self trace: false.</body></methods><methods><class-id>Store.StoreLogEnvironment</class-id> <category>private</category><body package="Store-Base" selector="safelyExecuteBlock:note:">safelyExecuteBlock: aBlock note: aNote	[Notice show: 'Executing SQL statements..'  			while: 				[ Cursor database showWhile:					[ aBlock value.					Dialog warn: 'SQL executed successfully!' ]]	]	on: Error 		do: [  :ex |  DbRegistry storeBroker processPublishException: ex  note: aNote  ]</body></methods><methods><class-id>Store.PublishSpecification</class-id> <category>accessing-calculated</category><body package="Store-IMG-Configurations" selector="at:">at: aKey	"backward compatibility for when dictionary expected."	^self perform: aKey</body><body package="Store-IMG-Configurations" selector="at:ifAbsent:">at: aKey ifAbsent:aBlock	"backward compatibility for when dictionary expected. Never absent... or a bug"	^self perform: aKey</body><body package="Store-IMG-Configurations" selector="basePath">basePath	"Return the base path of the filename for the parcel to be saved."		^( Filename expandEnvironmentIn: self parcelDirectory ) asString</body><body package="Store-IMG-Configurations" selector="padded">padded	"compatibilty"	^self parcelPadded</body></methods><methods><class-id>Store.PublishSpecification</class-id> <category>accessing</category><body package="Store-IMG-Configurations" selector="binarySave">binarySave	^binarySave</body><body package="Store-IMG-Configurations" selector="binarySave:">binarySave: aBoolean	binarySave := aBoolean</body><body package="Store-IMG-Configurations" selector="bundleStructure">bundleStructure	^bundleStructure</body><body package="Store-IMG-Configurations" selector="bundleStructure:">bundleStructure: aBoolean	bundleStructure := aBoolean</body><body package="Store-IMG-Configurations" selector="databaseLinks">databaseLinks	^databaseLinks</body><body package="Store-IMG-Configurations" selector="databaseLinks:">databaseLinks: aBoolean	databaseLinks := aBoolean</body><body package="Store-IMG-Configurations" selector="dbPundle:">dbPundle: aPundle	object := aPundle.	modified := publish := false.	parentVersion := object version.	version := object version.</body><body package="Store-IMG-Configurations" selector="mergeData">mergeData	^mergeData</body><body package="Store-IMG-Configurations" selector="mergeData:">mergeData: aMergeData	mergeData := aMergeData</body><body package="Store-IMG-Configurations" selector="parcelBackup">parcelBackup	^parcelBackup</body><body package="Store-IMG-Configurations" selector="parcelBackup:">parcelBackup: aBoolean	parcelBackup := aBoolean</body><body package="Store-IMG-Configurations" selector="parcelDirectory">parcelDirectory	^parcelDirectory</body><body package="Store-IMG-Configurations" selector="parcelDirectory:">parcelDirectory: anObject	parcelDirectory := anObject</body><body package="Store-IMG-Configurations" selector="parcelHideSource">parcelHideSource	^parcelHideSource</body><body package="Store-IMG-Configurations" selector="parcelHideSource:">parcelHideSource: aBoolean	parcelHideSource := aBoolean</body><body package="Store-IMG-Configurations" selector="parcelOverwrite">parcelOverwrite	^parcelOverwrite</body><body package="Store-IMG-Configurations" selector="parcelOverwrite:">parcelOverwrite: aBoolean	parcelOverwrite := aBoolean</body><body package="Store-IMG-Configurations" selector="parcelPadded">parcelPadded	^parcelPadded</body><body package="Store-IMG-Configurations" selector="parcelPadded:">parcelPadded: aBoolean	parcelPadded := aBoolean</body><body package="Store-IMG-Configurations" selector="parcelRepublish">parcelRepublish	^parcelRepublish</body><body package="Store-IMG-Configurations" selector="parcelRepublish:">parcelRepublish: aBoolean	parcelRepublish := aBoolean</body><body package="Store-IMG-Configurations" selector="parcelSave">parcelSave	^parcelSave</body><body package="Store-IMG-Configurations" selector="parcelSave:">parcelSave: aBoolean	parcelSave := aBoolean</body><body package="Store-IMG-Configurations" selector="parcelSaveSource">parcelSaveSource	^parcelSaveSource</body><body package="Store-IMG-Configurations" selector="parcelSaveSource:">parcelSaveSource: aBoolean	parcelSaveSource := aBoolean</body></methods><methods><class-id>Store.PublishSpecification</class-id> <category>testing</category><body package="Store-IMG-Configurations" selector="canPublish">canPublish	"Answer true if the item can be published."	^self pundle classOfDbRecord canPublish: self pundle userData: self</body></methods><methods><class-id>Store.PublishSpecification</class-id> <category>initialize-release</category><body package="Store-IMG-Configurations" selector="initialize">initialize	super initialize.	binarySave := false.	parcelSave := false.	bundleStructure := false.	databaseLinks := false.	parcelDirectory := ''.	parcelRepublish := false. 	parcelBackup := false. 	parcelOverwrite := false. 	parcelSaveSource := true. 	parcelHideSource := false. 	parcelPadded := false.</body></methods><methods><class-id>Store.PublishSpecification</class-id> <category>publishing</category><body package="Store-IMG-Configurations" selector="publishBlessing">publishBlessing	"Create new blessing/comment records for the pundle."	self publish		ifFalse: [ ^true ].	^[ Blessing		forPundle: self pundle		withLevel: self blessing value		andComment: self comment string.	true	] on: Store.DbRegistry errorSignals do: [ :ex | ex return: false ].</body><body package="Store-IMG-Configurations" selector="publishPundle">publishPundle	"Publish. Answer false if aborted."	^Notice showNotice: 'Publishing ' , self pundle name complete: self pundle itemCount while: 		[ self publishSilently ].</body><body package="Store-IMG-Configurations" selector="publishSilently">publishSilently	"Publish. Answer false if aborted."	self publish		ifFalse: [ ^true ].	^[ ( self pundle classOfDbRecord newFrom: self pundle userData: self ) == nil		ifTrue: [ ^false ].	self description == nil		ifFalse: [ self description updateVersion ].	self parcelSave		ifTrue: [ self pundle saveAsParcelFromSpecs: self ].	true	] on: Store.DbRegistry errorSignals do: [ :ex | ex return: false ].</body></methods><methods><class-id>Store.PublishSpecification class</class-id> <category>instance creation</category><body package="Store-IMG-Configurations" selector="dbPundle:">dbPundle: aPundle	^self new dbPundle: aPundle</body><body package="Store-IMG-Configurations" selector="new">new	^self basicNew initialize.</body><body package="Store-IMG-Configurations" selector="pundle:">pundle: aPundle	^aPundle isLoaded		ifTrue: [ self new pundle: aPundle ]		ifFalse: [ self dbPundle: aPundle ].</body></methods><methods><class-id>Store.PublishFragmentSpecification</class-id> <category>testing</category><body package="Store-IMG-Configurations" selector="canPublish">canPublish	"Answer true if the receiver's pundle can be published."	| msg |	super canPublish		ifFalse: [ ^false ].	self pundle dbTrace == nil		ifTrue: [ msg := '&lt;1s&gt;  needs to be published before it can be fragmented.&lt;n&gt;' ].	msg == nil  &amp;  self pundle isBundle 		ifTrue: 			[ ( self pundle contents contains: [ :p | p dbTrace == nil ] )				ifTrue: [ msg := 'All components of &lt;1s&gt; need to be published before it can be fragmented.&lt;n&gt;' ].			].	msg == nil		ifFalse: [ Dialog warn: ( msg expandMacrosWith: self pundle name ) ].	^msg == nil</body></methods><methods><class-id>Store.DataTag</class-id> <category>testing</category><body package="Store-Change Management" selector="existsInImage">existsInImage	| own |	^( own := self owner ) ~~ nil		and: [ own includesDataKey: self dataKey ]</body><body package="Store-Change Management" selector="isDataTag">isDataTag	^true</body><body package="Store-Change Management" selector="isForData">isForData	^true</body><body package="Store-Change Management" selector="isInClass">isInClass	^( forClass == nil ) | forClass</body><body package="Store-Change Management" selector="isSubdefTag">isSubdefTag	^true</body></methods><methods><class-id>Store.DataTag</class-id> <category>private-loading</category><body package="Store-Change Management" selector="applyDefinitionFrom:">applyDefinitionFrom: aRecord 	"Load the new data."	^aRecord loadSrc</body></methods><methods><class-id>Store.DataTag</class-id> <category>accessing</category><body package="Store-Change Management" selector="actual">actual	^self bindingReference</body><body package="Store-Change Management" selector="containingPackage">containingPackage	"Answer a packge that contians the data described by me."	^ Registry containingPackageForDataKey: self dataKey symbol: symbol.</body><body package="Store-Change Management" selector="dataKey">dataKey	^dataKey asSymbol</body><body package="Store-Change Management" selector="dataKey:">dataKey: aSymbol	dataKey := aSymbol</body><body package="Store-Change Management" selector="forClass:">forClass: aBoolean	forClass := aBoolean.</body><body package="Store-Change Management" selector="isMeta">isMeta	^false</body><body package="Store-Change Management" selector="name">name	^symbol, '.', dataKey</body><body package="Store-Change Management" selector="owner">owner		"Answers the owning class/namespace"	^self actualClass</body><body package="Store-Change Management" selector="ownerName">ownerName		"Answers the owning class/namespace"	^symbol</body><body package="Store-Change Management" selector="sourceTextForImage">sourceTextForImage	| owner |	^( owner := self owner ) == nil		ifTrue: [ nil ]		ifFalse: [ owner asNameSpace definitionOf: self dataKey ifAbsent: [ nil ] ]</body><body package="Store-Change Management" selector="symbolKey">symbolKey	^dataKey</body></methods><methods><class-id>Store.DataTag</class-id> <category>actions</category><body package="Store-Change Management" selector="browseVersions">browseVersions  	TabApplicationSystemBrowser browseVersionsOfMethodOrStatic: self</body><body package="Store-Change Management" selector="compileText:from:">compileText: someText from: aController 	"Compile new source for this tag.  Return True if sucessful and False on failure."	| changed |	Cursor execute showWhile: 		[ changed := Object evaluatorClass 				evaluate: someText string				notifying: aController				logged: true		].	^changed ~~ nil"  was...	Dialog warn: 'The text representation of data cannot be used to generate data.'.	^false"</body><body package="Store-Change Management" selector="moveToPackage:ifNotLoaded:">moveToPackage: newPackage ifNotLoaded: aBlock 	| owner | 	owner := self owner.	( owner notNil and: [ owner includesDataKey: self dataKey ] )		ifTrue: [ XChangeSet current					moveDataKey: self dataKey					owner: owner					toPackage: newPackage				]		ifFalse: [ aBlock value ]</body><body package="Store-Change Management" selector="removeFromSystemTolerant:fromPackage:">removeFromSystemTolerant: tolerantBoolean fromPackage: aPackage	| owner |	owner := self owner.	owner isNil		ifTrue: [ tolerantBoolean 				ifFalse: [ self error: symbol, ' does not exist in the image.' ]			   ]		ifFalse: 			[ ( aPackage hasDataKey: self dataKey in: owner )				ifTrue: 					[ ( ( Override unloadDataKey: self dataKey in: owner from: aPackage ) not								and: [ tolerantBoolean not ] ) 						ifTrue: 							[  ( owner asNameSpace includesKey: self dataKey )								ifFalse: [ self error: '"' , self name , '" does not exist in the image.' ]							]					]			]</body></methods><methods><class-id>Store.DataTag</class-id> <category>change list support</category><body package="Store-Change Management" selector="bindingReference">bindingReference	^BindingReference pathString: self owner fullName, '.', self dataKey.</body><body package="Store-Change Management" selector="browseSystemVersion">browseSystemVersion	"Private- Open a browser on the system version of this override."	"Assumes system version exists."	FullSystemBrowser new		initializeForMethodsLabel: 'Current Definition'		list: ( Array with: self bindingReference )		initialSelection: self dataKey;		open</body><body package="Store-Change Management" selector="fileOutObjectType">fileOutObjectType	^#variable</body><body package="Store-Change Management" selector="fileOutOn:">fileOutOn: aStream	"Fileout the change onto aStream."	| owner obj |	( owner := self owner ) == nil		ifTrue: [ ^nil ].	obj := owner asNameSpace fullyQualifiedReferenceOf: dataKey.	aStream storeObjectDefinition: obj.	obj fileOutInitializerOn: aStream.</body><body package="Store-Change Management" selector="fileOutOn:from:">fileOutOn: aStream from: aRecord	"Fileout the change onto aStream."	aRecord fileOutOn: aStream.</body><body package="Store-Change Management" selector="fileOutRemovalOn:">fileOutRemovalOn: aStream 	"Fileout a removal of the object from the system onto aStream."	aStream removeObject: symbol, '.', dataKey type: self fileOutObjectType</body></methods><methods><class-id>Store.DataTag</class-id> <category>converting</category><body package="Store-Change Management" selector="recordForPackage:">recordForPackage: aPackage	"Answer a db record from aPackage."	"double dispatch."	^aPackage recordForDataTag: self.</body></methods><methods><class-id>Store.DataTag class</class-id> <category>instance creation</category><body package="Store-Change Management" selector="newClassName:dataKey:">newClassName: aString dataKey: dataKey	^self new 		className: aString; 		isMeta: false; 		dataKey: dataKey;		forClass: true.</body><body package="Store-Change Management" selector="newClassSymbol:dataKey:">newClassSymbol: aSymbol dataKey: dataKey	^self new 		classSymbol: aSymbol; 		isMeta: false; 		dataKey: dataKey;		forClass: true.</body><body package="Store-Change Management" selector="newNameSpaceName:dataKey:">newNameSpaceName: aString dataKey: dataKey	^self new 		name: aString; 		isMeta: false; 		dataKey: dataKey;		forClass: false.</body><body package="Store-Change Management" selector="newNameSpaceSymbol:dataKey:">newNameSpaceSymbol: aSymbol dataKey: dataKey	^self new 		symbol: aSymbol; 		isMeta: false; 		dataKey: dataKey;		forClass: false.</body></methods><methods><class-id>Store.DataTag class</class-id> <category>accessing</category><body package="Store-Change Management" selector="tagBaseIndex">tagBaseIndex	^4</body></methods><methods><class-id>Store.Privileges class</class-id> <category>query</category><body package="Store-Ownership" selector="existsPrivilege:pundle:user:ifPundleAbsent:">existsPrivilege: aSymbol pundle: aPundle user: aUserName ifPundleAbsent: aBlock 	"self existsPrivilege: #read pundle: (Registry packageNamed: 'Code') user: 'MeMeMe' 	ifPundleAbsent: [self halt]"	|  names |	names := self usersWithPrivilege: aSymbol pundle: aPundle.	(names includes: aUserName)		ifTrue: [^true].	^self usersAndGroupsTable isUser: aUserName memberOf: names</body><body package="Store-Ownership" selector="privilegesForPundle:user:">privilegesForPundle: aPundle user: aUserName</body><body package="Store-Ownership" selector="privilegesForUser:">privilegesForUser: aUserName</body><body package="Store-Ownership" selector="pundlesUser:privilege:">pundlesUser: aUser privilege: aSymbol 	"Answer a collection of pundles for which a user has given privilege. 	Do not check groups that the user belongs to."	^self privilegeTable pundlesUser: aUser privilege: aSymbol.</body><body package="Store-Ownership" selector="pundlesUserAndGroups:privilege:">pundlesUserAndGroups: aUser privilege: aSymbol 	"Answer a collection of pundles for which a user has given privilege. 	Check groups that the user belongs to and return also all pundles that 	the groups has privileges."	| groups coll |	groups := self usersAndGroupsTable groupNamesForUserNamed: aUser userName.	coll := self privilegeTable pundlesUser: aUser privilege: aSymbol.	groups do: 		[ :gn | coll addAll: 			( self privilegeTable pundlesGroupName: gn privilege: aSymbol )		].	^coll</body><body package="Store-Ownership" selector="usersWithAnyPrivilegeForPundle:">usersWithAnyPrivilegeForPundle: aPundle	"Answer a collection of pairs (user&lt;String&gt; privileges&lt;Set of Symbols&gt;)"</body><body package="Store-Ownership" selector="usersWithPrivilege:pundle:">usersWithPrivilege: aSymbol pundle: aPundle	^self privilegeTable usersWithPrivilege: aSymbol pundle: aPundle</body></methods><methods><class-id>Store.Privileges class</class-id> <category>private</category><body package="Store-Ownership" selector="privilegeTable">privilegeTable	^DBPundlePrivileges</body><body package="Store-Ownership" selector="usersAndGroupsTable">usersAndGroupsTable	^DBUserGroup</body></methods><methods><class-id>Store.Privileges class</class-id> <category>private-db installation</category><body package="Store-Ownership" selector="alterTablesPctincrease">alterTablesPctincrease	"Fix for databases created with 5i.2. Alter STORAGE PSTINCREASE from 0 to 1"	( Array with: DBUserGroup with: DBPundlePrivileges ) 		do: [:aClass | aClass alterTablePctincrease]</body><body package="Store-Ownership" selector="createTables">createTables	"self createTables"	( Array with: DBUserGroup with: DBPundlePrivileges ) 		do: [ :aClass | aClass createDatabaseTable ].	Transcript cr; show: 'Done!'.</body><body package="Store-Ownership" selector="dropTables">dropTables	"self dropTables"	( Array with: DBUserGroup with: DBPundlePrivileges ) 		do: [ :aClass | aClass dropTableForClass ].	Transcript cr; show: 'Done!'</body><body package="Store-Ownership" selector="installUserManagement">installUserManagement	"Create  the tables and install usermanagement policies."	self installUserManagementPolicy.</body><body package="Store-Ownership" selector="installUserManagementPolicy">installUserManagementPolicy	"Create  the tables and install usermanagement policies."	"self installUserManagement"	| admin |	DBUserGroup newGroupNamed: DBUserGroup adminGroupName.	DBUserGroup newGroupNamed: 'QA'.	admin := Dialog request: 'Image Administrator Name:' initialAnswer: DbRegistry tableOwner.	admin isEmpty		ifFalse: [ DBUserGroup newUserNamed: admin inGroupNamed: DBUserGroup adminGroupName ].</body><body package="Store-Ownership" selector="installUserManagementTables">installUserManagementTables	"Create  the tables and install usermanagement policies."	"self installUserManagement"	[ self createTables ] 	on: Error	do: 	[ :e | ( Dialog confirm: e description, ' Continue with installation?' )				ifFalse: [ ^self ].			e return		].</body></methods><methods><class-id>Store.BundleDifferenceBrowser</class-id> <category>aspects</category><body package="Store-UI-Comparitors" selector="bundle1">bundle1	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^bundle1 isNil		ifTrue:			[bundle1 := nil asValue]		ifFalse:			[bundle1]</body><body package="Store-UI-Comparitors" selector="bundle1name">bundle1name	^self bundleName: bundle1 value.</body><body package="Store-UI-Comparitors" selector="bundle2">bundle2	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^bundle2 isNil		ifTrue:			[bundle2 := nil asValue]		ifFalse:			[bundle2]</body><body package="Store-UI-Comparitors" selector="bundle2name">bundle2name	^self bundleName: bundle2 value.</body><body package="Store-UI-Comparitors" selector="bundleName:">bundleName: bundle	| name |	name  := bundle stringKey: #( ).	bundle isLoaded 		ifTrue: 			[ name := name, 				(  bundle hasBeenModified 					ifTrue: [ '*' ] 					ifFalse: [ '=' ]				)			].	^name asValue.</body></methods><methods><class-id>Store.BundleDifferenceBrowser</class-id> <category>menus</category><body package="Store-UI-Comparitors" selector="customTextMenu">customTextMenu	"No accept from this browser."	| mb |	mb := MenuBuilder new.	mb 		add: 'find...'-&gt;#find;		line;		add: 'copy'-&gt;#copySelection.	^mb menu.</body></methods><methods><class-id>Store.BundleDifferenceBrowser</class-id> <category>actions</category><body package="Store-UI-Comparitors" selector="comparePackages">comparePackages	| diffs pfo |	diffs := self class compareBundle: bundle1 value with: bundle2 value.	pfo := ScheduledWindow promptForOpen.		[ScheduledWindow promptForOpen: false.	diffs do: 		[:pair | 		pair first isNil 			ifTrue: [self browsePackage: pair last]			ifFalse:				[pair last isNil					ifTrue: [self browsePackage: pair first]					ifFalse: [ComparisonBrowser comparePackage: pair first toPackage: pair last]]]]	ensure: [ScheduledWindow promptForOpen: pfo]</body></methods><methods><class-id>Store.BundleDifferenceBrowser</class-id> <category>private</category><body package="Store-UI-Comparitors" selector="browsePackage:">browsePackage: aPackage	TabApplicationSystemBrowser openOnPackage: aPackage</body></methods><methods><class-id>Store.BundleDifferenceBrowser class</class-id> <category>instance creation</category><body package="Store-UI-Comparitors" selector="compare:with:">compare: bundle1 with: bundle2 		| diffBrowser |	diffBrowser := self new.	diffBrowser bundle1 value: bundle1.	diffBrowser bundle2 value: bundle2.	diffBrowser text1 value: bundle1 describeContents.	diffBrowser text2 value: bundle2 describeContents.	diffBrowser openInterface: #windowSpec</body></methods><methods><class-id>Store.TextModification</class-id> <category>testing</category><body package="Store-Merge" selector="isTextModification">isTextModification		^true</body></methods><methods><class-id>Store.TextModification</class-id> <category>comparing</category><body package="Store-Merge" selector="=">= aMod 	^aMod notNil and: [aMod isTextModification and: [aMod isMoveModification not and: [aMod text = self text and: [aMod packageName = self packageName and: [aMod tag = self tag]]]]]</body></methods><methods><class-id>Store.TextModification</class-id> <category>accessing</category><body package="Store-Merge" selector="description">description	^self packageName, ' '</body><body package="Store-Merge" selector="existsInPackage">existsInPackage	^text notNil</body><body package="Store-Merge" selector="record">record	^nil</body><body package="Store-Merge" selector="source">source	^text</body><body package="Store-Merge" selector="text:">text: sourceCode	text := sourceCode</body><body package="Store-Merge" selector="timeStampString">timeStampString	^''</body></methods><methods><class-id>Store.TextModification</class-id> <category>actions</category><body package="Store-Merge" selector="apply">apply	"Apply a modification to the image."	"| imPkg | 	imPkg := TT_Registry packageNamed: packageName.	imPkg isNil ifTrue: [self error: 'Package ' , packageName , ' not found.'].	tag existsInImage		ifTrue: 			[| oldPkg |			oldPkg := tag containingPackage.			oldPkg isNil ifTrue: [self error: 'No containing package for: ' , tag printString].			oldPkg = imPkg ifFalse: [self halt]]."	self notify: tag printString</body></methods><methods><class-id>Store.TextModification</class-id> <category>change list support</category><body package="Store-Merge" selector="category">category	^tag isForMethod		ifTrue: [ tag category ]</body><body package="Store-Merge" selector="sameAsSystem">sameAsSystem	"No record, so this is the system."	^true</body><body package="Store-Merge" selector="systemCategory">systemCategory	^tag isForMethod		ifTrue: [ tag systemCategory ]</body><body package="Store-Merge" selector="text">text	"Asnwer the text to display in a text window."	^text</body></methods><methods><class-id>Store.TextModification class</class-id> <category>instance creation</category><body package="Store-Merge" selector="tag:package:text:">tag: aTag package: aPackage text: sourceCode	^self new tag: aTag; package: aPackage; text: sourceCode</body></methods><methods><class-id>Store.PackageOwnerElement</class-id> <category>relationships</category><body package="Store-UI-Graphs" selector="elementRelatedBy:">elementRelatedBy: relToken 	"Answer a collection of related elements."	Transcript cr; show: 'PackageElement token: ', relToken, ' element: ', element printString.	Transcript cr; show: ( element relatedBy: relToken ) printString.	^element relatedBy: relToken.</body><body package="Store-UI-Graphs" selector="stringKey:">stringKey: hints	^element class == DBUserGroup		ifTrue: 			[ ( hints includes: #sort ) 				ifFalse: [ element userName, ' owns' ]				ifTrue: [ element ]			]		ifFalse: [ element stringKey: hints ]</body></methods><methods><class-id>Store.PackageOwnerElement</class-id> <category>accessing</category><body package="Store-UI-Graphs" selector="itemString">itemString	^element</body></methods><methods><class-id>Store.PundleParentMap</class-id> <category>public</category><body package="Store-IMG-Pundles" selector="reconnectParents">reconnectParents		"Changed so as to leave matching database 'unchanged.' "	| changed |	descriptions do: 		[ :descr | "		changed := descr isChangeSetEmpty. "		descr reconnect."		changed ifFalse: [ descr emptyChangeSet ].  "		]</body></methods><methods><class-id>Store.PundleParentMap</class-id> <category>initialization</category><body package="Store-IMG-Pundles" selector="initialize">initialize	self initializeList: Registry allPundles.</body><body package="Store-IMG-Pundles" selector="initialize:">initialize: aPundle	| list |	descriptions := OrderedCollection new.	list := OrderedCollection with: aPundle.	aPundle isBundle		ifTrue: [  list := list, aPundle allContainedItems ].	self initializeList: list.</body><body package="Store-IMG-Pundles" selector="initializeList:">initializeList: itemList	itemList do: 		[:pundle | 		| descr descrClass kindAndName |		descrClass := PundleParent descriptionClassForPundle: pundle.		kindAndName := descrClass pundleKind , ' "' , pundle name , '"'.		pundle hasTrace			ifTrue: 				[descr := descrClass newFrom: pundle.				descriptions add: descr]			ifFalse: 				[| mostRecent |				mostRecent := pundle classOfDbRecord mostRecentVersionOfPundleWithName: pundle name.				mostRecent isNil					ifTrue: [Dialog warn: 'The ' , kindAndName , ' has no trace and there is no published version in the database.Cannot add to the map.']					ifFalse: [(Dialog confirm: 'The ' , kindAndName , ' has no trace.The most recent published version is:' , mostRecent itemString , 'Do you want to use it as the parent?')							ifTrue: 								[descr := descrClass newFromDB: mostRecent.								descriptions add: descr								]							]			]		]</body><body package="Store-IMG-Pundles" selector="readFrom:">readFrom: aStream  	descriptions := OrderedCollection new.	[ [ | descr |	descr := PundleParent readFrom: aStream.	descriptions add: descr 	  ] repeat	] on: aStream class endOfStreamSignal do: [ :ex | ex return ]</body></methods><methods><class-id>Store.PundleParentMap</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="storeParentsOn:">storeParentsOn: aStream	descriptions do: [:descr| descr writeOn: aStream]</body><body package="Store-IMG-Pundles" selector="writeParentsToFile:">writeParentsToFile: fName	| aStream  |	aStream := fName asFilename writeStream.	[ self storeParentsOn: aStream ]		ensure: [ aStream close ]</body></methods><methods><class-id>Store.PundleParentMap class</class-id> <category>utilities</category><body package="Store-IMG-Pundles" selector="readParents">readParents	"self readParents"	| fName |	fName := Dialog requestFileName: 'Read a pundle table from:' default: 'parent.tbl'.	fName isEmpty ifTrue: [^self].	^self readParentsFromFile: fName</body><body package="Store-IMG-Pundles" selector="readParentsAndReconnect">readParentsAndReconnect	"self readParents"	| aStream baby fName |	fName := Dialog requestFileName: 'Read a pundle table from:' default: 'parent.tbl'.	fName isEmpty ifTrue: [^self].	aStream := fName asFilename readStream.	[baby := self readFrom: aStream]		ensure: [aStream close].	baby reconnectParents</body><body package="Store-IMG-Pundles" selector="readParentsAndReconnectFromFile:">readParentsAndReconnectFromFile: fName	"self readParentsAndReconnectFromFile: 'parent.tbl'"	(self readParentsFromFile: fName) reconnectParents</body><body package="Store-IMG-Pundles" selector="readParentsFromFile:">readParentsFromFile: fName	"self readParentsFromFile: 'parent.tbl'"	| aStream baby |	aStream := fName asFilename readStream.	[baby := self readFrom: aStream]		ensure: [aStream close].	^baby</body><body package="Store-IMG-Pundles" selector="writeParents">writeParents	"self writeParents"	| fName |	fName := Dialog requestNewFileName: 'Store a pundle table in:' default: 'parent.tbl'.	fName isEmpty ifTrue: [^self].	self writeParentsToFile: fName</body><body package="Store-IMG-Pundles" selector="writeParentsToFile:">writeParentsToFile: fName	"self writeParentsToFile: 'parent.tbl'"	self new writeParentsToFile: fName.</body></methods><methods><class-id>Store.PundleParentMap class</class-id> <category>instance creation</category><body package="Store-IMG-Pundles" selector="new">new 	^super new initialize</body><body package="Store-IMG-Pundles" selector="on:">on: aPundle	^super new initialize: aPundle.</body><body package="Store-IMG-Pundles" selector="readFrom:">readFrom: aStream	| baby |	baby := super new.	baby readFrom: aStream.	^baby</body></methods><methods><class-id>Store.ClassTag</class-id> <category>testing</category><body package="Store-Change Management" selector="existsInImage">existsInImage	^self actualClass notNil</body><body package="Store-Change Management" selector="isClassTag">isClassTag	^true</body><body package="Store-Change Management" selector="isForClass">isForClass	^true</body></methods><methods><class-id>Store.ClassTag</class-id> <category>private-loading</category><body package="Store-Change Management" selector="applyDefinitionFrom:">applyDefinitionFrom: aRecord 	"Load the new class from a definition contained in 	aRecord.	Return true is the operation is successful."	^(aRecord loadDefinition: aRecord definition logged: false) notNil</body><body package="Store-Change Management" selector="canLoad">canLoad	"Answer true if a record with my tag 	can be load into the image. 	For class definition it is always true."	^self isMeta		ifTrue: [super canLoad]		ifFalse: [true]</body></methods><methods><class-id>Store.ClassTag</class-id> <category>accessing</category><body package="Store-Change Management" selector="containingPackage">containingPackage	"Answer a packge that contians the 	defintion described by me."	"(ClassCommentTag newClassName: 'MethodTag class') 	containingPackage"	^Registry containingPackageForClassNamed: self className</body><body package="Store-Change Management" selector="name">name	^self className</body><body package="Store-Change Management" selector="sourceTextForImage">sourceTextForImage	| cl |	cl := self actualClass.	^cl isNil		ifTrue: [nil]		ifFalse: [cl definition]</body></methods><methods><class-id>Store.ClassTag</class-id> <category>actions</category><body package="Store-Change Management" selector="browseVersions">browseVersions  	TabApplicationSystemBrowser browseVersionsOfNamespaceOrClass: self</body><body package="Store-Change Management" selector="compileText:from:">compileText: someText from: aController 	"Compile new source for this tag.  Return True if	sucessful and False on failure."	| actualClass changedClass |	actualClass := self actualClass.	actualClass isNil ifTrue: [actualClass := nil class].	Cursor execute showWhile: [changedClass := actualClass evaluatorClass "subclassDefinerClass"					evaluate: someText string					notifying: aController					logged: true].	^changedClass ~~ nil</body><body package="Store-Change Management" selector="moveToPackage:ifNotLoaded:">moveToPackage: newPackage ifNotLoaded: aBlock 	| actual | 	actual := self actualClass.	actual notNil		ifTrue: [XChangeSet current				moveClassDefinition: actual				toPackage: newPackage]		ifFalse: [aBlock value]</body><body package="Store-Change Management" selector="removeFromSystemTolerant:fromPackage:">removeFromSystemTolerant: tolerantBoolean fromPackage: aPackage	"Remove the receiver's definition from the image if aPackage owns it. If tolerantBoolean is false, 	display an error if the definition doesn't exist."	| cls |	cls := self actualClass.	cls isNil		ifTrue: 			[ tolerantBoolean 				ifFalse: [ self error: 'Class "' , self className , '" does not exist in the image.' ]			]		ifFalse: 			[ ( aPackage hasDefinitionFor: cls )				ifTrue: [ Override unloadClassOrNameSpace: cls from: aPackage ]			]</body></methods><methods><class-id>Store.ClassTag</class-id> <category>change list support</category><body package="Store-Change Management" selector="browseSystemVersion">browseSystemVersion	"Private- Open a browser on the system version of this override."	"Assumes system version exists."	SmalltalkWorkbench browseClass: self actualClass.</body><body package="Store-Change Management" selector="fileOutObjectType">fileOutObjectType	^#class</body><body package="Store-Change Management" selector="fileOutOn:">fileOutOn: aStream 	"Fileout the system version onto aStream."	| obj |	^( obj := self actualClass ) == nil		ifFalse:  [ obj fileOutDefinitionOn: aStream ]</body><body package="Store-Change Management" selector="fileOutOn:from:">fileOutOn: aStream from: aRecord	"Fileout the change onto aStream."	aRecord fileOutDefinitionOn: aStream.</body><body package="Store-Change Management" selector="fileOutRemovalOn:">fileOutRemovalOn: aStream 	"Fileout a removal of the object from the system onto aStream."	self isMeta		ifFalse: [ aStream removeObject: symbol type: self fileOutObjectType ]</body><body package="Store-Change Management" selector="type">type	"Answer a symbol representing the sub-type of this kind of modification.	By default return #'other'."	^#'class definition'</body></methods><methods><class-id>Store.ClassTag</class-id> <category>converting</category><body package="Store-Change Management" selector="recordForPackage:">recordForPackage: aPackage	"Answer a db record from aPackage."	"double dispatch."	^aPackage recordForClassTag: self.</body></methods><methods><class-id>Store.ClassTag class</class-id> <category>accessing</category><body package="Store-Change Management" selector="tagBaseIndex">tagBaseIndex	^1		"also reserves 5 for metaclass"</body></methods><methods><class-id>Store.GraphTool</class-id> <category>graph actions</category><body package="Store-UI-Graphs" selector="beGraph">beGraph	| focus |	self graphView bm visualBuilderClass: Lens.LDMGraphBuilder.	focus := self graphView focus value.	self graphView onPerspective: self perspective.	self graphView focus: focus.</body><body package="Store-UI-Graphs" selector="beIndentedList">beIndentedList	self graphView bm visualBuilderClass: IndentedListBuilder</body><body package="Store-UI-Graphs" selector="closeAllIn">closeAllIn	graphView selectionDo: [:e | graphView browserModel body closeAllFrom: e side: 2]</body><body package="Store-UI-Graphs" selector="closeAllOut">closeAllOut	graphView selectionDo: [:e | graphView browserModel body closeAllFrom: e side: 1]</body></methods><methods><class-id>Store.GraphTool</class-id> <category>menu enabling</category><body package="Store-UI-Graphs" selector="makePundleMenuDynamic:">makePundleMenuDynamic: menu  	super makePundleMenuDynamic: menu.	self makeDynamicItem: #openOneOut selectionBlock: [self nonEmptySelection] inMenu: menu.	self makeDynamicItem: #openOneIn selectionBlock: [self nonEmptySelection] inMenu: menu.	self makeDynamicItem: #closeOneOut selectionBlock: [self nonEmptySelection] inMenu: menu.	self makeDynamicItem: #closeOneIn selectionBlock: [self nonEmptySelection] inMenu: menu.	self makeDynamicItem: #open4Out selectionBlock: [self nonEmptySelection] inMenu: menu.	self makeDynamicItem: #open4In selectionBlock: [self nonEmptySelection] inMenu: menu.	self makeDynamicItem: #openAllOut selectionBlock: [self nonEmptySelection] inMenu: menu.	self makeDynamicItem: #openAllIn selectionBlock: [self nonEmptySelection] inMenu: menu.	^menu</body></methods><methods><class-id>Store.GraphTool</class-id> <category>accessing</category><body package="Store-UI-Graphs" selector="focus:">focus: aFocus	self graphView focus: aFocus</body><body package="Store-UI-Graphs" selector="graphView">graphView	""	^graphView isNil		ifTrue:			[graphView := LensGraphView onPerspective: self perspective]		ifFalse:			[graphView]</body></methods><methods><class-id>Store.GraphTool</class-id> <category>selection</category><body package="Store-UI-Graphs" selector="nonEmptySelection">nonEmptySelection	self graphView selectionDo: [:sel | ^true].	^false</body><body package="Store-UI-Graphs" selector="pundles">pundles	| sels |	sels := List new.	self graphView selectionDo: [:each | sels add: each element].	^sels</body><body package="Store-UI-Graphs" selector="pundleVersions">pundleVersions	| sels |	sels := List new.	self graphView selectionDo: [:each | sels add: each element].	^sels</body><body package="Store-UI-Graphs" selector="selectPundle:">selectPundle: aPundle	self needsMoreWork. "due to element proxy"	self graphView select: aPundle</body></methods><methods><class-id>Store.GraphTool</class-id> <category>actions</category><body package="Store-UI-Graphs" selector="closeIn">closeIn	self graphView closeIn</body><body package="Store-UI-Graphs" selector="closeOut">closeOut	self graphView closeIn</body><body package="Store-UI-Graphs" selector="open4In">open4In	self graphView open4In</body><body package="Store-UI-Graphs" selector="open4Out">open4Out	self graphView open4Out</body><body package="Store-UI-Graphs" selector="openAllIn">openAllIn	self graphView openInLevels: 0</body><body package="Store-UI-Graphs" selector="openAllOut">openAllOut	self graphView openOutLevels: 0</body><body package="Store-UI-Graphs" selector="openOneIn">openOneIn	self graphView   openInLevels: 1</body><body package="Store-UI-Graphs" selector="openOneOut">openOneOut	self graphView  openOutLevels: 1</body><body package="Store-UI-Graphs" selector="updatePundleContents">updatePundleContents	"Reconstructs the entire graph"	self graphView focus: self graphView focus value</body><body package="Store-UI-Graphs" selector="updatePundleVersion">updatePundleVersion	"Updates the visual representation of each graph element, but no 	elements are added to or removed from the graph."	(self graphView bm body) releaseVisuals; rebuild</body></methods><methods><class-id>Store.GroupGraph</class-id> <category>interface opening</category><body package="Store-UI-Graphs" selector="postOpenWith:">postOpenWith: aBuilder 	super postOpenWith: aBuilder.	self updateGroupList.	self updateUserList.	self updateGraph.	self setButtons.</body></methods><methods><class-id>Store.GroupGraph</class-id> <category>aspects</category><body package="Store-UI-Graphs" selector="groupList">groupList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^groupList isNil		ifTrue:			[groupList := SelectionInList new]		ifFalse:			[groupList]</body><body package="Store-UI-Graphs" selector="userList">userList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^userList isNil		ifTrue:			[userList := SelectionInList new]		ifFalse:			[userList]</body></methods><methods><class-id>Store.GroupGraph</class-id> <category>accessing</category><body package="Store-UI-Graphs" selector="perspective">perspective	^#tt_containsAdjacent</body></methods><methods><class-id>Store.GroupGraph</class-id> <category>actions</category><body package="Store-UI-Graphs" selector="addToGroup">addToGroup	| user group |	user := userList selection.	group := groupList selection.	(user isNil or: [group isNil]) ifTrue: [^Dialog warn: 'Select a group and group member (user) that you wish to add before pressing this button'].	DBUserGroup newUserNamed: user inGroupNamed: group.	self updateGraph</body><body package="Store-UI-Graphs" selector="listChange">listChange	self updateGraph.	self setButtons.</body><body package="Store-UI-Graphs" selector="newGroup">newGroup	| group |	group := Dialog request: 'New Group Name:'.	group size = 0 ifTrue: [ ^self ].	( DBUserGroup newGroupNamed: group ) == nil		ifFalse:			[ self updateGroupList.			self groupList selection: group.			self updateGraph.			].</body><body package="Store-UI-Graphs" selector="newUser">newUser	| group user |	group := groupList selection.	group size = 0 ifTrue: [^Dialog warn: 'Please select a group'].	user := Dialog request: 'New user name:'.	user size = 0 ifTrue: [^self].	DBUserGroup newUserNamed: user inGroupNamed: group.	self updateUserList.	self userList selection: user.	self updateGraph.</body><body package="Store-UI-Graphs" selector="removeFromGroup">removeFromGroup	| user group |	user := userList selection.	group := groupList selection.	(user isNil or: [group isNil]) ifTrue: [^Dialog warn: 'Select a group and group member (user) that you wish to remove before pressing this button'].	DBUserGroup removeUserNamed: user inGroupNamed: group.	self updateGraph</body><body package="Store-UI-Graphs" selector="updateGraph">updateGraph	| focus cache |	focus := Set new.	cache := Dictionary new.	userList selection notNil ifTrue: [focus add: (GroupElement element: userList selection cache: cache)].	groupList selection notNil ifTrue: [focus add: (GroupElement element: groupList selection cache: cache)].	self graphView focus: focus.</body><body package="Store-UI-Graphs" selector="updateGroupList">updateGroupList	self groupList list: DBUserGroup allGroupNames asSortedCollection asOrderedCollection</body><body package="Store-UI-Graphs" selector="updateUserList">updateUserList	self userList list: DBUserGroup allUserNames asSortedCollection asOrderedCollection</body></methods><methods><class-id>Store.GroupGraph</class-id> <category>private</category><body package="Store-UI-Graphs" selector="setButtons">setButtons	| enable |	enable := ( ( userList selection ~~ nil ) and: [ groupList selection ~~ nil ] ).	( builder componentAt: #addToGroup ) isEnabled: enable.	( builder componentAt: #removeFromGroup )  isEnabled: enable.	( builder componentAt: #newUser ) isEnabled: ( groupList selection ~~ nil ).</body></methods><methods><class-id>Store.GroupGraph class</class-id> <category>class initialization</category><body package="Store-UI-Graphs" selector="initialize">initialize	"self initialize"		self initializeRelationships.	self initializePerspectives</body><body package="Store-UI-Graphs" selector="initializePerspectives">initializePerspectives	"self initializePerspectives"	^(List new) add: ((Array new: 9)			at: 1 put: #LDMPerspective;			at: 2 put: #arrRows:;			at: 3 put: 	#(#(#V1 #F1 'tt_contains' true true false true true) 						   #(#F1 #V2 'tt_contains' true true false true true) );			at: 4 put: #arrLabelHints:;			at: 5 put: #();			at: 6 put: #arrRelDesc:;			at: 7 put: ((Array new: 1)				at: 1 put: ((Array new: 5)					at: 1 put: 'tt_contains';					at: 2 put: true;					at: 3 put: #solid;					at: 4 put: ColorValue purple;					at: 5 put: 1; yourself);  yourself);			at: 8 put: #name:;			at: 9 put: #tt_containsAdjacent; yourself) decodeAsLiteralArray; yourself</body><body package="Store-UI-Graphs" selector="initializeRelationships">initializeRelationships	"self initializeRelationships"	^List new 		add: #( #LDMFirstOrderRel #name: 'tt_contains' #description: 'contains' 				#reverse: nil #token: #tt_containsRel) decodeAsLiteralArray; 		add: #( #LDMFirstOrderRel #name: 'tt_containsR' #description: 'containsR' 				#reverse: nil #token: #tt_containsRRel) decodeAsLiteralArray; yourself</body></methods><methods><class-id>Store.PrivilegeGraph</class-id> <category>private</category><body package="Store-UI-Graphs" selector="listChange">listChange	self setButtons.	self updateText.	^true.			"multi-lists  must answer true/false"</body><body package="Store-UI-Graphs" selector="perspective">perspective	^#tt_ownsAdjacent</body><body package="Store-UI-Graphs" selector="privilegeManager">privilegeManager	^DBPundlePrivileges</body><body package="Store-UI-Graphs" selector="setButtons">setButtons	"Set the enablement of the buttons. There must be a selection in both lists."	"Enable only when both a user and package are selected. Sets if the user does not	already have rights for any package selected. Revoke only if has rights for all packages selected."	| set revoke owner |	owner := userGroupList selection.	( ( owner == nil )  |  ( packageList selections size &lt; 1 ) )		ifTrue: [ set := revoke := false ]		ifFalse: 			[ set := true. revoke := true.			packageList selections do:				[ :pkg | 				( self privilegeManager privilegeForUser: owner pundle: pkg ) == nil					ifTrue: [ set := set &amp; true.  revoke := false ]					ifFalse: [ revoke := revoke &amp; true. set := false ].				]			].	( builder componentAt: #assignOwner ) widget isEnabled: set.	( builder componentAt: #grantRead ) widget isEnabled: set.	( builder componentAt: #grantPublish ) widget isEnabled: set.	( builder componentAt: #revokeRights ) widget isEnabled: revoke.</body><body package="Store-UI-Graphs" selector="setTextTo:">setTextTo: aString 	self privilegeText value: aString.</body><body package="Store-UI-Graphs" selector="updateGraph">updateGraph	| focus cache |	focus := Set new.	cache := Dictionary new.	packageList selection notNil 		ifTrue: [ focus add: 				( PackageOwnerElement element: packageList selection cache: cache )  			   ].	userGroupList selection notNil 		ifTrue: [ focus add: 				( PackageOwnerElement element: userGroupList selection cache: cache )  			   ].	self graphView focus: focus</body><body package="Store-UI-Graphs" selector="updateGraphOLD">updateGraphOLD	| focus cache |	focus := Set new.	cache := Dictionary new.	packageList selection notNil 		ifTrue: [ focus add: 				( PackageOwnerElement 					element: packageList selection  					cache: cache ) 			   ].	userGroupList selection notNil 		ifTrue: [ focus add: 					( PackageOwnerElement 						element: userGroupList selection 						cache: cache ) 			   ].	self graphView focus: focus</body><body package="Store-UI-Graphs" selector="updateGraphPLAY">updateGraphPLAY	| focus cache |	focus := Set new.	cache := Dictionary new.	packageList selection notNil 		ifTrue: [ focus add: 				( PackageOwnerElement 					element: packageList selection  					cache: cache ) 			   ].	userGroupList selection notNil 		ifTrue: [ focus add: ( DBUserGroup userNamed: userGroupList selection ) ]."					( DBPundlePrivileges forUser: userGroupList selection ) ]."	self graphView focus: focus</body><body package="Store-UI-Graphs" selector="updatePackageList">updatePackageList	| pkgs |	pkgs := pkgs := Store.Registry allPackages.	Store.Package allNames do: 	[ :name | 	( pkgs contains: [ :pkg | pkg name = name ] )		ifFalse: [ pkgs add: ( Store.Package newNamed: name ) ]	].	self packageList list: ( ( pkgs asSortedCollection: [ :a :b | a name &lt; b name ] ) asOrderedCollection )."		( Registry allPackages asSortedCollection: [ :a :b | a name &lt; b name ] ) asOrderedCollection   "</body><body package="Store-UI-Graphs" selector="updateText">updateText	| stream privs |	stream := ( String new: 100 ) writeStream.	privs := OrderedCollection new.	userGroupList selection notNil 		ifTrue: [ privs addAll: ( self privilegeManager allPrivilegesFor: userGroupList selection ) ].	packageList selections size &gt; 0		ifTrue: 			[ packageList selections do:				[ :pkg | privs addAll: ( self privilegeManager allPrivilegesForPundle: pkg ) ]			].	privs asSet asSortedCollection do: 		[ :priv | stream nextPutAll:  priv fullDescription; cr ].	self setTextTo: stream contents.</body><body package="Store-UI-Graphs" selector="updateUserGroupList">updateUserGroupList	| users |	users := DBUserGroup allDistinctUserGroups asSet.	users addAll: Store.DBPundlePrivileges allDistinctUserGroups.	userGroupList list:  users asSortedCollection asOrderedCollection."		( DBUserGroup allUserNames asOrderedCollection, 			  DBUserGroup allGroupNames asOrderedCollection		 ) asSortedCollection asOrderedCollection"</body></methods><methods><class-id>Store.PrivilegeGraph</class-id> <category>actions</category><body package="Store-UI-Graphs" selector="assignOwner">assignOwner	self grant: #owner</body><body package="Store-UI-Graphs" selector="grant:">grant: aSymbol	| owner |	owner  := userGroupList selection.	packageList selections do:		[ :pkg | self privilegeManager grant: aSymbol to: owner for: pkg  ].	self updateText.	self setButtons.</body><body package="Store-UI-Graphs" selector="grantPublish">grantPublish	self grant: #publish</body><body package="Store-UI-Graphs" selector="grantRead">grantRead	self grant: #read</body><body package="Store-UI-Graphs" selector="revokeRights">revokeRights	| owner |	owner  := userGroupList selection.	packageList selections do:		[ :pkg | self privilegeManager revokeAllFor: owner for: pkg ].	self updateText.	self setButtons.</body></methods><methods><class-id>Store.PrivilegeGraph</class-id> <category>aspects</category><body package="Store-UI-Graphs" selector="packageList">packageList	^packageList isNil		ifTrue: [ packageList := MultiSelectionInList new ]		ifFalse: 	[ packageList ]</body><body package="Store-UI-Graphs" selector="privilegeText">privilegeText	^privilegeText isNil		ifTrue: [ privilegeText := String new asValue ]		ifFalse: 	[ privilegeText ]</body><body package="Store-UI-Graphs" selector="userGroupList">userGroupList	^userGroupList isNil		ifTrue: [ userGroupList := SelectionInList new ]		ifFalse: 	[ userGroupList ]</body></methods><methods><class-id>Store.PrivilegeGraph</class-id> <category>interface opening</category><body package="Store-UI-Graphs" selector="postOpenWith:">postOpenWith: aBuilder 	super postOpenWith: aBuilder.	self updateUserGroupList.	self updatePackageList.	self setButtons.	self updateText.	self mainWindow label: 'Package - User / Group Privliges'</body></methods><methods><class-id>Store.PrivilegeGraph class</class-id> <category>class initialization</category><body package="Store-UI-Graphs" selector="initialize">initialize	"self initialize"		self initializeRelationships.	self initializePerspectives</body><body package="Store-UI-Graphs" selector="initializePerspectives">initializePerspectives	"self initializePerspectives"	^List new 		add: ( ( Array new: 9 )			at: 1 put: #LDMPerspective;			at: 2 put: #arrRows:;			at: 3 put: 	#(#(#V1 #F1 'tt_owns' true true false true true) 						   #(#F1 #V2 'tt_owns' true true false true true) );			at: 4 put: #arrLabelHints:;			at: 5 put: #();			at: 6 put: #arrRelDesc:;			at: 7 put: ((Array new: 1)				at: 1 put: ((Array new: 5)					at: 1 put: 'tt_owns';					at: 2 put: true;					at: 3 put: #solid;					at: 4 put: ColorValue purple;					at: 5 put: 1; yourself);  yourself);			at: 8 put: #name:;			at: 9 put: #tt_ownsAdjacent; yourself) decodeAsLiteralArray; yourself</body><body package="Store-UI-Graphs" selector="initializeRelationships">initializeRelationships	"self initializeRelationships"	^List new 		add: #( #LDMFirstOrderRel #name: 'tt_owns'  #description: 'owns'  					#reverse: nil  #token: #tt_ownsRel ) decodeAsLiteralArray; 		add: #( #LDMFirstOrderRel #name: 'tt_ownsR' #description: 'is owned' 					#reverse: nil #token: #tt_ownsRRel ) decodeAsLiteralArray; 		add: #( #LDMFirstOrderRel #name: 'tt_read'  #description: 'reads'  					#reverse: nil  #token: #tt_readRel ) decodeAsLiteralArray; 		add: #( #LDMFirstOrderRel #name: 'tt_readR' #description: 'is read' 					#reverse: nil #token: #tt_readRRel ) decodeAsLiteralArray; 		add: #( #LDMFirstOrderRel #name: 'tt_publish'  #description: 'can publish'  					#reverse: nil  #token: #tt_publish ) decodeAsLiteralArray; 		add: #( #LDMFirstOrderRel #name: 'tt_publishR' #description: 'can be published' 					#reverse: nil #token: #tt_publishRRel ) decodeAsLiteralArray; 		yourself</body></methods><methods><class-id>Store.PackageMethodsBrowserHelper</class-id> <category>list accessing</category><body package="Store-UI-Browser" selector="dataForModelIn:">dataForModelIn: packages	| name newList |	newList := OrderedCollection new.	name := self selectedModel absoluteName.	packages do:		[ :pkg | newList addAll: 			( pkg dataForNamed: name andProtocol: self protocol asSymbol )		].	^newList.</body><body package="Store-UI-Browser" selector="generateNewList">generateNewList	^self browser generateMethodsFor: selectionId</body><body package="Store-UI-Browser" selector="howManySelections">howManySelections	| cnt |	^( cnt := super howManySelections ) == 0		ifFalse: [ cnt ]		ifTrue: 			[ module forcedValue == nil				ifTrue: [ 0 ]				ifFalse: [ 1 ].			].</body><body package="Store-UI-Browser" selector="methodsForClassIn:">methodsForClassIn: packages	| name newList |	newList := OrderedCollection new.	name := self selectedModel absoluteName.	packages do:		[ :pkg | newList addAll: 		( pkg methodsForClassNamed: name  				  andProtocol: self protocol 				  meta: self isMeta		)		].	^newList.</body><body package="Store-UI-Browser" selector="selection">selection	| sel |	^( sel := super selection ) == nil		ifTrue: [ module forcedValue ]		ifFalse: [ sel ].</body><body package="Store-UI-Browser" selector="selectionChanged">selectionChanged	self setSelection.	self nextModule == nil 		ifTrue: [ super selectionChanged ]		ifFalse: [ self browser batchUpdates: [ self nextModule updateList	] ]</body><body package="Store-UI-Browser" selector="selections">selections	| sels val |	^( sels := super selections ) isEmpty		ifTrue: 			[ ( val := module forcedValue ) == nil				ifTrue: [ sels ]				ifFalse: [ OrderedCollection with: val ]			 ]		ifFalse: [ sels ].</body><body package="Store-UI-Browser" selector="updateListFull">updateListFull	( self selectedModel == nil ) 		ifTrue: [ ^self setNewList: List new ].	self setNewList: self generateNewList.</body></methods><methods><class-id>Store.PackageMethodsBrowserHelper</class-id> <category>testing</category><body package="Store-UI-Browser" selector="selectionIsforData">selectionIsforData	^( self selection notNil ) and:		[ self isData | self selection isForData ]</body></methods><methods><class-id>Store.PackageMethodsBrowserHelper</class-id> <category>visual blocks</category><body package="Store-UI-Browser" selector="itemIsInPackage:">itemIsInPackage: anItem	self package == nil	ifTrue: [ ^false ].	^anItem isForData		ifTrue:			[ self package 				includesDataKey: anItem dataKey 				ownerName: anItem environmentString			]		ifFalse:			[ self package 				includesSelector: anItem selector 				className: anItem className 				meta: anItem isMeta			]</body><body package="Store-UI-Browser" selector="textEmphasisForItem:">textEmphasisForItem: anItem	^anItem isForData		ifTrue:			[ self emphasizer 				emphasisForStaticDefinition: anItem				for: self browser 				id: self selectionId			]		ifFalse: 			[ self emphasizer 				emphasisForMethodDefinition: anItem				for: self browser 				id: self selectionId			]</body></methods><methods><class-id>Store.PackageMethodsBrowserHelper</class-id> <category>initialization</category><body package="Store-UI-Browser" selector="postBuildWith:">postBuildWith: aBuilder		self setVisualBlocksWith: aBuilder</body></methods><methods><class-id>Store.PackageMethodsBrowserHelper</class-id> <category>text processing</category><body package="Store-UI-Browser" selector="acceptTextForData:from:">acceptTextForData: text from: textController	^[ self forceIfForPackage: [ super acceptTextForData: text from: textController ] ]  		on: RedefinitionNotification 		do: [ :note | RedefinitionNotification interactiveHandler: note forcedPackage: self package].</body><body package="Store-UI-Browser" selector="acceptTextForMethod:from:">acceptTextForMethod: text from: textController		^[ self forceIfForPackage: [ super acceptTextForMethod: text from: textController ] ]  		on: RedefinitionNotification 		do: [ :note | RedefinitionNotification interactiveHandler: note forcedPackage: self package ].</body><body package="Store-UI-Browser" selector="doItReceiver">doItReceiver	| sel cls |	sel := self selection.	^( sel == nil or: [ sel isForData ] )		ifTrue: [ nil ]		ifFalse: 			[ ( cls := sel implementingClass ) == nil				ifFalse: [ cls instanceBehavior ]			]</body><body package="Store-UI-Browser" selector="explainerClass">explainerClass	| sel |	^( ( ( sel := self selection ) == nil ) or: [ sel isForData ] )		ifTrue: [ nil ]		ifFalse: [ sel implementingClass ]</body></methods><methods><class-id>Store.PackageMethodsBrowserHelper</class-id> <category>private</category><body package="Store-UI-Browser" selector="decorate:">decorate: descriptor	| des target |	( target := self selectedModel ) == nil 		ifTrue: [ ^BrowserListEntry value: descriptor type: nil ].	"ignore"	des := descriptor isSymbol  	"gets called when setting selection"		ifTrue: 			[ ( target isForClass  and: [ self isData not ] )				ifTrue: 					[ MethodDescriptor 						fromSelector: descriptor 						className: target absoluteName 						meta: self isMeta 					]				ifFalse: 					[ DatumDescriptor						fromDataKey: descriptor 						owner: self target					]			]		ifFalse: [ descriptor ].	^des isForData		ifTrue: [ BrowserListEntry value: des type: #variable ]		ifFalse: [ BrowserListEntry value: des type: nil ].</body><body package="Store-UI-Browser" selector="defaultFileName">defaultFileName	| fileName many one |	fileName := self selectedModel == nil		ifTrue: [ ( self selections first ownerName tokensBasedOn: $.) last, '-' ]  		ifFalse: [ self selectedModel name, '-' ].	( self selections first isForData )		ifTrue: 			[ many := 'data'.  			one := self selections first dataKey 			]		ifFalse:			[ many := 'methods'.  			one := self selections first selector copyWithout: $:.			].	^self selections size &gt; 1		ifTrue: [ fileName, many, '.st' ]		ifFalse: [ fileName, one, '.st' ].</body><body package="Store-UI-Browser" selector="definitionOf:">definitionOf: anItem	self package == nil ifTrue: [ ^nil ].	^( self package isLoaded and: [ anItem isLoaded ] )		ifFalse: [ nil ]		ifTrue: 			[ anItem isForGeneral 				ifTrue: [  BindingReference simpleName: anItem dataKey in: anItem owner ]				ifFalse: [ anItem ]			]</body><body package="Store-UI-Browser" selector="loadList:">loadList: list		"Load a list of published methods or data."	| imPkg |	imPkg := Registry packageNamed: self package name.	imPkg == nil		ifTrue: [ ^Dialog warn: 'No loaded plackage: ', self package name ].	list do: 		[ :item | 		item isPseudo			ifTrue: [ Dialog warn: item displayString, ' is not defined in this plackage.' ]			ifFalse: [ item loadSrcIntoPackage: imPkg confirm: true ]		]</body><body package="Store-UI-Browser" selector="packagesForSelectedClassOrNameSpace">packagesForSelectedClassOrNameSpace	| packages |	self selectedModel == nil	 ifTrue: [ ^OrderedCollection new ].	self isFilteredByPackage		ifTrue: [ packages := Array with: self package ] 		ifFalse: 			[ packages := OrderedCollection new.			Registry 				packagesContaining: self selectedModel				do: [ :pkg | packages add: pkg ].			].	^packages</body><body package="Store-UI-Browser" selector="selectVersion:">selectVersion: anItem 		anItem == nil		ifTrue: [ ^nil ].	^anItem isForData		ifTrue: [ DataElement selectVersionNamed: anItem dataKey in: anItem ownerName ]		ifFalse: [ Method selectVersionNamed: anItem selector					in: anItem ownerName meta: anItem isMeta ].</body><body package="Store-UI-Browser" selector="selectVersion:in:">selectVersion: aMethodOrData  in: aClassOrNameSpace 	( aClassOrNameSpace == nil ) | ( aMethodOrData == nil )		ifTrue: [ ^nil ].	^( aClassOrNameSpace isForNameSpace  or: [ self isData ] )		ifTrue: [ DataElement selectVersionNamed: aMethodOrData dataKey					in: aClassOrNameSpace absoluteName ]		ifFalse: [ Method selectVersionNamed: aMethodOrData selector					in: aClassOrNameSpace absoluteName meta: self isMeta  ].</body><body package="Store-UI-Browser" selector="targetCompiler">targetCompiler	^self selectedModel isForClass		ifTrue: [ self selectedModel  actual ]		ifFalse: [ Compiler ]</body></methods><methods><class-id>Store.PackageMethodsBrowserHelper</class-id> <category>actions</category><body package="Store-UI-Browser" selector="fileOut">fileOut	| fileName aFileManager |	self selections == nil ifTrue: [ ^self ].	fileName := Dialog requestNewFileName: 'File the package out on:'  default: self defaultFileName.	fileName isEmpty ifTrue: [ ^nil ].	aFileManager := SourceCodeStream  write: fileName.	[ Cursor wait showWhile:		[ aFileManager timeStamp.		aFileManager deferInitializations.		self selections do:			[ :sel | sel fileOutOn: aFileManager ].		aFileManager finishInitializations		]	] ensure: [ aFileManager close ].</body><body package="Store-UI-Browser" selector="inspectMethod">inspectMethod	"Inspect the current method."	self selection inspect</body><body package="Store-UI-Browser" selector="remove">remove	self selections isEmpty		ifTrue: [ ^false ].	self package isLoaded		ifFalse: [ self warnPackageNotLoaded.  ^false ].	self changeRequest ifFalse: [ ^self ].	( Dialog confirm: 'Remove these items?' for: self interfaceWindow )		ifFalse: [ ^self ].	( self selections first isForData ) 		ifTrue: [ self selections do: [ :dd | self removeShared: dd ] ]		ifFalse: 	[ self selections do: [ :md | self removeMethod: md ] ].	module updateList.</body><body package="Store-UI-Browser" selector="removeMethod:">removeMethod: methodDefinition	"Remove a method from the system or restore an overridden definition."	| cls selector overs choice |	cls := methodDefinition implementingClass.	selector := methodDefinition selector.	( overs := Override overridesForSelector: selector class: cls ) == nil		ifTrue: [ ^cls removeSelector: selector ].	choice := self overrideActionDialog: overs.	choice == false ifTrue: [ ^self ].	choice == true ifTrue: [ ^cls removeSelector: selector ].	choice isOverride		ifTrue: [ Override reinstall: choice list: overs ]		ifFalse: [ Override removeOverridesForSelector: selector class: cls in: choice ]</body><body package="Store-UI-Browser" selector="removeShared:">removeShared: dataDescription	"Remove a shared variable from the system or restore an overridden definition."	| overs choice ns bind |	ns := dataDescription nameSpace.	( bind := ns bindingFor: dataDescription dataKey ) == nil		ifTrue: [ ^self ].	( overs := Override overridesForDataKey: dataDescription dataKey in: ns namedReferent ) == nil		ifTrue: [ ^ns removeBinding: bind ].	choice := self overrideActionDialog: overs.	choice == false ifTrue: [ ^self ].	choice == true ifTrue: [ ^ns removeBinding: bind  ].	choice isOverride		ifTrue: [ Override reinstall: choice list: overs ]		ifFalse: [ Override removeOverridesForDataKey: dataDescription dataKey in: ns namedReferent in: choice ]</body><body package="Store-UI-Browser" selector="spawn">spawn"	self isPackageLoaded		ifTrue: [ ^super spawn ]."	  self spawningBrowserClass 			openOnPackage: self package methods: self selections.</body></methods><methods><class-id>Store.PackageMethodsBrowserHelper</class-id> <category>menus</category><body package="Store-UI-Browser" selector="actionsForMultiSelect">actionsForMultiSelect	^super actionsForMultiSelect, 		#(#moveToPackage #revertToPreviousVersion #loadSelection)</body><body package="Store-UI-Browser" selector="actionsForStaticsOnly">actionsForStaticsOnly	^super actionsForStaticsOnly, #( #inpectData )</body><body package="Store-UI-Browser" selector="actionsForUnloadedPackages">actionsForUnloadedPackages	^#(  fileOut #spawn #loadSelection #browseVersions #compareWithImage 			#compareWithVersion #findPackage )</body><body package="Store-UI-Browser" selector="initializeStatic">initializeStatic	self selection == nil ifTrue: [ ^self ].	self selections do:		[ :s |		s isForData ifFalse: [ ^self ].		s isLoaded			ifFalse: [  ^self warnPackageNotLoaded ].		( s nameSpace bindingFor: s dataKey ) reinitializeValue		].</body><body package="Store-UI-Browser" selector="menuHeader">menuHeader	^selectionId isInteger		ifTrue: [ self class menuHeader, selectionId printString ]		ifFalse: [ self class menuHeader ]</body><body package="Store-UI-Browser" selector="setEnablement:">setEnablement: menu	"Set the menu's items enabled/disabled state."	"Since loaded and unloaded not in the same browser we only have to disable things."	"Don't override a menu items particular enablement"	menu enablementSelector == nil		ifFalse: [ ^menu ].	super setEnablement: menu.	self selection == nil		ifTrue: [ ^menu ].	self selection isLoaded 		ifTrue: [ ^menu ].	self menu: menu do: 		[ :item | 		( self actionsForUnloadedPackages includes: item nameKey )			ifFalse: [ item disable ]		].</body></methods><methods><class-id>Store.PackageMethodsBrowserHelper</class-id> <category>selections</category><body package="Store-UI-Browser" selector="itemForPackage:">itemForPackage: item	| obj |	item isForData		ifTrue: 			[ ( obj := self package datum: item dataKey forNamed: item ownerName ) == nil				ifTrue: [ obj := PseudoSubdef dataKey: item dataKey owner: item ownerName ].			]		ifFalse: 			[ ( obj := self package method: item selector forClassNamed: item ownerName meta: item isMeta ) == nil				ifTrue: [ obj := PseudoSubdef selector: item selector owner: item ownerName ].			].	^obj.</body><body package="Store-UI-Browser" selector="selectedClassOrNameSpace">selectedClassOrNameSpace	| env |	self isPackageLoaded ifFalse: [ ^nil ].	"selected class/namespace not in image."	^env := ( env := self selected: #model ) == nil		ifTrue: [ ^nil ]		ifFalse: 			[ env isDataModel 				ifTrue: [ env actual ]				ifFalse: [ env ]			].</body><body package="Store-UI-Browser" selector="selectedModel">selectedModel	^self selected: #model</body><body package="Store-UI-Browser" selector="selector">selector	| sel |	^( sel := self selection ) isForMethod		ifTrue: [ sel selector ]</body><body package="Store-UI-Browser" selector="targetClass">targetClass	| env |	^( env := self selectedClassOrNameSpace ) == nil		ifTrue: [ nil ]		ifFalse: 			[ env isForNameSpace ifTrue: [ ^nil ].			env isDataModel 				ifTrue: [ env actual ]				ifFalse: 					[ self isMeta						ifTrue: [ env instanceBehavior class ]						ifFalse: [ env ]						]			]</body><body package="Store-UI-Browser" selector="targetClassOrNameSpace">targetClassOrNameSpace	| env |	env := ( env := self selectedClassOrNameSpace ) == nil		ifTrue: [ ^nil ]		ifFalse: 			[ env isDataModel 				ifTrue: [ env actual ]				ifFalse: [ env ]			].	^self isData		ifTrue: [ env asNameSpace ]		ifFalse: [ env ]</body></methods><methods><class-id>Store.PackageMethodsBrowserHelper</class-id> <category>accessing</category><body package="Store-UI-Browser" selector="windowLabel">windowLabel	| first |	( self isPackageLoaded and: [ self selectedClassOrNameSpace ~~ nil ] )		ifTrue: [ ^super windowLabel ].	first := self selectedModel == nil			ifTrue: [ self package == nil ifTrue: [ '' ] ifFalse: [ self package itemString ] ]			ifFalse: [ self selectedModel itemString ].		^self protocol == nil		ifTrue: 			[ module hasList 				ifTrue: [ '&lt;1p&gt; Message Browser' expandMacrosWith: first ]				ifFalse: [ '&lt;1p&gt; &lt;2s&gt; Method Browser' 							expandMacrosWith: first 							with: ( SystemUtils convertAbsoluteNameToFull: self list first value ownerName )						  ]			]		ifFalse: 			[ | stream |			stream := String new writeStream.			self protocols 				do: [ :p | stream nextPutAll: p ]				separatedBy: [ stream nextPutAll: ', ' ]. 			'&lt;1p&gt; {&lt;2s&gt;} Message Category Browser' 				expandMacrosWith: first with: stream contents			]</body></methods><methods><class-id>Store.PackageMethodsBrowserHelper</class-id> <category>menus accessing</category><body package="Store-UI-Browser" selector="enhance:for:submenu:sending:">enhance: menu for: md submenu: nameKey sending: msg	| item |	md == nil 		ifTrue: 			[ ( item := menu atNameKey: nameKey ) ~~ nil				ifTrue: [ item enabled: false; submenu: nil ]			]		ifFalse: [ super enhance: menu for: md submenu: nameKey sending: msg ]</body><body package="Store-UI-Browser" selector="getListMenu:">getListMenu: forMenuBar	| menu sel md |	menu := forMenuBar			ifTrue: [self  getStoreMenuBarMenu]			ifFalse: [self getListMenu].	menu == nil ifTrue: [menu := Menu new].	self setEnablement: menu.	self isPackageLoaded 		ifTrue: 			[ md := ( (sel := self selection) == nil )				ifTrue: [ nil ]				ifFalse: [ self definitionOf: sel ]			].	( md == nil or: [ md isBindingReference] )		ifTrue:			[ self enhance: menu for: md				submenu: #allSenders				sending: #browseAllStaticReferences:.			md := nil.			]		ifFalse:			[ self enhance: menu for: md				submenu: #allSenders				sending: #browseAllReferences:.			].	self enhance: menu for: md		submenu: #allImplementors		sending: #browseAllImplementors:.	self enhance: menu for: md		submenu: #localSenders		sending: #browseLocalReferences:.	self enhance: menu for: md		submenu: #localImplementors		sending: #browseLocalImplementors:.	^menu</body></methods><methods><class-id>Store.PackageMethodsBrowserHelper</class-id> <category>drag and drop</category><body package="Store-UI-Browser" selector="addClientDataTo:">addClientDataTo: anIdentityDict	self isPackageLoaded ifFalse: [ ^false ].		"don't drag from unloaded packages."	self selections isEmpty ifTrue: [ ^false ].	self targetClassOrNameSpace == nil ifTrue: [ ^false ].	anIdentityDict		at: self storePackageKey put: self package;		at: self storeMethodKey put: self selections;		at: self classOrNamespaceKey put: self targetClassOrNameSpace.	self selections first isForMethod		ifTrue:			[ anIdentityDict at: self class selectorKey put:				( self selections collect: [ :m | m selector ] ).			anIdentityDict at: self classOrNamespaceKey put:				( self targetClassOrNameSpace fullName )			]		ifFalse:			[ anIdentityDict at: self class staticKey put:				( self selections collect: [ :m | m dataKey ] ).			].	^true.</body><body package="Store-UI-Browser" selector="getDragDropKey">getDragDropKey	"return the data key for the drag"	^self storeStaticKey.</body></methods><methods><class-id>Store.PackageMethodListBrowserHelper</class-id> <category>list accessing</category><body package="Store-UI-Browser" selector="updateListFull">updateListFull		"This is a fixed list brower...So only remove removed methods"	| list |	self package == nil ifTrue: [ ^self ].	self package isLoaded ifFalse: [ ^self ]. 	"ignore it.""	list := self list collect: [ :entry | entry value ].	list := list select: [ :md | self package includesMethod: md ].			self setNewList: list asList."</body></methods><methods><class-id>Store.PackageMethodListBrowserHelper</class-id> <category>text processing</category><body package="Store-UI-Browser" selector="acceptText:from:">acceptText: text from: textController	| newSelector targetClass protocol |	self selection == nil		ifTrue: [ ^nil ].	protocol := self selection protocol.	self selection isLoaded		ifFalse: [ self warnPackageNotLoaded. ^false ].	( targetClass := self selection myClass ) == nil		ifTrue: [ ^Dialog warn: 'Class not loaded.' ].	[ newSelector := self forceIfForPackage: 		[  targetClass compile: text classified: protocol notifying: textController ] 	] on: RedefinitionNotification 	 do: [ :note | RedefinitionNotification interactiveHandler: note forcedPackage: self package ].	^newSelector ~~ nil</body></methods><methods><class-id>Store.PackageMethodListBrowserHelper</class-id> <category>visual blocks</category><body package="Store-UI-Browser" selector="textForItem:">textForItem: anItem	^( anItem isForData		ifTrue: [ anItem displayString ]		ifFalse: [ anItem asMethodString ]	) asText</body></methods><methods><class-id>Store.PackageMethodListBrowserHelper</class-id> <category>drag and drop</category><body package="Store-UI-Browser" selector="addClientDataTo:">addClientDataTo: anIdentityDict	self isPackageLoaded ifFalse: [ ^false ].		"don't drag from unloaded packages."	self selections isEmpty ifTrue: [ ^false ].	anIdentityDict		at: self storePackageKey put: self package;		at: self storeMethodKey put: self selections.	^true.</body></methods><methods><class-id>Store.PackageMethodsEditorHelper</class-id> <category>menus</category><body package="Store-UI-Browser" selector="actionsForMultiSelect">actionsForMultiSelect	^#( )</body><body package="Store-UI-Browser" selector="actionsForUnloadedPackages">actionsForUnloadedPackages	^#(  #loadSelection #compareWithImage #compareWithVersion #findPackage #removeFromPackage )</body><body package="Store-UI-Browser" selector="browseVersions">browseVersions	"remove this menu item."</body><body package="Store-UI-Browser" selector="initializeData">initializeData	"remove this menu item."</body><body package="Store-UI-Browser" selector="inspectData">inspectData	"remove this menu item."</body><body package="Store-UI-Browser" selector="moveToPackage">moveToPackage	"remove this menu item."</body><body package="Store-UI-Browser" selector="openResourceEditor">openResourceEditor	"remove this menu item."</body><body package="Store-UI-Browser" selector="revert">revert	"remove this menu item."</body></methods><methods><class-id>Store.PackageMethodsEditorHelper</class-id> <category>visual blocks</category><body package="Store-UI-Browser" selector="textForItem:">textForItem: anItem	^anItem fullDisplayString asText</body></methods><methods><class-id>Store.PackageMethodsEditorHelper</class-id> <category>actions</category><body package="Store-UI-Browser" selector="removeFromPackage">removeFromPackage	( Dialog confirm: 'Permanently remove from package?' )		ifTrue: 			[  self selection isForMethod				ifTrue: [ self package removeDBMethod: self selection ]				ifFalse: [ self package removeDBDatum: self selection ]			]</body></methods><methods><class-id>Store.PackageComparisonEmphasizer</class-id> <category>private-status</category><body package="Store-UI-Comparitors" selector="classButtonsStatus:criteria:">classButtonsStatus: behavior criteria:cset	| cc |	cc := cset at: behavior absoluteSymbol ifAbsent: [ ^#( #( ) #( ) #( ) ) ].	cc getDataChangesIfNone: [ #( ) ].	^Array		with: ( ( cc isMetaModified: false ) 				ifTrue: [ #( change ) ]  ifFalse: [ #( ) ] )		with: ( ( cc isMetaModified: true )				ifTrue: [ #( change ) ]  ifFalse: [ #( ) ] )		with: ( ( cc isDataModified  )				ifTrue: [ #( change ) ]  ifFalse: [ #( ) ] )</body><body package="Store-UI-Comparitors" selector="classOrNameSpaceStatus:criteria:">classOrNameSpaceStatus: aClassOrNameSpace  criteria: changeSet	| changes |	changes := changeSet at: aClassOrNameSpace absoluteSymbol ifAbsent: [ ^#( ) ].		^self statusFromChanges: changes.</body><body package="Store-UI-Comparitors" selector="dataDefinitionStatus:criteria:">dataDefinitionStatus: aStaticDef  criteria: changeSet 	| changes |	changes := changeSet at: aStaticDef ownerName asSymbol ifAbsent: [ ^#( ) ].	changes := ( changes getDataChangesIfNone: [ ^#( ) ] ) 					at: aStaticDef dataKey ifAbsent: [ ^#( ) ].	^self statusFromChange: changes.</body><body package="Store-UI-Comparitors" selector="dataKeyStatus:owner:criteria:">dataKeyStatus: aKey owner: anOwner criteria: changeSet 	| changes |	changes := changeSet at: anOwner absoluteSymbol ifAbsent: [ ^#( ) ].	changes := ( changes getDataChangesIfNone: [ ^#( ) ] ) 					at: aKey ifAbsent: [ ^#( ) ].	^self statusFromChange: changes.</body><body package="Store-UI-Comparitors" selector="methodDefinitionStatus:criteria:">methodDefinitionStatus: aMethodDef  criteria: changeSet 	| changes |	changes := changeSet at: aMethodDef className asClassNameOnly asSymbol ifAbsent: [ ^#( ) ].	changes := ( changes getMethodChangesMeta: aMethodDef isMeta ifNone: [ ^#( ) ] ) 					at: aMethodDef selector ifAbsent: [ ^#( ) ].	^self statusFromChange: changes.</body><body package="Store-UI-Comparitors" selector="selectorStatus:class:criteria:">selectorStatus: aSelector class: aClass  criteria: changeSet 	| changes |	changes := changeSet at: aClass absoluteSymbol ifAbsent: [ ^#( ) ].	changes := ( changes getMethodChangesMeta: aClass isMeta ifNone: [ ^#( ) ] ) 					at: aSelector ifAbsent: [ ^#( ) ].	^self statusFromChange: changes.</body></methods><methods><class-id>Store.PackageComparisonEmphasizer</class-id> <category>private</category><body package="Store-UI-Comparitors" selector="currentCriteria:id:">currentCriteria: aBrowser id: selectionId	"Answer what we are highlighting based on."		^aBrowser changes changeSetFor: selectionId</body><body package="Store-UI-Comparitors" selector="emphasisForAttribute:">emphasisForAttribute: status	"Answer an array of emphasis for status. Default mapping is:		#change		red		#added			green		#removed		strikeout"	( status ==  #change )  		ifTrue: [ ^#( bold ) ].	( status ==  #add )  		ifTrue: [ ^Array with: ( #color-&gt;ColorValue red ) with: #bold ].	( status ==  #remove )  		ifTrue: [ ^#( #bold #strikeout ) ].	^#( norm )</body><body package="Store-UI-Comparitors" selector="statusFromChange:">statusFromChange: aSymbol	^Array with: aSymbol</body><body package="Store-UI-Comparitors" selector="statusFromChanges:">statusFromChanges: changes	changes isAdded		ifTrue: [ ^#( #add ) ].	changes isDefinitionRemoved		ifTrue: [ ^#( #remove ) ].	( ( changes isChanged )  |  ( changes isRelocated )  |  ( changes isRenamed  ) )		ifTrue: [ ^#( #change ) ].	^#( ).</body></methods><methods><class-id>Store.PackageComparisonEmphasizer</class-id> <category>api</category><body package="Store-UI-Comparitors" selector="emphasisForClassButtons:for:id:">emphasisForClassButtons: aModel for: aBrowser id: selectionId	"Answer an array of emphasis sets for aBehavior (class or metaclass)	for the instance, class and static buttons."	| criteria stats |	( ( ( criteria := self currentCriteria: aBrowser id: selectionId ) == nil ) or: [ aModel == nil ] ) 		ifTrue: [ ^#( #( #norm ) #( #norm ) #( norm ) ) ].	^aModel isForNameSpace		ifTrue: [ Array with: #( #norm ) with: #( #norm ) with: #( #norm ) ]		ifFalse:			[ stats := self classButtonsStatus: aModel criteria:criteria.			stats collect: [ :stat | self  mapStatusToEmphasis: stat ]			]</body><body package="Store-UI-Comparitors" selector="emphasisForProtocol:for:id:">emphasisForProtocol: aProtocol for: aBrowser id: selectionId	"Answer the emphasis set for aProtocol displayed in aBrowser with a selectionId."	| criteria owner status |	( criteria := self currentCriteria: aBrowser id: selectionId ) == nil		ifTrue: [ ^#( #norm ) ].	( owner := aBrowser selectedModelFor: selectionId ) == nil		ifTrue: [ ^#( #norm ) ].	^#( )		"for now""	status := ( owner isForNameSpace or: [ aBrowser isData ] )		ifTrue: [ self dataProtocolStatus: aProtocol model: owner criteria: criteria ]		ifFalse: [ self methodProtocolStatus: aProtocol classModel: owner criteria: criteria ].	^self  mapStatusToEmphasis: status."</body></methods><methods><class-id>Store.BundleTabApplication</class-id> <category>componentBuilding</category><body package="Store-UI-Browser" selector="buildComponentArray">buildComponentArray	components := List new.	components add:  self classesComponent.	components add: self protocolsComponent.	components add: self methodsComponent.	self linkComponentsInArray: components.	self linkFirstComponentToSubcanvas.</body><body package="Store-UI-Browser" selector="classesComponent">classesComponent	^SimpleBrowserModule new		helperType: PackageClassesBrowserHelper</body><body package="Store-UI-Browser" selector="componentId">componentId	^#packageTab</body><body package="Store-UI-Browser" selector="methodListComponent">methodListComponent	^SimpleBrowserModule new		helperType: PackageMethodListBrowserHelper</body><body package="Store-UI-Browser" selector="methodsComponent">methodsComponent	^SimpleBrowserModule new		helperType: PackageMethodsBrowserHelper</body><body package="Store-UI-Browser" selector="packageComponent">packageComponent	^SimpleBrowserModule new		helperType: PackageBrowserHelper.</body><body package="Store-UI-Browser" selector="packageHierachyComponent">packageHierachyComponent	^HierarchicalBrowserModule new		helperType: PundleHierarchyBrowserHelper.</body><body package="Store-UI-Browser" selector="protocolsComponent">protocolsComponent	^SimpleBrowserModule new		specName: #listSpecProtocols;		helperType: PackageProtocolBrowserHelper</body><body package="Store-UI-Browser" selector="protocolsComponentNoButtons">protocolsComponentNoButtons	^SimpleBrowserModule new		helperType: PackageProtocolBrowserHelper</body><body package="Store-UI-Browser" selector="setComponentIds:to:">setComponentIds: aComponentList to: anId	aComponentList do:		[ :comp | comp helpers do: [ :h | h selectionId: anId ] ]</body></methods><methods><class-id>Store.BundleTabApplication</class-id> <category>accessing</category><body package="Store-UI-Browser" selector="dbManager">dbManager	^DbRegistry</body><body package="Store-UI-Browser" selector="defaultEmphasizer">defaultEmphasizer	^CachingPackageEmphasizer new.</body><body package="Store-UI-Browser" selector="icon">icon	^icon isNil 		ifTrue: [ icon := self eraseBackgroundOnImage: (self class packageIcon)] 		ifFalse:[ icon ]</body><body package="Store-UI-Browser" selector="isFilteredByPackage">isFilteredByPackage	^packageFilter</body><body package="Store-UI-Browser" selector="label">label	^self canvas selection isNil 		ifTrue:[ self class label ] 		ifFalse:[ self canvas selection name ]</body><body package="Store-UI-Browser" selector="manager">manager	^Registry</body><body package="Store-UI-Browser" selector="pkgDef">pkgDef	^pkgDef</body><body package="Store-UI-Browser" selector="rightHandComponents">rightHandComponents	^components </body><body package="Store-UI-Browser" selector="showPackageComment">showPackageComment	pkgDef value: #showPackageComment</body><body package="Store-UI-Browser" selector="showPackageDefinition">showPackageDefinition	pkgDef value: #showPackageDefinition</body><body package="Store-UI-Browser" selector="showPackageProperties">showPackageProperties	pkgDef value: #showPackageProperties</body></methods><methods><class-id>Store.BundleTabApplication</class-id> <category>accessing subcanvases</category><body package="Store-UI-Browser" selector="getCanvas">getCanvas	| module |	module := self packageHierachyComponent.	module	browser: self browser.	^module</body></methods><methods><class-id>Store.BundleTabApplication</class-id> <category>initialization</category><body package="Store-UI-Browser" selector="addDependents">addDependents	self manager addDependent: self.</body><body package="Store-UI-Browser" selector="initialize">initialize"	super initialize.   "	pkgDef := #showDefinition asValue.	pkgDef onChangeSend: #updateText to: browser.	self addDependents.	packageFilter := false.</body><body package="Store-UI-Browser" selector="initializeForPackage:">initializeForPackage: aPackage	self browser setPackageFor: #default to: aPackage.	aPackage isLoaded not 		ifTrue: [ 	packageFilter := true ].	components := List new		add: self packageComponent;		add: self classesComponent;		 add: self protocolsComponent;		add: self methodsComponent;		yourself.	self linkComponentsInArray: components.	components first 		forceSelection: aPackage;		updateList.</body><body package="Store-UI-Browser" selector="initializeForPackage:classOrNameSpace:">initializeForPackage: aPackage  classOrNameSpace: aClassOrNameSpace	self browser setPackageFor: #default to: aPackage.	aPackage isLoaded not 		ifTrue: [ 	packageFilter := true ].	self  browser setModelFor: #default to:  aClassOrNameSpace.	components := List new		 add: self protocolsComponent;		add: self methodsComponent;		yourself.	self linkComponentsInArray: components.	self browser updateLists</body><body package="Store-UI-Browser" selector="initializeForPackage:method:">initializeForPackage: aPackage  method: aMethod	self browser setPackageFor: #default to: aPackage.	aPackage isLoaded not 		ifTrue: [ 	packageFilter := true ].	components := List with: self methodListComponent.	self linkComponentsInArray: components.	components first 		setNewListSilently: ( Array with: aMethod );		forceSelection: aMethod;		updateList;		yourself.</body><body package="Store-UI-Browser" selector="initializeForPackage:methods:">initializeForPackage: aPackage  methods: aCollection	aCollection size == 1		ifTrue: [ ^self initializeForPackage: aPackage  method: aCollection first ].	self browser setPackageFor: #default to: aPackage.	aPackage isLoaded not 		ifTrue: [ 	packageFilter := true ].	components := List with: self methodListComponent.	self linkComponentsInArray: components.	components first setNewListSilently: aCollection.	self browser updateLists</body><body package="Store-UI-Browser" selector="initializeForPackage:owner:protocols:">initializeForPackage: aPackage owner: aClassOrNameSpace protocols: aProtocolList	self browser setPackageFor: #default to: aPackage.	self browser setModelFor: #default to: aClassOrNameSpace.	self browser setProtocolFor: #default to: aProtocolList.	aPackage isLoaded not 		ifTrue: [ 	packageFilter := true ].	components := List with: self methodsComponent.	self linkComponentsInArray: components.	self browser updateLists</body><body package="Store-UI-Browser" selector="initializeForPackages">initializeForPackages	components := List new		add: self packageHierachyComponent;		add: self classesComponent;		 add: self protocolsComponent;		add: self methodsComponent;		yourself.	self linkComponentsInArray: components.	self browser updateLists</body><body package="Store-UI-Browser" selector="openOnPackage:classOrNameSpace:">openOnPackage: aPackage  classOrNameSpace: aClassOrNameSpace	self browser setPackageFor: #default to: aPackage.	aPackage isLoaded not 		ifTrue: [ 	packageFilter := true ].	self  browser setClassOrNameSpaceFor: self componentId to:  aClassOrNameSpace.	components := List new		 add: self protocolsComponent;		add: self methodsComponent;		yourself.	self linkComponentsInArray: components.	self browser updateLists</body><body package="Store-UI-Browser" selector="release">release	super release.	self removeDependents.	pkgDef retractInterestsFor: browser.</body><body package="Store-UI-Browser" selector="removeDependents">removeDependents	self manager removeDependent: self.</body></methods><methods><class-id>Store.BundleTabApplication</class-id> <category>updating</category><body package="Store-UI-Browser" selector="refreshLists">refreshLists	self canvas setPresetWidthTo: 500.</body><body package="Store-UI-Browser" selector="update:with:from:">update: anAspect with: aParameter from: aSender	browser == nil ifTrue: [ ^self ].	"store unloading itself"	( ( browser currentTabApplication == self ) and: [ aSender == self manager ] )		ifFalse: [ ^super update: anAspect with: aParameter from: aSender ]."Transcript show: anAspect , ':',   aParameter printString; cr.""1 halt."	( anAspect == #pundleTrace )  |   ( anAspect == #pundleModificationStatus ) |				( anAspect == #pundleBlessing )		ifTrue: [ ^self updateTextForPundle: aParameter ].	anAspect == #changedBundleStructure:		ifTrue: [ ^self updateListForPundle: aParameter ].	self updateList.</body><body package="Store-UI-Browser" selector="updateList">updateList		( components == nil or: [ components isEmpty ] )		ifFalse: [ components first updateList ]</body><body package="Store-UI-Browser" selector="updateListForPundle:">updateListForPundle: anItem	| mod |	( mod := components first module ) currentHelper attribute == #package		ifTrue: 			[ ( mod list itemIsVisible: anItem ) 				ifTrue: [ self updateList ]			]		ifFalse: 			[ ( self browser selectedPackageFor: #default ) = anItem					ifTrue: [ self updateList ]			].</body><body package="Store-UI-Browser" selector="updateTextForPundle:">updateTextForPundle: anItem	anItem isLoaded 		ifTrue: [ 	self browser updateText ]."	| mod |	(self  components size &gt; 0 and:			[ ( mod := self components first module ) currentHelper attribute == #package ] )		ifTrue: 			[ ( mod list itemIsVisible: anItem ) 				ifTrue: [ self browser updateText  ]			]		ifFalse: 			[ ( self browser selectedPackageFor: #default ) = anItem				ifTrue: [ self browser updateText ]			]."</body></methods><methods><class-id>Store.BundleTabApplication</class-id> <category>lists</category><body package="Store-UI-Browser" selector="allPackages">allPackages	^Registry allPackages asSortedCollection: [ :a :b | a name &lt; b name ]</body><body package="Store-UI-Browser" selector="dataFor:protocol:in:">dataFor: aModel protocol: protocol in: pkgs	| name newList |	newList := OrderedCollection new.	name := aModel absoluteName.	pkgs do:		[ :pkg | newList addAll: 			( pkg dataForNamed: name andProtocol: protocol )		].	^newList.</body><body package="Store-UI-Browser" selector="generateMethodsFor:">generateMethodsFor: id 	"Answer a method/data List for the id. "	| cns pkgs forData newList name protocols |	cns := self browser selectedModelFor: id.	pkgs := self packagesFor: cns id: id.	protocols := browser selectedProtocolFor: id.	newList := OrderedCollection new.	(cns == nil or: [protocols == nil or: [protocols isEmpty]]) 		ifTrue: [^newList].	forData := (self browser selectedModelFor: id) isForNameSpace 				or: [self browser isData].	name := cns absoluteName.	pkgs do: 			[:pkg | 			forData 				ifTrue: 					[protocols 						do: [:protocol | newList addAll: (pkg dataForNamed: name andProtocol: protocol)]]				ifFalse: 					[protocols do: 							[:protocol | 							newList addAll: (self 										methodsForClassNamed: name										protocol: protocol										inPundle: pkg)]]].	^(newList asSortedCollection: [:a :b | a name &lt; b name]) 		asOrderedCollection</body><body package="Store-UI-Browser" selector="generateNameSpaceClassListFor:">generateNameSpaceClassListFor: selectionId	| pkg list |	( pkg := browser selectedPackageFor: selectionId ) == nil		ifTrue: [ ^#( ) ].	pkg isLoaded |  pkg isInCurrentDatabase		ifFalse: [ ^#( ) ].	( pkg isLoaded not ) &amp;  ( DbRegistry isOnline not )		ifTrue: [ ^#( ) ].	list := pkg allNameSpaces asOrderedCollection addAll: 		( browser isMeta			ifTrue: [ pkg allMetaclasses ]			ifFalse: [ self computeAllClassesFor: pkg ]		 ); yourself.	^list</body><body package="Store-UI-Browser" selector="generateProtocolsFor:">generateProtocolsFor: id 	"Answer a protocol list for the id."	| target |	(self browser selectedPackageFor: id) == nil ifTrue: [^List new].	target := self browser selectedModelFor: id.	target == nil ifTrue: [^List new].	^self isFilteredByPackage 		ifTrue: 			[(self browser isData or: [target isForNameSpace]) 				ifTrue: 					[((self browser selectedPackageFor: id) protocolsForDataIn: target) asList]				ifFalse: 					[self protocolsForClassNamed: target absoluteName						inPundle: (self browser selectedPackageFor: id)]]		ifFalse: 			[target := target valueOrDo: [nil].			target == nil 				ifTrue: [List new]				ifFalse: 					[(self browser isData or: [target isForNameSpace]) 						ifTrue: [target := target asNameSpace]						ifFalse: 							[self browser isMeta 								ifTrue: [target isMeta ifFalse: [target := target class]]].					target organization categories asList]]</body><body package="Store-UI-Browser" selector="methodsFor:protocol:in:">methodsFor: aModel protocol: protocol in: pkgs	| name newList |	newList := OrderedCollection new.	name := aModel absoluteName.	pkgs do:		[ :pkg | newList addAll: 			( pkg methodsForClassNamed: name andProtocol: protocol meta: self browser isMeta )		].	^newList.</body><body package="Store-UI-Browser" selector="packagesFor:id:">packagesFor: aModel id: id	^self browser isFilteredByPackage		ifTrue: [ Array with: ( self browser selectedPackageFor: id ) ]		ifFalse: [ Registry packagesContaining: aModel ]</body></methods><methods><class-id>Store.BundleTabApplication</class-id> <category>testing</category><body package="Store-UI-Browser" selector="isClassCentric">isClassCentric	^false</body></methods><methods><class-id>Store.BundleTabApplication</class-id> <category>private</category><body package="Store-UI-Browser" selector="cachedItems">cachedItems	^cachedItems ifNil: [cachedItems := Dictionary new]</body><body package="Store-UI-Browser" selector="cachedLeafItemsFor:">cachedLeafItemsFor: pundle 	^(self cachedItems at: pundle		ifAbsentPut: 			[(Dictionary new)				at: #leafItems put: pundle leafItems;				yourself]) 			at: #leafItems</body><body package="Store-UI-Browser" selector="computeAllClassesFor:">computeAllClassesFor: pundle 	| allClasses dictionary |	pundle isBundle ifFalse: [^pundle allClasses].	allClasses := OrderedCollection new: 200.	pundle leafItems do: [:p | allClasses addAll: p allClasses].	"Try to eliminate duplicates the hard way.   Note, I'm	 aware that this is complete garbage. However, #hash is	 broken for the PseudoPseudo hierarchy, and I can not rely	 on it to work. AR 49058 will fix that."	dictionary := Dictionary new: allClasses size.	allClasses do: 		[:recordOrPseudo|		dictionary at: recordOrPseudo absoluteName put: recordOrPseudo].	^dictionary values</body><body package="Store-UI-Browser" selector="methodsForClassNamed:protocol:inPundle:">methodsForClassNamed: name protocol: protocol inPundle: pundle 	| leafItems allMethods |	"Protect against browsing what is in the image, since that is plenty fast."	(pundle isLoaded or: [pundle isPackage]) 		ifTrue: 			[^pundle 				methodsForClassNamed: name				andProtocol: protocol				meta: browser isMeta].	(self browser selectedAllMethodsFor: #default) ifNotNil: 		[:methods | 		^methods select: [:method | method protocolName = protocol asString]].	"in-line the bundle case"	leafItems := self cachedLeafItemsFor: pundle.	allMethods := Set new.	leafItems do: 			[:pkg | |items|			items := pkg						methodsForClassNamed: name						meta: browser isMeta.			items isEmpty ifFalse: [pkg methodsWithSource].			allMethods addAll: items].	allMethods := allMethods asList.	self browser setAllMethodsFor: #default to: allMethods.	^allMethods select: [:method | method protocolName = protocol asString]</body><body package="Store-UI-Browser" selector="protocolsForClassNamed:inPundle:">protocolsForClassNamed: name inPundle: pundle 	| set leafItems |	"Protect against browsing what is in the image, since that is plenty fast."	(pundle isLoaded or: [pundle isPackage]) 		ifTrue: [^(pundle protocolsForClassNamed: name meta: browser isMeta) asList].	"We've selected a new class so, cleary anything that is at allMethods"	self browser setAllMethodsFor: #default to: nil.	leafItems := self cachedLeafItemsFor: pundle.	set := Set new.	leafItems do: 		[:pkg | |items|		items := pkg protocolsForClassNamed: name meta: browser isMeta.		items isEmpty ifFalse: [pkg methodsWithSource].		set addAll: items].	^set asList</body></methods><methods><class-id>Store.BundleTabApplication class</class-id> <category>accessing</category><body package="Store-UI-Browser" selector="label">label	^'PKG'</body></methods><methods><class-id>Store.PackageComparisonApplication</class-id> <category>initialization</category><body package="Store-UI-Comparitors" selector="defaultEmphasizer">defaultEmphasizer	^PackageComparisonEmphasizer new.</body><body package="Store-UI-Comparitors" selector="initializeForClass:toClass:">initializeForClass: aClass toClass: bClass	| list1 list2 |	packageFilter := false.	components := List new 		add: self classComponent;		add: self classComponent;		yourself.	list1 :=  Array with: components first.	list2 :=  Array with: components last.	self setComponentIds: list1 to: 1.	self setComponentIds: list2 to: 2.	self linkComponentsInArray: list1.	self linkComponentsInArray: list2.	self browser 		invisibleAttributes: #( #package #model #method );		setMethodFor: 1 to: aClass;		setMethodFor: 2 to: bClass.	components first forceSelection: aClass.	components last forceSelection: bClass.	self browser updateText.</body><body package="Store-UI-Comparitors" selector="initializeForMethod:toMethod:">initializeForMethod: aMethod toMethod: bMethod	| list1 list2 |	packageFilter := false.	components := List new 		add: self methodComponent;		add: self methodComponent;		yourself.	list1 :=  Array with: components first.	list2 :=  Array with: components last.	self setComponentIds: list1 to: 1.	self setComponentIds: list2 to: 2.	self linkComponentsInArray: list1.	self linkComponentsInArray: list2.	self browser 		invisibleAttributes: #( #package #model #method );		setMethodFor: 1 to: aMethod;		setMethodFor: 2 to: bMethod.	components first forceSelection: aMethod.	components last forceSelection: bMethod.	self browser updateText.</body><body package="Store-UI-Comparitors" selector="initializeForPackage:toPackage:">initializeForPackage: aPackage toPackage: bPackage	| list1 list2 |	packageFilter := true.	components := List new		add: self packageComponent;		add: self classesComponent;		add: self methodsComponent;		add: self packageComponent;		add: self classesComponent;		add: self methodsComponent;		yourself.	list1 :=  ( components asArray copyFrom: 1 to: 3 ).	list2 :=  ( components asArray copyFrom: 4 to:6 ).	self setComponentIds: list1 to: 1.	self setComponentIds: list2 to: 2.	self linkComponentsInArray: list1.	self linkComponentsInArray: list2.	self browser setPackageFor: 1 to: aPackage.	self browser setPackageFor: 2 to: bPackage.	list1 first forceSelection: aPackage.	list2 first forceSelection: bPackage.	list1  first updateList.	( list1 at: 2 ) updateList.</body></methods><methods><class-id>Store.PackageComparisonApplication</class-id> <category>accessing</category><body package="Store-UI-Comparitors" selector="changes">changes	 	changes == nil		ifTrue: 			[ | pkg1 pkg2 |			pkg1  :=  browser selectedPackageFor: 1.			pkg2  :=  browser selectedPackageFor: 2.			changes := pkg1 pundleChangesClass with: pkg1 with: pkg2			].	^changes.</body><body package="Store-UI-Comparitors" selector="isFilteredByPackage">isFilteredByPackage	^true</body></methods><methods><class-id>Store.PackageComparisonApplication</class-id> <category>lists</category><body package="Store-UI-Comparitors" selector="generateAllMethodsFor:">generateAllMethodsFor: id	"Answer a method/data List for the id - ignoring protocol. "	| cns pkg forData name |	cns := self browser selectedModelFor: id.	pkg := self browser selectedPackageFor: id.	( cns == nil or: [ pkg == nil ] )		ifTrue: [ ^OrderedCollection new. ].	forData := ( self browser selectedModelFor: id ) isForNameSpace or: [ self browser isData ].	name := cns absoluteName.	^( (  forData		ifTrue: [ pkg dataForNamed: name ]		ifFalse: [ pkg methodsForClassNamed: name meta: browser isMeta ]	 ) asSortedCollection: [ :a :b  | a name &lt; b name ] ) asOrderedCollection.</body><body package="Store-UI-Comparitors" selector="generateMethodsFor:">generateMethodsFor: id	"Answer a method/data List for the id. "	| cns cset list pkg clsChanges |	( browser isIdInvisible: id ) ifTrue: [ ^List new ].	( browser comparisonType value == #showAll ) 		ifTrue: [ ^self generateAllMethodsFor: id ].	( cns := self browser selectedModelFor: id ) == nil		ifTrue: [ ^#( ) ].	cset := changes changeSetFor: id.	( clsChanges := cset at: cns absoluteSymbol ifAbsent: nil ) == nil		ifTrue: [ ^#( ) ].	list :=  ( browser isData or: [ cns isForNameSpace ] )			ifTrue: [ clsChanges modifiedDatumDescriptors ]			ifFalse: [ clsChanges modifiedMethodDescriptorsMeta: browser isMeta ].	 ( pkg := self browser selectedPackageFor: id ) isLoaded		ifFalse: [ list := list collect: [ :d | pkg recordOrPseudoForTag: d ] ].	^list asSortedCollection: [ :a :b | a name &lt; b name ].</body><body package="Store-UI-Comparitors" selector="generateNameSpaceClassListFor:">generateNameSpaceClassListFor: selectionId	"Answer a namespace and class list for the id. "	| cset pkg |	( browser isIdInvisible: selectionId ) ifTrue: [ ^List new ].	browser comparisonType value == #showAll		ifTrue: [ ^super generateNameSpaceClassListFor: selectionId ].	cset :=  self changes changeSetFor: selectionId.	pkg := self browser selectedPackageFor: selectionId.	^( cset collect: [ :cc | self recordFor: cc inPackage: pkg ] )		asSortedCollection</body></methods><methods><class-id>Store.PackageComparisonApplication</class-id> <category>private</category><body package="Store-UI-Comparitors" selector="recordFor:inPackage:">recordFor: anObject inPackage: aPackage	| des name isMeta |	name := anObject symbol asString.	isMeta := self browser isMeta.	anObject isForClass		ifTrue: [ ( des := aPackage classInPackageNamed: name meta: isMeta ) == nil					ifTrue: [ des := PseudoClass named: name meta: isMeta ]			   ]		ifFalse: [ ( des := aPackage nameSpaceInPackageNamed: name ) == nil					ifTrue: [ des := PseudoNameSpace newNamed: name ]				].	^des</body></methods><methods><class-id>Store.PackageComparisonApplication</class-id> <category>components</category><body package="Store-UI-Comparitors" selector="classComponent">classComponent	^SimpleBrowserModule new		helperType: PackageClassesVersionBrowserHelper</body><body package="Store-UI-Comparitors" selector="methodComponent">methodComponent	^SimpleBrowserModule new		helperType: PackageMethodsVersionBrowserHelper</body></methods><methods><class-id>Store.DBObject</class-id> <category>support</category><body package="Store-DB-BaseObjects" selector="broker">broker	^ self class broker</body><body package="Store-DB-BaseObjects" selector="collection:intersect:">collection: coll1 intersect: coll2	^coll1 select: [:each | coll2 includes: each]</body><body package="Store-DB-BaseObjects" selector="collection:intersects:">collection: coll1 intersects: coll2	^(self collection: coll1 intersect: coll2) isEmpty not</body><body package="Store-DB-BaseObjects" selector="currentUserName">currentUserName	^ self class currentUserName</body><body package="Store-DB-BaseObjects" selector="install">install		self installInDatabase</body><body package="Store-DB-BaseObjects" selector="installInTable">installInTable	self error: 'Tables are no longer supported.'</body><body package="Store-DB-BaseObjects" selector="newSQL">newSQL		^ self class newSQL</body><body package="Store-DB-BaseObjects" selector="postDatabaseInstall">postDatabaseInstall	"For consistency"	"Added by Philippe F. Monnet of Andersen Consulting"</body><body package="Store-DB-BaseObjects" selector="preDatabaseInstall">preDatabaseInstall	"For consistency"	"Added by Philippe F. Monnet of Andersen Consulting"</body><body package="Store-DB-BaseObjects" selector="prime">prime	"Fill slots that do not map to table columns with instances of Object"</body><body package="Store-DB-BaseObjects" selector="processFields">processFields	"Do any necessary data conversions following retrieval"</body><body package="Store-DB-BaseObjects" selector="processString:">processString: aString	^self class processString: aString</body><body package="Store-DB-BaseObjects" selector="unprime">unprime	"Nil out the slots that do not map to table columns"</body></methods><methods><class-id>Store.DBObject</class-id> <category>private-utilities</category><body package="Store-DB-BaseObjects" selector="errorSignals">errorSignals	^ self class errorSignals</body><body package="Store-DB-BaseObjects" selector="insertInDatabase:">insertInDatabase: aColumnArray	self broker process: 			( self newSQL				insertColumnsValues: aColumnArray )		bindInput: self.</body><body package="Store-DB-BaseObjects" selector="installInDatabase">installInDatabase	"Create a corresponding record in the database."	self preDatabaseInstall.	self broker process: self installSqlString bindInput: self.	self postDatabaseInstall.</body><body package="Store-DB-BaseObjects" selector="installSqlString">installSqlString	"Answer a sql command containing all columns."	^ self newSQL		insertColumnsValues: self class columnNamesForQuery.</body><body package="Store-DB-BaseObjects" selector="nextID">nextID	"Check which database and get next sequence number"	^ self broker nextIDForClass: self class</body><body package="Store-DB-BaseObjects" selector="removeFromDatabase">removeFromDatabase	self broker process: 			( self newSQL				delete;				whereSqlString )		 bindInput: self</body></methods><methods><class-id>Store.DBObject</class-id> <category>tt-private</category><body package="Store-DB-BaseObjects" selector="decode:">decode: aByteArray	"Decode anObject that was stored with #encode:"	| stream bos obj |	aByteArray == nil		ifTrue: [ ^nil ].	stream := ReadStream on: aByteArray asByteArray.	bos := BinaryObjectStorage onOld: stream.	obj := bos next.	bos close.	^obj</body><body package="Store-DB-BaseObjects" selector="encode:">encode: anObject	"Encode anObject and answer a bytearray."		| stream bos |	stream := WriteStream on: ByteArray new.	bos := BinaryObjectStorage onNew: stream.	bos nextPut: anObject.	bos close.	^stream contents</body><body package="Store-DB-BaseObjects" selector="timeStampString">timeStampString	"Answer the receiver's timestamp as a string."	| stamp |	self timeStamp isNil ifTrue:  [ ^'***' ].	stamp := Time aTime: self timeStamp + self class timeOffset.	^Locale current printAsTime: 		( Timestamp  fromDate: stamp first andTime: stamp last) policyNamed: #short</body></methods><methods><class-id>Store.DBObject class</class-id> <category>private-utilities</category><body package="Store-DB-BaseObjects" selector="allRecords">allRecords	"Answer a collection of all records in the table."	^[ self processList: 		(self broker process: (self newSQL selectAll)				 bindOutput: self newPrimed).	] 	on: self  errorSignals 	do: 	[:ex |   ex outer.		OrderedCollection new		].</body><body package="Store-DB-BaseObjects" selector="answerFromQuery:bindInput:">answerFromQuery: aSQLString bindInput: anObject	^self broker process: aSQLString bindInput: anObject.</body><body package="Store-DB-BaseObjects" selector="answerSetFromQuery:bindInput:">answerSetFromQuery: aSQLString bindInput: anObject	| coll |	[coll := self broker process: aSQLString bindInput: anObject.	] 	on: self  errorSignals 	do: 	[:ex |  ex outer.		^OrderedCollection new 		].	^coll notNil 		ifTrue:			[(coll collect: [:each| each first]) asSet]		ifFalse: [OrderedCollection new]</body><body package="Store-DB-BaseObjects" selector="checkFieldsWith:">checkFieldsWith: aDict 	"Test if all keys in the dictionary are representes by column names."	| instVars |	instVars := self columnNames.	aDict keys do: [:each | (instVars includes: each)			ifFalse: 				[self error: (#ShouldBeAnInstanceVariable &lt;&lt; #store &gt;&gt; 'This should be an instance variable to field type mapping').				^false]].	^true</body><body package="Store-DB-BaseObjects" selector="deleteWhereColumn:value:">deleteWhereColumn: column value: value	self broker process: (self newSQL						delete;						where;						column: column equalTo: value)</body><body package="Store-DB-BaseObjects" selector="errorSignals">errorSignals	^DbRegistry errorSignals</body><body package="Store-DB-BaseObjects" selector="processList:">processList: aList	aList == nil		ifTrue: [ ^OrderedCollection new: 1 ].	aList do: 		[ :each | 		each unprime.		each processFields		].	^aList</body><body package="Store-DB-BaseObjects" selector="resetSequenceGeneratorSessions">resetSequenceGeneratorSessions	"Reset all the session used to generate the primary keys."	self withAllSubclasses do: [:x | x resetSequenceGeneratorSession]</body></methods><methods><class-id>Store.DBObject class</class-id> <category>installation-pkgs</category><body package="Store-DB-BaseObjects" selector="alterTablePctincrease">alterTablePctincrease		self broker alterTableFor: self  pctIncreaseBy: 1.</body><body package="Store-DB-BaseObjects" selector="tableExists">tableExists	"Sent to a class representing a database table, answer true if table has been installed."	"Blessing tableExists"	"DefinedRecord tableExists"  "should always answer false"	| query |	^[ ( query := self newSQLFor: self )			selectAll;			where;			addString: '1 = 2'.	self broker processSQL: query sqlString.	true.	] on: Error do: [ :ex | false ]</body></methods><methods><class-id>Store.DBObject class</class-id> <category>instance creation</category><body package="Store-DB-BaseObjects" selector="newPrimed">newPrimed	| anObject |	anObject := self new.	anObject prime.	^anObject</body></methods><methods><class-id>Store.DBObject class</class-id> <category>private-accessing</category><body package="Store-DB-BaseObjects" selector="blockFactor">blockFactor	^self safeBlockFactor: self defaultBlockFactor</body><body package="Store-DB-BaseObjects" selector="closeConnection">closeConnection	DbRegistry closeConnection</body><body package="Store-DB-BaseObjects" selector="connection">connection	^ DbRegistry connection</body><body package="Store-DB-BaseObjects" selector="connectionClass">connectionClass	^ DbRegistry connectionClass</body><body package="Store-DB-BaseObjects" selector="defaultBlockFactor">defaultBlockFactor	^3</body><body package="Store-DB-BaseObjects" selector="isOnline">isOnline	^ DbRegistry isOnline</body><body package="Store-DB-BaseObjects" selector="isSessionValid:">isSessionValid: aSession	^( aSession == nil or: 			[ aSession state = #new  or: [ aSession state = #paused ]  ] 	  ) not</body><body package="Store-DB-BaseObjects" selector="resetSequenceGeneratorSession">resetSequenceGeneratorSession	SequenceGeneratorSession notNil 		ifTrue: 			[ self broker notNil ifTrue: [ self broker dismissSession: SequenceGeneratorSession].			SequenceGeneratorSession := nil.]</body><body package="Store-DB-BaseObjects" selector="resetSession">resetSession 	Session notNil 		ifTrue: 			[ self brokerOrNil notNil 				ifTrue: [ self broker dismissSession: Session ].			Session := nil			]</body><body package="Store-DB-BaseObjects" selector="safeBlockFactor:">safeBlockFactor: anInteger	"Because of problems on the mac, keep the block factor low"	^( anInteger &gt; 50 and: [ OSHandle currentOS == #mac ] )		ifTrue: [ 50 ]		ifFalse: [ anInteger ].</body><body package="Store-DB-BaseObjects" selector="sequenceGeneratorSession">sequenceGeneratorSession"I moved it to the brokers side because it returned the invalid cursor state for SQLServer prepared session. TK"	DbRegistry isOnline not ifTrue: [ ^nil].	SequenceGeneratorSession := self broker 		sequenceGeneratorSession: SequenceGeneratorSession		forClass: self.	^ SequenceGeneratorSession.</body><body package="Store-DB-BaseObjects" selector="session">session"Session := nil."	( self isSessionValid: Session)		ifFalse: [ Session := self broker getNewSession ].	Session blockFactor: self blockFactor.	^Session</body><body package="Store-DB-BaseObjects" selector="timeOffset">timeOffset	^ 2922938387</body><body package="Store-DB-BaseObjects" selector="timeStamp">timeStamp	^Time secondClock - self timeOffset	"^Date today printString , '    ' , Time now printString"</body><body package="Store-DB-BaseObjects" selector="timeStampFromDate:">timeStampFromDate: aDate	^aDate asSeconds - self timeOffset</body></methods><methods><class-id>Store.DBObject class</class-id> <category>private - db-file transfer</category><body package="Store-DB-BaseObjects" selector="collectionFrom:">collectionFrom: aStream 	"Read aStream and answer a collection of DBUserGroup instances."	| coll |	coll := OrderedCollection new.	[aStream atEnd]		whileFalse: 			[| baby |			baby := self readFrom: aStream.			coll add: baby].	^coll</body><body package="Store-DB-BaseObjects" selector="storeTableInto:">storeTableInto: aStream	| coll |	coll := self allRecords.	coll do: [:each| each storeOn: aStream].</body></methods><methods><class-id>Store.DBObject class</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="broker">broker	^ DbRegistry storeBroker</body><body package="Store-DB-BaseObjects" selector="brokerOrNil">brokerOrNil	^[ DbRegistry storeBroker ] 		on: UnhandledException 		do: [ :ex | ex exit: nil ].</body><body package="Store-DB-BaseObjects" selector="columnNames">columnNames	"Answer all the instance variable names that coorespond to column names in the database table.	Default is all of them."	^self allInstVarNames</body><body package="Store-DB-BaseObjects" selector="columnNamesForQuery">columnNamesForQuery	"Answer all the instance variable names that coorespond to column names in the database table.	Default is same as instsallatoin column names."	^self columnNames</body><body package="Store-DB-BaseObjects" selector="commentFor:">commentFor:  aClass	^self processString: aClass comment</body><body package="Store-DB-BaseObjects" selector="currentUserName">currentUserName	^ DbRegistry currentUserName</body><body package="Store-DB-BaseObjects" selector="databaseName">databaseName	"SQL Server notation"	^ self tableSpaceName</body><body package="Store-DB-BaseObjects" selector="definitionFor:">definitionFor:  aClass	^self processString: aClass definition</body><body package="Store-DB-BaseObjects" selector="indexColumnNames">indexColumnNames		^ Array new.</body><body package="Store-DB-BaseObjects" selector="indexName">indexName	^ nil</body><body package="Store-DB-BaseObjects" selector="newList:isEqualTo:">newList: newList isEqualTo: oldList	"There is no senders to this method?"	| sortList1 sortList2 |	newList size = oldList size ifFalse: [^false].	sortList1 := newList asSortedCollection: [:x :y | x name &lt; y name].	sortList2 := oldList  asSortedCollection: [:x :y | x name &lt; y name].	sortList1 with: sortList2 do: [:each1 :each2 |		(each1 primaryKey = each2 primaryKey) ifFalse: [^false]].	^true</body><body package="Store-DB-BaseObjects" selector="newSQL">newSQL	^ self broker newSQLFor: self</body><body package="Store-DB-BaseObjects" selector="newSQLFor:">newSQLFor: aClass	^ self broker newSQLFor: aClass</body><body package="Store-DB-BaseObjects" selector="processString:">processString: aString	"Purify to &lt;cr&gt; line termination"	"self processString: (String with: Character lf with: Character cr with: (Character value: 11))" 	^IOAccessor convertStringFromPlatform: aString string.</body><body package="Store-DB-BaseObjects" selector="sourceCodeAt:forClass:">sourceCodeAt: aSelector forClass: aClass 	"ACMEObject sourceCodeAt: #sourceCodeAt:forClass: forClass: ACMEObject class"	"Get the source the way it is done by the base system but without changing the cursor	and checking InputState"	| newSource index method |	method := aClass compiledMethodAt: aSelector.	newSource := SourceFileManager default stringAt: method sourcePointer ifAbsent: [nil].	newSource == nil ifTrue: [  "no stored source"		^(aClass decompilerClass new			decompile: aSelector			in: aClass			method: method) decompiledCode].	((newSource at: newSource size) isSeparator)		ifTrue:			[index := newSource size. "tidy up for file out"			[((newSource at: index) isSeparator)				and: [index &gt; 1]]				whileTrue: [index := index - 1].			newSource := newSource copyFrom: 1 to: index].	^self processString: newSource</body><body package="Store-DB-BaseObjects" selector="xmlDefinitionFor:">xmlDefinitionFor:  aClass	^self processString: aClass xmlDefinition</body></methods><methods><class-id>Store.DBObject class</class-id> <category>installation</category><body package="Store-DB-BaseObjects" selector="createDatabaseSequence">createDatabaseSequence	self broker createDatabaseSequence:  self.	self broker 		grantForSeqClass: self  		permissions: self broker permissionsForSequence 		toUsers: #('PUBLIC').</body><body package="Store-DB-BaseObjects" selector="createDatabaseTable">createDatabaseTable	"Creates a corresponding database table."	self broker createDatabaseTable: self.	self setDatabasePrivilegesForTable.	(self needsSequenceFor: self)  ifTrue: [self createDatabaseSequence]</body><body package="Store-DB-BaseObjects" selector="createPhysicalSpaces">createPhysicalSpaces	^ self broker createPhysicalSpaces</body><body package="Store-DB-BaseObjects" selector="createViewForClass:">createViewForClass: aClass	self broker createViewForClass: aClass.	self broker grantForClass: aClass  permissions: #('SELECT')  toUsers: #('PUBLIC').</body><body package="Store-DB-BaseObjects" selector="deinstall">deinstall	"self deinstall"	self dropTables.	self dropViews.</body><body package="Store-DB-BaseObjects" selector="dropDatabases">dropDatabases	(Array with: Store.DBObject with: Store.Blob) do: [ :each | self broker dropDatabaseFor: each].</body><body package="Store-DB-BaseObjects" selector="dropSequenceForClass:">dropSequenceForClass: aClass 	self broker dropSequenceForClass: aClass.</body><body package="Store-DB-BaseObjects" selector="dropTableForClass">dropTableForClass	self broker dropTableForClass: self.	(self needsSequenceFor: self)		ifTrue: [ self broker dropSequenceForClass: self ]</body><body package="Store-DB-BaseObjects" selector="dropViewForClass">dropViewForClass	self broker dropViewForClass: self .</body><body package="Store-DB-BaseObjects" selector="flushTable">flushTable	table := nil</body><body package="Store-DB-BaseObjects" selector="indexParameters">indexParameters	"Answer a string specifying index parameters. If the default index is acceptable 	answer nil."	^'TABLESPACE  NEWBERN2 '</body><body package="Store-DB-BaseObjects" selector="installPhysicalSpaces">installPhysicalSpaces	^ self broker installPhysicalSpaces</body><body package="Store-DB-BaseObjects" selector="needsSequence">needsSequence	"Answer true to create a database sequence generator."	"Most subclasses are false."	^self == DBObject</body><body package="Store-DB-BaseObjects" selector="needsSequenceFor:">needsSequenceFor: aClass"Check with broker if it supports sequence"	^self broker needsSequenceFor: aClass.</body><body package="Store-DB-BaseObjects" selector="nextIndex">nextIndex	nextIndex isNil ifTrue: [nextIndex := SmallInteger minVal].	nextIndex := nextIndex + 1.	^nextIndex</body><body package="Store-DB-BaseObjects" selector="primaryKeyTypes">primaryKeyTypes	"Returns the primary key types"	^#( #PrimaryKey #PrimaryKeyInteger #PrimaryKeyString 		#PrimaryKeyChar PrimaryKeyShortString)</body><body package="Store-DB-BaseObjects" selector="registerToDebug">registerToDebug	^ self broker registerToDebug</body><body package="Store-DB-BaseObjects" selector="setDatabasePrivilegesForTable">setDatabasePrivilegesForTable	"Defines who can do what wtih the table"	self broker setDatabasePrivilegesForTable: self.</body><body package="Store-DB-BaseObjects" selector="storageParameters">storageParameters	"Answer a string describing special storage parameters for the table or nil if the default parameters are 	acceptable answer."	^'STORAGE(INITIAL 512K NEXT 512K PCTINCREASE 1) '</body><body package="Store-DB-BaseObjects" selector="table">table	table isNil ifTrue: [table := Dictionary new].	^table</body><body package="Store-DB-BaseObjects" selector="tableSpaceName">tableSpaceName	"Answer a name of a tablespace the table should live in. If the default tablespace is acceptable 	answer nil."	^'NEWBERN2'</body></methods><methods><class-id>Store.DatabaseIdentifier</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="identityName">identityName	^ identityName</body><body package="Store-DB-BaseObjects" selector="identityName:">identityName: aString	identityName := aString.</body><body package="Store-DB-BaseObjects" selector="primaryKey">primaryKey	^OrderedCollection with: self  identityName</body></methods><methods><class-id>Store.DatabaseIdentifier</class-id> <category>private-utilities</category><body package="Store-DB-BaseObjects" selector="installInDatabase1">installInDatabase1	"Create a corresponding record in the database."	| str stream  ind | 	str := self installSqlString.	ind := str findString: ':identity' startingAt: 1.	stream := (String new: 100) writeStream.	stream nextPutAll: (str copyFrom: 1 to: ind - 1).	stream nextPut: $'.	stream nextPutAll: self identityName, ''')'.  	str := String readFrom: stream.	self broker process: stream contents.</body></methods><methods><class-id>Store.DatabaseIdentifier class</class-id> <category>installation</category><body package="Store-DB-BaseObjects" selector="createDatabaseTable1">createDatabaseTable1	"Creates a corresponding database table and force you to enter DB identifier."	| identifier |	[			(identifier := Dialog request: 'Please, enter the database identifier.' initialAnswer: '') isEmpty			ifTrue: [ false]			ifFalse: [ true ]	] whileFalse.	self broker createDatabaseTable: self.	self broker grantForClass: self permissions: #('SELECT') toUsers: #('PUBLIC').	self newDBIdentifier: identifier.	DbRegistry databaseIdentifier: identifier.</body><body package="Store-DB-BaseObjects" selector="fieldTypes">fieldTypes	| aDict  |	aDict := Dictionary new.	aDict at: 'identityName' put: #PrimaryKeyString.	self checkFieldsWith: aDict.	^aDict</body><body package="Store-DB-BaseObjects" selector="installInDatabase">installInDatabase	"Asks the user to identify the database. Does not take no for an answer."	| identifier |	[ ( identifier := Dialog request: 'Enter a unique name for this Store repository:'					initialAnswer: ''	   ) isEmpty		ifTrue: [ false]		ifFalse: [ true ]	] whileFalse.	self newDBIdentifier: identifier.	DbRegistry databaseIdentifier: identifier.</body><body package="Store-DB-BaseObjects" selector="setDatabasePrivilegesForTable">setDatabasePrivilegesForTable	self broker grantForClass: self permissions: #('SELECT' 'UPDATE') toUsers: #('PUBLIC').</body></methods><methods><class-id>Store.DatabaseIdentifier class</class-id> <category>instance creation</category><body package="Store-DB-BaseObjects" selector="newDBIdentifier:">newDBIdentifier: aString	self new		identityName: aString;		installInDatabase.</body></methods><methods><class-id>Store.DatabaseIdentifier class</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="databaseIdentifier">databaseIdentifier	^[ self databaseIdentifierSQL]		on: Error		do: [ :exception | exception return: nil.].</body><body package="Store-DB-BaseObjects" selector="databaseIdentifierSQL">databaseIdentifierSQL	^ (self broker processSQL: 			( self newSQL selectAll) bindOutput: self newPrimed)			first			identityName</body><body package="Store-DB-BaseObjects" selector="getDatabaseIdentifier">getDatabaseIdentifier	^ self databaseIdentifierSQL</body></methods><methods><class-id>Store.DBUserGroup</class-id> <category>testing</category><body package="Store-Ownership" selector="isGroup">isGroup	^self type = self class groupType</body><body package="Store-Ownership" selector="isUser">isUser	^self type = self class userType</body></methods><methods><class-id>Store.DBUserGroup</class-id> <category>initialize-release</category><body package="Store-Ownership" selector="initialize">initialize	self makeUser.</body><body package="Store-Ownership" selector="readFrom:">readFrom: aStream	groupName := aStream upToSeparator.	aStream skipSeparators.	userName := aStream upToSeparator.	aStream skipSeparators.	type := aStream upToSeparator.	type := type asSymbol.</body></methods><methods><class-id>Store.DBUserGroup</class-id> <category>printing</category><body package="Store-Ownership" selector="itemString">itemString	^userName asString,	(self isUser		ifTrue:	['  [', (groupName isNil ifTrue: [''] ifFalse: [groupName asString]),']']		ifFalse:	[''])</body><body package="Store-Ownership" selector="printOn:">printOn: aStream	aStream nextPutAll: self userName asString."	aStream nextPutAll:	( self isUser		ifTrue:	['  [', ( groupName isNil ifTrue: [ '' ] ifFalse: [ groupName asString ] ),']' ]		ifFalse:	[ '' ]	)."</body><body package="Store-Ownership" selector="storeOn:">storeOn: aStream	aStream nextPutAll: groupName; tab.	aStream nextPutAll: userName; tab.	aStream nextPutAll: type asString; cr.</body></methods><methods><class-id>Store.DBUserGroup</class-id> <category>support</category><body package="Store-Ownership" selector="postDatabaseInstall">postDatabaseInstall	self class checkAddingAdmin: self.</body><body package="Store-Ownership" selector="removeFromDatabase">removeFromDatabase	super removeFromDatabase.	self class checkRemovingAdmin: self.</body><body package="Store-Ownership" selector="updateInDatabase">updateInDatabase	"Added by Philippe F. Monnet of Andersen Consulting"		self broker process: 			( self newSQL				update;				column: #groupName equalTo: self groupName printString;				where;				column: #userName equalTo: userName printString)</body></methods><methods><class-id>Store.DBUserGroup</class-id> <category>relationships</category><body package="Store-Ownership" selector="containsUserNamed:">containsUserNamed: aUserName	"Answer true if aUserName is the receiver, or contained in the receiver's users."	self isUser 	ifTrue: [ ^userName asUppercase = aUserName asUppercase ].	^( self class userNamesInGroupNamed: userName ) includes: aUserName.</body><body package="Store-Ownership" selector="ownedPundleModels">ownedPundleModels	"Returns a list of pundle models owned by the receiver"	^( ( self class pundlePrivilegesClass pundlesOwnedBy: self )			collect: [ :ownership | Registry packageNamed: ownership name ]	 )  reject: [ :pkg |  pkg == nil ]</body><body package="Store-Ownership" selector="ownedPundles">ownedPundles	"Returns a list of pundle names owned by the receiver"	^( self class pundlePrivilegesClass pundlesOwnedBy: self )			collect: [ :ownership | ownership pundleName ]</body><body package="Store-Ownership" selector="relatedBy:">relatedBy: relToken	"Anwer set of relations. Main relationship is owner-&gt;pundle."	relToken == #tt_ownsRel		ifTrue: [ ^( self class pundlePrivilegesClass pundlesUser: self privilege: #owner ) asSet ].	relToken == #readRel		ifTrue: [ ^( self class pundlePrivilegesClass pundlesUser: self privilege: #read )  asSet ].	relToken == #publishRel		ifTrue: [ ^( self class pundlePrivilegesClass pundlesUser: self privilege: #publish ) asSet ].	^super relatedBy: relToken</body></methods><methods><class-id>Store.DBUserGroup</class-id> <category>accessing</category><body package="Store-Ownership" selector="groupName">groupName	"Answer the receiver's groupName."	^groupName</body><body package="Store-Ownership" selector="groupName:">groupName: newGroupName	"Set the receiver's groupName to newGroupName."	groupName := newGroupName</body><body package="Store-Ownership" selector="makeGroup">makeGroup	self type: self class groupType</body><body package="Store-Ownership" selector="makeUser">makeUser	self type: self class userType</body><body package="Store-Ownership" selector="name">name	"Answer the receiver's userName."	^self userName</body><body package="Store-Ownership" selector="type">type	"Answer the receiver's type."	^type</body><body package="Store-Ownership" selector="type:">type: newType	"Set the receiver's type to newType."	type := newType</body><body package="Store-Ownership" selector="userName">userName	"Answer the receiver's userName."	^userName == nil		ifTrue: [ '' ]		ifFalse: [ userName ]</body><body package="Store-Ownership" selector="userName:">userName: newUserName	"Set the receiver's userName to newUserName."	userName := newUserName</body><body package="Store-Ownership" selector="userType">userType	"Answer the receiver's type."	^type</body></methods><methods><class-id>Store.DBUserGroup</class-id> <category>comparing</category><body package="Store-Ownership" selector="&lt;=">&lt;= aDBUserGroup	aDBUserGroup class == self class		ifFalse: [ ^userName &lt;= aDBUserGroup name ].	^self isGroup = aDBUserGroup isGroup		ifTrue: [ userName &lt;= aDBUserGroup userName ]		ifFalse: [ self isGroup ].</body><body package="Store-Ownership" selector="=">= aDBUserGroup		aDBUserGroup class == self class		ifFalse: [ ^false ].	^( type = aDBUserGroup userType )  &amp;  ( userName = aDBUserGroup userName ) &amp; ( groupName = aDBUserGroup groupName )</body><body package="Store-Ownership" selector="hash">hash	^type hash bitXor: ( userName hash bitXor: groupName hash )</body></methods><methods><class-id>Store.DBUserGroup class</class-id> <category>instance creation</category><body package="Store-Ownership" selector="new">new	^super new initialize</body><body package="Store-Ownership" selector="newGroupNamed:">newGroupNamed: aGroupName	"Create, install and answer a new group. Verifies group doesn't already exist and answers nil if it does."	( DBUserGroup allGroupNames includes: aGroupName ) 		ifTrue: 			[ Dialog warn: 'Group "', aGroupName, '" already exists.'.			^nil			].	^self new	 	groupName: aGroupName;		 userName: aGroupName;	 	makeGroup;		installInDatabase;		yourself.</body><body package="Store-Ownership" selector="readFrom:">readFrom: aStream	| baby |	baby := self new.	baby readFrom: aStream.	^baby</body><body package="Store-Ownership" selector="removeUserNamed:inGroupNamed:">removeUserNamed: aUserName inGroupNamed: aGroupName	"Remove a user from a group."	self new	 	groupName: aGroupName;		userName: aUserName;		makeUser;		removeFromDatabase.</body></methods><methods><class-id>Store.DBUserGroup class</class-id> <category>accessing</category><body package="Store-Ownership" selector="adminGroupName">adminGroupName	^'ADMINISTRATOR'</body><body package="Store-Ownership" selector="pundlePrivilegesClass">pundlePrivilegesClass	^DBPundlePrivileges</body></methods><methods><class-id>Store.DBUserGroup class</class-id> <category>private-visual blocks</category><body package="Store-Ownership" selector="selectedVisualBlock">selectedVisualBlock	^	[:view :index | 	| str pkg |	pkg := view sequence at: index.	str := DbRegistry textForItem: pkg.	BoundedWrapper on: (LabelAndIcon with: str attributes: view textStyle) beCheckMark]</body><body package="Store-Ownership" selector="visualBlock">visualBlock	^	[:view :index | 	| str pkg |	pkg := view sequence at: index.	str := DbRegistry textForItem: pkg.	BoundedWrapper on: (Label			with: str			attributes: view textStyle			offset: 16 @ 0)]</body></methods><methods><class-id>Store.DBUserGroup class</class-id> <category>tmp-tests</category><body package="Store-Ownership" selector="test2">test2	"self test2"	^self isUser: 'kuba' memberOf: #('bernstein')</body></methods><methods><class-id>Store.DBUserGroup class</class-id> <category>public-query</category><body package="Store-Ownership" selector="allDistinctUserGroups">allDistinctUserGroups	^( self broker answerFromQuery: 				(self newSQL selectDistinct: #( userName type ))		bindInput: 				( self new makeUser; yourself )) 	collect: 		[ :row |		self new userName: row first; type: row last; yourself		].</body><body package="Store-Ownership" selector="allGroupNames">allGroupNames	"Answer a collection of group names."	"self allGroupNames"		^self answerSetFromQuery:  			( self newSQL				selectDistinct: #( groupName );				where;				column: #type  equalTo: ':type')		bindInput: ( self new makeGroup).</body><body package="Store-Ownership" selector="allUserGroups">allUserGroups	^self allRecords</body><body package="Store-Ownership" selector="allUserNames">allUserNames	"Answer a collection of user names."	"self allUserNames"		^self answerSetFromQuery: 				( self newSQL					selectDistinct: #( userName );					where;					column: #type equalTo: ':type')		bindInput: ( self new makeUser)</body><body package="Store-Ownership" selector="dbHasAdmin">dbHasAdmin		"self dbHasAdmin"	^self tableExists and:		[ ( self userNamesInGroupNamed: self adminGroupName ) notEmpty ]</body><body package="Store-Ownership" selector="groupNamed:">groupNamed: aUserName 	"A user named aUserName, or nil if none."		"self groupNamed: 'Developer'"	| aList inp |	inp := self new.	inp userName: aUserName.	inp makeGroup.	[aList := self processList: 		(self  broker process: 				( self newSQL					selectAll;					where;					column: #userName equalTo: ':userName';					and;					column: #type  equalTo: ':type') 		bindInput: inp		bindOutput: self newPrimed)	] 	on: self  errorSignals 	do: 	[ :ex | ex outer. ^nil ].	^ (aList isNil or: [ aList isEmpty])		ifTrue: [ nil] 		ifFalse: [ aList first ].</body><body package="Store-Ownership" selector="groupNamesForUserNamed:">groupNamesForUserNamed: aUserName 	"Answer a collection of group names that the user belongs to."	^self answerSetFromQuery:  				( self newSQL					selectDistinct: #( groupName );					where;					column: #userName equalTo: ':userName';					and;					column: #type equalTo: ':type')		bindInput: 				(self new					userName: aUserName;					makeUser;					yourself)</body><body package="Store-Ownership" selector="groupsForUser:">groupsForUser: aUser	"Answer a collection of groups that the user belongs to."	^( self answerSetFromQuery: 					( self newSQL						selectDistinct: #( groupName );						where;						column: #userName  equalTo: ':userName';						and;						column: #type equalTo: ':type')			bindInput: aUser ) 		collect:		[ :gname | self groupNamed: gname ].</body><body package="Store-Ownership" selector="isInAdmin:">isInAdmin: userName	^( self userNamesInGroupNamed: self adminGroupName )		includes: userName.</body><body package="Store-Ownership" selector="isUser:memberOf:">isUser: aUserName memberOf: aCollectionOfNames	"Answer true if a user belongs to one of the groups specified in the collection of names."		| set |	set := self groupNamesForUserNamed: aUserName.	aCollectionOfNames do: [:each|  (set includes: each) ifTrue: [^true]].	^false</body><body package="Store-Ownership" selector="userName:type:">userName: aUserName type:  aType	^aType = self groupType		ifTrue: [ self groupNamed: aUserName ]		ifFalse: [ self userNamed: aUserName ].</body><body package="Store-Ownership" selector="userNamed:">userNamed: aUserName 	"A user named aUserName, or nil if none."		"self userNamed: 'BERN'"	| aList inp |	inp := self new.	inp userName: aUserName.	inp makeUser.	[aList := self processList:			(self broker 	process: 					( self newSQL						selectAll;						where;						column: #userName equalTo: ':userName';						and;						column: #type equalTo: ':type') 		bindInput: inp		bindOutput: self newPrimed)	] 	on: self  errorSignals 	do: 	[ :ex | ex outer. ^nil ].	^ (aList isNil or: [ aList isEmpty])		ifTrue: [ nil] 		ifFalse: [ aList first ].</body><body package="Store-Ownership" selector="userNamesInGroupNamed:">userNamesInGroupNamed: aGroupName 	"Answer a collection of user names in the group."	^self answerSetFromQuery:  				( self newSQL					selectDistinct: #( userName );					where;					column: #groupName equalTo: ':groupName';					and;					column: #type equalTo: ':type')						bindInput: 				( self new					groupName: aGroupName;					makeUser;					yourself)</body><body package="Store-Ownership" selector="usersInGroupNamed:">usersInGroupNamed: aGroupName 	"Get all users that belong to aGroupName. Answer a collection of my instances."	^[self processList:		( self broker 			process: 					( self newSQL						selectAll;						where;						column: #groupName equalTo: ':groupName') 			bindInput: 					( self new 						groupName: aGroupName; 						yourself)			bindOutput: self newPrimed)	] 	on: self  errorSignals 	do: 	[ :ex | ex outer. OrderedCollection new ].</body></methods><methods><class-id>Store.DBUserGroup class</class-id> <category>installation</category><body package="Store-Ownership" selector="checkAddingAdmin:">checkAddingAdmin: aDbUser	aDbUser isUser  &amp;  ( aDbUser groupName = self adminGroupName )		ifTrue: 			[ self broker grantForClass: self  						permissions: self databasePrivilegesList						toUsers: (Array with: aDbUser userName).			self broker grantForClass: DBPundlePrivileges						permissions:self databasePrivilegesList						toUsers: (Array with: aDbUser userName).			].</body><body package="Store-Ownership" selector="checkRemovingAdmin:">checkRemovingAdmin: aDbUser	aDbUser isUser  &amp;  ( aDbUser groupName = self adminGroupName )		ifTrue: 			[  self broker revokeForClass: self  						permissions: self databasePrivilegesList						fromUsers: (Array with: aDbUser userName).			self broker revokeForClass: DBPundlePrivileges						permissions:self databasePrivilegesList						fromUsers: (Array with: aDbUser userName).			].</body><body package="Store-Ownership" selector="databasePrivilegesList">databasePrivilegesList	^ #( 'UPDATE' 'DELETE' 'INSERT')</body><body package="Store-Ownership" selector="fieldTypes">fieldTypes	| aDict  |	aDict := Dictionary new.	aDict at: 'groupName' put: #PrimaryKeyString.	aDict at: 'userName' put: #PrimaryKeyString.	aDict at: 'type' put: #String.	self checkFieldsWith: aDict.	^aDict</body><body package="Store-Ownership" selector="grantDatabasePrivilegesTo:">grantDatabasePrivilegesTo: userName	"This table is controlled by the system admin."	"self grantDatabasePrivilegesTo: 'eliot' "	[ self broker grantForClass: self 				permissions:  #( 'INSERT' 'UPDATE' 'DELETE')				toUsers:  userName	]	on: self connectionClass unableToExecuteSQLSignal 	do: [ :e | Dialog warn: e description ]</body><body package="Store-Ownership" selector="groupType">groupType	^'G'</body><body package="Store-Ownership" selector="indexParameters">indexParameters	^nil</body><body package="Store-Ownership" selector="needsSequence">needsSequence	^false</body><body package="Store-Ownership" selector="revokeDatabasePrivilegesFrom:">revokeDatabasePrivilegesFrom: userName	"This table is controlled by the system admin."	"self revokeDatabasePrivilegesTo: 'eliot' "	[ self  broker revokeForClass: self 				permissions: #('INSERT'  'UPDATE'  'DELETE' )				fromUsers:  userName	]	on: self connectionClass unableToExecuteSQLSignal 	do: [ :e | Dialog warn: e description ]</body><body package="Store-Ownership" selector="setDatabasePrivilegesForTable">setDatabasePrivilegesForTable	"This table is controlled by the system admin."	self broker grantForClass: self permissions: #('SELECT') toUsers: #('PUBLIC')</body><body package="Store-Ownership" selector="tableSpaceName">tableSpaceName	^'NEWBERN2'</body><body package="Store-Ownership" selector="userType">userType	^'U'</body></methods><methods><class-id>Store.DBUserGroup class</class-id> <category>menus</category><body package="Store-Ownership" selector="newUserNamed:inGroupNamed:">newUserNamed: aUserName inGroupNamed: aGroupName	"Add a user to a group."	| dbuser |	( dbuser  := self new )	 	groupName: aGroupName;		userName: aUserName;		makeUser.	[ dbuser installInDatabase ] 	on: self broker indexConflictSignal 	do: 	[ : e | e return ].			"adding again not really a mistake?"</body></methods><methods><class-id>Store.Association</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="referenceField">referenceField	"implement for any class doing package cross-referencing."	self subclassResponsibility</body></methods><methods><class-id>Store.Association class</class-id> <category>installation</category><body package="Store-DB-BaseObjects" selector="fieldTypes">fieldTypes	^Dictionary new.</body></methods><methods><class-id>Store.Association class</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="referenceColumn">referenceColumn	"implement for any class doing package cross-referencing."	^self subclassResponsibility</body><body package="Store-DB-BaseObjects" selector="viewColumnNames">viewColumnNames	"Answer a collection of column names that should be included 	into a view table."	^#()</body></methods><methods><class-id>Store.Association class</class-id> <category>private-garbage-collection</category><body package="Store-DB-BaseObjects" selector="allInstancesInAndOnlyIn:">allInstancesInAndOnlyIn: packageKeys	"Send to a concrete subclass. Answer a collection of ids of instance records 	that is in the set of packages and no others." 	| rows out in |	rows := self allPackagesCrossReferenced: packageKeys.	out := Set new: rows size.	in := Set new: rows size.	rows do:		[ :row |		( packageKeys includes: row packageRef )			ifTrue: 				[ ( out includes: row referenceField )					ifFalse: [ in add: row referenceField ]				]			ifFalse: 				[ out add: row referenceField.				in remove: row referenceField ifAbsent: nil.				]		].	^in asOrderedCollection</body><body package="Store-DB-BaseObjects" selector="allPackagesCrossReferenced:">allPackagesCrossReferenced: packageKeys	"Send to a concrete subclass. Answer a collection of instances that is in the set of packages and no others" 	^self allPackagesCrossReferenced: packageKeys refColumn: self referenceColumn</body><body package="Store-DB-BaseObjects" selector="allPackagesCrossReferenced:refColumn:">allPackagesCrossReferenced: packageKeys refColumn: refColumn	"Send to a concrete subclass. Answer a collection of instances that includes 	all the methods 	referenced by all the packages and back again."	"Methods allPackagesCrossReferenced: #( 100 178 ) refColumn: #methodRef"	| res maxIds answer pkeys |	"We need to make sure the query string isn't too long. 	What follows is an overly cautious."	maxIds :=  ( self broker maxSqlString - 100 ) // 10.	answer := OrderedCollection new: 500.	pkeys := packageKeys asOrderedCollection.	1 to: pkeys size by: maxIds do:		[ :index | | keys |		keys := pkeys copyFrom:  index to: ( ( index + maxIds - 1 min: packageKeys size ) ).		[ res := self broker 				getAnswerFromSession:  [ self crossRefSession: keys refColumn: refColumn ]				bindInput: [:x | ]		] on: self errorSignals do: [ :exp | self error: 'Cannot complete GC' ].		answer addAll: res.		].	^answer asOrderedCollection</body><body package="Store-DB-BaseObjects" selector="crossRefSession:refColumn:">crossRefSession: packageKeys refColumn: refColumn	"Answer a session for doing a cross-reference between packageKeys and a column."	"Send to a concrete subclass. NOTE- a once only session, so we're not saving it"	| stringKeys |	stringKeys := packageKeys collect: [ :k | k printString ].	^self broker getNewSession		bindOutput: self newPrimed;		blockFactor: ( self safeBlockFactor: 10000 );		prepare:			( self newSQL				selectAll;				where;				column: refColumn;				in: ( self newSQL						selectDistinct: ( Array with: refColumn );						where;						column: #packageRef equalToArray: stringKeys					)			);		yourself.</body><body package="Store-DB-BaseObjects" selector="removeAllConnectedTo:">removeAllConnectedTo: aPackageID	"Remove any record from the table which references aPackageID.	Note that this method can only be sent by the database system administrator, 	since it requires privileges that are not given to the regular users."	self deleteWhereColumn:  #packageRef value: aPackageID printString.</body></methods><methods><class-id>Store.Association class</class-id> <category>db-utilities</category><body package="Store-DB-BaseObjects" selector="itemCountForPackage:">itemCountForPackage: aPackageRef	"Ansert the number of instances associated with aPackageRef."	"Send to a concrete subclass."	| res query |	( query := self newSQLFor: self )		selectCountAll;		where;		column: #packageRef equalTo: aPackageRef printString.				res := self broker processSQL: query sqlString.	^res first first</body></methods><methods><class-id>Store.Data</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="dataRef">dataRef	"Answer the receiver's dataRef."	^dataRef</body><body package="Store-DB-Subdefs" selector="dataRef:">dataRef: newDataRef	"Set the receiver's dataRef to newDataRef."	dataRef := newDataRef</body><body package="Store-DB-Subdefs" selector="packageRef">packageRef	"Answer the receiver's packageRef."	^packageRef</body><body package="Store-DB-Subdefs" selector="packageRef:">packageRef: newPackageRef	"Set the receiver's packageRef to newPackageRef."	packageRef := newPackageRef</body><body package="Store-DB-Subdefs" selector="primaryKey">primaryKey	^OrderedCollection with: self  packageRef with: self methodRef</body><body package="Store-DB-Subdefs" selector="referenceField">referenceField	"implement for any class doing package cross-referencing."	^self dataRef</body></methods><methods><class-id>Store.Data</class-id> <category>printing</category><body package="Store-DB-Subdefs" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream 		nextPut: $(;		nextPutAll: packageRef printString, ': ', dataRef printString;		nextPut: $).</body></methods><methods><class-id>Store.Data class</class-id> <category>private-utilities</category><body package="Store-DB-Subdefs" selector="copyDataFromTrace:to:">copyDataFromTrace: oldPkgID to: newPkgID 	"Copy all data present in oldPkgID 	into newPkgID."	self broker process: 		( self newSQL				insert: #( packageRef dataRef );				select: 	(Array with: newPkgID printString with: #dataRef);				where;				column: #packageRef equalTo: oldPkgID printString).</body><body package="Store-DB-Subdefs" selector="removeDatum:inPackage:">removeDatum: dID inPackage: pkgID 	"Remove the row: pkgID, dID"	self broker process: (self newSQL						delete;						where;						column: #packageRef equalTo: pkgID printString;						and;						column: #dataRef equalTo: dID printString).</body><body package="Store-DB-Subdefs" selector="replaceDatum:with:inPackage:">replaceDatum: oldID with: newID inPackage: pkgID 	"Replace the row: pkgID, oldID with a row: pkgID, newID"	self broker process: (self newSQL						update;						column: #dataRef equalTo: newID printString;						where;						column: #packageRef equalTo: pkgID printString;						and;						column: #dataRef equalTo: oldID printString)</body></methods><methods><class-id>Store.Data class</class-id> <category>installation</category><body package="Store-DB-Subdefs" selector="fieldTypes">fieldTypes	| aDict  |	aDict := Dictionary new.	aDict at: 'packageRef' put: #PrimaryKey.	aDict at: 'dataRef' put: #PrimaryKey.	self checkFieldsWith: aDict.	^aDict</body><body package="Store-DB-Subdefs" selector="setDatabasePrivilegesForTable">setDatabasePrivilegesForTable	"We need update and delete on Data to speed up publishing."	super setDatabasePrivilegesForTable.	self broker grantForClass: self permissions: #('UPDATE' 'DELETE') toUsers: #('PUBLIC')</body></methods><methods><class-id>Store.Data class</class-id> <category>private-garbage-collection</category><body package="Store-DB-Subdefs" selector="createIndex">createIndex 	"Create index on dataRef to speed up	garbage collection process."	^self broker createIndexForClass: self</body><body package="Store-DB-Subdefs" selector="dropIndex">dropIndex 	"Drop index on dataRef to speed up	garbage collection process."	^self broker dropIndexForClass: self.</body><body package="Store-DB-Subdefs" selector="indexColumnNames">indexColumnNames 	^ Array with: 'dataRef'</body><body package="Store-DB-Subdefs" selector="indexName">indexName		^ '_DATUM_IDX'</body><body package="Store-DB-Subdefs" selector="packagesContainingDatum:">packagesContainingDatum: datumID 	"Check what packages define datumID.	Return a collection of package IDs "	"self packagesContainingDatum: 15"	^[(self broker process: 			( self newSQL				select: #( packageRef );				where;				column: #dataRef equalTo: datumID printString)	 ) collect: [:each| each first]	]	on: self  errorSignals 	do: 	[:ex | ex outer.  OrderedCollection new ].</body></methods><methods><class-id>Store.Data class</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="referenceColumn">referenceColumn		^#dataRef</body></methods><methods><class-id>Store.PkgNameSpaces</class-id> <category>accessing</category><body package="Store-DB-Records" selector="definitionOrder">definitionOrder	"Answer the receiver's definitionOrder."	^definitionOrder</body><body package="Store-DB-Records" selector="definitionOrder:">definitionOrder: newClassOrder	"Set the receiver's definitionOrder to newClassOrder."	definitionOrder := newClassOrder</body><body package="Store-DB-Records" selector="nameSpaceRef">nameSpaceRef	"Answer the receiver's nameSpaceRef."	^nameSpaceRef</body><body package="Store-DB-Records" selector="nameSpaceRef:">nameSpaceRef: newNameSpaceRef	"Set the receiver's nameSpaceRef to newNameSpaceRef."	nameSpaceRef := newNameSpaceRef</body><body package="Store-DB-Records" selector="packageRef">packageRef	"Answer the receiver's packageRef."	^packageRef</body><body package="Store-DB-Records" selector="packageRef:">packageRef: newPackageRef	"Set the receiver's packageRef to newPackageRef."	packageRef := newPackageRef</body><body package="Store-DB-Records" selector="primaryKey">primaryKey	^OrderedCollection with: self  packageRef with: self nameSpaceRef</body><body package="Store-DB-Records" selector="referenceField">referenceField	"implement for any class doing package cross-referencing."	^self nameSpaceRef</body></methods><methods><class-id>Store.PkgNameSpaces class</class-id> <category>installation</category><body package="Store-DB-Records" selector="fieldTypes">fieldTypes	| dict |	( dict := Dictionary new )		at: 'packageRef' put: #PrimaryKey;	 	at: 'nameSpaceRef' put: #PrimaryKey;		at: 'definitionOrder' put: #Integer.	self checkFieldsWith: dict.	^dict</body></methods><methods><class-id>Store.PkgNameSpaces class</class-id> <category>private-garbage-collection</category><body package="Store-DB-Records" selector="packagesContainingNameSpace:">packagesContainingNameSpace: anID	"Check what packages define a given class. Return a collection of package IDs "	^[(self broker process: 			( self newSQL				select: #( packageRef );				where;				column: #nameSpaceRef equalTo: anID printString)	 ) collect: [ :each | each first ]	] 	on: self  errorSignals 	do: 	[:ex |   ex outer. OrderedCollection new].</body></methods><methods><class-id>Store.PkgNameSpaces class</class-id> <category>accessing</category><body package="Store-DB-Records" selector="referenceColumn">referenceColumn		^#nameSpaceRef</body></methods><methods><class-id>Store.Properties</class-id> <category>printing</category><body package="Store-DB-Records" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream 		nextPut: $(;		nextPutAll: pundleRef printString, ': ', propertyRef printString, '(', recType printString, ')';		nextPut: $).</body></methods><methods><class-id>Store.Properties</class-id> <category>accessing</category><body package="Store-DB-Records" selector="primaryKey">primaryKey	^OrderedCollection 		with: self packageRef		with: self propertyRef		with: self recType</body><body package="Store-DB-Records" selector="propertyRef">propertyRef	"Answer the receiver's propertyRef."	^propertyRef</body><body package="Store-DB-Records" selector="propertyRef:">propertyRef: newPropertyRef 	"Set the receiver's propertyRef to newPropertyRef."	propertyRef := newPropertyRef</body><body package="Store-DB-Records" selector="pundleRef">pundleRef	"Answer the receiver's pundleRef."	^pundleRef</body><body package="Store-DB-Records" selector="pundleRef:">pundleRef: newPundleRef 	"Set the receiver's pundleRef to newPundleRef."	pundleRef := newPundleRef</body><body package="Store-DB-Records" selector="recType">recType	"Answer the receiver's recType."	^recType</body><body package="Store-DB-Records" selector="recType:">recType: newRecType	"Set the receiver's recType to newRecType."	recType := newRecType</body><body package="Store-DB-Records" selector="referenceField">referenceField	"implement for any class doing package cross-referencing."	^self propertyRef</body></methods><methods><class-id>Store.Properties class</class-id> <category>accessing</category><body package="Store-DB-Records" selector="referenceColumn">referenceColumn		^#propertyRef</body><body package="Store-DB-Records" selector="typeCodeForBundles">typeCodeForBundles	^0</body><body package="Store-DB-Records" selector="typeCodeForClass:">typeCodeForClass: aClass 	"self typeCodeForClass: Package"	^(aClass isKindOf: Bundle) 		ifTrue: [self typeCodeForBundles]		ifFalse: [self typeCodeForPackages]</body><body package="Store-DB-Records" selector="typeCodeForPackages">typeCodeForPackages	^1</body></methods><methods><class-id>Store.Properties class</class-id> <category>installation</category><body package="Store-DB-Records" selector="fieldTypes">fieldTypes	"Note: recType left out here defaults correctly to VARCHAR(255)."	| aDict  |	aDict := Dictionary new.	aDict at: 'pundleRef' put: #PrimaryKey.	aDict at: 'propertyRef' put: #PrimaryKey.	aDict at: 'recType' put: #PrimaryKey.	self checkFieldsWith: aDict.	^aDict</body></methods><methods><class-id>Store.Properties class</class-id> <category>private-garbage-collection</category><body package="Store-DB-Records" selector="bundlesContainingProperty:">bundlesContainingProperty: anID	"Check what bundles define a given property. Return a collection of bundle IDs."	^self pundlesContainingProperty: anID type: self typeCodeForBundles</body><body package="Store-DB-Records" selector="packagesContainingProperty:">packagesContainingProperty: anID	"Check what packages define a given property. Return a collection of package IDs "	^self pundlesContainingProperty: anID type: self typeCodeForPackages</body><body package="Store-DB-Records" selector="pundlesContainingProperty:type:">pundlesContainingProperty: anID type: aRecordTypeCode	"Check what pundles define a given property. Return a collection of pundle IDs.	aRecordTypeString is part of the key, eg., 0 for bundle, 1 for package."	^[(self broker process: 			( self newSQL				select: #( pundleRef );				where;				column: #propertyRef equalTo: anID printString;				and;				column: #recType equalTo: aRecordTypeCode printString)	 ) collect: [ :each | each first ]	] 	on: self  errorSignals 	do: 	[:ex |   ex outer. OrderedCollection new].</body></methods><methods><class-id>Store.Methods</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="methodRef">methodRef	"Answer the receiver's methodRef."	^methodRef</body><body package="Store-DB-Subdefs" selector="methodRef:">methodRef: newMethodRef	"Set the receiver's methodRef to newMethodRef."	methodRef := newMethodRef</body><body package="Store-DB-Subdefs" selector="packageRef">packageRef	"Answer the receiver's packageRef."	^packageRef</body><body package="Store-DB-Subdefs" selector="packageRef:">packageRef: newPackageRef	"Set the receiver's packageRef to newPackageRef."	packageRef := newPackageRef</body><body package="Store-DB-Subdefs" selector="primaryKey">primaryKey	^OrderedCollection with: self  packageRef with: self methodRef</body><body package="Store-DB-Subdefs" selector="referenceField">referenceField	"implement for any class doing package cross-referencing."	^self methodRef</body></methods><methods><class-id>Store.Methods</class-id> <category>printing</category><body package="Store-DB-Subdefs" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream 		nextPut: $(;		nextPutAll: packageRef printString;		nextPutAll: ' - ';		nextPutAll: methodRef printString;		nextPut: $).</body></methods><methods><class-id>Store.Methods class</class-id> <category>private-utilities</category><body package="Store-DB-Subdefs" selector="copyMethodsFromTrace:to:">copyMethodsFromTrace: oldPkgID to: newPkgID 	"Copy all methods present in oldPkgID 	into newPkgID."	self broker process: 		( self newSQL				insert: #( packageRef methodRef );				select: 	( Array with: newPkgID printString with: #methodRef );				where;				column: #packageRef equalTo: oldPkgID printString).</body><body package="Store-DB-Subdefs" selector="removeMethod:inPackage:">removeMethod: mID inPackage: pkgID 	"Remove the row: pkgID, mID"	self broker process: (self newSQL						delete;						where;						column: #packageRef equalTo: pkgID printString;						and;						column: #methodRef equalTo: mID printString).</body><body package="Store-DB-Subdefs" selector="replaceMethod:with:inPackage:">replaceMethod: oldID with: newID inPackage: pkgID 	"Replace the row: pkgID, oldID with a row: pkgID, newID"	self broker process: (self newSQL						update;						column: #methodRef equalTo: newID printString;						where;						column: #packageRef equalTo: pkgID printString;						and;						column: #methodRef equalTo: oldID printString)</body></methods><methods><class-id>Store.Methods class</class-id> <category>installation</category><body package="Store-DB-Subdefs" selector="fieldTypes">fieldTypes	| aDict  |	aDict := Dictionary new.	aDict at: 'packageRef' put: #PrimaryKey.	aDict at: 'methodRef' put: #PrimaryKey.	self checkFieldsWith: aDict.	^aDict</body><body package="Store-DB-Subdefs" selector="indexParameters">indexParameters	"Answer a string specifying index parameters. If the default index is acceptable 	answer nil."	^'TABLESPACE  NEWBERN2 STORAGE(INITIAL 3M NEXT 512K) '</body><body package="Store-DB-Subdefs" selector="setDatabasePrivilegesForTable">setDatabasePrivilegesForTable	"We need update and delete on TT_Methods to speed up publishing."	super setDatabasePrivilegesForTable.	self broker grantForClass: self permissions: #('UPDATE' 'DELETE') toUsers: #('PUBLIC')</body><body package="Store-DB-Subdefs" selector="storageParameters">storageParameters	"Answer a string describing special storage parameters for the table or nil if the default parameters are 	acceptable answer."	^'STORAGE(INITIAL 3M NEXT 512K PCTINCREASE 1) '</body></methods><methods><class-id>Store.Methods class</class-id> <category>private-garbage-collection</category><body package="Store-DB-Subdefs" selector="allPackagesMethodsCrossReferenced:">allPackagesMethodsCrossReferenced: packageKeys	"Answer a collection of Methods that includes all the methods referenced by all the packages and	back again."	"Methods allPackagesMethodsCrossReferenced: #( 100 178 )"	| str res stringKeys |	stringKeys := packageKeys collect: [ :k | k printString ].	[ str := self newSQL			selectAll;			where;			column: #methodRef;			in: ( self newSQL					selectDistinct: #( methodRef );					where;					column: #packageRef equalToArray: stringKeys				).	res := self processList: ( self broker process: str bindOutput: self newPrimed ).	DbRegistry printDebug: 'Method&gt;&gt;allPackagesMethodsCrossReferenced:..'; printDebug: res.	] on: self errorSignals  	  do: [ :ex | ex outer. ^OrderedCollection new ].	^res</body><body package="Store-DB-Subdefs" selector="createIndex">createIndex 	"Create index on methodRef to speed up	garbage collection process."	^self broker createIndexForClass: self</body><body package="Store-DB-Subdefs" selector="dropIndex">dropIndex 	"Drop index on methodRef to speed up	garbage collection process."	^self broker dropIndexForClass: self</body><body package="Store-DB-Subdefs" selector="gcSession">gcSession	"Answer a session for retriving all the rows in the methods table."	"Note: there's no point in saving it since this will only be preformed once."	^self broker getNewSession		bindOutput: self newPrimed;		blockFactor: ( self safeBlockFactor: 10000 );		prepare: self newSQL selectAll;		yourself</body><body package="Store-DB-Subdefs" selector="indexColumnNames">indexColumnNames	^ Array with: 'methodRef'</body><body package="Store-DB-Subdefs" selector="indexName">indexName	^'_METHOD_IDX'</body><body package="Store-DB-Subdefs" selector="methodsInAndOnlyIn:">methodsInAndOnlyIn: aSetOfPackageIds	"Answers a set of method refs that are in the packages represented by their ids, 	but not in any other package."	"Methods methodsInAndOnlyIn: #( 100 178 )"	| keep remove |	keep := Set new: ( aSetOfPackageIds size * 500 ).	remove := Set new: ( aSetOfPackageIds size * 50 ).	( self allPackagesMethodsCrossReferenced: aSetOfPackageIds ) do:		[ :row |		( aSetOfPackageIds includes: row packageRef )			ifTrue: 				[ ( keep includes: row methodRef )					ifFalse: [ remove add: row methodRef ]				]			ifFalse: 				[ keep add: row methodRef.				remove remove: row methodRef ifAbsent: nil.				]		].	^remove</body><body package="Store-DB-Subdefs" selector="methodsInAndOnlyInOLD:">methodsInAndOnlyInOLD: aSetOfPackageIds	"Answers a set of method refs that are in the packages represented by their ids, 	but not in any other package."	| stream row keep remove |	keep := Set new: 50000.	remove := Set new: 5000.	stream := self gcSession execute; answer.	[ stream atEnd ] whileFalse:		[ row := stream next.		( aSetOfPackageIds includes: row packageRef )			ifTrue: 				[ ( keep includes: row methodRef )					ifFalse: [ remove add: row methodRef ]				]			ifFalse: 				[ keep add: row methodRef.				remove remove: row methodRef ifAbsent: nil.				]		].	^remove</body><body package="Store-DB-Subdefs" selector="packagesContainingMethod:">packagesContainingMethod: methodID 	"Check what packages define methodID.	Return a collection of package IDs "	"self packagesContainingMethod: 15"	^ (self broker process: 			( self newSQL				select: #( packageRef );				where;				column: #methodRef equalTo: methodID printString))		collect: [:each| each first]</body></methods><methods><class-id>Store.Methods class</class-id> <category>session</category><body package="Store-DB-Subdefs" selector="defaultBlockFactor">defaultBlockFactor	^1000</body></methods><methods><class-id>Store.Methods class</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="referenceColumn">referenceColumn		^#methodRef</body></methods><methods><class-id>Store.PkgClasses</class-id> <category>accessing</category><body package="Store-DB-Records" selector="classRef">classRef	"Answer the receiver's classRef."	^classRef</body><body package="Store-DB-Records" selector="classRef:">classRef: newClassRef	"Set the receiver's classRef to newClassRef."	classRef := newClassRef</body><body package="Store-DB-Records" selector="definitionOrder">definitionOrder	"Answer the receiver's definitionOrder."	^definitionOrder</body><body package="Store-DB-Records" selector="definitionOrder:">definitionOrder: newClassOrder	"Set the receiver's definitionOrder to newClassOrder."	definitionOrder := newClassOrder</body><body package="Store-DB-Records" selector="metaclassRef">metaclassRef	"Answer the receiver's metaclassRef."	^metaclassRef</body><body package="Store-DB-Records" selector="metaclassRef:">metaclassRef: newMetaclassRef	"Set the receiver's metaclassRef to newMetaclassRef."	metaclassRef := newMetaclassRef</body><body package="Store-DB-Records" selector="packageRef">packageRef	"Answer the receiver's packageRef."	^packageRef</body><body package="Store-DB-Records" selector="packageRef:">packageRef: newPackageRef	"Set the receiver's packageRef to newPackageRef."	packageRef := newPackageRef</body><body package="Store-DB-Records" selector="primaryKey">primaryKey	^OrderedCollection with: self  packageRef with: self classRef with: self metaclassRef</body><body package="Store-DB-Records" selector="referenceField">referenceField	"implement for any class doing package cross-referencing."	^self classRef</body></methods><methods><class-id>Store.PkgClasses</class-id> <category>printing</category><body package="Store-DB-Records" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream 		nextPut: $(;		nextPutAll: packageRef printString, ': ', classRef printString, ' ', metaclassRef printString;		nextPut: $).</body></methods><methods><class-id>Store.PkgClasses class</class-id> <category>private-utilities</category><body package="Store-DB-Records" selector="copyClassesFromTrace:to:">copyClassesFromTrace: oldPkgID to: newPkgID 	"Copy all methods present in oldPkgID 	into newPkgID."	self broker process: 		( self newSQL				insert:  #( packageRef classRef metaclassRef classOrder );				select: 	( Array with: newPkgID printString with: #classRef with: #metaclassRef with: #classOrder );				where;				column: #packageRef equalTo: oldPkgID printString).</body><body package="Store-DB-Records" selector="removeClass:meta:inPackage:">removeClass: oldID meta: oldMetaID  inPackage: pkgID 	"Remove the row: pkgID, mID"	self broker process: (self newSQL						delete;						where;						column: #packageRef equalTo: pkgID printString;						and;						column: #classRef equalTo: oldID printString;						and;						column: #metaclassRef equalTo: oldMetaID printString).</body><body package="Store-DB-Records" selector="replaceClass:meta:with:meta:inPackage:">replaceClass: oldID meta: oldMetaID with: newID meta: newMetaID inPackage: pkgID 	"Replace the row: pkgID, oldID with a row: pkgID, newID"	self broker process: (self newSQL						update;						column: #classRef equalTo: newID printString;						column: #metaclassRef equalTo:newMetaID printString;						where;						column: #packageRef equalTo: pkgID printString;						and;						column: #classRef equalTo: oldID printString;						and;						column: #metaclassRef equalTo: oldMetaID printString)</body></methods><methods><class-id>Store.PkgClasses class</class-id> <category>installation</category><body package="Store-DB-Records" selector="fieldTypes">fieldTypes	| dict |	( dict := Dictionary new )		at: 'packageRef' put: #PrimaryKey;	 	at: 'classRef' put: #PrimaryKey;		at: 'metaclassRef' put: #PrimaryKey;		at: 'definitionOrder' put: #Integer.	self checkFieldsWith: dict.	^dict</body></methods><methods><class-id>Store.PkgClasses class</class-id> <category>private-garbage-collection</category><body package="Store-DB-Records" selector="allMetaclassesInAndOnlyIn:">allMetaclassesInAndOnlyIn: packageKeys	"Send to a concrete subclass. Answer a collection of ids of instance records 	that is in the set of packages and no others." 	"Already obsolete :-). But I need it for old packages."	| rows out in |	rows := self allPackagesCrossReferenced: packageKeys refColumn: #metaclassRef.	out := Set new: rows size.	in := Set new: rows size.	rows do:		[ :row |		( packageKeys includes: row packageRef )			ifTrue: 				[ ( out includes: row metaclassRef )					ifFalse: [ in add: row metaclassRef ]				]			ifFalse: 				[ out add: row metaclassRef.				in remove: row metaclassRef ifAbsent: nil.				]		].	^in asOrderedCollection</body><body package="Store-DB-Records" selector="packagesContainingClass:">packagesContainingClass: aClassID	"Check what packages define a given class.	Return a collection of package IDs "	"self packagesContainingClass: 2978"	^[(self broker process: 				( self newSQL					select: #( packageRef );					where;					column: #classRef equalTo: aClassID printString)	 ) collect: [:each| each first]	] 	on: self  errorSignals 	do: 	[:ex |   ex outer.  OrderedCollection new].</body><body package="Store-DB-Records" selector="packagesContainingMetaclass:">packagesContainingMetaclass: aClassID	"Check what packages define a given class.	Return a collection of package IDs "	"self packagesContainingMetaclass: 2982"	^[(self broker process: 					( self newSQL						select: #( packageRef );						where;						column: #metaclassRef equalTo: aClassID printString)	 )  collect: [:each| each first]	] 	on: self  errorSignals 	do: 	[:ex |   ex outer. OrderedCollection new].</body></methods><methods><class-id>Store.PkgClasses class</class-id> <category>accessing</category><body package="Store-DB-Records" selector="referenceColumn">referenceColumn		^#classRef</body></methods><methods><class-id>Store.DBRecord</class-id> <category>support</category><body package="Store-DB-BaseObjects" selector="textForItem">textForItem	^DbRegistry textForItem: self</body></methods><methods><class-id>Store.DBRecord</class-id> <category>comparing</category><body package="Store-DB-BaseObjects" selector="youngerThan:">youngerThan: aPackage	"Answer true if I'm younger then aPackage."	^aPackage isLoaded		ifTrue: [ ( aPackage youngerThan: self ) not ]		ifFalse: [ self primaryKey &gt; aPackage primaryKey ].</body></methods><methods><class-id>Store.DBRecord</class-id> <category>printing</category><body package="Store-DB-BaseObjects" selector="displayString">displayString	^self textForItem</body></methods><methods><class-id>Store.DBRecord</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="dbIdentifier">dbIdentifier	"Answer the receiver's database identifier."	^dbIdentifier</body><body package="Store-DB-BaseObjects" selector="dbIdentifier:">dbIdentifier: aSymbol	"Set the receiver's database identifier."	dbIdentifier := aSymbol asSymbol</body><body package="Store-DB-BaseObjects" selector="dbTrace">dbTrace	"Answer the receiver's trace."	^trace</body><body package="Store-DB-BaseObjects" selector="dbTrace:">dbTrace: newTrace	"Set the receiver's trace to newTrace."	trace := newTrace</body><body package="Store-DB-BaseObjects" selector="name">name	^name</body><body package="Store-DB-BaseObjects" selector="name:">name: anObject	name := anObject</body><body package="Store-DB-BaseObjects" selector="primaryKey">primaryKey	"Answer the receiver's primaryKey."	^primaryKey</body><body package="Store-DB-BaseObjects" selector="primaryKey:">primaryKey: newPrimaryKey	"Set the receiver's primaryKey to newPrimaryKey."	primaryKey := newPrimaryKey</body><body package="Store-DB-BaseObjects" selector="setVersionTo:">setVersionTo: aVersion	self broker process: 			( self newSQL				update;				column: #version  equalTo: aVersion printString;				where;				column: #primaryKey equalTo: self primaryKey printString).	 self version: aVersion.</body><body package="Store-DB-BaseObjects" selector="timeStamp">timeStamp	"Answer the receiver's timeStamp."	^timeStamp</body><body package="Store-DB-BaseObjects" selector="timeStamp:">timeStamp: newTimeStamp	"Set the receiver's timeStamp to newTimeStamp."	timeStamp := newTimeStamp</body><body package="Store-DB-BaseObjects" selector="trace">trace	"Answer the receiver's trace."	^trace</body><body package="Store-DB-BaseObjects" selector="trace:">trace: newTrace	"Set the receiver's trace to newTrace."	trace := newTrace</body><body package="Store-DB-BaseObjects" selector="userName">userName	^userName</body><body package="Store-DB-BaseObjects" selector="userName:">userName: anObject	userName := anObject</body><body package="Store-DB-BaseObjects" selector="version">version	^version</body><body package="Store-DB-BaseObjects" selector="version:">version: anObject	version := anObject</body></methods><methods><class-id>Store.DBRecord</class-id> <category>db-utilities</category><body package="Store-DB-BaseObjects" selector="children">children	"Consult the database and find all my children."	| coll |	coll := self broker process:				(self newSQL					selectAll;					where;					column: #trace equalTo: ':primaryKey')				bindInput: self				bindOutput: self class newPrimed.	coll		do: 			[:each | 			each unprime.			each processFields].	^coll</body><body package="Store-DB-BaseObjects" selector="classOfDbRecord">classOfDbRecord	"Answer a class which is used to represent packages in the database."	"In this case, the receiver's class."	^self class.</body></methods><methods><class-id>Store.DBRecord</class-id> <category>private-garbage-collection</category><body package="Store-DB-BaseObjects" selector="removeRecordFromDB">removeRecordFromDB	"Remove a record representing me from the database.	Note that this method can only be sent by the database	system administrator, since it requires privileges	that are not given to the regular users."	self broker process:				(self newSQL					delete;					where;					column: #primaryKey equalTo: ':primaryKey')			bindInput: self</body><body package="Store-DB-BaseObjects" selector="updateTrace:">updateTrace: newTrace	"Change the trace field in the database.	Note that this method can only be sent by the database system administrator, 	since it requires privileges that are not given to the regular users."	self dbTrace:  newTrace.	self broker process: 					( self newSQL					update;					column: #trace equalTo: ':trace';					where;					column: #primaryKey equalTo: ':primaryKey')			bindInput: self</body></methods><methods><class-id>Store.DBRecord</class-id> <category>testing</category><body package="Store-DB-BaseObjects" selector="isInCurrentDatabase">isInCurrentDatabase	^dbIdentifier = nil		or: [ dbIdentifier = DbRegistry dbIdentifier ].</body></methods><methods><class-id>Store.DBRecord</class-id> <category>private</category><body package="Store-DB-BaseObjects" selector="prime">prime	"Put instances of Object into slots that are not mapped into columns in the DB.	This is crucial for reading from DB since the primed slots are skipped"	super prime.	dbIdentifier := Object new.</body><body package="Store-DB-BaseObjects" selector="unprime">unprime	"Remove the effect of priming (see the prime method)."	super unprime.	dbIdentifier := DbRegistry dbIdentifier.		"where we came from"</body></methods><methods><class-id>Store.DBRecord class</class-id> <category>installation</category><body package="Store-DB-BaseObjects" selector="columnNames">columnNames		"self columnNames"	^super columnNames		remove: 'dbIdentifier';		yourself</body><body package="Store-DB-BaseObjects" selector="fieldTypes">fieldTypes	| aDict |	aDict := Dictionary new.	aDict at: 'primaryKey' put: #PrimaryKey.	aDict at: 'timeStamp' put: #Integer.	aDict at: 'trace' put: #Integer.	^aDict</body><body package="Store-DB-BaseObjects" selector="viewColumnNames">viewColumnNames 	"This message is overided by collection classes that define	complex views."	^#()</body></methods><methods><class-id>Store.DBRecord class</class-id> <category>db-utilities</category><body package="Store-DB-BaseObjects" selector="allNames">allNames	"Answer a collection of all names known to the database."	"Note: should be sent to an appropiate subclass."	^ Cursor database showWhile: [		[ (( self broker process: 				(self newSQL					selectDistinct: #( name ))		  ) collect: [ :n | n first ] ) asSortedCollection		]		on: self errorSignals 		do: 	[ :ex | ex outer.				OrderedCollection new			].	]</body><body package="Store-DB-BaseObjects" selector="allVersionsWithName:">allVersionsWithName: aName 	"Answer a colection of db records"	"Note: should be sent to an appropiate subclass."	^[(self doPostLoadProcessingOn:		(self broker process: 					( self newSQL					selectAll;					where;					column: #name equalTo: aName asString printString)				bindOutput: self newPrimed)		) asSortedCollection: [ :x :y | x primaryKey &gt; y primaryKey ]	] 	on: self errorSignals 	do: 	[ :ex | ex outer. 			OrderedCollection new		].</body><body package="Store-DB-BaseObjects" selector="allVersionsWithName:after:">allVersionsWithName: aName after: dbTrace	"Answer a colection of db records, that were published since dbTrace."	"Note: should be sent to an appropiate subclass."	| items |	[	items := self doPostLoadProcessingOn: 				(self broker process:							( self newSQL								selectAll;								where;								column: #name  equalTo: aName asString printString;								and;								column: #primaryKey greaterThan: dbTrace printString)						bindOutput: self newPrimed).			1 to: items size	do: 				[ :i |  | pkg cached |					pkg := items at: i.					cached := self cachedItemFor: pkg.					items at: i put: cached]	]	on: self  errorSignals 	do: 	[ :ex |  ex outer.			^OrderedCollection new		].						^items asSortedCollection: [ :x :y | x primaryKey &gt; y primaryKey ]</body><body package="Store-DB-BaseObjects" selector="allVersionsWithName:blessingLevel:">allVersionsWithName: aName blessingLevel: anInteger	^self allVersionsWithName: aName blessingLevels:(Array with: anInteger)</body><body package="Store-DB-BaseObjects" selector="allVersionsWithName:blessingLevels:">allVersionsWithName: aName blessingLevels: anArray	"Answer a colection of db records"	"Note: should be sent to an appropiate subclass."	|  items sqlStatement blessingORConditionalStatement |	"SELECT * FROM .. WHERE name = ..   AND (.. OR ...) "	sqlStatement := self newSQL 					selectAll; 					where; 					column: #name equalTo: aName asString printString;					and;					beginClause.	blessingORConditionalStatement := WriteStream on: (String new: 64).	anArray 		do:[:each | blessingORConditionalStatement 								nextPutAll: 'blessingLevel = '; 								print: each ] 		separatedBy:[ blessingORConditionalStatement nextPutAll: ' OR '].	sqlStatement addString:  blessingORConditionalStatement contents.	sqlStatement endClause.	[ items := self doPostLoadProcessingOn:				(self broker process: sqlStatement sqlString 						bindOutput: self newPrimed)	] 	on: self  errorSignals 	do: 	[ :ex | ex outer.			 ^OrderedCollection new 		].		^items asSortedCollection: [ :x :y | x primaryKey &gt; y primaryKey ]</body><body package="Store-DB-BaseObjects" selector="allVersionsWithName:newerThan:">allVersionsWithName: aName newerThan: aDBRecord	"Answer a colection of db records"	"Note: should be sent to an appropriate subclass."	^[(self doPostLoadProcessingOn:					(self broker process: 							( self newSQL								selectAll;								where;								column: #primaryKey greaterThan: aDBRecord primaryKey printString;								and;								column: #name  equalTo:  aName asString printString)				 bindOutput: self newPrimed)	 ) asSortedCollection: [ :x :y | x primaryKey &gt; y primaryKey ]	] 	on: self  errorSignals 	do: 	[ :ex | ex outer.			OrderedCollection new		].</body><body package="Store-DB-BaseObjects" selector="aRecordWithID:">aRecordWithID: anID 	"Get a DB record identified by anID from the DB."	"This method can only be used for concrete subclasses." 	^ self getRecordWithID: anID</body><body package="Store-DB-BaseObjects" selector="doPostLoadProcessingOn:">doPostLoadProcessingOn: dbRecords 	^self processList: dbRecords.</body><body package="Store-DB-BaseObjects" selector="newestVersionWithName:">newestVersionWithName: aName 	"Answer a colection of db records"	"Note: should be sent to an appropriate subclass."	| items sqlString |	sqlString := self newSQL					selectAll;					where;					column: #primaryKey;					equal;					beginClause;					addString: ( self newSQL									selectMax: #( primaryKey );									where;									column: #name equalTo: aName asString printString);					endClause.	^self isOnline		ifTrue:			[ ( items := self doPostLoadProcessingOn: 				(self broker process: sqlString bindOutput: self newPrimed))			isEmpty				ifFalse: [ items first ].			].</body><body package="Store-DB-BaseObjects" selector="retrievalErrorString">retrievalErrorString	^'Error encountered (&lt;1s&gt;).\Versions of: &lt;2s&gt; cannot be retrieved' withCRs</body><body package="Store-DB-BaseObjects" selector="withName:version:">withName: aName version: aVersion 	"Answer a collection of DBRecords."	"Note: should be sent to an appropiate subclass."	^ [(self doPostLoadProcessingOn:					(self broker process:						( self newSQL							selectAll;							where;							column: #name equalTo: aName asString printString;							and;							column: #version equalTo: aVersion asString printString)				 bindOutput: self newPrimed)	 ) asOrderedCollection		] 	on: self  errorSignals 	do: 	[ :ex | ex outer. 			OrderedCollection new 		].</body></methods><methods><class-id>Store.DBRecord class</class-id> <category>private-garbage collection</category><body package="Store-DB-BaseObjects" selector="removeFromDB:">removeFromDB: primaryKeys	"Remove all the records with matching primaryKeys."	"Generic method -- send to concrete subclass."	| maxIds pkeys |	maxIds :=  ( self broker maxSqlString - 100 ) // 10.	pkeys :=  primaryKeys asOrderedCollection collect: [ :k | k printString ].	1 to: pkeys size by: maxIds do:		[ :index | | keys |		keys := pkeys copyFrom:  index to: ( index + maxIds - 1 min: pkeys size ).		self broker process:			( self newSQL				delete;				where;				column: #primaryKey equalToArray: keys			).		].</body><body package="Store-DB-BaseObjects" selector="removeRecordsFromDB:">removeRecordsFromDB: records	"Remove all the records from the database."	"Generic method -- send to concrete subclass."	self removeFromDB: 		( records collect: [ :rec | rec primaryKey ] )</body></methods><methods><class-id>Store.DBRecord class</class-id> <category>private</category><body package="Store-DB-BaseObjects" selector="getRecordWithID:">getRecordWithID: anID 	"Get a DB record identified by 'anID' from the DB. 	Use the prepared session stored in the PrimaryKeySession class instance 	variable.	This is a private method. Use aRecordWithID:"	| dbRecs res |	[dbRecs := self broker getAnswerFromSession: [self primaryKeySession]			bindInput: [:session| session bindInput primaryKey: anID ].	]	on: self  errorSignals 	do: 	[ :ex |   ex outer. ^nil ].	dbRecs isEmpty		ifTrue: [^nil]		ifFalse: [res := dbRecs first].	res unprime.	res processFields.	^res</body></methods><methods><class-id>Store.Record</class-id> <category>testing</category><body package="Store-DB-BaseObjects" selector="isClass">isClass	^false</body><body package="Store-DB-BaseObjects" selector="isDataModel">isDataModel	"Is this a Bernstein data model?"	^true</body><body package="Store-DB-BaseObjects" selector="isExtension">isExtension	^false</body><body package="Store-DB-BaseObjects" selector="isForClass">isForClass			^false</body><body package="Store-DB-BaseObjects" selector="isForData">isForData	^false</body><body package="Store-DB-BaseObjects" selector="isForGeneral">isForGeneral	^false</body><body package="Store-DB-BaseObjects" selector="isForMethod">isForMethod	^false</body><body package="Store-DB-BaseObjects" selector="isForNameSpace">isForNameSpace			^false</body><body package="Store-DB-BaseObjects" selector="isForProperty">isForProperty			^false</body><body package="Store-DB-BaseObjects" selector="isLoaded">isLoaded	^false</body><body package="Store-DB-BaseObjects" selector="isPseudo">isPseudo	^false.</body></methods><methods><class-id>Store.Record</class-id> <category>comparing</category><body package="Store-DB-BaseObjects" selector="sameAs:">sameAs: aThing 	^aThing notNil and: [aThing sameAsDBThing: self]</body><body package="Store-DB-BaseObjects" selector="sameAsDBThing:">sameAsDBThing: aThing	"If primary key is not set then a records have to be indentical."	aThing class ~= self class ifTrue: [^false].	self primaryKey isNil ifTrue: [^aThing == self].	^aThing primaryKey =  self primaryKey</body></methods><methods><class-id>Store.Record</class-id> <category>printing</category><body package="Store-DB-BaseObjects" selector="fullDisplayString">fullDisplayString	^self displayString</body><body package="Store-DB-BaseObjects" selector="itemString">itemString	^self name , self versionString</body><body package="Store-DB-BaseObjects" selector="longItemString">longItemString	| vr un |	vr := self version.	vr isNil ifTrue: [vr := 'unknown'].	un := self userName.	un isNil ifTrue: [un := 'unknown'].	^self name, '		(' , vr , ',' , un , ') 		', self timeStampString</body><body package="Store-DB-BaseObjects" selector="printOn:">printOn: aStream		aStream nextPut: ${.	name printOn: aStream.	aStream nextPut: $-.	version printOn: aStream.	aStream nextPut: $-.	primaryKey printOn: aStream.	aStream nextPut: $}.</body><body package="Store-DB-BaseObjects" selector="versionString">versionString	| vr un |	vr := self version.	un := self userName.	( vr == nil and: [ un == nil ] )		ifTrue: [ ^'' ].			( vr isNil or: [ vr class = Object ] ) 		ifTrue: [ vr := self timeStampString ].	un isNil ifTrue: [un := 'unknown' ].	^'(' , vr , ',' , un , ')'</body><body package="Store-DB-BaseObjects" selector="versionStringAlternate">versionStringAlternate	^self versionString</body></methods><methods><class-id>Store.Record</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="getTrace">getTrace	"Given an ID of a record get the real record from 	database. If trace is zero answer nil."	^self class aRecordWithID: self dbTrace</body><body package="Store-DB-BaseObjects" selector="hasTrace">hasTrace	^self dbTrace notNil and: [self dbTrace ~= 0]</body><body package="Store-DB-BaseObjects" selector="setNoTrace">setNoTrace	self setTrace: nil</body><body package="Store-DB-BaseObjects" selector="setTrace:">setTrace: aDBRecord	trace := aDBRecord isNil ifTrue: [0] ifFalse: [aDBRecord primaryKey]</body></methods><methods><class-id>Store.Record</class-id> <category>private</category><body package="Store-DB-BaseObjects" selector="getDefinitionID:">getDefinitionID: anID		| record |	( record := self getDefinitionRecordID: anID ) notNil				ifTrue: [ ^record definition ].		^String new.</body><body package="Store-DB-BaseObjects" selector="getDefinitionRecordID:">getDefinitionRecordID: anID	"Given an ID of a record containing a string definition	answer a record."	self isInCurrentDatabase &amp; self class isOnline		ifFalse: [ ^nil ].	^self class definitionClass aRecordWithID: anID</body><body package="Store-DB-BaseObjects" selector="postDatabaseInstall">postDatabaseInstall	"Retrieve and set primary key "	(self primaryKey isNil ) ifTrue: [self primaryKey: self nextID].</body><body package="Store-DB-BaseObjects" selector="preDatabaseInstall">preDatabaseInstall	"Some subclasses have prep work to perform before creating record."	self prepareInstallation.		"Set primary key and user name."	(self class needsSequenceFor: self class) ifTrue: [self primaryKey: self nextID].	self userName: self currentUserName.</body><body package="Store-DB-BaseObjects" selector="prepareInstallation">prepareInstallation	"Subclasses may need to 		create foreign key records etc., before creating record.	Default is do nothing"</body></methods><methods><class-id>Store.Record class</class-id> <category>installation</category><body package="Store-DB-BaseObjects" selector="fieldTypes">fieldTypes	| aDict  |	aDict := super fieldTypes.	self checkFieldsWith: aDict.	^aDict</body><body package="Store-DB-BaseObjects" selector="viewColumnNames">viewColumnNames 	"This message is overided by collection classes that define	complex views."	^#()</body></methods><methods><class-id>Store.Record class</class-id> <category>db-utilities</category><body package="Store-DB-BaseObjects" selector="allIn:butNotIn:refColumn:associationClass:">allIn: aKey1 butNotIn: aKey2 refColumn: aRefColumn associationClass: aClass 	| str inpObject res |	inpObject := Array with: aKey1 with: aKey2.	[ str := self newSQL			selectAll;			where;			column: #primaryKey;			in: ( (self newSQLFor: aClass)					select: ( Array with: aRefColumn );					where;					column: #packageRef equalTo: ':1';					and;					column: aRefColumn;					notIn: ((self newSQLFor: aClass)							select: ( Array with: aRefColumn );							where;							column: #packageRef equalTo: ':2')).	res := self processList: 			(self broker 	process: str						bindInput: inpObject						bindOutput: self newPrimed).	DbRegistry printDebug: 'Record&gt;&gt;allIn:butNotIn:..'; printDebug: res.	] on: self errorSignals  	  do: [ :ex | ex outer. ^OrderedCollection new ].	^res</body><body package="Store-DB-BaseObjects" selector="allInPackage:butNotIn:">allInPackage: pkgKey1 butNotIn: pkgKey2 	"Answer a collection of instances that are defined in pkgKey1, but not in pkgKey2"	"Send to concrete subclass."	"ClassRecord allClassesInPackage: 2631 butNotIn: 2495"	^self sourcesViewClass 		recordsWithSourcesIn:  pkgKey1 		butNotIn: pkgKey2</body><body package="Store-DB-BaseObjects" selector="allInPackages:">allInPackages: keys	"Answer a collection of items that are in the packages in keys"	"Send to a concrete subclass that implements #referenceColumn"	"Method allInPackages: #( '23' '55' )"	keys isEmpty		ifTrue: [ ^OrderedCollection new ].	^self allInPackages: keys refColumn: self referenceColumn</body><body package="Store-DB-BaseObjects" selector="allInPackages:butNotIn:">allInPackages: keys1 butNotIn: keys2 	"Answer a collection of items that are in one the packages in keys1 but not in keys2"	^self 		allInPackages: keys1 		butNotIn: keys2 		refColumn: self referenceColumn</body><body package="Store-DB-BaseObjects" selector="allInPackages:butNotIn:refColumn:">allInPackages: keys1 butNotIn: keys2 refColumn: referenceColumn	"Answer a collection of items that are in one the packages in keys1 but not in keys2"	| str res |	keys1 isEmpty		ifTrue: [ ^OrderedCollection new ].	keys2 isEmpty		ifTrue: [ ^self allInPackages: keys1 refColumn: referenceColumn ].	[ str := self newSQL			selectAll;			where;			column: #primaryKey;			in: ( ( self newSQLFor: self associationClass )					select: ( Array with: referenceColumn );					where;					column: #packageRef equalToArray: keys1;					and;					column: referenceColumn;					notIn: ( ( self broker newSQLFor: self associationClass )							select: ( Array with: referenceColumn  );							where;							column: #packageRef equalToArray: keys2 ) ).	res := self processList: ( self broker process: str bindOutput: self newPrimed ).	DbRegistry printDebug: 'Record&gt;&gt;allIn:butNotIn:..'; printDebug: res.	] on: self errorSignals  	  do: [ :ex | ex outer. ^OrderedCollection new ].	^res</body><body package="Store-DB-BaseObjects" selector="allInPackages:refColumn:">allInPackages: keys refColumn: referenceColumn	"Answer a collection of items that are in the packages in keys"	"Send to a concrete subclass"	^self broker processSQL:  		( self newSQL 			selectAll;			where;			column: #primaryKey;			in: ( self associationClass newSQL					select: ( Array with: referenceColumn );					where;					column: #packageRef equalToArray: keys				)		) bindOutput: self newPrimed.</body><body package="Store-DB-BaseObjects" selector="allNames">allNames	"self allNames"	^[ ( self broker safelyExecuteBlock: 		[ self broker			process: ( self newSQL selectDistinct: #( name ) ) 			bindInput: nil  			bindOutput: nil			usingSession: self session		] ) collect: [ :each | each at: 1 ]	] on: self  errorSignals do: 			[ :ex |  		ex outer.		( self table collect: [ :each | each name ] ) asSet 		]</body><body package="Store-DB-BaseObjects" selector="allNamesMatching:">allNamesMatching: aString	"Wildcard search. Send to appropiate subclass"	"Method allNamesMatching: 'all*' "	^[ self processList: 		( self broker process:			( self newSQL 				selectAll;				where;				column: #name wildcard: aString printString			 ) 		 bindOutput: self newPrimed		)		]		on: self  errorSignals 		do: 	[:ex |  ex outer. ^#() ].</body><body package="Store-DB-BaseObjects" selector="aRecordWithID:">aRecordWithID: anID 	"Get a DB record identified by anID from the DB."	"This method can only be used for concrete subclasses." 	^ self getRecordWithID: anID</body><body package="Store-DB-BaseObjects" selector="chooseNameMatching:description:">chooseNameMatching: aString description: bString	"Wildcard search and select. Send to appropiate subclass. Answers a symbol or nil"	"Method chooseNameMatching: 'all*' description: 'selector' "	| list names |	( list := self allNamesMatching: aString ) isEmpty		ifTrue: 			[ Dialog warn: 'No ', bString, ' matching ', aString. 			^nil 			].	names := ( list collect: [ :dbr | dbr name asSymbol ] ) asSet asSortedCollection asOrderedCollection.	names size == 1		ifTrue: [ ^names first ].	^Dialog 		choose: 'Choose a ', bString, '...'		fromList: names		values: names		lines: 12		cancel: nil</body><body package="Store-DB-BaseObjects" selector="resetPrimaryKeySessions">resetPrimaryKeySessions	"Reset all the session used to access records by the primary key."	self withAllSubclasses do: [:x | x resetPrimaryKeySession]</body><body package="Store-DB-BaseObjects" selector="selectPrimaryKeysIn:bindInput:">selectPrimaryKeysIn: keyCollection bindInput: inpObject 	"Select records from the DB with primary keys 	in 'keyCollection', return the records.	Get them in chunks of size 'step'."	| result step keys |	step := 100.	keyCollection isEmpty ifTrue: [^#()].	result := OrderedCollection new: keyCollection size.	keys := keyCollection asOrderedCollection.	1		to: keys size		by: step		do: 			[:startIndex | 			| stream str |			stream := (String new: 100) writeStream.			startIndex to: (startIndex + step - 1 min: keys size)				do: 	[:index | 						(keys at: index)						printOn: stream.						stream nextPutAll: ', '					].			stream skip: -2.			str := self newSQL						selectAll;						where;						column: #primaryKey;						in: stream contents.			result addAll: (self broker					process: str					bindInput: inpObject					bindOutput: self newPrimed)].	result notNil ifTrue: [result do: [:each | each unprime; processFields]].	^result</body></methods><methods><class-id>Store.Record class</class-id> <category>private</category><body package="Store-DB-BaseObjects" selector="executeSQL:onError:">executeSQL: aSqlStatement onError: aBlock	^ [ self processList: 			(self broker 	process: aSqlStatement 					bindOutput: self newPrimed).	] 	on: self  errorSignals 	do:	[:ex | aBlock value ].</body><body package="Store-DB-BaseObjects" selector="getRecordWithID:">getRecordWithID: anID 	"Get a DB record identified by 'anID' from the DB. 	Use the prepared session stored in the PrimaryKeySession class instance 	variable.	This is a private method. Use aRecordWithID:"	| dbRecs res |	[dbRecs := self broker getAnswerFromSession: [self primaryKeySession]			bindInput: [:session| session bindInput primaryKey: anID ].	]	on: self  errorSignals 	do: 	[ :ex |   ex outer. ^nil ].	dbRecs isEmpty		ifTrue: [^nil]		ifFalse: [res := dbRecs first].	res unprime.	res processFields.	^res</body><body package="Store-DB-BaseObjects" selector="primaryKeySession">primaryKeySession	"Answer session for accessing records when the primary	key for the record is known."	"PrimaryKeySession := nil."	( self isSessionValid: PrimaryKeySession)		ifFalse:			[PrimaryKeySession := self broker getNewSession.			PrimaryKeySession bindOutput: self newPrimed.			PrimaryKeySession bindInput: self newPrimed.			PrimaryKeySession prepare: 						( self newSQL							selectAll;							where;							column: #primaryKey equalTo: ':primaryKey').			PrimaryKeySession blockFactor: 10].	^PrimaryKeySession</body><body package="Store-DB-BaseObjects" selector="resetPrimaryKeySession">resetPrimaryKeySession	PrimaryKeySession notNil 		ifTrue: 			[ self brokerOrNil notNil 				ifTrue: [ self broker dismissSession: PrimaryKeySession ].			 PrimaryKeySession := nil			]</body></methods><methods><class-id>Store.Record class</class-id> <category>instance creation</category><body package="Store-DB-BaseObjects" selector="fromSourcesView:">fromSourcesView: aSourcesView 	| record |	record := self fromView: aSourcesView.	record sourceCode: ( self definitionClass fromView: aSourcesView ) definition.	^record</body></methods><methods><class-id>Store.Record class</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="definitionClass">definitionClass		^Blob</body></methods><methods><class-id>Store.Pundle</class-id> <category>testing</category><body package="Store-DB-Pundles" selector="canBePublishedToCurrentDatabase">canBePublishedToCurrentDatabase	"For a database pundle, this means, can be modified in the current db. In other words,	is this pundle in the current database."	^self isInCurrentDatabase</body><body package="Store-DB-Pundles" selector="existsInImage">existsInImage	^false</body><body package="Store-DB-Pundles" selector="hasBeenModified">hasBeenModified	"We are in the DB so we can not be modified."	^false</body><body package="Store-DB-Pundles" selector="isBundle">isBundle	^false</body><body package="Store-DB-Pundles" selector="isPackage">isPackage	^false</body><body package="Store-DB-Pundles" selector="isParcel">isParcel	^false</body><body package="Store-DB-Pundles" selector="pseudoPackage">pseudoPackage	"Answer false since I'm genuine."	^false</body></methods><methods><class-id>Store.Pundle</class-id> <category>relationships</category><body package="Store-DB-Pundles" selector="elementLabel:">elementLabel: hints 	"This method returns a visual component used to represent me in a 	browser graph."	| lab |	lab := LabelAndIcon with: (self stringKey: hints)				attributes: (TextAttributes styleNamed: #systemDefault).	lab icon: (AbstractTool iconForPundle: self).	^lab</body><body package="Store-DB-Pundles" selector="relatedBy:">relatedBy: token 	""	token == #tt_derivesRel		ifTrue: 			[| kids imPun |			kids := self class allVersionsWithTrace: self primaryKey.			imPun := self getImagePundle.			(imPun notNil and: [imPun dbTrace = self primaryKey])				ifTrue: [kids add: imPun].			^kids].	token == #tt_derivesRRel ifTrue: [^Set with: self parentRecord].	^super relatedBy: token</body><body package="Store-DB-Pundles" selector="stringKey:">stringKey: hints 	^(hints includes: #blessing)		ifTrue: [Policies blessingPolicy stringKeyFor: self versionString blessingLevel: self blessingLevelNumber]		ifFalse: [primaryKey == nil				ifTrue: [name]				ifFalse: [self displayString]]</body></methods><methods><class-id>Store.Pundle</class-id> <category>accessing</category><body package="Store-DB-Pundles" selector="allDatabases">allDatabases	"Answer a collection of datbase identifiers that the receiver has links to"	^Array with: dbIdentifier</body><body package="Store-DB-Pundles" selector="allEnclosingComponents">allEnclosingComponents	"Answer a collection of all enclosing bundles."	| coll |	coll := self enclosingComponents asSet.	coll copy do: [ :bundle | coll addAll: bundle allEnclosingComponents ].	^coll</body><body package="Store-DB-Pundles" selector="asComponentDescription">asComponentDescription	^self descriptionClass new		id: primaryKey;		dbIdentifier: dbIdentifier;		componentName: name;		yourself</body><body package="Store-DB-Pundles" selector="asDBDescription">asDBDescription	^self subclassResponsibility</body><body package="Store-DB-Pundles" selector="blessingLevel">blessingLevel	"Answer the receiver's blessingLevel."	^blessingLevel</body><body package="Store-DB-Pundles" selector="blessingLevel:">blessingLevel: newBlessingLevel	"Set the receiver's blessingLevel to newBlessingLevel."	blessingLevel := newBlessingLevel</body><body package="Store-DB-Pundles" selector="blessingLevelNumber">blessingLevelNumber	"Answer the value of my blessing.."	^( self  blessingLevel == nil )		ifTrue: [ 0 ]		ifFalse: 			[ self blessingLevel isString				ifTrue: [ self blessingLevel asNumber ]				ifFalse: [ self blessingLevel ]			].</body><body package="Store-DB-Pundles" selector="blessingLevelString">blessingLevelString	"Answer the name of my blessing.."	^Policies blessingPolicy blessingName: self blessingLevelNumber.</body><body package="Store-DB-Pundles" selector="comment">comment	"Return empty string if the comment is not set."	| str |	^(str := self commentOrNil) isNil		ifTrue: ['']		ifFalse: [str]</body><body package="Store-DB-Pundles" selector="comment:">comment: aString 	commentStr := ( aString == nil or: [ aString isEmpty ] )		ifTrue: [ nil ]		ifFalse: [ aString string ].</body><body package="Store-DB-Pundles" selector="commentID">commentID	"Answer the receiver's commentID."	^commentID</body><body package="Store-DB-Pundles" selector="commentID:">commentID: newCommentID	"Set the receiver's commentID to newCommentID."	commentID := newCommentID</body><body package="Store-DB-Pundles" selector="commentOrNil">commentOrNil	"Allow for lazy evaluation."	commentStr isNil		ifTrue: [ commentStr := self getDefinitionID: self commentID ].	^commentStr isEmpty		ifTrue: [ nil ]		ifFalse: [ commentStr ]</body><body package="Store-DB-Pundles" selector="databaseId">databaseId	^DbRegistry databaseIdentifier.</body><body package="Store-DB-Pundles" selector="databaseList">databaseList	"Answer an array of datbase identifiers wheter the receiver has links or not"	^Array with: dbIdentifier</body><body package="Store-DB-Pundles" selector="deploymentPrerequisites">deploymentPrerequisites	^self  properties at: #prerequisiteParcels ifAbsent: [ nil ].</body><body package="Store-DB-Pundles" selector="developmentPrerequisites">developmentPrerequisites	^self  properties at: #developmentPrerequisites ifAbsent: [ nil ].</body><body package="Store-DB-Pundles" selector="enclosingComponents">enclosingComponents	"Answer a collection of all owning bundles."	^self class partClass enclosingComponentsOfId: self primaryKey.</body><body package="Store-DB-Pundles" selector="name:">name: anObject	name := anObject asString</body><body package="Store-DB-Pundles" selector="parcelName">parcelName	"Answer the parcel name, or receiver's name if absent."		^self properties at: #parcelName ifAbsent: [ name ]</body><body package="Store-DB-Pundles" selector="parentRecord">parentRecord	^(trace isNil or: [trace isZero])		ifTrue: [nil]		ifFalse: [self class aRecordWithID: trace]</body><body package="Store-DB-Pundles" selector="postLoadAction">postLoadAction	^self  properties at: #postLoadBlock ifAbsent: [ nil ].</body><body package="Store-DB-Pundles" selector="postLoadBlock">postLoadBlock	^self  properties at: #postLoadBlock ifAbsent: [ nil ].</body><body package="Store-DB-Pundles" selector="postUnloadAction">postUnloadAction	^self  properties at: #postUnloadBlock ifAbsent: [ nil ].</body><body package="Store-DB-Pundles" selector="postUnloadBlock">postUnloadBlock	^self  properties at: #postUnloadBlock ifAbsent: [ nil ].</body><body package="Store-DB-Pundles" selector="preLoadBlock">preLoadBlock	^self  properties at: #preLoadBlock ifAbsent: [ nil ].</body><body package="Store-DB-Pundles" selector="preReadBlock">preReadBlock	^self  properties at: #preReadBlock ifAbsent: [ nil ].</body><body package="Store-DB-Pundles" selector="prerequisiteParcels">prerequisiteParcels	"Answer the names of the receiver's prerequisite parcels	 as an Array of Name String, Version String pairs."	^self properties at: #prerequisiteParcels ifAbsent: [#()]</body><body package="Store-DB-Pundles" selector="preSaveAction">preSaveAction	^self  properties at: #preSaveBlock ifAbsent: [ nil ].</body><body package="Store-DB-Pundles" selector="preSaveBlock">preSaveBlock	^self  properties at: #preSaveBlock ifAbsent: [ nil ].</body><body package="Store-DB-Pundles" selector="preUnloadAction">preUnloadAction	^self  properties at: #preUnloadBlock ifAbsent: [ nil ].</body><body package="Store-DB-Pundles" selector="preUnloadAction:">preUnloadAction: aString	"Was finalDoitString.  Stored in the properties dictionary."	self  properties at: #preUnloadAction put: aString string</body><body package="Store-DB-Pundles" selector="preUnloadBlock">preUnloadBlock	^self  properties at: #preUnloadBlock ifAbsent: [ nil ].</body><body package="Store-DB-Pundles" selector="properties">properties	"Answer the property dictionary. First, try loading it from the relational tables.	If no properties are found, maybe it is an older record, so try loading from	the old style BOSSed dictionary, stored binary in another file under propertiesID."	(properties == nil and: [self class shouldLoadPropertyRecords]) 		ifTrue: 			[self propertyRecords isEmpty 				ifFalse: [properties := self propertyRecordsAsDictionary]].	properties == nil 		ifTrue: [properties := self getPropertiesID: self propertiesID].	properties == nil ifTrue: [properties := IdentityDictionary new].	^properties</body><body package="Store-DB-Pundles" selector="properties:">properties: idDictionary	"Set the properties dictionary."	properties := idDictionary</body><body package="Store-DB-Pundles" selector="propertiesForFileOut">propertiesForFileOut	"Answer a version of the property dictionary for filingout.."	^self properties.</body><body package="Store-DB-Pundles" selector="propertiesForSave">propertiesForSave	"Answer a version of the property dictionary for saving. Since we're already saved, it's the same."	^self properties.</body><body package="Store-DB-Pundles" selector="propertiesID">propertiesID	^propertiesID</body><body package="Store-DB-Pundles" selector="propertiesID:">propertiesID: anInteger	"Set the receiver's propertiesID to newPrimaryKey."	propertiesID := anInteger</body><body package="Store-DB-Pundles" selector="propertiesOrNil">propertiesOrNil	"Answer properties if it contains  values, or nil."	"Because we really aren't interested in storing a bunch of empty property dictionaries."		^( properties == nil or: [ properties isEmpty ] )		ifTrue: [ nil ]		ifFalse: [ properties ].</body><body package="Store-DB-Pundles" selector="propertyAt:ifAbsent:">propertyAt: symbol ifAbsent: aBlock	^self properties at: symbol ifAbsent: aBlock</body><body package="Store-DB-Pundles" selector="pundleChangesClass">pundleChangesClass	self subclassResponsibility</body><body package="Store-DB-Pundles" selector="structure">structure	"Answer an array that reflects the receiver's contents in the form:		#( #( #package name ) #( #bundle name ) .... )"		| answer |	answer := OrderedCollection new: self contents size.	self contents do:		[ :cd | | comp |		( comp := cd asDBComponent ) isPackage			ifTrue: [ answer add: ( Array with: #package with: comp name ) ]			ifFalse: [ answer add: ( Array with: #bundle with: comp name ) ].		].	^answer asArray</body><body package="Store-DB-Pundles" selector="textRepresentationForTag:">textRepresentationForTag: aTag 	^aTag isPropertyTag		ifTrue: [ aTag convertValue: ( self propertyAt: aTag property ifAbsent: nil ) ]		ifFalse:			[ aTag isStructureTag				ifTrue: [ aTag formatStructure: self structure ]				ifFalse: [ self error:'Invalid tag: ', aTag printString ]			].</body><body package="Store-DB-Pundles" selector="tracePackage">tracePackage		^self parentRecord</body><body package="Store-DB-Pundles" selector="versionComment">versionComment	"Return empty string if the comment is not set."	| str |	^(str := self versionCommentOrNil) isNil		ifTrue: ['']		ifFalse: [str]</body><body package="Store-DB-Pundles" selector="versionComment:">versionComment: aString 	commentStr := aString</body><body package="Store-DB-Pundles" selector="versionCommentOrNil">versionCommentOrNil	"Allow for lazy evaluation."	^commentStr isNil		ifTrue: [commentStr := self getDefinitionID: self commentID]		ifFalse: [commentStr]</body><body package="Store-DB-Pundles" selector="versionSelectionBlock">versionSelectionBlock	"Answer the versionSelectionBlock string or nil if none."		^properties at: #versionSelectionBlock ifAbsent: nil</body><body package="Store-DB-Pundles" selector="warningSuppressionBlock">warningSuppressionBlock		^properties at: #warningSuppressionBlock ifAbsent: nil</body></methods><methods><class-id>Store.Pundle</class-id> <category>private-accessing</category><body package="Store-DB-Pundles" selector="createImagePundle">createImagePundle	"Check if there if already loaded versions of the receiver and answer it. 	If not create a new pundle and register it."	| imPkg |	imPkg := self getImagePundle.	imPkg isNil		ifTrue: 			[ imPkg := self class imageClass named: self name.			imPkg dbIdentifier: self  dbIdentifier 			].	^imPkg</body><body package="Store-DB-Pundles" selector="ownRecordForTag:">ownRecordForTag: aTag 	"Answer the item in this bundle corresponding to 'aTag' or nil if not there.	Ignores sub-components."	^self recordForTag: aTag</body><body package="Store-DB-Pundles" selector="parentVersionString">parentVersionString	"Answer a string describing the parent version."	| traceVersion trPkg  |	(trPkg := self parentRecord) isNil 		ifTrue: [ ^''.   "^Policies versionPolicy initialVersionForPundle: self" ].	(traceVersion := trPkg version) isNil ifTrue: [traceVersion := ''].	^traceVersion</body><body package="Store-DB-Pundles" selector="recordForPropertyTag:">recordForPropertyTag: aTag 	"Answer the item in this package corresponding to 'aTag' or nil if not there."	^( self properties includesKey: aTag property )		ifFalse: [ nil ]		ifTrue: 			[ aTag copy				package: self; 				yourself			].</body><body package="Store-DB-Pundles" selector="recordForTag:">recordForTag: aTag 	"Answer the item in this package corresponding to 'aTag' or nil if not there."	^self subclassResponsibility.</body><body package="Store-DB-Pundles" selector="updateBlessing:">updateBlessing: aNewLevel	"Update DB to reflect changes in my latest 	blessing level."	Cursor database showWhile: [		self broker process: 			( self newSQL				update;				column: #blessingLevel equalTo: aNewLevel printString;				where;				column: #primaryKey equalTo: primaryKey printString)	].	self blessingLevel: aNewLevel.	Registry blessingChangedForPundle: self.</body></methods><methods><class-id>Store.Pundle</class-id> <category>printing</category><body package="Store-DB-Pundles" selector="propertyText">propertyText	| stream |	stream := ( String new: 100 ) stream.	stream nextPutAll: ( DbRegistry textForItem: self ); cr; cr.	( self properties associations asSortedCollection: [ :a :b | a key &lt; b key ] ) do:		[ :prop | 		stream nextPutAll: prop key, ': ', prop value printString; cr.		].	^stream contents.</body></methods><methods><class-id>Store.Pundle</class-id> <category>ownership</category><body package="Store-DB-Pundles" selector="owner">owner	^Policies ownershipPolicy ownerOfPundle: self</body></methods><methods><class-id>Store.Pundle</class-id> <category>comparing</category><body package="Store-DB-Pundles" selector="=">= aPundle 	"Compare two database pundles."	^self class = aPundle class and: 		[ self primaryKey = aPundle primaryKey and: 			[ self primaryKey notNil or: [ self name = aPundle name ] ] 		]</body><body package="Store-DB-Pundles" selector="comparesTo:">comparesTo: aCodeComponent	"Answer true if the receiver is some version of aCodeComponent."	^aCodeComponent isPackage = self isPackage		and: [ name = aCodeComponent name ].</body><body package="Store-DB-Pundles" selector="hash">hash	^self primaryKey hash</body></methods><methods><class-id>Store.Pundle</class-id> <category>actions</category><body package="Store-DB-Pundles" selector="doActionEvalualtion:withArguments:for:">doActionEvalualtion: aString withArguments: args for: aDescription 	| block val |	block := Cursor execute showWhile: 		[ nil class evaluatorClass new				evaluate: (ReadStream on: aString asString)				in: nil 				allowReceiver: false				receiver: nil				environment: nil class environment				notifying: nil				ifFail: [ Dialog warn: self name, ': Compilation error in ', aDescription. ^false ]		].	block numArgs == args size		ifFalse: [ Dialog warn: self name, ': invalid ', aDescription.  ^false ].	[ val := block valueWithArguments: args ] on: Error do:		[ :e | Dialog warn: self name, ': Error evaluating ', aDescription. ^false ].	^val ~~ false.</body><body package="Store-DB-Pundles" selector="loadSrcWithImgPundle:">loadSrcWithImgPundle: imgPundle	( ( imgPundle notNil 			and: [ imgPundle dbTrace == self primaryKey ] )			and: [ imgPundle hasBeenModified not ] )		ifTrue: 			[ ( Dialog confirm: 'The selected version is already loaded.&lt;nt&gt;Reconcile and reload?' expandMacros )					ifTrue: [ imgPundle reconcileWithDb: self ]					ifFalse: [ ^self ].			].	self loadSrc</body><body package="Store-DB-Pundles" selector="runPreLoad">runPreLoad	| action |	(action := self preLoadBlock ) == nil		ifTrue: [ ^nil ].	^self doActionEvalualtion: action withArguments: ( Array with: self ) for: 'preLoad'</body><body package="Store-DB-Pundles" selector="runPreRead">runPreRead	| action |	( action := self preReadBlock ) == nil		ifTrue: [ ^true ].	( self doActionEvalualtion: action withArguments: ( Array new ) for: 'PreRead' )		ifTrue: [ ^true ].	^Dialog confirm: ( 'Pre-read action for &lt;1s&gt; failed.&lt;ntttt&gt;Continue?' expandMacrosWith: name ).</body></methods><methods><class-id>Store.Pundle</class-id> <category>private</category><body package="Store-DB-Pundles" selector="addBlessingLevel:andComment:">addBlessingLevel: aLevel andComment: aComment 	"Create a new record with the blessing level only 	if the level is higher then zero or the comment is not empty."	(aLevel &gt; 0 or: [aComment isEmpty not])		ifTrue: [Blessing				forPundle: self 				withLevel: aLevel				andComment: aComment]</body><body package="Store-DB-Pundles" selector="addDBProperties:">addDBProperties: aCollectionOfDBProperties 	"Create new entries in the table which binds properties to packages.	These relate new packages to either new or pre-existing property records."	| property |	aCollectionOfDBProperties do: 			[:each | 			(property := Properties new)				pundleRef: self primaryKey;				propertyRef: each primaryKey;				recType: (Properties typeCodeForClass: self).			property install]</body><body package="Store-DB-Pundles" selector="addProperties:">addProperties: aCollectionOfProperties 	"Convert collection of properties into collection of DB properties and add 	them to the receiver."	self addProperties: aCollectionOfProperties mergeData: nil</body><body package="Store-DB-Pundles" selector="addProperties:mergeData:">addProperties: aCollectionOfProperties mergeData: mergeData 	"Convert collection of properties into collection of DB properties and add 	them to the receiver. Currently, mergeData is not used (07-24-04).	Note that if the trace is not null then check the properties from the trace and 	create new records only for properties that are different."	| propertyList newDBProperties traceProperties |	self class shouldSavePropertyRecords 		ifFalse: [self error: 'Saving property records is supposedly disabled.'].	traceProperties := self hasTrace 				ifTrue: [self getTrace propertyRecords]				ifFalse: [#()].	propertyList := "SystemUtils sortForLoading:" aCollectionOfProperties.	newDBProperties := OrderedCollection new.	propertyList do: 			[:each | 			| aDBProperty |			aDBProperty := nil.			"mergeData == nil			ifFalse: 				[ aDBProperty := mergeData resolutionRecordForTag: 						(PropertyTag newProperty: each) packageNamed: self name. 				]."			aDBProperty == nil 				ifTrue: 					[aDBProperty := traceProperties 								detect: [:dbProp | dbProp absoluteName = each absoluteName]								ifNone: [nil]].			"Add property record to list, creating in DB if necessary."			newDBProperties add: (PropertyRecord recordFor: each trace: aDBProperty)].	"Create relational links in DB for all properties."	self addDBProperties: newDBProperties</body><body package="Store-DB-Pundles" selector="getPropertiesID:">getPropertiesID: anID	anID == 0 ifTrue: [ ^nil ].	^( self getDefinitionRecordID: anID ) binData</body><body package="Store-DB-Pundles" selector="preDatabaseInstall">preDatabaseInstall	"Some subclasses have prep work to perform before creating record."	super preDatabaseInstall.	self validateVersionString.</body><body package="Store-DB-Pundles" selector="prepareInstallation">prepareInstallation	"Create records for pundle properties and comment, if necessary.	The BOSSed properties dictionary will only be saved if enabled. Otherwise, the	propertiesID := 0, to indicate no BOSSed dictionary available for this pundle.	The property records array, like namespaces, are saved elsewhere."	self class shouldSaveBOSSedProperties 		ifTrue: [self propertiesID isNil 			ifTrue: [self propertiesID: (self class definitionClass fromBinData: self propertiesOrNil) primaryKey]]		ifFalse: [self propertiesID: 0].	self commentID isNil 		ifTrue: [self commentID: (self class definitionClass fromString: self commentOrNil) primaryKey]</body><body package="Store-DB-Pundles" selector="prime">prime	"Put instances of Object into slots that are not mapped into columns in the DB.	This is crucial for reading from DB since the primed slots are skipped"	super prime.	commentStr := Object new.	properties := Object new.	propertyRecords := Object new.</body><body package="Store-DB-Pundles" selector="propertyRecords">propertyRecords	"Retrieve this pundle's property records from the relational tables.	If found,	these are used to generate the properties (a dictionary)."	| dbProperties |	propertyRecords isNil 		ifTrue: 			[			[dbProperties := self broker 						getAnswerFromSession: [PropertiesView propertiesSession]						bindInput: 							[:session | 							| bindObject |							bindObject := session bindInput.							bindObject pundleRef: self primaryKey.							bindObject recType: (Properties typeCodeForClass: self)].			propertyRecords := (dbProperties 						collect: [:each | (PropertyRecord fromView: each) package: self]) 							asOrderedCollection] 					on: self errorSignals					do: 						[:ex | 						propertyRecords := OrderedCollection new.						^propertyRecords]].	^propertyRecords</body><body package="Store-DB-Pundles" selector="propertyRecordsAsDictionary">propertyRecordsAsDictionary	"Return an IdentityDictionary of properties."	| dict |	dict := IdentityDictionary new.	propertyRecords 		do: [ :propRecord | dict at: propRecord name asSymbol put: propRecord definitionStr ].	^dict</body><body package="Store-DB-Pundles" selector="sameVersionAs:">sameVersionAs: aPundle		^aPundle sameVersionAsPublished: self</body><body package="Store-DB-Pundles" selector="sameVersionAsLoadedPundle:">sameVersionAsLoadedPundle: anImPundle	^anImPundle sameVersionAsPublished: self</body><body package="Store-DB-Pundles" selector="sameVersionAsPublished:">sameVersionAsPublished: aDbPundle	^aDbPundle primaryKey = self primaryKey</body><body package="Store-DB-Pundles" selector="unprime">unprime	"Remove the effect of priming (see the prime method)."	super unprime.	commentStr := nil.	properties := nil.	propertyRecords := nil.</body><body package="Store-DB-Pundles" selector="validateVersionString">validateVersionString	"Check to see it the receiver's version string is already used. 	This is way too late in the game to cancel, so insist on a new version string."	[ Policies versionPolicy existsVersionString: version forPundle: self ] whileTrue: 		[ version := 			Dialog				request: ( 'Version &lt;1s&gt; of &lt;2s&gt; already exists.&lt;n&gt;Enter another version string' 							expandMacrosWith: version with: self name )				initialAnswer: ( Policies versionPolicy nextVersion: version forPundle: self )				onCancel: [ version ].		].</body></methods><methods><class-id>Store.Pundle</class-id> <category>private-file out</category><body package="Store-DB-Pundles" selector="fileOutMethods:on:">fileOutMethods: methodCollection on: aFileManager 	"First group methods by class and protocol 	and the ask aFileManager to do the job class by class"	| toFileOut byClass byProtocol |	toFileOut := Dictionary new.	methodCollection do: 		[ :each | 		byClass := toFileOut at: each className ifAbsent: [ Dictionary new ].		byProtocol := byClass at: each protocolName ifAbsent: [ Set new ].		byProtocol add: each.		byClass at: each protocolName put: byProtocol.		toFileOut at: each className put: byClass.		( each name = 'initialize' and: [ each className namesMetaClass] )			ifTrue: [ aFileManager initializeThisClass: 						( PseudoClass newNamed: each className classNameOnly )				   ]		].		toFileOut keysAndValuesDo: 			[ :k :v | 			aFileManager fileOutTTMessages: v for: k logging: true.			aFileManager cr.			IncrementNotification signalWith: 				( v inject: 0 into: [ :s :c | s + c size ] )			]</body><body package="Store-DB-Pundles" selector="fileOutProperties:on:">fileOutProperties: props on: aFileManager	props associationsDo:		[ :assoc |		aFileManager 			component: self componentType			named: self name			property: assoc key			value: assoc value				].</body><body package="Store-DB-Pundles" selector="fileOutPropertiesOn:">fileOutPropertiesOn: aFileManager		self fileOutProperties: self propertiesForFileOut on: aFileManager.</body></methods><methods><class-id>Store.Pundle</class-id> <category>prereqs</category><body package="Store-DB-Pundles" selector="checkParcelPrerequisite:version:">checkParcelPrerequisite: reqName version: reqVersion	"Validate the existense of a parcel as a prerequisite. Answer true if loaded"	^( [ Parcel ensureLoadedParcel: reqName withVersion: reqVersion forPundle: self ] 		on: Parcel missingParcelSignal do: [ :exp | exp return: nil ]	 ) ~~ nil</body><body package="Store-DB-Pundles" selector="checkParcelPrerequisiteLoaded:named:version:">checkParcelPrerequisiteLoaded: reqType named: reqName version: reqVersion	"Validate the existence of a parcel as a prerequisite. 	Answer true if acceptable version is already loaded"	| parcel |	( reqType == #parcel ) |  ( reqType == #any )		ifFalse: [ ^false ].	( parcel := Parcel parcelNamed: reqName ) == nil		ifTrue: [ ^false ].	^parcel 		checkPrerequisiteNamed: reqName 		withVersion: parcel version		requiredVersion: reqVersion</body><body package="Store-DB-Pundles" selector="checkPrerequisite:name:version:">checkPrerequisite: reqType name: reqName version: reqVersion	"Validate the existence of a prerequisite. Answer true if okay to finish loading"	| pref message |	( self checkPrerequisiteLoaded: reqType named: reqName version: reqVersion )		ifTrue: [ ^true ].	pref := Policies prerequisitePolicy searchOrder.	reqType == #parcel  |  ( reqType == #any &amp; pref == #parcelsFirst )		ifTrue: 			[ ( self checkParcelPrerequisite: reqName version: reqVersion ) 				ifTrue: [ ^true ]			].	( self checkPundlePrerequisite: reqType named: reqName version: reqVersion )		ifTrue: [ ^true ].	( ( reqType == #any ) &amp; ( pref == #parcelsFirst ) )		ifFalse:			[ ( reqType == #package )  |  ( reqType == #bundle )				ifFalse: [ ( self checkParcelPrerequisite: reqName version: reqVersion ) 							ifTrue: [ ^true ] ]			].	message := 'Unable to load prerequisite &lt;1s&gt; &lt;2s&gt;&lt;nttt&gt;Continue?' 						expandMacrosWith: reqName 						with: ( reqVersion isEmpty 									ifTrue: [ '' ] 									ifFalse: [ 'version ', reqVersion ] ).	^Dialog confirm: message</body><body package="Store-DB-Pundles" selector="checkPrerequisiteLoaded:named:version:">checkPrerequisiteLoaded: reqType named: reqName version: reqVersion	"Validate the existence of a parcel/bundle/package as a prerequisite. 	Answer true if acceptable version is already loaded"	^( self checkParcelPrerequisiteLoaded: reqType named: reqName version: reqVersion ) 		or: [ self checkPundlePrerequisiteLoaded: reqType named: reqName version: reqVersion ]</body><body package="Store-DB-Pundles" selector="checkPrerequisiteNamed:withVersion:requiredVersion:">checkPrerequisiteNamed: prerequisiteName withVersion: prerequisiteVersionString requiredVersion: requiredVersionString	"Answer if the version of the prerequisite prerequisiteName is acceptable.	Callback for prerequiste loading"	| blk |	( blk := self versionSelectionBlock  ) == nil		ifTrue: 			[ ^( requiredVersionString isNil or: [ requiredVersionString isEmpty ] )				ifTrue: [ true ]				ifFalse: 	[ prerequisiteVersionString = requiredVersionString ].			].	^blk		value: prerequisiteName		value: prerequisiteVersionString		value: requiredVersionString</body><body package="Store-DB-Pundles" selector="checkPrerequisites">checkPrerequisites	"Check the prereqs. Answer true if it's okay to load."	| reqs |	( reqs :=  self developmentPrerequisites ) == nil		ifTrue: [ ^true ].	reqs do: 		[ :req | 		( self checkPrerequisite: req first name: ( req at: 2 ) version: req last ) 			ifFalse: [ ^false ] 		].	^true.</body><body package="Store-DB-Pundles" selector="checkPundlePrerequisite:named:version:">checkPundlePrerequisite: reqType named: reqName version: reqVersion	"Attempt to load a pundle that satifies the prerequisite."	"We know an acceptable version is not already loaded."	| pundle pundles |	( ( reqType == #bundle )  |  ( reqType == #any ) )		ifTrue: [ pundle := Bundle loadWithName: reqName version: reqVersion  ].	( pundle == nil and: [ ( reqType == #package )  |  ( reqType == #any ) ] )		ifTrue: [ pundle := Package loadWithName: reqName version: reqVersion ].	pundle == nil		ifFalse: [ ^true ].	pundles := ( ( reqType == #bundle )  |  ( reqType == #any ) )		ifTrue: [ pundles := Bundle allVersionsWithName: reqName ]		ifFalse: [ #( ) ].	( pundles isEmpty and: [ ( reqType == #package )  |  ( reqType == #any ) ] ) 		ifTrue: [ pundles := Package allVersionsWithName: reqName ].	pundles isEmpty		ifTrue: [ ^false ].	pundle := Policies prerequisitePolicy getPrereq: reqName from: pundles version: reqVersion for: self.	^pundle == nil		ifTrue: [ false ]		ifFalse: [ pundle loadSrc ~~ nil ]</body><body package="Store-DB-Pundles" selector="checkPundlePrerequisiteLoaded:named:version:">checkPundlePrerequisiteLoaded: reqType named: reqName version: reqVersion	"Validate the existense of a pundle as a prerequisite. 	Answer true if acceptable version is already loaded"	| pundle |	( reqType == #bundle ) |  ( reqType == #any )		ifTrue: [ pundle := Registry bundleNamed: reqName ].	( pundle == nil and:		[ ( reqType == #package ) |  ( reqType == #any ) ]	) ifTrue: [ pundle := Registry packageNamed: reqName ].	^pundle == nil		ifTrue: [ false ]		ifFalse: 			[ self 				checkPrerequisiteNamed: reqName 				withVersion: pundle traceVersion 				requiredVersion: reqVersion			].</body><body package="Store-DB-Pundles" selector="selectPrereqVersionOf:fromList:version:">selectPrereqVersionOf: aPundleName fromList: aList version: aString	"Display a list of pundle versions. Answer the selection,	nil if none. Send to appropiate subclass."		 ^Dialog 		choose: ((#ChoosePrereq &lt;&lt; #store &gt;&gt; 'Choose version to fullfill prerequiste: &lt;1s&gt;') expandMacrosWith:  aString)		fromList: ( aList collect: [ :m | m displayString, ' ', m blessingLevelString ] )		values: aList		lines: 10 cancel: [ ^nil ]		for: nil.</body><body package="Store-DB-Pundles" selector="shouldSuppressLoadWarningsForParcel:">shouldSuppressLoadWarningsForParcel: prerequisiteName	"Evaluate the warningSuppressionBlock for the given prerequisite.	 The block should return true to suppress warnings.	Callback for prerequiste loading"	| blk |	( blk := self warningSuppressionBlock  ) == nil		ifTrue: [ ^false ].	^blk value: prerequisiteName</body><body package="Store-DB-Pundles" selector="streamDirectory">streamDirectory	"parcel loading call-back"	^nil</body></methods><methods><class-id>Store.Pundle</class-id> <category>utilities</category><body package="Store-DB-Pundles" selector="mostRecentVersion">mostRecentVersion	"Answer a pundle that is the most recently published version of the receiver."	^self class mostRecentVersionOfPundleWithName: name</body><body package="Store-DB-Pundles" selector="selectVersion">selectVersion 	^self class selectVersionOf: self name.</body></methods><methods><class-id>Store.Pundle</class-id> <category>fileout</category><body package="Store-DB-Pundles" selector="fileOut">fileOut	"Ask for file name and file out the content of the pundle into it."	| aFileManager fileName |	fileName := Dialog 		requestNewFileName: 'File out on:'		default: self name , '.st'.	fileName isEmpty ifTrue: [^nil].	aFileManager := SourceCodeStream write: fileName.	[Notice 		showNotice: 'Filing out ' , self name		complete: self itemCount		while: 			[aFileManager timeStamp.			aFileManager deferInitializations.			self fileOutOn: aFileManager.			aFileManager finishInitializations]		title: 'Store'] 			ensure: [aFileManager close]</body></methods><methods><class-id>Store.Pundle</class-id> <category>private-differences calculation</category><body package="Store-DB-Pundles" selector="basicModifications">basicModifications	"Answer my content as a list of modifications. Does not iterate through contents."	"Pundle adds the common properties. Subclasses take care of the rest."	^( self properties keys collect:		[ :prop | 		Modification 			tag: ( PropertyTag package: self property: prop ) 			package: self			record: self		] 	) asList</body><body package="Store-DB-Pundles" selector="basicModificationsFor:">basicModificationsFor: id	"Answer my content as a list of modifications."	"Pundle adds the common properties. Subclasses take care of the rest."	^dbIdentifier = id		ifTrue: [ self basicModifications ]		ifFalse: [ #( ) ].</body><body package="Store-DB-Pundles" selector="classesAndNameSpacesFromChanges:">classesAndNameSpacesFromChanges: changeSet	| list |	list := OrderedCollection new.	changeSet keysAndValuesDo:		[ :symbol :cc | 		( cc isForClass			ifTrue: 				[ list add: 					( self classes 						detect: 	[ :cls | cls absoluteName = symbol asString ] 						ifNone: [ PseudoClass named: symbol meta: false ]					).				list add: 					( self metaclasses 						detect: 	[ :cls | cls absoluteName = symbol asString ] 						ifNone: [ PseudoClass named: symbol meta: true ]					).				]				ifFalse:					[ list add: 						( self nameSpaces 							detect: 	[ :cls | cls absoluteName = symbol asString ] 							ifNone: [ PseudoNameSpace newNamed: symbol ]						)					]			)		].	^list</body><body package="Store-DB-Pundles" selector="modifications">modifications	"Answer my content as a list of modifications."	"Pundle adds the common properties. Subclasses take care of the rest."	^self basicModifications</body><body package="Store-DB-Pundles" selector="modificationsFor:">modificationsFor: id	"Answer my content as a list of modifications."	"Pundle adds the common properties. Subclasses take care of the rest."	^dbIdentifier = id		ifTrue: [ self modifications ]		ifFalse: [ #( ) ].</body></methods><methods><class-id>Store.Pundle class</class-id> <category>private-utilities</category><body package="Store-DB-Pundles" selector="allPackagesOrBundles">allPackagesOrBundles	"This method is common for packages and bundles but it should be called 	only from a concrete class (TT_Package or TT_Bundle). 	Answer a SortedCollection of TT_Packages/TT_Bundles"	^Cursor wait showWhile: 		[ [ ( self  processList: (self broker process: 								( self newSQL selectAll)							bindOutput: self newPrimed)	  	     ) asSortedCollection: [ :x :y | x primaryKey &gt; y primaryKey ]		  ] on: self errorSignal do: [ :ex | ex outer. OrderedCollection new ]		]</body><body package="Store-DB-Pundles" selector="cachedItemFor:">cachedItemFor: aPundle	"Answer the cached item if there is one.	Put item in the cache otherwise.	Currently only packages are cached."	^aPundle</body><body package="Store-DB-Pundles" selector="canPublish:atBlessing:">canPublish: imPundle atBlessing: level 	"Answer true if there are no bojections to publishing 	the imPkg at blessing level 'level'"	| objections |	objections := self objectionsToPublishing: imPundle atBlessing: level.	objections == nil		ifFalse: 			[Dialog warn: ('Your policy prevents the publication at this blessing level:\' , objections) withCRs.			^false].	^true</body><body package="Store-DB-Pundles" selector="firstVersionOfPundleWithName:">firstVersionOfPundleWithName: aName 	"This method takes advantage of the key generation schema: 	the more recent the version the higher key."	| dbPundles |	dbPundles := self allVersionsWithName: aName.	^dbPundles isEmpty		ifTrue: [nil]		ifFalse: [dbPundles last ]</body><body package="Store-DB-Pundles" selector="knownPackagesOrBundles">knownPackagesOrBundles	"Answer a SelectionInList containing names of all bundles/packages stored in DB.	Note that this is an abstract method and must be called from a concrete subclass like Package or Bundle."	| names |	names := self allNames asSortedCollection.	^SelectionInList with: names asList.</body><body package="Store-DB-Pundles" selector="mostRecentVersionOfPundleWithName:">mostRecentVersionOfPundleWithName: aName 	"This method takes advantage of the key generation schema: 	the more recent the version the higher key."	^self newestVersionWithName: aName.</body><body package="Store-DB-Pundles" selector="propertyRecordsFromDictionary:">propertyRecordsFromDictionary: aDictionary 	"Return an OrderedCollection of propertyRecords from the (properties) dictionary."	| propertyRec records |	records := OrderedCollection new.	aDictionary keysAndValuesDo: 			[:key :value | 			propertyRec := PropertyRecord newName: key definition: value.			records add: propertyRec].	^records</body></methods><methods><class-id>Store.Pundle class</class-id> <category>installation</category><body package="Store-DB-Pundles" selector="columnNames">columnNames		"self columnNames"	^super columnNames		remove: 'commentStr';		remove: 'properties';		remove: 'propertyRecords';		yourself.</body><body package="Store-DB-Pundles" selector="fieldTypes">fieldTypes		" self fieldTypes "	^super fieldTypes		at: 'blessingLevel' put: #Integer;		at: 'commentID' put: #Integer;		at: 'propertiesID' put: #Integer;		yourself.</body><body package="Store-DB-Pundles" selector="needsSequence">needsSequence	^true</body></methods><methods><class-id>Store.Pundle class</class-id> <category>class initalization</category><body package="Store-DB-Pundles" selector="initialize">initialize	"self initialize"	ComponentNotFoundSignal := Object informationSignal newSignal 		notifierString: 'Component not found';		nameClass: self message: #componentNotFoundSignal.</body><body package="Store-DB-Pundles" selector="initializeCache">initializeCache	"This is subclass specific method."	Cache := WeakDictionary new.</body></methods><methods><class-id>Store.Pundle class</class-id> <category>instance creation</category><body package="Store-DB-Pundles" selector="newNamed:">newNamed: aName 	"Create a record for a package. Put the name and the time stamp. 	Do not install the package in the database."	| newDBPundle |	newDBPundle := self new.	newDBPundle setNoTrace; name: aName; timeStamp: self timeStamp.	^newDBPundle</body><body package="Store-DB-Pundles" selector="propertyRecordsFromPundle:">propertyRecordsFromPundle: aPundle 	"Extract an OrderdCollection of PropertyRecords from aPundle object.	aPundle might be a PackageModel, in which case we convert its properties dictionary."	^(aPundle isKindOf: Pundle) 		ifTrue: [aPundle propertyRecords]		ifFalse: [self propertyRecordsFromDictionary: aPundle propertiesForSave]</body></methods><methods><class-id>Store.Pundle class</class-id> <category>signals</category><body package="Store-DB-Pundles" selector="componentNotFoundSignal">componentNotFoundSignal	^ComponentNotFoundSignal</body></methods><methods><class-id>Store.Pundle class</class-id> <category>private</category><body package="Store-DB-Pundles" selector="newFrom:">newFrom: anImagePundle 	"Given a image pundle create a new instance of the receiver.		This is a private method used by all public methods that store pundles in the database."	| newDBPundle parentPundle props |	newDBPundle := self newNamed: anImagePundle name.	parentPundle := anImagePundle parentRecord.	anImagePundle dbIdentifier: DbRegistry dbIdentifier.	newDBPundle setTrace: parentPundle.	( parentPundle notNil and: [ parentPundle commentOrNil = anImagePundle commentOrNil ] )		ifTrue: [ newDBPundle commentID: parentPundle commentID ]		ifFalse: [ newDBPundle comment: anImagePundle commentOrNil ].	props := anImagePundle propertiesForSave.	( parentPundle notNil and: [ self properties: parentPundle properties equals: props ] )		ifTrue: [ newDBPundle propertiesID: parentPundle propertiesID ]		ifFalse: [ newDBPundle properties: props ].	^newDBPundle</body><body package="Store-DB-Pundles" selector="properties:equals:">properties: aPropertiesDictionary equals: bPropertiesDictionary	"Anwer true if  the two dictionaries contain the same key/values."	aPropertiesDictionary size == bPropertiesDictionary size		ifFalse: [ ^false ].	( aPropertiesDictionary == nil ) &amp; ( bPropertiesDictionary == nil )		ifTrue: [ ^true ].	aPropertiesDictionary keysAndValuesDo:		[ :key :value |		( bPropertiesDictionary at: key ifAbsent: [ ^false ] ) = value			ifFalse: [ ^false ]		].	^true</body><body package="Store-DB-Pundles" selector="shouldLoadPropertyRecords">shouldLoadPropertyRecords	"Should the property records be loaded? Answer should not be false for older DBs."	^self shouldSavePropertyRecords</body><body package="Store-DB-Pundles" selector="shouldSaveBOSSedProperties">shouldSaveBOSSedProperties	"Should the properties also be saved as a BOSSed dictionary, for reading by pre-7.3 images?"	"#(#bossAndTable #tableOnly #bossOnly )"	^DbRegistry isDb73Enabled not or:		[ #(#bossAndTable #bossOnly) includes: PropertiesPublishingPolicy ]</body><body package="Store-DB-Pundles" selector="shouldSavePropertyRecords">shouldSavePropertyRecords	"Should the property records be saved? Answer should not be false for older DBs."	"#(#bossAndTable #tableOnly #bossOnly )"	^DbRegistry isDb73Enabled		and: [ #(#bossAndTable #tableOnly) includes: PropertiesPublishingPolicy ]</body><body package="Store-DB-Pundles" selector="subclassFromType:">subclassFromType: aSymbol	"Answer the subclass that is represented by a type symbol."	^aSymbol == #package			ifTrue: [ Package ]			ifFalse: [ Bundle ].</body></methods><methods><class-id>Store.Pundle class</class-id> <category>private-garbage-collection</category><body package="Store-DB-Pundles" selector="pundlesReferingTo:">pundlesReferingTo: aDefinitionID	"Answer a set of IDS that refer to a given definition either as 	comment or initialization or finalization string."	"Note: should be sent to the appropiate subclass."	| str |	str := aDefinitionID printString.	^[(self broker process:					( self newSQL						selectAll;						where;						column: #commentID  equalTo: str;						or;						column: #propertiesID  equalTo: str)	 ) collect: [ :each | each first ]	] 	on: self  errorSignals 	do: 	[:ex |   ex outer. OrderedCollection new].</body></methods><methods><class-id>Store.Pundle class</class-id> <category>db-utilities</category><body package="Store-DB-Pundles" selector="allVersionsWithName:andBlessingLevel:">allVersionsWithName: aName andBlessingLevel: aBlessingLevel	"Answer a colection of TT_Packages or TT_Bundles"	"Note this message has to be sent to a TT_Bundle or TT_Package class."	|  items |	[ items :=self processList: 				(self broker process: 						( self newSQL							selectAll;							where;							column: #name  equalTo: aName asString printString;							and;							column: #blessingLevel equalTo: aBlessingLevel printString)					bindOutput: self newPrimed).			1 to: items size do: 			[ :i | | pkg cached |				pkg := items at: i.				cached := self cachedItemFor: pkg.				items at: i put: cached].	] 	on: self errorSignals 	do: 	[ :ex | ex outer. ^OrderedCollection new ].	^items asSortedCollection: [ :x :y | x primaryKey &gt; y primaryKey ]</body><body package="Store-DB-Pundles" selector="allVersionsWithName:lessThanTimeStamp:">allVersionsWithName: aName lessThanTimeStamp:  timeStamp	"Answer a colection of Packages or Bundles"	"Note this message has to be sent to Bundle or Package class."	| items |	[items := self  processList:				(self broker 					process: 						( self newSQL							selectAll;							where;							column: #name equalTo: aName asString printString;							and;							column: #timeStamp  lessThan: timeStamp printString)					bindOutput: self newPrimed).		1 to: items size do: 			[ :i | | pkg cached |			pkg := items at: i.			cached := self cachedItemFor: pkg.			items at: i put: cached			].	] 	on: self errorSignals 	do: 	[ :ex | ex outer.  ^OrderedCollection new ].	^items asOrderedCollection</body><body package="Store-DB-Pundles" selector="allVersionsWithTrace:">allVersionsWithTrace: aTrace 	"Answer a colection of Packages"	"1 halt. self allVersionsWithTrace: 341"	| dbPkgs pkgs |	dbPkgs := 		[ pkgs := self  processList: 					(self broker process: 						(self newSQL							selectAll;							where;							column: #trace equalTo: aTrace  printString)					 bindOutput: self newPrimed).				1 to: pkgs size do: 					[ :i | | pkg cached |						pkg := pkgs at: i.						cached := Cache at: pkg primaryKey ifAbsent: [ nil ].						cached notNil 							ifTrue: [ pkgs at: i put: cached ]							ifFalse: [ Cache at: pkg primaryKey put: pkg ]					].		pkgs.		] 	on: self errorSignals 	do: 	[ :ex | ex outer.			self  table select: [ :each | each dbTrace = aTrace ] 		].	^dbPkgs == nil		ifTrue: [ OrderedCollection new ]		ifFalse: [ dbPkgs asSortedCollection: [ :x :y | x primaryKey &gt; y primaryKey ] ]</body><body package="Store-DB-Pundles" selector="canPublish:userData:">canPublish: aPundle userData: publishSpec 	"Check if a user can publish aPundle with a given blessing 	and if the version string is unique in the database."	| verString |	aPundle isSaveableWithWarning		ifFalse: [ ^false ].	( self canPublish: aPundle atBlessing: publishSpec blessing )		ifFalse: [^false].	verString := Policies versionPolicy versionStringForPundle: aPundle initialVersion: publishSpec version.	verString isNil ifTrue: [ ^false ].	publishSpec version: verString.	^true</body><body package="Store-DB-Pundles" selector="hasVersionNamed:">hasVersionNamed: aName	"Answer true if a version named aName exists.	Note: must be sent to a concrete subclass."	"Bundle hasVersionNamed: 'StoreBase' "	| res query |	( query := self newSQLFor: self )		selectCountAll;		where;		column: 'name' equalTo: aName printString.				res := self broker processSQL: query sqlString.	^res first first &gt; 0</body><body package="Store-DB-Pundles" selector="knownPundles">knownPundles	"Answer a SelectionInList containing names of 	all bundles and packages stored in DB."	| pkgs buns names |	pkgs := (Package allPackages collect: [:each | each name]) asSet.	buns := (Bundle allBundles collect: [:each | each name]) asSet.	names := OrderedCollection new: pkgs size + buns size.	names addAll: pkgs.	names addAll: buns.	^SelectionInList with: names asSortedCollection asList.</body><body package="Store-DB-Pundles" selector="loadMostRecentlyMergedWithName:">loadMostRecentlyMergedWithName: aName	| aPundle |	aPundle := self mostRecentlyMergedWithName: aName.	aPundle notNil		ifTrue:[aPundle loadSrc].	^aPundle</body><body package="Store-DB-Pundles" selector="loadPundleId:">loadPundleId: primaryKey	"Loads a pundle by key. Note: must be sent to a particular subclass - not the abstract Pundle class."	( self aRecordWithID: primaryKey ) loadSrc</body><body package="Store-DB-Pundles" selector="loadWithName:version:">loadWithName: aName version: aVersion	| aPundle |	aPundle := self pundleWithName: aName version: aVersion.	aPundle notNil		ifTrue:[aPundle loadSrc].	^aPundle</body><body package="Store-DB-Pundles" selector="mostRecentlyMergedWithName:">mostRecentlyMergedWithName: aName	| dbPkgs  |	dbPkgs := self allVersionsWithName: aName andBlessingLevel: Policies mergePolicy blessingForIntegrated.	dbPkgs 		isEmpty ifTrue: [^nil].	dbPkgs := dbPkgs asSortedCollection: [:x :y | x primaryKey &gt; y primaryKey].	^dbPkgs first</body><body package="Store-DB-Pundles" selector="pundleWithName:version:">pundleWithName: aName version: aVersion 	| coll |	coll := self withName: aName version: aVersion.	^coll isEmpty ifTrue:[nil] ifFalse:[coll first]</body><body package="Store-DB-Pundles" selector="reloadPundle:id:fromDatabase:">reloadPundle: pundleName id: primaryKey fromDatabase: databaseId 	"Loads a pundle based on the primary key."	"Note: must be sent to a subclass, not the abstract Pundle class."	| choice |	self connection.	DbRegistry databaseIdentifier = databaseId		ifFalse: [ ^Dialog warn: ( 'Cannot load &lt;1s&gt; from &lt;2s&gt; - not logged on'					expandMacrosWith: pundleName with: databaseId printString ) ].	choice := Dialog 		choose: self instanceBehavior name, ' ', pundleName, ' was loaded or published.'		 labels: ( Array with: 'Reload From the Database' with: 'Set the Parent' with: 'Do Nothing' )		values: #( #reload #reset #cancel )		default: #reset.	choice == #cancel ifTrue: [ ^self ].				choice == #reload		ifTrue: [ self loadPundleId: primaryKey ]		ifFalse: [ self resetPundleId: primaryKey ].</body><body package="Store-DB-Pundles" selector="reloadPundle:named:id:fromDatabase:">reloadPundle: aSymbol named: pundleName id: primaryKey fromDatabase: databaseId 	"Loads a pundle based on the primary key."	( self subclassFromType: aSymbol )		reloadPundle: pundleName id: primaryKey fromDatabase: databaseId.</body><body package="Store-DB-Pundles" selector="reloadPundle:type:id:fromDatabase:">reloadPundle: pundleName type: aSymbol id: primaryKey fromDatabase: databaseId 	"Loads a pundle based on the primary key."	( self subclassFromType: aSymbol )		reloadPundle: pundleName id: primaryKey fromDatabase: databaseId.</body><body package="Store-DB-Pundles" selector="rename">rename	"Rename aName to aNewName for all matching records in the db.	Send to appropiate subclass. Only the system admin has rights."		| oldName newName |	oldName := self selectName.	oldName == nil		ifTrue: [ ^self ].	newName := ''.	[ newName := SmalltalkWorkbench requestNewPackageName: newName.	newName isEmpty ifTrue: [ ^self ].	( self hasVersionNamed: newName )		ifTrue: [ Dialog warn: ( '&lt;1s&gt; already exists.' expandMacrosWith: newName ). false	]		ifFalse: [ true ]	] whileFalse.	self rename: oldName to: newName.</body><body package="Store-DB-Pundles" selector="rename:to:">rename: aName to: aNewName	"Rename aName to aNewName for all matching records in the db.	Send to appropiate subclass. Only the system admin has rights."		| list |	list := self allVersionsWithName: aName.	list isEmpty		ifTrue: [ Dialog warn: 'No published versions'. ^nil ].	Cursor database showWhile: 		[ list do:			[ :pundle |			self broker process: 				( self newSQL					update;					column: #name equalTo: aNewName printString;					where;					column: #primaryKey equalTo: pundle primaryKey printString 				)			].		].</body><body package="Store-DB-Pundles" selector="resetPundleId:">resetPundleId: primaryKey	"Resets the image pundle to match the database pundle indetified by key."	"Note: must be sent to a particular subclass - not the abstract Pundle class."	| dbPundle imgPundle |	dbPundle := self aRecordWithID: primaryKey.	( imgPundle := dbPundle getImagePundle ) == nil		ifTrue: [ ^( Dialog confirm: 						( 'Image version of &lt;1s&gt; does not exist.&lt;ntt&gt;Load from the database?' 							expandMacrosWith: dbPundle name						)				)  ifTrue: [ self loadPundleId: primaryKey ].				].	imgPundle 		dbTrace: dbPundle primaryKey;		markNotModified.</body><body package="Store-DB-Pundles" selector="selectMultipleVersionsOf:">selectMultipleVersionsOf: aPundleName	"Display a list of pundle versions. Answer the selections,	nil if none. Send to appropiate subclass."		"Package selectMultipleVersionsOf: 'Store-ImageModel'"	| list |	list := self allVersionsWithName: aPundleName.	list isEmpty		ifTrue: [ Dialog warn: 'No prior versions'. ^nil ].	list size == 1		ifTrue: [ ^OrderedCollection with: list first ].	^SimpleDialog new		chooseMultiple: 'Choose versions...'		fromList: ( list collect: [ :m | m displayString, ' ', m blessingLevelString ] ) 		values: list		buttons: #()  values: #()		lines: 12  		cancel: nil  for: nil</body><body package="Store-DB-Pundles" selector="selectName">selectName	"Display a list of pundle versions. Answer the selection,	nil if none. Send to appropiate subclass."		"Bundle selectName"	| list |	list := self allNames asSortedCollection.	list isEmpty		ifTrue: [ Dialog warn: 'No prior versions'. ^nil ].	 ^Dialog 		choose: 'Choose ', self class name asClassNameOnly, '...'		fromList: list 		values: list		lines: 15 cancel: [ ^nil ]		for: nil.</body><body package="Store-DB-Pundles" selector="selectVersionOf:">selectVersionOf: aPundleName	"Display a list of pundle versions. Answer the selection,	nil if none. Send to appropiate subclass."		| list |	list := self allVersionsWithName: aPundleName.	list isEmpty		ifTrue: [ Dialog warn: 'No prior versions'. ^nil ].	list size == 1		ifTrue: [ ^list first ].	 ^Dialog 		choose: 'Choose version...'		fromList: ( list collect: [ :m | m displayString, ' ', m blessingLevelString ] ) 		values: list		lines: 10 cancel: [ ^nil ]		for: nil.</body></methods><methods><class-id>Store.Pundle class</class-id> <category>accessing</category><body package="Store-DB-Pundles" selector="legalPublishingProperties">legalPublishingProperties	^LegalPublishingProperties</body><body package="Store-DB-Pundles" selector="propertiesPublishingPolicy">propertiesPublishingPolicy	^PropertiesPublishingPolicy</body><body package="Store-DB-Pundles" selector="propertiesPublishingPolicy:">propertiesPublishingPolicy: aSymbol 	(self legalPublishingProperties includes: aSymbol) ifFalse: 		[self error: (#InvalidPropertyPolicy &lt;&lt; #store &gt;&gt; '&lt;1&gt; is not a valid properties publishing policy' 							expandMacrosWith: aSymbol)].	PropertiesPublishingPolicy := aSymbol</body></methods><methods><class-id>Store.Package</class-id> <category>testing</category><body package="Store-DB-Pundles" selector="containedItems">containedItems	"Answer a collection of components."	^#()			"don't got none."</body><body package="Store-DB-Pundles" selector="hasExtensions">hasExtensions	"Answer true if the receiver extends a class/namespace not in the package."	| extended defined |	defined := self classes collect: [ :class | class absoluteName ].	extended := ( self methods collect: [:method | method className] ) asSet.	extended := extended reject: [:mName | mName includes: $ ].	defined addAll: ( self nameSpaces collect: [ :ns | ns absoluteName ] ).	extended addAll: ( self data collect: [ :elem | elem environmentString ] ).	defined do: [:each | extended remove: each ifAbsent: nil ].	^extended isEmpty not.</body><body package="Store-DB-Pundles" selector="includesDataKey:className:">includesDataKey: dataKey className: aClassName	data == nil ifTrue: [ ^false ].	^( self data detect: 		[:datum | datum className = aClassName 					and: [ datum dataKey = dataKey ]		] ifNone: [ nil]	) ~~ nil</body><body package="Store-DB-Pundles" selector="includesDataKey:nameSpaceName:">includesDataKey: dataKey nameSpaceName:  aName	data == nil ifTrue: [ ^false ].	^( self data detect: 		[:datum | datum dataKey = dataKey   					and: [ datum nameSpaceName = aName ]		] ifNone: [ nil]	) ~~ nil</body><body package="Store-DB-Pundles" selector="includesDataKey:owner:">includesDataKey: dataKey owner: aName	data == nil ifTrue: [ ^false ].	^( self data detect: 		[:datum | datum environmentString = aName 					and: [ datum dataKey = dataKey ]		] ifNone: [ nil]	) ~~ nil</body><body package="Store-DB-Pundles" selector="includesDataKey:ownerName:">includesDataKey: dataKey ownerName: aName	^( self data detect: 		[:datum | datum environmentString = aName 					and: [ datum dataKey = dataKey ]		] ifNone: [ nil]	) ~~ nil</body><body package="Store-DB-Pundles" selector="includesDatum:">includesDatum: aDataDescriptor	"Answer true if the receiver contains a definition of aDataDescriptor. 	Since this is for package comparisons, include overrides."	^self includesDataKey: aDataDescriptor dataKey ownerName: aDataDescriptor absoluteOwnerName</body><body package="Store-DB-Pundles" selector="includesMethod:">includesMethod: aMethodDescriptor	^self 		includesSelector: aMethodDescriptor selector 		className: aMethodDescriptor absoluteClassName asClassNameOnly		meta: aMethodDescriptor isMeta</body><body package="Store-DB-Pundles" selector="includesSelector:class:">includesSelector: aSelector class: aClass	^self 		includesSelector: aSelector 		className: aClass absoluteName asClassNameOnly 		meta: aClass isMeta</body><body package="Store-DB-Pundles" selector="includesSelector:className:meta:">includesSelector: aSelector className: aClassName meta: isMeta	^( self method: aSelector forClassNamed: aClassName meta: isMeta ) ~~ nil</body><body package="Store-DB-Pundles" selector="isDataEmpty">isDataEmpty	^self data size = 0</body><body package="Store-DB-Pundles" selector="isLeaf">isLeaf	^true</body><body package="Store-DB-Pundles" selector="isPackage">isPackage	^true</body><body package="Store-DB-Pundles" selector="isUpdating">isUpdating	^self properties at: #updating ifAbsent: [ false ].</body></methods><methods><class-id>Store.Package</class-id> <category>private-file out</category><body package="Store-DB-Pundles" selector="createOrFindExpression">createOrFindExpression	"Answer a string that when evaluated will instantiate the image version of the receiver - creating, if neccessary."	^'( Store.Registry packageNamedOrCreate: ', self name printString, ' ) '.</body><body package="Store-DB-Pundles" selector="fileNameForBinVersion">fileNameForBinVersion	"Answer a file name for storing the binary version of the package.	Create a file name from the primary key and db identity."	^nil.			"For now""  	| fileName |	fileName := ConnectionTool connectionDefaults packageDir value.	fileName isEmpty ifTrue: [^nil].	fileName := fileName asFilename.	^fileName construct: self primaryKey printString."</body><body package="Store-DB-Pundles" selector="fileOutClassesOn:">fileOutClassesOn: aFileManager 	"New classes or classes with new definitions."	self classesWithSource	do: 		[ :each | each fileOutDifferencesBetween: nil on: aFileManager ].	aFileManager cr; cr</body><body package="Store-DB-Pundles" selector="fileOutDataKeys:in:on:">fileOutDataKeys: aCollection in: anOwner on: aFileManager 	"file out a collection of datakeys in anOwner. Order is not important."	| cname |	cname := anOwner absoluteName.	( aCollection collect: [ :key | self datum: key forOwnerNamed: cname ] ) 		do: [ :dd | dd fileOutOn: aFileManager ].	aFileManager cr; cr.</body><body package="Store-DB-Pundles" selector="fileOutDataOn:">fileOutDataOn: aFileManager 	self dataWithSource do: [ :dd | dd fileOutOn: aFileManager ].	aFileManager cr; cr.</body><body package="Store-DB-Pundles" selector="fileOutMethodsOn:">fileOutMethodsOn: aFileManager 	"File out the receiver's methods to aFileManager"	self fileOutMethods: self methodsWithSource on: aFileManager.</body><body package="Store-DB-Pundles" selector="fileOutNameSpacesOn:">fileOutNameSpacesOn: aFileManager 	"New namespaces or namespaces with new definitions."	( self nameSpacesWithSource )		"filed out in order"		do: [ :each | each fileOutDifferencesBetween: nil on: aFileManager ].	aFileManager cr; cr</body><body package="Store-DB-Pundles" selector="fileOutOn:">fileOutOn: aFileManager 	"File out package on aFileManager"	aFileManager addComment: 'Package ' , self itemString.	self fileOutPropertiesOn: aFileManager.	self fileOutNameSpacesOn: aFileManager.	self fileOutClassesOn: aFileManager.	self fileOutDataOn: aFileManager.	self fileOutMethodsOn: aFileManager.	aFileManager cr.</body><body package="Store-DB-Pundles" selector="fileOutSelectors:in:on:">fileOutSelectors: aCollection in: aClass on: aFileManager 	"First group methods by protocol and the ask aFileManager to do the job."	| meths cname |	cname := aClass absoluteName.	meths := aCollection collect: [ :sel | self method: sel forClassNamed: cname meta: aClass isMeta ]. 	self fileOutMethods: meths on: aFileManager.</body></methods><methods><class-id>Store.Package</class-id> <category>private-utilities</category><body package="Store-DB-Pundles" selector="classIntersectionWith:">classIntersectionWith: aPackage	"Answer a collection of classes that are	common to the receiver and aPackage."	| other common |	other := aPackage classes collect: [:aClass| aClass primaryKey].	common := classes select: [:mineClass| other includes: mineClass primaryKey].	^common</body><body package="Store-DB-Pundles" selector="metaclassIntersectionWith:">metaclassIntersectionWith: aPackage	"Answer a collection of classes that are	common to the receiver and aPackage."	| other common |	other := aPackage metaclasses collect: [:aClass| aClass primaryKey].	common := metaclasses select: [:mineClass| other includes: mineClass primaryKey].	^common</body><body package="Store-DB-Pundles" selector="superclassOrder:">superclassOrder: dbClasses	"Sort all of the classes in the list into a collection where no class is 	preceded by a subclass or by its metaclass.	I cannot use method in the chage set since the classes are not in 	the image"	^self class superclassOrder: dbClasses</body></methods><methods><class-id>Store.Package</class-id> <category>private-accessing</category><body package="Store-DB-Pundles" selector="recordForClassTag:">recordForClassTag: aTag 	"Answer the item in this package corresponding to 'aTag' or nil if not there."	^( aTag isMeta		ifTrue: [ self metaclasses ]		ifFalse: [ self classes ] 	) detect: 		[ :dbClass | 		dbClass absoluteName asClassNameOnly = aTag className		] ifNone: [ nil ]</body><body package="Store-DB-Pundles" selector="recordForDataTag:">recordForDataTag: aTag 	"Answer the item in this package corresponding to 'aTag' or nil if not there." 	^data isNil		ifTrue: 			[ DataView				datumWithKey: aTag dataKey asString				ownerName: aTag ownerName asString				package: self primaryKey			]		ifFalse: 			[ data detect: 				[ :datum | 				datum environmentString = aTag ownerName asString 					and: [ datum dataKey = aTag dataKey ]				] ifNone: [ nil ]			]</body><body package="Store-DB-Pundles" selector="recordForMethodTag:">recordForMethodTag: aTag 	"Answer the item in this package corresponding to 'aTag' or nil if not there." 	^methods isNil		ifTrue: [ MethodsView					methodNamed: aTag selector asString					class: aTag className					package: self primaryKey				]		ifFalse: 			[ methods detect: 				[ :method | 				method className = aTag className and: [ method selector = aTag selector ]				] ifNone: [ nil ]			]</body><body package="Store-DB-Pundles" selector="recordForNameSpaceTag:">recordForNameSpaceTag: aTag 	"Answer the item in this package corresponding to 'aTag' or nil if not there."	^self nameSpaces detect: 		[ :dbNs | 		dbNs absoluteName = aTag name		] ifNone: [ nil ]</body><body package="Store-DB-Pundles" selector="recordForStructureTag:">recordForStructureTag: aTag 	"Answer the item in this package corresponding to 'aTag' or nil if not there."	^nil</body><body package="Store-DB-Pundles" selector="recordForTag:">recordForTag: aTag 	"Answer the item in this package corresponding to 'aTag' 	or nil if not there."	^aTag recordForPackage: self.</body><body package="Store-DB-Pundles" selector="recordOrPseudoForClassTag:">recordOrPseudoForClassTag: aTag 	"Answer the item in this package corresponding to 'aTag' or an instance of PseudoClass if not there."	^( aTag isMeta		ifTrue: [ self metaclasses ]		ifFalse: [ self classes ] 	) detect: 		[ :dbClass | 		dbClass absoluteName asClassNameOnly = aTag className		] ifNone: [ PseudoClass named: aTag className meta: aTag isMeta ]</body><body package="Store-DB-Pundles" selector="recordOrPseudoForDataTag:">recordOrPseudoForDataTag: aTag 	"Answer the item in this package corresponding to 'aTag' or an instance of PseudoSubdef if not there." 		| dm |	dm := data == nil		ifTrue: 			[ DataView				datumWithKey: aTag dataKey asString				ownerName: aTag ownerName				package: self primaryKey			]		ifFalse: 			[ data detect: 				[ :datum | 				datum environmentString = aTag environmentString 					and: [ datum dataKey = aTag dataKey ]				] ifNone: [  PseudoSubdef dataKey: aTag dataKey owner: aTag ownerName  ]			].	^dm == nil		ifTrue: [ PseudoSubdef dataKey: aTag dataKey owner: aTag ownerName ]		ifFalse: [ dm ].</body><body package="Store-DB-Pundles" selector="recordOrPseudoForMethodTag:">recordOrPseudoForMethodTag: aTag 	"Answer the item in this package corresponding to 'aTag' or an instance of PseudoSubdef if not there." 	| meth |	meth := methods ==  nil		ifTrue: [ MethodsView					methodNamed: aTag selector asString					class: aTag classNameWithMeta					package: self primaryKey				]		ifFalse: 			[ methods detect: 				[ :method | 				method className = aTag classNameWithMeta and: [ method selector = aTag selector ]				] ifNone: [ nil ]			].		^meth == nil		ifTrue: [  PseudoSubdef selector: aTag selector owner: aTag classNameWithMeta ]		ifFalse: [ meth ].</body><body package="Store-DB-Pundles" selector="recordOrPseudoForNameSpaceTag:">recordOrPseudoForNameSpaceTag: aTag 	"Answer the item in this package corresponding to 'aTag' or an instance of PseudoNameSpace if not there."	^self nameSpaces detect: 		[ :dbNs | 		dbNs absoluteName = aTag name		] ifNone: [ PseudoNameSpace named: aTag name ]</body><body package="Store-DB-Pundles" selector="recordOrPseudoForTag:">recordOrPseudoForTag: aTag 	"Answer the item in this package corresponding to 'aTag' or a pseudo record if not there."	aTag isForMethod		ifTrue: [ ^self recordOrPseudoForMethodTag: aTag ].	aTag isForData		ifTrue: [ ^self recordOrPseudoForDataTag: aTag ].	aTag isForClass | aTag isClassCommentTag		ifTrue: [ ^self recordOrPseudoForClassTag: aTag ].	aTag isForNameSpace | aTag isNameSpaceCommentTag		ifTrue: [ ^self  recordOrPseudoForNameSpaceTag: aTag ].	self error: 'Unknown tag type.'</body></methods><methods><class-id>Store.Package</class-id> <category>private-differences calculation</category><body package="Store-DB-Pundles" selector="classesAndNameSpacesFromChanges:">classesAndNameSpacesFromChanges: changeSet	| list |	list := OrderedCollection new.	changeSet keysAndValuesDo:		[ :symbol :cc | 		( cc isForClass			ifTrue: 				[ list add: 					( self classes 						detect: 	[ :cls | cls absoluteName = symbol asString ] 						ifNone: [ PseudoClass named: symbol meta: false ]					).				list add: 					( self metaclasses 						detect: 	[ :cls | cls absoluteName = symbol asString ] 						ifNone: [ PseudoClass named: symbol meta: true ]					).				]				ifFalse:					[ list add: 						( self nameSpaces 							detect: 	[ :cls | cls absoluteName = symbol asString ] 							ifNone: [ PseudoNameSpace newNamed: symbol ]						)					]			)		].	^list</body><body package="Store-DB-Pundles" selector="classesNamed:">classesNamed: aSetOfNames 	"Convert aSetOfnames into a collection of TT_Classes or TT_PseudoClasses."		| names selected |	names := aSetOfNames copy.	selected := SortedCollection sortBlock: [:x :y | x name &lt; y name].	self classes do: 		[ :cl | ( names includes: cl absoluteName )			ifTrue: 				[names remove: cl absoluteName.				selected add: cl				]		].	self metaclasses do: 		[ :cl | ( names includes: cl absoluteName, ' class'  )			ifTrue: 				[ names remove: cl absoluteName, ' class'.				selected add: cl				]		].	names do: 		[ :nm |  selected add: (PseudoClass newNamed: nm ) ].	^selected</body><body package="Store-DB-Pundles" selector="computeDiffsBetween:into:">computeDiffsBetween: aPackage into: diffHolder	^aPackage computeDiffsBetweenDBPackage: self into: diffHolder</body><body package="Store-DB-Pundles" selector="computeDiffsBetweenDBPackage:into:">computeDiffsBetweenDBPackage: aBDPackage into: diff	"Store  differences between receiver and a aDBPackage 	into an instance of TT_PackageDifferences.	Store receiver's definitions as number2 since this method	is called with arguments reversed."	diff methodsSide: 2 put: (Method allInPackage: self primaryKey butNotIn: aBDPackage primaryKey).	diff methodsSide: 1 put: (Method allInPackage: aBDPackage primaryKey butNotIn: self primaryKey).	diff dataSide: 2 put: (DataElement allInPackage: self primaryKey butNotIn: aBDPackage primaryKey).	diff dataSide: 1 put: (DataElement allInPackage: aBDPackage primaryKey butNotIn: self primaryKey).	diff nameSpacesSide: 2 put: (NameSpaceRecord allInPackage: self primaryKey butNotIn: aBDPackage primaryKey).	diff nameSpacesSide: 1 put: (NameSpaceRecord allInPackage: aBDPackage primaryKey butNotIn: self primaryKey).	diff classesSide: 2 put: (ClassRecord allInPackage: self primaryKey butNotIn: aBDPackage primaryKey).	diff classesSide: 1 put: (ClassRecord allInPackage: aBDPackage primaryKey butNotIn: self primaryKey).	diff metaSide: 2 put: (ClassRecord allMetaclassesInPackage: self primaryKey butNotIn: aBDPackage primaryKey).	diff metaSide: 1 put: (ClassRecord allMetaclassesInPackage: aBDPackage primaryKey butNotIn: self primaryKey).	^diff</body><body package="Store-DB-Pundles" selector="modifications">modifications	"Answer my content as a collection of modifications."	| mods |	mods := super modifications.	self classes do: 		[ :cl | 		mods add: ( Modification tag: cl asTag package: self record: cl ).		mods add: ( Modification tag: cl asCommentTag package: self record: cl )		].	self nameSpaces do: 		[ :ns | 		mods add: ( Modification tag: ns asTag package: self record: ns ).		mods add: ( Modification tag: ns asCommentTag package: self record: ns )		].	self methods do: [ :mm | mods add: ( Modification	 tag: mm asTag	package: self record: mm ) ].	self data do: [ :dm | mods add: ( Modification tag: dm asTag package: self record: dm ) ].	^mods</body><body package="Store-DB-Pundles" selector="nameSpacesNamed:">nameSpacesNamed: aSetOfNames 	"Convert aSetOfnames into a collection of NameSpaceRecords or PseudoNameSpaces."		| names selected |	names := aSetOfNames copy.	selected := SortedCollection sortBlock: [:x :y | x name &lt; y name].	self nameSpaces do: 		[ :ns | ( names includes: ns absoluteName )			ifTrue: 				[names remove: ns absoluteName.				selected add: ns				]		].	names do: 		[ :nm |  selected add: ( PseudoNameSpace newNamed: nm ) ].	^selected</body></methods><methods><class-id>Store.Package</class-id> <category>db-utilities</category><body package="Store-DB-Pundles" selector="conflictsWithImage">conflictsWithImage	"Answer a collection of package elements that describe entities that 	already exists in the image."	| conflicts |	conflicts := OrderedCollection new.	conflicts addAll: (self nameSpaces select: [:each | each conflictsWithImage]).	conflicts addAll: (self classes select: [:each | each conflictsWithImage]).	conflicts addAll: (self methods select: [:each | each conflictsWithImage]).	conflicts addAll: (self data select: [:each | each conflictsWithImage]).	^conflicts</body><body package="Store-DB-Pundles" selector="itemCount">itemCount	^( Methods  itemCountForPackage: primaryKey ) +		( PkgClasses  itemCountForPackage: primaryKey ) +		( PkgNameSpaces  itemCountForPackage: primaryKey ) +		( Data  itemCountForPackage: primaryKey )</body><body package="Store-DB-Pundles" selector="loadClasses:into:">loadClasses: dbClasses into: imgPackage 	"Load the dbClasses and their meta classes. Supress errors for second try. 	Answer the list of failed classes."	| failed |	failed := OrderedCollection new.	dbClasses do: 		[ :cls |  		[ cls loadSrcInto: imgPackage ] on: UnhandledException do:			[ :ex | 			failed add: cls.			ex return			]  		].	^failed</body><body package="Store-DB-Pundles" selector="loadClasses:metaclasses:">loadClasses: dbClasses metaclasses: dbMetaclasses	"Load the dbClasses and their meta classes. Supress errors for second try.	Answer the list of failed classes."	| failed  |	failed := Set new.	dbClasses do:		[ :cls | [ cls loadSrc.  ] on: Error do: [ :ex | failed add: cls. ex return ]  ].	^failed.</body><body package="Store-DB-Pundles" selector="loadClasses:metaclasses:toRemove:">loadClasses: dbClasses metaclasses: dbMetaclasses toRemove: toRemove	"Load the dbClasses and their meta classes. Supress errors for second try.	Answer the list of failed classes."	| idx failed metaClass |	failed := OrderedCollection new.	dbClasses do:		[ :cls |		idx := toRemove findFirst: [ :imCl | imCl name = cls name ].		idx &gt; 0 ifTrue:  [ toRemove removeAtIndex: idx ].		[ cls loadSrc.   ] on: Error do: [ :ex | failed add: cls. ex return ].		metaClass := dbMetaclasses detect: [:meta | meta name = ( cls name , ' class') ].		metaClass loadSrc		].	^failed.</body><body package="Store-DB-Pundles" selector="loadData:ownerName:intoPackage:ifNone:">loadData: dataKey ownerName: fullName intoPackage: destPackage ifNone: noneBlock	"Load the data specified from the database."	| element |	element := self datum: dataKey forOwnerNamed: fullName.	element isNil ifTrue: [ ^noneBlock value ].	element loadSrcIntoPackage: destPackage confirm: false.</body><body package="Store-DB-Pundles" selector="loadMethod:className:intoPackage:">loadMethod: selector className: fullClassName intoPackage: destnPackage 	"Load the method specified from the database. 	aSelector		Symbol 	fullClassName	String 	destnPackage	TT_PackageModel 	"	^self		loadMethod: selector		className: fullClassName		intoPackage: destnPackage		ifNone: [self error: 'No method ', fullClassName, ' &gt;&gt; ', selector, ' in package ', self itemString]</body><body package="Store-DB-Pundles" selector="loadMethod:className:intoPackage:ifNone:">loadMethod: selector className: fullClassName intoPackage: destnPackage ifNone: noneBlock	"Load the method specified from the database.		aSelector		Symbol		fullClassName	String  		destnPackage	TT_PackageModel		noneBlock		Block - execute if there is no such method in the package	"	| aTtMethod |	aTtMethod := self method: selector					forClassNamed: fullClassName asClassNameOnly							"remove 'a Class' in metaclass names"					meta: fullClassName namesMetaClass.	aTtMethod isNil ifTrue: [^noneBlock value].	aTtMethod loadSrcIntoPackage: destnPackage confirm: false.</body><body package="Store-DB-Pundles" selector="loadNameSpaces:imagePackage:">loadNameSpaces: dbNamespaces imagePackage: imgPackage	"Load the dbNamespaces and their meta classes. "	dbNamespaces do: 	[ :ns | ns loadSrcInto: imgPackage ].</body><body package="Store-DB-Pundles" selector="loadNameSpaces:toRemove:">loadNameSpaces: dbNamespaces toRemove: toRemove	"Load the dbNamespaces and their meta classes. "	| idx |	dbNamespaces do:		[ :ns |		idx := toRemove findFirst: [ :imNS | imNS absoluteName = ns absoluteName ].		idx &gt; 0 ifTrue:  [ toRemove removeAtIndex: idx ].		ns loadSrc.		].</body><body package="Store-DB-Pundles" selector="loadNameSpaces:toRemove:imagePackage:">loadNameSpaces: dbNamespaces toRemove: toRemove imagePackage: imgPackage	"Load the dbNamespaces and their meta classes. "	| idx |	dbNamespaces do:		[ :ns |		idx := toRemove findFirst: [ :imNS | imNS absoluteName = ns absoluteName ].		idx &gt; 0 ifTrue:  [ toRemove removeAtIndex: idx ].		ns loadSrc.		"got to validate that it got to the right place."		XMainChangeSet current moveNameSpaceDefinition: ns object toPackage: imgPackage.		].</body><body package="Store-DB-Pundles" selector="loadSrc">loadSrc	"Load the package from DB.	Return the image package or nil on error."	| imgPackage |	[ ( imgPackage := self loadSrcWithin: nil warnReplace: true ) == nil		ifFalse: 			[ ChangeSet loadPundle: self.			SourceFileManager default loadPundle: self.			imgPackage cleanUpOverrides.			]	] on: RedefinitionNotification do:			[ : note | self name =  ( note currentPackage name )						ifFalse: [ note override install. ].			note resume.			].	Undeclared purgeUnusedBindings.	^imgPackage</body><body package="Store-DB-Pundles" selector="loadSrcWithin:warnReplace:">loadSrcWithin: parentBundle warnReplace: warnReplace	"Load the package from DB. 	Return the image package or nil on error."	self checkPrerequisites		ifFalse: [ ^nil ].	self runPreRead		ifFalse: [ ^nil ].	^self 		loadWithin: parentBundle 		useBinIfAvailable: Policies publishPolicy allowBinaryLoading		warnReplace: warnReplace</body><body package="Store-DB-Pundles" selector="loadWithin:useBinIfAvailable:warnReplace:">loadWithin: parentBundle useBinIfAvailable: binOK warnReplace: warnReplace	"Load the package."	| imPkg |	( binOK not or: [ ( imPkg := self binLoadWithin: parentBundle ) isNil ] )		ifTrue: [ imPkg := self sourceLoadFromDBloadWithin: parentBundle warnReplace: warnReplace ].	Root allNameSpaces do: [ :ns | ns organization removeEmptyCategories ].	^imPkg</body><body package="Store-DB-Pundles" selector="postLoad:">postLoad: imPkg 	"Do post load clean up"	imPkg isNil		ifFalse: 			["self checkContentWith: imPkg."			imPkg 				dbTrace: self primaryKey;								runPostLoad;				markNotModified.			]</body><body package="Store-DB-Pundles" selector="preLoadCheckWith:within:">preLoadCheckWith: imPkg within: aBundle	"Verify the receiver can be loaded."	^LoadAnalyzer		preDBLoadOverlapCheckOf: imPkg		within: aBundle		classes: self classesWithSource		nameSpaces: self nameSpacesWithSource		methods: self methodsWithSource		data: self dataWithSource</body><body package="Store-DB-Pundles" selector="tableOfContents">tableOfContents	"Answer a string describing the content of the receiver"	| aStream |	aStream := WriteStream on: (String new: 200).	aStream nextPutAll: 'Package: ' , self name; cr.	aStream nextPutAll: 'Clasess:'; cr.	classes := self superclassOrder: self classes.	classes do: [:each | aStream nextPutAll: each name; cr].	aStream nextPutAll: 'Methods:'; cr.	self methods do: [:each | aStream nextPutAll: each className, '&gt;&gt;', each protocolName, '&gt;&gt;', each name; cr].	^aStream contents</body><body package="Store-DB-Pundles" selector="typeStringForBlessing">typeStringForBlessing		^Blessing typeStringForPackages</body><body package="Store-DB-Pundles" selector="youngerVersions">youngerVersions	"Answer a collection of Packages that were published after the receiver.."	^self class allVersionsWithName: self name newerThan: self.</body></methods><methods><class-id>Store.Package</class-id> <category>private-loading</category><body package="Store-DB-Pundles" selector="binaryVersion">binaryVersion	"Answer a ParcelRecord if one exists for the receiver. Answer nil otherwise."	^parcelID == nil		ifFalse: 			[ ( self class parcelRecordClass aRecordWithID: parcelID )				pundle: self;				yourself			]</body><body package="Store-DB-Pundles" selector="binLoadWithin:">binLoadWithin: parentBundle	| imgPkg record unloadable |	( record  := self binaryVersion ) == nil		 ifTrue: [ ^nil ].	unloadable := OrderedCollection new.	imgPkg := Registry packageNamed: name.	[ [ imgPkg == nil		ifTrue:			[ imgPkg := ( Registry packageNamedOrCreate: name )							dbTrace: self primaryKey;							loadFrom: record using: CodeReaderForStore new;							yourself.			]		ifFalse: 	[ imgPkg updateFrom: record within: parentBundle ]. 	] on: CodeReader requestWarningSuppressionSignal        do: [ :ex | ex resume: true ].	"to supress unloadable code dialog"	"handle the redef by short-circutting the bundle/package handler. Parcel dealing with this atm"	] on: RedefinitionNotification do: [ :note | note resume ].	[ self checkUninstalledClasses: imgPkg ] on: UnloadableDefinitionError do:		[ :exp | 		exp package: imgPkg.		unloadable add: exp.		exp resume.		].	unloadable isEmpty		ifFalse: [ TabApplicationSystemBrowser 					browseUnloadableExecptionList: unloadable 					labeled: ( 'UNLOADABLE DEFINITIONS for package: &lt;1s&gt;' 								expandMacrosWith: self itemString ).				].	imgPkg == nil		ifFalse: 			[ imgPkg 				dbTrace: self primaryKey;				markNotModified.			].	^imgPkg</body><body package="Store-DB-Pundles" selector="checkUninstalledClasses:">checkUninstalledClasses: imgPackage	"Determine if there are any uninstalled classes or methods and deal with them appropriately."	| uninstalledClasses uninstalledMethods uninstalledBindings |	uninstalledClasses := imgPackage propertyAt: #uninstalledClasses ifAbsent: [ OrderedCollection new ].	uninstalledMethods := imgPackage propertyAt: #uninstalledMethods ifAbsent: [ OrderedCollection new ].	uninstalledBindings :=  imgPackage propertyAt: #uninstalledBindings ifAbsent: [ OrderedCollection new ].	uninstalledMethods isEmpty &amp; uninstalledClasses isEmpty &amp; uninstalledBindings isEmpty		ifFalse: [ self checkUninstalledClasses: uninstalledClasses methods: uninstalledMethods bindings: uninstalledBindings ].	imgPackage propertyAt: #uninstalledClasses put: nil.			imgPackage propertyAt: #uninstalledMethods put: nil.	imgPackage propertyAt: #uninstalledBindings put: nil.</body><body package="Store-DB-Pundles" selector="checkUninstalledClasses:methods:bindings:">checkUninstalledClasses: uninstalledClasses methods: uninstalledMethods bindings: uninstalledBindings	"Determine why the uninstalled can't be installed and display a message box informing the user.	Signal the unloadable exception for the browser."	| clsRecords methRecords dataRecords |	clsRecords := self classesNamed: ( uninstalledClasses collect: [ :uc | uc absoluteName ] ).	methRecords :=  ( uninstalledMethods collect:		[ :um | MethodsView					methodNamed: um selector asString					class: um implementingClass classNameWithMeta					package: self primaryKey		] ) asOrderedCollection.	dataRecords := OrderedCollection new.	"uninstalled classes methods are not seperate records, so convert them."	uninstalledClasses do:		[ :uc | uc selectors do:				[ :sel | methRecords add: 						( MethodsView							methodNamed: sel asString							class: uc absoluteName							package: self primaryKey						)				].			uc class selectors do:				[ :sel | methRecords add: 						( MethodsView							methodNamed: sel asString							class: uc class absoluteName							package: self primaryKey						)				].			dataRecords addAll: 				( uc asNameSpace keys collect:					[ :key | 					DataView datumWithKey: key asString					ownerName: uc absoluteName					package: self primaryKey					]				).		].	uninstalledBindings do:		[ :ubc |  		ubc asNameSpace keys do:			[ :key |			dataRecords add:				( DataView datumWithKey: key ownerName: ubc absoluteName package: self primaryKey ) 			]		].	LoadAnalyzer checkUninstalledForPackage: self classes: clsRecords methods: methRecords data: dataRecords.	clsRecords asOrderedCollection, methRecords, dataRecords		 do: [ :rec | UnloadableDefinitionError signalWith: rec ].</body><body package="Store-DB-Pundles" selector="doDiffSourceLoad:within:">doDiffSourceLoad: imPkg within: parentBundle	"Load source code of the packge. Make sure that only defintions that 	are different are loaded. Remove definitions that are in the image but are not present 	in the parentBundle."	| diffs unloadable |	diffs := PackageDifferences with: self  with: imPkg. 	( diffs preLoadCheckWithin: parentBundle ) 		ifFalse: [^false].	unloadable := OrderedCollection new.	imPkg runPreUnload: true.	parentBundle == nil		ifTrue: 			[Notice 				showProgress: 'Loading package ' , self name 				complete: diffs 				itemCount while: 					[ 						[ diffs loadFromDBWithin: parentBundle ] 							on: UnloadableDefinitionError 							do:								[ :exp | 								exp package: imPkg.								unloadable add: exp.								exp resume.						] 					]				title: 'Store'			]		ifFalse: 			[ MessageNotification raiseSignal:  self name.			ResetIncrementNotification signalWith: diffs itemCount.			diffs loadFromDBWithin: parentBundle.			].	"Set comment and initalization string."	imPkg comment: self commentOrNil.	imPkg properties: self properties.	"Execute initialization string."	"imPkg runPostLoad."	unloadable isEmpty		ifFalse: [ TabApplicationSystemBrowser 					browseUnloadableExecptionList: unloadable 					labeled: ( 'UNLOADABLE DEFINITIONS for package: &lt;1s&gt;' 								expandMacrosWith: self itemString ).				].	^true</body><body package="Store-DB-Pundles" selector="doSourceLoad:within:">doSourceLoad: imPkg within: parentBundle	"Load source code of the packge. Make sure that only methods and classes that 	are different are loaded. ImgPkg should be empty."	| dbClasses dbNamespaces retry unloadable |	"To display what the error is. In the future, we can pass back the message itself 	and display it in the unloadable definition browser."	self preLoadCheckWith: imPkg  within: parentBundle. 		self runPreLoad.	dbClasses := self classes.	dbNamespaces := self nameSpaces.	unloadable := OrderedCollection new.	[ SystemUtils modifySystem:		[ self loadNameSpaces: dbNamespaces imagePackage: imPkg.		retry := self loadClasses: dbClasses into: imPkg.		self doSourceLoadData: imPkg.		retry := self loadClasses: retry into: imPkg		].	retry do: [ :rec | UnloadableDefinitionError signalWith: rec ].	"Remove classes that were defined in the loaded package"	self doSourceLoadMethods.	] on: UnloadableDefinitionError do:		[ :exp | 		exp package: imPkg.		unloadable add: exp.		exp resume.		].	imPkg removeEmptyProtocols.	self initializeData: self data.	self initializeClasses: dbClasses.	"Set comment and initalization string."	imPkg comment: self commentOrNil; 		properties: self properties.	"Execute initialization string."	"imPkg runPostLoad."	unloadable isEmpty		ifFalse: [ TabApplicationSystemBrowser 					browseUnloadableExecptionList: unloadable 					labeled: ( 'UNLOADABLE DEFINITIONS for package: &lt;1s&gt;' 								expandMacrosWith: self itemString ).				].	^true</body><body package="Store-DB-Pundles" selector="doSourceLoadData:">doSourceLoadData: imPkg	"Load the data of the package 'imPkg'. Make sure that only data that 	are different are loaded. Remove definitions that are in the image but are not present 	in this package."	| toRemove dbData toLoad affectedClasses |	toLoad := List new. 	toRemove := imPkg data asOrderedCollection.	toRemove removeAllSuchThat: 		[ :dataDescriptor | | binding |		( binding := dataDescriptor binding ) == nil			ifTrue: [ true ] 			ifFalse: [ binding value class == ExternalDictionary ]		].	dbData := self data.	dbData do: 		[ :each | | idx imMt |		"Find if a datum is in the system." 		imMt := nil.		idx := toRemove findFirst: [ :mt | mt fullName  = each fullName ].		idx &gt; 0 ifTrue: 			[imMt := toRemove at: idx.			toRemove removeAtIndex: idx].		(imMt isNil or: [(imMt sameAsDBThing: each) not])			ifTrue: [toLoad add: each]].	toLoad do: [ :each | each loadSrc ].	"Remove data."	affectedClasses := Set new.		toRemove do: 		[ :imMt |  		imMt myClass unloadDataKey: imMt dataKey.		affectedClasses add: imMt myClass		].	affectedClasses do: [:aClass | aClass organization removeEmptyCategories].</body><body package="Store-DB-Pundles" selector="doSourceLoadMethods">doSourceLoadMethods	"Load the methods of the receiver. Called when the  image package	is empty."	(  Method sortForLoading: self methodsWithSource package: self ) do: 		[  :each | each loadAsNewWithCommittingSource: false].	[self methodsWithSource do: 		[:method|		method myClass ifNotNil: 			[:class|  |cm source|			cm := class compiledMethodAt: method selector.			source := cm sourcePointer.			source isInteger ifFalse:				[cm sourcePointer: (SourceFileManager default					storeMethodSources: source					class: method myClass 										selector: method selector					category: method protocol 					safely: false)]]]] ensure: [SourceFileManager default targetFile commit]</body><body package="Store-DB-Pundles" selector="doSourceLoadMethods:">doSourceLoadMethods: imPkg	"Load the methods of the package 'imPkg'. Make sure that only methods that 	are different are loaded. Remove definitions that are in the image but are not present 	in this package."	| toRemove dbMethods toLoad affectedClasses |	toLoad := List new. 	toRemove := imPkg methods asOrderedCollection.	dbMethods := self methodsWithSource.	dbMethods do: 		[ :each | | idx imMt |		"Find if a method is in the system. Do not check if protocol is the same. 		If the method is classified differently then loadSrc method will		move it into proper protocol." 		imMt := nil.		idx := toRemove findFirst: [:mt| mt className asString = each className and: 										[mt selector = each selector]].		idx &gt; 0 ifTrue: 			[imMt := toRemove at: idx.			toRemove removeAtIndex: idx].		(imMt isNil or: [(imMt sameAsDBThing: each) not])			ifTrue: [toLoad add: each]].	( Method sortForLoading: toLoad package: self ) do: 		[ :each | each loadAsNew ].	"Remove methods."	affectedClasses := Set new.	toRemove do: 		[ :imMt |  		imMt myClass quietlyRemoveSelector: imMt selector.		affectedClasses add: imMt myClass		].	affectedClasses do: 		[ :aClass | aClass organization removeEmptyCategories ].</body><body package="Store-DB-Pundles" selector="doSourceLoadMethods:within:">doSourceLoadMethods: imPkg within: parentBundle	"Load the methods of the package 'imPkg'. Make sure that only methods that 	are different are loaded. Remove definitions that are in the image but are not present 	in the parent bundle. Assumes imPkg empty."	(  Method sortForLoading: self methodsWithSource package: self ) do: 		[ :each | each loadAsNew ].</body><body package="Store-DB-Pundles" selector="initializeClasses:">initializeClasses: dbClasses	"Send #postLoad to all newly instantiated classes and #initialize to all classes whose 	initialize method was modified."	| toPostLoad toInit |	toPostLoad := dbClasses collect: 		[ :cls |  | obj | 		( obj := cls object ) == nil			ifFalse: [ obj postLoad: self ].		obj		].	"hack - but got to execute new versions of #initialize"	toInit := OrderedCollection new.	self methods do:		[ :meth |  | cls |		( ( meth isMeta and: [ meth selector == #initialize ] ) and: [ ( cls := meth myClass ) ~~ nil ] )			ifTrue: 				[ ( toPostLoad includes: cls instanceBehavior ) 					ifFalse: [ toInit add: cls instanceBehavior ]				].		].	( SystemUtils  sortForLoading: toInit ) do: 		[ :cls | cls initialize ].</body><body package="Store-DB-Pundles" selector="initializeData:">initializeData: dbData	"Initialize all the statics"	| ns bind |	[ ( DataElement sortStaticsForLoading: dbData ) do: 		[ :each |		( ns := each owner ) == nil			ifFalse: 				[ ns := ns asNameSpace.				( bind := ns bindingFor: each dataKey ) == nil					ifFalse: [ bind reinitializeValue ]				]		].	] on: UnloadableDefinitionError do: [ :exp | exp resume ].</body><body package="Store-DB-Pundles" selector="sourceLoadFromDBloadWithin:warnReplace:">sourceLoadFromDBloadWithin: parentBundle warnReplace: warnReplace	"Load the package from DB. 	If the user does not want to replace the loaded version answer the	existing image package. Note: catch errors during the load."	| imPkg loadRes |	imPkg := self createImagePundle.	imPkg dbIdentifier: self dbIdentifier.	(warnReplace and: [imPkg canReplaceVersions not]) ifTrue: [^imPkg].	Policies packagePolicy forcePackage: imPkg while: 		[ XMainChangeSet ignoreMainChangesWhile: 			[ loadRes := imPkg isCompletelyEmpty 				ifTrue: 					[ parentBundle == nil						ifTrue: 							[Notice 								showProgress: 'Loading package ' , self itemString 								complete: self itemCount 								while: [ self doSourceLoad: imPkg within: parentBundle ]								title: 'Store'							]						ifFalse: 							[ MessageNotification raiseSignal:  self itemString.							ResetIncrementNotification signalWith: self itemCount.							self doSourceLoad: imPkg within: parentBundle.							]					]				ifFalse: 	[ self doDiffSourceLoad: imPkg within: parentBundle ]			].			loadRes ifTrue: [ self postLoad: imPkg ]		].	^loadRes		ifTrue: [ imPkg ]		ifFalse: [ nil ]</body></methods><methods><class-id>Store.Package</class-id> <category>private</category><body package="Store-DB-Pundles" selector="addClasses:">addClasses: aCollectionOfClasses 	self addClasses: aCollectionOfClasses mergeData: nil</body><body package="Store-DB-Pundles" selector="addClasses:andMetaclasses:">addClasses: aCollectionOfClasses andMetaclasses: aCollectionOfMetaclasses 	"Convert collection of classes into collection of DB classes and add 	classes to the receiver. 	Note that if the trace is not null then check the classes from the trace and 	create new records only for classes that are different."	| newDBClasses newDBMetaclasses traceClasses |	traceClasses := self hasTrace ifTrue: [ self getTrace classes ] ifFalse: [ #() ].	newDBClasses := OrderedCollection new.	aCollectionOfClasses do: 		[ :each |  | aDBClass |		aDBClass := traceClasses detect: 			[ :dbClass | dbClass absoluteName = each absoluteName ] ifNone: [ nil ].		newDBClasses add: ( ClassRecord recordFor: each trace: aDBClass ).		IncrementNotification raiseSignal.		].	traceClasses := self hasTrace ifTrue: [self getTrace metaclasses] ifFalse: [#()].	newDBMetaclasses := OrderedCollection new.	aCollectionOfMetaclasses 	do: 		[:each | 		| aDBClass |		aDBClass := traceClasses detect: [:dbClass | dbClass classNameWithMeta = each absoluteName]					ifNone: [nil].		newDBMetaclasses add: (ClassRecord recordFor: each trace: aDBClass)		].	self addDBClasses: newDBClasses andMetaclasses: newDBMetaclasses</body><body package="Store-DB-Pundles" selector="addClasses:andMetaclasses:mergeData:">addClasses: aCollectionOfClasses andMetaclasses: aCollectionOfMetaclasses mergeData: mergeData	"Convert collection of classes into collection of DB classes and add 	classes to the receiver. 	Note that if the trace is not null then check the classes from the trace and 	create new records only for classes that are different."	| newDBClasses newDBMetaclasses traceClasses |	traceClasses := self hasTrace ifTrue: [self getTrace classes] ifFalse: [#()].	newDBClasses := OrderedCollection new.	aCollectionOfClasses do: 		[:each |    | aDBClass aDBClass2 |		aDBClass := mergeData resolutionRecordForTag: 				(ClassTag newClass: each) packageNamed: self name. 		aDBClass2 := mergeData resolutionRecordForTag: 				(ClassCommentTag newClass: each) packageNamed: self name. 		aDBClass2 notNil 			ifTrue:				[aDBClass isNil 					ifTrue:  [ aDBClass := aDBClass2 ]					ifFalse:  						[ aDBClass  = aDBClass2  							ifFalse: 							["Two different defintions we cannot reuse."							aDBClass := nil							]						]				].			aDBClass isNil 				ifTrue: 					[aDBClass := traceClasses detect: 						[:dbClass | dbClass absoluteName = each absoluteName] ifNone: [nil]					].			newDBClasses add: (ClassRecord recordFor: each trace: aDBClass).			IncrementNotification raiseSignal.			].	traceClasses := self hasTrace ifTrue: [self getTrace metaclasses] ifFalse: [#()].	newDBMetaclasses := OrderedCollection new.	aCollectionOfMetaclasses do: 		[:each | 		| aDBClass aDBClass2 |		aDBClass := mergeData resolutionRecordForTag: 			(ClassTag newClass: each)  packageNamed: self name. 		aDBClass2 := mergeData resolutionRecordForTag: 			(ClassCommentTag newClass: each)  packageNamed: self name. 		aDBClass2 notNil 			ifTrue:				[aDBClass isNil 					ifTrue: [aDBClass := aDBClass2]					ifFalse: 						[aDBClass  = aDBClass2  							ifFalse: 								["Two different defintions we cannot reuse."								aDBClass := nil								]						]				].			aDBClass isNil 				ifTrue: [aDBClass := traceClasses detect: 							[:dbClass | dbClass name = each name asString] ifNone: [nil]						].			newDBMetaclasses add: (ClassRecord recordFor: each trace: aDBClass)			].	self addDBClasses: newDBClasses andMetaclasses: newDBMetaclasses</body><body package="Store-DB-Pundles" selector="addClasses:mergeData:">addClasses: aCollectionOfClasses mergeData: mergeData 	"This method assumes that the corresponding metaclasses 	should be part of the package too."	| classList metaClasses |	classList := SystemUtils sortForLoading: aCollectionOfClasses.	metaClasses := classList collect: [ :each | each class ].	mergeData isNil		ifTrue: [ self addClasses: classList andMetaclasses: metaClasses ]		ifFalse: [ self addClasses: classList andMetaclasses: metaClasses mergeData: mergeData ]</body><body package="Store-DB-Pundles" selector="addData:">addData: aCollectionOfData 	"Convert a collection of method descriptors into a collection of DB data. 	Install the new collection in the DB. 	Note that if the trace is not null then check the data from the trace and 	create a new record only for a datum that is different then the one in 	database."	| newDBData traceData |	traceData := self hasTrace ifTrue: [ self getTrace data ] ifFalse: [ #() ].	newDBData := aCollectionOfData collect: 		[ :dd |  | owner dataKey aTraceDatum |		owner := dd owner.		dataKey := dd dataKey asString.		aTraceDatum := traceData detect: 				[:dbDatum | dbDatum name = dataKey and: 						[dbDatum environmentString = owner absoluteName ]				] ifNone: [ nil ].		IncrementNotification raiseSignal.		DataElement recordFromDescriptor: dd trace: aTraceDatum package: self		].	self addDBData: newDBData.	^newDBData</body><body package="Store-DB-Pundles" selector="addDBClasses:andMetaclasses:">addDBClasses: aCollectionOfDBClasses andMetaclasses: aCollectionOfDBMetaclasses 	"Create new entries in a table which binds classes to packages."	| aClass index |	index := classes size + 1.	aCollectionOfDBClasses with: aCollectionOfDBMetaclasses do: 		[ :each :meta | 		aClass := (PkgClasses new) 					packageRef: self primaryKey; 					classRef: each primaryKey; 					metaclassRef: meta primaryKey;					definitionOrder: index.		index := index + 1.		aClass install.		]</body><body package="Store-DB-Pundles" selector="addDBData:">addDBData: aCollectionOfDBData 	"Create new entries in a table which binds data to packages."	aCollectionOfDBData do: [:each | self addNewDBDatum: each]</body><body package="Store-DB-Pundles" selector="addDBMethods:">addDBMethods: aCollectionOfDBMethods 	"Create new entries in a table which binds methods to packages."	aCollectionOfDBMethods do: [:each | self addNewDBMethod: each]</body><body package="Store-DB-Pundles" selector="addDBNameSpaces:">addDBNameSpaces: aCollectionOfDBNameSpaces 	"Create new entries in a table which binds namespaces to packages."	| namespace index |	index := classes size + 1.	aCollectionOfDBNameSpaces do: 		[ :each | 		( namespace := PkgNameSpaces new ) 			packageRef: self primaryKey; 			nameSpaceRef: each primaryKey; 			definitionOrder: index.		index := index + 1.		namespace install		]</body><body package="Store-DB-Pundles" selector="addMethods:">addMethods: aCollectionOfMethods 	"Convert a collection of method descriptors into a collection of DB methods. 	Install the new collection in the DB. 	Note that if the trace is not null then check the methods from the trace and 	create a new record only for a method that is different then the one in 	database."	| newDBMethods traceMethods |	traceMethods := self hasTrace ifTrue: [ self getTrace methods ] ifFalse: [ #() ].	newDBMethods := aCollectionOfMethods collect: 		[ :md |  | selector cls aTraceMethod  |			selector := md selector asString.		cls := md implementingClass.		aTraceMethod := traceMethods detect: 			[ :dbMethod | dbMethod name = selector and: [ dbMethod className = cls name asString ] ] 				ifNone: [ nil ].		IncrementNotification raiseSignal.		Method	recordFromDescription: md	trace: aTraceMethod package: self.		].	self addDBMethods: newDBMethods.	^newDBMethods</body><body package="Store-DB-Pundles" selector="addNameSpaces:">addNameSpaces: aCollectionOfNameSpaces 	self addNameSpaces: aCollectionOfNameSpaces mergeData: nil</body><body package="Store-DB-Pundles" selector="addNameSpaces:mergeData:">addNameSpaces: aCollectionOfNameSpaces  mergeData: mergeData	"Convert collection of classes into collection of DB namespaces and add 	them to the receiver. 	Note that if the trace is not null then check the classes from the trace and 	create new records only for classes that are different."	| nameSpaceList newDBNameSpaces traceNameSpaces |	traceNameSpaces := self hasTrace ifTrue: [self getTrace nameSpaces] ifFalse: [#()].	nameSpaceList := SystemUtils sortForLoading: aCollectionOfNameSpaces.	newDBNameSpaces := OrderedCollection new.	nameSpaceList do: 		[:each |    | aDBNameSpace |		mergeData == nil			ifFalse: 				[ aDBNameSpace := mergeData resolutionRecordForTag: 						(NameSpaceTag newNameSpace: each) packageNamed: self name. 				].		aDBNameSpace == nil			ifTrue: 				[  aDBNameSpace := traceNameSpaces detect: 					[ :dbNs | dbNs absoluteName = each absoluteName ] ifNone: [nil].				].		newDBNameSpaces add: 			( NameSpaceRecord recordFor: each trace: aDBNameSpace ).		].	self addDBNameSpaces: newDBNameSpaces</body><body package="Store-DB-Pundles" selector="addNewDBDatum:">addNewDBDatum: aDBDatum	"Create new entry in a table which binds data to packages."	Data new		packageRef: self primaryKey; 		dataRef: aDBDatum primaryKey;		install</body><body package="Store-DB-Pundles" selector="addNewDBMethod:">addNewDBMethod: aDBMethod	"Create new entry in a table which binds methods to packages."	| baby |	baby := (Methods new) packageRef: self primaryKey; methodRef: aDBMethod primaryKey.	baby install</body><body package="Store-DB-Pundles" selector="descriptionClass">descriptionClass	^PackageDescription</body><body package="Store-DB-Pundles" selector="installSqlString">installSqlString	"Column names must be String, for consistency with #columnNames"	^ self newSQL		insertColumnsValues:  #( 'primaryKey' 'name' 'timeStamp' 'version' 'userName' 'trace' 'commentID' 'propertiesID' 'parcelID' 'binFile' ).</body><body package="Store-DB-Pundles" selector="prime">prime	"Put instances of Object into slots that are not mapped into columns in the DB.	This is crucial for reading from DB since the primed slots are skipped"	super prime.	namespaces := Object new.	classes := Object new.	metaclasses := Object new.	methods := Object new.	data := Object new.	overrides := Object new.</body><body package="Store-DB-Pundles" selector="processFields">processFields	"Do any necessary data conversions following retrieval"</body><body package="Store-DB-Pundles" selector="removeDBDatum:">removeDBDatum: aDBDatum 	"Replace an entry in a table which binds methods to packages."	Data		removeDatum: aDBDatum primaryKey		inPackage: self primaryKey</body><body package="Store-DB-Pundles" selector="removeDBMethod:">removeDBMethod: aDBMethod 	"Replace an entry in a table which binds methods to packages."	Methods		removeMethod: aDBMethod primaryKey		inPackage: self primaryKey</body><body package="Store-DB-Pundles" selector="replaceDBDatum:with:">replaceDBDatum: aDBDatum with: newDBDatum	"Replace an entry in a table which binds data to packages."	Data		replaceDatum: aDBDatum primaryKey		with: newDBDatum primaryKey		inPackage: self primaryKey</body><body package="Store-DB-Pundles" selector="replaceDBMethod:with:">replaceDBMethod: aDBMethod with: newDBMethod	"Replace an entry in a table which binds methods to packages."	Methods		replaceMethod: aDBMethod primaryKey		with: newDBMethod primaryKey		inPackage: self primaryKey</body><body package="Store-DB-Pundles" selector="unprime">unprime	"Remove the effect of priming (see the prime method)."	super unprime.		namespaces := nil.	classes := nil.	metaclasses := nil.	methods := nil.	data := nil.	overrides := nil.</body></methods><methods><class-id>Store.Package</class-id> <category>comparing</category><body package="Store-DB-Pundles" selector="sameAsImThing:">sameAsImThing: aPkg	^false</body></methods><methods><class-id>Store.Package</class-id> <category>db repair</category><body package="Store-DB-Pundles" selector="duplicateMethodReport">duplicateMethodReport	| stream |	stream := ( String new: 1000 ) writeStream.	self duplicateMethodReportOn: stream.	^stream contents.</body><body package="Store-DB-Pundles" selector="duplicateMethodReportOn:">duplicateMethodReportOn: aStream	| dups |	( dups := self duplicateMethods ) size == 0		ifTrue: [ ^self ].	aStream nextPutAll: self name, self versionString; cr.	dups do:		[ :dup |		dup do:			[ : m | 			aStream tab; 				nextPutAll: m printString;				nextPutAll: m versionString;   				cr 			].		aStream cr.		].	self parentRecord duplicateMethodReportOn: aStream.</body><body package="Store-DB-Pundles" selector="duplicateMethods">duplicateMethods	"Check the receiver for duplicate published methods. 	Answer a dictionary of #'Class selector' -&gt; duplicate methods"	| dups |	dups := IdentityDictionary new.	self methods do:	[ :m | 	( methods contains: [ :mm | m ~~ mm and: [ m comparesTo: mm ] ] )		ifTrue: [ ( dups at: m displayString asSymbol ifAbsentPut: [ OrderedCollection new ] ) add: m ]	].	^dups</body><body package="Store-DB-Pundles" selector="duplicateStaticReport">duplicateStaticReport	| stream |	stream := ( String new: 1000 ) writeStream.	self duplicateStaticReportOn: stream.	^stream contents.</body><body package="Store-DB-Pundles" selector="duplicateStaticReportOn:">duplicateStaticReportOn: aStream	| dups |	( dups := self duplicateStatics ) size == 0		ifTrue: [ ^self ].	aStream nextPutAll: self name, self versionString; cr.	dups do:		[ :dup |		dup do:			[ : m | 			aStream tab; 				nextPutAll: m printString;				nextPutAll: m versionString;   				cr 			].		aStream cr.		].	self parentRecord duplicateStaticReportOn: aStream.</body><body package="Store-DB-Pundles" selector="duplicateStatics">duplicateStatics	"Check the receiver for duplicate published statics. 	Answer a dictionary of #'Owner.datakey' -&gt; duplicate methods"	| dups |	dups := IdentityDictionary new.	self data do:	[ :m | 	( data contains: [ :mm | m ~~ mm and: [ m comparesTo: mm ] ] )		ifTrue: [ ( dups at: m displayString asSymbol ifAbsentPut: [ OrderedCollection new ] ) add: m ]	].	^dups</body><body package="Store-DB-Pundles" selector="repairDuplicateMethods:">repairDuplicateMethods: duplicates	duplicates do:		[ :dups | TabApplicationSystemBrowser editPackage: self methodOrStatics: dups ].</body><body package="Store-DB-Pundles" selector="repairDuplicateStatics:">repairDuplicateStatics: duplicates	duplicates do:		[ :dups | TabApplicationSystemBrowser editPackage: self methodOrStatics: dups ].</body><body package="Store-DB-Pundles" selector="searchAndDestroyDuplicateMethods">searchAndDestroyDuplicateMethods	| dups |	( dups := self duplicateMethods ) size == 0		ifTrue: [ ^Dialog warn: 'No duplicates found.' ].	self repairDuplicateMethods: dups.</body><body package="Store-DB-Pundles" selector="searchAndDestroyDuplicateStatics">searchAndDestroyDuplicateStatics	| dups |	( dups := self duplicateStatics ) size == 0		ifTrue: [ ^Dialog warn: 'No duplicates found.' ].	self repairDuplicateStatics: dups.</body></methods><methods><class-id>Store.Package</class-id> <category>accessing</category><body package="Store-DB-Pundles" selector="actualClassInPackageNamed:">actualClassInPackageNamed: aString 	"Answer an instance class from package or nil if 	the package does not contain definition of the class. "	^( self classes 		detect: [ :dbClass | dbClass name = aString ] ifNone: [ ^nil ] 	) myClass</body><body package="Store-DB-Pundles" selector="allClasses">allClasses	"Answer a collection of classes. The collection contains classes that are defined in the package and 	pseudo classes for which only methods or data are defined"	| defined extended mc |	Cursor wait		showWhile: 			[defined := self classes collect: [:class | class absoluteName].			extended := (self methods collect: [:method | method fullClassName]) asSet.			extended addAll: ( ( self data select: [ :elem | elem isInClass ] )						collect: [ :elem | elem environmentString ] ).			mc := extended asOrderedCollection select: [:mName | mName namesMetaClass ].			extended := extended asOrderedCollection reject: [:mName | mName namesMetaClass ]. 			mc do: 				[ :c | ( extended includes: c asClassNameOnly ) 							ifFalse: [ extended add: c asClassNameOnly ].				].			defined do: [:each | extended remove: each ifAbsent: []].			extended := extended collect: [:cName| PseudoClass newNamed: cName]].	^( self classes  , extended ).</body><body package="Store-DB-Pundles" selector="allMetaclasses">allMetaclasses	"Answer a collection of metaclasses. The collection contains metaclasses that are defined 	in the package and metaclasses for which methods are defined"	| defined extended |	Cursor wait		showWhile: 			[ defined := self metaclasses collect: [:class | class absoluteName, ' class'].			extended := (self methods collect: [:method | method className]) asSet.			extended := extended select: [:mName | mName includes: $ ].			defined do: [:each | extended remove: each ifAbsent: []].			extended := extended collect: [:cName| PseudoClass newNamed: cName]].	^self metaclasses , extended asOrderedCollection.</body><body package="Store-DB-Pundles" selector="allNameSpaces">allNameSpaces	"Answer a collection of namespaces. The collection contains 	namespaces that are defined in the package and pseudo 	namespaces for which only data is defined"	| defined extended |	Cursor wait		showWhile: 			[defined := self nameSpaces collect: [: ns | ns absoluteName].			extended :=  ( ( self data select: [ :elem | elem isInNameSpace ] ) 							collect: [:elem | elem nameSpaceName] ) asSet.			defined do: [:each | extended remove: each ifAbsent: [] ].			extended := extended asOrderedCollection.			extended := extended collect: [:ns | PseudoNameSpace newNamed: ns]].	^self nameSpaces, extended</body><body package="Store-DB-Pundles" selector="asDBDescription">asDBDescription	^self class partClass new		packageRef: self primaryKey		yourself</body><body package="Store-DB-Pundles" selector="binFile">binFile	^binFile</body><body package="Store-DB-Pundles" selector="binFile:">binFile: aString	binFile := aString</body><body package="Store-DB-Pundles" selector="classes">classes	| dbClasses |	classes isNil 		ifTrue: 		[ [ 			  dbClasses := self broker getAnswerFromSession: [ PkgClassesView classesSession ]			  bindInput: [:session | session bindInput primaryKey: self primaryKey].			  classes := ( dbClasses collect: 					[ :each | ( ClassRecord fromView: each ) package: self ] ) asOrderedCollection.		   ] 		   on: self errorSignals 		   do:	[:ex |  					dbClasses := OrderedCollection new.					^dbClasses				].		].	^classes</body><body package="Store-DB-Pundles" selector="classes:">classes: aCollection	classes := aCollection</body><body package="Store-DB-Pundles" selector="classesDefinedInPackage">classesDefinedInPackage	^self classes</body><body package="Store-DB-Pundles" selector="classesWithSource">classesWithSource	| dbClasses |	classes == nil 		ifFalse: [ ^classes].		"if already there.... source may be there too." 	[ dbClasses := PkgClassesAndSourcesView recordsWithSourcesIn: self ]		on: self  errorSignals do: [ :ex |  ^OrderedCollection new ].	^classes := dbClasses.</body><body package="Store-DB-Pundles" selector="classInPackageNamed:">classInPackageNamed: aString 	"Answer a class from package or nil if 	the package does not contain definition of the class. 	aString is either a class name or a class name followed by ' class'. 	Answer the class or metaclass it names."	^aString namesMetaClass		ifTrue: [self metaclasses detect: [:dbClass | dbClass name = aString]				ifNone: [nil]]		ifFalse: [self classes detect: [:dbClass | dbClass name = aString]				ifNone: [nil]]</body><body package="Store-DB-Pundles" selector="classInPackageNamed:meta:">classInPackageNamed: aString meta: aBoolean	"Answer a class or metaclass from package or nil if the package 	does not contain a definition of the class. "	^( aBoolean 			ifTrue: [ self metaclasses ] 			ifFalse: [ self classes ] 	) detect: [ :dbClass | dbClass absoluteName = aString ] ifNone: [ nil ]</body><body package="Store-DB-Pundles" selector="componentType">componentType	"Answer a symbol representing the class of the receiver."	^#package</body><body package="Store-DB-Pundles" selector="data">data	| dbData |	data == nil ifFalse: [ ^data ].	[ dbData := self broker getAnswerFromSession: [ DataView dataSession ]						bindInput: [:session | session bindInput primaryKey: self primaryKey].	dbData := dbData collect: [:each | ( DataElement fromView: each ) package: self ].	data := dbData asSortedCollection: [:x :y | x name &lt; y name]	] 	on: self  errorSignals 	do: 	[:ex | 			dbData := OrderedCollection new.			^dbData		].	^data</body><body package="Store-DB-Pundles" selector="data:">data: aCollection	data := aCollection</body><body package="Store-DB-Pundles" selector="dataForNamed:">dataForNamed: aFullName 	"Answer a collection of data belonging to the class or namespace aFullName."	^self data select: [ :datum | datum environmentString = aFullName ]. "	^data notNil		ifTrue: [ self data select: [ :datum | datum environmentString = aFullName ] ]		ifFalse: 			[ | inp coll |			inp := DataView new.			inp primaryKey: self primaryKey; fullName: aFullName.			coll := inp dataForNameSpace.			coll asSortedCollection: [ :x :y | x name &lt; y name ]			]"</body><body package="Store-DB-Pundles" selector="dataForNamed:andProtocol:">dataForNamed: aFullName andProtocol: aSymbol	"Answer a collection of data."	^( self dataForNamed: aFullName ) select:		[ : datum | datum protocolName asSymbol = aSymbol asSymbol ].</body><body package="Store-DB-Pundles" selector="dataProtocolsForNamed:">dataProtocolsForNamed: aName 	^( ( self dataForNamed: aName )			collect: [ :d | d protocolName asSymbol ]	 ) asSet asSortedCollection." if no data.....?????			[| inp |			inp := TT_DataView new.			inp primaryKey: self primaryKey; nameSpaceName: aString.			^inp protocols]"</body><body package="Store-DB-Pundles" selector="dataWithSource">dataWithSource	| dbData |	data == nil 		ifFalse: [ ^data].		"if already there.... source may be there too." 	[ dbData := DataAndSourcesView recordsWithSourcesIn: self ]		on: self  errorSignals do: [ :ex |  ^OrderedCollection new ].	^data := dbData.</body><body package="Store-DB-Pundles" selector="datum:forNamed:">datum: dataKey forNamed: aFullName	"Answer a datum with 'dataKey' defined in the namespace 	named aFullName."	^data notNil		ifTrue: [self data 			detect: [:datum | datum environmentString = aFullName 								and: [datum dataKey = dataKey]]				ifNone: [nil]]		ifFalse: 			[DataView datumWithKey: dataKey asString					ownerName: aFullName					package: self primaryKey]</body><body package="Store-DB-Pundles" selector="datum:forNameSpaceNamed:">datum: dataKey forNameSpaceNamed: aFullName	"Answer a datum with 'dataKey' defined in the namespace 	named aFullName."	^data notNil		ifTrue: [self data 			detect: [:datum | datum fullName = aFullName 								and: [datum dataKey = dataKey]]				ifNone: [nil]]		ifFalse: 			[DataView datumWithKey: dataKey asString					ownerName: aFullName					package: self primaryKey]</body><body package="Store-DB-Pundles" selector="datum:forOwnerNamed:">datum: dataKey forOwnerNamed: aFullName	"Answer a datum with 'dataKey' defined in the namespace 	named aFullName."	^data notNil		ifTrue: 			[ self data detect: 				[ :datum | datum environmentString = aFullName and: [ datum dataKey = dataKey ] ] 					ifNone: [ nil ]			]		ifFalse: 			[ DataView datumWithKey: dataKey asString				ownerName: aFullName				package: self primaryKey			]</body><body package="Store-DB-Pundles" selector="flushCashes">flushCashes	classes := nil.	metaclasses := nil.	methods := nil.	data := nil</body><body package="Store-DB-Pundles" selector="getImagePundle">getImagePundle	"Check if there if already loaded versions of a package and answer it"	^Registry packageNamed: self name.</body><body package="Store-DB-Pundles" selector="includesClassNamed:">includesClassNamed: aName 	| className |	className := aName asClassNameOnly.	^( self classes anySatisfy: [ :class | class absoluteName = className ] )</body><body package="Store-DB-Pundles" selector="includesDefinitionOf:">includesDefinitionOf: aName  	"Answer wheter the receiver contains something represented by	aName . Note that only defined NameSpace/Classes are saved." 	^( self includesClassNamed: aName ) or: [ self includesNameSpaceNamed: aName ]</body><body package="Store-DB-Pundles" selector="includesNameSpaceNamed:">includesNameSpaceNamed: aName 	^self nameSpaces anySatisfy: [:ns |  ns absoluteName = aName]</body><body package="Store-DB-Pundles" selector="leafItems">leafItems	"I'm a leaf item."	^Array with: self</body><body package="Store-DB-Pundles" selector="metaclasses">metaclasses 	| dbClasses |	metaclasses isNil ifTrue: 		[			[ dbClasses := self broker getAnswerFromSession: [PkgMetaclassesView metaclassesSession ]			bindInput: [:session | session bindInput primaryKey: self primaryKey ].			metaclasses := ( dbClasses collect: [ :each | ( ClassRecord fromView: each ) package: self ] ) asOrderedCollection.			] 			on: self  errorSignals 			do: 	[ :ex | 					dbClasses := OrderedCollection new.					^dbClasses				]		].	^metaclasses</body><body package="Store-DB-Pundles" selector="metaclasses:">metaclasses: aCollection	metaclasses := aCollection</body><body package="Store-DB-Pundles" selector="metaclassesDefinedInPackage">metaclassesDefinedInPackage	^self metaclasses</body><body package="Store-DB-Pundles" selector="metaclassNamed:">metaclassNamed: aString	^self metaclasses detect: [:dbClass| dbClass name = aString] ifNone: [nil]</body><body package="Store-DB-Pundles" selector="method:forClassNamed:meta:">method: aSelector forClassNamed: aClassName meta: isMeta 	"Answer a method with selector aSelector defined in the class 	named aClassName."	| cName |	cName := ( isMeta and: [ aClassName namesMetaClass not ] )				ifTrue: [aClassName , ' class' ]				ifFalse: [ aClassName ].	^methods notNil		ifTrue: 			[ self methods detect: 				[ :method | method classNameWithMeta = cName and: [ method selector = aSelector ] ]						ifNone: [ nil ]			]		ifFalse: 			[MethodsView methodNamed: aSelector asString					class: cName					package: self primaryKey]</body><body package="Store-DB-Pundles" selector="methods">methods	| dbMethods |	methods == nil ifFalse: [ ^methods]. 	[ dbMethods := self broker 						getAnswerFromSession: [ MethodsView methodsSession ]						bindInput: [ :session | session bindInput primaryKey: self primaryKey].	methods := dbMethods collect: [ :each | Method fromView: each ].	] 	on: self  errorSignals 	do: 	[ :ex | 			dbMethods := OrderedCollection new.			^dbMethods		].	^methods</body><body package="Store-DB-Pundles" selector="methods:">methods: aCollection	methods := aCollection</body><body package="Store-DB-Pundles" selector="methodsForClass:">methodsForClass: aClass	| aClassName |	aClassName := aClass isMeta		ifTrue: [aClass absoluteName, ' class'] ifFalse: [ aClass absoluteName ].	^self methodsForClassNamed: aClassName.</body><body package="Store-DB-Pundles" selector="methodsForClass:andProtocol:">methodsForClass: aClassName andProtocol: aProtocolName 	"Answer a collection of method names."	| pname |	pname := aProtocolName asString.	^methods notNil		ifTrue: 			[ self methods select: 				[ :method | 				method className = aClassName and: [ method protocolName = pname ]				]			]		ifFalse: 			[ | inp coll|			inp := MethodsView new.			inp primaryKey: self primaryKey; className: aClassName; protocolName: pname.			coll := inp methodsForClassAndProtocol.			coll asSortedCollection: [:x :y | x name &lt; y name]			]</body><body package="Store-DB-Pundles" selector="methodsForClassNamed:">methodsForClassNamed: aClassName 	"Answer a collection of methods."	^methods notNil		ifTrue: [self methods select: [:method | method className = aClassName]]		ifFalse: 			[| inp coll |			inp := MethodsView new.			inp primaryKey: self primaryKey; className: aClassName.			coll := inp methodsForClass.			coll asSortedCollection: [:x :y | x name &lt; y name]]</body><body package="Store-DB-Pundles" selector="methodsForClassNamed:andProtocol:meta:">methodsForClassNamed: aClassName andProtocol: aProtocolName meta: isMeta	^self 		methodsForClass: (isMeta ifTrue: [aClassName, ' class'] ifFalse: [aClassName]) 		andProtocol: aProtocolName</body><body package="Store-DB-Pundles" selector="methodsForClassNamed:meta:">methodsForClassNamed: aClassName meta: isMeta	"Answer a collection of methods."	| cname | 	cname := isMeta		ifTrue: [ aClassName, ' class'] 		ifFalse: [ aClassName ].	^methods notNil		ifTrue: [self methods select: [:method | method className = cname]]		ifFalse: 			[| inp coll |			inp := MethodsView new.			inp primaryKey: self primaryKey; className: cname.			coll := inp methodsForClass.			coll asSortedCollection: [:x :y | x name &lt; y name]]</body><body package="Store-DB-Pundles" selector="methodsWithSource">methodsWithSource	| dbMethods |	methods == nil 		ifFalse: [ ^methods].		"if already there.... source may be there too." 	[ dbMethods := MethodsAndSourcesView recordsWithSourcesIn: self ]		on: self  errorSignals do: [ :ex |  ^OrderedCollection new ].	^methods := dbMethods.</body><body package="Store-DB-Pundles" selector="nameSpaceInPackageNamed:">nameSpaceInPackageNamed: aName 	^self nameSpaces		detect: [ :dbNS | dbNS absoluteName = aName ] ifNone: [ nil ]</body><body package="Store-DB-Pundles" selector="nameSpaces">nameSpaces	| dbNamespaces |	namespaces isNil 		ifTrue: 		[	[ 			  dbNamespaces := self broker getAnswerFromSession: [ PkgNameSpacesView nameSpacesSession ]			  bindInput: [:session | session bindInput primaryKey: self primaryKey].			  namespaces := ( dbNamespaces collect: [:each | ( NameSpaceRecord fromView: each ) package: self ] ) asOrderedCollection.			] 			on: self  errorSignals 			do: 	[:ex | 					dbNamespaces := OrderedCollection new.					^dbNamespaces				]		].	^namespaces</body><body package="Store-DB-Pundles" selector="nameSpaces:">nameSpaces: aCollection	namespaces := aCollection</body><body package="Store-DB-Pundles" selector="nameSpacesDefinedInPackage">nameSpacesDefinedInPackage	^self nameSpaces</body><body package="Store-DB-Pundles" selector="nameSpacesWithSource">nameSpacesWithSource	| dbNameSpaces |	namespaces == nil 		ifFalse: [ ^namespaces].		"if already there.... source may be there too." 	[ dbNameSpaces := PkgNameSpacesAndSourcesView recordsWithSourcesIn: self ]		on: self  errorSignals do: [ :ex |  ^OrderedCollection new ].	^namespaces := dbNameSpaces.</body><body package="Store-DB-Pundles" selector="parcelID">parcelID	^parcelID</body><body package="Store-DB-Pundles" selector="parcelID:">parcelID: aNumber	parcelID := aNumber</body><body package="Store-DB-Pundles" selector="protocolsForClass:">protocolsForClass: aString 	"Answer a collection of protocol names."	| mtds |	methods notNil		ifTrue: 			[mtds := self methods select: [:method | method className = aString].			^(mtds collect: [:method | method protocolName asSymbol]) asSet asSortedCollection]		ifFalse: 			[| inp |			inp := MethodsView new.			inp primaryKey: self primaryKey; className: aString.			^inp protocols]</body><body package="Store-DB-Pundles" selector="protocolsForClassNamed:meta:">protocolsForClassNamed: aClassName meta: isMeta	^self protocolsForClass: (isMeta ifTrue: [aClassName, ' class'] ifFalse: [aClassName])</body><body package="Store-DB-Pundles" selector="protocolsForDataIn:">protocolsForDataIn: anObject	^( ( self dataForNamed: anObject absoluteName )			collect: [ :d | d protocolName asSymbol ]	 ) asSet asSortedCollection.</body><body package="Store-DB-Pundles" selector="pundleChangesClass">pundleChangesClass	^PackageChanges</body><body package="Store-DB-Pundles" selector="sourceForTag:">sourceForTag: aTag 	"Answer the source code in this package corresponding to 'aTag' 	or nil if not there."	| rec |	rec := self recordForTag: aTag.	^rec textRepresentationForTag: aTag</body><body package="Store-UI" selector="toolListIcon">toolListIcon	^PackageModel packageIcon</body></methods><methods><class-id>Store.Package class</class-id> <category>private-utilities</category><body package="Store-DB-Pundles" selector="cachedItemFor:">cachedItemFor: aPundle 	"Answer the cached item if there is one. 	Put item in the cache otherwise. 	Currently only packages are cached."	| pkg cached |	cached := Cache at: aPundle primaryKey ifAbsent: [nil].	pkg := (cached notNil and: [cached class == self])				ifTrue: [cached]				ifFalse: 					["Cache at: aPundle primaryKey put: aPundle."					aPundle].	^pkg</body><body package="Store-DB-Pundles" selector="nameSpaceOrder:">nameSpaceOrder: dbNameSpaces	"Sort all of the namespace in the list into a collection where no namespace is preceded by 	it's environment.	I cannot use method in SystemUtils since the classes are not in the image"	| oc new names |	oc := dbNameSpaces copy.	new := OrderedCollection new.	[ oc isEmpty ] whileFalse: 		[		names := oc  collect: [ :each | each absoluteName ].		oc copy do: 			[ :each |			( names includes: each environmentString ) 				ifFalse: [ new add: each.  oc remove: each ]			]	].	^new</body><body package="Store-DB-Pundles" selector="objectionsToPublishing:atBlessing:">objectionsToPublishing: imPkg atBlessing: level 	"Answer true if there are no bojections to publishing 	the imPkg at blessing level 'level'"	^Policies publishPolicy objectionsToPublishingPackage: imPkg atBlessingLevel: level.</body><body package="Store-DB-Pundles" selector="sortForLoading:">sortForLoading: aCollection	"Sort aCollection of classes and namespaces in environment and superclass order."	| sorted |	sorted := self nameSpaceOrder: ( aCollection select: [ :obj | obj isForNameSpace ] ).	sorted addAll: ( self superclassOrder: ( aCollection select: [ :obj | obj isForClass] ) ).	^sorted.</body><body package="Store-DB-Pundles" selector="superclassOrder:">superclassOrder: dbClasses	"Sort all of the classes in the list into a collection where no class is preceded by a subclass or 	by its metaclass. I cannot use method in SystemUtils since the classes are not in the image"	| oc newDBClasses classNames |	oc := dbClasses copy.	newDBClasses := OrderedCollection new.	[ oc isEmpty ] whileFalse: 		[		classNames := oc  collect: [ :each | each absoluteName ].		oc copy do: 			[ :each |			( each isPseudo not and: [  classNames includes: each superclass ] ) 				ifFalse: [ newDBClasses add: each.  oc remove: each ]			]	].	^newDBClasses</body></methods><methods><class-id>Store.Package class</class-id> <category>instance creation</category><body package="Store-DB-Pundles" selector="fromPackage:">fromPackage: aPackage	"Create a new instance and install in DB. "	"dialog calls back to: #publishPackage:userData:"	PublishPackageDialog publishPackage: aPackage</body><body package="Store-DB-Pundles" selector="newFrom:userData:">newFrom: aPackage userData: userData	"Create a new instance of a package and install it in DB.	Version checking and policy checking is done BEFORE this message	is sent. Can parcel binary, but leave regular parcel to the owning bundle."	| trace newDBPackage res newDBMethods  transaction mergeData dbParcel count binSave propRecords | 	mergeData := userData at: #mergeData ifAbsent: [nil].	( binSave := ( userData at: #binarySave ifAbsent: [ false ] ) value )		ifFalse:			[ "since parcels send #preSave: so send only when no parcel" 			( SystemUtils sortForLoading: aPackage allDefinedClasses ) do:				[ :cls | cls preSave: aPackage ].			].	newDBPackage := self newFrom: aPackage.	trace := newDBPackage parentRecord.	newDBPackage version: (userData at: #version).	binSave		ifTrue: 			[ aPackage parcelOutToDb: ( dbParcel := self parcelRecordClass from: aPackage ).			dbParcel installInDatabase.			newDBPackage parcelID: dbParcel primaryKey.			].	transaction := 		[ newDBPackage install.		newDBPackage addClasses: aPackage packageClasses mergeData: mergeData.		newDBPackage addNameSpaces: aPackage packageNameSpaces mergeData: mergeData.		self shouldSavePropertyRecords 					ifTrue: [ propRecords := self propertyRecordsFromPundle: aPackage.							"Insert the property records and/or links into the DB."							newDBPackage addProperties: propRecords].		self needsMoreWork. "BELOW IS ASSUMMING THAT IF THERE IS NO TRACE"							"IT IS A PackageModel."		trace isNil					ifTrue: ["If possible use differences for publishing."						newDBMethods := newDBPackage addMethods: aPackage methodsAsArray.						newDBPackage addData: aPackage dataAsArray]					ifFalse: 						[| diff |						diff := PackageDifferences with: trace with: aPackage.						newDBMethods := diff storeMethodsIntoPackage: newDBPackage using: mergeData.						diff storeDataIntoPackage: newDBPackage using: mergeData].			newDBPackage addBlessingLevel: (userData at: #blessing)  							andComment: (userData at: #comment) asString.			newDBPackage		].	count := trace == nil		ifTrue: [ aPackage itemCount ] 		ifFalse: [ aPackage changedItemCount ].	MessageNotification raiseSignal:  ( 'package &lt;1s&gt;' expandMacrosWith: newDBPackage name ).	ResetIncrementNotification signalWith: count.	res := self broker publishTransaction: transaction.	res notNil		ifTrue: 			["Sources are safe in DB"			aPackage dbTrace: newDBPackage primaryKey.			aPackage markNotModified].	^res</body><body package="Store-DB-Pundles" selector="newFrom:userData:pundleFragments:">newFrom: aPackage userData: userData pundleFragments: aCollection	^self newFrom: aPackage userData: userData</body><body package="Store-DB-Pundles" selector="publishPackage:userData:">publishPackage: aPackage userData: userDialog	"Install in DB. Rolback transaction and return nil if errors are encountered in DB."	| trace res newDBMethods verString transaction dbParcel count dbPackage binSave propRecords |	( binSave := userDialog binarySave value  )		ifFalse:			[ "since parcels send #preSave: so send only when no parcel" 			( SystemUtils sortForLoading: aPackage allDefinedClasses ) do:				[ :cls | cls preSave: aPackage ].			]. 	dbPackage := self newFrom: aPackage.	trace := dbPackage parentRecord.	( self canPublish: aPackage atBlessing: ( userDialog blessingLevel value ) )		ifFalse: [ ^nil ].	verString := Policies versionPolicy versionStringForPundle: aPackage  					initialVersion: userDialog versionString value.	verString isNil ifTrue: [ ^nil ].	dbPackage version: verString.	binSave 		ifTrue: 			[ [ aPackage parcelOutToDb: 				( dbParcel := self parcelRecordClass from: aPackage ).			dbParcel installInDatabase.			dbPackage parcelID: dbParcel primaryKey			  ] on: DbRegistry errorSignals 			    do: [ :exp | ^nil ]			].		transaction := 		[dbPackage install.		dbPackage addClasses: aPackage packageClasses.		dbPackage addNameSpaces: aPackage packageNameSpaces.		self shouldSavePropertyRecords 					ifTrue: [ propRecords := self propertyRecordsFromPundle: aPackage.							"Insert the property records and/or links into the DB."							dbPackage addProperties: propRecords].		self needsMoreWork. "BELOW IS ASSUMMING THAT IF THERE IS NO TRACE"							"IT IS A PackageModel."		trace isNil					ifTrue: ["If possible use differences for publishing."						newDBMethods := dbPackage addMethods: aPackage methodsAsArray.						dbPackage addData: aPackage dataAsArray]					ifFalse: 						[ | diff |						diff := PackageDifferences with: trace with: aPackage.						newDBMethods := diff storeMethodsIntoPackage: dbPackage.						diff storeDataIntoPackage: dbPackage].		dbPackage 			addBlessingLevel: userDialog blessingLevel value 			andComment: userDialog blessingComment value asString.		dbPackage].	count := trace == nil		ifTrue: [ aPackage itemCount ] 		ifFalse: [ aPackage changedItemCount ].	res := self broker publishTransaction: transaction showing: 'Publishing ' , dbPackage name count: count.	res notNil		ifTrue: 			[ "Sources are safe in DB."			aPackage 				dbTrace: dbPackage primaryKey;				markNotModified.			userDialog parcelSave value 				ifTrue: 					[ aPackage parcelOutTo: userDialog parcelDirectory value, '.pcl' 							sourceFileName:  userDialog parcelDirectory value, '.pst'							parcelOptions: userDialog options					].			].	^res</body></methods><methods><class-id>Store.Package class</class-id> <category>db-utilities</category><body package="Store-DB-Pundles" selector="allPackages">allPackages	"Answer a SortedCollection of TT_Packages"	"self allPackages"	^self allPackagesOrBundles</body><body package="Store-DB-Pundles" selector="allVersionsWithTrace:">allVersionsWithTrace: aTrace 	"Answer a colection of Packages"	"self allVersionsWithTrace: 458"	| pkgs |	[ pkgs := self processList:				(self broker process: 					( self newSQL						selectAll;						where;						column: #trace equalTo: aTrace  printString)				bindOutput: self newPrimed).		1 to: pkgs size do: 			[ :i | | pkg cached |			pkg := pkgs at: i.			cached := Cache at: pkg primaryKey ifAbsent: [ nil ].			cached notNil 				ifTrue: [pkgs at: i put: cached]				ifFalse: [ Cache at: pkg primaryKey put: pkg ]			].	]	on: self  errorSignals 	do: 	[:ex |  ex outer.				pkgs := self  table select: [ :each | each dbTrace = aTrace ] 		].	^pkgs asSortedCollection: [ :x :y | x primaryKey &gt; y primaryKey ]</body><body package="Store-DB-Pundles" selector="alterTablesPctincrease">alterTablesPctincrease	"Fix for databases created with 5i.2. Alter STORAGE PSTINCREASE from 0 to 1"	self dbTables do: 		[ :aClass | aClass alterTablePctincrease ]</body><body package="Store-DB-Pundles" selector="aRecordWithID:">aRecordWithID: anID 	"Check my cache first then use super method."	| rec |	rec := Cache at: anID ifAbsent: [nil].	(rec notNil and: [rec class == self])		ifFalse: 			[rec := super aRecordWithID: anID.			"rec notNil ifTrue: [Cache at: anID put: rec]"].	^rec</body><body package="Store-DB-Pundles" selector="defaultBlockFactor">defaultBlockFactor	^100</body><body package="Store-DB-Pundles" selector="knownPackages">knownPackages	"Answer a SelectionInList containing names of 	all packages stored in DB."	"self knownPackages"	^self knownPackagesOrBundles</body><body package="Store-DB-Pundles" selector="update5i2">update5i2	self broker alterTableFor: self addColumn: #parcelID.</body></methods><methods><class-id>Store.Package class</class-id> <category>private</category><body package="Store-DB-Pundles" selector="doPostLoadProcessingOn:">doPostLoadProcessingOn: dbRecords 	| recs |	recs := super doPostLoadProcessingOn: dbRecords.	1 to: recs size do: 		[ :i | | pkg cached |		pkg := recs at: i.		cached := self cachedItemFor: pkg.		recs at: i put: cached		].	^recs</body><body package="Store-DB-Pundles" selector="fromView:">fromView: aPackageView  	| aPackage |	aPackage := self new.	aPackage primaryKey: aPackageView primaryKey;			name: aPackageView name;			timeStamp: aPackageView timeStamp;			version: aPackageView version;			userName: aPackageView userName;			dbTrace: aPackageView dbTrace;			longField: aPackageView longField;			commentID: aPackageView commentID;			propertiesID: aPackageView propertiesID;			binFile: aPackageView binFile;			processFields.	^aPackage</body><body package="Store-DB-Pundles" selector="newNamed:">newNamed: aName 	"Create a record for a package. 	Put the name and the time stamp. 	Do not install the package in the database."	| newDBPackage |	newDBPackage := super newNamed: aName.	newDBPackage binFile: ''.	^newDBPackage</body></methods><methods><class-id>Store.Package class</class-id> <category>class initalization</category><body package="Store-DB-Pundles" selector="initialize">initialize	"TT_Package initialize"	self initializeCache.</body></methods><methods><class-id>Store.Package class</class-id> <category>installation</category><body package="Store-DB-Pundles" selector="columnNames">columnNames		"self columnNames"	^super columnNames		remove: 'namespaces';		remove: 'classes';		remove: 'metaclasses';		remove: 'methods';		remove: 'data';		remove: 'overrides';		yourself.</body><body package="Store-DB-Pundles" selector="fieldTypes">fieldTypes		" self fieldTypes "	^super fieldTypes		at: 'parcelID' put: #Integer;		yourself.</body><body package="Store-DB-Pundles" selector="storageParameters">storageParameters	"Answer a string describing special storage parameters for the table or nil if the default parameters are 	acceptable answer."	^'STORAGE(INITIAL 256K NEXT 256K PCTINCREASE 1) '</body></methods><methods><class-id>Store.Package class</class-id> <category>installation-pkgs</category><body package="Store-DB-Pundles" selector="allComponents">allComponents	"Answer a string containing the name of all tables and views.	Below each table name put column names."	"self allComponents"	| stream |	stream := WriteStream on: (String new: 8192).	stream nextPutAll: 'TABLES:';cr.	self printNamesOf: self dbTables on: stream.	stream cr; cr; nextPutAll: 'VIEWS:';cr.	self printNamesOf: ( self dbViews, self dbSourcesViews ) on: stream.	^stream contents</body><body package="Store-DB-Pundles" selector="createPkgTables">createPkgTables	self dbTables do: 		[ :aClass | aClass createDatabaseTable ]</body><body package="Store-DB-Pundles" selector="createPkgViews">createPkgViews	self dbViews do: 		[ :aClass | aClass createViewForClass: aClass ].	self dbSourcesViews do: 		[ :aClass | self broker createSourcesViewForClass: aClass ]</body><body package="Store-DB-Pundles" selector="dbSessions">dbSessions	"Answer an ordered collection of classes that maintain sessions in the db."	^OrderedCollection new		add: MethodsView; 		add: PkgClassesView; 		add: PkgMetaclassesView; 		add: PkgNameSpacesView; 		add: Blob; 		add: BinaryBlob; 		add: BundlesView; 		add: PackagesView; 		add: DataView;		add: MethodsAndSourcesView;		add: DataAndSourcesView;		add: PkgClassesAndSourcesView;		add: PkgNameSpacesAndSourcesView;		yourself</body><body package="Store-DB-Pundles" selector="dbSourcesViews">dbSourcesViews	"Answer an ordered collection of classes that are represented by OB views"	"Note, supplements dbViews with three way views including sources."	^OrderedCollection new		add: MethodsAndSourcesView;		add: DataAndSourcesView;		add: PkgClassesAndSourcesView;		add: PkgNameSpacesAndSourcesView;		yourself</body><body package="Store-DB-Pundles" selector="dbTables">dbTables	"Answer an ordered collection of classes that are represented by DB tables."	^OrderedCollection new		add: ClassRecord; 		add: NameSpaceRecord; 		add: Package; 		add: ParcelRecord; 		add: PkgClasses; 		add: PkgNameSpaces; 		add: Method; 		add: Methods; 		add: Blob; 		add: BinaryBlob; 		add: Blessing;		add: Bundle; 		add: Bundles; 		add: Packages;		add: DataElement; 		add: Data; 		add: DatabaseIdentifier;		add: Files;		add: FileRecord;		add: Properties;		add: PropertyRecord;		yourself</body><body package="Store-DB-Pundles" selector="dbViews">dbViews	"Answer an ordered collection of classes that are represented by OB views"	"Note, these are only the two table views. Other views are #dbSourcesViews."	^OrderedCollection new		add: MethodsView; 		add: PkgClassesView; 		add: PkgMetaclassesView; 		add: PkgNameSpacesView;		add: DataView;		add: PropertiesView;		yourself.</body><body package="Store-DB-Pundles" selector="deinstallPkgs">deinstallPkgs	"self deinstallPkgs "	Method dropMethodRetrievalIndex.	self dropPkgViews.	self dropPkgTables.	Transcript cr; show: 'Done!'</body><body package="Store-DB-Pundles" selector="dropPkgTables">dropPkgTables	self dbTables reverseDo: 		[ :aClass | aClass dropTableForClass ]</body><body package="Store-DB-Pundles" selector="dropPkgViews">dropPkgViews	( self dbViews, self dbSourcesViews ) reverseDo: 		[ :aClass | 			aClass resetSession.			aClass dropViewForClass.		]</body><body package="Store-DB-Pundles" selector="installPkgs">installPkgs	"self installPkgs "	self createPkgTables.	self createPkgViews.	Method createMethodRetrievalIndex.	Transcript cr; show: 'Done!'</body><body package="Store-DB-Pundles" selector="printNamesOf:on:">printNamesOf: aComponentList on: aStream 	"Print the names of views and all column names"	aComponentList do: 		[ :aClass | 		aStream cr; nextPutAll: 'Table: ' , (self broker tableName: aClass); cr; nextPutAll: '-----'; cr.		aClass columnNames do: 			[ :cName |  | cType |			cType := aClass fieldTypes at: cName ifAbsent: [ #String ].			aStream 				nextPutAll: (self broker columnName: cName for: aClass); tab; 				nextPutAll: cType asString; cr			]		]</body><body package="Store-DB-Pundles" selector="resetPkgViews">resetPkgViews	( self dbViews, self dbSourcesViews ) reverseDo: 		[ :aClass | aClass resetSession ]</body><body package="Store-DB-Pundles" selector="resetSessions">resetSessions	"self resetSessions"	self dbSessions reverseDo: 		[ :aClass | aClass resetSession ].	self resetPkgViews</body></methods><methods><class-id>Store.Package class</class-id> <category>constants</category><body package="Store-DB-Pundles" selector="imageClass">imageClass	^PackageModel</body><body package="Store-DB-Pundles" selector="parcelRecordClass">parcelRecordClass	"Answer a class which is used when publishing binary to db."	^ParcelRecord</body><body package="Store-DB-Pundles" selector="partClass">partClass	^Packages</body></methods><methods><class-id>Store.PseudoPseudo</class-id> <category>testing</category><body package="Store-DB-BaseObjects" selector="isExtension">isExtension	^true</body><body package="Store-DB-BaseObjects" selector="isPseudo">isPseudo	^true.</body></methods><methods><class-id>Store.PseudoPseudo</class-id> <category>comparing</category><body package="Store-DB-BaseObjects" selector="&lt;=">&lt;= aDescriptor	^self absoluteName &lt;= aDescriptor absoluteName</body><body package="Store-DB-BaseObjects" selector="=">= aThing	^self comparesTo: aThing</body><body package="Store-DB-BaseObjects" selector="sameAsDBThing:">sameAsDBThing: aThing	^aThing isExtension and: [aThing name = self name]</body><body package="Store-DB-BaseObjects" selector="sameAsImThing:">sameAsImThing: aThing	^aThing isExtension and: [self name = aThing name]</body></methods><methods><class-id>Store.PseudoPseudo</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="absoluteName">absoluteName	^name</body><body package="Store-DB-BaseObjects" selector="absoluteSymbol">absoluteSymbol	^self absoluteName asSymbol</body><body package="Store-DB-BaseObjects" selector="actual">actual	^nil		"don't exist"</body><body package="Store-DB-BaseObjects" selector="comment">comment		^'Not defined in this package'</body><body package="Store-DB-BaseObjects" selector="definition">definition		^'Not defined in this package'</body><body package="Store-DB-BaseObjects" selector="definitionAndComment">definitionAndComment		^'Not defined in this package'</body><body package="Store-DB-BaseObjects" selector="fullName">fullName	^name</body><body package="Store-DB-BaseObjects" selector="symbol">symbol	^self absoluteSymbol</body><body package="Store-DB-BaseObjects" selector="timeStampString">timeStampString		^'Not defined in this package'</body><body package="Store-DB-BaseObjects" selector="version">version	^'--'</body><body package="Store-DB-BaseObjects" selector="xmlDefinition">xmlDefinition		^'&lt;do-it&gt;"Not defined in this package"&lt;/do-it&gt;'</body></methods><methods><class-id>Store.PseudoPseudo</class-id> <category>printing</category><body package="Store-DB-BaseObjects" selector="displayString">displayString	^SystemUtils convertAbsoluteNameToFull: self absoluteName</body><body package="Store-DB-BaseObjects" selector="storeOn:">storeOn: aStream	"Append to the argument aStream the global names of the receiver."	aStream nextPutAll: self fullName</body><body package="Store-DB-BaseObjects" selector="versionString">versionString	^''</body></methods><methods><class-id>Store.PseudoPseudo</class-id> <category>browser support</category><body package="Store-DB-BaseObjects" selector="binding">binding		"No such thing"	^self</body><body package="Store-DB-BaseObjects" selector="containingPackages">containingPackages	^#( )</body><body package="Store-DB-BaseObjects" selector="isForClass">isForClass			^false</body><body package="Store-DB-BaseObjects" selector="isForNameSpace">isForNameSpace			^false</body><body package="Store-DB-BaseObjects" selector="valueOrDo:">valueOrDo: aBlock	"Does not exist in the image (ie. has no value), so execute the block."	^aBlock value</body></methods><methods><class-id>Store.PseudoPseudo class</class-id> <category>instance creation</category><body package="Store-DB-BaseObjects" selector="newNamed:">newNamed: aName 	^(self new) name: aName; yourself</body></methods><methods><class-id>Store.PseudoNameSpace</class-id> <category>browser support</category><body package="Store-DB-Records" selector="isForNameSpace">isForNameSpace	^true</body></methods><methods><class-id>Store.PseudoNameSpace</class-id> <category>comparing</category><body package="Store-DB-Records" selector="comparesTo:">comparesTo: anObject		"Answer true if anObject could be another version of the receiver."	( self objectIsForSelf: anObject ) ifFalse: [ ^false ].	^name = anObject absoluteName.</body><body package="Store-DB-Records" selector="objectIsForSelf:">objectIsForSelf: anObject		"Answer true if anObject represents the same kind of thing as the reciever."	^anObject isForNameSpace</body></methods><methods><class-id>Store.PseudoNameSpace</class-id> <category>accessing</category><body package="Store-DB-Records" selector="environmentString">environmentString	| path |	path := (GeneralBindingReference parseString: name).	path removeLast.	^path fold: [:a :b | a, '.', b]</body><body package="Store-DB-Records" selector="fileOutObjectType">fileOutObjectType	^#nameSpace</body><body package="Store-DB-Records" selector="name">name	^( name tokensBasedOn: $.) last</body></methods><methods><class-id>Store.PseudoClass</class-id> <category>testing</category><body package="Store-DB-Records" selector="isForClass">isForClass	^true</body><body package="Store-DB-Records" selector="isMeta">isMeta	^name namesMetaClass</body></methods><methods><class-id>Store.PseudoClass</class-id> <category>accessing</category><body package="Store-DB-Records" selector="absoluteName">absoluteName	^name asClassNameOnly</body><body package="Store-DB-Records" selector="classNameWithMeta">classNameWithMeta	^name</body><body package="Store-DB-Records" selector="fileOutObjectType">fileOutObjectType	^#class</body><body package="Store-DB-Records" selector="name">name	^( name asClassNameOnly tokensBasedOn: $.) last</body><body package="Store-DB-Records" selector="textRepresentationForTag:">textRepresentationForTag: aTag 	^aTag isClassCommentTag		ifTrue: [ self comment ]		ifFalse: [ self definition ]</body></methods><methods><class-id>Store.PseudoClass</class-id> <category>comparing</category><body package="Store-DB-Records" selector="comparesTo:">comparesTo: anObject		"Answer true if anObject could be another version of the receiver."	( self objectIsForSelf: anObject ) ifFalse: [ ^false ].	^self absoluteName = anObject absoluteName."	^name = anObject classNameWithMeta.  "</body><body package="Store-DB-Records" selector="objectIsForSelf:">objectIsForSelf: anObject		"Answer true if anObject represents the same kind of thing as the reciever."	^anObject isForClass</body></methods><methods><class-id>Store.PseudoClass class</class-id> <category>instance creation</category><body package="Store-DB-Records" selector="named:meta:">named: aName meta: isMeta	^isMeta		ifTrue: [ self newNamed: aName, ' class' ]		ifFalse: [ self newNamed: aName asString ].</body></methods><methods><class-id>Store.DefinedRecord</class-id> <category>db-utilities</category><body package="Store-DB-Records" selector="conflictsWithImage">conflictsWithImage		"Answer true if the receiver's name conflicts with something already		in the image."	^self fullName asStrictReference isDefined</body><body package="Store-DB-Records" selector="definitionClass">definitionClass		^Blob</body><body package="Store-DB-Records" selector="definitionRecord">definitionRecord	"Create a new record in the database that holds the source code."	^self class definitionClass fromString: definitionStr</body></methods><methods><class-id>Store.DefinedRecord</class-id> <category>accessing</category><body package="Store-DB-Records" selector="absoluteName">absoluteName	^self fullName</body><body package="Store-DB-Records" selector="absoluteSymbol">absoluteSymbol	^self absoluteName asSymbol</body><body package="Store-DB-Records" selector="actual">actual		"Answer the object represented by the receiver as it exists in the image."	^self object</body><body package="Store-DB-Records" selector="comment">comment	| aString |	aString := self commentStr.	aString size = 0 ifTrue: [ ^'' ].	^aString	"get string only of classComment, undoubling quotes   ???""	^String readFromString: aString  "</body><body package="Store-DB-Records" selector="commentID">commentID	"Answer the receiver's commentID."	^commentID</body><body package="Store-DB-Records" selector="commentID:">commentID: newCommentID	"Set the receiver's commentID to newCommentID."	commentID := newCommentID</body><body package="Store-DB-Records" selector="commentStr">commentStr	"Allow for lazy evaluation."	^commentStr isNil		ifTrue: [commentStr := self getDefinitionID: self commentID]		ifFalse: [commentStr]</body><body package="Store-DB-Records" selector="commentStr:">commentStr: aValue	commentStr := aValue</body><body package="Store-DB-Records" selector="definition">definition	| str |	str := self definitionStr.	^( str isEmpty not and: [ str first == $&lt; ] )		ifTrue: [ self convertFromXML: str ]		ifFalse: [ str ]</body><body package="Store-DB-Records" selector="definitionAndComment">definitionAndComment	^self class mergeDefinition: self definition andComment: self comment</body><body package="Store-DB-Records" selector="definitionID">definitionID	"Answer the receiver's definitionID."	^definitionID</body><body package="Store-DB-Records" selector="definitionID:">definitionID: newDefinitionID	"Set the receiver's definitionID to newDefinitionID."	definitionID := newDefinitionID</body><body package="Store-DB-Records" selector="definitionStr">definitionStr	"Allow for lazy evaluation."	^definitionStr isNil		ifTrue: [definitionStr := self getDefinitionID: self definitionID]		ifFalse: [definitionStr]</body><body package="Store-DB-Records" selector="definitionStr:">definitionStr: aValue	definitionStr := aValue</body><body package="Store-DB-Records" selector="environmentString">environmentString	^environmentString</body><body package="Store-DB-Records" selector="environmentString:">environmentString: aString	environmentString := aString</body><body package="Store-DB-Records" selector="fullName">fullName	^BindingReference fullNameFrom: self fullyQualifiedPath name: self realname.</body><body package="Store-DB-Records" selector="fullyQualifiedPath">fullyQualifiedPath	^self environmentString == nil		ifTrue: [ '' ]		ifFalse: [ environmentString ].</body><body package="Store-DB-Records" selector="nameSpace">nameSpace		"Answer the receiver's containing NameSpace as it exists in the image.		nil if not there."  "May be a class' namespace."	| obj |	^( obj := self owner ) == nil		ifTrue: [ obj ]		ifFalse: [ obj asNameSpace ]</body><body package="Store-DB-Records" selector="nameSpaceName">nameSpaceName	^self fullyQualifiedPath</body><body package="Store-DB-Records" selector="object">object		"Answer the object represented by the receiver as it exists in the image."	^self fullName asStrictReference valueOrDo: [ nil ]</body><body package="Store-DB-Records" selector="owner">owner		"Answer the receiver's container as it exists in the image.		nil if not there."	^( self environmentString == nil or: [ environmentString isEmpty ] )		ifTrue: [ nil ]		ifFalse: [ environmentString asStrictReference valueOrDo: [ nil ] ].</body><body package="Store-DB-Records" selector="ownerName">ownerName		"Answer the receiver's owner's name. nil if not there."	^( self environmentString == nil or: [ environmentString isEmpty ] )		ifTrue: [ nil ]		ifFalse: [ environmentString ].</body><body package="Store-DB-Records" selector="package">package	^package </body><body package="Store-DB-Records" selector="package:">package: pkg	package := pkg</body><body package="Store-DB-Records" selector="realname">realname	^name</body><body package="Store-DB-Records" selector="sourceCode">sourceCode	"Answer a definition"	^self definition</body><body package="Store-DB-Records" selector="sourceCode:">sourceCode: aValue	"Set the definition string. To have the same protocol as method records"	definitionStr := aValue</body><body package="Store-DB-Records" selector="xmlDefinition">xmlDefinition	| str |	str := self definitionStr.	^(str isEmpty or: [str first == $&lt;])		ifTrue: [str]		ifFalse: [self convertToXML: str]</body></methods><methods><class-id>Store.DefinedRecord</class-id> <category>comparing</category><body package="Store-DB-Records" selector="&lt;=">&lt;= aDescriptor	^self name &lt;= aDescriptor name</body><body package="Store-DB-Records" selector="comparesTo:">comparesTo: anObject		"Answer true if anObject could be another version of the receiver."	( self objectIsForSelf: anObject ) ifFalse: [ ^false ].	^anObject absoluteName asClassNameOnly = self absoluteName</body><body package="Store-DB-Records" selector="hash">hash	^self name hash</body><body package="Store-DB-Records" selector="objectIsForSelf:">objectIsForSelf: anObject		"Answer true if anObject represents the same kind of thing as the reciever."	^self subclassResponsibility</body><body package="Store-DB-Records" selector="quickComparesTo:">quickComparesTo: anObject		"Answer true if anObject could be another version of the receiver."		"For comparing differenct db versions."	self  class == anObject class		ifFalse: [ ^false ].	name = anObject name and: [ self environmentString = anObject environmentString ].</body><body package="Store-DB-Records" selector="sameAsImage">sameAsImage	"Answer true if the receiver is the same as the image version."	^self sameAsImThing: self asDescriptor</body></methods><methods><class-id>Store.DefinedRecord</class-id> <category>private</category><body package="Store-DB-Records" selector="convertFromXML:">convertFromXML: aString	^self subclassResponsibility</body><body package="Store-DB-Records" selector="convertToXML:">convertToXML: aString	^self subclassResponsibility</body><body package="Store-DB-Records" selector="convertVariableNodeToXML:">convertVariableNodeToXML: aParseNode	| eName |	eName := (aParseNode respondsTo: #name)			ifTrue: [aParseNode name asString]			ifFalse: [aParseNode value == nil				ifTrue: ['nil']				ifFalse: [aParseNode value isBindingReference					ifTrue: [aParseNode value asString]					ifFalse: [self error: 'Expected to find a global reference here']]].	('Smalltalk.#*' match: eName)		ifTrue: [eName := eName copyFrom: 'Smalltalk.*' size to: eName size].	^eName</body><body package="Store-DB-Records" selector="convertXMLNameToSmalltalk:quoted:">convertXMLNameToSmalltalk: aString quoted: shouldBeQuoted	| eName |	aString = 'nil' ifTrue: [^aString].	eName := aString.	((eName includes: $.) or: [eName = 'Smalltalk'])		ifFalse: [eName := 'Smalltalk.', eName].	shouldBeQuoted		ifTrue: [eName := '#{', eName, '}'].	^eName</body><body package="Store-DB-Records" selector="loadDefinition:into:logged:">loadDefinition: aString  into: imgPackage logged: logFlag	"Load the receiver into the image by compiling it's definition.	Ensure that it gets into imgPackage (NOTE: only neccessary if definition not being evaluated)."	| obj  |	obj := self object.	obj :=  [ Object evaluatorClass 	"subclassDefinerClass"				evaluate: aString notifying: nil logged: logFlag 			] on: VariableConfirmation do: [ :ex | ex resume: false ].		IncrementNotification raiseSignal.	^obj</body><body package="Store-DB-Records" selector="loadDefinition:logged:">loadDefinition: aString logged: logFlag	"Load the receiver into the image by compiling it's definition."	"DS- took out optimazation of not compiling  unchanged defs."	IncrementNotification raiseSignal.	^Object evaluatorClass "subclassDefinerClass"		evaluate: aString		notifying: nil		logged: logFlag.</body><body package="Store-DB-Records" selector="move:to:">move: obj to: imgPackage 	"Move obj, assumed to be the insanitiation of the reciever, to imgPackage."	self subclassResponsibility</body><body package="Store-DB-Records" selector="prepareInstallation">prepareInstallation	"Create first records for both definition string and comment string."	self definitionID == nil		ifTrue: [ self definitionID: 	(self class definitionClass fromString: definitionStr) primaryKey ].	self commentID == nil		ifTrue: 			[ self commentID: 				( ( commentStr isNil or: [ commentStr isEmpty ] )					ifTrue: [ 0 ]					ifFalse: [ ( self class definitionClass fromString: commentStr ) primaryKey ]				  )			].</body><body package="Store-DB-Records" selector="prime">prime	"Fill slots that do not map to table columns with instances of Object"	super prime.	definitionStr := Object new.	commentStr := Object new.	version := Object new.	package := Object new.</body><body package="Store-DB-Records" selector="processFields">processFields	"Do any necessary data conversions following retrieval"	definitionStr notNil ifTrue: 		[ self definitionStr: ( self processString: self definitionStr ) ].	commentStr notNil 		ifTrue: [ self commentStr: ( self processString: self commentStr ) ]</body><body package="Store-DB-Records" selector="sax:tag:value:">sax: driver tag: tag value: value	driver startElement: tag atts: nil.	driver characters: value.	driver endElement</body><body package="Store-DB-Records" selector="unprime">unprime	"Nil out the slots that do not map to table columns"	super unprime.	definitionStr := nil.	commentStr := nil.	version := nil.	package := nil.</body></methods><methods><class-id>Store.DefinedRecord</class-id> <category>public interface</category><body package="Store-DB-Records" selector="load">load	| record |	record := self loadDefinition.	self loadCommentFor: record</body><body package="Store-DB-Records" selector="loadCommentFor:">loadCommentFor: aLoadedRecord 	"Given the loadedClass set the record's comment."	(self class commentFor: aLoadedRecord) ~= self comment 		ifTrue: [ aLoadedRecord comment: self comment ]</body><body package="Store-DB-Records" selector="loadDefinition">loadDefinition	"Load the defintion only"	^self loadDefinition: self definition logged: true</body></methods><methods><class-id>Store.DefinedRecord</class-id> <category>filing out</category><body package="Store-DB-Records" selector="fileOutCommentOn:">fileOutCommentOn: aStream	"Fileout the receiver's  comment on a stream."	self comment isEmpty 		ifFalse: [ aStream comment: self value: self commentStr ].	"	IncrementNotification raiseSignal. "</body><body package="Store-DB-Records" selector="fileOutDefinitionOn:">fileOutDefinitionOn: aStream	"File the receiver out on aSourceFileManager."	aStream storeObjectDefinition: self.</body><body package="Store-DB-Records" selector="fileOutDifferencesBetween:on:">fileOutDifferencesBetween: other on: aStream	"Create a file that upon filing in brings transforms other into myself."	( other == nil or: [ other definition ~= self definition ] ) 		ifTrue: [ aStream storeObjectDefinition: self ].	( other == nil or: [ other comment ~= self comment ] ) 		ifTrue: 			[ self comment isEmpty 				ifFalse: [ aStream comment: self value: self commentStr ].			].	IncrementNotification raiseSignal.</body><body package="Store-DB-Records" selector="fileOutSourceOn:">fileOutSourceOn: aStream	"File the receiver out on aSourceFileManager."	self fileOutDefinitionOn: aStream.	self fileOutCommentOn: aStream.	IncrementNotification raiseSignal.</body></methods><methods><class-id>Store.DefinedRecord</class-id> <category>printing</category><body package="Store-DB-Records" selector="fullDisplayString">fullDisplayString	^'&lt;1s&gt; &lt;2s&gt;' 		expandMacrosWith: self displayString 		with: self versionString</body><body package="Store-DB-Records" selector="storeOn:">storeOn: aStream	"Append to the argument aStream the global names of the receiver."	aStream nextPutAll: self fullName</body></methods><methods><class-id>Store.DefinedRecord</class-id> <category>change list support</category><body package="Store-DB-Records" selector="text">text	"Asnwer the text to display in a text window."	^self definition</body></methods><methods><class-id>Store.DefinedRecord class</class-id> <category>db-accessing</category><body package="Store-DB-Records" selector="allVersionsNamed:">allVersionsNamed: aName	"Given a name of a NameSpace answer a collection of all versions 	of the space in the database."	"NameSpaceRecord allVersionsNamed: 'Smalltalk'"	"ClassRecord allVersionsNamed: 'TT_Class'"	| versions simpleName | 	simpleName := ( BindingReference pathString: aName ) simpleName.	versions := self 		executeSQL: 				( self newSQL					selectAll;					where;					column: #name  equalTo: simpleName asString printString)	 	onError: [ self table select: [ :each | each name = aName asString ] ].	^versions asSortedCollection: [:x :y | x primaryKey &gt; y primaryKey].</body><body package="Store-DB-Records" selector="selectVersionNamed:">selectVersionNamed: aName	| list |	list := self allVersionsNamed: aName.	list isEmpty		ifTrue: [ Dialog warn: 'No prior versions'. ^nil ].	list size == 1		ifTrue: [ ^list first ].	 ^Dialog 		choose: 'Choose version...'		fromList: ( list collect: [ :m | m itemString ] ) values: list		lines: 10 cancel: [ ^nil ]		for: nil.</body></methods><methods><class-id>Store.DefinedRecord class</class-id> <category>installation</category><body package="Store-DB-Records" selector="fieldTypes">fieldTypes		"self fieldTypes"	| aDict  |	( aDict := super fieldTypes )		at: 'commentID' put: #Integer;		at: 'definitionID' put: #Integer.	self checkFieldsWith: aDict.	^aDict</body><body package="Store-DB-Records" selector="needsSequence">needsSequence	^true</body><body package="Store-DB-Records" selector="storageParameters">storageParameters	"Answer a string describing special storage parameters for the table or nil if the default parameters are 	acceptable answer."	^'STORAGE(INITIAL 2M NEXT 512K PCTINCREASE 1) '</body></methods><methods><class-id>Store.DefinedRecord class</class-id> <category>private</category><body package="Store-DB-Records" selector="newFrom:">newFrom: object	| new |	new := self from: object timeStamp: self timeStamp trace: nil.	new install.	^new</body><body package="Store-DB-Records" selector="newOrExistingFrom:trace:">newOrExistingFrom: object trace: oldDB	"Answer an instance of the receiver, if a trace is the same as 	an object answer the trace class.	If either definition or comment for a trace class is the same	reuse it."	| newDB |	newDB := self from: object timeStamp: self timeStamp trace: oldDB.	oldDB definition string = newDB definition string		ifTrue: [ newDB definitionID: oldDB definitionID ].	oldDB commentStr string = newDB commentStr string		ifTrue: [ newDB commentID: oldDB commentID ].	^( newDB commentID = oldDB commentID 			and: [ newDB definitionID = oldDB definitionID ] )		ifTrue: [ oldDB ]		ifFalse: 			[ newDB install.			newDB			]</body><body package="Store-DB-Records" selector="recordFor:trace:">recordFor: object trace: aDBObject	^aDBObject == nil		ifTrue: [ self newFrom: object ]		ifFalse: [ self newOrExistingFrom: object trace: aDBObject ].</body></methods><methods><class-id>Store.DefinedRecord class</class-id> <category>instance creation</category><body package="Store-DB-Records" selector="fromView:">fromView: aView	| newDBRecord |	newDBRecord := self new.	self moveFieldsFrom: aView to: newDBRecord.	newDBRecord processFields.	^newDBRecord</body><body package="Store-DB-Records" selector="moveFieldsFrom:to:">moveFieldsFrom: aView to: aDBRecord	aDBRecord		primaryKey: aView primaryKey;		name: aView name;		timeStamp: aView timeStamp;	 	version: aView version;	 	userName: aView userName;	 	dbTrace: aView dbTrace;	 	definitionID: aView definitionID;	 	commentID: aView commentID;		environmentString: aView environmentString.</body></methods><methods><class-id>Store.DefinedRecord class</class-id> <category>accessing</category><body package="Store-DB-Records" selector="columnNames">columnNames		"self columnNames"		"TT_Class columnNames"	^super columnNames		remove: 'commentStr';		remove: 'definitionStr';		remove: 'version';		remove: 'package';		yourself.</body></methods><methods><class-id>Store.DefinedRecord class</class-id> <category>utility</category><body package="Store-DB-Records" selector="mergeDefinition:andComment:">mergeDefinition: definitionString andComment: aComment	^definitionString string, 'COMMENT:', aComment string</body></methods><methods><class-id>Store.DefinedRecord class</class-id> <category>private-garbage-collection</category><body package="Store-DB-Records" selector="recordsReferingToCommentID:">recordsReferingToCommentID: aDefinitionID 	"Collect records that use a given definition record as a comment. 	Answer a collection of IDs."	"Should only be sent to a specific subclass."	"self classesReferingToCommentID: 149745"	| ids |	ids := self broker process: 				( self newSQL					select: #( primaryKey );					where;					column: #commentID equalTo: aDefinitionID printString).	ids size &gt; 1 ifTrue: [ids := ids collect: [:each| each first]].	^ids</body><body package="Store-DB-Records" selector="recordsReferingToDefinitionID:">recordsReferingToDefinitionID: aDefinitionID 	"Collect Records that refer to a given definition record. 	Answer a collection of IDs."	"Should only be sent to a concrete subclass."	"self classesReferingToDefinitionID: 149744"	| ids |	ids := self broker process: 					( self newSQL						select: #( primaryKey );						where;						column: #definitionID equalTo: aDefinitionID printString).	^ids collect: [ :each | each first ]</body></methods><methods><class-id>Store.PropertyRecord</class-id> <category>comparing</category><body package="Store-DB-Records" selector="comparesTo:">comparesTo: anObject 	"Answer true if anObject could be another version of the receiver.	Update to compare this property key, (ie., name) with that of the other."	(self objectIsForSelf: anObject) ifFalse: [^false].	^anObject property = self property</body><body package="Store-DB-Records" selector="objectIsForSelf:">objectIsForSelf: anObject		"Answer true if anObject represents the same kind of thing as the reciever."	^anObject isForProperty</body><body package="Store-DB-Records" selector="property">property	"To be consistent with PropertyTag semantics and for other reasons,	this method serves as an accessor to the corresponding property name,	i.e., the key in the a Pundle's properties dictionary."	^self name</body></methods><methods><class-id>Store.PropertyRecord</class-id> <category>db-utilities</category><body package="Store-DB-Records" selector="containingBundles">containingBundles	^[( Properties bundlesContainingProperty: self primaryKey )		collect: [ :id | Bundle aRecordWithID: id ]	]	on: self errorSignals	do: [ :ex | ex outer. OrderedCollection new ].</body><body package="Store-DB-Records" selector="containingPackages">containingPackages	^[( Properties packagesContainingProperty: self primaryKey )		collect: [ :id | Package aRecordWithID: id ]	]	on: self errorSignals	do: [ :ex | ex outer. OrderedCollection new ].</body><body package="Store-DB-Records" selector="definitionRecord">definitionRecord	"Create a new record in the database that holds the property object."	^self class definitionClass fromBinData: self definitionObject</body></methods><methods><class-id>Store.PropertyRecord</class-id> <category>printing</category><body package="Store-DB-Records" selector="displayString">displayString	^self name</body><body package="Store-DB-Records" selector="printOn:">printOn: aStream	aStream nextPutAll: 'Property{';		nextPutAll: self primaryKey printString;		nextPutAll: '-';		nextPutAll: self name;		nextPutAll: '}'.</body></methods><methods><class-id>Store.PropertyRecord</class-id> <category>testing</category><body package="Store-DB-Records" selector="isForProperty">isForProperty			^true</body></methods><methods><class-id>Store.PropertyRecord</class-id> <category>accessing</category><body package="Store-DB-Records" selector="definition">definition	"Overridden to behave like the original Property Dictionary, which doesn't process the property."	^self definitionObject</body><body package="Store-DB-Records" selector="definitionObject">definitionObject	"Return the property value."	^self definitionStr</body><body package="Store-DB-Records" selector="definitionObject:">definitionObject: aPropertyValue	"Return the property value."	^self definitionStr: aPropertyValue</body><body package="Store-DB-Records" selector="searchString">searchString	^searchString</body><body package="Store-DB-Records" selector="searchString:">searchString: anObject	searchString := anObject</body></methods><methods><class-id>Store.PropertyRecord</class-id> <category>private</category><body package="Store-DB-Records" selector="getDefinitionID:">getDefinitionID: anID 	"This method is ultimately called for commentStr and definitionStr.	Superclass implementation thinks the types are always string-based.	But definitionStr is binary (un-BOSSed object), so we must override."	| record def |	def := (record := self getDefinitionRecordID: anID) notNil 				ifTrue: 					[record isData ifTrue: [record binData] ifFalse: [record definition]]				ifFalse: [def := String new].	^def</body><body package="Store-DB-Records" selector="prepareInstallation">prepareInstallation	"Create first records for both definition object and comment string."	self definitionID == nil 		ifTrue: [self definitionID: (self class definitionClass fromBinData: self definitionObject) primaryKey].	self commentID == nil 		ifTrue: [self commentID: (self class definitionClass fromString: commentStr) primaryKey]</body><body package="Store-DB-Records" selector="processFields">processFields	"Do any necessary data conversions following retrieval"	commentStr notNil 		ifTrue: [self commentStr: (self processString: self commentStr)]</body></methods><methods><class-id>Store.PropertyRecord class</class-id> <category>accessing</category><body package="Store-DB-Records" selector="associationClass">associationClass	^Properties</body><body package="Store-DB-Records" selector="referenceColumn">referenceColumn	^#propertyRef</body><body package="Store-DB-Records" selector="searchStringFrom:">searchStringFrom: anObject 	"Return a search string for anObject, or empty string.	To prevent db encoding complaints, convert to ascii, or use empty string."	| aString bytes |	^(anObject isKindOf: String) 		ifTrue: 			[| max |			max := self broker maxPropertySearchStringSize.			aString := anObject copyFrom: 1 to: (max min: anObject size).			bytes := [aString asByteArrayEncoding: #ascii] on: Error						do: [:ex | ex return: #[]].			bytes asString]		ifFalse: ['']</body></methods><methods><class-id>Store.PropertyRecord class</class-id> <category>instance creation</category><body package="Store-DB-Records" selector="from:timeStamp:trace:">from: prop timeStamp: timeStamp trace: oldDB	| env |	env := nil. ":= prop environment."	^self new		name: prop name asString;		timeStamp: timeStamp;		environmentString: ( env == nil ifTrue: [ '' ] ifFalse: [ env absoluteName ] );		definitionObject:  prop definitionObject;		commentStr: prop comment;		searchString: prop searchString;		setTrace: oldDB;		yourself.</body><body package="Store-DB-Records" selector="moveFieldsFrom:to:">moveFieldsFrom: aView to: aDBRecord 	super moveFieldsFrom: aView to: aDBRecord.	aDBRecord searchString: aView searchString</body><body package="Store-DB-Records" selector="newName:definition:">newName: aName definition: aPropertyValue 	"Create a new property record from name and definition."	| rec |	rec := self new.	rec name: aName.	rec definitionObject: aPropertyValue.	rec searchString: (self searchStringFrom: aPropertyValue).	^rec</body></methods><methods><class-id>Store.PropertyRecord class</class-id> <category>private</category><body package="Store-DB-Records" selector="newOrExistingFrom:trace:">newOrExistingFrom: object trace: oldDB	"Answer an instance of the receiver, if a trace is the same as 	an object answer the trace class.	If either definition or comment for a trace class is the same	reuse it."	| newDB |	newDB := self from: object timeStamp: self timeStamp trace: oldDB.	oldDB definitionObject = newDB definitionObject		ifTrue: [ newDB definitionID: oldDB definitionID ].	oldDB commentStr string = newDB commentStr string		ifTrue: [ newDB commentID: oldDB commentID ].	^( newDB commentID = oldDB commentID 			and: [ newDB definitionID = oldDB definitionID ] )		ifTrue: [ oldDB ]		ifFalse: 			[ newDB install.			newDB			]</body></methods><methods><class-id>Store.ClassRecord</class-id> <category>converting</category><body package="Store-DB-Records" selector="asCommentTag">asCommentTag	"Answer an instance of ClassCommentTag"	^ClassCommentTag newClassName: self absoluteName isMeta:  self isMeta</body><body package="Store-DB-Records" selector="asDescriptor">asDescriptor	"Answer an instance of ClassDescriptor."	^ClassDescriptor fromModel: self</body><body package="Store-DB-Records" selector="asTag">asTag	"Answer an instance of TT_ClassTag"	^ClassTag newClassName: self absoluteName isMeta: self isMeta</body></methods><methods><class-id>Store.ClassRecord</class-id> <category>testing</category><body package="Store-DB-Records" selector="isClass">isClass	^true</body><body package="Store-DB-Records" selector="isForClass">isForClass			^true</body><body package="Store-DB-Records" selector="isMeta">isMeta	^self name namesMetaClass</body></methods><methods><class-id>Store.ClassRecord</class-id> <category>printing</category><body package="Store-DB-Records" selector="displayString">displayString	^SystemUtils convertAbsoluteNameToFull: self absoluteName</body><body package="Store-DB-Records" selector="printOn:">printOn: aStream	aStream nextPutAll: 'ClassRecord{';		nextPutAll: self primaryKey printString;		nextPutAll: '-';		nextPutAll: self name;		nextPutAll: '}'.</body></methods><methods><class-id>Store.ClassRecord</class-id> <category>public interface</category><body package="Store-DB-Records" selector="browseVersions">browseVersions  	TabApplicationSystemBrowser browseVersionsOfNamespaceOrClass: self</body><body package="Store-DB-Records" selector="loadComment">loadComment	| cl |	(cl := self myClass) isNil ifFalse: [self loadCommentFor: cl]</body><body package="Store-DB-Records" selector="loadComponents:meta:package:">loadComponents: aSet meta: isMeta package: aDBPackage 	"Load specified components: #definition #comment #methods #data	from aDBPackge."	| imPkg methods cls data cname |	imPkg := Registry packageNamed: aDBPackage name.	imPkg isNil ifTrue: [ ^Dialog warn: 'Package ,' , aDBPackage name , ' is not loaded.'.].	cls := ((aSet includes: #definition)				or: [aSet includes: #comment])				ifTrue: [self]				ifFalse: [nil].	cname := self classNameWithMeta.	"actually, this is always the instance side."	isMeta ifTrue: [ cname := cname, ' class' ].		methods := (aSet includes: #methods)				ifTrue: [ aDBPackage methodsForClassNamed: cname ]				ifFalse: [ Array new ].	data := (aSet includes: #data)				ifTrue: [aDBPackage dataForNamed: self absoluteName]				ifFalse: [Array new].	(LoadAnalyzer		canLoadClass: cls		methods: methods		data: data		from: imPkg)		ifFalse: [^self].	(aSet includes: #definition)		ifTrue: [Policies packagePolicy forcePackage: imPkg while: [self loadDefinition]].	(aSet includes: #comment)		ifTrue: [Policies packagePolicy forcePackage: imPkg while: [self loadComment]].	(aSet includes: #methods)		ifTrue: [methods do: [:m | m loadSrcIntoPackage: imPkg confirm: false]].	(aSet includes: #data)		ifTrue: [data do: [:m | m loadSrcIntoPackage: imPkg confirm: false]]</body><body package="Store-DB-Records" selector="loadComponents:package:">loadComponents: aSet package: aDBPackage 	"Load specified components: #definition #comment #methods #data	from aDBPackge."	| imPkg methods cls data |	imPkg := Registry packageNamed: aDBPackage name.	imPkg isNil ifTrue: [ ^Dialog warn: 'Package ,' , aDBPackage name , ' is not loaded.'.].	cls := ((aSet includes: #definition)				or: [aSet includes: #comment])				ifTrue: [self]				ifFalse: [nil].	methods := (aSet includes: #methods)				ifTrue: [aDBPackage methodsForClassNamed: self classNameWithMeta]				ifFalse: [Array new].	data := (aSet includes: #data)				ifTrue: [aDBPackage dataForNamed: self absoluteName]				ifFalse: [Array new].	(LoadAnalyzer		canLoadClass: cls		methods: methods		data: data		from: imPkg)		ifFalse: [^self].	(aSet includes: #definition)		ifTrue: [Policies packagePolicy forcePackage: imPkg while: [self loadDefinition]].	(aSet includes: #comment)		ifTrue: [Policies packagePolicy forcePackage: imPkg while: [self loadComment]].	(aSet includes: #methods)		ifTrue: [methods do: [:m | m loadSrcIntoPackage: imPkg confirm: false]].	(aSet includes: #data)		ifTrue: [data do: [:m | m loadSrcIntoPackage: imPkg confirm: false]]</body><body package="Store-DB-Records" selector="loadFrom:using:">loadFrom: aDBPackage using: loader 	"Since the metaclass definition is obsolete, the instance side can load it all."	self 		loadComponents: ( loader componentsToLoadOnSide: false ) 		meta: false		package: aDBPackage.	self 		loadComponents: ( loader componentsToLoadOnSide: true )		meta: true		package: aDBPackage.</body><body package="Store-DB-Records" selector="loadSrc">loadSrc	"Load a class definition if necessary do not log changes."	^self loadSrcInto: nil.		"whatever the default is"</body><body package="Store-DB-Records" selector="loadSrcInto:">loadSrcInto: imgPackage	"Load a class definition if necessary do not log changes."	| class |	class := self loadDefinition: self definition into: imgPackage logged: false.	self isMeta 		ifFalse: 	[ self loadCommentFor: class ].	IncrementNotification raiseSignal.	^class notNil</body><body package="Store-DB-Records" selector="myClass">myClass		"Answer the receiver's class in the image. 		Answer nil if not loaded."	| cls |	cls := self fullName asClassNameOnly asStrictReference valueOrDo: [ ^nil ].	^self isMeta		ifTrue: [ cls class ]		ifFalse: [ cls ].</body><body package="Store-DB-Records" selector="removeFromPackage:">removeFromPackage: aPackage	"For adding a removal of unloaded defintions from the change sets."	XMainChangeSet current		addRemoveClass: self className		package: aPackage</body></methods><methods><class-id>Store.ClassRecord</class-id> <category>browser support</category><body package="Store-DB-Records" selector="asString">asString	^name</body><body package="Store-DB-Records" selector="binding">binding		"No such thing"	^self</body><body package="Store-DB-Records" selector="simpleName">simpleName	^name</body><body package="Store-DB-Records" selector="value">value		"Implemented by any subclass wanting to be displayed in a browser"	^self myClass</body><body package="Store-DB-Records" selector="valueOrDo:">valueOrDo: aBlock		"Implemented by any subclass wanting to be displayed in a browser"	^self myClass</body></methods><methods><class-id>Store.ClassRecord</class-id> <category>accessing</category><body package="Store-DB-Records" selector="absoluteName">absoluteName	^self fullNameOnly</body><body package="Store-DB-Records" selector="className">className	^name</body><body package="Store-DB-Records" selector="classNameWithMeta">classNameWithMeta	^self fullyQualifiedPath, '.', name</body><body package="Store-DB-Records" selector="fileOutObjectType">fileOutObjectType		"Answer a symbol that represents the type of the receiver."	^#class</body><body package="Store-DB-Records" selector="fullName">fullName	| str |	str := BindingReference fullNameFrom: self fullyQualifiedPath name: self realname.	self isMeta ifTrue: [ str := str, ' class' ].	^str</body><body package="Store-DB-Records" selector="fullNameOnly">fullNameOnly	^BindingReference fullNameFrom: self fullyQualifiedPath name: self realname.</body><body package="Store-DB-Records" selector="instanceBehavior">instanceBehavior		^self</body><body package="Store-DB-Records" selector="nameOnly">nameOnly	^BindingReference fullNameFrom: self fullyQualifiedPath name: self realname.</body><body package="Store-DB-Records" selector="object">object		"Answer the object represented by the receiver as it exists in the image."	| obj |	obj := self fullNameOnly asStrictReference valueOrDo: [ ^nil ].	^self isMeta		ifTrue: [ obj class ]		ifFalse: [ obj ]</body><body package="Store-DB-Records" selector="realname">realname	^name asClassNameOnly</body><body package="Store-DB-Records" selector="setCommentFor:">setCommentFor: aClass 	"OBSOLETE"</body><body package="Store-DB-Records" selector="superclass">superclass	"Answer the receiver's superclass."	^superclass</body><body package="Store-DB-Records" selector="superclass:">superclass: newSuperclass	"Set the receiver's superclass to newSuperclass."	superclass := newSuperclass</body><body package="Store-DB-Records" selector="symbol">symbol	^self absoluteSymbol</body><body package="Store-DB-Records" selector="textRepresentationForTag:">textRepresentationForTag: aTag 	^aTag isClassCommentTag		ifTrue: [self comment]		ifFalse: [self definition]</body></methods><methods><class-id>Store.ClassRecord</class-id> <category>db-utilities</category><body package="Store-DB-Records" selector="containingPackages">containingPackages	^[( PkgClasses packagesContainingClass: self primaryKey )		collect: [ :id | Package aRecordWithID: id ]	]	on: self errorSignals	do: [ :ex | ex outer. OrderedCollection new ].</body><body package="Store-DB-Records" selector="instSideFrom:">instSideFrom: aDBPackage 	^self isMeta		ifTrue: [ aDBPackage classInPackageNamed: self absoluteName meta: false ] 		ifFalse: [ self ]</body><body package="Store-DB-Records" selector="metaSideFrom:">metaSideFrom: aDBPackage 	^self isMeta		ifTrue: [ self ]		ifFalse: [ aDBPackage classInPackageNamed: self absoluteName meta: true ]</body><body package="Store-DB-Records" selector="oppositeSideFrom:">oppositeSideFrom: aDBPackage 	^self isMeta		ifTrue: [self instSideFrom: aDBPackage]		ifFalse: [self metaSideFrom: aDBPackage]</body></methods><methods><class-id>Store.ClassRecord</class-id> <category>private</category><body package="Store-DB-Records" selector="convertFromXML:">convertFromXML: aString	| p element out attr value i |	p := XML.XMLParser on: aString readStream.	element := p validate: false; getNextChar; element.	out := (String new: 128) writeStream.	out nextPutAll: (self			convertXMLNameToSmalltalk: (element elementNamed: 'environment') characterData			quoted: false).	out nextPutAll: ' defineClass: ';		store: (element elementNamed: 'name') characterData asSymbol.	out crtab; nextPutAll: 'superclass: ';		nextPutAll: (self			convertXMLNameToSmalltalk: (element elementNamed: 'super') characterData			quoted: true).	out crtab; nextPutAll: 'indexedType: ';		store: (element elementNamed: 'indexed-type') characterData asSymbol.	out crtab; nextPutAll: 'private: ';		nextPutAll: (element elementNamed: 'private') characterData.	out crtab; nextPutAll: 'instanceVariableNames: ';		store: (element elementNamed: 'inst-vars') characterData.	out crtab; nextPutAll: 'classInstanceVariableNames: ';		store: (element elementNamed: 'class-inst-vars') characterData.	out crtab; nextPutAll: 'imports: ';		store: (element elementNamed: 'imports') characterData.	out crtab; nextPutAll: 'category: ';		store: (element elementNamed: 'category') characterData.	attr := [element elementNamed: 'attributes'] on: Error do: [:ex | ex return: nil].	attr == nil ifFalse:		[out crtab; nextPutAll: 'attributes: #('.		attr elements do: [:elm |			elm isElement ifTrue:				[out crtab: 3; nextPutAll: '#('; store: elm tag type asSymbol; space.				((elm elements contains: [:e | e isElement]) or: [elm elements isEmpty])					ifTrue: [value := (elm elements select: [:e | e isElement])							collect: [:e | e characterData]]					ifFalse:						[value := elm characterData.						i := #('nil' 'true' 'false') indexOf: value.						value := i = 0 ifTrue: [value asSymbol] ifFalse: [#(nil true false) at: i]].				out store: value; nextPutAll: ')']].		out nextPutAll: ')'].	^out contents</body><body package="Store-DB-Records" selector="convertToXML:">convertToXML: aString	| parse driver data eName |	parse := Compiler new parse: aString in: nil class noPattern: true notifying: nil.	parse := parse node block body statements first.	data := Dictionary new.	parse selector keywords with: parse arguments do:		[:key :value | data at: key put: value].	driver := XML.DOM_SAXDriver new.	driver 	startDocumentFragment;		startElement: 'class' atts: nil.	self sax: driver tag: 'name' value: (data at: 'defineClass:') value asString.	eName := self convertVariableNodeToXML: parse receiver.	self sax: driver tag: 'environment' value: eName.	self sax: driver tag: 'super' value: (self convertVariableNodeToXML: (data at: 'superclass:')).	self sax: driver tag: 'private' value: (data at: 'private:') value printString.	self sax: driver tag: 'indexed-type' value: (data at: 'indexedType:') value asString.	self sax: driver tag: 'inst-vars' value: (data at: 'instanceVariableNames:') value.	self sax: driver tag: 'class-inst-vars' value: (data at: 'classInstanceVariableNames:') value.	self sax: driver tag: 'imports' value: (data at: 'imports:') value asString.	self sax: driver tag: 'category' value: (data at: 'category:') value asString.	(data includesKey: 'attributes:') ifTrue:		[driver startElement: 'attributes' atts: nil.		(data at: 'attributes:') value do: [:attr |			(attr last isKindOf: Array)				ifTrue:					[driver startElement: attr first atts: nil.					attr last do: [:s | self sax: driver tag: 'item' value: s].					driver endElement]				ifFalse: [self sax: driver tag: attr first value: attr last displayString]].		driver endElement].	driver endElement;		endDocumentFragment.	^SmalltalkWorkbench prettyPrint: driver document root</body><body package="Store-DB-Records" selector="loadDefinition:into:logged:">loadDefinition: aString  into: imgPackage logged: logFlag	"Load the receiver into the image by compiling it's definition."	( self superclass asStrictReference isDefined or: [ self superclass = 'nil' ] )		ifFalse: [  ^false ].	^[ super loadDefinition: aString  into: imgPackage logged: logFlag ] 		on: ClassBuilder buildFailureSignal do: 			[ :ex | | msg |			msg := '&lt;n&gt;&lt;1s&gt;: Error compiling class &lt;2s&gt;:&lt;nt&gt;&lt;3s&gt;'				expandMacrosWith: imgPackage name				with: name				with: ex description.			Transcript show: msg.			ex proceed 			].</body><body package="Store-DB-Records" selector="loadSrcIntoPackage:confirm:">loadSrcIntoPackage: imPkg confirm: aBoolean	"Load the method. Make sure that it goes to the imPkg. and it does not	overwrites existing definition from another package."	aBoolean 		ifTrue: [(Dialog confirm: 'Do you want to load the selected class?') 			ifFalse: [^self]].	( LoadAnalyzer canLoadClass: self from: imPkg )		ifTrue: [ Policies packagePolicy forcePackage: imPkg while:  [ self loadSrc ] ]</body><body package="Store-DB-Records" selector="move:to:">move: obj to: imgPackage 	"Move obj, assumed to be the insanitiation of the reciever, to imgPackage."	XChangeSet current moveClassDefinition: obj toPackage: imgPackage</body></methods><methods><class-id>Store.ClassRecord</class-id> <category>comparing</category><body package="Store-DB-Records" selector="comparesTo:">comparesTo: anObject		"Answer true if anObject could be another version of the receiver."	( self objectIsForSelf: anObject ) ifFalse: [ ^false ].	anObject isMeta = self isMeta		ifFalse: [ ^false ].	^anObject absoluteName = self absoluteName.</body><body package="Store-DB-Records" selector="objectIsForSelf:">objectIsForSelf: anObject		"Answer true if anObject represents the same kind of thing as the reciever."	^anObject isForClass</body><body package="Store-DB-Records" selector="quickComparesTo:">quickComparesTo: anObject		"Answer true if anObject could be another version of the receiver."		"For comparing differenct db versions."	^( super quickComparesTo: anObject ) and: [ self isMeta = anObject isMeta ]</body><body package="Store-DB-Records" selector="sameAsImThing:">sameAsImThing: aThing 	"Answer true if aThing is defined the same as the receiver."		"Ds- this compares the definition as a string--problem is, 		for non-existant ClassPools there is an error producing this		string. So... punt for now."	^[ aThing definitionAndComment = self definitionAndComment ] 		on: Dictionary valueNotFoundSignal do: [ :exp | exp return: false ].</body><body package="Store-DB-Records" selector="sourceMatches:">sourceMatches: aClass	"Answer whether the source matches."	^aClass definitionAndComment equalsAcrossPlatforms: self definitionAndComment</body></methods><methods><class-id>Store.ClassRecord class</class-id> <category>instance creation</category><body package="Store-DB-Records" selector="from:timeStamp:trace:">from: class timeStamp: timeStamp trace: oldDB	| classDef classComment |	classDef := self definitionFor: class.	classComment := self commentFor: class.	^self new		name: class name asString;		environmentString: class environment absoluteName;		timeStamp: timeStamp;		superclass: 			(class superclass isNil 							ifTrue: ['nil'] 				ifFalse: [class superclass absoluteName]			);		definitionStr: classDef;		commentStr: classComment;		setTrace: oldDB</body><body package="Store-DB-Records" selector="moveFieldsFrom:to:">moveFieldsFrom: aView to: aDBRecord	super moveFieldsFrom: aView to: aDBRecord.	aDBRecord superclass: aView superclass.</body><body package="Store-DB-Records" selector="psuedoClassForClassNamed:">psuedoClassForClassNamed: className "OBSOLETE"	^self new		name: className asString;		definitionStr: 'Removed from the system';		commentStr: '*****'</body></methods><methods><class-id>Store.ClassRecord class</class-id> <category>accessing</category><body package="Store-DB-Records" selector="associationClass">associationClass	^PkgClasses</body><body package="Store-DB-Records" selector="commentFor:">commentFor:  aClass	^self processString: aClass comment</body><body package="Store-DB-Records" selector="defaultBlockFactor">defaultBlockFactor	^16</body><body package="Store-DB-Records" selector="referenceColumn">referenceColumn	^#classRef</body><body package="Store-DB-Records" selector="sourcesViewClass">sourcesViewClass	^PkgClassesAndSourcesView</body></methods><methods><class-id>Store.ClassRecord class</class-id> <category>db-utilities</category><body package="Store-DB-Records" selector="allMetaclassesInPackage:butNotIn:">allMetaclassesInPackage: pkgKey1 butNotIn: pkgKey2 	"Answer a collection of metaclasses that are part of a package 	whith key pkgKey1 but are not part of a package pkgKey2."	"self allMetaclassesInPackage: 63 butNotIn: 57"	^Array new	"^ self 		allIn: pkgKey1		butNotIn: pkgKey2		refColumn: 'metaclassRef'		associationClass: PkgClasses"</body><body package="Store-DB-Records" selector="allMetaclassesInPackages:">allMetaclassesInPackages: keys	"Answer a collection of items that are in the packages in keys"	"Send to a concrete subclass that implements #referenceColumn"	"Method allInPackages: #( '23' '55' )"	^self allInPackages: keys refColumn: #metaClassRef</body><body package="Store-DB-Records" selector="allMetaclassesInPackages:butNotIn:">allMetaclassesInPackages: pkgKeys1 butNotIn: pkgKeys2 	"Answer a collection of instances for metaclasses that are contained in one of the packages 	in pkgKeys1, but not in the packages in pkgKeys2."	^Array new"	^ self 		allInPackages: pkgKeys1 		butNotIn: pkgKeys2 		refColumn: #metaclassRef"</body></methods><methods><class-id>Store.ClassRecord class</class-id> <category>private-testing</category><body package="Store-DB-Records" selector="test1">test1	"Create class records in the data base."	"self test1"	self newFrom: self</body></methods><methods><class-id>Store.Subdef</class-id> <category>support</category><body package="Store-DB-Subdefs" selector="textForItem">textForItem	^self itemString asText</body></methods><methods><class-id>Store.Subdef</class-id> <category>comparing</category><body package="Store-DB-Subdefs" selector="=">= aThing	^self sameAs: aThing</body><body package="Store-DB-Subdefs" selector="hash">hash	^self symbolKey hash</body><body package="Store-DB-Subdefs" selector="sameAsImThing:">sameAsImThing: aThing 	^aThing sameAsDBThing: self</body></methods><methods><class-id>Store.Subdef</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="creatorPackage">creatorPackage	^creatorPackage isNil		ifTrue: [ 0 ]		ifFalse: [	creatorPackage ]</body><body package="Store-DB-Subdefs" selector="creatorPackage:">creatorPackage: aPrimaryKey	creatorPackage := aPrimaryKey</body><body package="Store-DB-Subdefs" selector="creatorPackageVersion">creatorPackageVersion	| pkg |	^[creatorPackageVersion isNil		ifTrue: [self creatorPackage &gt; 0				ifTrue: 					[pkg := Package aRecordWithID: self creatorPackage.					pkg isNil ifTrue: [self error: 'Package not found.'].					creatorPackageVersion := pkg version]				ifFalse: [nil]]		ifFalse: [creatorPackageVersion]	]	on: self errorSignals	do: [ :ex | ex outer. nil]</body><body package="Store-DB-Subdefs" selector="creatorPackageVersion1">creatorPackageVersion1	^creatorPackageVersion isNil		ifTrue: [self creatorPackage &gt; 0				ifTrue: 					[| pkg user |					pkg := Package aRecordWithID: self creatorPackage.					pkg isNil ifTrue: [self error: 'Package not found.'].					user := self userName.					user isNil ifTrue: [user := 'unknown'].					creatorPackageVersion := pkg name , '(' , pkg version , ',' , user , ')']				ifFalse: [nil]]		ifFalse: [creatorPackageVersion]</body><body package="Store-DB-Subdefs" selector="sourceCode">sourceCode	^sourceCodeString isNil		ifTrue: [sourceCodeString := self getDefinitionID: self sourceCodeID]		ifFalse: [sourceCodeString]</body><body package="Store-DB-Subdefs" selector="sourceCode:">sourceCode: bytes	sourceCodeString := bytes</body><body package="Store-DB-Subdefs" selector="sourceCodeID">sourceCodeID	^sourceCodeID</body><body package="Store-DB-Subdefs" selector="sourceCodeID:">sourceCodeID: anID	sourceCodeID := anID</body><body package="Store-DB-Subdefs" selector="symbolKey">symbolKey	^self name asSymbol</body></methods><methods><class-id>Store.Subdef</class-id> <category>printing</category><body package="Store-DB-Subdefs" selector="displayString">displayString	^self itemString</body><body package="Store-DB-Subdefs" selector="versionString">versionString	| str |	str := self creatorPackageVersion.	^str isNil		ifTrue: [super versionString]		ifFalse: 			[| un |			un := self userName.			un isNil ifTrue: [un := 'unknown'].			' (' , str , ',' , un , ')']</body><body package="Store-DB-Subdefs" selector="versionString1">versionString1	| vstr |	vstr := self creatorPackageVersion.	^vstr isNil		ifTrue: [super versionString]		ifFalse: [vstr]</body></methods><methods><class-id>Store.Subdef</class-id> <category>private</category><body package="Store-DB-Subdefs" selector="prepareInstallation">prepareInstallation	"Create first a record for the definition string."	self sourceCodeID isNil 		ifTrue: [self sourceCodeID: self definitionRecord primaryKey].</body><body package="Store-DB-Subdefs" selector="prime">prime	"Fill slots that do not map to table columns with instances of Object"	super prime.	sourceCodeString := Object new.	creatorPackageVersion := Object new.	creatorPackage := Object new.		"only used for version strings."</body><body package="Store-DB-Subdefs" selector="unprime">unprime	"Nil out the slots that do not map to table columns"	super unprime.	creatorPackageVersion := nil.	sourceCodeString := nil.	creatorPackage := nil</body></methods><methods><class-id>Store.Subdef class</class-id> <category>installation</category><body package="Store-DB-Subdefs" selector="needsSequence">needsSequence	^true</body></methods><methods><class-id>Store.Method</class-id> <category>testing</category><body package="Store-DB-Subdefs" selector="isForMethod">isForMethod	^true</body><body package="Store-DB-Subdefs" selector="isMeta">isMeta	( meta == nil or: [ meta isKindOf: Object])		ifTrue: [ self metaString: metaString ].	^meta</body></methods><methods><class-id>Store.Method</class-id> <category>converting</category><body package="Store-DB-Subdefs" selector="asDescriptor">asDescriptor	"Answer an instance of DatumDescriptor."	^self asMethodDescriptor</body><body package="Store-DB-Subdefs" selector="asMethodDescriptor">asMethodDescriptor	^MethodDescriptor fromSelector: self selector className: self className meta: meta</body><body package="Store-DB-Subdefs" selector="asTag">asTag	"Answer an instance of TT_MethodTag."	^MethodTag 		newClassName: self className 		meta: self isMeta		selector: self selector		protocol: self protocol.</body></methods><methods><class-id>Store.Method</class-id> <category>printing</category><body package="Store-DB-Subdefs" selector="asMethodString">asMethodString	| string |	string := ( SystemUtils convertAbsoluteNameToFull: className ), ' '.	^string, self itemString.</body><body package="Store-DB-Subdefs" selector="displayString">displayString	^self name</body><body package="Store-DB-Subdefs" selector="fullDisplayString">fullDisplayString	^self asMethodString</body><body package="Store-DB-Subdefs" selector="printOn:">printOn: aStream	className isNil 		ifTrue: [ aStream nextPutAll: String new]		ifFalse: [ aStream nextPutAll: className].	aStream nextPutAll: '&gt;&gt;'.	self protocolName isNil 		ifTrue: [ aStream nextPutAll: String new]		ifFalse: [aStream nextPutAll: self protocolName].	aStream nextPutAll: '&gt;&gt;'.	self name isNil 		ifTrue: [ aStream nextPutAll: String new]		ifFalse: [aStream nextPutAll: self name].</body></methods><methods><class-id>Store.Method</class-id> <category>public interface</category><body package="Store-DB-Subdefs" selector="browseVersions">browseVersions  	TabApplicationSystemBrowser browseVersionsOfMethodOrStatic: self</body><body package="Store-DB-Subdefs" selector="loadAsNew">loadAsNew		^self loadAsNewWithCommittingSource: true</body><body package="Store-DB-Subdefs" selector="loadAsNewWithCommittingSource:">loadAsNewWithCommittingSource: commitSourceStream	"Load the method and skip the checking since the method is new. 	Answer true if the compilation was successful.  If commitSourceStream is false, then it is the	the client's responsibility to ensure that the changes log file is flushed."	| class protocol ret |	class := self myClass.	class == nil 		ifTrue: 			[ UnloadableDefinitionError signalWith: self.			^false			].	protocol := self protocolName asSymbol.	ret := commitSourceStream 			ifTrue: [ (class compile: self sourceCode classified: protocol notifying: nil attributes: nil) notNil]			ifFalse: [ (class compileWithoutUsingChangeFile: self sourceCode classified: protocol notifying: nil attributes: nil) notNil].	IncrementNotification raiseSignal.	^ret</body><body package="Store-DB-Subdefs" selector="loadInClass:protocol:">loadInClass: class protocol: aProtocol	"Check also for correct protocol"	| selector tracePackage |	selector := self name asSymbol.	( ( class includesSelector: selector )			and: [ ( class organization categoryOfElement: selector )	= aProtocol 			and: [ ( self class sourceCodeAt: selector forClass: class ) = self sourceCode]]	)		ifFalse: [ class compile: self sourceCode classified: aProtocol ].	tracePackage :=  ( Registry containingPackageForSelector: selector class: class ) tracePackage.	( tracePackage notNil and: 			[ self sameAs: ( tracePackage method: self name 								forClassNamed: self className asClassNameOnly								meta: self className namesMetaClass  )			]	) ifTrue: [ XChangeSet current removeSelectorChanges: selector class: class ].</body><body package="Store-DB-Subdefs" selector="loadInClass:protocol:package:">loadInClass: class protocol: aProtocol  package: imgPackage	"Check also for correct protocol"	| selector tracePackage |	selector := self name asSymbol.	( ( class includesSelector: selector )			and: [ ( class organization categoryOfElement: selector )	= aProtocol 			and: [ ( self class sourceCodeAt: selector forClass: class ) = self sourceCode]]	)		ifTrue: [ imgPackage == nil ifFalse:				[ XChangeSet current moveSelector:self name class: class toPackage: imgPackage ] 			   ]		ifFalse: [ class compile: self sourceCode classified: aProtocol ].	tracePackage :=  ( Registry containingPackageForSelector: selector class: class ) tracePackage.	( tracePackage notNil and: 			[ self sameAs: ( tracePackage method: self name 								forClassNamed: self className asClassNameOnly								meta: self className namesMetaClass  )			]	) ifTrue: [ XChangeSet current removeSelectorChanges: selector class: class ].</body><body package="Store-DB-Subdefs" selector="loadSrc">loadSrc	"Load the method."	^self loadSrcInto: nil</body><body package="Store-DB-Subdefs" selector="loadSrcInto:">loadSrcInto: imgPackage	"Load the method."	| class protocol |	class := self myClass.	class isNil 		ifTrue: 			[ ^UnloadableDefinitionError new					definitionRecord: self;					package: imgPackage;					raise 			].	protocol := self protocol.	self loadInClass: class protocol: protocol  package: imgPackage.	IncrementNotification raiseSignal.</body><body package="Store-DB-Subdefs" selector="loadSrcIntoPackage:confirm:">loadSrcIntoPackage: imPkg confirm: aBoolean	"Load the method. Make sure that it goes to the imPkg. and it does not	overwrites existing definition from another package."	aBoolean 		ifTrue: [(Dialog confirm: 'Do you want to load the selected method?') 			ifFalse: [^self]].	(LoadAnalyzer canLoadMethod: self from: imPkg)		ifTrue: [Policies packagePolicy forcePackage: imPkg while:  [self loadSrc]]</body><body package="Store-DB-Subdefs" selector="removeFromPackage:">removeFromPackage: aPackage	"For adding a removal of unloaded defintions from the change sets."	XMainChangeSet current		addRemoveSelector: self selector		className: self className asClassNameOnly		meta: self isMeta		package: aPackage</body></methods><methods><class-id>Store.Method</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="absoluteClassName">absoluteClassName	^className</body><body package="Store-DB-Subdefs" selector="className">className	^className</body><body package="Store-DB-Subdefs" selector="className:">className: anObject	className := anObject.	self meta: anObject namesMetaClass</body><body package="Store-DB-Subdefs" selector="classNameWithMeta">classNameWithMeta	^className</body><body package="Store-DB-Subdefs" selector="classSymbol">classSymbol 	^self className asClassNameOnly asSymbol</body><body package="Store-DB-Subdefs" selector="definition">definition	^self sourceCode</body><body package="Store-DB-Subdefs" selector="fullClassName">fullClassName	^className</body><body package="Store-DB-Subdefs" selector="implementingClass">implementingClass	^self myClass</body><body package="Store-DB-Subdefs" selector="meta">meta	^meta</body><body package="Store-DB-Subdefs" selector="meta:">meta: aBoolean	meta := aBoolean.	metaString := meta textRepresentation.</body><body package="Store-DB-Subdefs" selector="metaString">metaString	^metaString</body><body package="Store-DB-Subdefs" selector="metaString:">metaString: aString	metaString := aString.	meta := Boolean fromText: aString.</body><body package="Store-DB-Subdefs" selector="methodSources">methodSources	^MethodSourceCollection source: self sourceCode</body><body package="Store-DB-Subdefs" selector="myClass">myClass	"Answer the class containing the receiver. " 	| class |	class := self className asClassNameOnly asStrictReference valueOrDo: [ ^nil ].	^self isMeta 		ifTrue: [ class class]		ifFalse: [ class ]</body><body package="Store-DB-Subdefs" selector="ownerName">ownerName	^className</body><body package="Store-DB-Subdefs" selector="protocol">protocol	^protocolName isNil		ifTrue: [#unknown]		ifFalse: [protocolName asSymbol]</body><body package="Store-DB-Subdefs" selector="protocolName">protocolName	^protocolName</body><body package="Store-DB-Subdefs" selector="protocolName:">protocolName: aString	protocolName := aString</body><body package="Store-DB-Subdefs" selector="selector">selector	^self symbolKey</body><body package="Store-DB-Subdefs" selector="textRepresentationForTag:">textRepresentationForTag: aTag	^self sourceCode</body></methods><methods><class-id>Store.Method</class-id> <category>db-utilities</category><body package="Store-DB-Subdefs" selector="conflictsWithImage">conflictsWithImage	"Answer true if a method with the same selector 	exists in the image."	| class selector |	class := self myClass.	class isNil ifTrue: [^false].	selector := self name asSymbol.	^class includesSelector: selector</body><body package="Store-DB-Subdefs" selector="containingPackages">containingPackages	^[( Methods packagesContainingMethod: self primaryKey )		collect: [ :id | Package aRecordWithID: id ]	]	on: self errorSignals	do: [ :ex | ex outer. OrderedCollection new ].</body><body package="Store-DB-Subdefs" selector="definitionRecord">definitionRecord	"Create a new record in the database that holds the source code."	^self class definitionClass fromString: sourceCodeString</body><body package="Store-DB-Subdefs" selector="diffWithImage">diffWithImage	| aClass selector imgMethod |	aClass := self myClass.	aClass isNil ifTrue: [^Dialog warn: 'The method''s class does not exist in the image.'].	selector := self selector.	(aClass includesSelector: selector)		ifFalse: [^Dialog warn: 'The method does not exist in the image.'].	imgMethod := MethodDescriptor fromSelector: selector className: className meta: self isMeta.	ComparisonBrowser compareMethod: self toMethod: imgMethod."  	TextDifferenceBrowser 		compare: (DBObject sourceCodeAt: selector forClass: aClass)		with: self sourceCode"</body></methods><methods><class-id>Store.Method</class-id> <category>private</category><body package="Store-DB-Subdefs" selector="fileOutOn:">fileOutOn: aSourceCodeStream		| d |	d := Dictionary new.	d at: self protocol put: (Set with: self).	aSourceCodeStream fileOutTTMessages: d for: self className logging: true.</body><body package="Store-DB-Subdefs" selector="invalidClassMessage">invalidClassMessage	^'The method ', self printString, ' cannot be loaded. Class not in image.'</body><body package="Store-DB-Subdefs" selector="prime">prime	super prime.	meta := Object new.</body><body package="Store-DB-Subdefs" selector="processFields">processFields	"Do any necessary data conversions following retrieval"	self metaString: metaString.	"Set meta flag"</body><body package="Store-DB-Subdefs" selector="sameAsSelector:class:">sameAsSelector: aSelector class: aClass 	"Answer true if I'm the same as method aSelector in class aClass."	| protocol key |	protocol := aClass organization categoryOfElement: aSelector.	protocol == nil ifTrue: [ protocol := 'As yet unclassified' ].	aClass isMeta = self isMeta ifFalse: [ ^false ].	self className = aClass absoluteName ifFalse: [ ^false ].	self name = aSelector asString ifFalse: [ ^false ].	self protocolName = protocol asString ifFalse: [^false].	key := self class sourcePointerFor: aSelector inClass: aClass.	key isNil ifTrue: [ ^false ].	^self sourceCode = ( self class sourceCodeAt: aSelector forClass: aClass )</body><body package="Store-DB-Subdefs" selector="unprime">unprime	super unprime.	meta := nil</body></methods><methods><class-id>Store.Method</class-id> <category>comparing</category><body package="Store-DB-Subdefs" selector="comparesTo:">comparesTo: anObject		"Answer true if anObject could be another version of the receiver."	( self objectIsForSelf: anObject ) ifFalse: [ ^false ].	^( anObject selector = self  selector ) and:		[ anObject classNameWithMeta = self classNameWithMeta ]</body><body package="Store-DB-Subdefs" selector="hash">hash	^self className hash + self symbolKey hash</body><body package="Store-DB-Subdefs" selector="objectIsForSelf:">objectIsForSelf: anObject		"Answer true if anObject represents the same kind of thing as the reciever."	^anObject isForMethod</body><body package="Store-DB-Subdefs" selector="quickComparesTo:">quickComparesTo: anObject		"Answer true if anObject could be another version of the receiver."		"For comparing differenct db versions."	self  class == anObject class		ifFalse: [ ^false ].	^( ( self selector = anObject selector )  and:  [ self isMeta = anObject isMeta ] )			and: [ self ownerName = anObject ownerName ]	</body><body package="Store-DB-Subdefs" selector="sameAsImage">sameAsImage	"Answer true if the receiver is the same as the image version."	^self sameAsImThing: self asDescriptor</body><body package="Store-DB-Subdefs" selector="sourceMatches:">sourceMatches: aMethod		"Answer wheter the source matches."	^( self protocol = aMethod protocol 		and: [ self sourceCode equalsAcrossPlatforms: aMethod sourceCode ] )</body></methods><methods><class-id>Store.Method</class-id> <category>change list support</category><body package="Store-DB-Subdefs" selector="systemCategory">systemCategory	"Return the category of the corresponding method the system, if any"	| class |	^( class := self myClass ) == nil		ifFalse: [ class whichCategoryIncludesSelector: self selector ]</body><body package="Store-DB-Subdefs" selector="text">text	"Asnwer the text to display in a text window."	^self definition</body></methods><methods><class-id>Store.Method class</class-id> <category>private-utilities</category><body package="Store-DB-Subdefs" selector="commentFor:in:">commentFor: aSelector in: aClass 	^( aClass compiledMethodAt: aSelector asSymbol ifAbsent: [ ^'' ] ) 		stDocumentation</body><body package="Store-DB-Subdefs" selector="fileOutMethod:">fileOutMethod: aMethod	"Prompt the user for the name of the file-out file; make a reasonable 	suggestion first"	| selector sel fileName fileManager |	aMethod isNil ifTrue: [^self].	(selector := aMethod selector) isKeyword		ifTrue: 			[sel := WriteStream on: (String new: 20).			selector keywords do: [:each | sel nextPutAll: (each copyFrom: 1 to: each size - 1)].			sel := sel contents]		ifFalse: [sel := selector].	fileName := Filename defaultClass suggest: 			(Filename defaultClass filterSeps: aMethod className , '-' , sel , '.st').	fileName := Dialog requestNewFileName: 'File out as' default: fileName.	fileName = '' ifTrue: [^nil].		"File it out"	fileManager := SourceCodeStream  write: fileName.		[fileManager timeStamp.	aMethod fileOutOn: fileManager]		ensure: [fileManager close]</body><body package="Store-DB-Subdefs" selector="moveMethod:">moveMethod: aMethod 	"Ask for destination package and move selector."	| dPkg  selector |	(aMethod isNil or: [aMethod isLoaded not])		ifTrue: [^false].	selector := aMethod selector.	(dPkg := PackageChooser chooseOrAdd) isNil ifTrue: [^false].	XChangeSet current 		moveSelector: selector		class: aMethod myClass		toPackage: dPkg.	^true</body><body package="Store-DB-Subdefs" selector="protocolNameFor:in:">protocolNameFor: aMethod in: aClass 	| protocolName |	protocolName := aClass organization categoryOfElement: aMethod asSymbol.	^protocolName isNil		ifTrue: ['unclassified']		ifFalse: [protocolName asString]</body><body package="Store-DB-Subdefs" selector="simpleSortForLoading:">simpleSortForLoading: methods	"Basic sort methods by class order."	| orderedMethods dict ordered |	dict := Dictionary new.	orderedMethods := OrderedCollection new.		methods do:		[ :meth |		[ ( dict at: meth implementingClass ifAbsentPut: [ OrderedCollection new ] )			add: meth.		] on: UnhandledException do:			[ :exp | 			UnloadableDefinitionError signalWith: meth.			exp return.			].		].	ordered := SystemUtils metaclassesFirst: (SystemUtils sortForLoading: dict keys).	ordered do:		[ :cls | orderedMethods addAll: ( dict at: cls ) ].	^orderedMethods.</body><body package="Store-DB-Subdefs" selector="simpleSortForLoading:package:">simpleSortForLoading: methods package: aPackage	"Basic sort methods by class order, with extension methods last."	| orderedMethods dict ordered definitions extensions absoluteClassNames |	dict := Dictionary new.	orderedMethods := OrderedCollection new.		methods do:		[ :meth |		[ ( dict at: meth implementingClass ifAbsentPut: [ OrderedCollection new ] )			add: meth.		] on: UnhandledException do:			[ :exp | 			UnloadableDefinitionError signalWith: meth.			exp return.			].		].	"Inline the #includesDefinitionOf: test for speed."	#includesDefinitionOf:. "For senders"	absoluteClassNames :=  aPackage classes collect: [ :class | class absoluteName asClassNameOnly ].	definitions := Set new: 23.	extensions := Set new: 23.	dict keys do:		[ :cls | | absoluteName |		absoluteName := cls instanceBehavior absoluteName.		( absoluteClassNames includes: absoluteName )			ifTrue: [ definitions add: cls ]			ifFalse: [ extensions add: cls ]		].	ordered := ( SystemUtils metaclassesFirst: ( SystemUtils sortForLoading: definitions ) )				addAll: ( SystemUtils metaclassesFirst: ( SystemUtils sortForLoading: extensions ) );				yourself.			   		ordered do: [ :cls | orderedMethods addAll: ( dict at: cls ) ].	^orderedMethods.</body><body package="Store-DB-Subdefs" selector="sortForLoading:">sortForLoading: aCollectionOfDBMethods	"Make sure that all method that contain c type 	declaration are moved to the front."	| cmeths other |	cmeths := aCollectionOfDBMethods select: [ :meth | meth version = 'CTYPE' ].	other := aCollectionOfDBMethods select: [ :meth | ( meth version = 'CTYPE' ) not ].	^( self simpleSortForLoading: cmeths )		addAll: ( self simpleSortForLoading: other );		yourself</body><body package="Store-DB-Subdefs" selector="sortForLoading:package:">sortForLoading: aCollectionOfDBMethods package: aPackage	"Make sure that all method that contain c type declaration 	are moved to the front and extenstion methods are moved to the end."	| cmeths other |	cmeths := aCollectionOfDBMethods select: [ :meth | meth version = 'CTYPE' ].	other := aCollectionOfDBMethods select: [ :meth | ( meth version = 'CTYPE' ) not ].	^( self simpleSortForLoading: cmeths )		addAll: ( self simpleSortForLoading: other package: aPackage );		yourself</body><body package="Store-DB-Subdefs" selector="sourcePointerFor:inClass:">sourcePointerFor: aSelector inClass: aClass	| method |	method := aClass compiledMethodAt: aSelector.	^method sourcePointer</body></methods><methods><class-id>Store.Method class</class-id> <category>instance creation</category><body package="Store-DB-Subdefs" selector="allMethodVersionsNamed:inClass:meta:">allMethodVersionsNamed: aName inClass: className meta: isMeta	| dbMethods cname |	cname := ( isMeta and: [ className namesMetaClass not ] )		ifTrue: [ className, ' class' ] 		ifFalse: [ className ].	dbMethods := [self processList: 						(self broker  process: 							( self newSQL								selectAll;								where;								column: #name equalTo: aName asString printString;								and;								column: #className equalTo: cname asString printString)						bindOutput: Method newPrimed).	] 	on: self  errorSignals	do: 	[ :ex |  ex outer.			 ( Method table select: [:each | each name = aName asString] )  				select: [:each | each className = className asString] 		].	^dbMethods asSortedCollection: [ :x :y | x primaryKey &gt; y primaryKey ].</body><body package="Store-DB-Subdefs" selector="fromClass:named:timeStamp:trace:">fromClass: class named: aName timeStamp: timeStamp trace: oldDBMethod 	^(self new) name: aName asString;		 timeStamp: timeStamp; 		className: class absoluteName;		meta: class isMeta;		protocolName: (self protocolNameFor: aName in: class); 		sourceCode: (self sourceCodeAt: aName forClass: class);		setTrace: oldDBMethod</body><body package="Store-DB-Subdefs" selector="fromView:">fromView: aMethodView 	| aMethod |	aMethod := self new.	aMethod primaryKey: aMethodView primaryKey;			name: aMethodView name;			meta: aMethodView isMeta;			timeStamp: aMethodView timeStamp;			version: aMethodView version;			userName: aMethodView userName;			dbTrace: aMethodView dbTrace;			className: aMethodView className;			sourceCodeID: aMethodView sourceCodeID;			protocolName: aMethodView protocolName;			processFields.	^aMethod</body><body package="Store-DB-Subdefs" selector="psuedoRecordFor:inClassNamed:">psuedoRecordFor: aSelector inClassNamed: className	^(self new) name: aSelector asString;		protocolName: '*removed*';		className: className asString;		sourceCode: 'Deleted method'.</body></methods><methods><class-id>Store.Method class</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="associationClass">associationClass	^Methods</body><body package="Store-DB-Subdefs" selector="columnNames">columnNames	| columnNames |	columnNames := super columnNames.	columnNames 		remove: 'sourceCodeString';		remove: 'creatorPackageVersion';		remove: 'creatorPackage';		remove: 'meta';		yourself.	^columnNames</body><body package="Store-DB-Subdefs" selector="defaultBlockFactor">defaultBlockFactor	^1000</body><body package="Store-DB-Subdefs" selector="referenceColumn">referenceColumn	^#methodRef</body><body package="Store-DB-Subdefs" selector="sourcesViewClass">sourcesViewClass	^MethodsAndSourcesView</body></methods><methods><class-id>Store.Method class</class-id> <category>performance tuning</category><body package="Store-DB-Subdefs" selector="createMethodRetrievalIndex">createMethodRetrievalIndex	"self createMethodRetrievalIndex"	self broker createIndexForClass: self 				index: 'TT_MethodRetrievalIndex' 				columns: (Array with: 'name' with: 'className').</body><body package="Store-DB-Subdefs" selector="dropMethodRetrievalIndex">dropMethodRetrievalIndex	"self dropMethodRetrievalIndex"	self broker dropIndexForClass: self 				index: 'TT_MethodRetrievalIndex' .</body></methods><methods><class-id>Store.Method class</class-id> <category>db-utilities</category><body package="Store-DB-Subdefs" selector="allNamesMatching:in:">allNamesMatching: aString in: cname	"Wildcard search within a class"	"Method allNamesMatching: 'a*' in: 'Root.Smalltalk.Core.Object'"	| answer |	answer := 		[ self broker process:			( self newSQL 				selectDistinct: #( name );				where;				column: #name wildcard: aString printString;				and;				column: #className equalTo: cname asString printString			 ) 		] on: self  errorSignals  do: [:ex |  ex outer. ^#() ].	^answer isEmpty		ifTrue: [ answer ]		ifFalse: [ answer collect: [ :array | array first ] ].</body><body package="Store-DB-Subdefs" selector="chooseAvailableMethodMatching:in:">chooseAvailableMethodMatching: aString in: aClass	"Wildcard search and select for methods not currently in the image for a particular class"	"Method chooseAvailableMethodMatching: '*' in: Store.Method "	| list names |	( list := self allNamesMatching: aString in: aClass absoluteName ) isEmpty		ifTrue: [ ^Dialog warn: 'No selectors matching ', aString ].	names := list reject: [:each | aClass includesSelector: each asSymbol ].	names isEmpty		ifTrue: [ ^Dialog warn: 'No removed methods in ', aClass fullName ].	^SimpleDialog new		chooseMultiple: 'Choose selectors...'		fromList: names		values: names		buttons: #()		values: #()		lines: 12		cancel: nil		for: nil</body><body package="Store-DB-Subdefs" selector="classNamesInPackages:">classNamesInPackages: pkgIds	| allClasses |	pkgIds isEmpty		ifTrue: [ ^OrderedCollection new ].	allClasses := self broker process:		( self newSQL  classNamesInPackages: pkgIds	).	^( allClasses collect: [ :array | array first asClassNameOnly ] ) asSet</body><body package="Store-DB-Subdefs" selector="selectVersionNamed:in:meta:">selectVersionNamed: aName in: ownerName meta: aBoolean	| list |	list := self allMethodVersionsNamed: aName inClass: ownerName meta: aBoolean.	list isEmpty		ifTrue: [ Dialog warn: 'No prior versions'. ^nil ].	list size == 1		ifTrue: [ ^list first ].	 ^Dialog 		choose: 'Choose version...'		fromList: ( list collect: [ :m | m itemString ] ) values: list		lines: 10 cancel: [ ^nil ]		for: nil.</body></methods><methods><class-id>Store.Method class</class-id> <category>private</category><body package="Store-DB-Subdefs" selector="fromDescription:trace:package:">fromDescription: methodDescription trace: oldDBMethod package: aDBPackage	| newDbMethod variableAssociation cls selector |	cls := methodDescription owner.	selector := methodDescription selector asString.	newDbMethod := self new 		name: selector;		timeStamp: self timeStamp; 		className: cls absoluteName;		meta: methodDescription isMeta;		protocolName: methodDescription protocol; 		sourceCode: methodDescription sourceCode;		setTrace: oldDBMethod;		yourself.	oldDBMethod notNil 		ifTrue:			[ ( oldDBMethod sourceCode = newDbMethod sourceCode  )				ifTrue: [ newDbMethod sourceCodeID: oldDBMethod sourceCodeID ].			].	newDbMethod creatorPackage: aDBPackage primaryKey.	newDbMethod install.	( cls isKindOf: ExternalInterface class )		ifTrue: 			[ ( ( variableAssociation := ( cls compiledMethodAt: selector asSymbol ) returnsStaticVariable ) notNil 					and: [ variableAssociation value isKindOf: CType ] 			  )				ifTrue: [ newDbMethod setVersionTo: 'CTYPE' ]		].	^newDbMethod</body><body package="Store-DB-Subdefs" selector="newNamed:inClass:trace:package:">newNamed: aName inClass: class trace: oldDBMethod package: aDBPackage 	| newDBMethod variableAssociation |	"Transcript show: 'Creating new method: ' , class name, '&gt;&gt;', aName; cr; flush."	newDBMethod := self				fromClass: class				named: aName				timeStamp: self timeStamp				trace: oldDBMethod.	(oldDBMethod notNil and: [oldDBMethod sourceCode = newDBMethod sourceCode])		ifTrue: [newDBMethod sourceCodeID: oldDBMethod sourceCodeID].	newDBMethod creatorPackage: aDBPackage primaryKey.	newDBMethod install.	(class isKindOf: ExternalInterface class)		ifTrue: [((variableAssociation := (class compiledMethodAt: aName asSymbol) returnsStaticVariable) notNil and: [variableAssociation value isKindOf: CType])				ifTrue: [newDBMethod setVersionTo: 'CTYPE']].	^newDBMethod</body><body package="Store-DB-Subdefs" selector="recordFromDescription:trace:package:">recordFromDescription: methodDescription trace: oldDBMethod package: aDBPackage 	"Answer a record for aMethod. If the trace is identical as aMethod 	answer the trace instead creating a new record."	^oldDBMethod isNil		ifTrue: 			[ self				fromDescription: methodDescription				trace: nil				package: aDBPackage			]		ifFalse: 			[ ( oldDBMethod sameAsSelector: methodDescription selector class: methodDescription owner )				ifTrue: [ oldDBMethod ]				ifFalse: 					[ self						fromDescription: methodDescription						trace: oldDBMethod						package: aDBPackage					]			]</body><body package="Store-DB-Subdefs" selector="recordNamed:inClass:trace:package:">recordNamed: aMethod inClass: class trace: oldDBMethod package: aDBPackage 	"Answer a record for aMethod. If the trace is identical as aMethod 	answer the trace instead creating a new record."	^oldDBMethod isNil		ifTrue: [self				newNamed: aMethod				inClass: class				trace: nil				package: aDBPackage]		ifFalse: [(oldDBMethod sameAsSelector: aMethod class: class)				ifTrue: [oldDBMethod]				ifFalse: [self						newNamed: aMethod						inClass: class						trace: oldDBMethod						package: aDBPackage]]</body></methods><methods><class-id>Store.Method class</class-id> <category>installation</category><body package="Store-DB-Subdefs" selector="fieldTypes">fieldTypes	| aDict  |	aDict := super fieldTypes.	aDict at: 'sourceCodeID' put: #Integer.	self checkFieldsWith: aDict.	^aDict</body><body package="Store-DB-Subdefs" selector="indexParameters">indexParameters	"Answer a string specifying index parameters. If the default index is acceptable 	answer nil."	^'TABLESPACE NEWBERN2 STORAGE(INITIAL 1M NEXT 256K) '</body><body package="Store-DB-Subdefs" selector="storageParameters">storageParameters	"Answer a string describing special storage parameters for the table or nil if the default parameters are 	acceptable answer."	^'STORAGE(INITIAL 5M NEXT 512K PCTINCREASE 1) '</body></methods><methods><class-id>Store.Method class</class-id> <category>private-garbage-collection</category><body package="Store-DB-Subdefs" selector="createIndex">createIndex 	"Create index on methodRef to speed up	garbage collection process."	^self broker createIndexForClass: self.</body><body package="Store-DB-Subdefs" selector="dropIndex">dropIndex 	"Drop index on methodRef to speed up	garbage collection process."	^self broker dropIndexForClass: self.</body><body package="Store-DB-Subdefs" selector="indexColumnNames">indexColumnNames	^ Array with: 'sourceCodeID'</body><body package="Store-DB-Subdefs" selector="indexName">indexName	^ '_DEF_IDX '</body><body package="Store-DB-Subdefs" selector="methodsReferingToDefinitionID:">methodsReferingToDefinitionID: aDefinitionID 	"Collect TT_Methods that 	refer to a given definition record. 	Answer a collection of IDs."	"self methodsReferingToDefinitionID: 154335"	|ids|	ids := self broker process: 					( self newSQL							select: #( primaryKey );							where;							column: #sourceCodeID equalTo: aDefinitionID printString).	^ids collect: [:each| each first]</body></methods><methods><class-id>Store.FileRecord</class-id> <category>downloading</category><body package="Store-DB-Pundles" selector="download">download	"Download the file. Answer wheter we did so successfully"	| filename stream blob |	( blob := self fileData ) == nil		ifTrue: [ 				Dialog warn: (#IsEmpty &lt;&lt; #store &gt;&gt; '&lt;1s&gt; is empty' expandMacrosWith: self filename). 				^false				].	filename := self filename asFilename.	( filename := self validateFilenameForDownload: filename ) == nil		ifTrue: [ ^false ].	stream := filename writeStream binary.	[ stream nextPutAll: blob rawData ] 			ensure: [ stream close ].	^true.</body><body package="Store-DB-Pundles" selector="validateFilenameForDownload:">validateFilenameForDownload: aFilename	"Validate that a file can be written. Answer the filename to be used."		| filename |	filename := aFilename.	[ filename canBeWritten ]		whileFalse: 			[ filename := 				( Dialog 					request: 'Please enter a valid filename for this platform'					initialAnswer: filename asString					onCancel: [ ^nil ]				  ) asFilename				 ].	^filename</body></methods><methods><class-id>Store.FileRecord</class-id> <category>support</category><body package="Store-DB-Pundles" selector="processFields">processFields	super processFields.	self revertBinaryData</body><body package="Store-DB-Pundles" selector="textForItem">textForItem	^name</body></methods><methods><class-id>Store.FileRecord</class-id> <category>accessing</category><body package="Store-DB-Pundles" selector="asDescriptor">asDescriptor	^( self descriptionClass from: self filename asString )		dbTrace: primaryKey;		name: self filename;		yourself</body><body package="Store-DB-Pundles" selector="components">components	^components</body><body package="Store-DB-Pundles" selector="components:">components: collection	components := collection</body><body package="Store-DB-Pundles" selector="descriptionClass">descriptionClass	^FileModel</body><body package="Store-DB-Pundles" selector="fileData">fileData	"Allow for lazy evaluation."	fileData == nil		ifTrue: [ fileData := self class definitionClass aRecordWithID: fileID ].	^fileData</body><body package="Store-DB-Pundles" selector="fileData:">fileData: byteArray	^fileData := byteArray</body><body package="Store-DB-Pundles" selector="fileID">fileID	^fileID</body><body package="Store-DB-Pundles" selector="fileID:">fileID: anInteger	fileID := anInteger</body><body package="Store-DB-Pundles" selector="filename">filename	^components == nil		ifTrue: [ nil ]		ifFalse: [ LogicalFilename fromComponents: components ].</body><body package="Store-DB-Pundles" selector="fileSize">fileSize	^fileSize</body><body package="Store-DB-Pundles" selector="fileSize:">fileSize: anInteger	fileSize := anInteger</body><body package="Store-DB-Pundles" selector="name:">name: aString	name := aString asString.	self timeStamp: self class timeStamp.</body></methods><methods><class-id>Store.FileRecord</class-id> <category>private</category><body package="Store-DB-Pundles" selector="convertBinaryData">convertBinaryData	"Before storing the record into the database, we first have to convert the components of the 	 filename into BOSS data."		components := self encode: components.</body><body package="Store-DB-Pundles" selector="prepareInstallation">prepareInstallation	"Create records for the file data."	| filename |	( filename := self filename ) == nil		ifTrue: [ ^self ].	self fileID isNil		ifTrue: 			[ 			fileSize := filename fileSize.			fileData := filename asFilename contentsOfEntireBinaryFile.			self fileID: ( self class definitionClass fromRawData: self fileData ) primaryKey 			].</body><body package="Store-DB-Pundles" selector="prime">prime	"Put instances of Object into slots that are not mapped into columns in the DB.	This is crucial for reading from DB since the primed slots are skipped"	super prime.	fileData := Object new.</body><body package="Store-DB-Pundles" selector="revertBinaryData">revertBinaryData	"Once the record has been stored into the database, revert the components back from the BOSS object."	components := self decode: components.</body><body package="Store-DB-Pundles" selector="unprime">unprime	"Remove the effect of priming (see the prime method)."	super unprime.	fileData := nil.</body></methods><methods><class-id>Store.FileRecord</class-id> <category>private-utilities</category><body package="Store-DB-Pundles" selector="installInDatabase">installInDatabase	"Create a corresponding record in the database."	self preDatabaseInstall.		[self convertBinaryData.	self broker process: self installSqlString bindInput: self] 			ensure: [self revertBinaryData].	self postDatabaseInstall</body></methods><methods><class-id>Store.FileRecord class</class-id> <category>constants</category><body package="Store-DB-Pundles" selector="componentMark">componentMark	^'F'</body><body package="Store-DB-Pundles" selector="componentNotFoundSignal">componentNotFoundSignal	"Answer a signal for a component not found error."	"Place holder in case we decide to do file specific stuff later."	^Pundle componentNotFoundSignal</body><body package="Store-DB-Pundles" selector="definitionClass">definitionClass	^BinaryBlob</body><body package="Store-DB-Pundles" selector="partClass">partClass	^Files</body></methods><methods><class-id>Store.FileRecord class</class-id> <category>installation</category><body package="Store-DB-Pundles" selector="columnNames">columnNames	"self columnNames"	^super columnNames		remove: 'fileData';		yourself</body><body package="Store-DB-Pundles" selector="fieldTypes">fieldTypes	"self fieldTypes "	| dict |	dict := super fieldTypes		at: 'fileID' put: #Integer;		at: 'fileSize' put: #Integer;		at: 'components' put: #BinData;		yourself.	self checkFieldsWith: dict.	^dict.</body><body package="Store-DB-Pundles" selector="needsSequence">needsSequence	^true</body></methods><methods><class-id>Store.FileRecord class</class-id> <category>instance creation</category><body package="Store-DB-Pundles" selector="fromPortableFilename:">fromPortableFilename: aPortableFilename	^self new		components: aPortableFilename componentStrings;		name: (aPortableFilename asString);		yourself</body><body package="Store-DB-Pundles" selector="newFrom:">newFrom: aFileModel	"Given a fileModel create a new instance of the receiver.		This is a private method used by all public methods that store files in the database."	| newDBFile |	newDBFile := self fromPortableFilename: aFileModel portableFilename.	^newDBFile</body><body package="Store-DB-Pundles" selector="newFrom:userData:">newFrom: aFileModel userData: userData	"Create a new instance of a FileRecord and install it in DB."	| newDBFile res transaction | 	newDBFile := self newFrom: aFileModel.	transaction := 		[ newDBFile install.		newDBFile		].	MessageNotification raiseSignal:  ( 'file &lt;1s&gt;' expandMacrosWith: aFileModel name ).	ResetIncrementNotification signalWith: 1.	res := self broker publishTransaction: transaction.	res notNil  "Sources are safe in DB"		ifTrue: 			[ aFileModel dbTrace: newDBFile primaryKey."			aFileModel markNotModified.  "			].	^res</body></methods><methods><class-id>Store.Blessing</class-id> <category>support</category><body package="Store-DB-BaseObjects" selector="prime">prime	"Fill slots that do not map to table columns with instances of Object"	commentString := Object new.</body><body package="Store-DB-BaseObjects" selector="unprime">unprime	"Nil out the slots that do not map to table columns"	commentString := nil.</body></methods><methods><class-id>Store.Blessing</class-id> <category>private-db</category><body package="Store-DB-BaseObjects" selector="installSqlString">installSqlString	"Column names must be String, for consistency with #columnNames"	^ self newSQL		insertColumnsValues:  #( 'primaryKey' 'timeStamp' 'userName' 'commentID' 'blessingLevel' 'trace' 'pkgID' 'recType' ).</body><body package="Store-DB-BaseObjects" selector="postDatabaseInstall">postDatabaseInstall	(self primaryKey isNil ) ifTrue: [self primaryKey: self nextID].</body><body package="Store-DB-BaseObjects" selector="preDatabaseInstall">preDatabaseInstall	"Create record for comment string, if necessary."	self commentID isNil ifTrue: [self commentID: (self class definitionClass fromString: commentString) primaryKey].	"Set primary key and user name."	(self class needsSequenceFor: self class) ifTrue: [self primaryKey: self nextID].	self userName: self currentUserName.</body><body package="Store-DB-BaseObjects" selector="processFields">processFields	"Do any necessary data conversions following retrieval"	self commentString notNil ifTrue: [		self commentString: (self processString: self commentString)]</body></methods><methods><class-id>Store.Blessing</class-id> <category>printing</category><body package="Store-DB-BaseObjects" selector="descriptionString">descriptionString		| ws |	ws := WriteStream on: String new. 	ws nextPutAll: 'Blessed by: ';	 	nextPutAll: self userNameString;		nextPutAll: ' at level: ';		nextPutAll: self blessingLevelString;		nextPutAll: ' on: ';		nextPutAll: self timeStampString;		cr;		nextPutAll: self getCommentString;		cr.	^ws contents</body></methods><methods><class-id>Store.Blessing</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="blessingLevel">blessingLevel	"Answer the receiver's blessingLevel."	^blessingLevel</body><body package="Store-DB-BaseObjects" selector="blessingLevel:">blessingLevel: newBlessingLevel	"Set the receiver's blessingLevel to newBlessingLevel."	blessingLevel := newBlessingLevel</body><body package="Store-DB-BaseObjects" selector="blessingLevelString">blessingLevelString	| bNbr |	bNbr := blessingLevel isNil ifTrue: [0] ifFalse: [blessingLevel].	^Policies blessingPolicy blessingName: bNbr</body><body package="Store-DB-BaseObjects" selector="commentID">commentID	"Answer the receiver's commentID."	^commentID</body><body package="Store-DB-BaseObjects" selector="commentID:">commentID: newCommentID	"Set the receiver's commentID to newCommentID."	commentID := newCommentID</body><body package="Store-DB-BaseObjects" selector="commentString">commentString	"Answer the receiver's commentString."	^commentString</body><body package="Store-DB-BaseObjects" selector="commentString:">commentString: newCommentString	"Set the receiver's commentString to newCommentString."	commentString := newCommentString</body><body package="Store-DB-BaseObjects" selector="dbTrace">dbTrace	"Answer the receiver's trace."	^trace</body><body package="Store-DB-BaseObjects" selector="dbTrace:">dbTrace: newTrace	"Set the receiver's trace to newTrace."	trace := newTrace</body><body package="Store-DB-BaseObjects" selector="getCommentString">getCommentString	| defClass |	commentString == nil		ifTrue: 			[  ( defClass := self class definitionClass aRecordWithID: self commentID ) isNil				ifTrue: [  self commentString: String new]				ifFalse: [ self commentString: defClass  definition ]			].	^commentString</body><body package="Store-DB-BaseObjects" selector="pkgID">pkgID	"Answer the receiver's pkgID."	^pkgID</body><body package="Store-DB-BaseObjects" selector="pkgID:">pkgID: newPkgID	"Set the receiver's pkgID to newPkgID."	pkgID := newPkgID</body><body package="Store-DB-BaseObjects" selector="primaryKey">primaryKey	"Answer the receiver's primaryKey."	^primaryKey</body><body package="Store-DB-BaseObjects" selector="primaryKey:">primaryKey: newPrimaryKey	"Set the receiver's primaryKey to newPrimaryKey."	primaryKey := newPrimaryKey</body><body package="Store-DB-BaseObjects" selector="recType">recType	"Answer the receiver's recType."	^recType</body><body package="Store-DB-BaseObjects" selector="recType:">recType: newRecType	"Set the receiver's recType to newRecType."	recType := newRecType</body><body package="Store-DB-BaseObjects" selector="timeStamp">timeStamp	"Answer the receiver's timeStamp."	^timeStamp</body><body package="Store-DB-BaseObjects" selector="timeStamp:">timeStamp: newTimeStamp	"Set the receiver's timeStamp to newTimeStamp."	timeStamp := newTimeStamp</body><body package="Store-DB-BaseObjects" selector="trace">trace	"Answer the receiver's trace."	^trace</body><body package="Store-DB-BaseObjects" selector="trace:">trace: newTrace	"Set the receiver's trace to newTrace."	trace := newTrace</body><body package="Store-DB-BaseObjects" selector="userName">userName	"Answer the receiver's userName."	^userName</body><body package="Store-DB-BaseObjects" selector="userName:">userName: newUserName	"Set the receiver's userName to newUserName."	userName := newUserName</body><body package="Store-DB-BaseObjects" selector="userNameString">userNameString	^userName isNil		ifTrue: ['Unknown']		ifFalse: [userName]</body></methods><methods><class-id>Store.Blessing class</class-id> <category>installation</category><body package="Store-DB-BaseObjects" selector="fieldTypes">fieldTypes	| aDict |	aDict := Dictionary new.	aDict at: 'primaryKey' put: #PrimaryKey.	aDict at: 'timeStamp' put: #Integer.	aDict at: 'pkgID' put: #Integer.	aDict at: 'trace' put: #Integer.	aDict at: 'commentID' put: #Integer.	aDict at: 'blessingLevel' put: #Integer.	self checkFieldsWith: aDict.	^aDict</body><body package="Store-DB-BaseObjects" selector="needsSequence">needsSequence	^true</body><body package="Store-DB-BaseObjects" selector="storageParameters">storageParameters	"Answer a string describing special storage parameters for the table or nil if the default parameters are 	acceptable answer."	^'STORAGE(INITIAL 1M NEXT 100K PCTINCREASE 1) '</body></methods><methods><class-id>Store.Blessing class</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="columnNames">columnNames	| columnNames |	columnNames := super columnNames.	columnNames remove: 'commentString'.	^columnNames</body><body package="Store-DB-BaseObjects" selector="typeStringForBundles">typeStringForBundles	^'B'</body><body package="Store-DB-BaseObjects" selector="typeStringForPackages">typeStringForPackages	^'P'</body></methods><methods><class-id>Store.Blessing class</class-id> <category>db-utilities</category><body package="Store-DB-BaseObjects" selector="aRecordWithID:">aRecordWithID: anID 	"Get a DB record identified by 'anID' from the DB."	"self aRecordWithID: 1"	| dbPkgs |	anID = 0 ifTrue: [ ^nil ].	dbPkgs := [ self processList: 						(self broker process: 							( self newSQL								selectAll;								where;								column: #primaryKey equalTo: anID printString)				bindOutput: self newPrimed)	]	on:  self errorSignals	do: [ :ex |  ex outer.			self table select: [ :each | each primaryKey = anID]		].	^dbPkgs isEmpty		ifTrue: [ nil ]		ifFalse: [ dbPkgs first ]</body><body package="Store-DB-BaseObjects" selector="blessingHistoryForPackageID:">blessingHistoryForPackageID: anID 	"Answer a formattted string containing blessing history for 	a given package."	"self blessingHistoryForPackageID: 1"	| records |	anID = 0 ifTrue: [^nil].	DbRegistry isOnlineImage		ifFalse: [ ^'unknown' ].		"not important enough for a dialog."	records := self blessingsForPackageID: anID.	^Policies blessingPolicy describeBlessings: records.</body><body package="Store-DB-BaseObjects" selector="blessingHistoryForPundle:">blessingHistoryForPundle: aPundle 	"Answer a formattted string containing blessing history for a given pundle."	aPundle primaryKey = 0 ifTrue: [ ^nil ].	self isOnline		ifFalse: [ ^'unknown' ].	^[Policies blessingPolicy describeBlessings: 			(self blessingsForRecordID: aPundle primaryKey 						type: aPundle typeStringForBlessing).	] 	on: self errorSignals 	do: [ :ex | 'unknown' ].</body><body package="Store-DB-BaseObjects" selector="blessingsForPackageID:">blessingsForPackageID: anID 	"Get a sorted collection DB records which define belssing levels for a package.	Sort the collection is descending order of primary key."	"self blessingsForPackageID: 3"	^self blessingsForRecordID: anID type: self typeStringForPackages</body><body package="Store-DB-BaseObjects" selector="blessingsForRecordID:type:">blessingsForRecordID: anID type: aRecordTypeString 	"Get a sorted collection DB records which define belssing levels for a package 	or a bundle. Sort the collection is descending order of primary key."	"self blessingsForRecordID: 3 type: self typeStringForPackages"	| inputObject |	inputObject := self newPrimed.	inputObject pkgID: anID; recType: aRecordTypeString.	anID = 0 ifTrue: [^nil].	^[( self processList:			( self broker process: 					(self newSQL						selectAll;						where;						column: #pkgID equalTo: ':pkgID';						and;						column: #recType equalTo: ':recType')				bindInput: inputObject				bindOutput: self newPrimed)		)  asSortedCollection: [ :x :y | x primaryKey &gt; y primaryKey ]	]	on:  self  errorSignals	do: [ :ex | ex outer.			OrderedCollection new ].</body><body package="Store-DB-BaseObjects" selector="definitionClass">definitionClass		^Blob</body></methods><methods><class-id>Store.Blessing class</class-id> <category>instance creation</category><body package="Store-DB-BaseObjects" selector="forPundle:withLevel:andComment:">forPundle: aDBPundle withLevel: aBlessingLevel andComment: aString 	| aThing |	aThing := self new.	aThing commentString: aString asString;			pkgID: aDBPundle primaryKey; 			blessingLevel: aBlessingLevel; 			timeStamp: self timeStamp; 			recType: aDBPundle typeStringForBlessing.	self broker publishTransaction: [		aThing install.		aDBPundle updateBlessing: aBlessingLevel]. 	^aThing</body></methods><methods><class-id>Store.Blessing class</class-id> <category>private-garbage-collection</category><body package="Store-DB-BaseObjects" selector="attachedToPundle:">attachedToPundle: aPundle 	"Answer a collection of blessing records that are attached to a given pundle"	^self blessingsForRecordID: aPundle primaryKey type: aPundle typeStringForBlessing</body><body package="Store-DB-BaseObjects" selector="removeAllAttachedToPackageID:">removeAllAttachedToPackageID: aPackageID 	"Remove any record from the table which references aPackageID.	Note that this method can only be sent by the database	system administrator, since it requires privileges	that are not given to the regular users."	self deleteWhereColumn:  #pkgID value: aPackageID printString.</body><body package="Store-DB-BaseObjects" selector="removeAllAttachedToPundle:">removeAllAttachedToPundle: aPundle 	"Remove any record from the table which references aPundle.	Note that this method can only be sent by the database system administrator, 	since it requires privileges that are not given to the regular users."	self broker process:			( self newSQL				delete;				where;				column: #pkgID equalTo: aPundle primaryKey printString;				and;				column: #recType equalTo: aPundle typeStringForBlessing printString)</body></methods><methods><class-id>Store.ViewRecord class</class-id> <category>session</category><body package="Store-DB-BaseObjects" selector="createAllInButNotInSession">createAllInButNotInSession	"Answers all the records in one package, but not the other."	"Called by concrete subclasses."		| sql sqlAssist |	( sqlAssist := self newSQL )		selectAll;		where;		column: #primaryKey equalTo: ':1';		and;		column: #primaryKey notEqualTo: ':2'.			sql := ( self columnNames includes: 'definitionOrder' )		ifTrue: [ sqlAssist orderBy:  #definitionOrder ]		ifFalse: [ sqlAssist sqlString ].	^( self class		process: sql		bindOutput: self class newPrimed	) collect: [ :each | self  fromView: each]</body><body package="Store-DB-BaseObjects" selector="createSourcesSession">createSourcesSession	"Answer a sources session for the receiver."	"Called by concrete subclasses that have a sources view to initialize."		| sql sqlAssist |	( sqlAssist := self newSQL )		selectAll;		where;		column: #packageRef equalTo: ':primaryKey'.	sql := ( self columnNames includes: 'definitionOrder' )		ifTrue: [ sqlAssist orderBy:  #definitionOrder ]		ifFalse: [ sqlAssist sqlString ].				^self broker getNewSession		blockFactor: self blockFactor;		bindOutput: self newPrimed;		bindInput: self new;		prepare: sql;		yourself.</body><body package="Store-DB-BaseObjects" selector="defaultBlockFactor">defaultBlockFactor	^8</body></methods><methods><class-id>Store.ViewRecord class</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="definitionReferenceColumn">definitionReferenceColumn	"Answer the column symbol of the column that contains the definition id."	^#definitionID</body></methods><methods><class-id>Store.ViewRecord class</class-id> <category>queries</category><body package="Store-DB-BaseObjects" selector="allInPackages:">allInPackages: pkgList	"Send only to a concrete subclass that implements #referencedClass and has a packageRef column.	Answer the referenced class instances defined in any the packages in the list"	"PkgClassesView allInPackages: ( Bundle newestVersionWithName: 'StoreBase' ) leafItems"	| views |	pkgList isEmpty		ifTrue: [ ^OrderedCollection new ].	views := self processList:		( [ self broker process:			( self newSQL				selectAll;				where;				column: #packageRef equalToArray: ( pkgList collect: [ :pkg | pkg primaryKey printString ] ) )			bindOutput: self newPrimed		] on: self errorSignals 			do: 	[ :ex | ex outer. ^OrderedCollection new ]	).	^views collect: [ :v | self referencedClass fromView: v ]</body><body package="Store-DB-BaseObjects" selector="recordsWithSourcesIn:">recordsWithSourcesIn: aPackage	"Answers all instances of the receiver's #referencedClass records."	"Send only to a concrete sources view subclass."	| dbRecords | 	^[ dbRecords := self broker 						getAnswerFromSession: [ self sourcesSession ]						bindInput: [ :session | session bindInput primaryKey: aPackage primaryKey].	dbRecords asOrderedCollection collect: [ :each | self referencedClass fromSourcesView: each ].	] on: self  errorSignals do: [ :ex | ^OrderedCollection new ].</body><body package="Store-DB-BaseObjects" selector="recordsWithSourcesIn:butNotIn:">recordsWithSourcesIn:  aPrimaryKey butNotIn: bPrimaryKey	"Answer all instances of the receiver's referenced class contained 	in aPackage, but not in bPackage. Used to compute package updates."	"Send to a concrete subclass that implemelments:		#referencedClass, #childReference and #subCollectionClass"	| sql sqlAssist |	( sqlAssist := self newSQL ) recordsWithSourcesIn:  aPrimaryKey butNotIn: bPrimaryKey.		sql := ( self columnNames includes: 'definitionOrder' )		ifTrue: [ sqlAssist orderBy:  #definitionOrder ]		ifFalse: [ sqlAssist sqlString ].	^( self broker		process: sql		bindOutput: self newPrimed	) collect: [ :each | self referencedClass fromSourcesView: each ]</body></methods><methods><class-id>Store.PkgNameSpacesView</class-id> <category>private</category><body package="Store-DB-Records" selector="prime">prime	super prime.	version := Object new.</body><body package="Store-DB-Records" selector="unprime">unprime	super unprime.	version := nil.</body></methods><methods><class-id>Store.PkgNameSpacesView</class-id> <category>accessing</category><body package="Store-DB-Records" selector="commentID">commentID	^commentID</body><body package="Store-DB-Records" selector="commentID:">commentID: aValue	commentID := aValue</body><body package="Store-DB-Records" selector="definitionID">definitionID	^definitionID</body><body package="Store-DB-Records" selector="definitionID:">definitionID: aValue	definitionID := aValue</body><body package="Store-DB-Records" selector="definitionOrder">definitionOrder	"Answer the receiver's definitionOrder."	^definitionOrder</body><body package="Store-DB-Records" selector="definitionOrder:">definitionOrder: anInteger	"Set the receiver's definitionOrder."	definitionOrder := anInteger</body><body package="Store-DB-Records" selector="environmentString">environmentString	^environmentString</body><body package="Store-DB-Records" selector="environmentString:">environmentString: aValue	environmentString := aValue</body><body package="Store-DB-Records" selector="packageRef">packageRef	^packageRef</body><body package="Store-DB-Records" selector="packageRef:">packageRef: anObject	packageRef := anObject</body></methods><methods><class-id>Store.PkgNameSpacesView class</class-id> <category>installation</category><body package="Store-DB-Records" selector="childReference">childReference	^'nameSpaceRef'</body><body package="Store-DB-Records" selector="parentReference">parentReference	^'packageRef'</body><body package="Store-DB-Records" selector="referencedClass">referencedClass	^NameSpaceRecord</body><body package="Store-DB-Records" selector="subCollectionClass">subCollectionClass	^PkgNameSpaces</body></methods><methods><class-id>Store.PkgNameSpacesView class</class-id> <category>session</category><body package="Store-DB-Records" selector="nameSpacesSession">nameSpacesSession	"NameSpacesSession := nil"	( self isSessionValid: NameSpacesSession)		ifFalse:			[NameSpacesSession := self broker getNewSession.			NameSpacesSession bindOutput: self newPrimed.			NameSpacesSession bindInput: NameSpaceRecord new.			NameSpacesSession prepare: 						(self newSQL							selectAll;							where;							column: #packageRef  equalTo: ':primaryKey';							orderBy: #definitionOrder) ].	^NameSpacesSession</body><body package="Store-DB-Records" selector="resetSession">resetSession	NameSpacesSession notNil		ifTrue: 			[ self brokerOrNil notNil 				ifTrue: [ self broker dismissSession: NameSpacesSession ].			NameSpacesSession := nil			]</body></methods><methods><class-id>Store.PkgNameSpacesView class</class-id> <category>accessing</category><body package="Store-DB-Records" selector="columnNames">columnNames		"self columnNames"	| columnNames |	columnNames := super columnNames.	columnNames remove: 'version'.	^columnNames</body></methods><methods><class-id>Store.PkgClassesView</class-id> <category>accessing</category><body package="Store-DB-Records" selector="commentID">commentID	^commentID</body><body package="Store-DB-Records" selector="commentID:">commentID: aValue	commentID := aValue</body><body package="Store-DB-Records" selector="definitionID">definitionID	^definitionID</body><body package="Store-DB-Records" selector="definitionID:">definitionID: aValue	definitionID := aValue</body><body package="Store-DB-Records" selector="definitionOrder">definitionOrder	"Answer the receiver's definitionOrder."	^definitionOrder</body><body package="Store-DB-Records" selector="definitionOrder:">definitionOrder: anInteger	"Set the receiver's definitionOrder."	definitionOrder := anInteger</body><body package="Store-DB-Records" selector="environmentString">environmentString	^environmentString</body><body package="Store-DB-Records" selector="environmentString:">environmentString: aString		environmentString  := aString</body><body package="Store-DB-Records" selector="packageRef">packageRef	^packageRef</body><body package="Store-DB-Records" selector="packageRef:">packageRef: anObject	packageRef := anObject</body><body package="Store-DB-Records" selector="superclass">superclass	^superclass</body><body package="Store-DB-Records" selector="superclass:">superclass: anObject	superclass := anObject</body></methods><methods><class-id>Store.PkgClassesView</class-id> <category>private</category><body package="Store-DB-Records" selector="prime">prime	super prime.	version := Object new.</body><body package="Store-DB-Records" selector="unprime">unprime	super unprime.	version := nil.</body></methods><methods><class-id>Store.PkgClassesView class</class-id> <category>installation</category><body package="Store-DB-Records" selector="childReference">childReference	^'classRef'</body><body package="Store-DB-Records" selector="parentReference">parentReference	^'packageRef'</body><body package="Store-DB-Records" selector="referencedClass">referencedClass	^ClassRecord</body><body package="Store-DB-Records" selector="subCollectionClass">subCollectionClass	^PkgClasses</body></methods><methods><class-id>Store.PkgClassesView class</class-id> <category>session</category><body package="Store-DB-Records" selector="classesSession">classesSession	( self isSessionValid: ClassesSession)		ifFalse:			[ClassesSession := self broker getNewSession.			ClassesSession bindOutput: self newPrimed.			ClassesSession bindInput: Package new.			ClassesSession prepare: 						( self newSQL						selectAll;						where;						column: #packageRef equalTo: ':primaryKey';						orderBy:  #definitionOrder)].	^ClassesSession</body><body package="Store-DB-Records" selector="defaultBlockFactor">defaultBlockFactor	^16</body><body package="Store-DB-Records" selector="resetSession">resetSession	ClassesSession notNil		ifTrue: 			[ self brokerOrNil notNil 				ifTrue: [ self broker dismissSession: ClassesSession ].			ClassesSession := nil			]</body></methods><methods><class-id>Store.PkgClassesView class</class-id> <category>accessing</category><body package="Store-DB-Records" selector="columnNames">columnNames		"self columnNames"	| columnNames |	columnNames := super columnNames.	columnNames remove: 'version'.	^columnNames</body></methods><methods><class-id>Store.BundlesView</class-id> <category>accessing</category><body package="Store-DB-Pundles" selector="bundleComment">bundleComment	^bundleComment</body><body package="Store-DB-Pundles" selector="bundleComment:">bundleComment: aValue	bundleComment := aValue</body><body package="Store-DB-Pundles" selector="bundleRef">bundleRef	^bundleRef</body><body package="Store-DB-Pundles" selector="bundleRef:">bundleRef: aValue	bundleRef := aValue</body><body package="Store-DB-Pundles" selector="expression">expression	^expression</body><body package="Store-DB-Pundles" selector="expression:">expression: aValue	expression := aValue</body><body package="Store-DB-Pundles" selector="seqNumber">seqNumber	^seqNumber</body><body package="Store-DB-Pundles" selector="seqNumber:">seqNumber: aValue	seqNumber := aValue</body></methods><methods><class-id>Store.BundlesView class</class-id> <category>installation</category><body package="Store-DB-Pundles" selector="childReference">childReference		^'subBundleRef'</body><body package="Store-DB-Pundles" selector="parentReference">parentReference	^'bundleRef'</body><body package="Store-DB-Pundles" selector="referencedClass">referencedClass	^Bundle</body><body package="Store-DB-Pundles" selector="subCollectionClass">subCollectionClass	^Bundles</body></methods><methods><class-id>Store.BundlesView class</class-id> <category>session</category><body package="Store-DB-Pundles" selector="bundleSession">bundleSession	"BundleSession := nil "	( self isSessionValid: BundleSession)		ifFalse: 			[BundleSession := self broker  getNewSession.			BundleSession bindOutput: self newPrimed.			BundleSession bindInput: Bundle new.			BundleSession prepare: 					( self newSQL						selectAll;						where;						column: #bundleRef equalTo: ':primaryKey') ].	^BundleSession</body><body package="Store-DB-Pundles" selector="resetSession">resetSession	BundleSession notNil		ifTrue: 			[ self brokerOrNil notNil 				ifTrue: [ self broker dismissSession: BundleSession ].			BundleSession := nil			]</body></methods><methods><class-id>Store.PkgNameSpacesAndSourcesView</class-id> <category>accessing</category><body package="Store-DB-Records" selector="blobData">blobData	^blobData</body><body package="Store-DB-Records" selector="blobType">blobType 	^blobType</body></methods><methods><class-id>Store.PkgNameSpacesAndSourcesView class</class-id> <category>session</category><body package="Store-DB-Records" selector="resetSession">resetSession	NameSpacesWithSourcesSession notNil		ifTrue: 			[ self brokerOrNil notNil 				ifTrue: [ self broker dismissSession: NameSpacesWithSourcesSession ].			NameSpacesWithSourcesSession := nil			].</body><body package="Store-DB-Records" selector="sourcesSession">sourcesSession	"NameSpacesWithSourcesSession := nil"	( self isSessionValid: NameSpacesWithSourcesSession )		ifFalse: 	[ NameSpacesWithSourcesSession := self createSourcesSession ].	^NameSpacesWithSourcesSession</body></methods><methods><class-id>Store.PropertiesView</class-id> <category>private</category><body package="Store-DB-Records" selector="prime">prime	super prime.	version := Object new.</body><body package="Store-DB-Records" selector="unprime">unprime	super unprime.	version := nil.</body></methods><methods><class-id>Store.PropertiesView</class-id> <category>accessing</category><body package="Store-DB-Records" selector="commentID">commentID	^commentID</body><body package="Store-DB-Records" selector="commentID:">commentID: anObject	commentID := anObject</body><body package="Store-DB-Records" selector="definitionID">definitionID	^definitionID</body><body package="Store-DB-Records" selector="definitionID:">definitionID: anObject	definitionID := anObject</body><body package="Store-DB-Records" selector="environmentString">environmentString	^environmentString</body><body package="Store-DB-Records" selector="environmentString:">environmentString: anObject	environmentString := anObject</body><body package="Store-DB-Records" selector="pundleRef">pundleRef	^pundleRef</body><body package="Store-DB-Records" selector="pundleRef:">pundleRef: anObject	pundleRef := anObject</body><body package="Store-DB-Records" selector="recType">recType	^recType</body><body package="Store-DB-Records" selector="recType:">recType: anObject	recType := anObject</body><body package="Store-DB-Records" selector="searchString">searchString	^searchString</body><body package="Store-DB-Records" selector="searchString:">searchString: anObject	searchString := anObject</body></methods><methods><class-id>Store.PropertiesView class</class-id> <category>accessing</category><body package="Store-DB-Records" selector="columnNames">columnNames		"self columnNames"	| columnNames |	columnNames := super columnNames.	columnNames remove: 'version'.	^columnNames</body></methods><methods><class-id>Store.PropertiesView class</class-id> <category>installation</category><body package="Store-DB-Records" selector="childReference">childReference	^'propertyRef'</body><body package="Store-DB-Records" selector="parentReference">parentReference	^'pundleRef'</body><body package="Store-DB-Records" selector="referencedClass">referencedClass	^PropertyRecord</body><body package="Store-DB-Records" selector="subCollectionClass">subCollectionClass	^Properties</body></methods><methods><class-id>Store.PropertiesView class</class-id> <category>session</category><body package="Store-DB-Records" selector="propertiesSession">propertiesSession	"PropertiesSession := nil"	( self isSessionValid: PropertiesSession)		ifFalse:			[PropertiesSession := self broker getNewSession.			PropertiesSession bindOutput: self newPrimed.			PropertiesSession bindInput: Properties new.			PropertiesSession prepare: 						(self newSQL							selectAll;							where;							column: #pundleRef  equalTo: ':pundleRef';							and;							column: #recType equalTo: ':recType') ].	^PropertiesSession</body><body package="Store-DB-Records" selector="resetSession">resetSession	"self resetSession"	PropertiesSession notNil		ifTrue: 			[ self brokerOrNil notNil 				ifTrue: [ self broker dismissSession: PropertiesSession ].			PropertiesSession := nil			]</body></methods><methods><class-id>Store.NameSpaceRecord</class-id> <category>private</category><body package="Store-DB-Records" selector="convertFromXML:">convertFromXML: aString	| p element out attr value i |	p := XML.XMLParser on: aString readStream.	element := p validate: false; getNextChar; element.	out := (String new: 128) writeStream.	out nextPutAll: (self			convertXMLNameToSmalltalk: (element elementNamed: 'environment') characterData			quoted: false).	out nextPutAll: ' defineNameSpace: ';		store: (element elementNamed: 'name') characterData asSymbol.	out crtab; nextPutAll: 'private: ';		nextPutAll: (element elementNamed: 'private') characterData.	out crtab; nextPutAll: 'imports: ';		store: (element elementNamed: 'imports') characterData.	out crtab; nextPutAll: 'category: ';		store: (element elementNamed: 'category') characterData.	attr := [element elementNamed: 'attributes'] on: Error do: [:ex | ex return: nil].	attr == nil ifFalse:		[out crtab; nextPutAll: 'attributes: #('.		attr elements do: [:elm |			elm isElement ifTrue:				[out crtab: 3; nextPutAll: '#('; store: elm tag type asSymbol; space.				((elm elements contains: [:e | e isElement]) or: [elm elements isEmpty])					ifTrue: [value := (elm elements select: [:e | e isElement])							collect: [:e | e characterData]]					ifFalse:						[value := elm characterData.						i := #('nil' 'true' 'false') indexOf: value.						value := i = 0 ifTrue: [value asSymbol] ifFalse: [#(nil true false) at: i]].				out store: value; nextPutAll: ')']].		out nextPutAll: ')'].	^out contents</body><body package="Store-DB-Records" selector="convertToXML:">convertToXML: aString	| parse driver data eName |	parse := Compiler new parse: aString in: nil class noPattern: true notifying: nil.	parse := parse node block body statements first.	data := Dictionary new.	parse selector keywords with: parse arguments do:		[:key :value | data at: key put: value].	driver := XML.DOM_SAXDriver new.	driver 	startDocumentFragment;		startElement: 'name-space' atts: nil.	self sax: driver tag: 'name' value: (data at: 'defineNameSpace:') value asString.	eName := self convertVariableNodeToXML: parse receiver.	self sax: driver tag: 'environment' value: eName.	self sax: driver tag: 'private' value: (data at: 'private:') value printString.	self sax: driver tag: 'imports' value: (data at: 'imports:') value.	self sax: driver tag: 'category' value: (data at: 'category:') value asString.	driver endElement;		endDocumentFragment.	^SmalltalkWorkbench prettyPrint: driver document root</body><body package="Store-DB-Records" selector="loadSrcIntoPackage:confirm:">loadSrcIntoPackage: imPkg confirm: aBoolean	"Load the method. Make sure that it goes to the imPkg. and it does not	overwrites existing definition from another package."	aBoolean 		ifTrue: [(Dialog confirm: 'Do you want to load the selected namespace?') 			ifFalse: [^self]].	( LoadAnalyzer canLoadNameSpace: self from: imPkg )		ifTrue: [ Policies packagePolicy forcePackage: imPkg while:  [ self loadSrc ] ]</body><body package="Store-DB-Records" selector="move:to:">move: obj to: imgPackage 	"Move obj, assumed to be the insanitiation of the reciever, to imgPackage."	XChangeSet current moveNameSpaceDefinition: obj toPackage: imgPackage</body></methods><methods><class-id>Store.NameSpaceRecord</class-id> <category>printing</category><body package="Store-DB-Records" selector="displayString">displayString	^SystemUtils convertAbsoluteNameToFull: self absoluteName</body><body package="Store-DB-Records" selector="printOn:">printOn: aStream	aStream nextPutAll: 'NameSpace{';		nextPutAll: self primaryKey printString;		nextPutAll: '-';		nextPutAll: self name;		nextPutAll: '}'.</body></methods><methods><class-id>Store.NameSpaceRecord</class-id> <category>testing</category><body package="Store-DB-Records" selector="isForNameSpace">isForNameSpace	^true</body></methods><methods><class-id>Store.NameSpaceRecord</class-id> <category>browser support</category><body package="Store-DB-Records" selector="binding">binding		"No such thing"	^self</body><body package="Store-DB-Records" selector="value">value	^self fullName asStrictReference valueOrDo: [ nil ]</body><body package="Store-DB-Records" selector="valueOrDo:">valueOrDo: aBlock	^self fullName asStrictReference valueOrDo: aBlock</body></methods><methods><class-id>Store.NameSpaceRecord</class-id> <category>public interface</category><body package="Store-DB-Records" selector="browseVersions">browseVersions  	TabApplicationSystemBrowser browseVersionsOfNamespaceOrClass: self</body><body package="Store-DB-Records" selector="loadComponents:package:">loadComponents: aSet package: aDBPackage 	"Load specified components: #definition #comment #data	from aDBPackge."	| imPkg ns data |	imPkg := Registry packageNamed: aDBPackage name.	imPkg isNil ifTrue: [ ^Dialog warn: 'Package ,' , aDBPackage name , ' is not loaded.'.].	ns := ((aSet includes: #definition)				or: [aSet includes: #comment])				ifTrue: [self]				ifFalse: [nil].	data := (aSet includes: #data)				ifTrue: [aDBPackage dataForNamed: self absoluteName]				ifFalse: [Array new].	(LoadAnalyzer canLoadNameSpace: ns data: data from: imPkg)		ifFalse: [^self].	(aSet includes: #definition)		ifTrue: [Policies packagePolicy forcePackage: imPkg while: [self loadDefinition]]." Namespaces don't have comments.....	(aSet includes: #comment)		ifTrue: [Policies packagePolicy forcePackage: imPkg while: [self loadComment]]."	(aSet includes: #data)		ifTrue: [data do: [:m | m loadSrcIntoPackage: imPkg confirm: false]]</body><body package="Store-DB-Records" selector="loadFrom:using:">loadFrom: aDBPackage using: loader 	self loadComponents: ( loader componentsToLoad )		package: aDBPackage</body><body package="Store-DB-Records" selector="loadSrc">loadSrc	"Load a class definition if necessary do not log changes."	^self loadSrcInto: nil.		"whatever the default is"</body><body package="Store-DB-Records" selector="loadSrcInto:">loadSrcInto: imgPackage	"Load a nanespace definition if necessary do not log changes."	| ns |	ns := self loadDefinition: self definition into: imgPackage logged: false.	self loadCommentFor: ns.</body><body package="Store-DB-Records" selector="removeFromPackage:">removeFromPackage: aPackage	"For adding a removal of unloaded defintions from the change sets."	XMainChangeSet current		addRemoveNameSpace: self absoluteName		package: aPackage</body></methods><methods><class-id>Store.NameSpaceRecord</class-id> <category>comparing</category><body package="Store-DB-Records" selector="objectIsForSelf:">objectIsForSelf: anObject		"Answer true if anObject represents the same kind of thing as the reciever."	^anObject isForNameSpace</body><body package="Store-DB-Records" selector="sameAsImThing:">sameAsImThing: aThing 	"Answer true if aThing is defined the same as the receiver."		"Ds- this compares the definition as a string--problem is, 		for non-existant ClassPools there is an error producing this		string. So... punt for now."	^[ ( aThing absoluteName = self absoluteName 			and: [ aThing definitionAndComment = self definitionAndComment ] ) 	] on: Dictionary valueNotFoundSignal do:		[ :exp | exp return: false ].</body><body package="Store-DB-Records" selector="sourceMatches:">sourceMatches: aClass	"Answer whether the source matches."	^aClass definitionAndComment equalsAcrossPlatforms: self definitionAndComment</body></methods><methods><class-id>Store.NameSpaceRecord</class-id> <category>converting</category><body package="Store-DB-Records" selector="asCommentTag">asCommentTag	"Answer an instance of NameSpaceCommentTag"	^NameSpaceCommentTag newNameSpaceName: self absoluteName</body><body package="Store-DB-Records" selector="asDescriptor">asDescriptor	"Answer an instance of ClassDescriptor."	^NameSpaceDescriptor fromModel: self</body><body package="Store-DB-Records" selector="asTag">asTag	"Answer an instance of TT_NameSpaceTag"	^NameSpaceTag newNameSpaceName: self absoluteName</body></methods><methods><class-id>Store.NameSpaceRecord</class-id> <category>accessing</category><body package="Store-DB-Records" selector="fileOutObjectType">fileOutObjectType		"Answer a symbol that represents the type of the receiver."	^#namespace</body><body package="Store-DB-Records" selector="symbol">symbol	^self absoluteSymbol</body><body package="Store-DB-Records" selector="textRepresentationForTag:">textRepresentationForTag: aTag 	^aTag isCommentTag		ifTrue: [ self comment ]		ifFalse: [ self definition ]</body></methods><methods><class-id>Store.NameSpaceRecord</class-id> <category>db-utilities</category><body package="Store-DB-Records" selector="containingPackages">containingPackages	^[( PkgNameSpaces packagesContainingNameSpace: primaryKey )		collect: [ :id | Package aRecordWithID: id ].	]	on: self errorSignals	do: [ :ex | ex outer. OrderedCollection new ].</body></methods><methods><class-id>Store.NameSpaceRecord class</class-id> <category>instance creation</category><body package="Store-DB-Records" selector="from:timeStamp:trace:">from: nspace timeStamp: timeStamp trace: oldDB	| env |	env := nspace environment.	^self new		name: nspace name asString;		timeStamp: timeStamp;		environmentString: ( env == nil ifTrue: [ '' ] ifFalse: [ env absoluteName ] );		definitionStr:  nspace definition;		commentStr: nspace comment;		setTrace: oldDB;		yourself.</body></methods><methods><class-id>Store.NameSpaceRecord class</class-id> <category>public interface</category><body package="Store-DB-Records" selector="loadComponents:package:">loadComponents: aSet package: aDBPackage 	"Load specified components: #definition #comment #methods #data	from aDBPackge."	| set |	( set := aSet copy )		remove: #methods ifAbsent: [].		super loadComponents: set package: aDBPackage.</body></methods><methods><class-id>Store.NameSpaceRecord class</class-id> <category>accessing</category><body package="Store-DB-Records" selector="associationClass">associationClass	^PkgNameSpaces</body><body package="Store-DB-Records" selector="commentFor:">commentFor: aNS	^aNS comment</body><body package="Store-DB-Records" selector="referenceColumn">referenceColumn	^#nameSpaceRef</body><body package="Store-DB-Records" selector="sourcesViewClass">sourcesViewClass	^PkgNameSpacesAndSourcesView</body></methods><methods><class-id>Store.Bundle</class-id> <category>testing</category><body package="Store-DB-Pundles" selector="containsDescription:">containsDescription: aComponentDescription	^self containedItems contains: 		[ :item | aComponentDescription describesSameAs: item ]</body><body package="Store-DB-Pundles" selector="includesDataKey:owner:">includesDataKey: key owner: owner		^( self leafItems 		detect: [ :pkg | pkg includesDataKey: key owner: owner ]		ifNone: [ nil ]  	  ) ~~ nil</body><body package="Store-DB-Pundles" selector="includesDefinitionOf:">includesDefinitionOf: absoluteName		^( self leafItems 		detect: [ :pkg | pkg includesDefinitionOf: absoluteName ]		ifNone: [ nil ]	) ~~ nil</body><body package="Store-DB-Pundles" selector="includesMethod:">includesMethod: aMethodDescriptor	^self 		includesSelector: aMethodDescriptor selector 		className: aMethodDescriptor className 		meta: aMethodDescriptor isMeta</body><body package="Store-DB-Pundles" selector="includesSelector:class:">includesSelector: selector class: aClass		^( self leafItems 		detect: [ :pkg | pkg includesSelector: selector class: aClass ]		ifNone: [ nil ]  	  ) ~~ nil</body><body package="Store-DB-Pundles" selector="includesSelector:className:meta:">includesSelector: selector className: className meta: isMeta	"Answer wheter the reciver contains className&gt;&gt;aSelector."	self leafItems 		detect: [ :pkg | pkg includesSelector: selector className: className meta: isMeta ]		ifNone: [ ^false ].	^true</body><body package="Store-DB-Pundles" selector="isBundle">isBundle	^true</body><body package="Store-DB-Pundles" selector="isLeaf">isLeaf	^self contents size == 0.</body></methods><methods><class-id>Store.Bundle</class-id> <category>private-file out</category><body package="Store-DB-Pundles" selector="fileOutOn:">fileOutOn: aFileManager 	"File out the bundle on aFileManager."	self fileOutPropertiesOn: aFileManager.	self containedItems do: 		[ :comp | comp fileOutOn: aFileManager ]</body><body package="Store-DB-Pundles" selector="fileOutSelectors:in:on:">fileOutSelectors: aCollection in: aClass on: aFileManager 	| meths cname |	cname := aClass absoluteName.	meths := OrderedCollection new.	aCollection do: 		[ :sel | | meth |		self leafItems 				detect: [ :pkg | ( meth := pkg method: sel forClassNamed: cname meta: aClass isMeta ) ~~ nil ]				ifNone: [ nil ].		meth == nil ifFalse: [ meths add: meth ].		].	self fileOutMethods: meths on: aFileManager.</body></methods><methods><class-id>Store.Bundle</class-id> <category>relationships</category><body package="Store-DB-Pundles" selector="relatedBy:">relatedBy: token 	token == #tt_containsRel ifTrue: [^self containedItems asSet].	^super relatedBy: token</body></methods><methods><class-id>Store.Bundle</class-id> <category>browser support</category><body package="Store-DB-Pundles" selector="allClasses">allClasses	"Answer a collection of classes. The collection contains classes that are defined in the bundle and 	pseudo classes for which only methods or data are defined"	| defined extended |	defined := self classes collect: [ :class | class absoluteName ].	extended := ( Method classNamesInPackages: self leafItems ).	extended addAll: ( ( self data select: [ :elem | elem isInClass ] )				collect: [ :elem | elem environmentString ] ).	defined do: [ :each | extended remove: each ifAbsent: nil ].	extended := extended collect: [ :cName | PseudoClass newNamed: cName ].	^( self classes, extended asOrderedCollection ).</body><body package="Store-DB-Pundles" selector="allClassesOLD">allClassesOLD	"Answer a collection of classes. The collection contains classes that are defined in the package and 	pseudo classes for which only methods or data are defined"	| classes |	classes := Set new.	self leafItems do: [ :pkg | classes addAll: pkg allClasses ].	^classes</body><body package="Store-DB-Pundles" selector="allMetaclasses">allMetaclasses	"Answer a collection of metaclasses. The collection contains classes that are defined in the package and 	pseudo classes for which only methods or data are defined"	| classes |	classes := Set new.	self leafItems do: [ :pkg | classes addAll: pkg allMetaclasses ].	^classes</body><body package="Store-DB-Pundles" selector="allNameSpaces">allNameSpaces	"Answer a collection of namespaces. The collection contains namespaces that are defined in the package 	and pseudo namespaces for which only data are defined"	| set |	set := Set new.	self leafItems do: [ :pkg | set addAll: pkg allNameSpaces ].	^set</body><body package="Store-DB-Pundles" selector="classInPackageNamed:meta:">classInPackageNamed: aString meta: aBoolean	"Answer a collection of classes. The collection contains classes that are defined in the package and 	pseudo classes for which only methods or data are defined"	| cls |	self leafItems do: 		[ :pkg | 		( cls := pkg classInPackageNamed: aString meta: aBoolean ) == nil			ifFalse: [ ^cls ].		].	^nil</body><body package="Store-DB-Pundles" selector="dataForNamed:">dataForNamed: aFullName 	"Answer a collection of datum descriptors."	| set |	set := Set new.	self leafItems do:		[ :pkg |  set addAll: 	( pkg dataForNamed: aFullName ) ].	^set asOrderedCollection</body><body package="Store-DB-Pundles" selector="dataForNamed:andProtocol:">dataForNamed: aFullName andProtocol: aSymbol	"Answer a collection of datum descriptors."	| set |	set := Set new.	self leafItems do:		[ :pkg |  set addAll: 	( pkg dataForNamed: aFullName andProtocol: aSymbol) ].	^set asOrderedCollection</body><body package="Store-DB-Pundles" selector="includesDataKey:ownerName:">includesDataKey: dataKey ownerName: aName		"Answer wheter the reciver contains aName.dataKey."	self leafItems 		detect: [ :pkg | pkg includesDataKey: dataKey ownerName: aName ] 		ifNone: [ ^false ].	^true</body><body package="Store-DB-Pundles" selector="methodsForClassNamed:andProtocol:meta:">methodsForClassNamed: cName andProtocol: protocolName meta: isMeta	"Answer a collection of method descriptors."	| set |	set := Set new.	self leafItems do:		[ :pkg |  set addAll: 			( pkg methodsForClassNamed: cName 					andProtocol: protocolName meta: isMeta ) 		].	^set asOrderedCollection</body><body package="Store-DB-Pundles" selector="methodsForClassNamed:meta:">methodsForClassNamed: aClassName meta: isMeta	"Answer a collection of methods."	| set |	set := Set new.	self leafItems do: [ :pkg | set addAll: ( pkg methodsForClassNamed: aClassName meta: isMeta ) ].	^set  asSortedCollection: [:x :y | x name &lt; y name]</body><body package="Store-DB-Pundles" selector="protocolsForClassNamed:meta:">protocolsForClassNamed: aClassName meta: isMeta	"Answer a collection of protocols."	| set |	set := Set new.	self leafItems do: 		[ :pkg | set addAll: ( pkg protocolsForClassNamed: aClassName meta: isMeta ) ].	^set</body><body package="Store-DB-Pundles" selector="protocolsForDataIn:">protocolsForDataIn: anObject	| set |	set := Set new.	self leafItems do:		[ :pkg |  set addAll: ( pkg protocolsForDataIn: anObject ) ].	^set asSortedCollection</body><body package="Store-UI" selector="toolListIcon">toolListIcon	^BundleModel bundleIcon</body></methods><methods><class-id>Store.Bundle</class-id> <category>accessing</category><body package="Store-DB-Pundles" selector="allItems">allItems	"Answer a list of pundles contianed in this bundle and in bundles contained by 	this 	bundle. 	The list preserves the bundle order. Put this bundle as a last item on the list."	| items |	items := OrderedCollection new.	self containedItems do: 		[ :item | 		item isBundle			ifTrue: [ items addAll: item allItems ]			ifFalse: [ items add: item ]		].	items add: self. 	^items</body><body package="Store-DB-Pundles" selector="allUniqueItems">allUniqueItems	"Answer a list of pundles contianed in this bundle and in bundles contained by 	this bundle. 	The list preserves the bundle order. 	Put this bundle as a last item on the list. 	Remove duplicates from the list."	| items present |	items := self allItems.	present := Set new: items size.	items := items				select: 					[:each | 					| res |					res := present includes: each.					present add: each.					res not].	^items</body><body package="Store-DB-Pundles" selector="asDBDescription">asDBDescription	^self class partClass new		subBundleRef: self primaryKey		yourself</body><body package="Store-DB-Pundles" selector="classes">classes	"Answer all the classes defined in the receiver's pacakges."	^PkgClassesView allInPackages: self leafItems.</body><body package="Store-DB-Pundles" selector="componentType">componentType	"Answer a symbol representing the class of the receiver."	^#bundle</body><body package="Store-DB-Pundles" selector="containedItems">containedItems	"Answer a collection of TT_Bundles/TT_Packages."	| items |	items := OrderedCollection new: self contents size.	[self contents do: 		[ :each | | item |		item := each asDBComponent.		item notNil ifTrue: [ items add: item ]		]	]	on: self errorSignals	do: [ :ex | ^OrderedCollection new ].	^items</body><body package="Store-DB-Pundles" selector="contents">contents		contents isNil ifTrue: [self getContent].	^contents</body><body package="Store-DB-Pundles" selector="contents:">contents: aCollection		contents := aCollection</body><body package="Store-DB-Pundles" selector="contentsFromImage:">contentsFromImage:  anImageBundle	"Get record descriptions.	This message assumes that all bundle components	have been published already."	contents := anImageBundle dbContent.	files := anImageBundle fileContent.</body><body package="Store-DB-Pundles" selector="contentsFromImage:pundleFragments:">contentsFromImage:  anImageBundle pundleFragments: aDictionary	"Get record descriptions.	This message assumes that all bundle components	have been published already."	contents := anImageBundle dbContentPundleFragments: aDictionary</body><body package="Store-DB-Pundles" selector="data">data	"Answer all the DataElements defined in the receiver's pacakges."	^DataView allInPackages: self leafItems.</body><body package="Store-DB-Pundles" selector="describeContents">describeContents	| strm |	strm := WriteStream on: String new.	self describeContentsOn: strm level: 0.	^strm contents</body><body package="Store-DB-Pundles" selector="describeContentsOn:level:">describeContentsOn: aStream level: aDepth 	self containedItems		do: 			[:pun | 			aDepth timesRepeat: [aStream tab].			aStream nextPutAll: (pun stringKey: #()); cr.			pun isBundle ifTrue: [pun describeContentsOn: aStream level: aDepth + 1]]</body><body package="Store-DB-Pundles" selector="descriptionAndLevels:level:">descriptionAndLevels: collection level: aDepth 	self containedItems do: 		[ :pun | 		collection add: ( Array with: pun with: aDepth ).		pun isBundle 			ifTrue: [ pun descriptionAndLevels: collection level: aDepth + 1 ]		].	^collection.</body><body package="Store-DB-Pundles" selector="fileDescriptions">fileDescriptions		^self files collect: [ :file | file asDescriptor ]</body><body package="Store-DB-Pundles" selector="files">files		files isNil ifTrue: [self getContent].	^files</body><body package="Store-DB-Pundles" selector="getImagePundle">getImagePundle	"Check if there if already loaded versions of a bundle and answer it"	^Registry bundleNamed: self name.</body><body package="Store-DB-Pundles" selector="itemCount">itemCount	"Answer a count of work to be done."	^self containedItems inject: 1 into:		[ :sz :pun | sz + pun itemCount ]</body><body package="Store-DB-Pundles" selector="leafItems">leafItems	"Answer a list of packages contianed in this bundle 	and in bundles contained by this bundle."	| items |	items := OrderedCollection new.	self isInCurrentDatabase		ifFalse: [ ^items ].	self containedItems do: [:item | items addAll: item leafItems].	^items</body><body package="Store-DB-Pundles" selector="metaclasses">metaclasses	"Answer all the classes defined in the receiver's pacakges."	| coll |	coll := OrderedCollection new.	self leafItems do:		[ :pkg | coll addAll: pkg metaclasses ].	^coll.</body><body package="Store-DB-Pundles" selector="methods">methods	"Answer all the methods defined in the receiver's packages."	^MethodsView allInPackages: self leafItems.</body><body package="Store-DB-Pundles" selector="nameSpaces">nameSpaces	"Answer all the namespaces defined in the receiver's packages."	^PkgNameSpacesView allInPackages: self leafItems.</body><body package="Store-DB-Pundles" selector="newItems">newItems	"Answer a collection of items that were 	published when I was published."	| old |	old := self parentRecord.	old isNil ifTrue: [^self containedItems collect: [:i | Array with: i with: nil]].	^AbstractTool compareItems: self containedItems with: old containedItems</body><body package="Store-DB-Pundles" selector="pundleChangesClass">pundleChangesClass	^BundleChanges</body><body package="Store-DB-Pundles" selector="traceBundle">traceBundle		^self parentRecord</body><body package="Store-DB-Pundles" selector="uniqueItemsAndLeveles">uniqueItemsAndLeveles	"Answer a colleciton of description level pairs"	| collection |	collection := OrderedCollection new.	self descriptionAndLevels: collection level: 1.	^collection</body></methods><methods><class-id>Store.Bundle</class-id> <category>db-utilities</category><body package="Store-DB-Pundles" selector="installContentInDatabase">installContentInDatabase	1 to: contents size do: [:i | 		(contents at: i)			seqNumber: i;			bundleRef: self primaryKey; 			installInDatabase]</body><body package="Store-DB-Pundles" selector="installFilesInDatabase">installFilesInDatabase	files == nil		ifTrue: [ ^self ].	files do: 		[ :file | 		file 			bundleRef: self primaryKey; 			installInDatabase		]</body><body package="Store-DB-Pundles" selector="installInDatabase">installInDatabase 	"Install and store package list."	super installInDatabase.	self installContentInDatabase.	self installFilesInDatabase.</body><body package="Store-DB-Pundles" selector="installSqlString">installSqlString	"Column names must be String, for consistency with #columnNames"	^ self newSQL		insertColumnsValues:  #( 'primaryKey' 'name' 'timeStamp' 'version' 'userName' 'trace' 'commentID' 'propertiesID' ).</body><body package="Store-DB-Pundles" selector="loadSrc">loadSrc	"Load the contents form the database. Answer an image bundle.	This must be the outer bundle."	| imgBundle leafNames |	leafNames := self leafItems collect: [ :pkg | pkg name ].	Notice 		showNotice: ('Loading &lt;1s&gt;' expandMacrosWith: self itemString)		complete: self itemCount		while: 			[ ( [  imgBundle := self loadSrcWithin: self ] on: RedefinitionNotification do:				[ :note | ( leafNames includes: note currentPackage name )							ifFalse: [ note override install. ].				note resume.				] ) == nil 					ifFalse: 						[ ChangeSet loadPundle: self.						SourceFileManager default loadPundle: self.						imgBundle cleanUpOverrides.						self downloadFiles.						]			]		title: 'Store'.	Undeclared purgeUnusedBindings.	^imgBundle</body><body package="Store-DB-Pundles" selector="loadSrcWithin:">loadSrcWithin: parentBundle	"Load the contents form the database. Answer an image bundle."	^BundleModel newFromDB: self within: parentBundle.</body><body package="Store-DB-Pundles" selector="republishFromUserData:">republishFromUserData: userData 	"Republish the receiver (assumed to be a copy of an existing db bundle).	Only a description of this bundle has to be stored in the database.	Version checking and policy checking is done BEFORE this message	is sent."	| transaction res |	self version: ( userData at: #version ).	trace := primaryKey.		"from whence we came"	primaryKey := nil.		"to force get new primary key value"	propertiesID := nil.		"to force republish"	timeStamp := self class timeStamp.	userName := DbRegistry userName.	transaction := 		[ self installInDatabase.		self addBlessingLevel: ( userData at: #blessing )				andComment: ( userData at: #comment ) asString ].	res := self broker publishTransaction: transaction showing: 'Publishing bundle: ' , self name count: contents size.	^res</body><body package="Store-DB-Pundles" selector="typeStringForBlessing">typeStringForBlessing		^Blessing typeStringForBundles</body></methods><methods><class-id>Store.Bundle</class-id> <category>private</category><body package="Store-DB-Pundles" selector="createOrFindExpression">createOrFindExpression	"Answer a string that when evaluated will instantiate the receiver - creating, if neccessary."	^'( Store.Registry bundleNamedOrCreate: ', self name printString, '  ) '.</body><body package="Store-DB-Pundles" selector="definesClass:">definesClass: aClass 	^self includesDefinitionOf: aClass absoluteName asClassNameOnly</body><body package="Store-DB-Pundles" selector="definesName:in:">definesName: key in: nameSpace	^self includesDataKey: key owner: nameSpace</body><body package="Store-DB-Pundles" selector="definesObject:">definesObject: aNameSpace 	^self includesDefinitionOf: aNameSpace absoluteName</body><body package="Store-DB-Pundles" selector="definesSelector:forClass:">definesSelector: selector forClass: aClass 	^self		includesSelector: selector 		className: aClass absoluteName 		classNameOnly meta: aClass isMeta</body><body package="Store-DB-Pundles" selector="descriptionClass">descriptionClass	^BundleDescription</body><body package="Store-DB-Pundles" selector="downloadFiles">downloadFiles	| allFiles filesToDownload |	Store.DbRegistry is73Enabled  		ifFalse: [ ^self ].	allFiles := self files copy.	(self leafItems collect: [ :p | p isBundle ifTrue: [ p files ] ifFalse: [ #() ] ] ) do: [:each | allFiles addAll: each].	allFiles size &gt; 0		ifFalse: [ ^self ].	allFiles := allFiles collect: [ :f | FileRecord aRecordWithID: f fileRef ].	filesToDownload := SimpleDialog new		chooseMultiple: #downloadFilesDotDotDot &lt;&lt; #store &gt;&gt; 'Download files...' 		fromList: ( allFiles collect: [ :n | n filename asString ] )		values:  allFiles 		initialSelections: #( ) 		buttons: #( ) values: #( )		lines: ( 12 min: allFiles size ) + 1		cancel: [ ^self ] 		for: Dialog defaultParentWindow. 	filesToDownload do:		[ :file | file download ].</body><body package="Store-DB-Pundles" selector="getContent">getContent	"Consult the database and retrive components 	descriptions."	| packages bundles |	bundles := Bundles allFromBundleID: self primaryKey.	packages := Packages allFromBundleID: self primaryKey.	files := DbRegistry is73Enabled		ifTrue: [ ( Files allFromBundleID: self primaryKey ) asList ]		ifFalse: [ OrderedCollection new asList ].	contents := ((bundles , packages) asSortedCollection: [:x :y | x seqNumber &lt; y seqNumber]) asList</body><body package="Store-DB-Pundles" selector="prime">prime	"Put instances of Object into slots that are not mapped into columns in the DB.	This is crucial for reading from DB since the primed slots are skipped"	super prime.	contents := Object new.	files := Object new.</body><body package="Store-DB-Pundles" selector="unprime">unprime	"Remove the effect of priming (see the prime method)."	super unprime.	contents := nil.	files :=  nil.</body></methods><methods><class-id>Store.Bundle</class-id> <category>private-differences calculation</category><body package="Store-DB-Pundles" selector="basicModifications">basicModifications	"Answer my content as a collection of modifications."	"In this case, just the bundle proper, not the contents."	^super basicModifications		add: ( Modification 					tag: ( BundleStructureTag bundle: self ) 					package: self 					record: self 				);		yourself.</body><body package="Store-DB-Pundles" selector="computeDiffsBetween:into:">computeDiffsBetween: aBundle into: diffHolder	^aBundle computeDiffsBetweenDBBundle: self into: diffHolder</body><body package="Store-DB-Pundles" selector="computeDiffsBetweenDBBundle:into:">computeDiffsBetweenDBBundle: aDBBundle into: diff	"Store  differences between receiver and a aDBPackage into an instance of 	PackageDifferences. Store receiver's definitions as number2 since this method	is called with arguments reversed. "	| myPackages dbPackages pkgs dbpkgs |	myPackages := self leafItems collect: [ :pkg | pkg primaryKey printString ].	dbPackages := aDBBundle  leafItems collect: [ :pkg | pkg primaryKey printString ].	pkgs := myPackages reject: [ :pkg | dbPackages includes: pkg ].      dbpkgs := dbPackages reject: [ :pkg | myPackages  includes:  pkg ].	diff nameSpacesSide: 2 put: (NameSpaceRecord allInPackages: pkgs butNotIn: dbpkgs).	diff classesSide: 2 put: (ClassRecord allInPackages: pkgs butNotIn: dbpkgs).	diff metaSide: 2 put: (ClassRecord allMetaclassesInPackages: pkgs butNotIn: dbpkgs).	diff methodsSide: 2 put: (Method allInPackages: pkgs butNotIn: dbpkgs).	diff dataSide: 2 put: (DataElement allInPackages: pkgs butNotIn: dbpkgs ).	diff nameSpacesSide: 1 put: (NameSpaceRecord allInPackages: dbpkgs butNotIn: pkgs).	diff classesSide: 1 put: (ClassRecord allInPackages: dbpkgs butNotIn: pkgs).	diff metaSide: 1 put: (ClassRecord allMetaclassesInPackages: dbpkgs butNotIn: pkgs).	diff methodsSide: 1 put: (Method allInPackages: dbpkgs butNotIn: pkgs).	diff dataSide: 1 put: (DataElement allInPackages: dbpkgs butNotIn: pkgs).	^diff</body><body package="Store-DB-Pundles" selector="modifications">modifications	"Answer my content as a collection of modifications."	| mods |	mods := self basicModifications.	self containedItems do:		[ :pundle | mods addAll: pundle modifications ].	^mods</body></methods><methods><class-id>Store.Bundle</class-id> <category>private-accessing</category><body package="Store-DB-Pundles" selector="ownRecordForTag:">ownRecordForTag: aTag 	"Answer the item in this bundle corresponding to 'aTag' or nil if not there.	Ignores sub-components."	^aTag isComponentTag		ifTrue: [ aTag recordForPackage: self ].</body><body package="Store-DB-Pundles" selector="recordForStructureTag:">recordForStructureTag: aTag 	"Answer the item in this package corresponding to 'aTag' or nil if not there."	^aTag copy		package: self; 		yourself</body><body package="Store-DB-Pundles" selector="recordForTag:">recordForTag: aTag 	"Answer the item in this package corresponding to 'aTag' or nil if not there."	aTag isComponentTag		ifTrue: [ ^aTag recordForPackage: self ].	self leafItems do:		[ :pkg | | rec |		( rec := pkg recordForTag: aTag ) == nil			ifFalse: [ ^rec ]		].	^nil</body></methods><methods><class-id>Store.Bundle class</class-id> <category>private-utilities</category><body package="Store-DB-Pundles" selector="objectionsToPublishing:atBlessing:">objectionsToPublishing: imBndl atBlessing: level 	"Answer true if there are no bojections to publishing 	the imPkg at blessing level 'level'"	^Policies publishPolicy objectionsToPublishingBundle: imBndl atBlessingLevel: level.</body></methods><methods><class-id>Store.Bundle class</class-id> <category>instance creation</category><body package="Store-DB-Pundles" selector="newFrom:userData:">newFrom: anImageBundle userData: userData 	"Given a image bundle create a new record in the database.	Only a description of this bundle has to be stored in the database.	Version checking and policy checking is done BEFORE this message	is sent."	| newDBBundle transaction res propRecords |	newDBBundle := self newFrom: anImageBundle.	newDBBundle version: userData version.	transaction :=		[ newDBBundle contentsFromImage: anImageBundle.		newDBBundle installInDatabase.		self shouldSavePropertyRecords					ifTrue: [ propRecords := self propertyRecordsFromPundle: anImageBundle.							"Insert the property records and/or links into the DB."							newDBBundle addProperties: propRecords].		newDBBundle addBlessingLevel: (userData at: #blessing)			andComment: (userData at: #comment) asString.		newDBBundle		].	MessageNotification raiseSignal:  ( 'bundle &lt;1s&gt;' expandMacrosWith: newDBBundle name ).	ResetIncrementNotification signalWith: anImageBundle itemCount.	res := self broker publishTransaction: transaction.	res notNil		ifTrue:			[ anImageBundle				dbTrace: newDBBundle primaryKey;				setContentsFromDB: res;				markNotModified.			].	^res</body><body package="Store-DB-Pundles" selector="newFrom:userData:pundleFragments:">newFrom: anImageBundle userData: userData pundleFragments: aCollection	"Given a image bundle create a new record in the database. 	Only a description of this bundle has to be stored in the database.	Version checking and policy checking is done BEFORE this message	is sent."	| newDBBundle transaction res propRecords |	newDBBundle := self newFrom: anImageBundle.	newDBBundle version: (userData at: #version).	transaction := 			[newDBBundle contentsFromImage: anImageBundle pundleFragments: aCollection.			newDBBundle installInDatabase.			self shouldSavePropertyRecords 					ifTrue: [ propRecords := self propertyRecordsFromPundle: anImageBundle.							"Insert the property records and/or links into the DB."							newDBBundle addProperties: propRecords].			newDBBundle addBlessingLevel: (userData at: #blessing)					andComment: (userData at: #comment) asString.			newDBBundle].	res := self broker publishTransaction: transaction showing: 'Publishing bundle: ' , newDBBundle name count: anImageBundle itemCount.	^res</body></methods><methods><class-id>Store.Bundle class</class-id> <category>db-utilities</category><body package="Store-DB-Pundles" selector="allBundles">allBundles	"Answer a SortedCollection of TT_Bundles"	"self allBundles"	^self allPackagesOrBundles</body><body package="Store-DB-Pundles" selector="knownBundles">knownBundles	"Answer a SelectionInList containing names of 	all bundles stored in DB."	"self knownBundles"	^self knownPackagesOrBundles</body></methods><methods><class-id>Store.Bundle class</class-id> <category>class initalization</category><body package="Store-DB-Pundles" selector="initialize">initialize	"TT_Bundle initialize"	self initializeCache.</body></methods><methods><class-id>Store.Bundle class</class-id> <category>installation</category><body package="Store-DB-Pundles" selector="columnNames">columnNames	"Answer all the instance variable names that coorespond to column names in the database table."		"self columnNames"	| columnNames |	columnNames := super columnNames.	columnNames remove: 'contents'.	columnNames remove: 'files'.	^columnNames</body><body package="Store-DB-Pundles" selector="deInstallBundles">deInstallBundles	"self deInstallBundles "	self broker dropTableForClass: self.	self broker dropTableForClass: Bundles.	self broker dropTableForClass: Packages.	self broker dropTableForClass: Files.</body><body package="Store-DB-Pundles" selector="installBundles">installBundles	"self installBundles"	self createDatabaseTable.	Bundles createDatabaseTable.	Packages createDatabaseTable.	Files createDatabaseTable.</body></methods><methods><class-id>Store.Bundle class</class-id> <category>constants</category><body package="Store-DB-Pundles" selector="imageClass">imageClass	^BundleModel</body><body package="Store-DB-Pundles" selector="partClass">partClass	^Bundles</body></methods><methods><class-id>Store.Bundle class</class-id> <category>private</category><body package="Store-DB-Pundles" selector="newFrom:">newFrom: anImagePundle 	"Given a image pundle create a new instance of the receiver.		This is a private method used by all public methods that store pundles in the database."	anImagePundle initializeForReconcileWith: nil.	"so it gets initialized first"	^super newFrom: anImagePundle.</body></methods><methods><class-id>Store.PseudoSubdef</class-id> <category>printing</category><body package="Store-DB-Subdefs" selector="displayString">displayString	^key</body></methods><methods><class-id>Store.PseudoSubdef</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="absoluteClassName">absoluteClassName	^name</body><body package="Store-DB-Subdefs" selector="absoluteOwnerName">absoluteOwnerName	^name</body><body package="Store-DB-Subdefs" selector="className">className	^name</body><body package="Store-DB-Subdefs" selector="classNameWithMeta">classNameWithMeta	^name</body><body package="Store-DB-Subdefs" selector="dataKey">dataKey	^key</body><body package="Store-DB-Subdefs" selector="dataKey:">dataKey: aSymbol	key := aSymbol.	isData := true.</body><body package="Store-DB-Subdefs" selector="environmentString">environmentString	^name</body><body package="Store-DB-Subdefs" selector="fullClassName">fullClassName	^name</body><body package="Store-DB-Subdefs" selector="implementingClass">implementingClass	^nil</body><body package="Store-DB-Subdefs" selector="owner">owner	^nil</body><body package="Store-DB-Subdefs" selector="ownerName">ownerName	^name</body><body package="Store-DB-Subdefs" selector="selector">selector	^key</body><body package="Store-DB-Subdefs" selector="selector:">selector: aSymbol	key := aSymbol.	isData := false.</body></methods><methods><class-id>Store.PseudoSubdef</class-id> <category>comparing</category><body package="Store-DB-Subdefs" selector="comparesTo:">comparesTo: anObject		"Answer true if anObject could be another version of the receiver."	( self objectIsForSelf: anObject ) ifFalse: [ ^false ].	( self isForMethod 		ifTrue: [ anObject classNameWithMeta ]		ifFalse: [ anObject environmentString ]	) = self environmentString			ifFalse: [ ^false ].	^( self isForMethod 		ifTrue: [ anObject selector ]		ifFalse: [ anObject dataKey ]	) = key</body><body package="Store-DB-Subdefs" selector="objectIsForSelf:">objectIsForSelf: anObject		"Answer true if anObject represents the same kind of thing as the reciever."	^self isForGeneral		ifTrue: [ anObject isForGeneral ]		ifFalse: [ anObject isForMethod ]</body><body package="Store-DB-Subdefs" selector="sameAsDBThing:">sameAsDBThing: aThing	^self comparesTo: aThing</body><body package="Store-DB-Subdefs" selector="sameAsImThing:">sameAsImThing: aThing	^self comparesTo: aThing</body></methods><methods><class-id>Store.PseudoSubdef</class-id> <category>testing</category><body package="Store-DB-Subdefs" selector="isForData">isForData	^isData</body><body package="Store-DB-Subdefs" selector="isForGeneral">isForGeneral	^isData</body><body package="Store-DB-Subdefs" selector="isForMethod">isForMethod	^isData not</body><body package="Store-DB-Subdefs" selector="isMeta">isMeta	^self className namesMetaClass</body></methods><methods><class-id>Store.PseudoSubdef class</class-id> <category>instance creation</category><body package="Store-DB-Subdefs" selector="dataKey:owner:">dataKey: aSymbol owner: aName	^( super newNamed: aName )		dataKey: aSymbol;		yourself</body><body package="Store-DB-Subdefs" selector="selector:owner:">selector: aSymbol owner: aName	^( super newNamed: aName )		selector: aSymbol;		yourself</body></methods><methods><class-id>Store.BundlePart</class-id> <category>accessing</category><body package="Store-DB-Pundles" selector="bundleRef">bundleRef	"Answer the receiver's bundleRef."	^bundleRef</body><body package="Store-DB-Pundles" selector="bundleRef:">bundleRef: newBundleRef	"Set the receiver's bundleRef to newBundleRef."	bundleRef := newBundleRef</body><body package="Store-DB-Pundles" selector="expressionID">expressionID	"Answer the receiver's expressionID."	^expressionID</body><body package="Store-DB-Pundles" selector="expressionID:">expressionID: newExpressionID	"Set the receiver's expressionID to newExpressionID."	expressionID := newExpressionID</body><body package="Store-DB-Pundles" selector="expressionStr">expressionStr	"Answer the receiver's expressionStr."	^expressionStr</body><body package="Store-DB-Pundles" selector="expressionStr:">expressionStr: newExpressionStr	"Set the receiver's expressionStr to newExpressionStr."	expressionStr := newExpressionStr</body><body package="Store-DB-Pundles" selector="seqNumber">seqNumber	"Answer the receiver's seqNumber."	^seqNumber</body><body package="Store-DB-Pundles" selector="seqNumber:">seqNumber: newSeqNumber	"Set the receiver's seqNumber to newSeqNumber."	seqNumber := newSeqNumber</body></methods><methods><class-id>Store.BundlePart</class-id> <category>printing</category><body package="Store-DB-Pundles" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream nextPut: $&lt;.	bundleRef printOn: aStream.	aStream nextPut: $[.	seqNumber printOn: aStream.	aStream nextPut: $].</body></methods><methods><class-id>Store.BundlePart</class-id> <category>private</category><body package="Store-DB-Pundles" selector="prime">prime	"Put instances of Object into slots that are not mapped into columns in the DB. 	It is crucial for reading from DB since the primed slots are skipped."	expressionStr := Object new</body><body package="Store-DB-Pundles" selector="unprime">unprime	"Remove the effect of priming (see the prime method)."	expressionStr := nil</body></methods><methods><class-id>Store.BundlePart class</class-id> <category>installation</category><body package="Store-DB-Pundles" selector="columnNames">columnNames	| columnNames |	columnNames := super columnNames.	columnNames remove: 'expressionStr'.	^columnNames</body><body package="Store-DB-Pundles" selector="fieldTypes">fieldTypes	| aDict  |	aDict := super fieldTypes.	aDict at: 'bundleRef' put: #PrimaryKey.	aDict at: 'expressionID' put: #Integer.	aDict at: 'seqNumber' put: #Integer.	self checkFieldsWith: aDict.	^aDict</body></methods><methods><class-id>Store.BundlePart class</class-id> <category>db-utilities</category><body package="Store-DB-Pundles" selector="allFromBundleID:">allFromBundleID: aBundleID	"Answer a collection of descriptions that comprises	the content of a bundle aBundleID."	^[self processList: (self broker process: 							( self newSQL								selectAll;								where;								column: #bundleRef equalTo: aBundleID printString)						bindOutput: self newPrimed)	]	on: self  errorSignals 	do: 	[:ex |  ex outer.  ^OrderedCollection new ]</body></methods><methods><class-id>Store.BundlePart class</class-id> <category>private-garbage-collection</category><body package="Store-DB-Pundles" selector="removeAllConnectedTo:">removeAllConnectedTo: aBundleID	"Remove any record from the table which references aBundleID.	Note that this method can only be sent by the database system administrator, 	since it requires privileges that are not given to the regular users."	self deleteWhereColumn:  #bundleRef value: aBundleID printString.</body></methods><methods><class-id>Store.Files</class-id> <category>accessing</category><body package="Store-DB-Pundles" selector="asDBComponent">asDBComponent	"Answer a corresponding FileRecord."	| rec |	[ rec := FileRecord aRecordWithID: fileRef.]		on: self errorSignals		do: [ :ex | ex outer. ^nil ].		rec isNil ifTrue: [ FileRecord componentNotFoundSignal raiseWith: self ].	^rec</body><body package="Store-DB-Pundles" selector="fileRef">fileRef	^fileRef</body><body package="Store-DB-Pundles" selector="fileRef:">fileRef: anObject	fileRef := anObject</body></methods><methods><class-id>Store.Files</class-id> <category>private</category><body package="Store-DB-Pundles" selector="asComponentDescription">asComponentDescription		| baby |	baby := FileModel new.	baby dbTrace: fileRef.	fileRef notNil		ifTrue: [ baby portableFilename: self asDBComponent filename ].	^baby</body></methods><methods><class-id>Store.Files class</class-id> <category>installation</category><body package="Store-DB-Pundles" selector="fieldTypes">fieldTypes	| aDict  |	aDict := super fieldTypes.	aDict at: 'fileRef' put: #PrimaryKey.	self checkFieldsWith: aDict.	^aDict</body></methods><methods><class-id>Store.Bundles</class-id> <category>accessing</category><body package="Store-DB-Pundles" selector="asDBComponent">asDBComponent	"Answer a corresponding Bundle."	| rec |	[ rec := Bundle aRecordWithID: subBundleRef ]		on: self errorSignals		do: [ :ex | ex outer. ^nil ].	rec == nil 		ifTrue: [ Pundle componentNotFoundSignal raiseWith: self ].	^rec</body><body package="Store-DB-Pundles" selector="subBundleRef">subBundleRef	"Answer the receiver's subBundleRef."	^subBundleRef</body><body package="Store-DB-Pundles" selector="subBundleRef:">subBundleRef: newSubBundleRef	"Set the receiver's subBundleRef to newSubBundleRef."	subBundleRef := newSubBundleRef</body></methods><methods><class-id>Store.Bundles</class-id> <category>private</category><body package="Store-DB-Pundles" selector="asComponentDescription">asComponentDescription		^BundleDescription new		id: subBundleRef;		dbIdentifier: DbRegistry dbIdentifier;		yourself</body></methods><methods><class-id>Store.Bundles class</class-id> <category>installation</category><body package="Store-DB-Pundles" selector="fieldTypes">fieldTypes	| aDict  |	aDict := super fieldTypes.	aDict at: 'subBundleRef' put: #PrimaryKey.	self checkFieldsWith: aDict.	^aDict</body></methods><methods><class-id>Store.Bundles class</class-id> <category>accessing</category><body package="Store-DB-Pundles" selector="viewColumnNames">viewColumnNames	"Answer a collection of column names that should be included 	into a view table."	| coll |	coll := OrderedCollection withAll: super viewColumnNames.	coll add: 'expression'; add: 'seqNumber'.	^coll</body></methods><methods><class-id>Store.Bundles class</class-id> <category>db-utilities</category><body package="Store-DB-Pundles" selector="enclosingComponentsOfId:">enclosingComponentsOfId: aBundleID	"Answer a collection of bundles that comprise the containers of a bundle, aBundleID."	^ self select: #bundleRef column: #subBundleRef  value: aBundleID printString.</body><body package="Store-DB-Pundles" selector="select:column:value:">select: column column: aCol value: aVal	"Answer a collection of bundles that comprise the containers of a bundle, aBundleID."	| sql |	sql := ( self newSQL			select: (Array with: column);			where;			column: aCol equalTo: aVal).	^[ ( self broker process: sql ) collect: 	[ :array | Bundle aRecordWithID: array first ] ] 		on: self  errorSignals 		do: [:ex | ex outer. OrderedCollection new ]</body></methods><methods><class-id>Store.Blob</class-id> <category>private-db</category><body package="Store-DB-BaseObjects" selector="chainTo:">chainTo: aBlob 	"Store the primary key of aBlob in the 'blobType' instance variable."	blobType := aBlob primaryKey negated</body><body package="Store-DB-BaseObjects" selector="convertData">convertData	"Use the 'blobType' field to convert the binary data blob into the appropriate type."	blobData isNil  ifTrue: [ ^nil ].	self isString ifTrue: [ ^blobData := blobData asString ].	self isTwoByteString		ifTrue: 			[ | strm |			strm := ReadStream on: blobData.			^blobData := self decodeTwoByteDefinitionStream: strm			].	self isData ifTrue: [ ^blobData := self decode: blobData ].	self isByteArray ifTrue: [ ^blobData ].	self error: 'Unknown data type'.</body><body package="Store-DB-BaseObjects" selector="convertToBinary">convertToBinary	"Temporarily convert the data stored in the blobData instance variable into 	binary data. This conversion is done just before storing data in the data base."	blobData := self isTwoByteString		ifTrue: [ self encodeTwoByteDefinition: blobData ]		ifFalse: [ ( self isString )  |  ( self isByteArray )					ifTrue: [ blobData asByteArray ]					ifFalse: [ ( self encode: blobData ) asByteArray ]				].</body><body package="Store-DB-BaseObjects" selector="getBlobData">getBlobData	^ self broker getBlobData: blobData</body><body package="Store-DB-BaseObjects" selector="getBlobType">getBlobType	^blobType</body><body package="Store-DB-BaseObjects" selector="hasFakeType">hasFakeType	"Used to mark definitions that are spread among multiple records."	^blobType &lt; 0</body><body package="Store-DB-BaseObjects" selector="installInDatabase">installInDatabase	"If the blobData field is nil or empty then do not create the new record in DB. 	If the definition is longer then allowed by database then split it into multiple records."	| originalData |	( blobData ==nil  )		ifTrue: [ self primaryKey: 0.  	^self ].	originalData := blobData.		[ self convertToBinary.	blobData size &gt; self broker maxLongBytes		ifTrue: [ self installMultipleChunks  ]		"Split definition into multiple chunks."		ifFalse: [ self putIntoDatabase ]	] ensure: [ blobData := originalData ]</body><body package="Store-DB-BaseObjects" selector="installMultipleChunks">installMultipleChunks	"The definition is too long to fit into one record, split 	it into chunks no bigger then 'maxLongBytes' and install 	them as separate records. Mark chunks by putting	'fakeType' into the 'blobType' column.	The last chunk contains the real type."	| len nbr cSize chunks min max  def |	def := blobData.	len := def size.	nbr := len // self broker maxLongBytes + 1.	cSize := len // nbr + 1.	chunks := OrderedCollection new.	min := 1.		[max := len min: min + cSize - 1.	chunks add: (def copyFrom: min to: max).	min := max + 1.	min &lt; len] whileTrue.		self putChunksIntoDatabase: chunks</body><body package="Store-DB-BaseObjects" selector="nextChunk">nextChunk	^blobType negated</body><body package="Store-DB-BaseObjects" selector="postDatabaseInstall">postDatabaseInstall	(self primaryKey isNil ) ifTrue: [self primaryKey: self nextID].</body><body package="Store-DB-BaseObjects" selector="preDatabaseInstall">preDatabaseInstall	"Set primary key."	(self class needsSequenceFor: self class) ifTrue: [self primaryKey: self nextID].</body><body package="Store-DB-BaseObjects" selector="putChunksIntoDatabase:">putChunksIntoDatabase: chunks 	"Put data from multiple chunks into separate records in the database. 	Mark chunks by putting 'fakeBlobType' and by storing primaryKey of the next 	chunk into 'blobType' column. The last chunk contains the real record type."	| originalDef prevChunk newChunk |	originalDef := blobData.		[ self setData: chunks removeLast.	self putIntoDatabase.	prevChunk := self.	chunks reverseDo: 		[ :chunk | 		newChunk := self class privateNewPrimed.		newChunk setData: chunk; chainTo: prevChunk.		newChunk putIntoDatabase.		prevChunk := newChunk		].	self primaryKey: prevChunk primaryKey	] ensure: [ blobData := originalDef ]</body><body package="Store-DB-BaseObjects" selector="putIntoDatabase">putIntoDatabase	"Put data into database."	self preDatabaseInstall.	self broker getAnswerFromSession: [self class writeSession]		bindInput: [:session | session bindInput: self].	self postDatabaseInstall.</body><body package="Store-DB-BaseObjects" selector="setBlobType:">setBlobType: aValue	blobType := aValue</body><body package="Store-DB-BaseObjects" selector="setData:">setData: aValue	blobData := aValue</body></methods><methods><class-id>Store.Blob</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="binData">binData	^blobData isNil		ifTrue: [#[]]		ifFalse: [blobData]</body><body package="Store-DB-BaseObjects" selector="binData:">binData: aByteArray	"Store binary data."	blobData := aByteArray.	self beData.</body><body package="Store-DB-BaseObjects" selector="definition">definition	(self isString or: [self isTwoByteString]) 		ifFalse: [self error: 'Accessing strings instead of binary data.'].	^blobData isNil		ifTrue: ['']		ifFalse: [blobData]</body><body package="Store-DB-BaseObjects" selector="definition:">definition: aString 	"Store a definition string."	blobData := aString.	aString class == TwoByteString		ifTrue: [self beTwoByteString]		ifFalse: [self beString]</body><body package="Store-DB-BaseObjects" selector="primaryKey">primaryKey	"Answer the receiver's primaryKey."	^primaryKey</body><body package="Store-DB-BaseObjects" selector="primaryKey:">primaryKey: newPrimaryKey	"Set the receiver's primaryKey to newPrimaryKey."	primaryKey := newPrimaryKey</body><body package="Store-DB-BaseObjects" selector="rawData">rawData	^blobData </body><body package="Store-DB-BaseObjects" selector="rawData:">rawData: aByteArray	"Store binary data with no conversions."	blobData := aByteArray.	self beByteArray.</body></methods><methods><class-id>Store.Blob</class-id> <category>accessing-types</category><body package="Store-DB-BaseObjects" selector="beByteArray">beByteArray	blobType := 4.</body><body package="Store-DB-BaseObjects" selector="beData">beData	blobType := 1.</body><body package="Store-DB-BaseObjects" selector="beString">beString	blobType := 2.</body><body package="Store-DB-BaseObjects" selector="beTwoByteString">beTwoByteString	blobType := 3.</body><body package="Store-DB-BaseObjects" selector="isByteArray">isByteArray	^blobType = 4</body><body package="Store-DB-BaseObjects" selector="isData">isData	^blobType = 1.</body><body package="Store-DB-BaseObjects" selector="isString">isString	^blobType = 2</body><body package="Store-DB-BaseObjects" selector="isTwoByteString">isTwoByteString	^blobType = 3.</body></methods><methods><class-id>Store.Blob</class-id> <category>private-two byte strings</category><body package="Store-DB-BaseObjects" selector="byteOrder">byteOrder	| test null chara |	test := 'abc' asTwoByteString.	null := 0.	chara := $a asInteger.	(((test basicAt: 1) = chara) and: [(test basicAt: 2) = null]) ifTrue: [^#(0 1)].	(((test basicAt: 2) = chara) and: [(test basicAt: 1) = null]) ifTrue: [^#(1 0)].	self error: 'Can not determine byte order for TwoByteString'</body><body package="Store-DB-BaseObjects" selector="decodeTwoByteDefinitionStream:">decodeTwoByteDefinitionStream: strm	| string2Byte order inx |	string2Byte := TwoByteString new: strm size.	order := self byteOrder.	inx := 1.	[strm atEnd]		whileFalse: 			[string2Byte basicAt: inx + order first put: (self readDecodedByteFrom: strm).			string2Byte basicAt: inx + order last put: (self readDecodedByteFrom: strm).			inx := inx + 2].	^string2Byte copyFrom: 1 to: ((inx - 1)//2)</body><body package="Store-DB-BaseObjects" selector="encodeTwoByteDefinition:">encodeTwoByteDefinition: aString	| strm order |	strm := WriteStream on: (String new: (aString size * 4)).	order := self byteOrder.	1 to: aString basicSize by: 2 do: [:inx|		self writeByte: (aString basicAt: inx + order first) encodedOn: strm.		self writeByte: (aString basicAt: inx + order last) encodedOn: strm].	^strm contents asByteArray</body><body package="Store-DB-BaseObjects" selector="readDecodedByteFrom:">readDecodedByteFrom: aStream 	| code |	code := aStream next asInteger.	^(code &gt;= 16 and: [code &lt;= 127])		ifTrue: [code]		ifFalse: [code = 1				ifTrue: [0]				ifFalse: [(code &gt;= 2 and: [code &lt;= 5])						ifTrue: [aStream next asInteger - 32 + ((code - 2) * 64)]						ifFalse: 							[self error: 'Invalid encoding of TwoByteString'.							0]]]</body><body package="Store-DB-BaseObjects" selector="writeByte:encodedOn:">writeByte: aByte encodedOn: aStream 	(aByte &gt;= 16 and: [aByte &lt;= 127])		ifTrue: [aStream nextPut: (Character value: aByte)]		ifFalse: [aByte = 0				ifTrue: [aStream nextPut: (Character value: 1)]				ifFalse: 					[aStream nextPut: (Character value: 2 + (aByte // 64)).					aStream nextPut: (Character value: 32 + (aByte \\ 64))]]</body></methods><methods><class-id>Store.Blob class</class-id> <category>private</category><body package="Store-DB-BaseObjects" selector="defaultBlockFactor">defaultBlockFactor	^1</body><body package="Store-DB-BaseObjects" selector="new">new	self error: 'Instances of Blob should be created using "fromString:" or "fromBin:" messages.'</body><body package="Store-DB-BaseObjects" selector="privateNewPrimed">privateNewPrimed	| baby |	baby := super new.	baby prime.	^baby</body></methods><methods><class-id>Store.Blob class</class-id> <category>installation</category><body package="Store-DB-BaseObjects" selector="defReferenceColumnNames">defReferenceColumnNames	"Answer the columns used when linking directly to sources in a view."	^Array 		with: ( self broker columnName: 'blobType' for: self )		with: ( self broker columnName: 'blobData' for: self )</body><body package="Store-DB-BaseObjects" selector="fieldTypes">fieldTypes	| aDict |	aDict := Dictionary new.	aDict at: 'primaryKey' put: #PrimaryKey.	aDict at: 'blobType' put: #Integer.	aDict at: 'blobData' put: #BinData.	self checkFieldsWith: aDict.	^aDict</body><body package="Store-DB-BaseObjects" selector="fromStoredDefinition:">fromStoredDefinition: aDefinition		| newDBDefinition |	newDBDefinition := self privateNewPrimed.	newDBDefinition primaryKey: aDefinition primaryKey.	newDBDefinition definition:  aDefinition definition.	newDBDefinition install.	^newDBDefinition</body><body package="Store-DB-BaseObjects" selector="indexParameters">indexParameters	"Answer a string specifying index parameters. If the default index is acceptable 	answer nil."	^'TABLESPACE  NEWBERN1 STORAGE(INITIAL 1M NEXT 256K)'</body><body package="Store-DB-BaseObjects" selector="needsSequence">needsSequence	^true</body><body package="Store-DB-BaseObjects" selector="storageParameters">storageParameters	"Answer a string describing special storage parameters for the table or nil if the default parameters are 	acceptable answer."	^'STORAGE(INITIAL 25M NEXT 2M PCTINCREASE 1) '</body><body package="Store-DB-BaseObjects" selector="tableSpaceName">tableSpaceName	"Answer a name of a tablespace the table should live in. If the default tablespace is acceptable 	answer nil."	^'NEWBERN1'</body></methods><methods><class-id>Store.Blob class</class-id> <category>private-db-utilities</category><body package="Store-DB-BaseObjects" selector="aRecordWithID:session:">aRecordWithID: anID session: aSession 	"Given a record ID (primary key) and a database session 	answer an instance of TT_Blob. 	Check for definitions that are stored in multiple chunks and 	combine multiple DB records into one definition."	"self aRecordWithID: 1"	| res |	res := self getRecordWithID: anID session: aSession.	res isNil ifTrue: [^nil].	"will call #retrieveSources:session:, but not now, or this version will be unloadable."	res hasFakeType ifTrue:		[| dataList record data dataSize index |		 "Use a LinkedList to collect all the chunks to defer allocating the result		 until the total size is known, avoiding n squared concatenation overhead."		dataList := LinkedList new.		record := res.		dataList addLast: (LinkValue value: record binData).				[record := self getRecordWithID: record nextChunk session: aSession.		dataList addLast: (LinkValue value: record binData).		record hasFakeType]			whileTrue.		res setBlobType: record getBlobType.		dataSize := dataList inject: 0 into: [:sz :dataLink| sz + dataLink value size].		data := dataList first value class new: dataSize.		index := 1.		dataList do:			[:dataLink| | binData binDataSize |			binData := dataLink value.			binDataSize := binData size.			data replaceFrom: index to: index + binDataSize - 1 with: binData startingAt: 1.			index := index + binDataSize].		res setData: data].	res convertData.	^res</body><body package="Store-DB-BaseObjects" selector="createDefinitionSession">createDefinitionSession	"Given a connection answer a session suitable 	for retriving definition records by thier 	primary keys."	| session |	session :=  self broker getNewSession.	session bindOutput: self privateNewPrimed; 			bindInput: self privateNewPrimed; 			prepare: 				( self newSQL					selectAll;					where;					column: #primaryKey equalTo: ':primaryKey').	^session</body><body package="Store-DB-BaseObjects" selector="definitionSession">definitionSession	"Answer a session for retrieving definition records 	by the primary key."	( self isSessionValid: DefinitionSession)		ifFalse: 			[DefinitionSession :=  self createDefinitionSession].	^DefinitionSession</body><body package="Store-DB-BaseObjects" selector="getRecordWithID:session:">getRecordWithID: anID session: aSession 	"Given a record ID (primary key) and a database session	answer an instance of TT_Blob.	This is low level access method which does not combine	records."	"self aRecordWithID: 1"	| res ans |	aSession bindInput primaryKey: anID.	aSession execute.	[ ans := aSession answer.	ans == #noMoreAnswers ]		whileFalse:			[ ans == #noAnswerStream ifFalse:				[ res  := ans upToEnd ] ].	^res isEmpty		ifTrue: [nil]		ifFalse: [res size &gt; 1				ifTrue: 					[self error: 'Duplicate method definition'.					nil]				ifFalse: 					[| rec |					rec := res first.					rec unprime; processFields.					rec]]</body><body package="Store-DB-BaseObjects" selector="resetSession">resetSession	DefinitionSession notNil		ifTrue: 			[ self brokerOrNil notNil 				ifTrue: [ self broker dismissSession: DefinitionSession ].			DefinitionSession := nil			].	WriteSession notNil		ifTrue: 			[ self brokerOrNil notNil 				ifTrue: [ self broker dismissSession: WriteSession ].			WriteSession := nil			]</body><body package="Store-DB-BaseObjects" selector="retrieveSources:session:">retrieveSources: aBlob session: aSession	"If the sources of aBlob are chunks, then read and concat. all the chunks."	aBlob hasFakeType 		ifTrue:			[ | dataList record data dataSize index |			 "Use a LinkedList to collect all the chunks to defer allocating the result			 until the total size is known, avoiding n squared concatenation overhead."			dataList := LinkedList new.			record := aBlob.		dataList addLast: (LinkValue value: record binData).				[record := self getRecordWithID: record nextChunk session: aSession.		dataList addLast: (LinkValue value: record binData).		record hasFakeType]			whileTrue.		aBlob setBlobType: record getBlobType.		dataSize := dataList inject: 0 into: [:sz :dataLink| sz + dataLink value size].		data := dataList first value class new: dataSize.		index := 1.		dataList do:			[:dataLink| | binData binDataSize |			binData := dataLink value.			binDataSize := binData size.			data replaceFrom: index to: index + binDataSize - 1 with: binData startingAt: 1.			index := index + binDataSize].		aBlob setData: data].	aBlob convertData.	^aBlob</body><body package="Store-DB-BaseObjects" selector="writeSession">writeSession	"Answer a session for storing blobs"	( self isSessionValid: WriteSession)			ifFalse: 				[WriteSession := self broker getNewSession.				WriteSession bindOutput: self privateNewPrimed; 								prepare: 									( self newSQL									insertColumns: #( primaryKey blobType blobData )									values: #( ':primaryKey'  ':getBlobType'  ':getBlobData' )).				].	^WriteSession</body></methods><methods><class-id>Store.Blob class</class-id> <category>instance creation</category><body package="Store-DB-BaseObjects" selector="aRecordWithID:">aRecordWithID: anID 	"Get a DB record identified by 'anID' from the DB."	"self aRecordWithID: 1"	( anID isNil or: [ anID = 0 ] )  ifTrue: [ ^self fromString: nil ].	^[ self broker safelyExecuteBlock: 		[ self aRecordWithID: anID session: self definitionSession ]	] 	on: self errorSignals 	do: 	[:ex |  ex outer. 			self fromString: nil ]</body><body package="Store-DB-BaseObjects" selector="fromBinData:">fromBinData: aByteArray	"Create a new DB record from a string,	fill in user name and time stamp.	If aString is nil answer a record with key = 0."	| newDBDefinition |	newDBDefinition := self privateNewPrimed.	newDBDefinition binData: aByteArray.	newDBDefinition install.	^newDBDefinition</body><body package="Store-DB-BaseObjects" selector="fromRawData:">fromRawData: aByteArray	"Create a new DB record from a bytearray, fill in user name and time stamp.	If aByteArray is nil answer a record with key = 0."	| newDBDefinition |	newDBDefinition := self privateNewPrimed.	newDBDefinition rawData: aByteArray.	newDBDefinition install.	^newDBDefinition</body><body package="Store-DB-BaseObjects" selector="fromString:">fromString: aString	"Create a new DB record from a string,	fill in user name and time stamp.	If aString is nil answer a record with key = 0."	| newDBDefinition string |	string := aString == nil ifTrue: [ aString ] ifFalse: [ aString asString ].	newDBDefinition := self privateNewPrimed.	newDBDefinition definition: string.	newDBDefinition install.	^newDBDefinition</body><body package="Store-DB-BaseObjects" selector="fromView:">fromView: aSourcesView	"Answer an instance from a view that includes sources"	"Note, that this is a temporary guy used for converting sources. The primaryKey is not known."	| blob |	( blob := self basicNew )		setBlobType: aSourcesView blobType;		setData: aSourcesView blobData.	self retrieveSources: blob session: self definitionSession.	^blob.</body></methods><methods><class-id>Store.Blob class</class-id> <category>private-garbage-collection</category><body package="Store-DB-BaseObjects" selector="allIdsForID:">allIdsForID: anID	"Answer a collection of all ids chained to anID"	| session list record |	session := self definitionSession.	record := self getRecordWithID: anID session: session.	record isNil ifTrue: [ ^#( ) ].	list := OrderedCollection new.	[ record hasFakeType ] whileTrue:		[ list addLast: record nextChunk.			record := self getRecordWithID: record nextChunk session: session.		].	^list</body><body package="Store-DB-BaseObjects" selector="removeAllDBRecordsForID:">removeAllDBRecordsForID: anID 	"Remove a record with a primary key, anID AND all the linked records."	( self allIdsForID: anID ) do:		[ :id | self removeFromDBRecordWithID: id ].	self removeFromDBRecordWithID: anID.</body><body package="Store-DB-BaseObjects" selector="removeFromDBRecordWithID:">removeFromDBRecordWithID: anID	"Remove a record with primary key = anID from the database.	Note that this method can only be sent by the database	system administrator, since it requires privileges	that are not given to the regular users."	self broker process: 			( self newSQL				delete;				where;				column: #primaryKey  equalTo: anID printString)</body></methods><methods><class-id>Store.BinaryBlob class</class-id> <category>private-db-utilities</category><body package="Store-DB-BaseObjects" selector="definitionSession">definitionSession	"Answer a session for retrieving definition records 	by the primary key."	( self isSessionValid: DefinitionSession)		ifFalse: 			[DefinitionSession := self  createDefinitionSession].	^DefinitionSession</body><body package="Store-DB-BaseObjects" selector="resetSession">resetSession	DefinitionSession notNil		ifTrue: 			[ self brokerOrNil notNil 				ifTrue: [ self broker dismissSession: DefinitionSession ].			DefinitionSession := nil]			.	WriteSession notNil		ifTrue: 			[ self brokerOrNil notNil 				ifTrue: [ self broker dismissSession: WriteSession ].			WriteSession := nil]</body><body package="Store-DB-BaseObjects" selector="writeSession">writeSession	"Answer a session for storing blobs"	( self isSessionValid: WriteSession)		ifFalse: 			[WriteSession := self broker getNewSession.			WriteSession bindOutput: self privateNewPrimed; 						prepare: 							( self newSQL								insertColumns: #( primaryKey blobType blobData )								values: #( ':primaryKey'  ':getBlobType'  ':getBlobData' )).			].	^WriteSession</body></methods><methods><class-id>Store.SubdefView</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="className">className	^className</body><body package="Store-DB-Subdefs" selector="className:">className: anObject	className := anObject</body><body package="Store-DB-Subdefs" selector="packageRef">packageRef	^packageRef</body><body package="Store-DB-Subdefs" selector="packageRef:">packageRef: anObject	packageRef := anObject</body><body package="Store-DB-Subdefs" selector="sourceCodeID">sourceCodeID	^sourceCodeID</body><body package="Store-DB-Subdefs" selector="sourceCodeID:">sourceCodeID: anObject	sourceCodeID := anObject</body></methods><methods><class-id>Store.SubdefView class</class-id> <category>installation</category><body package="Store-DB-Subdefs" selector="parentReference">parentReference	^'packageRef'</body></methods><methods><class-id>Store.SubdefView class</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="definitionReferenceColumn">definitionReferenceColumn	"Answer the column symbol of the column that contains the definition id."	^#sourceCodeID</body></methods><methods><class-id>Store.MethodsView</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="isMeta">isMeta	^className namesMetaClass</body><body package="Store-DB-Subdefs" selector="protocolName">protocolName	^protocolName</body><body package="Store-DB-Subdefs" selector="protocolName:">protocolName: aString	protocolName := aString</body></methods><methods><class-id>Store.MethodsView</class-id> <category>db-utilities</category><body package="Store-DB-Subdefs" selector="methodNamedInClass">methodNamedInClass	"Answer a method named :name in class :className."	| res |	res := (self broker				process: 					( self newSQL						selectAll;						where;						column: #packageRef  equalTo: ':primaryKey';						and;						column: #className  equalTo: ':className';						and;						column: #name  equalTo: ':name')				bindInput: self				bindOutput: self class newPrimed) 			collect: [:each | Method fromView: each].	res size &gt; 1 ifTrue: [self error: 'Duplicate method definition'].	^res isEmpty		ifTrue: [nil]		ifFalse: [res first]</body><body package="Store-DB-Subdefs" selector="methodsForClass">methodsForClass	^(self broker		process: 			( self newSQL				selectAll;				where;				column: #packageRef  equalTo: ':primaryKey';				and;				column: #className equalTo: ':className') 		bindInput: self		bindOutput: self class newPrimed) collect: [:each | Method fromView: each]</body><body package="Store-DB-Subdefs" selector="methodsForClassAndProtocol">methodsForClassAndProtocol	^(self broker		process: 			( self newSQL				selectAll;				where;				column: #packageRef equalTo: ':primaryKey';				and;				column: #className equalTo: ':className';				and;				column: #protocolName equalTo: ':protocolName')		bindInput: self		bindOutput: self class newPrimed ) collect: [:each | Method fromView: each]</body><body package="Store-DB-Subdefs" selector="protocols">protocols	^(self broker process: 					( self newSQL						selectDistinct: #( protocolName );						where;						column: #packageRef  equalTo: ':primaryKey';						and;						column: #className equalTo: ':className')				bindInput: self )		collect: [:each | each first]</body></methods><methods><class-id>Store.MethodsView class</class-id> <category>installation</category><body package="Store-DB-Subdefs" selector="childReference">childReference	^'methodRef'</body><body package="Store-DB-Subdefs" selector="referencedClass">referencedClass	^Method</body><body package="Store-DB-Subdefs" selector="subCollectionClass">subCollectionClass	^Methods</body></methods><methods><class-id>Store.MethodsView class</class-id> <category>db-utilities</category><body package="Store-DB-Subdefs" selector="methodNamed:class:package:">methodNamed: aSelector class: aClassName package: aPackageID 	"Answer a TT_Method or nil."	"self methodNamed: 'methodNamed:class:package:'		  class: 'Root.Smalltalk.Store.MethodsView class' 		  package: ( Registry packageNamed: 'Store-DB-Subdefs' ) parentRecord primaryKey"	| res |	res := self broker getAnswerFromSession: [ MethodsView methodInClassSession ]							bindInput: [ :session | 								( session bindInput ) 								primaryKey: aPackageID; 								className: aClassName; 								name: aSelector asString].	^(res isNil or: [ res isEmpty])		ifTrue: [ nil ]		ifFalse: 			[ res size &gt; 1				ifTrue: 					[ Transcript show: ( '&lt;n&gt;Warning: Duplicate method definition: &lt;1s&gt;&gt;&gt;&lt;2s&gt; in package id: &lt;3s&gt;'						expandMacrosWith: aClassName with: aSelector with: aPackageID printString ) .					].			Method fromView: res last			]</body><body package="Store-DB-Subdefs" selector="protocolsForClassNamed:package:">protocolsForClassNamed: aString package: aDBpackage 	^ self broker 			process: 				( self newSQL					selectDistinct: #( classname );					where;					column: #packageRef equalTo: ':primaryKey'					and;					column: #className equalTo: ':className')			bindInput: aDBpackage</body></methods><methods><class-id>Store.MethodsView class</class-id> <category>session</category><body package="Store-DB-Subdefs" selector="defaultBlockFactor">defaultBlockFactor	^1000</body><body package="Store-DB-Subdefs" selector="methodInClassSession">methodInClassSession	( self isSessionValid: MethodInClassSession)		ifFalse:			[MethodInClassSession := self broker getNewSession.			MethodInClassSession bindOutput: self newPrimed.			MethodInClassSession bindInput: self new.			MethodInClassSession prepare: 						( self newSQL							selectAll;							where;							column: #packageRef  equalTo: ':primaryKey';							and;							column: #className equalTo: ':className';							and;							column: #name  equalTo: ':name') ].	^MethodInClassSession</body><body package="Store-DB-Subdefs" selector="methodsSession">methodsSession	"MethodsSession := nil"	( self isSessionValid: MethodsSession )		ifFalse:			[ MethodsSession := self broker getNewSession				blockFactor: self blockFactor;				bindOutput: self newPrimed;				bindInput: self new;				prepare: 					( self newSQL						selectAll;						where;						column: #packageRef equalTo: ':primaryKey' 					);				yourself. 			].	^MethodsSession</body><body package="Store-DB-Subdefs" selector="resetSession">resetSession	MethodsSession notNil		ifTrue: 			[ self brokerOrNil notNil 				ifTrue: [ self broker dismissSession: MethodsSession ].			MethodsSession := nil			].	MethodInClassSession notNil		ifTrue: 			[ self brokerOrNil notNil 				ifTrue: [ self broker dismissSession: MethodInClassSession ].			MethodInClassSession := nil			]</body></methods><methods><class-id>Store.MethodsAndSourcesView</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="blobData">blobData	^blobData</body><body package="Store-DB-Subdefs" selector="blobType">blobType 	^blobType</body></methods><methods><class-id>Store.MethodsAndSourcesView class</class-id> <category>session</category><body package="Store-DB-Subdefs" selector="resetSession">resetSession	MethodsWithSourcesSession notNil		ifTrue: 			[ self brokerOrNil notNil 				ifTrue: [ self broker dismissSession: MethodsWithSourcesSession ].			MethodsWithSourcesSession := nil			].</body><body package="Store-DB-Subdefs" selector="sourcesSession">sourcesSession	"MethodsWithSourcesSession := nil"	( self isSessionValid: MethodsWithSourcesSession )		ifFalse: 	[ MethodsWithSourcesSession := self createSourcesSession ].	^MethodsWithSourcesSession</body></methods><methods><class-id>Store.Packages</class-id> <category>accessing</category><body package="Store-DB-Pundles" selector="asDBComponent">asDBComponent	"Answer a corresponding TT_Bundle."	| rec |	[rec := Package aRecordWithID: packageRef.]	on: self errorSignals	do: [ :ex | ex outer. ^nil].		rec isNil ifTrue: [ Pundle componentNotFoundSignal raiseWith: self].	^rec</body><body package="Store-DB-Pundles" selector="packageRef">packageRef	"Answer the receiver's packageRef."	^packageRef</body><body package="Store-DB-Pundles" selector="packageRef:">packageRef: newPackageRef	"Set the receiver's packageRef to newPackageRef."	packageRef := newPackageRef</body></methods><methods><class-id>Store.Packages</class-id> <category>printing</category><body package="Store-DB-Pundles" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream nextPut: $ .	packageRef printOn: aStream.	aStream nextPut: $&gt;.</body></methods><methods><class-id>Store.Packages</class-id> <category>private</category><body package="Store-DB-Pundles" selector="asComponentDescription">asComponentDescription		| baby |	baby := PackageDescription new.	baby id: packageRef.	^baby</body></methods><methods><class-id>Store.Packages class</class-id> <category>installation</category><body package="Store-DB-Pundles" selector="fieldTypes">fieldTypes	| aDict  |	aDict := super fieldTypes.	aDict at: 'packageRef' put: #PrimaryKey.	self checkFieldsWith: aDict.	^aDict</body></methods><methods><class-id>Store.Packages class</class-id> <category>accessing</category><body package="Store-DB-Pundles" selector="viewColumnNames">viewColumnNames	"Answer a collection of column names that should be included 	into a view table."	| coll |	coll := OrderedCollection withAll: super viewColumnNames.	coll add: 'expression'; add: 'seqNumber'.	^coll</body></methods><methods><class-id>Store.Packages class</class-id> <category>db-utilities</category><body package="Store-DB-Pundles" selector="enclosingComponentsOfId:">enclosingComponentsOfId: aPackageID	"Answer a collection of bundleIds that comprises the containers of a package, aPackageID."	^ self select: #bundleRef column: #packageRef  value: aPackageID printString.</body><body package="Store-DB-Pundles" selector="select:column:value:">select: column column: aCol value: aVal	"Answer a collection of bundles that comprise the containers of a bundle, aBundleID."	| sql |	sql := ( self newSQL			select: ( Array with: column );			where;			column: aCol equalTo: aVal ).	^[ ( self broker process: sql ) collect: [ :array | Bundle aRecordWithID: array first ] ] 		on: self  errorSignals 		do: 	[:ex |  ex outer.  OrderedCollection new ].</body></methods><methods><class-id>Store.DataView</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="commentID">commentID	^commentID</body><body package="Store-DB-Subdefs" selector="commentID:">commentID: id	^commentID := id</body><body package="Store-DB-Subdefs" selector="definitionID">definitionID 	^definitionID</body><body package="Store-DB-Subdefs" selector="definitionID:">definitionID: id	^definitionID := id</body><body package="Store-DB-Subdefs" selector="encodedDataID">encodedDataID	^self sourceCodeID</body><body package="Store-DB-Subdefs" selector="encodedDataID:">encodedDataID: anObject	self sourceCodeID: anObject</body><body package="Store-DB-Subdefs" selector="environmentString">environmentString	^environmentString</body><body package="Store-DB-Subdefs" selector="environmentString:">environmentString: aString	environmentString := aString</body><body package="Store-DB-Subdefs" selector="packageRef">packageRef	^packageRef</body><body package="Store-DB-Subdefs" selector="protocolName">protocolName	^protocolName</body><body package="Store-DB-Subdefs" selector="protocolName:">protocolName: aString	protocolName := aString</body><body package="Store-DB-Subdefs" selector="typeString">typeString	^typeString</body><body package="Store-DB-Subdefs" selector="typeString:">typeString: aString	typeString := aString</body></methods><methods><class-id>Store.DataView</class-id> <category>private</category><body package="Store-DB-Subdefs" selector="prime">prime	super prime.	version := Object new.</body><body package="Store-DB-Subdefs" selector="unprime">unprime	super unprime.	version := nil.</body></methods><methods><class-id>Store.DataView class</class-id> <category>installation</category><body package="Store-DB-Subdefs" selector="childReference">childReference	^'dataRef'</body><body package="Store-DB-Subdefs" selector="fieldTypes">fieldTypes		"self fieldTypes"	| aDict  |	( aDict := super fieldTypes )		at: 'typeString' put: #Char.	self checkFieldsWith: aDict.	^aDict</body><body package="Store-DB-Subdefs" selector="referencedClass">referencedClass	^DataElement				"^TT_Datum"</body><body package="Store-DB-Subdefs" selector="subCollectionClass">subCollectionClass	^Data</body></methods><methods><class-id>Store.DataView class</class-id> <category>session</category><body package="Store-DB-Subdefs" selector="dataKeySession">dataKeySession	"DataKeySession := nil"	( self isSessionValid: DataKeySession)		ifFalse: 			[DataKeySession := self broker getNewSession.			DataKeySession bindOutput: self newPrimed.			DataKeySession bindInput: self new.			DataKeySession prepare: 					( self newSQL						selectAll;						where;						column: #packageRef  equalTo: ':primaryKey';						and;						column: #name  equalTo: ':name') ].	^DataKeySession</body><body package="Store-DB-Subdefs" selector="dataSession">dataSession	"DataSession := nil"	( self isSessionValid: DataSession )		ifFalse: 			[ DataSession := self broker getNewSession				blockFactor: self blockFactor;				bindOutput: self newPrimed;				bindInput: self new;				prepare: 					( self newSQL 						selectAll; 						where; 						column: #packageRef equalTo: ':primaryKey' 					);				yourself. 			].	^DataSession</body><body package="Store-DB-Subdefs" selector="resetSession">resetSession	DataSession notNil		ifTrue: 			[ self brokerOrNil notNil 				ifTrue: [ self broker dismissSession: DataSession ].			DataSession := nil			].	DataKeySession notNil		ifTrue: 			[ self brokerOrNil notNil 				ifTrue: [ self broker  dismissSession: DataKeySession ].			DataKeySession := nil 			]</body></methods><methods><class-id>Store.DataView class</class-id> <category>db-utilities</category><body package="Store-DB-Subdefs" selector="datumWithKey:ownerName:package:">datumWithKey: dataKey ownerName: aFullName package: aPackageID	"Answer a TT_DataElement or nil."	| res |	[ res := self broker 				getAnswerFromSession: [ DataView dataKeySession ] 				bindInput: [ :session | ( session bindInput) primaryKey: aPackageID; name: dataKey asString ].	] 	on: self  errorSignals 	do: 	[:ex |  ex outer. ^nil].	^res isEmpty		ifTrue: [ nil ]		ifFalse: 			[ res := res collect: [ : each | DataElement fromView: each ].			res := res select: [ :de | de environmentString = aFullName ].			res size == 0 				ifFalse:					[ res size &gt; 1						ifTrue: [ self error: 'Duplicate data definition'. nil ]						ifFalse: [ DataElement fromView: res first ]					]			]</body></methods><methods><class-id>Store.DataView class</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="columnNames">columnNames		"self columnNames"	| columnNames |	columnNames := super columnNames.	columnNames remove: 'version'.	^columnNames</body></methods><methods><class-id>Store.DataAndSourcesView</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="blobData">blobData	^blobData</body><body package="Store-DB-Subdefs" selector="blobType">blobType 	^blobType</body></methods><methods><class-id>Store.DataAndSourcesView class</class-id> <category>session</category><body package="Store-DB-Subdefs" selector="resetSession">resetSession	DataWithSourcesSession notNil		ifTrue: 			[ self brokerOrNil notNil 				ifTrue: [ self broker dismissSession: DataWithSourcesSession ].			DataWithSourcesSession := nil			].</body><body package="Store-DB-Subdefs" selector="sourcesSession">sourcesSession	"DataWithSourcesSession := nil"	( self isSessionValid: DataWithSourcesSession )		ifFalse: [ DataWithSourcesSession := self createSourcesSession ].	^DataWithSourcesSession</body></methods><methods><class-id>Store.DataAndSourcesView class</class-id> <category>db-utilities</category><body package="Store-DB-Subdefs" selector="dataWithSourcesIn:">dataWithSourcesIn: aPackage	| dbMethods | 	^[ dbMethods := self broker 						getAnswerFromSession: [ self dataWithSourcesSession ]						bindInput: [ :session | session bindInput primaryKey: aPackage primaryKey].	dbMethods collect: [ :each | DataElement fromSourcesView: each ].	] 	on: self  errorSignals 	do: 	[ :ex | ^OrderedCollection new ].</body></methods><methods><class-id>Store.PkgClassesAndSourcesView</class-id> <category>accessing</category><body package="Store-DB-Records" selector="blobData">blobData	^blobData</body><body package="Store-DB-Records" selector="blobType">blobType 	^blobType</body></methods><methods><class-id>Store.PkgClassesAndSourcesView class</class-id> <category>session</category><body package="Store-DB-Records" selector="resetSession">resetSession	ClassesWithSourcesSession notNil		ifTrue: 			[ self brokerOrNil notNil 				ifTrue: [ self broker dismissSession: ClassesWithSourcesSession ].			ClassesWithSourcesSession := nil			].</body><body package="Store-DB-Records" selector="sourcesSession">sourcesSession	"ClassesWithSourcesSession := nil"	( self isSessionValid: ClassesWithSourcesSession )		ifFalse: 	[ ClassesWithSourcesSession := self createSourcesSession ].	^ClassesWithSourcesSession</body></methods><methods><class-id>Store.VersionNode</class-id> <category>private-calculations</category><body package="Store-Merge" selector="becomeParentFor:">becomeParentFor: aNode	aNode parent: self.	children add: aNode.</body><body package="Store-Merge" selector="buildTowardsRoot:initial:">buildTowardsRoot: aRoot initial: initialNode 	"Move towards the specified root. 	If I'm older then the root then process stops. 	If I'm part of another tree then reparent the root of the	other tree off the 'initialNode'.	Answer either root or the node containing package older 	then the root.	If the common ancestor of me and aRoot cannot be found	raise an exception and then answer nil."	| node myParent |	(aRoot package youngerThan: self package)		ifTrue: [^self].	myParent := self package tracePackage.	node := myParent isNil				ifTrue: ["We cannot reach the root, Raise a signal."						self class noCommonAncestorSignal raiseRequestWith:  							(Array with: initialNode package with: aRoot package).						^nil]				ifFalse: [aRoot nodeContainingVersion: myParent primaryKey].	^node isNil		ifTrue: 			[node := self class on: myParent.			node becomeParentFor: self.			node buildTowardsRoot: aRoot initial: initialNode]		ifFalse: 			[node becomeParentFor: self.			aRoot]</body><body package="Store-Merge" selector="buildTree:">buildTree: integrationReady	"Given an initial package version find all integration-ready 	versions and build a tree which encompasses all 	integration-ready versions. 	Answer the root of the newly built tree."	| rNode  |	rNode := self.	integrationReady do: [:iv | (rNode nodeContainingVersion: iv primaryKey) isNil			ifTrue: 				[| n1 n2 res |				n1 := self class on: iv.				n2 := rNode.								[res := n1 buildTowardsRoot: n2 initial: self.				res = n2 or: [res isNil]]					whileFalse: 						[n1 := n2.						n2 := res].				res notNil ifTrue: [rNode := res]]].	rNode compressPreserving: self.	rNode setLevel: 0.	^rNode</body><body package="Store-Merge" selector="compressPreserving:">compressPreserving: aNode	"Remove all the nodes whith only	one child. Do not remove aNode"	self isLeaf ifTrue: [^self].	(self isRoot not and: [self package ~= aNode package and:  [children size = 1]])		 ifTrue:			[|child|			child := children asArray first.			parent remove: self.			parent children add: child.			child parent: parent.			child compressPreserving: aNode]		ifFalse:			[children do: [:each| each compressPreserving: aNode]]</body><body package="Store-Merge" selector="remove:">remove: aNode	"Remove aNode form my children."	children remove: aNode.</body><body package="Store-Merge" selector="setLevel:">setLevel: aLevel	level := aLevel.	children do: [:each| each setLevel: aLevel + 1]</body></methods><methods><class-id>Store.VersionNode</class-id> <category>testing</category><body package="Store-Merge" selector="nodeContainingVersion:">nodeContainingVersion: aKey 	"Starting from me as a tree root answer 	a node which contains a package with	the specified key."	| res |	self package primaryKey= aKey ifTrue: [^self].	self children do: [:ch | (res := ch nodeContainingVersion: aKey) notNil ifTrue: [^res]].	^nil</body></methods><methods><class-id>Store.VersionNode</class-id> <category>accessing</category><body package="Store-Merge" selector="children">children	^children</body><body package="Store-Merge" selector="children:">children: aValue	children := aValue</body><body package="Store-Merge" selector="isLeaf">isLeaf	^children isEmpty</body><body package="Store-Merge" selector="isRoot">isRoot	^parent isNil</body><body package="Store-Merge" selector="leaves">leaves	"Assuming that I'm the root of the tree	answer all leaves."	| leaves |	children isEmpty 		ifTrue: [^Set with: self].	leaves := Set new.	children do: [:each| leaves addAll: each leaves].	^leaves</body><body package="Store-Merge" selector="level">level	^level</body><body package="Store-Merge" selector="maxLevel">maxLevel	"Assuming that I'm the root of the tree 	calculate the biggest level."	| mLev |	mLev := level.	children do: [:each | mLev := mLev max: each maxLevel].	^mLev</body><body package="Store-Merge" selector="nodesAtLevel:">nodesAtLevel: aLevel 	"Assuming that I'm the root of the tree 	answer all my children that are at level aLevel."	| coll |	level = aLevel ifTrue: [^Set with: self].	coll := Set new.	children do: [:each | 		coll addAll: (each nodesAtLevel: aLevel)].	^coll</body><body package="Store-Merge" selector="package">package	^package</body><body package="Store-Merge" selector="package:">package: aValue	package := aValue</body><body package="Store-Merge" selector="parent">parent	^parent</body><body package="Store-Merge" selector="parent:">parent: aValue	parent := aValue</body></methods><methods><class-id>Store.VersionNode</class-id> <category>initialize release</category><body package="Store-Merge" selector="initialize">initialize	children := Set new.</body></methods><methods><class-id>Store.VersionNode</class-id> <category>printing</category><body package="Store-Merge" selector="printOn0:">printOn0: aStream	aStream nextPut: ${.	package primaryKey printOn: aStream.		aStream nextPut: $,.		parent isNil 		ifFalse: [parent package primaryKey printOn: aStream].	aStream nextPut: $,.	aStream nextPut: $(.	children do: [:each|		each package primaryKey printOn: aStream.			aStream nextPut: $ .].	aStream nextPut: $).	aStream nextPut: $}.</body><body package="Store-Merge" selector="printOn:">printOn: aStream 	aStream nextPut: Character space.	parent isNil ifFalse: [aStream nextPutAll: parent package version].	aStream nextPut: $-.	aStream nextPutAll: package version.	aStream nextPut: $-.	aStream nextPut: $(.	children		do: 			[:each | 			aStream nextPutAll: each package version.			aStream nextPut: Character space].	aStream nextPut: $)</body></methods><methods><class-id>Store.VersionNode class</class-id> <category>Signal constants</category><body package="Store-Merge" selector="noCommonAncestorSignal">noCommonAncestorSignal	^MergeTool noCommonAncestorSignal</body></methods><methods><class-id>Store.VersionNode class</class-id> <category>instance creation</category><body package="Store-Merge" selector="on:">on: aPackageVersion 	^(self new) initialize; package: aPackageVersion; yourself</body></methods><methods><class-id>Store.BasicPrerequisitePolicy</class-id> <category>private</category><body package="Store-User Management" selector="initialVersionOf:fromList:version:">initialVersionOf: reqName fromList: pundleList version: reqVersion	"Answer the inital version for testing. nil means user cancelled."	| pundle |	versionSelection == #ask		ifFalse: [ pundle := pundleList detect: [ :p | p blessingLevelNumber &gt;= blessingLevel ] ifNone: nil ].	pundle == nil		ifTrue: [ pundle := self selectPrereqVersionOf: reqName fromList: pundleList version: reqVersion ].	^pundle</body><body package="Store-User Management" selector="selectPrereqVersionOf:fromList:version:">selectPrereqVersionOf: aPundleName fromList: aList version: aString	"Display a list of pundle versions. Answer the selection,	nil if none. Send to appropiate subclass."		 ^Dialog 		choose: ((#ChoosePrereq &lt;&lt; #store &gt;&gt; 'Choose version to fullfill prerequiste: &lt;1s&gt;') expandMacrosWith:  aString)		fromList: ( aList collect: [ :m | m displayString, ' ', m blessingLevelString ] )		values: aList		lines: 10 cancel: [ ^nil ]		for: nil.</body></methods><methods><class-id>Store.BasicPrerequisitePolicy</class-id> <category>accessing</category><body package="Store-User Management" selector="blessingLevel">blessingLevel	blessingLevel == nil		ifTrue: [ blessingLevel := Policies blessingPolicy defaultBlessing ].	^blessingLevel</body><body package="Store-User Management" selector="blessingLevel:">blessingLevel: anInteger	blessingLevel := anInteger</body><body package="Store-User Management" selector="searchOrder">searchOrder	searchOrder == nil		ifTrue: [ searchOrder := #parcelsFirst ].	^searchOrder</body><body package="Store-User Management" selector="searchOrder:">searchOrder: aSymbol		searchOrder := aSymbol</body><body package="Store-User Management" selector="versionSelection">versionSelection	versionSelection == nil		ifTrue: [ versionSelection := #ask ].	^versionSelection</body><body package="Store-User Management" selector="versionSelection:">versionSelection: aSymbol	versionSelection := aSymbol</body></methods><methods><class-id>Store.BasicPrerequisitePolicy</class-id> <category>selecting</category><body package="Store-User Management" selector="getPrereq:from:version:for:">getPrereq: reqName from: pundleList version: reqVersion for: aPundle 	"Removed loop. Enabled to enforce loading of differing package version"	| pundle |	( pundle := self 				initialVersionOf: reqName				fromList: pundleList				version: reqVersion ) == nil 		ifTrue: [ ^ nil ].	"user cancelled selection"	( pundle == nil or: 			[ aPundle 				checkPrerequisiteNamed: reqName				withVersion: pundle version				requiredVersion: reqVersion ] ) 		ifTrue: [ ^pundle ].	( Dialog confirm: ( '&lt;1s&gt; requires&lt;nt&gt;&lt;2s&gt; version: &lt;3s&gt;&lt;n&gt;Do you want to load&lt;nt&gt;&lt;4s&gt;&lt;n&gt;instead?' 						expandMacrosWith: aPundle displayString with: reqName with: reqVersion with: pundle displayString ) )			ifTrue: [ ^pundle ].	^self selectPrereqVersionOf: reqName fromList: pundleList version: reqVersion.</body></methods><methods><class-id>Store.ConnectionProfile</class-id> <category>accessing</category><body package="Store-DB-BaseObjects" selector="connectionStatus">connectionStatus	^self isConnected		ifTrue: ['Connected']		ifFalse: ['']</body><body package="Store-DB-BaseObjects" selector="isConnected">isConnected	^DbRegistry connectedProfileHolder value = self</body><body package="Store-DB-BaseObjects" selector="tableOwner">tableOwner	^tableOwner</body><body package="Store-DB-BaseObjects" selector="tableOwner:">tableOwner: aString 	tableOwner := aString</body></methods><methods><class-id>Store.ConnectionProfile</class-id> <category>initialize-release</category><body package="Store-DB-BaseObjects" selector="initialize">initialize	super initialize.	tableOwner := 'BERN'.</body><body package="Store-DB-BaseObjects" selector="initializeFromXml:">initializeFromXml: anElement	name := anElement valueOfAttribute: 'name' ifAbsent: [self error: 'invalid file format'].	driverClassName := self valueOf: anElement childNamed: 'driver-class-name'.	environment := self valueOf: anElement childNamed: 'environment'.	userName := self valueOf: anElement childNamed: 'user-name'.	password := self valueOf: anElement childNamed: 'password'.	tableOwner := self valueOf: anElement childNamed: 'table-owner'.	self isValid ifFalse: [self error: 'invalid attributes specified in the file']</body></methods><methods><class-id>Store.ConnectionProfile</class-id> <category>private</category><body package="Store-DB-BaseObjects" selector="addXmlElementsTo:">addXmlElementsTo: anElement	anElement		addNode: (self elementFor: 'driver-class-name' with: self driverClassName);		addNode: (self elementFor: 'environment' with: self environment);		addNode: (self elementFor: 'user-name' with: self userName);		addNode: (self elementFor: 'password' with: self password);		addNode: (self elementFor: 'table-owner' with: self tableOwner)</body><body package="Store-DB-BaseObjects" selector="asXmlNode">asXmlNode	| root |	root := Element 		tag: 'store-repository' 		attributes: (Array with: (Attribute name: 'name' value: name))		elements: nil.	self addXmlElementsTo: root.	^root</body><body package="Store-DB-BaseObjects" selector="elementFor:with:">elementFor: tagString with: contentsString	^(Element tag: tagString)		addNode: (XML.Text text: contentsString)</body><body package="Store-DB-BaseObjects" selector="valueOf:childNamed:">valueOf: anElement childNamed: aString	| children textElement |	children := (anElement elementNamed: aString) children.	children isEmpty ifTrue: [^String new].	textElement := children first.	textElement isText ifFalse: [self error: 'invalid file format'].	^textElement text</body></methods><methods><class-id>Store.ConnectionProfile class</class-id> <category>instance creation</category><body package="Store-DB-BaseObjects" selector="fromXmlElement:">fromXmlElement: anElement	^self new initializeFromXml: anElement</body></methods><methods><class-id>Tools.StoreRepositoryListSetting</class-id> <category>persistence</category><body package="Store-UI" selector="addStateXmlElementsTo:">addStateXmlElementsTo: anElement	profiles do: 		[:each |		anElement addNode: each asXmlNode]</body><body package="Store-UI" selector="restoreFrom:">restoreFrom: aSettingSnapshot	| newProfiles |	newProfiles := OrderedCollection new.	aSettingSnapshot stateNodes do:		[:each | | profile |		profile := ConnectionProfile fromXmlElement: each.		newProfiles add: profile].	profiles := newProfiles.	self installProfiles</body></methods><methods><class-id>Tools.StoreRepositoryListSetting</class-id> <category>initialize-release</category><body package="Store-UI" selector="initialize">initialize	super initialize.	profiles := RepositoryManager repositories copy asList</body></methods><methods><class-id>Tools.StoreRepositoryListSetting</class-id> <category>actions</category><body package="Store-UI" selector="installProfiles">installProfiles	RepositoryManager replaceRepositoriesWith: profiles</body><body package="Store-UI" selector="profiles">profiles	^profiles</body><body package="Store-UI" selector="resetProfiles">resetProfiles	profiles := RepositoryManager repositories copy asList</body></methods><methods><class-id>Tools.StoreRepositoryListSetting class</class-id> <category>instance creation</category><body package="Store-UI" selector="new">new	^super new initialize</body></methods><methods><class-id>Store.BundlePrivilegeGraph</class-id> <category>interface opening</category><body package="Store-UI-Graphs" selector="postOpenWith:">postOpenWith: aBuilder "	super postOpenWith: aBuilder. Not needed yet. "		self updateUserGroupList.	self updateBundleList.	self setButtons.	self updateText.	self mainWindow label: 'Bundle - User / Group Privliges'.	(self widgetAt: #pundleLabel) labelString: 'Bundle:'.</body></methods><methods><class-id>Store.BundlePrivilegeGraph</class-id> <category>private</category><body package="Store-UI-Graphs" selector="updateBundleList">updateBundleList	| bndls |	bndls := Store.Registry allBundles.	Store.Bundle allNames do: 			[:name | 			(bndls contains: [:bndl | bndl name = name]) 				ifFalse: [bndls add: (Store.Bundle newNamed: name)]].	self packageList 		list: (bndls asSortedCollection: [:a :b | a name &lt; b name]) 				asOrderedCollection</body></methods><methods><class-id>Store.BundlePrivilegeGraph</class-id> <category>actions</category><body package="Store-UI-Graphs" selector="grant:">grant: aSymbol	| owner |	owner  := userGroupList selection.	packageList selections do:		[ :bundle | 		bundle allItems asSet do:			[ :comp | self privilegeManager grant: aSymbol to: owner for: comp  ].		].	self updateText.	self setButtons.</body><body package="Store-UI-Graphs" selector="revokeRights">revokeRights	| owner |	owner  := userGroupList selection.	packageList selections do:		[ :pkg | 		pkg allItems asSet do:			[ :comp | self privilegeManager revokeAllFor: owner for: comp ]		].	self updateText.	self setButtons.</body></methods><methods><class-id>Store.PackageVersionBrowserHelper</class-id> <category>list accessing</category><body package="Store-UI-Browser" selector="selectionChanged">selectionChanged	self browser updateText.</body><body package="Store-UI-Browser" selector="textForItem:">textForItem: aListEntry	"Answer the text for the item in the list."	^( '&lt;1s&gt;&lt;t&gt;&lt;t&gt;&lt;2s&gt;'		expandMacrosWith: aListEntry longItemString		with: aListEntry blessingLevelString	) asText</body><body package="Store-UI-Browser" selector="updateListFull">updateListFull		"Fill the list with the active list of classes and namespaces."	"fixed list - do nothing"</body></methods><methods><class-id>Store.PackageVersionBrowserHelper</class-id> <category>menus</category><body package="Store-UI-Browser" selector="editBundleSpec">editBundleSpec	"remove this menu item."</body><body package="Store-UI-Browser" selector="makeCurrent">makeCurrent	"remove this menu item."</body><body package="Store-UI-Browser" selector="renamePundle">renamePundle	"remove this menu item."</body></methods><methods><class-id>Store.PackageVersionBrowserHelper</class-id> <category>menus accessing</category><body package="Store-UI-Browser" selector="actionsForUnloadedPackages">actionsForUnloadedPackages	^#( #fileOutPackages #graphVersions #enclosingComponents #loadPundle 			#fileOutDifferences #diffPackageWithParent  #diffWithVersion 			#packageProperties #spawn #reconcile #mergePundleVersion )</body></methods><methods><class-id>Store.UnloadableExeceptionBrowserHelper</class-id> <category>actions</category><body package="Store-UI-Browser" selector="browseVersions">browseVersions	self selections do:		[ :exp | exp definitionRecord browseVersions ]</body><body package="Store-UI-Browser" selector="fileOut">fileOut	| fileName aFileManager |	fileName := Dialog requestNewFileName: 'File out on:' default: 'unloadable.st'.	fileName isEmpty ifTrue: [ ^nil ].	aFileManager := SourceCodeStream  write: fileName.	[ self selections do:		[ :exp | exp definitionRecord fileOutOn: aFileManager ]	] ensure: [ aFileManager close ]</body><body package="Store-UI-Browser" selector="help">help	SimpleDialog openOn: ( SimpleHelp helpString: self helpString ).</body><body package="Store-UI-Browser" selector="loadDefinition">loadDefinition	self selections do:		[ :exp | exp loadRecord ]</body><body package="Store-UI-Browser" selector="removeFromPackage">removeFromPackage	self selections do:		[ :exp | exp removeRecord ]</body></methods><methods><class-id>Store.UnloadableExeceptionBrowserHelper</class-id> <category>menus accessing</category><body package="Store-UI-Browser" selector="actionsForMultiSelect">actionsForMultiSelect	^#( #fileOut #browseVersions #loadDefinition #removeFromPackage )</body><body package="Store-UI-Browser" selector="actionsForNoSelect">actionsForNoSelect	^#( #help )</body></methods><methods><class-id>Store.UnloadableExeceptionBrowserHelper</class-id> <category>text processing</category><body package="Store-UI-Browser" selector="acceptDefinition:from:">acceptDefinition: aText from: aController	"Compiles random defintion - which is too random for this case."	^nil</body><body package="Store-UI-Browser" selector="helpString">helpString^'This is a list of definitions which could not be loaded. Your options are:Load them. If there is a problem with your prerequisites or bundle load ordering, they may be loadable now. Fix the problem and republish.  Alternatively, if the load problem can be fixed without touching this package, you may wish to simply publish the containing bundle, quit your image and reload.Remove them from the package.  Any definitions that cannot be loaded should be removed. This is because Store publishes only deltas. A definition needs to be explicitly removed or it will remain there and the same problems will occur.Fileout. If a Class or NameSpace has been moved to a different NameSpace, your extension methods may not load.  You can file them out, edit the name and file them into your package. Remember to remove these old definitions from the package as explained above.'</body><body package="Store-UI-Browser" selector="text">text	self selection == nil		ifTrue: [ ^nil ].	^self selection definitionRecord definition asText.</body></methods><methods><class-id>Store.UnloadableExeceptionBrowserHelper</class-id> <category>selections</category><body package="Store-UI-Browser" selector="defaultAttribute">defaultAttribute	"Answer the default attribute that this helper is responsible for selecting."	^#exception</body></methods><methods><class-id>Store.UnloadableExeceptionBrowserHelper class</class-id> <category>menus accessing</category><body package="Store-UI-Browser" selector="menuHeader">menuHeader	^'Exception'</body></methods><methods><class-id>Store.ParcelRecord</class-id> <category>testing</category><body package="Store-DB-Pundles" selector="isParcel">isParcel	^true</body></methods><methods><class-id>Store.ParcelRecord</class-id> <category>private</category><body package="Store-DB-Pundles" selector="getDefinitionID:">getDefinitionID: anID	"Override definition in Record because my definitions are raw data."	^(self getDefinitionRecordID: anID) rawData</body><body package="Store-DB-Pundles" selector="prepareInstallation">prepareInstallation	"Create first records for both definition string and comment string."	self sourceID == nil		ifTrue: [ self sourceID: (self class definitionClass fromRawData: sourceData ) primaryKey ].	self blobID == nil		ifTrue: [ self blobID: ( self class definitionClass fromRawData: blobData ) primaryKey ].</body><body package="Store-DB-Pundles" selector="prime">prime	"Put instances of Object into slots that are not mapped into columns in the DB.	This is crucial for reading from DB since the primed slots are skipped"	super prime.	pundle := blobData := sourceData := Object new.</body><body package="Store-DB-Pundles" selector="unprime">unprime	"Remove the effect of priming (see the prime method)."	super unprime.	pundle := blobData := sourceData := nil.</body></methods><methods><class-id>Store.ParcelRecord</class-id> <category>accessing</category><body package="Store-DB-Pundles" selector="asString">asString	"Answer a string representation - for binary parcel loading"	^name</body><body package="Store-DB-Pundles" selector="blobData">blobData	"Allow for lazy evaluation."	blobData == nil		ifTrue: [ blobData := self getDefinitionID: self blobID ].	^blobData</body><body package="Store-DB-Pundles" selector="blobData:">blobData: byteArray	^blobData := byteArray</body><body package="Store-DB-Pundles" selector="blobID">blobID	^blobID</body><body package="Store-DB-Pundles" selector="blobID:">blobID: anInteger	blobID := anInteger</body><body package="Store-DB-Pundles" selector="defaultParcelName">defaultParcelName	"This method is used to return a name that can be used in the creation	of a temporary source file (*.pst) when loading a parcel from a Store	database.  Currently only uses [name][primaryKey].pst but will need to	also have some way of identifying the database being accessed since	two different ParcelRecords in two different databases could have the	same name and the same primary key."	self needsMoreWork.	^name, primaryKey printString</body><body package="Store-DB-Pundles" selector="filename">filename	^filename</body><body package="Store-DB-Pundles" selector="filename:">filename: aFilename	filename := aFilename</body><body package="Store-DB-Pundles" selector="getImagePundle">getImagePundle	"Check if there is already loaded versions of the receiver and answer it"	^Parcel parcelNamed: self name.</body><body package="Store-DB-Pundles" selector="parcelName">parcelName	"Answer a parcel name for the receiver - use the package properties where possible."	^pundle == nil		ifTrue: [ name ]		ifFalse: [ pundle parcelName ].</body><body package="Store-DB-Pundles" selector="pundle:">pundle: value	pundle := value</body><body package="Store-DB-Pundles" selector="pundleID">pundleID	^pundleID</body><body package="Store-DB-Pundles" selector="pundleID:">pundleID: anInteger	pundleID := anInteger</body><body package="Store-DB-Pundles" selector="readHeader">readHeader	[^CodeReader new readHeaderFromRecord: self]		on: CodeReader fileFormatSignal		do:[:ex | ex return]</body><body package="Store-DB-Pundles" selector="readInfo">readInfo	[^CodeReader new readInfoFromRecord: self]		on: CodeReader fileFormatSignal		do:[:ex | ex return]</body><body package="Store-DB-Pundles" selector="sourceData">sourceData	"Allow for lazy evaluation."	sourceData == nil		ifTrue: [ sourceData := self getDefinitionID: self sourceID ].	^sourceData</body><body package="Store-DB-Pundles" selector="sourceData:">sourceData: byteArray	^sourceData := byteArray</body><body package="Store-DB-Pundles" selector="sourceID">sourceID	^sourceID</body><body package="Store-DB-Pundles" selector="sourceID:">sourceID: anInteger	sourceID := anInteger</body><body package="Store-DB-Pundles" selector="sourceStream">sourceStream	"Answer an internal encoded source stream on the package source."		^self sourceData == nil		ifTrue: [ nil ]		ifFalse: [ ( sourceData withEncoding: #Source) "readStream" ]</body></methods><methods><class-id>Store.ParcelRecord class</class-id> <category>installation</category><body package="Store-DB-Pundles" selector="columnNames">columnNames		"self columnNames"	 ^super columnNames	 	remove: 'pundle';		remove: 'blobData' ;		remove: 'sourceData';		yourself</body><body package="Store-DB-Pundles" selector="fieldTypes">fieldTypes		" self fieldTypes "	^super fieldTypes		 at: 'pundleID' put: #Integer;		 at: 'blobID' put: #Integer;		 at: 'sourceID' put: #Integer;		 at: 'pundleType' put: #Char;		yourself</body><body package="Store-DB-Pundles" selector="needsSequence">needsSequence	^true</body></methods><methods><class-id>Store.ParcelRecord class</class-id> <category>instance creation</category><body package="Store-DB-Pundles" selector="from:">from: aPackage	"Create a parcel record for a packagel.  	Do not install the record in the database."	^( self newNamed: aPackage name )		pundleID: aPackage primaryKey.</body><body package="Store-DB-Pundles" selector="newNamed:">newNamed: aName 	"Create a record for a parcel. Put the name and the time stamp. 	Do not install the package in the database."	^self new		setNoTrace; 		name: aName; 		timeStamp: self timeStamp;		yourself.</body></methods><methods><class-id>Store.ParcelRecord class</class-id> <category>constants</category><body package="Store-DB-Pundles" selector="definitionClass">definitionClass	^BinaryBlob</body><body package="Store-DB-Pundles" selector="imageClass">imageClass	^Parcel</body></methods><methods><class-id>Store.ParcelRecord class</class-id> <category>accessing</category><body package="Store-DB-Pundles" selector="parcelDirectory">parcelDirectory	"self parcelDirectory"	| dir env |	dir := UISettings preferenceFor: #packageDir.	( dir == nil or: [ dir isEmpty ] )		ifTrue: [ dir := Filename currentDirectory ]		ifFalse: [ dir := ( Filename canonicalize: dir ) asLogicalFileSpecification ].	( env := DbRegistry databaseIdentifier ) == nil 		ifFalse: 	[ dir := dir construct:  ( Filename canonicalize: env ) ].	^dir</body></methods><methods><class-id>Store.VersionGraph</class-id> <category>interface opening</category><body package="Store-UI-Graphs" selector="postOpenWith:">postOpenWith: aBuilder 	"This message is sent by the builder after it has opened a completed 	window."	| focus |	pundle isNil ifFalse: [aBuilder window label: 'Versions of ' , pundle name].	focus := self graphView focus value asArray.	focus size = 1 ifTrue: [self graphView select: focus first].</body></methods><methods><class-id>Store.VersionGraph</class-id> <category>accessing</category><body package="Store-UI-Graphs" selector="perspective">perspective	^#tt_derives</body><body package="Store-UI-Graphs" selector="pundle:">pundle: aPundle	pundle := aPundle</body></methods><methods><class-id>Store.VersionGraph</class-id> <category>initialize-release</category><body package="Store-UI-Graphs" selector="loadInitialVersions">loadInitialVersions	| punSet cache focus |	punSet := Set new.	(pundle isLoaded or: [pundle primaryKey notNil])		ifTrue: [punSet add: pundle]		ifFalse: 			[| list |			list := pundle class allVersionsWithName: pundle name.			list isEmpty				ifTrue: 					[Dialog warn: 'There are no published versions of "' , self pundle name , '".'.					^false].			punSet add: list last.			list do: [:each | (each dbTrace = 0 or: [each dbTrace isNil])					ifTrue: [punSet add: each]]].	cache := Dictionary new.	focus := punSet collect: [:pun | ElementProxy element: pun cache: cache].	self graphView focus: focus.	^true</body></methods><methods><class-id>Store.VersionGraph</class-id> <category>actions</category><body package="Store-UI-Graphs" selector="reloadVersions">reloadVersions	| pun |	pundle isLoaded		ifTrue: 			[pun := pundle isBundle						ifTrue: [Registry bundleNamed: pundle name]						ifFalse: [Registry packageNamed: pundle name].			pun isNil ifTrue: [(pun := pun classOfDbRecord mostRecentVersionOfPundleWithName: pundle name) isNil ifTrue: [^Dialog warn: pundle name , ' does not exist']].			self pundle: pun].	self loadInitialVersions</body></methods><methods><class-id>Store.VersionGraph class</class-id> <category>instance creation</category><body package="Store-UI-Graphs" selector="browseVersionsOfPundle:">browseVersionsOfPundle: aPundle 	DbRegistry		doIfOnlineImage: 			[| preferredPresentation |			preferredPresentation := UISettings preferenceFor: #versionManagerView.			Cursor wait				showWhile: 					[| graph |					graph := self new.					graph pundle: aPundle.					graph loadInitialVersions ifFalse: [^self].					preferredPresentation = #indentedPresentation ifTrue: [graph beIndentedList].					self openOn: graph]]</body></methods><methods><class-id>Store.VersionGraph class</class-id> <category>class initialization</category><body package="Store-UI-Graphs" selector="initialize">initialize	"self initialize"		self initializeRelationships.	self initializePerspectives</body><body package="Store-UI-Graphs" selector="initializePerspectives">initializePerspectives	"TT_VersionGraph initializePerspectives"	^(List new) add: ((Array new: 9)			at: 1 put: #LDMPerspective;			at: 2 put: #arrRows:;			at: 3 put: #(						#(#F1 #V1 'tt_derives' true false false false false) 						#(#V2 #F1 'tt_derives' true false false false false) 						#(#V1 #V1 'tt_derives' false false true false false)					);			at: 4 put: #arrLabelHints:;			at: 5 put: #(#blessing);			at: 6 put: #arrRelDesc:;			at: 7 put: ((Array new: 1)				at: 1 put: ((Array new: 5)					at: 1 put: 'tt_derives';					at: 2 put: true;					at: 3 put: #solid;					at: 4 put: ColorValue blue;					at: 5 put: 1; yourself); yourself);			at: 8 put: #name:;			at: 9 put: #tt_derives; yourself) decodeAsLiteralArray; yourself</body><body package="Store-UI-Graphs" selector="initializeRelationships">initializeRelationships	"self initializeRelationships"	^(List new) add: #(#LDMFirstOrderRel #name: 'tt_derives' #description: 'derives' #reverse: nil #token: #tt_derivesRel) decodeAsLiteralArray; add: #(#LDMFirstOrderRel #name: 'tt_derivesR' #description: 'derivesR' #reverse: nil #token: #tt_derivesRRel) decodeAsLiteralArray; yourself</body></methods><methods><class-id>Store.PackageMethodsVersionBrowserHelper</class-id> <category>menus</category><body package="Store-UI-Browser" selector="actionsForUnloadedPackages">actionsForUnloadedPackages	^#(  #fileOut #loadSelection #compareWithImage #compareWithVersion #findPackage )</body><body package="Store-UI-Browser" selector="setEnablement:">setEnablement: menu	"Set the menu's items enabled/disabled state."	"Since loaded and unloaded not in the same browser we only have to disable things."	"Don't override a menu items particular enablement"	menu enablementSelector == nil		ifFalse: [ ^menu ].	super setEnablement: menu.	self menu: menu do: 		[ :item | 		( self actionsForUnloadedPackages includes: item nameKey )			ifFalse: [ item disable ]		].</body></methods><methods><class-id>Store.PackageMethodsVersionBrowserHelper</class-id> <category>visual blocks</category><body package="Store-UI-Browser" selector="textForItem:">textForItem: anItem	^anItem fullDisplayString asText</body></methods><methods><class-id>Store.ComparisonBrowser</class-id> <category>private</category><body package="Store-UI-Comparitors" selector="currentTextEditor">currentTextEditor	"Answer either the current text widget or nil if it cannot be	determined."	| controller |	controller := [builder keyboardProcessor currentConsumer]		on: Error		do: [:ex | ex return: nil].	^(controller isKindOf: ParagraphEditor)		ifTrue: [controller]		ifFalse: [nil]</body><body package="Store-UI-Comparitors" selector="interfaceName">interfaceName	^self numberOfLists == 0		ifTrue: [ #windowSpec0 ]		ifFalse: [ #windowSpec2 ] 		"class &amp; methods"</body><body package="Store-UI-Comparitors" selector="isAttributeInvisible:">isAttributeInvisible: id	^invisibleAttributes includes: id.</body><body package="Store-UI-Comparitors" selector="isIdInvisible:">isIdInvisible: id	^id == invisibleId</body><body package="Store-UI-Comparitors" selector="postCopy">postCopy	super postCopy.	text2 := text2 value asValue.</body><body package="Store-UI-Comparitors" selector="tryAll:for:default:">tryAll: testBlock for: anInteger default: defaultBlock	( self componentList: anInteger ) reverseDo:		[ :comp | | val |		val := testBlock value: comp.		val == nil ifFalse: [ ^val ]		].	^defaultBlock value</body></methods><methods><class-id>Store.ComparisonBrowser</class-id> <category>menu accessing</category><body package="Store-UI-Comparitors" selector="viewMenu">viewMenu	| menu viewmenu |	menu := Menu new.	coordinator == nil ifFalse: [coordinator buildViewMenu: menu].	( self componentList: 1 )		do: [  :comp | comp buildViewMenu: menu ].	( self componentList: 1 ) size == 1	"got to disable changing protocols"		ifTrue:			[ menu menuItems do:				[ :item |				item enabled: ( ( item nameKey == #comment ) | ( item nameKey == #definition ) )				]			].	viewmenu := self class viewMenu.	viewmenu menuItems do: 		[ :i | i indication: ( comparisonType value = i value ) | ( differencesType = i value ) ].	menu addPart: viewmenu.	^menu</body></methods><methods><class-id>Store.ComparisonBrowser</class-id> <category>components</category><body package="Store-UI-Comparitors" selector="broadcastUpdate:">broadcastUpdate: aspect	"obsolete?"	( self componentList: 1 ) first broadcastUpdate: aspect.	( self componentList: 2 ) first broadcastUpdate: aspect</body><body package="Store-UI-Comparitors" selector="comparingComponentFor:">comparingComponentFor: aComponent	"Answer the matching component for aComponent. "	"For example, for package1 answers package2 and vice-versa"	| offset index |	offset := self components size / 2.	^self components at:		( ( index := self components indexOf: aComponent ) &gt; offset			ifTrue: [  index - offset ]			ifFalse: [ index + offset ]		)</body><body package="Store-UI-Comparitors" selector="comparingIdFor:">comparingIdFor: anInteger	"Answer the matching selectionId for anId. "	^anInteger == 1		ifTrue: [ 2 ]		ifFalse: [ 1 ].</body><body package="Store-UI-Comparitors" selector="component6">component6	^self visibleComponentAt: 6</body><body package="Store-UI-Comparitors" selector="componentFor:attribute:">componentFor:  anInteger attribute: attribute	"Answer a sublist of components for the first or second list."	^( self componentsFor: anInteger ) detect:		[ :comp | comp helpers first attribute == attribute ] ifNone: [ nil ].</body><body package="Store-UI-Comparitors" selector="componentList:">componentList:  anInteger	"Answer a sublist of components for the first or second list."	self components == nil		ifTrue: [ ^#( ) ].		"window not built"	^anInteger == 1		ifTrue: [ self components copyFrom: 1 to: ( self components size / 2 ) ]		ifFalse: [ self components copyFrom: ( self components size / 2 ) + 1 to: self components size ].</body><body package="Store-UI-Comparitors" selector="components">components	^self tabApplication components.</body><body package="Store-UI-Comparitors" selector="componentsFor:">componentsFor:  anInteger	"Answer a sublist of components for the first or second list."	^anInteger == 1		ifTrue: [ self components copyFrom: 1 to: ( self components size / 2 ) ]		ifFalse: [ self components copyFrom: ( self components size / 2 ) + 1 to: self components size ].</body><body package="Store-UI-Comparitors" selector="list6">list6	^self component6 listSpec</body><body package="Store-UI-Comparitors" selector="textHolderFor:">textHolderFor:  anInteger	"Answer the text the first or second list."	^anInteger == 1		ifTrue: [ text ]		ifFalse: [ text2 ].</body><body package="Store-UI-Comparitors" selector="textWidgetFor:">textWidgetFor:  anInteger	"Answer the text widget for the first or second list."	^( builder componentAt:		( anInteger == 1 ifTrue: [ #text ] ifFalse: [ #text2 ] 	)	)  widget.</body><body package="Store-UI-Comparitors" selector="windowLabel">windowLabel	| pkg1 pkg2 |	pkg1 := self selectedPackageFor: 1.	pkg2 := self selectedPackageFor: 2.	( ( pkg1 == nil ) | ( pkg2 == nil ) )		ifTrue: [ ^'Package Differences Browser' ].	^'&lt;1s&gt; versus &lt;2s&gt;' 		expandMacrosWith:  pkg1 displayString with: pkg2 displayString</body></methods><methods><class-id>Store.ComparisonBrowser</class-id> <category>textProcessing</category><body package="Store-UI-Comparitors" selector="displayTextFor:">displayTextFor: anInteger	| sel tv |	( sel := ( self componentsFor: anInteger ) first initialSelection ) == nil		ifFalse: 			[ builder == nil				ifFalse:					[ tv := self textWidgetFor: anInteger.					tv deselect.					tv controller find: sel.					tv displaySelection: true.					tv selectAndScroll					]			]</body><body package="Store-UI-Comparitors" selector="enableTextFor:">enableTextFor: anInteger	( self textWidgetFor:  anInteger ) isEnabled: true</body><body package="Store-UI-Comparitors" selector="refreshTextFor:">refreshTextFor: anInteger	^self tryAll: [ :c | c text ] for: anInteger default: [ Text new ].</body><body package="Store-UI-Comparitors" selector="setTextFor:to:">setTextFor: anInteger  to: aText	( self textHolderFor: anInteger ) value: aText</body><body package="Store-UI-Comparitors" selector="text1">text1	^text</body><body package="Store-UI-Comparitors" selector="text2">text2	^text2</body><body package="Store-UI-Comparitors" selector="textAccepted2:">textAccepted2: textController	( self 		tryAll: [ :c | c acceptText: textController text from: textController ]		for: 2		default: [ false ]	)		ifFalse: [ textController view flash ]</body><body package="Store-UI-Comparitors" selector="textAccepted:">textAccepted: textController	( self 		tryAll: [ :c | c acceptText: textController text from: textController ]		for: 1 		default: [ false ]	)		ifFalse: [ textController view flash ]</body><body package="Store-UI-Comparitors" selector="updateText">updateText	| one two |	one := self refreshTextFor: 1.		two := self refreshTextFor: 2.	[ differencesType == #showCodeDifferences		ifTrue: [ DiffList compareTokensIn: one with: two ]		ifFalse: [ DiffList compare: one with: two ]	] on: UnhandledException do:		[ :e |  e return.].		"Problem with embedded single quotes."	( self textHolderFor: 1 ) value: one.	( self textHolderFor: 2 ) value: two.</body></methods><methods><class-id>Store.ComparisonBrowser</class-id> <category>initialization</category><body package="Store-UI-Comparitors" selector="initialize">initialize	super initialize.	text2 := String new asValue.	invisibleId := 2.	self invisibleAttributes: #( #package ).	comparisonType := #showConflicts asValue.	differencesType := #showSourceDifferences.</body><body package="Store-UI-Comparitors" selector="invisibleAttributes:">invisibleAttributes:  aSet	"Set the set of attributes that have menus, but not visible lists."	invisibleAttributes := aSet</body><body package="Store-UI-Comparitors" selector="postBuildWith:">postBuildWith: aBuilder	(aBuilder componentAt: #text1) widget controller		autoAccept: false;		supportCodeEditingFeels: true;"		readOnly: ( self selectedPackageFor: 1 ) isLoaded not;  "		flushFeels.	(aBuilder componentAt: #text2) widget controller		autoAccept: false;		supportCodeEditingFeels: true;"		readOnly: ( self selectedPackageFor: 2 ) isLoaded not;  "		flushFeels.</body></methods><methods><class-id>Store.ComparisonBrowser</class-id> <category>actions</category><body package="Store-UI-Comparitors" selector="truePerformerFor:">truePerformerFor: moduleName	"Answer the module that is responsible for performing menu 	actions for moduleName. Answer the receiver if none."	( coordinator notNil and: [ coordinator menuHeader = moduleName ] )		ifTrue: [ ^coordinator ].	self components do: 		[ :comp |		comp menuHeader = moduleName			ifTrue: [ ^comp ]		].	^nil</body><body package="Store-UI-Comparitors" selector="updateLists">updateLists	( self componentList: 1 ) first updateList.	( self componentList: 2 ) first updateList.</body></methods><methods><class-id>Store.ComparisonBrowser</class-id> <category>selections</category><body package="Store-UI-Comparitors" selector="setButtonEmphasisFor:id:">setButtonEmphasisFor: classOrNameSpace id: selectionId 	| buttons |	builder == nil ifTrue: [^self].	buttons := self emphasizer 				emphasisForClassButtons: classOrNameSpace				for: self browser				id: selectionId.	buttons with: #(#instanceButton #classButton #dataButton)		do: 			[:emphasis :componentName | 			| component widget txt |			(component := builder componentAt: componentName) ~~ nil 				ifTrue: 					[txt := (widget := component widget) label text.					(txt emphasisAt: 1) ~= emphasis 						ifTrue: 							[txt emphasizeAllWith: emphasis.							widget label text: txt.							widget invalidate]]]</body><body package="Store-UI-Comparitors" selector="setSelection:for:to:">setSelection: attribute for: id to: aValue	"Set the selection for both lists."	| otherId module value |	super setSelection: attribute for: id to: aValue.	( ( self isIdInvisible: id )  or:  [ self isAttributeInvisible: attribute ] )		ifTrue: [ ^self ].		"can't see it, can't select it"	attribute == #model 		ifTrue: [ self setButtonEmphasisFor: aValue id: id ]. 	otherId := self comparingIdFor: id. 	( module := self componentFor: otherId attribute: attribute ) == nil		ifTrue: [ ^self ].	module browser == nil 		ifTrue: [ ^self ].		"the window is not up yet"	aValue == nil				ifTrue: [ ^module forceSelection: nil; updateList ].	value := module helpers first itemFor: aValue.	value == nil		ifTrue: [ module forceSelection: nil ]		ifFalse: [ module forceSelection: value; updateList ]</body><body package="Store-UI-Comparitors" selector="setSelectionOLD:for:to:">setSelectionOLD: attribute for: id to: aValue	"Set the selection for both lists."	| otherId otherValue matches module value |	super setSelection: attribute for: id to: aValue. 	otherId := self comparingIdFor: id.	module := self componentFor:  otherId attribute: attribute.	( ( aValue == nil ) | ( module == nil ) )		ifTrue: [ ^self ].	otherValue := self selected: attribute for: otherId.	matches := 	otherValue == nil 		ifTrue: [ false ]		ifFalse: 			[ otherValue isDataModel				ifTrue: [ aValue comparesTo: otherValue ]				ifFalse: [ aValue = otherValue ]			].		matches ifTrue: [ ^self ].	value := module helpers first itemFor: aValue.	value == nil 		ifTrue: [ module deselect. self setTextFor: otherId to: 'Not in this package' asText ]		ifFalse: [ module selection: value. module checkVisibility ].	"self revisitBeforeRelease"  	"set text is immediately wiped out."</body></methods><methods><class-id>Store.ComparisonBrowser</class-id> <category>aspects</category><body package="Store-UI-Comparitors" selector="comparisonType">comparisonType	^comparisonType</body><body package="Store-UI-Comparitors" selector="showAll">showAll	"Show all methods."	comparisonType value: #showAll.	self updateLists.</body><body package="Store-UI-Comparitors" selector="showCodeDifferences">showCodeDifferences	differencesType := #showCodeDifferences.	self updateText</body><body package="Store-UI-Comparitors" selector="showConflicts">showConflicts	"Show only conflicting methods"	comparisonType value: #showConflicts.	self updateLists.</body><body package="Store-UI-Comparitors" selector="showSourceDifferences">showSourceDifferences	differencesType := #showSourceDifferences.	self updateLists.</body></methods><methods><class-id>Store.ComparisonBrowser</class-id> <category>change</category><body package="Store-UI-Comparitors" selector="updateProtocolLists">updateProtocolLists	"really is update after class/instance/static button pressed"	| comps |	comps := self componentsFor: 1.	comps size &gt; 1		ifTrue: [ ( comps at: 2 ) updateList ].</body></methods><methods><class-id>Store.ComparisonBrowser</class-id> <category>coordination</category><body package="Store-UI-Comparitors" selector="getStoreMenuBarMenuFor:">getStoreMenuBarMenuFor: aString	^menuBarMenu ~~ nil ifTrue:		[menuBarMenu at: aString ifAbsent: []]</body><body package="Store-UI-Comparitors" selector="setStoreMenuBarMenu:for:">setStoreMenuBarMenu: aMenu for: aString	"Set the menuBarMenu for a particular helper, or nil"	menuBarMenu == nil ifTrue:		[menuBarMenu := Dictionary new].	menuBarMenu at: aString put: aMenu</body></methods><methods><class-id>Store.ComparisonBrowser class</class-id> <category>store-application configuration</category><body package="Store-UI-Comparitors" selector="compareClass:toClass:">compareClass: aClass toClass: bClass	| inst aBrowserTabApplication |	inst := self new.	aBrowserTabApplication := self defaultPackageTab newOnBrowser: inst.	^inst			tabApplication: aBrowserTabApplication;		initializeForClass: aClass toClass: bClass;		open.</body><body package="Store-UI-Comparitors" selector="compareMethod:toMethod:">compareMethod: aMethod toMethod: bMethod	| inst aBrowserTabApplication |	inst := self new.	aBrowserTabApplication := self defaultPackageTab newOnBrowser: inst.	^inst			tabApplication: aBrowserTabApplication;		initializeForMethod: aMethod toMethod: bMethod;		open.</body><body package="Store-UI-Comparitors" selector="comparePackage:toPackage:">comparePackage: aPackage toPackage: bPackage	| inst aBrowserTabApplication |	( aPackage == nil )  |   ( bPackage == nil )		ifTrue: [ ^nil ].  "Senders who care have already checked for nil, so this is just a fail safe."	inst := self new.	aBrowserTabApplication := self defaultPackageTab newOnBrowser: inst.	^inst			tabApplication: aBrowserTabApplication;		initializeForPackage: aPackage toPackage: bPackage;		open.</body><body package="Store-UI-Comparitors" selector="defaultPackageTab">defaultPackageTab 	^PackageComparisonApplication</body></methods><methods><class-id>Store.BasicVersionPolicy</class-id> <category>private</category><body package="Store-User Management" selector="existsVersionString:forPundle:">existsVersionString: aString forPundle: aPundleModel 	^( aPundleModel classOfDbRecord pundleWithName: aPundleModel name version: aString ) ~~ nil</body><body package="Store-User Management" selector="increment:">increment: aString 	"Given a string, increment the last digit sequence. If 'aString' does not end 	with a digit, returns 'aString'"	| lastNonDigit incrementedVersionNumber | 	lastNonDigit := aString findLast: [ :char | char isDigit not ]. 	lastNonDigit = aString size ifTrue: [ ^aString ]. 	incrementedVersionNumber := ( aString copyFrom: lastNonDigit + 1 to: aString size ) asNumber + 1. 	^( aString copyFrom: 1 to: lastNonDigit ) 		, incrementedVersionNumber printString</body></methods><methods><class-id>Store.BasicVersionPolicy</class-id> <category>accessing</category><body package="Store-User Management" selector="initialVersionForPundle:">initialVersionForPundle: aPundle   "Answer a string describing the first version of the package."	^'1.0'</body><body package="Store-User Management" selector="nextVersion:forPundle:">nextVersion: aString forPundle: aPundle	"Given the current version string, answer the string describing the next version of 	the package. The default implementation increments the last digit	sequence in 'aString'.  If 'aString' does not end with a digit, returns	'aString'"	aString isEmpty ifTrue: [ ^self initialVersionForPundle: aPundle ]. 	^self increment: aString.</body><body package="Store-User Management" selector="versionStringForPundle:initialVersion:">versionStringForPundle: aPundleModel initialVersion: initVerString 	"If a pundle with the same name and type (package/bundle) as aPundle doesn't	exist already, returns initVerString if initVerString is not nil.  Otherwise, returns 	another version string that doesn't conflict with a database entry.  Returns	nil if the user cancels the operation."	| verString |	verString := initVerString isNil				ifTrue: [self initialVersionForPundle: aPundleModel]				ifFalse: [initVerString].		[ (self existsVersionString: verString forPundle: aPundleModel ) and: 		[ verString := Dialog						request: ('Version ' , verString , ' of ' , aPundleModel name , 							' already exists.\Enter another version for ' , aPundleModel name , '.') withCRs						initialAnswer: verString						onCancel: [nil].		verString notNil		]	] whileTrue.	^verString</body></methods><methods><class-id>Store.BranchingVersionPolicy</class-id> <category>accessing</category><body package="Store-User Management" selector="nextVersion:forPundle:">nextVersion: aString forPundle: aPundle	"Given the current version string, answer the string describing the next version of 	the package. The default implementation increments the last digit sequence in 'aString'. 	If this version already exists, creates a branch off the original.	 If 'aString' does not end with a digit, returns 'aString'"	| versionString |	aString isEmpty ifTrue: [ ^self initialVersionForPundle: aPundle ]. 	versionString := self increment: aString.	( self existsVersionString: versionString forPundle: aPundle )		ifTrue: [ versionString := aString, self initialBranchString ]		ifFalse: [ ^versionString ].	[ self existsVersionString: versionString forPundle: aPundle ]		whileTrue:[ versionString := versionString, self initialBranchString  ].	^versionString</body><body package="Store-User Management" selector="versionStringForPundleNEW:initialVersion:">versionStringForPundleNEW: aPundleModel initialVersion: initVerString 	"If a pundle with the same name and type (package/bundle) as aPundle doesn't	exist already, returns initVerString if initVerString is not nil.  Otherwise, returns 	another version string that doesn't conflict with a database entry.  Returns	nil if the user cancels the operation."	| verString |	verString := initVerString isNil				ifTrue: [ self initialVersionForPundle: aPundleModel ]				ifFalse: [ initVerString ].	[ self existsVersionString: verString forPundle: aPundleModel ]		whileTrue:[ verString := self increment: verString ].	^verString</body></methods><methods><class-id>Store.BranchingVersionPolicy</class-id> <category>private</category><body package="Store-User Management" selector="initialBranchString">initialBranchString	^'.1'</body></methods><methods><class-id>Store.MiniRepositoryManager</class-id> <category>private</category><body package="Store-UI" selector="connectTo:">connectTo: aProfile	Cursor wait showWhile: [DbRegistry connectTo: aProfile]</body><body package="Store-UI" selector="connectToMessageTextFor:">connectToMessageTextFor: aProfile	^(#repmanConnectToProfile &lt;&lt; #labels &gt;&gt; 'Connect to &lt;1s&gt;')		expandMacrosWith: (self labelForProfile: aProfile)</body><body package="Store-UI" selector="connectToNew">connectToNew	self disconnect.	DbRegistry restoreConnection</body><body package="Store-UI" selector="currentRepositoryLabel">currentRepositoryLabel	| connectedProfile |	connectedProfile := DbRegistry connectedProfile.	^connectedProfile isNil 		ifTrue: [#repmanNotConnected &lt;&lt; #labels &gt;&gt; 'Not connected']		ifFalse: [self labelForProfile: connectedProfile]</body><body package="Store-UI" selector="disconnect">disconnect	Cursor wait showWhile: [DbRegistry disconnect]</body><body package="Store-UI" selector="disconnectFromMessageTextFor:">disconnectFromMessageTextFor: aProfile	^(#repmanDisconnectFrom &lt;&lt; #labels &gt;&gt; 'Disconnect from &lt;1s&gt;')		expandMacrosWith: (self labelForProfile: aProfile)</body><body package="Store-UI" selector="installLabelController">installLabelController	| controller |	controller := ControllerWithSelectMenu new.	controller		selectMenuHolder: [self repositoryListMenu];		menuHolder: [self repositoryMenu];		performer: self.	(self widgetAt: #label) controller: controller</body><body package="Store-UI" selector="isConnected">isConnected	^DbRegistry connectedProfileHolder value notNil</body><body package="Store-UI" selector="isConnectedProfileRegistered">isConnectedProfileRegistered	^RepositoryManager repositories includes: DbRegistry connectedProfile</body><body package="Store-UI" selector="labelForProfile:">labelForProfile: connectedProfile 	| label |	label := connectedProfile name.	(label notNil and: [label notEmpty]) ifTrue: [^label].	label := connectedProfile environment.	(label notNil and: [label notEmpty]) ifTrue: [^label].	^(#aRepository &lt;&lt; #labels &gt;&gt; 'a Repository') asString</body><body package="Store-UI" selector="storeIcon">storeIcon	^ToolbarIconLibrary visualFor: #store</body><body package="Store-UI" selector="updateRepositoryLabel">updateRepositoryLabel	self labelHolder value: self currentRepositoryLabel</body></methods><methods><class-id>Store.MiniRepositoryManager</class-id> <category>actions</category><body package="Store-UI" selector="openRepositoryManager">openRepositoryManager	RepositoryManager open</body><body package="Store-UI" selector="repositoryLoad">repositoryLoad	RepositoryManager loadRepositoriesFromFile</body><body package="Store-UI" selector="repositoryMoreRecentlyPublishedItems">repositoryMoreRecentlyPublishedItems	| list list2 |	DbRegistry doIfOnlineImage: 		[ list := (Registry allPackagesWithNewerInDB collect: [ :pkg | pkg name ]) asSet.		list2  := (Registry allBundlesWithNewerInDB collect: [ :bundle | bundle name ]) asSet.		Store.PublishedPundlesTool openOnBundles: list2 packages: list title: 'More Recently Published Items'		]</body><body package="Store-UI" selector="repositoryNew">repositoryNew	RepositoryManager addProfileFromUser</body><body package="Store-UI" selector="repositoryProperties">repositoryProperties	DbRegistry connectedProfileHolder value ifNotNil:		[:selection |		RepositoryPropertiesDialog openOn: selection.		RepositoryManager updateRepository: selection]</body><body package="Store-UI" selector="repositoryPublishedItems">repositoryPublishedItems	DbRegistry 		doIfOnlineImage: [Store.PublishedPundlesTool openOnAllPublishedPundles]</body><body package="Store-UI" selector="repositorySave">repositorySave	RepositoryManager saveRepositoriesToFile</body></methods><methods><class-id>Store.MiniRepositoryManager</class-id> <category>menu building</category><body package="Store-UI" selector="createConnectOrDisconnectItemFor:">createConnectOrDisconnectItemFor: aProfile 	| item |	item := MenuItem labeled:		(aProfile isConnected 			ifTrue: [self disconnectFromMessageTextFor: aProfile]			ifFalse: [self connectToMessageTextFor: aProfile]).	item value: (aProfile isConnected 				ifTrue: [[:controller | self disconnect]]				ifFalse: [[:controller | self connectTo: aProfile]]).	aProfile isConnected ifTrue:		[item labelImage: self storeIcon].	^item</body><body package="Store-UI" selector="createConnectToNewItem">createConnectToNewItem	^(MenuItem labeled: #repmanConnectToNew &lt;&lt; #labels &gt;&gt; 'Connect to...')		value: [:controller | self connectToNew];		yourself</body><body package="Store-UI" selector="disablePropertiesIn:">disablePropertiesIn: aMenu	(aMenu atNameKey: #repositoryProperties) disable</body><body package="Store-UI" selector="disableRepositoryItemsIn:">disableRepositoryItemsIn: aMenu	#(repositoryPublishedItems repositoryMoreRecentlyPublishedItems repositoryProperties) do:		[:each | 	(aMenu atNameKey: each) disable]</body><body package="Store-UI" selector="repositoryListMenu">repositoryListMenu	| menu repositories currentlyConnected |	menu := Menu new.	repositories := RepositoryManager repositories.	currentlyConnected := DbRegistry connectedProfile.	currentlyConnected notNil ifTrue:		[(repositories includes: currentlyConnected) ifFalse:			[menu				addItem: (self createConnectOrDisconnectItemFor: currentlyConnected);				addLine]].	repositories do: 		[:each | menu addItem: (self createConnectOrDisconnectItemFor: each)].	menu 		addLine;		addItem: self createConnectToNewItem.	^menu</body><body package="Store-UI" selector="repositoryMenu">repositoryMenu	| menu |	menu := self class repositoryMenu.	self isConnected 		ifFalse: [self disableRepositoryItemsIn: menu]		ifTrue: [self isConnectedProfileRegistered			ifFalse: [self disablePropertiesIn: menu]].	^menu</body></methods><methods><class-id>Store.MiniRepositoryManager</class-id> <category>initialize-release</category><body package="Store-UI" selector="initialize">initialize	super initialize.	"Hack to enable loading."	DbRegistry ifNil: [^self].	DbRegistry connectedProfileHolder		onChangeSend: #connectedProfileChanged		to: self.	self connectedProfileChanged</body><body package="Store-UI" selector="postBuildWith:">postBuildWith: aBuilder 	self installLabelController</body><body package="Store-UI" selector="preBuildWith:">preBuildWith: aBuilder 	super preBuildWith: aBuilder.	aBuilder visualAt: #storeIcon put: self storeIcon</body><body package="Store-UI" selector="release">release	super release.	DbRegistry connectedProfileHolder ifNotNil: 		[:valueHolder | valueHolder retractInterestsFor: self]</body></methods><methods><class-id>Store.MiniRepositoryManager</class-id> <category>notifications</category><body package="Store-UI" selector="connectedProfileChanged">connectedProfileChanged	self updateRepositoryLabel</body><body package="Store-UI" selector="noticeOfWindowClose:">noticeOfWindowClose: aWindow	self release.	^super noticeOfWindowClose: aWindow</body></methods><methods><class-id>Store.MiniRepositoryManager</class-id> <category>aspects</category><body package="Store-UI" selector="labelHolder">labelHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^labelHolder isNil		ifTrue:			[labelHolder := String new asValue]		ifFalse:			[labelHolder]</body></methods><methods><class-id>Store.MiniRepositoryManager class</class-id> <category>fileIn/Out</category><body package="Store-UI" selector="prerequisitesForLoading">prerequisitesForLoading	^(super prerequisitesForLoading)		add: DBAccess;		yourself</body></methods><methods><class-id>Store.MiniRepositoryManager class</class-id> <category>class initialization</category><body package="Store-UI" selector="initialize">initialize	"Hack to enable loading into a fresh image."	VisualLauncherToolDock instanceMethodsChanged</body></methods><methods><class-id>Store.PundleComponent</class-id> <category>initialize-release</category><body package="Store-UI" selector="initialize">initialize	"The module is configured as not for selecting to avoid auto-selection	of list items, which would trigger database queries."	super initialize.	pundleModule := IncrementalSearchModule 		forSelectionWithSearch: [:pattern | self pundlesMatching: pattern].	pundleModule		useEagerSelection: false;		pasteSelected: false;		showLabels: false;		useMultiSelection: true;		iconSelector: #toolListIcon;		menuHolder: [popupMenu] performer: self.	Registry addDependent: self.</body><body package="Store-UI" selector="listUpdateBlock:sendUpdatesFor:">listUpdateBlock: aBlock sendUpdatesFor: aSymbolCollection	"Set all of the initial condition.  Including:"	"Set the block to be used to recompute what pundles are contained in the list. 	 aBlock returns a List."	listUpdateBlock := aBlock.	updateInterests := aSymbolCollection.	self reloadVersions</body><body package="Store-UI" selector="listUpdateBlock:sendUpdatesFor:popupMenu:">listUpdateBlock: aBlock sendUpdatesFor: aSymbolCollection popupMenu: aPopupMenu	"Set all of the initial condition.  Including:"	"Set the block to be used to recompute what pundles are contained in the list. 	 aBlock returns a List."	listUpdateBlock := aBlock.	updateInterests := aSymbolCollection.	popupMenu := aPopupMenu.	self makePundleMenuDynamic: popupMenu.	self reloadVersions</body><body package="Store-UI" selector="release">release	super release.	pundleModule release.	Registry removeDependent: self.</body></methods><methods><class-id>Store.PundleComponent</class-id> <category>updating</category><body package="Store-UI" selector="update:with:">update: anAspect with: aParameter 	| aPundle |	super update: anAspect with: aParameter.	updateInterests == nil		ifTrue: [ ^self ].	((updateInterests includes: #all)		or: [updateInterests includes: anAspect])		ifFalse: [^self].	aPundle := (aParameter respondsTo: #value)				ifTrue: [aParameter value]				ifFalse: [aParameter].	( anAspect == #removedPundle )		ifTrue: [ self pundleModule list remove: aPundle ifAbsent: [] ].	(anAspect == #addedPundle or: [anAspect == #changedBundleStructure ])		ifTrue: [self reloadVersions].	(anAspect == #pundleModificationStatus or: [anAspect == #pundleTrace])		ifTrue: [self updateDisplayForPundle: aPundle]</body><body package="Store-UI" selector="updateDisplayForPundle:">updateDisplayForPundle: aPundle	| index |	index := self pundleModule list indexOf: aPundle ifAbsent: [^self].	self pundleModule listModule listWidget updateAt: index</body></methods><methods><class-id>Store.PundleComponent</class-id> <category>actions</category><body package="Store-UI" selector="reloadVersions">reloadVersions	| oldSelections newSelections |	oldSelections := self pundleModule selections.	newSelections := OrderedCollection new.	cachedPundles := listUpdateBlock value.	self pundleModule list: cachedPundles.	oldSelections do: [:oldSel |		cachedPundles do: [:newItem |			(newItem isBundle = oldSel isBundle and: [					newItem name = oldSel name]) ifTrue: [				newSelections add: newItem]]].	self pundleModule selections: newSelections</body></methods><methods><class-id>Store.PundleComponent</class-id> <category>interface opening</category><body package="Store-UI" selector="postBuildWith:">postBuildWith: aBuilder 	(self widgetAt: #pundleSubcanvas)		client: pundleModule		spec: pundleModule preferredWindowSpec		builder: aBuilder newSubBuilder</body></methods><methods><class-id>Store.PundleComponent</class-id> <category>accessing</category><body package="Store-UI" selector="onSelectionChangeSend:to:">onSelectionChangeSend: aSymbol to: anObject 	pundleModule selectionIndexHolder onChangeSend: aSymbol to: anObject</body><body package="Store-UI" selector="popupMenu">popupMenu	^popupMenu</body><body package="Store-UI" selector="pundleModule">pundleModule	^pundleModule</body><body package="Store-UI" selector="pundles">pundles	^pundleModule selections</body><body package="Store-UI" selector="pundleVersions">pundleVersions	^pundleModule selections select: [:pun | pun isLoaded or: [pun primaryKey notNil]]</body><body package="Store-UI" selector="selections">selections	^pundleModule selections</body><body package="Store-UI" selector="selections:">selections: selects 	| sels |	sels := OrderedCollection new.	selects 	do: 		[:opun | 		| match |		match := pundleModule list			detect: [:npun | npun isBundle = opun isBundle and: [npun name = opun name]]			ifNone: [nil].		match notNil ifTrue: [sels add: match]].	pundleModule selections: sels</body></methods><methods><class-id>Store.PundleComponent</class-id> <category>private</category><body package="Store-UI" selector="cachedPundles">cachedPundles	"Pundles last read from the database are cached to avoid re-querying when	filtering. The cache is filled by reloadVersions."	^cachedPundles isNil		ifTrue: [Array new]		ifFalse: [cachedPundles]</body><body package="Store-UI" selector="defaultDbId">defaultDbId	"Return the database id for the database we are currently connected to.	 Identical to BrowserNavigator&gt;&gt;#defaultDbId"	| id |	id := DbRegistry dbIdentifier.	^id isNil ifTrue: [#''] ifFalse: [id]</body><body package="Store-UI" selector="pundlesMatching:">pundlesMatching: aString	| pattern |	pattern := aString trimBlanks, '*'.	^self cachedPundles select: [:some | pattern match: some name]</body><body package="Store-UI" selector="storeBrowseChanges:">storeBrowseChanges: dbIdentifier 	"Open up a new browser environment on the methods that have changed 	 with respect to the database identified by dbIdentifier.	 Nearly identical to BrowserNavigator&gt;&gt;#storeBrowseChanges:"	| env |	env := SelectorEnvironment new.	env label: #ChangedMethods1 &lt;&lt; #browser &gt;&gt; 'Changed methods'.	self pundles do: 			[:pun | 			pun leafItems do: 					[:each | 					(each changedMessageListFor: dbIdentifier) 						do: [:meth | env addClass: meth implementingClass selector: meth selector]]].	env isEmpty 		ifTrue: 			[Dialog warn: #NoResultsToBrowse &lt;&lt; #browser &gt;&gt; 'No results to browse']		ifFalse: [env openEditor]</body></methods><methods><class-id>Store.BasicBlessingPolicy</class-id> <category>blessing numbers</category><body package="Store-User Management" selector="blessingName:">blessingName: aNumber 	"Given a number from DB answer the official name of the blessing level."	aNumber = 0 ifTrue: [ ^'Unblessed' ].	^( self blessings detect:		[ :bless | bless level == aNumber ] ifNone: [ ^'Unknown' ]	) name.</body><body package="Store-User Management" selector="blessingNumber:">blessingNumber: aName	"Given the name for the blessing level answer a number used in DB."	aName = 'Unblessed' ifTrue: [ ^0 ].	^( self blessings detect:		[ :bless | bless name = aName ] ifNone: [ ^nil ] 	  ) level.</body><body package="Store-User Management" selector="defaultBlessing">defaultBlessing		^defaultBlessing</body><body package="Store-User Management" selector="defaultBlessing:">defaultBlessing: aNumber		defaultBlessing := aNumber</body></methods><methods><class-id>Store.BasicBlessingPolicy</class-id> <category>initialize-release</category><body package="Store-User Management" selector="initialize">initialize	self initializeBlessings.	self defaultBlessing: self developmentBlessing.</body><body package="Store-User Management" selector="initializeBlessings">initializeBlessings	"Policies blessingPolicy initializeBlessings"	blessings := IdentityDictionary new		at: #Broken put: ( BlessingLevel name: 'Broken' level: 10 );		at: #WorkInProgress put: ( BlessingLevel name: 'Work In Progress' level: 15 );	 	at: #Development put: ( BlessingLevel name:  'Development' level: 20 );		at: #ToReview put: (  BlessingLevel name: 'To Review' level: 25 );		at: #Patch put: ( BlessingLevel name:  'Patch' level: 30 );	 	at: #IntegrationReady put: ( BlessingLevel name:  'Integration-Ready' level: 40 );		at: #Integrated put: ( BlessingLevel name:  'Integrated' level: 50 );		at: #ReadyToMerge put: ( BlessingLevel name: 'Ready to Merge' level: 55 );		at: #Merged put: ( BlessingLevel name:  'Merged'  level: 60 );		at: #Tested put: ( BlessingLevel name:  'Tested' level: 70 );		at: #InternalRelease put: ( BlessingLevel name:  'Internal Release' level:  80 );		at: #Release put: ( BlessingLevel name:  'Released' level:  99 );		yourself.</body></methods><methods><class-id>Store.BasicBlessingPolicy</class-id> <category>display</category><body package="Store-User Management" selector="describeBlessings:">describeBlessings: someTTBlessings	"Answer a string that describes a collection of database blessings."	| ws |	ws := WriteStream on: String new. 	someTTBlessings do: 		[ :bless | 		ws 			nextPutAll: '--- Blessed: ';			nextPutAll: bless blessingLevelString;			cr;			nextPutAll: '--- By: ';	 		nextPutAll: bless userNameString;			cr;			nextPutAll: '--- On: ';			nextPutAll: bless timeStampString;			cr;			nextPutAll: bless getCommentString;			cr; 			cr.		].	^ws contents</body></methods><methods><class-id>Store.BasicBlessingPolicy</class-id> <category>relationships</category><body package="Store-User Management" selector="stringKeyFor:blessingLevel:">stringKeyFor: aString blessingLevel: blessingLevel	blessingLevel = self developmentBlessing 		ifTrue: [^(aString , ' D') asText emphasizeAllWith: #italic].	blessingLevel = self integrationReadyBlessing 		ifTrue: [^( aString , ' Y' ) asText emphasizeAllWith: #bold ].	^aString , ' ' , ( String with: ( self blessingName: blessingLevel ) first )</body></methods><methods><class-id>Store.BasicBlessingPolicy</class-id> <category>accessing</category><body package="Store-User Management" selector="blessingNumbers">blessingNumbers	"Answer an array of existing blessing numbers."	^blessings values collect:		[ :bl | bl level ]</body><body package="Store-User Management" selector="blessings">blessings	"Answer an array of existing BlessingLevels."	^blessings values</body></methods><methods><class-id>Store.BasicBlessingPolicy</class-id> <category>publishing</category><body package="Store-User Management" selector="basicCanPublish:atBlessing:">basicCanPublish: aPundle atBlessing: aBlessing	^true</body><body package="Store-User Management" selector="objectionsToPublishingBundle:atBlessingLevel:">objectionsToPublishingBundle: aBundle atBlessingLevel: aLevel 	"Return a string specifying why this bundle may not be published.  Return nil if it may.	An example policy is shown in the corresponding package method."	^nil</body><body package="Store-User Management" selector="objectionsToPublishingPackage:atBlessingLevel:">objectionsToPublishingPackage: aPackage atBlessingLevel: aLevel 	"Return a string specifying why this package may not be published.  Return nil if it may.	An example policy is shown below:"	^nil"	aPackage changeSet listOfClasses 			detect: [:className | 				(className copyFrom: 1 to: 3) ~= 'TT_']			ifNone: [^nil].	^aLevel = (Policies blessingPolicy blessingNumber: 'Development')		ifTrue: [nil]		ifFalse: ['Changes to external classes may not\be published with this blessing.']"</body><body package="Store-User Management" selector="objectionsToPublishingParcel:atBlessingLevel:">objectionsToPublishingParcel: aParcel atBlessingLevel: aLevel 	"Return a string specifying why this parcel may not be published.  Return nil if it may.	An example policy is shown in the corresponding package method."	^nil</body><body package="Store-User Management" selector="objectionsToPublishingPundle:atBlessingLevel:">objectionsToPublishingPundle: aPundle atBlessingLevel: aLevel 	"Return a string specifying why this bundle may not be published.  Return nil if it may.	An example policy is shown in the corresponding package method."	^nil</body></methods><methods><class-id>Store.BasicBlessingPolicy</class-id> <category>blessing menus</category><body package="Store-User Management" selector="blessingLevelsMenu">blessingLevelsMenu	"Answer a menu with all existing blessing names and levels."	| menu labels values list |	list := self blessings asSortedCollection.	labels := list collect: [ :bless| bless name ].	values := list collect: [ :bless| bless level ].	menu := Menu labelArray: labels values: values.	^menu</body><body package="Store-User Management" selector="blessingLevelsMenuForPundle:">blessingLevelsMenuForPundle: aPundle	^self blessingLevelsMenu</body></methods><methods><class-id>Store.BasicBlessingPolicy</class-id> <category>blessing names</category><body package="Store-User Management" selector="brokenBlessing">brokenBlessing	"This is a constant, do not change or override.  Use indirection through this or another policy"	^( blessings at: #Broken ) level</body><body package="Store-User Management" selector="developmentBlessing">developmentBlessing	"This is a constant, do not change or override.  Use indirection through this or another policy"	^( blessings at: #Development ) level.</body><body package="Store-User Management" selector="integratedBlessing">integratedBlessing	"This is a constant, do not change or override.  Use indirection through this or another policy"	^( blessings at: #Integrated ) level</body><body package="Store-User Management" selector="integrationReadyBlessing">integrationReadyBlessing	"This is a constant, do not change or override.  Use indirection through this or another policy"	^( blessings at: #IntegrationReady ) level.</body><body package="Store-User Management" selector="internalReleaseBlessing">internalReleaseBlessing	"This is a constant, do not change or override.  Use indirection through this or another policy"	^( blessings at: #InternalRelease ) level</body><body package="Store-User Management" selector="mergedBlessing">mergedBlessing	"This is a constant, do not change or override.  Use indirection through this or another policy"	^( blessings at: #Merged ) level.</body><body package="Store-User Management" selector="patchBlessing">patchBlessing 	"This is a constant, do not change or override.  Use indirection through this or another policy"	^( blessings at: #Patch ) level</body><body package="Store-User Management" selector="readyToMergeBlessing">readyToMergeBlessing	"This is a constant, do not change or override.  Use indirection through this or another policy"	^( blessings at: #ReadyToMerge ) level</body><body package="Store-User Management" selector="releasedBlessing">releasedBlessing	"This is a constant, do not change or override.  Use indirection through this or another policy"	^( blessings at: #Release ) level</body><body package="Store-User Management" selector="testedBlessing">testedBlessing	"This is a constant, do not change or override.  Use indirection through this or another policy"	^( blessings at: #Tested ) level</body><body package="Store-User Management" selector="toReviewBlessing">toReviewBlessing	"This is a constant, do not change or override.  Use indirection through this or another policy"	^( blessings at: #ToReview ) level</body><body package="Store-User Management" selector="workInProgressBlessing">workInProgressBlessing 	"This is a constant, do not change or override.  Use indirection through this or another policy"	^( blessings at: #WorkInProgress ) level</body></methods><methods><class-id>Store.BasicBlessingPolicy class</class-id> <category>instance creation</category><body package="Store-User Management" selector="new">new	^super new initialize</body></methods><methods><class-id>Store.OwnerBlessingPolicy</class-id> <category>publishing</category><body package="Store-Ownership" selector="allowedBlessingLevelsForPundle:">allowedBlessingLevelsForPundle: aPundle 	"*** adapted from Philippe F. Monnet ***"	"Returns the list of allowed blessing levels for this pundle and the current 	owner"	| disallowedBlessings |	disallowedBlessings := OrderedCollection new.	self isImageAdministrator		ifFalse: 	[ disallowedBlessings addAll: self administratorBlessings ].	disallowedBlessings addAll: ( self disallowedBlessingsForPundle: aPundle ).	^self blessings reject: [ :b | disallowedBlessings includes: b level ].</body><body package="Store-Ownership" selector="basicCanPublish:atBlessing:">basicCanPublish: aPundle atBlessing: aBlessing	(self allowedBlessingLevelsForPundle: aPundle) do:		[ :bless | bless level = aBlessing 			ifTrue: [ ^true ] 		].	^false</body><body package="Store-Ownership" selector="disallowedBlessingsForPundle:">disallowedBlessingsForPundle: aPundle	self isImageAdministrator	      ifTrue:[ ^#( ) ].	self shouldValidateOwnership	ifFalse: [ ^#( ) ].	( Policies ownershipPolicy currentUserHasOwnershipPrivilegesFor: aPundle )		ifTrue:[ ^self administratorBlessings ].	^( Policies ownershipPolicy currentUserHasPublishingPrivilegesFor: aPundle )		ifTrue: [ self administratorBlessings, self ownerBlessings ]		ifFalse: [ self blessingNumbers ]</body><body package="Store-Ownership" selector="objectionsToPublishingBundle:atBlessingLevel:">objectionsToPublishingBundle: aBundle atBlessingLevel: aBlessingLevel 	"Return a string specifying why this bundle may 	not be published.  Return nil if it may."	^self objectionsToPublishingPundle: aBundle atBlessingLevel: aBlessingLevel</body><body package="Store-Ownership" selector="objectionsToPublishingPackage:atBlessingLevel:">objectionsToPublishingPackage: aPackage atBlessingLevel: aBlessingLevel 	"Return a string specifying why this package may 	not be published.  Return nil if it may."	^self objectionsToPublishingPundle: aPackage atBlessingLevel: aBlessingLevel</body></methods><methods><class-id>Store.OwnerBlessingPolicy</class-id> <category>initialize-release</category><body package="Store-Ownership" selector="initialize">initialize	"TT_Bernstein blessingPolicy initialize"	super initialize.	( blessings at: #Integrated ) beOwnerOnly.	( blessings at: #ReadyToMerge ) beOwnerOnly.	( blessings at: #Merged ) beOwnerOnly.	( blessings at: #Release ) beAdminOnly.	( blessings at: #Tested ) beQaOnly.</body></methods><methods><class-id>Store.OwnerBlessingPolicy</class-id> <category>administrator</category><body package="Store-Ownership" selector="isImageAdministrator">isImageAdministrator	"Returns a boolean indicating whether or not the user is the Image Administrator"	^DbRegistry isSystemAdministrator</body></methods><methods><class-id>Store.OwnerBlessingPolicy</class-id> <category>private</category><body package="Store-Ownership" selector="currentUserName">currentUserName	^DbRegistry currentUserName</body><body package="Store-Ownership" selector="isOwnershipOn">isOwnershipOn	^true</body><body package="Store-Ownership" selector="objectionsToPublishingPundle:atBlessingLevel:">objectionsToPublishingPundle: aPundle atBlessingLevel: aBlessingLevel 	"Return a string specifying why this Pundle may not be published.  Return nil if it may.	PRIVATE - public access through package/bundle versions of this method."	^self shouldValidateOwnership		ifTrue: 			[ | res1 res2 |			res1 := self validateOwnershipForPundle: aPundle blessingLevel: aBlessingLevel.			res2 := super objectionsToPublishingPundle: aPundle atBlessingLevel: aBlessingLevel.			( res1 notNil and: [ res2 notNil ] )				ifTrue: [ res1 , res2 ]				ifFalse: [ res1 notNil							ifTrue: [ res1 ]							ifFalse: [  res2 ]						]			]		ifFalse: [ nil ]</body><body package="Store-Ownership" selector="shouldValidateOwnership">shouldValidateOwnership	^self isOwnershipOn and: [ #{DBPundlePrivileges} isDefined ]</body><body package="Store-Ownership" selector="validateOwnershipForPundle:blessingLevel:">validateOwnershipForPundle: aPundle blessingLevel: aBlessingLevel 	^( self basicCanPublish: aPundle atBlessing: aBlessingLevel )		ifTrue: [ nil ]		ifFalse: 			[ 'You do not have the rights to publish ', aPundle name, 				' at a blessing level of ' , ( self blessingName: aBlessingLevel )			]</body></methods><methods><class-id>Store.OwnerBlessingPolicy</class-id> <category>blessings</category><body package="Store-Ownership" selector="administratorBlessings">administratorBlessings	"Returns a list of priviledged blessing numbers that should only be used by the Administrator"	^( self blessings select: [ :bless | bless isAdminOnly ] )		collect: [ :bless | bless level ]</body><body package="Store-Ownership" selector="ownerBlessings">ownerBlessings	"Returns a list of priviledged blessing numberss that should only be used by the pundle owner."	" OwnerBlessingPolicy new ownerBlessings"	^( self blessings select: [ :bless | bless isOwnerOnly ] )		collect: [ :bless | bless level ]</body></methods><methods><class-id>Store.OwnerBlessingPolicy</class-id> <category>blessing menus</category><body package="Store-Ownership" selector="blessingLevelsMenu">blessingLevelsMenu	"Answer a menu with all existing blessing names and levels."	| menu labels values list |	list := self blessings.	self isImageAdministrator		ifFalse: 			[ | adminBlessings |			adminBlessings := self administratorBlessings.			list  := list reject: [ :x | adminBlessings includes: x level ]			].	list := list asSortedCollection.	labels := list collect: [ :bless| bless name ].	values := list collect: [ :bless| bless level ].	menu := Menu labelArray: labels values: values.	^menu</body><body package="Store-Ownership" selector="blessingLevelsMenuForPundle:">blessingLevelsMenuForPundle: aPundle	"*** from 9 January 1995 at 3:44:13 pm by PHM (Philippe F. Monnet	) in B941220 ***"	"Modified to filter out the privileged values for users other than the image administrator"	| list menu labels values  |	list := ( self allowedBlessingLevelsForPundle: aPundle ) asSortedCollection.	labels := list collect: [ :bless| bless name ].	values := list collect: [ :bless| bless level ].	menu := Menu labelArray: labels values: values.	^menu</body></methods><methods><class-id>Store.EnvyStyleBlessingPolicy</class-id> <category>blessing names</category><body package="Store-Ownership" selector="integrationReadyBlessing">integrationReadyBlessing	"This is a constant, do not change or override.  Use indirection through this or another policy"	^( blessings at: #Development ) level.</body></methods><methods><class-id>Store.EnvyStyleBlessingPolicy</class-id> <category>initialize-release</category><body package="Store-Ownership" selector="initialize">initialize	"Policies blessingPolicy initializeBlessings"	self initializeBlessings.	self defaultBlessing: self developmentBlessing.	( blessings at: #Development ) beOwnerOnly.	( blessings at: #Integrated ) beOwnerOnly.	( blessings at: #Merged ) beOwnerOnly.	( blessings at: #Release ) beAdminOnly.</body><body package="Store-Ownership" selector="initializeBlessings">initializeBlessings	"Policies blessingPolicy initializeBlessings"	blessings := IdentityDictionary new		at: #Broken put: ( BlessingLevel name: 'Broken' level: 10 );		at: #WorkInProgress put: ( BlessingLevel name: 'Scratch' level: 15 );	 	at: #Development put: ( BlessingLevel name:  'Edition' level: 20 );		at: #Integrated put: ( BlessingLevel name:  'Version' level: 50 );		at: #Merged put: ( BlessingLevel name:  'Release'  level: 60 );		at: #Release put: ( BlessingLevel name:  'Product' level:  99 );		yourself.</body></methods><methods><class-id>Store.TEMPORARYOwnerBlessingPolicy</class-id> <category>blessing level</category><body package="Store-Ownership" selector="allowedBlessingLevelsForPackage:">allowedBlessingLevelsForPackage: aPackage 	"*** adapted from Philippe F. Monnet ***"	"Returns the list of allowed blessing levels for this package and the current owner"	^self allowedBlessingLevelsForPundle: aPackage</body><body package="Store-Ownership" selector="blessingLevelsMenuForPundle:">blessingLevelsMenuForPundle: aPundle	"*** from 9 January 1995 at 3:44:13 pm by PHM (Philippe F. Monnet	) in B941220 ***"	"Modified to filter out the privileged values for users other than the image administrator"	| list menu labels values  |	list := ( self allowedBlessingLevelsForPundle: aPundle ) asSortedCollection.	labels := list collect: [ :bless| bless name ].	values := list collect: [ :bless| bless level ].	menu := Menu labelArray: labels values: values.	^menu</body></methods><methods><class-id>Store.TEMPORARYOwnerBlessingPolicy</class-id> <category>ownership</category><body package="Store-Ownership" selector="canOwner:review:">canOwner: anOwner review: aPundle	"Answer true if anOwner is the owner or a member of a group that owns aPundle."	| aPundleOwner |	( aPundleOwner := aPundle owner ) == nil		ifTrue:[^false ].	^aPundleOwner containsUserNamed: anOwner userName</body><body package="Store-Ownership" selector="disallowedBlessingsForPackage:">disallowedBlessingsForPackage: aPackage	"*** adapted from 9 January 1995 at 3:16:26 pm by PHM (Philippe F. Monnet	) in B941220 ***"	| aPackageOwnership aUserName |	self shouldValidateOwnership	ifFalse: [ ^Array new ].	self class isImageAdministrator  	ifTrue:[ ^Array new ].	aPackageOwnership := aPackage owner.	aPackageOwnership isNil  ifTrue:[ ^Array new ].	aUserName := self class userName.	( aPackageOwnership ownerName = aUserName )		ifTrue:[ ^Array new ].	^( aPackageOwnership isUser or:[ aPackageOwnership groupName = aUserName ] )		ifTrue:	[ self administratorBlessings ]		ifFalse:	[ Array new ].</body><body package="Store-Ownership" selector="disallowedBlessingsForPundle:">disallowedBlessingsForPundle: aPundle	| aPundleOwnership aUserName |	self class isImageAdministrator		ifTrue:[^Array new].	self shouldValidateOwnership		ifFalse: [^Array new].	aPundleOwnership := Policies ownershipPolicy ownerOfPundle: aPundle.	aPundleOwnership isNil		ifTrue:[ ^#( ) ].	aUserName := self class userName.	(aPundleOwnership userName = aUserName)		ifTrue:[ ^#( )].	^(aPundleOwnership isUser or:[aPundleOwnership groupName = aUserName])		ifTrue:	[ self administratorBlessings ]		ifFalse:	[ #( ) ].</body><body package="Store-Ownership" selector="privilegedBlessingsForPundle:">privilegedBlessingsForPundle: aPundle	| aPundleOwnership aUserName |	aPundle name isNil		ifTrue:[^Array new].	self class isImageAdministrator		ifTrue:[^Array new].	aPundleOwnership := Policies ownershipPolicy ownerOfPundle: aPundle.	aPundleOwnership isNil		ifTrue:[^Array new].	aUserName := self class userName.	(aPundleOwnership userName asUppercase = aUserName asUppercase)		ifTrue:[^Array new].	^(aPundleOwnership isUser or:[aPundleOwnership groupName asUppercase = aUserName asUppercase])		ifTrue:	[ self administratorBlessings ]		ifFalse:	[ Array new ].</body><body package="Store-Ownership" selector="shouldValidateOwnership">shouldValidateOwnership	^(#{DBPundlePrivileges} isDefined and: [ self isOwnershipOn ])</body><body package="Store-Ownership" selector="validateOwnershipForPackage:blessingLevel:">validateOwnershipForPackage: aPackage blessingLevel: aBlessingLevel 	"*** adapted from Philippe F. Monnet ***"	^self validateOwnershipForPundle: aPackage blessingLevel: aBlessingLevel</body></methods><methods><class-id>Store.UISettings</class-id> <category>help</category><body package="Store-UI" selector="binaryLoadHelp">binaryLoadHelp	^'Allow Binary LoadingThe default is to load binary all packages that were saved binary. Setting this to never load binary, will do source code loading in all cases.'</body><body package="Store-UI" selector="databaseHelp">databaseHelp	^'Store Database DefaultsThe database identifier displays the name of the current Store database. This is set by your Image Administrator.The database table owner is logon that was used to install the Store tables. If you have multiple installations in the same repository, this controls which is visible to Store. This is set in the connection dialog.The parcel directory is the default directory used when saving packages or bundles as parcels. It is also the location of parcel source files that are created when loading a binary package from the database. The database identifier is used as a subdirectory because you may have multiple databases.'</body><body package="Store-UI" selector="fileoutOptionHelp">fileoutOptionHelp	^'Fileout Option SettingsPackage information can only be included in XML fileouts (see main Settings).Select "Never" to supress package information for all fileouts.Select "Package fileouts only" to include package information only when fileing out directly from  a Package.Select "All  Fileouts" to include package information  in  every fileout,  regardless of source.'</body><body package="Store-UI" selector="newClassHelp">newClassHelp	^'New Class SettingsThe New Class setting determines which package will contain a newly created class.'</body><body package="Store-UI" selector="newDatumHelp">newDatumHelp	^'New Data SettingsThe New Data setting determines which package will contain a newly created data item.'</body><body package="Store-UI" selector="newMethodHelp">newMethodHelp	^'New Methods SettingsThe New Method setting determines which package will contain a newly created method.'</body><body package="Store-UI" selector="packageCompareHelp">packageCompareHelp	^'Package Compare SettingsThis option is provided for convenience while Store is under development.  It provides access to a setting that allows users to work around certain types of bugs that may be encountered.Usually the ''optimize speed by using change set to compute changes'' should be chosen.  This results in much faster performance when publishing and when comparing a loaded package with a version in the database.Occasionally you may encounter a bug that causes the change set of a package to enter an incorrect state.  In this case, publishing the package may not publish all changed definitions, and comparing the in-image package with a database version may likewise fail to compute the correct result.To cause the publish and compare operations to ignore the damaged change set, choose ''consult database to compute changes''.  This forces these operations to compare the in-image version directly with the database version rather than consulting the change set to find out what has changed since the package was loaded.'</body><body package="Store-UI" selector="prereqOptionsHelp">prereqOptionsHelp	^'Store Prerequisite OptionsThis effects how development prerequisites are loaded.Version selection determines which version of a prerequisite is loaded. "Ask" will always prompt for a selection. "Always load equal to higher than" will look at the blessing level and use the most recent qualified version."When loading #any" refers to when #any is specified in the development prerequisite declaration. When both a parcel and a bundle/package exist, the default is to load the parcel. This allows you to decide that the bundle or package should be given priority.'</body><body package="Store-UI" selector="toolOptionHelp">toolOptionHelp	^'Tool Option SettingsThis option is option allows you to configure Store tools to your needs.If you choose "Show versions and blessing comments", version displays in both the Version Browser and Published Items tools will have two panes instead of one.  The lower pane will display the blessing comments for that version.'</body><body package="Store-UI" selector="versionBrowserHelp">versionBrowserHelp	^'Presentation in Version Browser The package version can be presented in the version browser in one of the three formsListIn this form, the package versions are listed sequentially from the most recent package version to the earliest. There is no indicatation about the relationship between the versions.Indented listIn this form, the package versions are presented as an indented list. The indentation enables to trace the relationship between a package version, its predecessors and all of the versions that were derived from the original version. The versions that were merged with other package versions (i.e., their state is INTEGRATED) are presented in bold.Graph ViewIn this form, the package versions are presented as a directed graph. The arrows in the graph are between the original package and all other package versions that were derived from the original version. The versions that were merged with other package versions (i.e., their state is INTEGRATED) are presented in bold.'</body></methods><methods><class-id>Store.UISettings</class-id> <category>resources</category><body package="Store-UI" selector="fieldMenu">fieldMenu	^MenuBuilder new		add: 'find...'-&gt;[:ctrlr | ctrlr find];		add: 'replace...'-&gt;			[:ctrlr |			ctrlr replace.			self disturb];		line;		add: 'undo' -&gt;			[:ctrlr |			ctrlr undo.			self disturb];		line;		add: 'copy'-&gt;[:ctrlr | ctrlr copySelection];		add: 'cut'-&gt;			[:ctrlr |			ctrlr cut.			self disturb];		add: 'paste'-&gt;			[:ctrlr |			ctrlr paste.			self disturb];		line;		menu</body></methods><methods><class-id>Store.UISettings</class-id> <category>private</category><body package="Store-UI" selector="enableBlessingLevelMenu">enableBlessingLevelMenu	| button |	( button := subBuilder namedComponents at: #blessingLevel ifAbsent: nil ) notNil		ifTrue: 			[ ( self class preferenceModelFor: #versionSelectionEditing ) value == #ask				ifTrue: [ button disable ]				ifFalse: [ button enable ]			].</body><body package="Store-UI" selector="masterList">masterList	^super masterList"	^TT_UISettings classPool at: (self class preferenceFor: #preferencesMasterList)"</body><body package="Store-UI" selector="rebuild">rebuild	super rebuild.	self enableBlessingLevelMenu.</body><body package="Store-UI" selector="versionSelectionChanged">versionSelectionChanged	self enableBlessingLevelMenu.	self disturb.</body></methods><methods><class-id>Store.UISettings</class-id> <category>interface opening</category><body package="Store-UI" selector="postOpenWith:">postOpenWith: aBuilder 	super postOpenWith: aBuilder.	self enableBlessingLevelMenu.</body><body package="Store-UI" selector="preBuildWith:">preBuildWith: aBuilder 	UserPreferences keysAndValuesDo: 		[ :key :value | aBuilder aspectAt: key put: value ]</body></methods><methods><class-id>Store.UISettings class</class-id> <category>class initialization</category><body package="Store-UI" selector="initialize">initialize	"self initialize "	self initializeUserPreferences.	developmentSpecList := OrderedCollection new				add: 'Database'-&gt;#(#databaseSpec #databaseHelp);				add: 'New Classes'-&gt;#(#newClassSpec #newClassHelp);				add: 'New Methods'-&gt;#(#newMethodSpec #newMethodHelp);				add: 'New Shared Variables'-&gt;#(#newDatumSpec #newDatumHelp);				add: 'Package Compare'-&gt;#(#packageCompareSpec #packageCompareHelp);"				add: 'Tool Options'-&gt;#(#toolOptionSpec #toolOptionHelp);    ** not being used. "				add: 'Fileout Options'-&gt;#(#fileoutOptionSpec #fileoutOptionHelp);				add: 'Prerequisite Loading'-&gt;#(#prereqOptionsSpec #prereqOptionsHelp);				add: 'Load Options'-&gt;#(#binaryLoadSpec #binaryLoadHelp);				asArray.	runtimeSpecList := OrderedCollection new				asArray.</body><body package="Store-UI" selector="initializeUserPreferences">initializeUserPreferences	"The user preference profile is a Dictionary with of value models against subject keys."	"self initializeUserPreferences"	UserPreferences == nil ifTrue: [ UserPreferences := Dictionary new ].	UserPreferences		at: #databaseIdentifier  put: (self databaseIdentifier asValue);		at: #preferencesMasterList ifAbsentPut: [#developmentSpecList asValue]; 		at: #ttUseChangeSetsForCompare ifAbsentPut: [true asValue];		at: #ttUseChangeSetsForCompareEditing put: 			((UserPreferences at: #ttUseChangeSetsForCompare) value asValue);		at: #ttShowPackageComments ifAbsentPut: [true asValue];		at: #ttShowPackageCommentsEditing put: 			((UserPreferences at: #ttShowPackageComments) value asValue);		at: #fileoutOption ifAbsentPut: [ #always asValue ];		at: #fileoutOptionEditing put: 			((UserPreferences at: #fileoutOption) value asValue);		at: #packageDir ifAbsentPut: ['' asValue];		at: #packageDirEditing put: ((UserPreferences at: #packageDir) value asValue);		at: #tablePrefix ifAbsentPut: [self tablePrefix asValue];		at: #databaseAccept put: [self databaseAccept]; 		at: #databaseReset put: [self databaseReset];		at: #newClassUseCurrent put: Policies packagePolicy newClassUseCurrent asValue;		at: #newClassUseCurrentEditing ifAbsentPut: [(UserPreferences at: #newClassUseCurrent) value asValue];		at: #newClassAccept put: [self newClassAccept]; 		at: #newClassReset put: [self newClassReset];		at: #methodPlacement ifAbsentPut: [self methodPlacementInitialize asValue];		at: #methodPlacementEditing put: (UserPreferences at: #methodPlacement) value asValue;		at: #newMethodAccept put: [self newMethodAccept]; 		at: #newMethodReset put: [self newMethodReset];		at: #datumPlacement ifAbsentPut: [self datumPlacementInitialize asValue];		at: #datumPlacementEditing put: (UserPreferences at: #datumPlacement) value asValue;		at: #versionSelection put: Policies prerequisitePolicy versionSelection asValue;		at: #searchOrder put: Policies prerequisitePolicy searchOrder asValue;		at: #blessingLevel put: Policies prerequisitePolicy blessingLevel asValue;		at: #versionSelectionEditing put: 			((UserPreferences at: #versionSelection) value asValue );		at: #searchOrderEditing put: 			((UserPreferences at: #searchOrder) value asValue );		at: #blessingLevelEditing put: 			((UserPreferences at: #blessingLevel) value asValue );		at: #newDatumAccept put: [self newDatumAccept]; 		at: #newDatumReset put: [self newDatumReset];		at: #packageCompareAccept put: [self packageCompareAccept]; 		at: #packageCompareReset put: [self packageCompareReset];		at: #toolOptionAccept put: [self toolOptionAccept]; 		at: #toolOptionReset put: [self toolOptionReset];		at: #fileoutOptionAccept put: [self fileoutOptionAccept]; 		at: #fileoutOptionReset put: [self fileoutOptionReset];		at: #versionManagerView ifAbsentPut: [#listPresentation asValue];		at: #versionManagerViewEditing put: ((UserPreferences at: #versionManagerView) value asValue);		at: #versionBrowserAccept put: [self versionBrowserAccept]; 		at: #versionBrowserReset put: [self versionBrowserReset];		at: #prereqOptionAccept put: [self prereqOptionAccept]; 		at: #prereqOptionReset put: [self prereqOptionReset];		at: #blessingLevelMenu put: [ Policies blessingPolicy blessingLevelsMenu ];		at: #allowBinaryLoading put: Policies publishPolicy allowBinaryLoading asValue;		at: #allowBinaryLoadingEditing ifAbsentPut: [(UserPreferences at: #allowBinaryLoading) value asValue];		at: #binaryLoadAccept put: [self binaryLoadAccept]; 		at: #binaryLoadReset put: [self binaryLoadReset];		yourself.</body><body package="Store-UI" selector="open">open	self raiseSingleInstance isNil ifTrue: [^super open]</body></methods><methods><class-id>Store.UISettings class</class-id> <category>accessing preferences</category><body package="Store-UI" selector="binaryLoadAccept">binaryLoadAccept	(self preferenceModelFor: #allowBinaryLoading)		value: (self preferenceFor: #allowBinaryLoadingEditing).	Policies publishPolicy allowBinaryLoading: (self preferenceFor: #allowBinaryLoadingEditing) value</body><body package="Store-UI" selector="binaryLoadReset">binaryLoadReset	(self preferenceModelFor: #allowBinaryLoadingEditing)		value: (self preferenceFor: #allowBinaryLoading)</body><body package="Store-UI" selector="databaseAccept">databaseAccept	(self preferenceModelFor: #packageDir)		value: (self preferenceFor: #packageDirEditing).	self checkPackageDir		ifTrue: 			[Package resetPkgViews.			DbRegistry closeConnection.			DbRegistry tablePrefix: (self preferenceFor: #tablePrefixEditing).			]</body><body package="Store-UI" selector="databaseReset">databaseReset	(self preferenceModelFor: #packageDirEditing)		value: (self preferenceFor: #packageDir)</body><body package="Store-UI" selector="fileoutOptionAccept">fileoutOptionAccept	( self preferenceModelFor: #fileoutOption ) 		value: ( self preferenceFor: #fileoutOptionEditing ).	( self preferenceModelFor: #fileoutOption ) value == #always		ifTrue: [ Registry installCallBacksForFileout ]		ifFalse: [ Registry removeCallBacksForFileout ].</body><body package="Store-UI" selector="fileoutOptionReset">fileoutOptionReset	(self preferenceModelFor: #fileoutOptionEditing) 		value: (self preferenceFor: #fileoutOption)</body><body package="Store-UI" selector="newClassAccept">newClassAccept	(self preferenceModelFor: #newClassUseCurrent)		value: (self preferenceFor: #newClassUseCurrentEditing).	Policies packagePolicy newClassUseCurrent: (self preferenceFor: #newClassUseCurrentEditing)</body><body package="Store-UI" selector="newClassReset">newClassReset	(self preferenceModelFor: #newClassUseCurrentEditing)		value: (self preferenceFor: #newClassUseCurrent)</body><body package="Store-UI" selector="newDatumAccept">newDatumAccept	| pkgPolicy |	pkgPolicy := Policies packagePolicy.	(self preferenceModelFor: #datumPlacement)		value: (self preferenceFor: #datumPlacementEditing).	(self preferenceFor: #datumPlacement)		= #currentINAU		ifTrue: 			[pkgPolicy newDatumUseCurrent: true.			pkgPolicy newDatumUseClassIfNoCurrent: false.			pkgPolicy newDatumUseClassIfCurrentSame: false.			pkgPolicy newDatumUseClass: false.			^self].	(self preferenceFor: #datumPlacement)		= #currentINUTCP		ifTrue: 			[pkgPolicy newDatumUseCurrent: true.			pkgPolicy newDatumUseClassIfNoCurrent: false.			pkgPolicy newDatumUseClassIfCurrentSame: false.			pkgPolicy newDatumUseClass: true.			^self].	(self preferenceFor: #datumPlacement)		= #useTCP		ifTrue: 			[pkgPolicy newDatumUseCurrent: false.			pkgPolicy newDatumUseClassIfNoCurrent: false.			pkgPolicy newDatumUseClassIfCurrentSame: false.			pkgPolicy newDatumUseClass: true.			^self].	(self preferenceFor: #datumPlacement)		= #useTCPIC		ifTrue: 			[pkgPolicy newDatumUseCurrent: false.			pkgPolicy newDatumUseClassIfNoCurrent: false.			pkgPolicy newDatumUseClassIfCurrentSame: true.			pkgPolicy newDatumUseClass: true.			^self].	(self preferenceFor: #datumPlacement)		= #useTCPICON		ifTrue: 			[pkgPolicy newDatumUseCurrent: false.			pkgPolicy newDatumUseClassIfNoCurrent: true.			pkgPolicy newDatumUseClassIfCurrentSame: true.			pkgPolicy newDatumUseClass: true.			^self].	pkgPolicy newDatumUseCurrent: false.	pkgPolicy newDatumUseClassIfNoCurrent: false.	pkgPolicy newDatumUseClassIfCurrentSame: false.	pkgPolicy newDatumUseClass: false</body><body package="Store-UI" selector="newDatumReset">newDatumReset	(self preferenceModelFor: #datumPlacementEditing)		value: (self preferenceFor: #datumPlacement).</body><body package="Store-UI" selector="newMethodAccept">newMethodAccept	| pkgPolicy |	pkgPolicy := Policies packagePolicy.	(self preferenceModelFor: #methodPlacement)		value: (self preferenceFor: #methodPlacementEditing).	(self preferenceFor: #methodPlacement)		= #currentINAU		ifTrue: 			[pkgPolicy newMethodUseCurrent: true.			pkgPolicy newMethodUseClassIfNoCurrent: false.			pkgPolicy newMethodUseClassIfCurrentSame: false.			pkgPolicy newMethodUseClass: false.			^self].	(self preferenceFor: #methodPlacement)		= #currentINUTCP		ifTrue: 			[pkgPolicy newMethodUseCurrent: true.			pkgPolicy newMethodUseClassIfNoCurrent: false.			pkgPolicy newMethodUseClassIfCurrentSame: false.			pkgPolicy newMethodUseClass: true.			^self].	(self preferenceFor: #methodPlacement)		= #useTCP		ifTrue: 			[pkgPolicy newMethodUseCurrent: false.			pkgPolicy newMethodUseClassIfNoCurrent: false.			pkgPolicy newMethodUseClassIfCurrentSame: false.			pkgPolicy newMethodUseClass: true.			^self].	(self preferenceFor: #methodPlacement)		= #useTCPIC		ifTrue: 			[pkgPolicy newMethodUseCurrent: false.			pkgPolicy newMethodUseClassIfNoCurrent: false.			pkgPolicy newMethodUseClassIfCurrentSame: true.			pkgPolicy newMethodUseClass: true.			^self].	(self preferenceFor: #methodPlacement)		= #useTCPICON		ifTrue: 			[pkgPolicy newMethodUseCurrent: false.			pkgPolicy newMethodUseClassIfNoCurrent: true.			pkgPolicy newMethodUseClassIfCurrentSame: true.			pkgPolicy newMethodUseClass: true.			^self].	pkgPolicy newMethodUseCurrent: false.	pkgPolicy newMethodUseClassIfNoCurrent: false.	pkgPolicy newMethodUseClassIfCurrentSame: false.	pkgPolicy newMethodUseClass: false</body><body package="Store-UI" selector="newMethodReset">newMethodReset	(self preferenceModelFor: #methodPlacementEditing)		value: (self preferenceFor: #methodPlacement).</body><body package="Store-UI" selector="packageCompareAccept">packageCompareAccept	(self preferenceModelFor: #ttUseChangeSetsForCompare) 		value: (self preferenceFor: #ttUseChangeSetsForCompareEditing)</body><body package="Store-UI" selector="packageCompareReset">packageCompareReset	(self preferenceModelFor: #ttUseChangeSetsForCompareEditing) 		value: (self preferenceFor: #ttUseChangeSetsForCompare)</body><body package="Store-UI" selector="preferenceFor:">preferenceFor: aSubject 	^(self preferenceModelFor: aSubject) value</body><body package="Store-UI" selector="preferenceModelFor:">preferenceModelFor: aSubject 	UserPreferences isNil ifTrue: [self initializeUserPreferences].	^(UserPreferences at: aSubject ifAbsent: [^nil])</body><body package="Store-UI" selector="preferenceModelFor:put:">preferenceModelFor: aSubject put: aModel	UserPreferences isNil ifTrue: [self initializeUserPreferences].	^UserPreferences at: aSubject put: aModel</body><body package="Store-UI" selector="prereqOptionAccept">prereqOptionAccept	( self preferenceModelFor: #searchOrder ) 		value: ( self preferenceFor: #searchOrderEditing ).	( self preferenceModelFor: #versionSelection ) 		value: ( self preferenceFor: #versionSelectionEditing ).	( self preferenceModelFor: #blessingLevel ) 		value: ( self preferenceFor: #blessingLevelEditing ).	Policies prerequisitePolicy 		searchOrder: ( self preferenceFor: #searchOrder ) value;		versionSelection: ( self preferenceFor: #versionSelection ) value;		blessingLevel: ( self preferenceFor: #blessingLevel ) value;		yourself.</body><body package="Store-UI" selector="prereqOptionReset">prereqOptionReset	( self preferenceModelFor: #searchOrderEditing ) 		value: ( self preferenceFor: #searchOrder ).	( self preferenceModelFor: #versionSelectionEditing ) 		value: ( self preferenceFor: #versionSelection ).	( self preferenceModelFor: #blessingLevelEditing ) 		value: ( self preferenceFor: #blessingLevel ).</body><body package="Store-UI" selector="resetEditing">resetEditing</body><body package="Store-UI" selector="toolOptionAccept">toolOptionAccept	(self preferenceModelFor: #ttShowPackageComments) 		value: (self preferenceFor: #ttShowPackageCommentsEditing)</body><body package="Store-UI" selector="toolOptionReset">toolOptionReset	(self preferenceModelFor: #ttShowPackageCommentsEditing) 		value: (self preferenceFor: #ttShowPackageComments)</body><body package="Store-UI" selector="versionBrowserAccept">versionBrowserAccept	(self preferenceModelFor: #versionManagerView)		value: (self preferenceFor: #versionManagerViewEditing).</body><body package="Store-UI" selector="versionBrowserReset">versionBrowserReset	(self preferenceModelFor: #versionManagerViewEditing)		value: (self preferenceFor: #versionManagerView).</body></methods><methods><class-id>Store.UISettings class</class-id> <category>load/unload</category><body package="Store-UI" selector="prerequisitesForLoading">prerequisitesForLoading	"TT_DBAcess initializes TT_DBRegistry."	^super prerequisitesForLoading		add: DBAccess;		add: Access;		yourself</body></methods><methods><class-id>Store.UISettings class</class-id> <category>private</category><body package="Store-UI" selector="checkPackageDir">checkPackageDir	"Test if the specified directory exists.  If the string is empty answer true."	| fmDir |	fmDir := self preferenceFor: #packageDirEditing.	fmDir isEmpty ifTrue: [ ^true ].	fmDir := LogicalFilename named: fmDir.	( fmDir definitelyExists and: [ fmDir isDirectory ] )		ifFalse: 			[ Dialog warn: 'Directory: ' , fmDir asString, '\\does not exist.' withCRs.			^false			].	fmDir isWritable		ifFalse: 			[ Dialog warn: 'Directory: ' , fmDir asString, '\\is not writable.' withCRs.			^false			].	^true</body><body package="Store-UI" selector="databaseIdentifier">databaseIdentifier	"Answer the current database indentifier, nil if none"	^ #{DbRegistry} ifDefinedDo:		[ :reg | reg databaseIdentifier ]</body><body package="Store-UI" selector="datumPlacementInitialize">datumPlacementInitialize	Policies packagePolicy newDatumUseCurrent		ifTrue: [Policies packagePolicy newDatumUseClass				ifTrue: [^#currentINUTCP]				ifFalse: [^#currentINAU]]		ifFalse: [Policies packagePolicy newDatumUseClass				ifTrue: [Policies packagePolicy newDatumUseClassIfNoCurrent						ifTrue: [Policies packagePolicy newDatumUseClassIfCurrentSame								ifTrue: [^#TCPICON]								ifFalse: [^#TCPIC]]						ifFalse: [^#useTCP]]				ifFalse: [^#alwaysAsk]].	^#alwaysAsk</body><body package="Store-UI" selector="methodPlacementInitialize">methodPlacementInitialize	Policies packagePolicy newMethodUseCurrent		ifTrue: [Policies packagePolicy newMethodUseClass				ifTrue: [^#currentINUTCP]				ifFalse: [^#currentINAU]]		ifFalse: [Policies packagePolicy newMethodUseClass				ifTrue: [Policies packagePolicy newMethodUseClassIfNoCurrent						ifTrue: [Policies packagePolicy newMethodUseClassIfCurrentSame								ifTrue: [^#TCPICON]								ifFalse: [^#TCPIC]]						ifFalse: [^#useTCP]]				ifFalse: [^#alwaysAsk]].	^#alwaysAsk</body><body package="Store-UI" selector="tablePrefix">tablePrefix	^ DbRegistry tablePrefix.</body></methods><methods><class-id>Store.UISettings class</class-id> <category>constants</category><body package="Store-UI" selector="windowLabel">windowLabel	^'Store Settings'</body></methods><methods><class-id>Store.PkgMetaclassesView class</class-id> <category>installation</category><body package="Store-DB-Records" selector="childReference">childReference	^'metaclassRef'</body></methods><methods><class-id>Store.PkgMetaclassesView class</class-id> <category>session</category><body package="Store-DB-Records" selector="metaclassesSession">metaclassesSession	( self isSessionValid: MetaclassesSession)		ifFalse:			[MetaclassesSession := self broker getNewSession.			MetaclassesSession bindOutput: self newPrimed.			MetaclassesSession bindInput: Package new.			MetaclassesSession prepare: 						( self newSQL							selectAll;							where;							column: #packageRef equalTo: ':primaryKey';							orderBy: #definitionOrder) ].	^MetaclassesSession</body><body package="Store-DB-Records" selector="resetSession">resetSession	MetaclassesSession notNil		ifTrue: 			[ self brokerOrNil notNil 				ifTrue: [ self broker dismissSession: MetaclassesSession ].			MetaclassesSession := nil			]</body></methods><methods><class-id>Store.ChangeSetInspector</class-id> <category>field list</category><body package="Store-UI" selector="fieldAll">fieldAll	^'*** all ***'</body><body package="Store-UI" selector="fieldList">fieldList	"Answer a collection of the keys of the inspected dictionary."	| keys | 	keys := object keys.	keys add: self fieldAll.	^keys asSortedCollection</body><body package="Store-UI" selector="fieldMenu">fieldMenu	^(InputState default ctrlDown or: [self object isMainChangeSet])		ifTrue: [field isSymbol				ifTrue: [Menu						labels: 'inspect changes to class\file out changes to class as...\empty changes to class...\file out all changes as ...\empty all changes...' withCRs						lines: #(3)						values: #(#inspectField #fileOutField #emptyField #fileOut #empty)]				ifFalse: [Menu labels: 'file out all changes as ...\empty all changes...' withCRs values: #(#fileOut #empty)]]		ifFalse: [field isSymbol				ifTrue: [Menu						labels: 'file out changes to class as...\file out all changes as ...' withCRs						lines: #(1)						values: #(#fileOutField #fileOut)]				ifFalse: [Menu labels: 'file out all changes as ...' withCRs values: #(#fileOut)]]</body><body package="Store-UI" selector="fieldValue">fieldValue	field = self fieldAll ifTrue: [ ^object ].	^object at: field		ifAbsent: 	['no longer any changes to this class']</body><body package="Store-UI" selector="printItems">printItems	"Answer whether the elements of the list of fields needs to be converted to strings"	^false</body></methods><methods><class-id>Store.ChangeSetInspector</class-id> <category>menu commands</category><body package="Store-UI" selector="empty">empty	(Dialog confirm: 'Really empty this change set?'			for: self interfaceWindow) 		ifTrue:			[self object initialize.			self changed: #text]</body><body package="Store-UI" selector="emptyField">emptyField	(Dialog confirm: 'Really empty all changes to class ', self field, '?'			for: self interfaceWindow) 		ifTrue:			[self object doClassChange: 					((Change new) classSymbol: self field; removeChanges).			field := nil.			self changed: #field]</body><body package="Store-UI" selector="fileOut">fileOut	| fileName |	fileName := Dialog requestNewFileName: 'File out as file named'					default: 'filename.st'.	fileName isEmpty ifTrue: [^self].	fileName := Filename named: fileName.	Transcript cr; cr; show: ('Filing out changes on:'); crtab; show: fileName asString.	Cursor write showWhile:		[ | strm |		strm := SourceCodeStream write: fileName.		[ strm timeStamp.		self object fileOutOn: strm		] ensure: [ strm close ]		]</body><body package="Store-UI" selector="fileOutField">fileOutField	| fileName |	fileName := Dialog requestNewFileName: 'File out change to ', self field, ' as file named'					default: 'filename.st'.	fileName isEmpty ifTrue: [^self].	fileName := Filename named: fileName.	Transcript cr; cr; show: ('Filing out changes on:'); crtab; show: fileName asString.	Cursor write showWhile:		[| strm |		strm := SourceCodeStream write: fileName.		[strm timeStamp.		self object fileOutOn: strm classSymbol: self field]			ensure: [strm close]]</body></methods><methods><class-id>Store.ChangeSetInspector</class-id> <category>initialize-release</category><body package="Store-UI" selector="inspect:">inspect: anObject 	super inspect: anObject .	self field: self fieldAll.</body><body package="Store-UI" selector="viewLabel">viewLabel	^windowLabel == nil		ifTrue:			[ self object isMainChangeSet				ifTrue: ['Main Changes']				ifFalse: ['Package Changes']			]		ifFalse: [ windowLabel ].</body></methods><methods><class-id>Store.ChangeSetInspector</class-id> <category>accessing</category><body package="Store-UI" selector="windowLabel:">windowLabel: aString	windowLabel := aString</body></methods><methods><class-id>Store.ChangeSetInspector class</class-id> <category>view creation</category><body package="Store-UI" selector="inspect:label:">inspect: anObject label: aLabel	"Answer an instance of me to provide an inspector for anObject."	^self open: 		( self new 			windowLabel: aLabel;			inspect: anObject		)</body><body package="Store-UI" selector="open:">open: anInspector 	"Create and schedule a window on the model, anInspector."	| window |	anInspector allButOpenInterface: #windowSpec.	window := anInspector builder window.	anInspector finallyOpenIn: (window defaultRectangle: (300 @ 200) rounded)		withType: #normal</body></methods><methods><class-id>Store.NameSpaceLoader</class-id> <category>interface opening</category><body package="Store-UI" selector="openForNameSpace:package:">openForNameSpace: aNameSpace package: aPackage	self nameSpace: aNameSpace; package: aPackage.	self openInterface: #loadDialog</body><body package="Store-UI" selector="postOpenWith:">postOpenWith: aBuilder 	aBuilder window label: 'Loader For: ', namespace fullName.</body></methods><methods><class-id>Store.NameSpaceLoader</class-id> <category>actions</category><body package="Store-UI" selector="loadAll">loadAll	self definition value: true.	self comment value: true.	self data value: true.	self loadChoosen</body></methods><methods><class-id>Store.NameSpaceLoader</class-id> <category>accessing</category><body package="Store-UI" selector="componentsToLoad">componentsToLoad	"If aBoolean is true answer the instance side."	| comp |	comp := Set new.	self definition value ifTrue: [ comp add: #definition ].	self comment value ifTrue: [ comp add: #comment ].	self data value ifTrue: [comp add: #data ].	^comp</body><body package="Store-UI" selector="nameSpace:">nameSpace: aNameSpace	namespace := aNameSpace</body></methods><methods><class-id>Store.NameSpaceLoader</class-id> <category>aspects</category><body package="Store-UI" selector="definition">definition	^definition isNil 		ifTrue: [ definition := false asValue ]		ifFalse: [ definition ]</body></methods><methods><class-id>Store.NameSpaceLoader class</class-id> <category>interface opening</category><body package="Store-UI" selector="openForNameSpace:package:">openForNameSpace: aNameSpace package: aPackage	| baby |	baby := self new.	baby nameSpace: aNameSpace; package: aPackage.	self openOn: baby withSpec: #loadDialog</body></methods><methods><class-id>Store.PundleLoadedChange</class-id> <category>fileIn/Out</category><body package="Store-Change Management" selector="fileIn">fileIn	"File-in the receiver - ie. make the change to the system."	Pundle 		reloadPundle: componentType 		named: componentName  		id: primaryKey  		fromDatabase: databaseId</body><body package="Store-Change Management" selector="fileOutOn:">fileOutOn: aSourceFile	aSourceFile		loadPundleNamed: componentName		type: componentType		primaryKey: databaseId		databaseId: primaryKey</body></methods><methods><class-id>Store.PundleLoadedChange</class-id> <category>testing</category><body package="Store-Change Management" selector="sameAsSystem">sameAsSystem	"Return true if the receiver represents an object that is the same as the system."	| comp |	( comp := self component ) == nil		ifTrue: [ ^false ].	^databaseId = comp databaseId and: [ primaryKey = comp dbTrace ]</body></methods><methods><class-id>Store.PundleLoadedChange</class-id> <category>comparing</category><body package="Store-Change Management" selector="=">= aChange	^( super = aChange ) and:		[ ( databaseId = aChange databaseId ) &amp; ( primaryKey = aChange primaryKey ) ].</body></methods><methods><class-id>Store.PundleLoadedChange</class-id> <category>accessing</category><body package="Store-Change Management" selector="actionString">actionString	"Answer a string for messages describing the receiver."	^' loaded from '</body><body package="Store-Change Management" selector="component:">component: aCodeComponent	"Extract relevant information from aCodeComponent."	super component: aCodeComponent.	databaseId := aCodeComponent databaseId.	primaryKey := aCodeComponent primaryKey.</body><body package="Store-Change Management" selector="databaseId">databaseId	^databaseId</body><body package="Store-Change Management" selector="databaseId:">databaseId: aString	databaseId := aString</body><body package="Store-Change Management" selector="parameters">parameters	"Return the parameters used for the 'same as' test"	^super parameters asOrderedCollection		add: databaseId;		add: primaryKey;		asArray.</body><body package="Store-Change Management" selector="primaryKey">primaryKey	^primaryKey</body><body package="Store-Change Management" selector="primaryKey:">primaryKey: anInteger	primaryKey := anInteger</body><body package="Store-Change Management" selector="systemVersion:">systemVersion: aCodeComponent	"Answer an appropiate version string for aCodeComponent."	^aCodeComponent databaseId 		ifNil: [ (#NotInConnectedDatabase &lt;&lt; #store &gt;&gt; 'Not in Connected Database') asString ]		ifNotNil: [ :id | id , ': ' , aCodeComponent primaryKey printString ]</body><body package="Store-Change Management" selector="type">type 	"Answer the sub-type of this kind of change."	^#componentLoaded</body></methods><methods><class-id>Store.PundleLoadedChange</class-id> <category>printing</category><body package="Store-Change Management" selector="version">version	^databaseId, ': ', primaryKey printString</body></methods><methods><class-id>Store.DefinitionBrowserApplication</class-id> <category>initialization</category><body package="Store-UI-Browser" selector="browseMethodsOrStatics:">browseMethodsOrStatics: aCollection	forcedList := aCollection asList.	components := List new		 add: self methodListComponent;		yourself.	self linkComponentsInArray: components.	components first setNewListSilently: aCollection.	self browser updateLists</body><body package="Store-UI-Browser" selector="browseNameSpacesOrClasses:">browseNameSpacesOrClasses: aCollection	forcedList := aCollection asList.	components := List new		 add: self classesComponent;		yourself.	self linkComponentsInArray: components.	components first setNewListSilently: aCollection.	self browser updateLists</body><body package="Store-UI-Browser" selector="browsePackages:">browsePackages: aCollection	forcedList := aCollection asList.	components := List new		 add: self packageComponent;		yourself.	self linkComponentsInArray: components.	components first setNewListSilently: aCollection.	self browser updateLists</body><body package="Store-UI-Browser" selector="editPackage:methodsOrStatics:">editPackage: pkg methodsOrStatics: aCollection	forcedList := aCollection asList.	components := List new		 add: self methodPackageEditorComponent;		yourself.	self linkComponentsInArray: components.	self browser setPackageFor: #default to: pkg.	components first setNewListSilently: aCollection.	self browser updateLists</body></methods><methods><class-id>Store.DefinitionBrowserApplication</class-id> <category>componentBuilding</category><body package="Store-UI-Browser" selector="classesComponent">classesComponent	^SimpleBrowserModule new		helperType: PackageClassesVersionBrowserHelper</body><body package="Store-UI-Browser" selector="methodListComponent">methodListComponent	^SimpleBrowserModule new		helperType: PackageMethodsVersionBrowserHelper</body><body package="Store-UI-Browser" selector="methodPackageEditorComponent">methodPackageEditorComponent	^SimpleBrowserModule new		helperType: PackageMethodsEditorHelper</body><body package="Store-UI-Browser" selector="packageComponent">packageComponent	^SimpleBrowserModule new		helperType: PackageVersionBrowserHelper</body></methods><methods><class-id>Store.DefinitionBrowserApplication</class-id> <category>lists</category><body package="Store-UI-Browser" selector="allPackages">allPackages	^forcedList</body><body package="Store-UI-Browser" selector="generateMethodsFor:">generateMethodsFor: id	^forcedList</body><body package="Store-UI-Browser" selector="generateNameSpaceClassListFor:">generateNameSpaceClassListFor: selectionId	^forcedList == nil		ifTrue: [ OrderedCollection new ]		ifFalse: [ forcedList ].</body><body package="Store-UI-Browser" selector="generateProtocolsFor:">generateProtocolsFor: id	^forcedList</body></methods><methods><class-id>Store.DefinitionBrowserApplication</class-id> <category>updating</category><body package="Store-UI-Browser" selector="update:with:from:">update: anAspect with: aParameter from: aSender</body></methods><methods><class-id>Store.PundleSavedChange</class-id> <category>fileIn/Out</category><body package="Store-Change Management" selector="fileIn">fileIn	"File-in the receiver - ie. make the change to the system."	"Note- The saving of a Pundle action is same as loading. "	super fileIn</body><body package="Store-Change Management" selector="fileOutOn:">fileOutOn: aSourceFile	aSourceFile		savePundleNamed: componentName		type: componentType		primaryKey: databaseId		databaseId: primaryKey</body></methods><methods><class-id>Store.PundleSavedChange</class-id> <category>accessing</category><body package="Store-Change Management" selector="actionString">actionString	"Answer a string for messages describing the receiver."	^' saved to '</body><body package="Store-Change Management" selector="type">type 	"Answer the sub-type of this kind of change."	^#componentSaved</body></methods><methods><class-id>Store.PackagesView</class-id> <category>accessing</category><body package="Store-DB-Pundles" selector="binFile">binFile	^binFile</body><body package="Store-DB-Pundles" selector="binFile:">binFile: aString	binFile := aString</body><body package="Store-DB-Pundles" selector="bundleRef">bundleRef	^bundleRef</body><body package="Store-DB-Pundles" selector="bundleRef:">bundleRef: aValue	bundleRef := aValue</body><body package="Store-DB-Pundles" selector="commentSize">commentSize	^commentSize</body><body package="Store-DB-Pundles" selector="commentSize:">commentSize: aNumber	commentSize := aNumber</body><body package="Store-DB-Pundles" selector="expression">expression	^expression</body><body package="Store-DB-Pundles" selector="expression:">expression: aValue	expression := aValue</body><body package="Store-DB-Pundles" selector="longField">longField	^longField</body><body package="Store-DB-Pundles" selector="longField:">longField: anObject	longField := anObject</body><body package="Store-DB-Pundles" selector="seqNumber">seqNumber	^seqNumber</body><body package="Store-DB-Pundles" selector="seqNumber:">seqNumber: aValue	seqNumber := aValue</body></methods><methods><class-id>Store.PackagesView class</class-id> <category>installation</category><body package="Store-DB-Pundles" selector="childReference">childReference		^'packageRef'</body><body package="Store-DB-Pundles" selector="parentReference">parentReference	^'bundleRef'</body><body package="Store-DB-Pundles" selector="referencedClass">referencedClass	^Bundle</body><body package="Store-DB-Pundles" selector="subCollectionClass">subCollectionClass	^Packages</body></methods><methods><class-id>Store.PackagesView class</class-id> <category>session</category><body package="Store-DB-Pundles" selector="packageSession">packageSession	( self isSessionValid: PackageSession)		ifFalse:			[PackageSession := self broker getNewSession.			PackageSession bindOutput: self newPrimed.			PackageSession bindInput: Package new.			PackageSession prepare: 					( self newSQL						selectAll;						where;						column: #bundleRef equalTo: ':primaryKey') ].	^PackageSession</body><body package="Store-DB-Pundles" selector="resetSession">resetSession	PackageSession notNil		ifTrue: 			[ self brokerOrNil notNil 				ifTrue: [ self broker dismissSession: PackageSession ].			PackageSession := nil			]</body></methods><methods><class-id>Store.BundleStructureTag</class-id> <category>private</category><body package="Store-Change Management" selector="formatStructure:">formatStructure: structure	"Answers a formatted print string for the bundle structure."		| stream |	stream := (String new: 256) writeStream.	structure do:		[ :array |		stream 			nextPutAll: array first printString; tab; tab;			nextPutAll: array last; cr		].	^stream contents</body></methods><methods><class-id>Store.BundleStructureTag</class-id> <category>private-loading</category><body package="Store-Change Management" selector="applyDefinitionFrom:into:">applyDefinitionFrom: dbPackage into: imgPackage	"Load the change. Answer true is the operation is successful."	dbPackage isLoaded		ifTrue: [ ^true ].		"already the in image version"	imgPackage structure: dbPackage structure.	^true.</body><body package="Store-Change Management" selector="removeFromSystemTolerant:fromPackage:">removeFromSystemTolerant: tolerantBoolean fromPackage: aPackage	tolerantBoolean		ifFalse: [ Dialog warn: 'Cannot remove bundle structure' ].</body></methods><methods><class-id>Store.BundleStructureTag</class-id> <category>testing</category><body package="Store-Change Management" selector="existsInImage">existsInImage	 ^self containingPackage ~~ nil</body><body package="Store-Change Management" selector="isStructureTag">isStructureTag	^true</body></methods><methods><class-id>Store.BundleStructureTag</class-id> <category>accessing</category><body package="Store-Change Management" selector="containingPackage">containingPackage	"Answer a packge that contians the defintion described by me, nil if none."	^package == nil		ifFalse: [ Registry bundleNamed: package name]</body><body package="Store-Change Management" selector="name">name	^'&lt;1s&gt; structure' 		expandMacrosWith: self packageName</body><body package="Store-Change Management" selector="sourceTextForImage">sourceTextForImage	^self sourceTextForImage: self containingPackage</body><body package="Store-Change Management" selector="sourceTextForImage:">sourceTextForImage: aPackage	aPackage == nil		ifTrue: [ ^'' ].	^self formatStructure: aPackage structure.</body><body package="Store-Change Management" selector="symbolKey">symbolKey	^#BundleStructure</body><body package="Store-Change Management" selector="text">text	package == nil 		ifTrue: [ ^'' ].	^self formatStructure: package structure.</body><body package="Store-Change Management" selector="textRepresentationForTag:">textRepresentationForTag: aTag 	^self text.</body></methods><methods><class-id>Store.BundleStructureTag</class-id> <category>actions</category><body package="Store-Change Management" selector="compileText:from:">compileText: someText from: aController 	"Compile new source for this tag. Return True if 	sucessful and False on failure."	| pkg |	^( pkg := self containingPackage ) == nil		ifTrue: [ false ]		ifFalse: [ pkg structure: package structure ].</body></methods><methods><class-id>Store.BundleStructureTag</class-id> <category>converting</category><body package="Store-Change Management" selector="recordForPackage:">recordForPackage: aPackage	"Answer a db record from aPackage."	"double dispatch. Answer nil if it's someone elses structure"	^( ( package isNil )  or: [ package comparesTo: aPackage ] )		ifTrue: [ 	aPackage recordForStructureTag: self ]</body></methods><methods><class-id>Store.BundleStructureTag</class-id> <category>change list support</category><body package="Store-Change Management" selector="browseSystemVersion">browseSystemVersion	BundleSpecEditor openOnBundle: package</body><body package="Store-Change Management" selector="definition">definition	^self text</body><body package="Store-Change Management" selector="fileOutOn:">fileOutOn: aStream 	"Fileout the system version onto aStream."	package == nil		ifFalse: [ aStream bundleStructure: package ].</body><body package="Store-Change Management" selector="fileOutOn:from:">fileOutOn: aStream from: aRecord	"Fileout the change onto aStream."	aStream bundleStructure: aRecord</body><body package="Store-Change Management" selector="fileOutRemovalOn:">fileOutRemovalOn: aStream 	"Fileout a removal of the object from the system onto aStream."	"nonsense"	^self shouldNotImplement</body><body package="Store-Change Management" selector="loadSrcIntoPackage:confirm:">loadSrcIntoPackage: aPackage confirm: aBoolean	"Load the receiver by setting its bundle structure."	aBoolean 		ifTrue: 			[ ( Dialog confirm: ( 'Reset &lt;1s&gt; bundle structure?' expandMacrosWith: aPackage name ) )				ifFalse: [ ^self ].			].	aPackage structure: package structure</body></methods><methods><class-id>Store.BundleStructureTag class</class-id> <category>instance creation</category><body package="Store-Change Management" selector="bundle:">bundle: aBundle	^self new		package: aBundle;		yourself</body></methods><methods><class-id>Store.BundleStructureTag class</class-id> <category>accessing</category><body package="Store-Change Management" selector="tagBaseIndex">tagBaseIndex	^11</body></methods><methods><class-id>Store.PundlesTool</class-id> <category>accessing</category><body package="Store-UI" selector="pundleClientApp">pundleClientApp	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^pundleClientApp isNil		ifTrue:			[pundleClientApp := PundleComponent new]		ifFalse:			[pundleClientApp]</body></methods><methods><class-id>Store.PundlesTool</class-id> <category>initialize-release</category><body package="Store-UI" selector="listUpdateBlock:sendUpdatesFor:menuBar:popupMenu:windowTitle:">listUpdateBlock: aBlock sendUpdatesFor: aSymbolCollection menuBar: aMenuBar popupMenu: aPopupMenu windowTitle: aTitle	self pundleClientApp listUpdateBlock: aBlock sendUpdatesFor: aSymbolCollection popupMenu: aPopupMenu.	self menuBar: aMenuBar popupMenu: aPopupMenu windowTitle: aTitle.</body><body package="Store-UI" selector="release">release	super release.	pundleClientApp release</body></methods><methods><class-id>Store.PundlesTool</class-id> <category>selection</category><body package="Store-UI" selector="pundles">pundles	^pundleClientApp pundles</body><body package="Store-UI" selector="pundleVersions">pundleVersions	^pundleClientApp pundles</body></methods><methods><class-id>Store.PundlesTool</class-id> <category>actions</category><body package="Store-UI" selector="reloadVersions">reloadVersions	pundleClientApp reloadVersions</body></methods><methods><class-id>Store.PublishedPundlesTool</class-id> <category>updating</category><body package="Store-UI" selector="selectionChanged">selectionChanged	self versionClientApp pundles: pundleClientApp pundles.	self versionClientApp reloadVersions</body></methods><methods><class-id>Store.PublishedPundlesTool</class-id> <category>selection</category><body package="Store-UI" selector="pundles">pundles	^self versionClientApp pundles size &gt; 0		ifTrue: [self versionClientApp pundles]		ifFalse: [pundleClientApp pundles]</body><body package="Store-UI" selector="pundleVersions">pundleVersions	^self versionClientApp pundles</body></methods><methods><class-id>Store.PublishedPundlesTool</class-id> <category>initialize-release</category><body package="Store-UI" selector="listUpdateBlock:sendUpdatesFor:menuBar:popupMenu:windowTitle:">listUpdateBlock: aBlock sendUpdatesFor: aSymbolCollection menuBar: aMenuBar popupMenu: aPopupMenu windowTitle: aTitle	super listUpdateBlock: aBlock sendUpdatesFor: aSymbolCollection menuBar: aMenuBar popupMenu: aPopupMenu windowTitle: aTitle.	self pundleClientApp onSelectionChangeSend: #selectionChanged to: self</body><body package="Store-UI" selector="release">release	super release.	versionClientApp release</body></methods><methods><class-id>Store.PublishedPundlesTool</class-id> <category>actions</category><body package="Store-UI" selector="reloadVersions">reloadVersions	| sels |	sels := pundleClientApp selections.	super reloadVersions.	versionClientApp reloadVersions.	pundleClientApp selections: sels</body><body package="Store-UI" selector="republish">republish		| sels |	sels := pundleClientApp selections.	self pundles		do: [ :sel | RepublishBundleDialog republishBundle: sel ].	super reloadVersions.	versionClientApp reloadVersions.	pundleClientApp selections: sels</body></methods><methods><class-id>Store.PublishedPundlesTool</class-id> <category>accessing</category><body package="Store-UI" selector="versionClientApp">versionClientApp	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^versionClientApp isNil		ifTrue:			[versionClientApp := VersionBrowser new]		ifFalse:			[versionClientApp]</body></methods><methods><class-id>Store.PublishedPundlesTool</class-id> <category>pundle actions</category><body package="Store-UI" selector="updatePundleVersion">updatePundleVersion		versionClientApp updatePundleVersion</body></methods><methods><class-id>Store.PublishedPundlesTool class</class-id> <category>interface opening</category><body package="Store-UI" selector="openOnBundles:packages:">openOnBundles: bundleNames packages: packageNames 	self		openOnBundles: bundleNames		packages: packageNames		title: 'Published Items'</body><body package="Store-UI" selector="openOnBundles:packages:title:">openOnBundles: bundleNames packages: packageNames title: aTitle	| updateBlock |	updateBlock := 		[ | list |		list := bundleNames asSortedCollection collect: [ :bname | Bundle new name: bname ].		list addAll: ( packageNames asSortedCollection collect: [ :pname | Package new name: pname ] ).		list asList.		].	self		openOnBlock: updateBlock		sendUpdatesFor: #( )		menu: self publishedMenuBarSkeleton		popup: self publishedPopupSkeleton		windowTitle: aTitle</body><body package="Store-UI" selector="openOnPackages:">openOnPackages: packageNames	"self openOnPackages: #( 'Kernel-Classes' 'Interface-Models' )"	| updateBlock |	updateBlock := 		[ ( packageNames asSortedCollection collect: [ :pname | Package new name: pname] ) asList ].	self		openOnBlock: updateBlock		sendUpdatesFor: #( )		menu: self publishedMenuBarSkeleton		popup: self publishedPopupSkeleton		windowTitle: 'Published Items'</body></methods><methods><class-id>Store.UnloadableExeceptionBrowserApplication</class-id> <category>lists</category><body package="Store-UI-Browser" selector="allExceptions">allExceptions	^exceptionList</body></methods><methods><class-id>Store.UnloadableExeceptionBrowserApplication</class-id> <category>components</category><body package="Store-UI-Browser" selector="exceptionListComponent">exceptionListComponent	^SimpleBrowserModule new		helperType: UnloadableExeceptionBrowserHelper</body></methods><methods><class-id>Store.UnloadableExeceptionBrowserApplication</class-id> <category>updating</category><body package="Store-UI-Browser" selector="update:with:from:">update: anAspect with: aParameter from: aSender</body></methods><methods><class-id>Store.UnloadableExeceptionBrowserApplication</class-id> <category>initialization</category><body package="Store-UI-Browser" selector="browseExceptions:">browseExceptions: aCollection	exceptionList := aCollection.	components := List new		 add: self exceptionListComponent;		yourself.	self linkComponentsInArray: components.	components first setNewListSilently: aCollection.	self browser updateLists</body></methods><methods><class-id>Store.PundleHierarchyBrowserHelper</class-id> <category>list accessing</category><body package="Store-UI-Browser" selector="intializeListFull">intializeListFull	module list		newObjectHierarchy: Registry		isLeafSelector: #isLeaf		childAccessor: #anyContainedItems		childNameAccessor: #displayString		maintainSelection: true</body><body package="Store-UI-Browser" selector="updateListFull">updateListFull	module list rebuildIndentedList</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>private-visual blocks</category><body package="Store-UI" selector="computeLabelsForView:">computeLabelsForView: aView 	"Compute all the labels right away so that we know 	what offsets to use. Store the labels so that extra 	database accesses are not needed to recompute them."	| max1 max2 max3 |	max1 := max2 := max3 := 0.	labelDict := Dictionary new: self currentItems list size.	self currentItems list do: 		[ :anItem |  | publishFlag pndl label1 label2 label3 label4 level levelOffset |		publishFlag := anItem publish.		label1 := LabelAndIcon with: ''.		publishFlag ifTrue: [label1 beCheckMark].		levelOffset := 10.		level := levelOffset * (anItem level).		pndl := anItem pundle.		label2 := pndl elementLabel: #().		label2 text: pndl name asText.		label2 attributes: aView textStyle.		label3 := Label with: (publishFlag					ifTrue: [anItem version]					ifFalse: [anItem parentVersion]).		label3 attributes: aView textStyle.		label4 := Label with: (publishFlag					ifTrue: [Policies blessingPolicy blessingName: (anItem blessing)]					ifFalse: ['']).		label4 attributes: aView textStyle.		labelDict at: anItem put: 			( Array				with: label1				with: (Array with: label2 with: level)				with: label3				with: label4).		max1 := label1 width max: max1.		max2 := label2 width + level max: max2.		max3 := label3 width max: max3		].	offsets := Array				with: 6				with: max1 + 16				with: max2 + max1 + 26				with: max3 + max2 + max1 + 56.</body><body package="Store-UI" selector="labelForItem:view:">labelForItem: anItem view: aView 	| cp labels |	cp := CompositePart new.	( labelDict == nil or: [ ( labelDict at: anItem ifAbsent: nil ) == nil ] )		ifTrue: [ self computeLabelsForView: aView.].	labels := labelDict at: anItem.	cp add: (labels at: 1) at: (offsets at: 1) @ 0.	cp add: (labels at: 2) first at: ((offsets at: 2) + (labels at: 2) last) @ 0.	cp add: (labels at: 3) at: (offsets at: 3) @ 0.	cp add: (labels at: 4) at: (offsets at: 4) @ 0.	^cp</body><body package="Store-UI" selector="listVisualBlock">listVisualBlock	""	^	[:view :index | 	| arr label | 	arr := view sequence at: index.	label := self labelForItem: arr view: view.	BoundedWrapper on: label]</body><body package="Store-UI" selector="selectedListVisualBlock">selectedListVisualBlock	""	^	[:view :index | 	| arr label rw|	arr := view sequence at: index.	label := self labelForItem: arr view: view.	rw := ReversingWrapper on: label.	rw reverse setValue: true.	BoundedWrapper on: rw]</body><body package="Store-UI" selector="setVisualBlocks">setVisualBlocks	| itemList |	( itemList := self subComponentAt: #itemsList ) == nil		ifFalse:			[ itemList widget visualBlock: self listVisualBlock.			itemList widget selectedVisualBlock: self selectedListVisualBlock.			].	( itemList := self subComponentAt: #fileList ) == nil		ifFalse:			[ itemList widget visualBlock: self listVisualBlock.			itemList widget selectedVisualBlock: self selectedListVisualBlock.			].</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>actions</category><body package="Store-UI" selector="accept">accept	"publish...."	self validateParcelOptions		ifFalse: [ ^self ].	self validateFileOptions		ifFalse: [ ^self ].	self newGlobalState.	 [ self publishFromUserData ] 		on: DbRegistry errorSignals 		do: [ :exp | exp return ].	retry ifTrue: [ ^self ].	callBackBlock == nil		ifFalse: [ callBackBlock value: items list ].		^self closeAndUnschedule</body><body package="Store-UI" selector="allBlessings">allBlessings	"Use current blessinglevel/comment for all items."	self forAllItemsDo: 		[ :ar | 		ar blessing: self blessingLevel value.		ar comment: self blessingComment value		].	labelDict := nil.	self newSelection</body><body package="Store-UI" selector="allVersions">allVersions	"Mark all items for publishing."	self versionString value isEmpty		ifFalse: [ self setAllVersionsTo: versionString value ].	self newSelection</body><body package="Store-UI" selector="cancel">cancel	^self closeAndUnschedule</body><body package="Store-UI" selector="options">options	"This stub method was generated by UIDefiner"	^self</body><body package="Store-UI" selector="publishAllNo">publishAllNo	self forAllItemsDo: 		[ :ar | ar publish: ar modified  ].	labelDict := nil.	self newSelection</body><body package="Store-UI" selector="publishAllYes">publishAllYes	self forAllItemsDo: 		[ :ar | 		( ar modified )			ifFalse: [ ar publish: true ]		].	labelDict := nil.	self newSelection</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>aspects</category><body package="Store-UI" selector="binarySave">binarySave	binarySave == nil		ifTrue: [ binarySave := false asValue ].	^binarySave</body><body package="Store-UI" selector="blessingComment">blessingComment	blessingComment == nil		ifTrue: [ blessingComment := String new asValue ].	^blessingComment</body><body package="Store-UI" selector="blessingLevel">blessingLevel	blessingLevel == nil		ifTrue: [ blessingLevel := nil asValue ].	^blessingLevel</body><body package="Store-UI" selector="bundleStructure">bundleStructure	bundleStructure == nil		ifTrue: [ bundleStructure := false asValue ].	^bundleStructure</body><body package="Store-UI" selector="bundleStructureChanged">bundleStructureChanged	"Enable the database links depending on wheter the structure will be saved."	self enableComponentAt: #databaseLinks enable: self bundleStructure value.	self databaseLinks value: ( self databaseLinks value  &amp;  self bundleStructure value ).</body><body package="Store-UI" selector="databaseLinks">databaseLinks	databaseLinks == nil		ifTrue: [ databaseLinks := false asValue ].	^databaseLinks</body><body package="Store-UI" selector="files">files	files == nil		ifTrue: [ files := SelectionInList new list: PublishSpecificationList new ].	^files</body><body package="Store-UI" selector="globalOptions">globalOptions	^self items list first.</body><body package="Store-UI" selector="items">items	items == nil		ifTrue: [ items := SelectionInList new ].	^items</body><body package="Store-UI" selector="parcelBackup">parcelBackup	parcelBackup == nil		ifTrue: [ parcelBackup := false asValue ].	^parcelBackup</body><body package="Store-UI" selector="parcelDetails">parcelDetails	^#( parcelDirectory 		parcelOverwrite 		parcelRepublish		parcelSaveSource 		parcelBackup		), self parcelSaveSourceDetails</body><body package="Store-UI" selector="parcelDirectory">parcelDirectory	| name |	parcelDirectory ==  nil		ifTrue: 			[ parcelDirectory := UISettings preferenceFor: #packageDir.			( parcelDirectory == nil or: [ parcelDirectory isEmpty ] )				ifTrue: [ parcelDirectory := Filename currentDirectory ].			name := self pundle parcelName.			parcelDirectory := ( parcelDirectory asFilename construct: name ) asString asValue.			 ].	^parcelDirectory</body><body package="Store-UI" selector="parcelHideSource">parcelHideSource	parcelHideSource == nil		ifTrue: [ parcelHideSource := false asValue ].	^parcelHideSource</body><body package="Store-UI" selector="parcelOverwrite">parcelOverwrite	parcelOverwrite == nil		ifTrue: [ parcelOverwrite := false asValue ].	^parcelOverwrite</body><body package="Store-UI" selector="parcelPadded">parcelPadded	parcelPadded == nil		ifTrue: [ parcelPadded := true asValue ].	^parcelPadded</body><body package="Store-UI" selector="parcelRepublish">parcelRepublish	parcelRepublish == nil		ifTrue: [ parcelRepublish := false asValue ].	^parcelRepublish</body><body package="Store-UI" selector="parcelSave">parcelSave	parcelSave == nil		ifTrue: [ parcelSave := false asValue ].	^parcelSave</body><body package="Store-UI" selector="parcelSaveChanged">parcelSaveChanged	"Enable the parcel directory depending on wheter parcel will be published."	| save |	save := self parcelSave value.	self parcelDetails do:		[ :sym | self enableComponentAt: sym enable: save ].	self enableComponentAt: #bundleStructure enable: save &amp; self pundle isBundle.	self bundleStructure value: ( parcelSave value  &amp;  bundleStructure value ).	self bundleStructureChanged.	self parcelSaveSourceChanged.	save &amp; self pundle isBundle		ifTrue: 			[ ( self pundle allContainedItems contains: 				[ :p | p properties keys contains: [ :k | CodeComponent binaryActions includes: k ] ]			  ) ifTrue: [ Dialog warn: 'Sub-components have actions that won''t be executed during parcel load.' ].			].</body><body package="Store-UI" selector="parcelSaveSource">parcelSaveSource	parcelSaveSource == nil		ifTrue: [ parcelSaveSource := true asValue ].	^parcelSaveSource</body><body package="Store-UI" selector="parcelSaveSourceChanged">parcelSaveSourceChanged	"Enable/disable the subcheck boxes depending on sources."	| save |	save := self parcelSaveSource value &amp;  ( self parcelSave value ).	self parcelSaveSourceDetails do:		[ :sym | self enableComponentAt: sym enable: save ].	self parcelRepublish value: ( self parcelRepublish value &amp; save ).	self enableComponentAt: #parcelRepublish enable: save.</body><body package="Store-UI" selector="parcelSaveSourceDetails">parcelSaveSourceDetails	^#( parcelHideSource 		parcelPadded 		)</body><body package="Store-UI" selector="parcelWarningMessage">parcelWarningMessage	parcelWarningMessage == nil		ifTrue: [ parcelWarningMessage := self validateParcelSaveString ].	^parcelWarningMessage</body><body package="Store-UI" selector="publish">publish	publish == nil		ifTrue: 			[ 			publish := false asValue.			self disableDetails.			].	^publish</body><body package="Store-UI" selector="publishFile">publishFile	publishFile == nil		ifTrue: [ publishFile := false asValue ].	^publishFile</body><body package="Store-UI" selector="versionString">versionString	versionString == nil		ifTrue: [ versionString := String new asValue ].	^versionString</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>private</category><body package="Store-UI" selector="detailHolders">detailHolders	| coll |	coll := OrderedCollection new.	coll add: self publish.	coll add: self blessingLevel.	coll add: self blessingComment.	coll add: self versionString.	^coll</body><body package="Store-UI" selector="details">details	"Answer a list of ids for individual pundle settings."	^#( blessingLevelButton blessingComment vStringLabel 		bCommentLabel versionStringBox )</body><body package="Store-UI" selector="disableDetails">disableDetails	| comp |	self details do: 		[ :sym | 		( comp := self subComponentAt: sym ) == nil 			ifFalse: [ comp disable ]		]</body><body package="Store-UI" selector="disablePublishBox">disablePublishBox	self enableComponentAt: #publishYes enable: false.	self enableComponentAt: #publishNo enable: false.</body><body package="Store-UI" selector="enableDetails">enableDetails	self currentItems selection notNil		ifTrue: 			[ ( self currentItems selection modified )				ifTrue: [ self disablePublishBox ]				ifFalse: [ self enablePublishBox ].			self publish value 				ifTrue: 					[ self details do: 						[:sym | self enableComponentAt: sym enable: true ] 					]			]</body><body package="Store-UI" selector="enablePublishBox">enablePublishBox	self enableComponentAt: #publishYes enable: true.	self enableComponentAt: #publishNo enable: true.</body><body package="Store-UI" selector="forAllItemsDo:">forAllItemsDo: aBlock	| alist |	alist := self currentItems list.	1 to: alist size do: 		[ :i | | ar |		ar := alist at: i.		aBlock value: ar.		alist at: i put: ar		]</body><body package="Store-UI" selector="newDetailState">newDetailState	| sel duplicates |	sel := self currentItems selection.	duplicates := self currentItems list select: 		[ :each | ( each pundle ) == ( sel pundle ) ].	duplicates do:		[ :each | | index sub |		each publish: self publish value.		each blessing: self blessingLevel value.		each comment: self blessingComment value.		each version: self versionString value.		index := self currentItems list indexOf: each.		( sub := self subComponentAt: #itemsList ) == nil			ifFalse: [ sub widget updateAt: index ].		( sub := self subComponentAt: #fileList ) == nil			ifFalse: [ sub widget updateAt: index ].		].	labelDict := nil.</body><body package="Store-UI" selector="newGlobalState">newGlobalState		"Update the global (belonging to the outer bundle) state."	^self globalOptions		binarySave: self binarySave value;		parcelSave: self parcelSave value;		databaseLinks: self databaseLinks value;		bundleStructure: self bundleStructure value;		parcelDirectory: self parcelDirectory value;		parcelRepublish: self parcelRepublish value;		parcelBackup: self parcelBackup value;		parcelOverwrite: self parcelOverwrite value;		parcelSaveSource: self parcelSaveSource value;		parcelHideSource: self parcelHideSource value;		parcelPadded: self parcelPadded value;		yourself.</body><body package="Store-UI" selector="newPublishState">newPublishState	"Publish selected. If an pundle is marked for publish, mark containing bundles as well."	self publish value		ifFalse: [ ^self ].	self publishState: self currentItems selection pundle.</body><body package="Store-UI" selector="newSelection">newSelection	| sel |	sel := self currentItems selection.	sel == nil		ifFalse:  			[ self setDetailState.			self enableDetails			]		ifTrue: 			[ self disableDetails.			self disablePublishBox			]</body><body package="Store-UI" selector="publishState:">publishState: aPundle	"aPundle has been marked for publication. Mark all bundles containing it as well."	self forAllItemsDo:		[ : each | | pundle |		pundle := each pundle.		 pundle isLoaded ifFalse: [ ^self ].	"doesnt appy if in db"		( ( pundle := each pundle ) isBundle				and: [ pundle containsItem: aPundle ] )					ifTrue: 				[ each publish: self publish value.				self publishState: pundle.				]		].</body><body package="Store-UI" selector="retractDetailInterest">retractDetailInterest	self publish retractInterestsFor: self.	self detailHolders do: 		[ :dh | dh retractInterestsFor: self ].</body><body package="Store-UI" selector="setAllVersionsTo:">setAllVersionsTo: aString	self forAllItemsDo: [ :ar | ar version: aString ].	labelDict := nil.</body><body package="Store-UI" selector="setDetailInterest">setDetailInterest	self publish onChangeSend: #newPublishState to: self.	self detailHolders do: [:dh| dh onChangeSend: #newDetailState to: self].</body><body package="Store-UI" selector="setDetailState">setDetailState	| sel |	sel := self currentItems selection.	self retractDetailInterest. 	self publish value: sel publish.	self blessingLevel value: sel blessing.	self blessingComment value: sel comment.	self versionString value: sel version.	self setDetailInterest</body><body package="Store-UI" selector="setDetailState:">setDetailState: selection	self retractDetailInterest. 	self publish value: selection publish.	self blessingLevel value: selection blessing.	self blessingComment value: selection comment.	self versionString value: selection version.	self setDetailInterest</body><body package="Store-UI" selector="updateFilePreferences">updateFilePreferences	| indx |	indx := self files selectionIndex.	( self subComponentAt: #filesList ) widget updateAt: indx</body><body package="Store-UI" selector="updateItemList">updateItemList	( self subComponentAt: #itemsList ) widget updateModel.	labelDict := nil.</body><body package="Store-UI" selector="updateSelectedItem">updateSelectedItem	| indx |	indx := self currentItems selectionIndex.	( self subComponentAt: #itemsList ) widget updateAt: indx</body><body package="Store-UI" selector="validateFileOptions">validateFileOptions	| msg1 msg2 |	msg1 := #File1sDoesNotExist &lt;&lt; #store &gt;&gt; 'File: &lt;1s&gt; does not exist.'.	msg2 :=  #File1snDoesNotExistInDB &lt;&lt; #store &gt;&gt; 'File: &lt;1s&gt;&lt;n&gt; does not exist in the database and is not being published.'.	self fileList do:		[ :fspec | 		fspec publish 			ifTrue: 				[ ( fspec file portableFilename exists )					ifFalse: 						[ Dialog warn: ( msg1 expandMacrosWith: fspec file name ).					^false 					]				] 			ifFalse: 				[ ( fspec file dbTrace isNil )					ifTrue: 						[ Dialog warn:  ( msg2  expandMacrosWith: fspec file name ).						^false						]				].		].	^true</body><body package="Store-UI" selector="validateParcelOptions">validateParcelOptions	| filename |	self parcelSave value ifFalse: [ ^true ].	( ( filename := self basePath , Parcel fileExtension ) asFilename exists				and: [ self parcelOverwrite value not ] )		ifTrue: 			[ ( Dialog confirm: ( '&lt;n&gt;&lt;1s&gt; exists: &lt;n&gt;&lt;n&gt;Overwrite files?&lt;n&gt;' expandMacrosWith: filename ) ) 				ifTrue: [ self parcelOverwrite value: true ]				ifFalse: [ ^false ].			].	^true</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>interface opening</category><body package="Store-UI" selector="buildInSubCanvas:withBuilder:">buildInSubCanvas: spec withBuilder: aBuilder 	"Reimplement to ensure that visualBlocks are set up on the subcanvas if was installed."	super buildInSubCanvas: spec withBuilder: aBuilder.	"subBuilder will not be nil if we are building a page on the notebook."	subBuilder isNil ifFalse: 		[self setVisualBlocks].	^aBuilder</body><body package="Store-UI" selector="localPostOpenWith:">localPostOpenWith: aBuilder	self items selectionIndexHolder onChangeSend: #newSelection to: self.	self files selectionIndexHolder onChangeSend: #newSelection to: self.	self setVisualBlocks.	self items selectionIndex: 1.	self parcelSaveChanged.	self setGlobalEnablement.</body><body package="Store-UI" selector="localRebuild">localRebuild		self setVisualBlocks.	self setGlobalEnablement.	self parcelSaveChanged.	self newSelection</body><body package="Store-UI" selector="openWith:">openWith: userData	self items list: userData.	labelDict := nil.	self open</body><body package="Store-UI" selector="openWith:ifSucessfulDo:">openWith: userData ifSucessfulDo: aOneArgumentBlock	callBackBlock := aOneArgumentBlock.		self openWith: userData.</body><body package="Store-UI" selector="openWith:with:">openWith: userData with: fileData	( ( fileData notEmpty ) &amp; ( DbRegistry isDb73Enabled not ) )		ifTrue: [ Dialog warn: 'Your database does not support external files.&lt;n&gt;Publishing will cause your image to forget attatched external files.' expandMacros ].	self items list: userData.	self files list: fileData.	labelDict := nil.	self open</body><body package="Store-UI" selector="postOpenWith:">postOpenWith: aBuilder 	"This message is sent by the builder after it has opened a completed window."	super postOpenWith: aBuilder.	self localPostOpenWith: aBuilder.</body><body package="Store-UI" selector="preBuildWith:">preBuildWith: aBuilder 	"This message is sent by the builder prior to beginning construction 	of either a SubCanvas or a complete window."	aBuilder 		aspectAt: #blessingLevelMenu 		put: Policies blessingPolicy blessingLevelsMenu.</body><body package="Store-UI" selector="rebuild">rebuild		super rebuild.	self localRebuild.</body><body package="Store-UI" selector="requestSliceChange">requestSliceChange	^true</body><body package="Store-UI" selector="resetForSlice">resetForSlice</body><body package="Store-UI" selector="setGlobalEnablement">setGlobalEnablement	| valid |	valid := self validateParcelSaveString isEmpty.	self enableComponentAt: #parcelSave enable: valid.	self enableComponentAt: #binarySave enable: valid.</body><body package="Store-UI" selector="windowLabel">windowLabel	^'Publishing &lt;1?package:bundle&gt;: &lt;2s&gt;' 		expandMacrosWith: self pundle isPackage 		with: self pundle name</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>resources</category><body package="Store-UI" selector="fieldMenu">fieldMenu	^MenuBuilder new		add: 'find...'-&gt;[:ctrlr | ctrlr find];		add: 'replace...'-&gt;			[:ctrlr |			ctrlr replace.			self disturb];		line;		add: 'undo' -&gt;			[:ctrlr |			ctrlr undo.			self disturb];		line;		add: 'copy'-&gt;[:ctrlr | ctrlr copySelection];		add: 'cut'-&gt;			[:ctrlr |			ctrlr cut.			self disturb];		add: 'paste'-&gt;			[:ctrlr |			ctrlr paste.			self disturb];		line;		menu</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>subcomponents</category><body package="Store-UI" selector="enableComponentAt:enable:">enableComponentAt: aSymbol enable: aBoolean	| comp |	( comp := subBuilder componentAt: aSymbol ) == nil		ifFalse: [ comp isEnabled: aBoolean ]</body><body package="Store-UI" selector="subComponentAt:">subComponentAt: aSymbol	^subBuilder componentAt: aSymbol</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>private-publishing</category><body package="Store-UI" selector="publishFromUserData">publishFromUserData	"Publish pundles contained in the user data list."	self specList canPublish			ifFalse: [ retry := true. ^self ].	self fileList publishFiles.		"??"	self specList publishPundle		ifFalse: [ ^self ].	retry := false.</body><body package="Store-UI" selector="validateParcelSaveString">validateParcelSaveString	"Check wheter save as parcel should be enabled. Answer the message if not, an empty string if okay"	| existing |	( existing := self pundle relatedParcel ) == nil		ifFalse: 			[ existing hasUninstalledCode 				ifTrue: [ ^' *** Parcel has uninstalled code ***' 	]			].	self pundle hasCodeOverridden 		ifTrue: [ ^'*** &lt;1s&gt; has overridden code ***' expandMacrosWith: self pundle name ].	^String new</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>binding</category><body package="Store-UI" selector="labelFor:">labelFor: aKey 	"Return an instance of a non-abstract subclass of CharacterArray, 	that will be used as a label for a component."	^[ self perform: aKey ] on: MessageNotUnderstood do:		[ : e | e return: aKey ].</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>help</category><body package="Store-UI" selector="fileHelp">fileHelp^#fileHelp &lt;&lt; #store &gt;&gt;'Select Publish All to publish all of the files listed.Select Publish None to reset the default, which does not publish any files.Publish and Do not Publish allow you to change the setting to the currently selected file.'</body><body package="Store-UI" selector="mainHelp">mainHelp^'The Blessing Level and Blessing Comment can be set individually for each component. It will apply to the selected item. Set Current Blessing Level and Comment for All, sets the same level and comment for all published items.Publish Binary - saves the packages in the database in parcel formal. This is good for faster initial loading and for cases where the individual packages may not compile cleanly. If this option is diabled, it means that the parcel is invalid. See the Parcel Options tab for details.'</body><body package="Store-UI" selector="parcelHelp">parcelHelp	^self class parcelHelp</body><body package="Store-UI" selector="publishHelp">publishHelp^'All modified components will be published. Select Publish All to publish all unmodified components.Select Publish Only Modified to reset the default, which does not publish any unmodified components.Publish and Do not Publish allow you to change the setting to the currently selected unmodfied component.'</body><body package="Store-UI" selector="versionHelp">versionHelp^'Change the version string for the selected component, or Set the Global Version for all the components.'</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>accessing</category><body package="Store-UI" selector="basePath">basePath	"Return the base path of the filename for the parcel to be saved."		^( Filename expandEnvironmentIn: ( self parcelDirectory value ) ) asString</body><body package="Store-UI" selector="currentItems">currentItems	^self isPaneForFiles		ifTrue: [ self files ]		ifFalse: [ self items ].</body><body package="Store-UI" selector="fileList">fileList	^self files list</body><body package="Store-UI" selector="pundle">pundle	^items list first pundle</body><body package="Store-UI" selector="specList">specList	^items list</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>initialize-release</category><body package="Store-UI" selector="initialize">initialize	super initialize.	retry := false.</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>testing</category><body package="Store-UI" selector="isPaneForFiles">isPaneForFiles	^( subBuilder componentAt: #fileList ) ~~ nil</body></methods><methods><class-id>Store.PublishPundleDialog class</class-id> <category>private</category><body package="Store-UI" selector="publishFileSpecsFrom:">publishFileSpecsFrom: anImageBundle  	^PublishSpecificationList filesFromBundle: anImageBundle</body><body package="Store-UI" selector="publishSpecsFrom:">publishSpecsFrom: anImageBundle  	^PublishSpecificationList fromBundle: anImageBundle</body><body package="Store-UI" selector="publishSpecsFromPackages:comments:defaultBlessing:mergeData:">publishSpecsFromPackages: aCollectionOfPackages comments: aCollectionOfComments defaultBlessing: aBlessingLevel mergeData: mergeData 	| coll |	coll := PublishSpecificationList new: aCollectionOfPackages size.	1 to: aCollectionOfPackages size do: 		[:index | | spec |			spec := PublishSpecification pundle: ( aCollectionOfPackages at: index ).			Policies mergePolicy shouldPublishAll 				ifTrue: [ spec publish: true].			spec blessing: aBlessingLevel.			spec mergeData: mergeData.			spec comment: (aCollectionOfComments at: index).			coll add: spec		].	^coll</body><body package="Store-UI" selector="userData:forPundle:">userData: anUserData forPundle: aPundle 	"Set the common items in the user data."	| mod vString pvString |	 mod := aPundle hasBeenModified or: [ aPundle hasTrace not ].	pvString := aPundle parentVersionString.	vString := pvString isEmpty			ifTrue: [ Policies versionPolicy initialVersionForPundle: aPundle ]			ifFalse: [ Policies versionPolicy nextVersion: pvString forPundle: aPundle ].	anUserData 		at: #publish put: mod;		at: #pundle put: aPundle;		at: #comment put: '';		at: #parentVersion put: pvString;		at: #version put: vString;		at: #level put: 0;		at: #modified put: mod;		at: #description put: nil;		at: #blessing put: Policies blessingPolicy defaultBlessing.</body><body package="Store-UI" selector="userDataFrom:">userDataFrom: anImageBundle  	| dict coll |	dict := Dictionary new.	self userData: dict forPundle: anImageBundle.	dict 		at: #publish put: true;		at: #modified put: true;		at: #binarySave put: false;		at: #parcelSave put: false;		at: #bundleStructure put: false;		at: #databaseLinks put: false;		at: #parcelDirectory put: '';		at: #parcelRepublish put: false;		at: #parcelBackup put: false;		at: #parcelOverwrite put: false;		at: #parcelSaveSource put: true;		at: #parcelHideSource put: false;		at: #parcelPadded put: true.	coll := List with: dict.	anImageBundle descriptionsAndLevels do: 		[ :pair | 	| pndl descr |		descr := pair at: 1.		pndl := descr component.		dict := Dictionary new.		self userData: dict forPundle: pndl.		dict at: #description put: descr.		dict at: #level put: ( pair at: 2 ).		coll add: dict		].	^coll</body><body package="Store-UI" selector="userDataFromPackages:comments:defaultBlessing:mergeData:">userDataFromPackages: aCollectionOfPackages comments: aCollectionOfComments defaultBlessing: aBlessingLevel mergeData: mergeData 	| coll |	coll := List new: aCollectionOfPackages size.	1 to: aCollectionOfPackages size		do: 			[:index | 			| dict |			dict := Dictionary new.			self userData: dict forPundle: (aCollectionOfPackages at: index).			Policies mergePolicy shouldPublishAll ifTrue: [dict at: #publish put: true].			dict at: #blessing put: aBlessingLevel.			dict at: #mergeData put: mergeData.			dict at: #comment put: (aCollectionOfComments at: index).			coll add: dict].	^coll</body><body package="Store-UI" selector="userDataFromPackages:comments:defaultBlessing:versions:mergeData:">userDataFromPackages: aCollectionOfPackages comments: aCollectionOfComments defaultBlessing: aBlessingLevel versions: aCollectionOfVersions mergeData: mergeData 	| coll |	coll := List new: aCollectionOfPackages size.	1 to: aCollectionOfPackages size do: 		[:index | | spec |			spec := PublishSpecification pundle: ( aCollectionOfPackages at: index ).			Policies mergePolicy shouldPublishAll 				ifTrue: [ spec publish: true].			spec blessing: aBlessingLevel.			spec mergeData: mergeData.			spec comment: ( aCollectionOfComments at: index ).			spec version:  ( aCollectionOfVersions at: index )		].	^coll</body><body package="Store-UI" selector="validateForPublishing:">validateForPublishing: pundles	pundles do:		[ :p | p canBePublishedToCurrentDatabase				ifFalse: 					[ | msg |					msg := '&lt;1s&gt; cannot be published to the current database,&lt;n&gt;because it is not linked to the existing versions with the same name.' 								expandMacrosWith: p name.					Dialog warn: msg.					^false					]		].	^true</body><body package="Store-UI" selector="windowLabel">windowLabel	^'Store Publish Dialog'</body></methods><methods><class-id>Store.PublishPundleDialog class</class-id> <category>class initialization</category><body package="Store-UI" selector="initialize">initialize	"self initialize "	developmentSpecList := 		OrderedCollection new			add: 'Main'-&gt;#(#mainSpec #mainHelp);			add: 'Versions'-&gt;#(#versionSpec #versionHelp);			add: 'Publishing Options'-&gt;#(#publishSpec #publishHelp);			add: 'Parcel Options'-&gt;#(#parcelSpec #parcelHelp);			add: 'File Options'-&gt;#(#filesSpec #fileHelp);			asArray.	runtimeSpecList := Array new: 1.</body></methods><methods><class-id>Store.PublishPundleDialog class</class-id> <category>interface opening</category><body package="Store-UI" selector="publishBundle:">publishBundle: anImageBundle 	"Present a dialog and let user set parameters for the 	new published bundle and its components."	|  coll files |	( self validateForPublishing: ( anImageBundle containedItems addFirst: anImageBundle; yourself ) )		ifFalse: [ ^self ].	coll := self publishSpecsFrom: anImageBundle.	files := self publishFileSpecsFrom: anImageBundle.	self new openWith: coll with: files.</body><body package="Store-UI" selector="publishPackages:comments:defaultBlessing:mergeData:">publishPackages: aCollectionOfPackages comments: aCollectionOfComments defaultBlessing: aDefaultBlessingLevel mergeData: mergeData 	"Present a dialog and let user set parameters for the 	new published bundle and its components."	| coll |	coll := self			publishSpecsFromPackages: aCollectionOfPackages			comments: aCollectionOfComments			defaultBlessing: aDefaultBlessingLevel			mergeData: mergeData.	self new openWith: coll.	^coll</body><body package="Store-UI" selector="publishPackages:comments:defaultBlessing:mergeData:ifSuccessfulDo:">publishPackages: aCollectionOfPackages comments: aCollectionOfComments defaultBlessing: aDefaultBlessingLevel mergeData: mergeData ifSuccessfulDo: aOneArgumentBlock 	"Open a publish dialog on aCollectionOfPackages. If everything is okay, exececute a block 	with the list of user data for each package. " 	| coll |	coll := self			publishSpecsFromPackages: aCollectionOfPackages			comments: aCollectionOfComments			defaultBlessing: aDefaultBlessingLevel			mergeData: mergeData.	self new openWith: coll ifSucessfulDo: aOneArgumentBlock.	^coll</body></methods><methods><class-id>Store.PublishPundleDialog class</class-id> <category>help</category><body package="Store-UI" selector="parcelHelp">parcelHelp	^'The parcel will be saved in the Parcel Path + .pcl, the sources in Parcel Path +.pst.Include Bundle Structure if you would like the bundle to be recreated when loading the parcel into a Store image.  Saving Database Links will hook the components to a particular database. This saves the loader from needing to reconcile source before publishing a new version to the same database.Save source file will create the parcel sources (.pst) file.Hide sources on load will not effect the current image, but will supress sources when it is loaded into a another image. This is for deployment parcels and should not be used during development.Select republish to save with sources to a parcel that is currently loaded to the same file name.  Republishing does not hide sources. Republishing will invalidate other images that point to the original file.'</body></methods><methods><class-id>Store.PublishFragmentDialog</class-id> <category>private-publishing</category><body package="Store-UI" selector="publishFromUserData">publishFromUserData	"Publish pundles contained in the user data list."	self specList canPublish		ifFalse: [ ^false ].	^self specList publishFragments.</body><body package="Store-UI" selector="validateParcelSaveString">validateParcelSaveString	"Check wheter save as parcel should be enabled. 	Answer the message if not, an empty string if okay"	^'Framents cannot be published as a parcel.'</body></methods><methods><class-id>Store.PublishFragmentDialog</class-id> <category>help</category><body package="Store-UI" selector="mainHelp">mainHelp^'The Blessing Level and Blessing Comment can be set individually for each component. It will apply to the selected item. Set Current Blessing Level and Comment for All, sets the same level and comment for all published items.Fragements cannot be publish as parcels or as binary.'</body></methods><methods><class-id>Store.PublishFragmentDialog class</class-id> <category>private</category><body package="Store-UI" selector="publishSpecsFromPackages:comments:defaultBlessing:versions:mergeData:">publishSpecsFromPackages: aCollectionOfPackages comments: aCollectionOfComments defaultBlessing: aBlessingLevel versions: aCollectionOfVersions mergeData: mergeData 	| coll |	coll := PublishSpecificationList new: aCollectionOfPackages size.	1 to: aCollectionOfPackages size do: 		[ :index | | spec |			spec := PublishFragmentSpecification pundle: ( aCollectionOfPackages at: index ).			Policies mergePolicy shouldPublishAll 				ifTrue: [ spec publish: true].			spec blessing: aBlessingLevel.			spec mergeData: mergeData.			spec comment: ( aCollectionOfComments at: index ).			spec version:  ( aCollectionOfVersions at: index ).			coll add: spec.		].	^coll</body><body package="Store-UI" selector="validateFragment:">validateFragment: aPundle	"Verify that it is possible to publish the pundles in aCollection as a fragment."	| msg |	aPundle dbTrace == nil		ifTrue: [ msg := '&lt;1s&gt;  needs to be published before it can be fragmented.&lt;n&gt;' ].	msg == nil  &amp;  aPundle isBundle 		ifTrue: 			[ ( aPundle contents contains: [ :p | p dbTrace == nil ] )				ifTrue: [ msg := 'All components of &lt;1s&gt; need to be published before it can be fragmented.&lt;n&gt;' ].			].	msg == nil		ifFalse: [ Dialog warn: ( msg expandMacrosWith: aPundle name ) ].	^msg == nil</body><body package="Store-UI" selector="validateFragments:">validateFragments: aPundleCollection	"Verify that it is possible to publish the pundles in aCollection as a fragment."	aPundleCollection do:		[ :pun |		( self validateFragment: pun )			ifFalse: [ ^false ].		].	^true.</body><body package="Store-UI" selector="windowLabel">windowLabel	^'Publish Fragments Dialog'</body></methods><methods><class-id>Store.PublishFragmentDialog class</class-id> <category>interface opening</category><body package="Store-UI" selector="publishFragments:comments:defaultBlessing:versions:">publishFragments: aCollectionOfPackages comments: aCollectionOfComments defaultBlessing: aDefaultBlessingLevel versions: aCollectionOfVersions	"Present a dialog and let user set parameters for the fragments to be published."	| specList |	specList := self			publishSpecsFromPackages: aCollectionOfPackages			comments: aCollectionOfComments			defaultBlessing: aDefaultBlessingLevel			versions:aCollectionOfVersions			mergeData: nil.	specList canPublish		ifFalse: [ ^self ].	self new openWith: specList.</body></methods><methods><class-id>Store.PublishFragmentDialog class</class-id> <category>class initialization</category><body package="Store-UI" selector="initialize">initialize	"self initialize "	developmentSpecList := 		OrderedCollection new			add: 'Main'-&gt;#(#mainSpec #mainHelp);			add: 'Versions'-&gt;#(#versionSpec #versionHelp);			asArray.	runtimeSpecList := Array new: 1.</body></methods><methods><class-id>Store.PublishPackageDialog</class-id> <category>aspects</category><body package="Store-UI" selector="blessingLevel">blessingLevel	blessingLevel == nil		ifTrue: [ blessingLevel := Policies blessingPolicy defaultBlessing asValue ].	^blessingLevel</body><body package="Store-UI" selector="versionString">versionString	versionString == nil		ifTrue: 			[ versionString :=  				( Policies versionPolicy 					nextVersion: package parentVersionString 					forPundle: package				) asValue 			].	^versionString</body></methods><methods><class-id>Store.PublishPackageDialog</class-id> <category>accessing</category><body package="Store-UI" selector="options">options	^self newGlobalState</body><body package="Store-UI" selector="package">package	^package</body><body package="Store-UI" selector="package:">package: aPackage	package := aPackage.</body><body package="Store-UI" selector="pundle">pundle	^package</body></methods><methods><class-id>Store.PublishPackageDialog</class-id> <category>private</category><body package="Store-UI" selector="newGlobalState">newGlobalState		"Update the global (belonging to the outer bundle) state."	^PublishSpecification new		binarySave: self binarySave value;		parcelSave: self parcelSave value;		databaseLinks: self databaseLinks value;		bundleStructure: self bundleStructure value;		parcelDirectory: self parcelDirectory value;		parcelRepublish: self parcelRepublish value;		parcelBackup: self parcelBackup value;		parcelOverwrite: self parcelOverwrite value;		parcelSaveSource: self parcelSaveSource value;		parcelHideSource: self parcelHideSource value;		parcelPadded: self parcelPadded value;		yourself.</body><body package="Store-UI" selector="newSelection">newSelection	"no such thing"</body></methods><methods><class-id>Store.PublishPackageDialog</class-id> <category>actions</category><body package="Store-UI" selector="accept">accept	"publish...."	| res |	self validateParcelOptions		ifFalse: [ ^self ].	self closeAndUnschedule.	res := Package publishPackage: self package userData: self.	res == nil  |  ( callBackBlock == nil )		ifFalse: [ callBackBlock value: items list ].</body></methods><methods><class-id>Store.PublishPackageDialog class</class-id> <category>interface opening</category><body package="Store-UI" selector="publishPackage:">publishPackage: aPackage	( self validateForPublishing: ( PublishSpecificationList with: aPackage ) )		ifFalse: [ ^self ].	^self new		package: aPackage;		open;		yourself</body></methods><methods><class-id>Store.PublishPackageDialog class</class-id> <category>class initialization</category><body package="Store-UI" selector="initialize">initialize	"self initialize "	developmentSpecList := 		OrderedCollection new			add: 'Main'-&gt;#(#mainSpec #mainHelp);			add: 'Parcel Options'-&gt;#(#parcelSpec #parcelHelp);			asArray.	runtimeSpecList := Array new: 1.</body></methods><methods><class-id>Store.BlessingDialog</class-id> <category>actions</category><body package="Store-UI" selector="accept">accept	"set new blessings and comments...."	self newGlobalState.	self specList publishBlessing.	dialog accept; closeRequest</body><body package="Store-UI" selector="cancel">cancel	dialog doCancel</body><body package="Store-UI" selector="publishAllYes">publishAllYes	self forAllItemsDo: 		[ :ar | ar publish: true ].	labelDict := nil.	self newSelection</body><body package="Store-UI" selector="resetBundleOnly">resetBundleOnly	self forAllItemsDo: 		[ :ar | ar publish: false ].	items list first publish: true.		labelDict := nil.	self newSelection</body></methods><methods><class-id>Store.BlessingDialog</class-id> <category>interface opening</category><body package="Store-UI" selector="localPostOpenWith:">localPostOpenWith: aBuilder	self items selectionIndexHolder onChangeSend: #newSelection to: self.	self setVisualBlocks.	self items selectionIndex: 1.</body><body package="Store-UI" selector="localRebuild">localRebuild		self setVisualBlocks.</body><body package="Store-UI" selector="userData:">userData: userData	self items list: userData.	labelDict := nil.</body><body package="Store-UI" selector="windowLabel">windowLabel	^'Resetting Blessing Levels and Comments'</body></methods><methods><class-id>Store.BlessingDialog</class-id> <category>help</category><body package="Store-UI" selector="mainHelp">mainHelp^'The Blessing Level and Blessing Comment can be set individually for each component. It will apply to the selected item. Set Current Blessing Level and Comment for All, sets the same level and comment for all published items.'</body><body package="Store-UI" selector="publishHelp">publishHelp^'The default is to reset the blessing level/comment for all modified subcomponents.Select Reset All to publish all components.Select Reset Only Modified to reset the default, which does not reset any unmodified components.Select Reset Bundle Only to reset only the topmost bundle.Reset and Do not Reset allow you to change the setting of the currently selected component.'</body></methods><methods><class-id>Store.BlessingDialog</class-id> <category>private</category><body package="Store-UI" selector="enableDetails">enableDetails	"The opposite of the publish dialog -- only modified guys can be changed."	self enablePublishBox.	self items selection notNil		ifTrue: 			[ self publish value				ifTrue: 					[ self details do: 						[:sym | self enableComponentAt: sym enable: true ] 					]			]</body><body package="Store-UI" selector="open">open	self openDialogInterface: #windowSpec</body><body package="Store-UI" selector="openDialogInterface:">openDialogInterface: aSymbol 		dialog := SimpleDialog new.	builder := dialog builder.	dialog postOpenBlock: [:dlg :bld |		self postOpenWith: bld].	dialog openFor: self interface: aSymbol</body></methods><methods><class-id>Store.BlessingDialog class</class-id> <category>interface opening</category><body package="Store-UI" selector="setBlessingFor:">setBlessingFor: aPundle	aPundle isBundle 			ifTrue: [ self setBlessingForBundle: aPundle ]		ifFalse: [ self setBlessingForPackage: aPundle ].</body><body package="Store-UI" selector="setBlessingForBundle:">setBlessingForBundle: aBundle	"self setBlessingForBundle: ( Registry packageNamed: 'Store-Base' ) parentRecord."	|  coll files |	( self validateForPublishing: ( aBundle containedItems addFirst: aBundle; yourself ) )		ifFalse: [ ^self ].	coll := self publishSpecsFrom: aBundle."	files := DbRegistry isDb73Enabled		ifTrue: [ self publishFileSpecsFrom: aBundle ]		ifFalse: [ PublishSpecificationList new ]."	files := self publishFileSpecsFrom: aBundle.	self new openWith: coll with: files.</body><body package="Store-UI" selector="setBlessingForPackage:">setBlessingForPackage: aPackage	"Redirect to existing dialog for a single package."		"self setBlessingForBundle: ( Registry packageNamed: 'Store-Base' ) parentRecord."	| dialog |	dialog := CommentPrompt forPundle: aPackage.	dialog blessingLevel value: aPackage blessingLevel.	dialog open.	dialog accept value 		ifTrue: 			[ Blessing 					forPundle: aPackage 					withLevel: dialog blessingLevel value 					andComment: dialog text value			]</body></methods><methods><class-id>Store.BlessingDialog class</class-id> <category>class initialization</category><body package="Store-UI" selector="initialize">initialize	"self initialize "	developmentSpecList := 		OrderedCollection new			add: 'Main'-&gt;#(#mainSpec #mainHelp);			add: 'Reset Options'-&gt;#(#publishSpec #publishHelp);			asArray.	runtimeSpecList := Array new: 1.</body></methods><methods><class-id>Store.BlessingDialog class</class-id> <category>private</category><body package="Store-UI" selector="publishSpecsFrom:">publishSpecsFrom: aBundle  	 ^PublishSpecificationList fromDbBundle: aBundle</body><body package="Store-UI" selector="userData:forPundle:">userData: anUserData forPundle: aPundle 	"Set the common items in the user data."	anUserData 		at: #publish put: true;		at: #pundle put: aPundle;		at: #comment put: '';		at: #level put: 0;		at: #modified put: true;		at: #version put: aPundle version;		at: #parentVersion put: aPundle version;		at: #description put: nil;		at: #blessing put: aPundle blessingLevelNumber;		yourself.</body><body package="Store-UI" selector="userData:forPundle:traceItems:">userData: anUserData forPundle: aPundle traceItems: traceItems	"Set the common items in the user data."	| mod |	 mod := traceItems contains: [ :p | p primaryKey = aPundle primaryKey ].	anUserData 		at: #publish put: mod not;		at: #pundle put: aPundle;		at: #comment put: '';		at: #level put: 0;		at: #modified put: mod not;		at: #description put: nil;		at: #version put: aPundle version;		at: #parentVersion put: aPundle version;		at: #blessing put: aPundle blessingLevelNumber;		yourself.</body><body package="Store-UI" selector="userDataFrom:">userDataFrom: aBundle  	| dict coll items traceItems trace |	dict := Dictionary new.	items := aBundle uniqueItemsAndLeveles.	( trace := aBundle parentRecord ) == nil		ifTrue: [ traceItems := Set new ]		ifFalse: [ traceItems := trace allItems ].	self userData: dict forPundle: aBundle traceItems: traceItems.	dict 		at: #publish put: true;		at: #modified put: true.	coll := List with: dict.	items do: 		[ :pair | 	| pndl comp |		comp := pair at: 1.		pndl := comp.		dict := Dictionary new.		self userData: dict forPundle: pndl traceItems: traceItems.		dict at: #description put: comp.		dict at: #level put: ( pair at: 2 ).		coll add: dict		].	^coll</body></methods><methods><class-id>Store.DatabaseMessageBox</class-id> <category>actions</category><body package="Store-Database" selector="copyToClipboard">copyToClipboard	"Copy the message to the clipboard"	[Screen default putExternalSelection: self errorMessage value asString ]		on: Object errorSignal		do: [:ex | 				Screen default putExternalSelection: ''.				ex return].</body><body package="Store-Database" selector="ok">ok	self accept value: true.</body><body package="Store-Database" selector="openNotifier">openNotifier	"Open a debugger on the error."	self hardHalt.	self ok.		"incase the debugger returns here:"</body></methods><methods><class-id>Store.DatabaseMessageBox</class-id> <category>aspects</category><body package="Store-Database" selector="errorMessage">errorMessage	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^errorMessage isNil		ifTrue:			[errorMessage := String new asValue]		ifFalse:			[errorMessage]</body><body package="Store-Database" selector="labelFor:">labelFor: aKey	aKey == #Title		ifFalse: [ ^nil ].	^titleString == nil		ifTrue: [ 'Database Error' ]		ifFalse: [ titleString ].</body><body package="Store-Database" selector="titleString:">titleString: aString	titleString := aString.</body></methods><methods><class-id>Store.DatabaseMessageBox class</class-id> <category>utilities</category><body package="Store-Database" selector="openOnMessage:">openOnMessage: errorMessageString	"self openOnMessage: 'errorMessageString'"	| dialog |	dialog := self new.	dialog errorMessage value: errorMessageString.	dialog open.	^dialog</body><body package="Store-Database" selector="openOnMessage:title:">openOnMessage: errorMessageString title: aString	"self openOnMessage: 'errorMessageString'"	| box |	box := self new.	box errorMessage value: errorMessageString.	box	titleString: aString.	box	open.	^box</body></methods><methods><class-id>Store.RepositoryPropertiesDialog</class-id> <category>aspects</category><body package="Store-UI" selector="databaseHolder">databaseHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^databaseHolder isNil		ifTrue:			[databaseHolder := String new asValue]		ifFalse:			[databaseHolder]</body><body package="Store-UI" selector="databaseListHolder">databaseListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^databaseListHolder isNil		ifTrue:			[databaseListHolder := List new asValue]		ifFalse:			[databaseListHolder]</body><body package="Store-UI" selector="environmentHolder">environmentHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^environmentHolder isNil		ifTrue:			[environmentHolder := String new asValue]		ifFalse:			[environmentHolder]</body><body package="Store-UI" selector="nameHolder">nameHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^nameHolder isNil		ifTrue:			[nameHolder := String new asValue]		ifFalse:			[nameHolder]</body><body package="Store-UI" selector="passwordHolder">passwordHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^passwordHolder isNil		ifTrue:			[passwordHolder := String new asValue]		ifFalse:			[passwordHolder]</body><body package="Store-UI" selector="tableOwnerHolder">tableOwnerHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^tableOwnerHolder isNil		ifTrue:			[tableOwnerHolder := String new asValue]		ifFalse:			[tableOwnerHolder]</body><body package="Store-UI" selector="userNameHolder">userNameHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^userNameHolder isNil		ifTrue:			[userNameHolder := String new asValue]		ifFalse:			[userNameHolder]</body></methods><methods><class-id>Store.RepositoryPropertiesDialog</class-id> <category>initialize-release</category><body package="Store-UI" selector="initialize">initialize	super initialize.	self initializeAspects.	self databaseListHolder value: self knownDatabaseInterfaces</body><body package="Store-UI" selector="profile:">profile: aConnectionProfile	profileHolder value: aConnectionProfile</body></methods><methods><class-id>Store.RepositoryPropertiesDialog</class-id> <category>private</category><body package="Store-UI" selector="canAccept">canAccept	^self validateRequiredValues and: [self validateName]</body><body package="Store-UI" selector="hasRequiredValues">hasRequiredValues	^(self isProvided: self nameHolder value)		and: [(self isProvided: self databaseHolder value)		and: [self isProvided: self userNameHolder value]]</body><body package="Store-UI" selector="initializeAspects">initializeAspects	profileHolder := ValueHolder new.	acceptTrigger := false asValue.	nameHolder := self profileAspect: #name.	databaseHolder := self profileAspect: #driverClassName.	environmentHolder := self profileAspect: #environment.	userNameHolder := self profileAspect: #userName.	passwordHolder := self profileAspect: #password.	tableOwnerHolder := self profileAspect: #tableOwner</body><body package="Store-UI" selector="isProvided:">isProvided: anObject	^anObject notNil and: [anObject notEmpty]</body><body package="Store-UI" selector="knownDatabaseInterfaces">knownDatabaseInterfaces	| result |	result := OrderedCollection new.	SQLBroker allSubclasses do: 		[:sb | 		(sb class includesSelector: #connectionClass) 			ifTrue: [result add: sb connectionClass name]].	^result</body><body package="Store-UI" selector="nameIsUnique">nameIsUnique	| name |	name := self nameHolder value.	^(RepositoryManager repositories anySatisfy: [:any | any name = name]) not		or: [profileHolder value name = name]</body><body package="Store-UI" selector="profileAspect:">profileAspect: aSymbol	| aspect |	aspect := (AspectAdaptor forAspect: aSymbol)		subjectChannel: profileHolder;		yourself.	^BufferedValueHolder subject: aspect triggerChannel: acceptTrigger</body><body package="Store-UI" selector="validateName">validateName	^self nameIsUnique		ifTrue: [true]		ifFalse:			[Dialog warn:				((#nameXIsAlreadyInUsePleaseChooseAnother &lt;&lt; #dialogs &gt;&gt; 'The name "&lt;1s&gt;" is already in use. Please choose a different name.')					expandMacrosWith: self nameHolder value).			false]</body><body package="Store-UI" selector="validateRequiredValues">validateRequiredValues	^self hasRequiredValues		ifTrue: [true]		ifFalse:			[Dialog warn: #aBunchOfValuesAreRequired &lt;&lt; #dialogs &gt;&gt; 'Name, interface, and a user name are required'.			false]</body></methods><methods><class-id>Store.RepositoryPropertiesDialog</class-id> <category>actions</category><body package="Store-UI" selector="ok">ok	self canAccept ifTrue:		[acceptTrigger value: true.		self accept value: true]</body></methods><methods><class-id>Store.RepositoryPropertiesDialog class</class-id> <category>instance creation</category><body package="Store-UI" selector="openOn:">openOn: aConnectionProfile	^self new		profile: aConnectionProfile;		open</body></methods><methods><class-id>Tools.StoreRepositoryListPage</class-id> <category>aspects</category><body package="Store-UI" selector="repositoryHolder">repositoryHolder	^nil asValue</body><body package="Store-UI" selector="repositoryListHolder">repositoryListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^repositoryListHolder isNil		ifTrue:			[repositoryListHolder :=  SelectionInListSortAware new.			repositoryListHolder selectionIndexHolder compute:				[:v |				self repositoryHolder value: repositoryListHolder selection].			repositoryListHolder]		ifFalse:			[repositoryListHolder]</body></methods><methods><class-id>Tools.StoreRepositoryListPage</class-id> <category>initialize-release</category><body package="Store-UI" selector="manager:">manager: aManager	super manager: aManager.	manager triggerChannel onChangeSend: #triggered to: self</body><body package="Store-UI" selector="postBuildWith:">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self repositorySelectionChanged</body><body package="Store-UI" selector="setting:">setting: aStoreRepositoryListSetting	setting := aStoreRepositoryListSetting.	self repositoryListHolder list: setting profiles.	self repositoryListHolder selectionIndexHolder		onChangeSend: #repositorySelectionChanged to: self.</body></methods><methods><class-id>Tools.StoreRepositoryListPage</class-id> <category>private</category><body package="Store-UI" selector="accept">accept	setting installProfiles</body><body package="Store-UI" selector="reset">reset	setting resetProfiles.	self repositoryListHolder list: setting profiles</body></methods><methods><class-id>Tools.StoreRepositoryListPage</class-id> <category>actions</category><body package="Store-UI" selector="addRepository">addRepository	| newProfile |	newProfile := ConnectionProfile new.	newProfile name: 'Repository ', (self repositoryListHolder list size + 1) printString.	(RepositoryPropertiesDialog openOn: newProfile) ifTrue:		[self repositoryListHolder list 			add: newProfile;			sortWith: [:a :b | a name &lt; b name].		self repositoryListHolder selection: newProfile.		manager tickle]</body><body package="Store-UI" selector="importSnapshots:">importSnapshots: aCollection	| snapshot newProfiles |	snapshot := aCollection detect: [:some | some id = setting id] ifNone: [^self].	newProfiles := List new.	snapshot stateNodes do:		[:each |		newProfiles add: (ConnectionProfile fromXmlElement: each)].	self repositoryListHolder list		removeAllSuchThat: [:each | true];		addAll: newProfiles.	self tickle</body><body package="Store-UI" selector="removeRepository">removeRepository	self repositoryListHolder selectionDo:		[:selection |		(Dialog confirm: #RemoveThisRepositoryQ &lt;&lt; #labels &gt;&gt; 'Remove this repository?')			ifTrue: 				[self repositoryListHolder list remove: selection.				manager tickle]]</body><body package="Store-UI" selector="repositoryProperties">repositoryProperties	self repositoryListHolder selectionDo:		[:selection |		RepositoryPropertiesDialog openOn: selection.		manager tickle]</body></methods><methods><class-id>Tools.StoreRepositoryListPage</class-id> <category>notifications</category><body package="Store-UI" selector="repositorySelectionChanged">repositorySelectionChanged	| hasSelection |	builder isNil ifTrue: [^self].	hasSelection := self repositoryListHolder selection notNil.	#(removeButton propertiesButton) do:		[:each | (self wrapperAt: each) isEnabled: hasSelection]</body><body package="Store-UI" selector="triggered">triggered	manager triggerChannel value 		ifTrue: [self accept]		ifFalse: [self reset]</body></methods><methods><class-id>Tools.StoreRepositoryListPage</class-id> <category>accessing</category><body package="Store-UI" selector="settings">settings	^Array with: setting</body></methods><methods><class-id>Store.DBPundlePrivileges</class-id> <category>private-database installation</category><body package="Store-Ownership" selector="updateUserInDatabase:">updateUserInDatabase: newUser	self broker process: 		'UPDATE ownerName, ownerType		WHERE pundleName = :pundleName 			AND pundleType = :pundleType			AND  privilige = ''owner'''		bindInput: self</body></methods><methods><class-id>Store.DBPundlePrivileges</class-id> <category>accessing</category><body package="Store-Ownership" selector="functionalKey">functionalKey	^Array with: self pundleName with: self pundleType with: self userName</body><body package="Store-Ownership" selector="privilege">privilege	"Answer the receiver's privilege."	^privilege</body><body package="Store-Ownership" selector="privilege:">privilege: newPrivilege	"Set the receiver's privilege to newPrivilege."	privilege := newPrivilege</body><body package="Store-Ownership" selector="pundle">pundle	^(self isBundle ifTrue: [Bundle] ifFalse: [Package]) newNamed: self pundleName</body><body package="Store-Ownership" selector="pundle:">pundle: aPundle	self pundleName: aPundle name.	self pundleType: (self typeOfPundle: aPundle)</body><body package="Store-Ownership" selector="pundleName">pundleName	"Answer the receiver's pundleName."	^pundleName</body><body package="Store-Ownership" selector="pundleName:">pundleName: newPundleName	"Set the receiver's pundleName to newPundleName."	pundleName := newPundleName</body><body package="Store-Ownership" selector="pundleType">pundleType	"Answer the receiver's pundleType."	^pundleType</body><body package="Store-Ownership" selector="pundleType:">pundleType: newPundleType	"Set the receiver's pundleType to newPundleType."	pundleType := newPundleType</body><body package="Store-Ownership" selector="user:">user: aDBUserGroup	self userName: aDBUserGroup userName.	self userType: aDBUserGroup type.</body><body package="Store-Ownership" selector="userName">userName	"Answer the receiver's userName."	^userName</body><body package="Store-Ownership" selector="userName:">userName: newUserName	"Set the receiver's userName to newUserName."	userName := newUserName</body><body package="Store-Ownership" selector="userType">userType	"Answer the receiver's userType."	^userType</body><body package="Store-Ownership" selector="userType:">userType: newUserType	"Set the receiver's userType to newUserType."	userType := newUserType</body></methods><methods><class-id>Store.DBPundlePrivileges</class-id> <category>types</category><body package="Store-Ownership" selector="isBundle">isBundle	^pundleType = 'B'</body><body package="Store-Ownership" selector="isGroup">isGroup	^pundleType = self class pundleOwnerClass groupType</body><body package="Store-Ownership" selector="isPackage">isPackage	^self isBundle not</body><body package="Store-Ownership" selector="isUser">isUser	^self isGroup not</body><body package="Store-Ownership" selector="typeOfPundle:">typeOfPundle: aPundle 	^self class typeOfPundle: aPundle</body></methods><methods><class-id>Store.DBPundlePrivileges</class-id> <category>printing</category><body package="Store-Ownership" selector="fullDescription">fullDescription	| stream |	stream := ( String new: 30 ) writeStream.	stream nextPutAll: userName.	( self isGroup )		ifTrue: [ stream nextPutAll: '(G)' ].	stream nextPutAll:		( privilege = 'owner'			ifTrue: [ ' owns ' ]			ifFalse: 				[ privilege = 'read'					ifTrue: [ ' can read ' ]					ifFalse: 						[ privilege = 'publish'							ifTrue: [ ' can publlish ' ]							ifFalse: [  ' *', privilege, '* ' ]						]				]		), pundleName.	self isBundle		ifTrue: [ stream nextPutAll: '(B)' ].	^stream contents.</body><body package="Store-Ownership" selector="itemString">itemString	^pundleName printString,		( privilege == #owner			ifTrue: [ ' is owned by ' ]			ifFalse: [ ' ', privilege printString, ' ' ]		),	 userName asString</body><body package="Store-Ownership" selector="printOn:">printOn: aStream	"*** created 9 January 1995 at 5:58:17 pm by PHM (Philippe F. Monnet	) in B941220 ***"	self itemString printOn: aStream</body><body package="Store-Ownership" selector="storeOn:">storeOn: aStream	"|ws|	ws := 'xxx' asFilename writeStream. DBPundlePrivileges allRecords 	do: [:r| r storeOn: ws]. ws close"	aStream nextPutAll: pundleName; tab.	aStream nextPutAll: pundleType; tab.	aStream nextPutAll: userName; tab.	aStream nextPutAll: userType asString; tab.	aStream nextPutAll: privilege asString; cr</body></methods><methods><class-id>Store.DBPundlePrivileges</class-id> <category>relationships</category><body package="Store-Ownership" selector="relatedBy:">relatedBy: relToken	"Anwer set of relations. Main relationship is owner-&gt;pundle."	| index |	( index := #( #ownerRel #readRel #publishRel ) indexOf: relToken ) &gt; 0		ifTrue:			[ ^self class pundlesUser: userName privilege: 					( #( #owner #read #publish ) at: index )			].	( index := #( #ownerRRel #readRRel #publishRRel ) indexOf: relToken ) &gt; 0		ifTrue:			[ ^self class 				usersWithPrivilege: ( #( #owner #read #publish ) at: index )				pundleName: pundleName 				pundleType: pundleType			].	^super relatedBy: relToken</body><body package="Store-Ownership" selector="stringKey:">stringKey: hints	^( hints includes: #sort ) 		ifTrue: [ userName, ' ', privilege ]		ifFalse: [ userName ]</body></methods><methods><class-id>Store.DBPundlePrivileges</class-id> <category>initialize-release</category><body package="Store-Ownership" selector="readFrom:">readFrom: aStream	"|ws bb| 	ws := 'xxx' asFilename readStream. bb := DBPundlePrivileges readFrom: ws. ws close. bb"	pundleName := aStream upTo: Character tab.	aStream skipSeparators.	pundleType := aStream upTo: Character tab.	aStream skipSeparators.	userName := aStream upTo: Character tab.	aStream skipSeparators.	userType := aStream upTo: Character tab.	aStream skipSeparators.	privilege := (aStream upTo: Character cr) asSymbol.</body></methods><methods><class-id>Store.DBPundlePrivileges</class-id> <category>comparing</category><body package="Store-Ownership" selector="&lt;=">&lt;= aPrivilege	self class == aPrivilege class		ifFalse: [ ^false ].	self userName = aPrivilege userName		ifFalse: [ ^self userName &lt;= aPrivilege userName ].	self privilege = aPrivilege privilege		ifFalse: [ ^self privilege &lt;= aPrivilege privilege ].	^self pundleName &lt;= pundleName.</body><body package="Store-Ownership" selector="=">= aPrivilege	self class == aPrivilege class		ifFalse: [ ^false ].	^( self userName = aPrivilege userName )	  &amp;		( self privilege = aPrivilege privilege )	&amp;		( self pundleName = aPrivilege pundleName )  &amp;		( self pundleType = aPrivilege pundleType ) 	 &amp;		( self userType = aPrivilege userType )</body><body package="Store-Ownership" selector="hash">hash	^self userName hash</body></methods><methods><class-id>Store.DBPundlePrivileges class</class-id> <category>instance creation</category><body package="Store-Ownership" selector="forPundle:">forPundle: aPundle	^self new pundle: aPundle</body><body package="Store-Ownership" selector="forPundle:user:">forPundle: aPundle user: aDBUser	^self new 		pundle: aPundle;  		user: aDBUser;		yourself.</body><body package="Store-Ownership" selector="forPundle:user:privilege:">forPundle: aPundle user: aDBUser privilege: privilege	^self new 		pundle: aPundle;  		user: aDBUser;  		privilege: privilege;		yourself.</body><body package="Store-Ownership" selector="forPundleName:type:">forPundleName: aPundleName type: aPundleType	^self new 		pundleName: aPundleName;		pundleType: aPundleType</body><body package="Store-Ownership" selector="forUser:">forUser: aUser	^self new user: aUser.</body><body package="Store-Ownership" selector="grant:to:for:">grant: aPrivilege to: aDBUser for: aPundle	"Set the access privilege to aDBUser for  a Pundle."		| priv |	aPrivilege == #owner		ifTrue: [ ^self updateOwnershipFor: aPundle to: aDBUser ].	priv := self forPundle: aPundle user: aDBUser privilege: aPrivilege.	[ priv installInDatabase ] on: self broker indexConflictSignal do:		[ :e | Dialog warn: 'User may only have one privilege per pundle.' ].</body><body package="Store-Ownership" selector="readFrom:">readFrom: aStream	| baby |	baby := self new.	baby readFrom: aStream.	^baby</body><body package="Store-Ownership" selector="revoke:to:for:">revoke: privilege to: aDBUser for: aPundle	"Deny the access privilege to aDBUser for  a Pundle."		( self forPundle: aPundle user: aDBUser privilege: privilege )		removeFromDatabase.</body><body package="Store-Ownership" selector="revokeAllFor:for:">revokeAllFor: aDBUser for: aPundle	"Deny the access privilege to aDBUser for  a Pundle."		| temp |	temp := self forPundle: aPundle user: aDBUser.	self rights do:		[ :priv | temp privilege: priv.		temp removeFromDatabase.		].</body><body package="Store-Ownership" selector="setOwnershipFor:to:">setOwnershipFor: aPundle to: anOwnerName	self updateOwnershipFor: aPundle to: anOwnerName</body><body package="Store-Ownership" selector="updateOwnershipFor:to:">updateOwnershipFor: aPundle to: aUser	| new old in |	new := self forPundle: aPundle user: aUser privilege: #owner.	( old := self ownerOfPundle: aPundle ) == nil		ifTrue: [ [ new installInDatabase ] on: self broker indexConflictSignal do:					[ :e | Dialog warn: 'User may only have one privilege per pundle.' ]			   ]		ifFalse: 			[ in := self forPundle: aPundle user: old  privilege: #owner.			self broker process: 				( self newSQL					setColumns: #( #userName #userType ) equalTo: 						( Array with: aUser userName printString with: aUser userType  printString );					whereSqlString 				  )				bindInput: in.			].</body></methods><methods><class-id>Store.DBPundlePrivileges class</class-id> <category>accessing</category><body package="Store-Ownership" selector="pundleOwnerClass">pundleOwnerClass	^DBUserGroup</body><body package="Store-Ownership" selector="rights">rights	^# ( #owner #read #publish )</body></methods><methods><class-id>Store.DBPundlePrivileges class</class-id> <category>private-pundle types</category><body package="Store-Ownership" selector="bundleType">bundleType	^'B'</body><body package="Store-Ownership" selector="packageType">packageType	^'P'</body><body package="Store-Ownership" selector="typeOfPundle:">typeOfPundle: aPundle	"Moved to class side by Philippe F. Monnet of Andersen Consulting"		^aPundle isBundle		ifTrue: [ self bundleType ]		ifFalse: [ self packageType ]</body></methods><methods><class-id>Store.DBPundlePrivileges class</class-id> <category>public-query</category><body package="Store-Ownership" selector="allPrivileges">allPrivileges	^self allRecords</body><body package="Store-Ownership" selector="allPrivilegesFor:">allPrivilegesFor: aUser 	"Answer a set of privileges for aUser."	"self allPrivilegesFor: ( DBUserGroup userNamed:'bern' )	"	| inp |	inp := self forUser: aUser.	^[self processList:			(self broker process: 				( self newSQL					selectAll;					where;					column: #userName equalTo: ':userName';					and;					column: #userType equalTo: ':userType')			bindInput: inp 			bindOutput: self newPrimed)	] 	on: self  errorSignals 	do: 	[:ex |   ex outer. OrderedCollection new].</body><body package="Store-Ownership" selector="allPrivilegesForPundle:">allPrivilegesForPundle: aPundle	"Answer a set of privileges for aPundle."	"self allPrivilegesForPundle: ( Registry packageNamed: 'Store' )	"	| inp |	inp := self forPundle: aPundle.	^[self processList: 		(self broker process: 				( self newSQL					selectAll;					where;					column: #pundleName equalTo: ':pundleName';					and;					column: #pundleType equalTo: ':pundleType')			bindInput: inp 			bindOutput: self newPrimed)	] 	on: self  errorSignals 	do: 	[:ex |   ex outer. OrderedCollection new].</body><body package="Store-Ownership" selector="allUsersFor:">allUsersFor: aPundle	"Answer a set of user names that have any privileges for aPundle"	| inp |	inp := self forPundle: aPundle.	[self processList:		( self broker process: 				(self newSQL					selectAll;					where;					column: #pundleName equalTo: ':pundleName'					and;					column: #pundleType equalTo: ':pundleType')			bindInput: inp 			bindOutput: self newPrimed)	]	on: self  errorSignals 	do: 	[:ex | ex outer. OrderedCollection new ].</body><body package="Store-Ownership" selector="ownerOfPundle:">ownerOfPundle: pundle	| list |	pundle == nil ifTrue: [ ^nil ].	list := self usersWithPrivilege: #owner 				pundleName: pundle name 				pundleType: ( self typeOfPundle: pundle ).	list size == 0 ifTrue: [ ^nil ].	list size &gt; 1 ifTrue: [ Dialog warn: pundle name,  ' has more than one owner.' ].	^list  asOrderedCollection first.</body><body package="Store-Ownership" selector="privilegeForUser:pundle:">privilegeForUser: aUser pundle: aPundle	"Answer the privilige the user has for aPundle."	| inp coll |	inp := self forPundle: aPundle user: aUser.	coll := self broker process: 				( self newSQL					selectAll;					where;					column: #pundleName equalTo: ':pundleName';					and;					column: #pundleType equalTo: ':pundleType';					and;					column: #userName equalTo: ':userName';					and;					column: #userType equalTo: ':userType')			bindInput: inp.	coll isEmpty ifTrue: [ ^nil].	^coll first first</body><body package="Store-Ownership" selector="pundlesGroupName:privilege:">pundlesGroupName: aUserName privilege: aSymbol	"Answer a collection of pundles for which a group has given privilege."	^self pundlesUserName: aUserName userType: self pundleOwnerClass groupType privilege: aSymbol.</body><body package="Store-Ownership" selector="pundlesOwnedBy:">pundlesOwnedBy: aDBUser	"Answer a collection of priviliges for which a user is the owner."	^self pundlesUser: aDBUser privilege: #owner</body><body package="Store-Ownership" selector="pundlesUser:privilege:">pundlesUser: aUser privilege: aSymbol	"Answer a collection of pundles for which a user has given privilege."	^self pundlesUserName: aUser userName userType: aUser type privilege: aSymbol.</body><body package="Store-Ownership" selector="pundlesUserName:userType:privilege:">pundlesUserName: aUserName userType: typeString privilege: aSymbol	"Answer a collection of priviliges for which a user has given privilege."	| inp |	inp := self new.	inp userName: aUserName; 		userType: typeString;		privilege: aSymbol.	^[self processList:			(self broker process:				( self newSQL					selectAll;					where;					column: #privilege equalTo: ':privilege';					and;					column: #userName equalTo: ':userName';					and;					column: #userType equalTo: ':userType')		bindInput: inp		bindOutput: self newPrimed)	]	on: self  errorSignals 	do: 	[:ex |  ex outer. OrderedCollection new ].</body><body package="Store-Ownership" selector="user:hasPrivilege:to:">user: aUser hasPrivilege: privilege to: aPundle	"Check aUser and all groups the user belongs to for a privilege"	| groups users |	^[	users := self usersWithPrivilege: privilege pundle: aPundle.		( users includes: aUser ) ifTrue: [ ^true ].		groups := self pundleOwnerClass groupsForUser: aUser.		groups do:			[ :grp | ( users includes: grp ) ifTrue: [ ^true] ].		false.	] 	on: self errorSignals	do: [ :ex | false].</body><body package="Store-Ownership" selector="usersWithPrivilege:pundle:">usersWithPrivilege: aSymbol pundle: aPundle	"Answer a set of user names that have a given privilege for aPundle"	"self controlPundle: "	^self usersWithPrivilege: aSymbol 		 pundleName: aPundle name 		 pundleType: ( self typeOfPundle: aPundle )</body><body package="Store-Ownership" selector="usersWithPrivilege:pundleName:pundleType:">usersWithPrivilege: aSymbol pundleName: aPundleName pundleType: aType	"Answer a set of user names that have a given privilege for aPundle"	"self usersWithPrivilege: #owner pundleName: 'Store-Base' pundleType: self packageType "	| inp coll |	inp := self forPundleName: aPundleName type: aType.	inp privilege: aSymbol.	[ coll := self broker process: 				( self newSQL					select: #( #userName #userType );					where;					column: #pundleName equalTo: ':pundleName';					and;					column: #pundleType equalTo: ':pundleType';					and;					column: #privilege equalTo: ':privilege')			bindInput: inp	] on: self errorSignals do: [ :ex | ex outer. ^nil].	^( coll collect: 			[ :each |  self pundleOwnerClass userName: each first type: each last 		] )</body></methods><methods><class-id>Store.DBPundlePrivileges class</class-id> <category>installation</category><body package="Store-Ownership" selector="fieldTypes">fieldTypes	| aDict  |	aDict := Dictionary new.	aDict at: 'pundleName' 	put: #PrimaryKeyString.	aDict at: 'pundleType' 	put: #PrimaryKeyChar.	aDict at: 'userName' 	put: #PrimaryKeyString.	aDict at: 'userType' 		put: #PrimaryKeyChar.	aDict at: 'privilege'		put: #String32. 	self checkFieldsWith: aDict.	^aDict</body><body package="Store-Ownership" selector="grantDatabasePrivilegesTo:">grantDatabasePrivilegesTo: userName	"This table is controlled by the system admin."	"self grantDatabasePrivilegesTo: 'eliot' "	self broker grantForClass: self  		permissions: #( #INSERT #UPDATE #DELETE) 		toUsers: (Array with:  userName)</body><body package="Store-Ownership" selector="indexParameters">indexParameters	^nil</body><body package="Store-Ownership" selector="revokeDatabasePrivilegesFrom:">revokeDatabasePrivilegesFrom: userName	"This table is controlled by the system admin."	"self revokeDatabasePrivilegesTo: 'eliot' "	self broker revokeForClass: self 			permissions: #( #INSERT  #UPDATE #DELETE) 			fromUsers: (Array with: userName)</body><body package="Store-Ownership" selector="setDatabasePrivilegesForTable">setDatabasePrivilegesForTable	"This table is controlled by the system admin."	self broker grantForClass: self permissions: #(#SELECT) toUsers: #( #PUBLIC)</body><body package="Store-Ownership" selector="tableSpaceName">tableSpaceName	^'NEWBERN2'</body></methods><methods><class-id>Store.DBPundlePrivileges class</class-id> <category>As yet unclassified</category><body package="Store-Ownership" selector="allDistinctUserGroups">allDistinctUserGroups	^( self broker answerFromQuery: 				(self newSQL selectDistinct: #( userName usertype ))		bindInput: 				( DBUserGroup new makeUser; yourself )) 	collect: 		[ :row |		DBUserGroup new userName: row first; type: row last; yourself		].</body></methods><methods><class-id>Store.PundleGraph</class-id> <category>initialize-release</category><body package="Store-UI-Graphs" selector="initialize">initialize	Registry addDependent: self.	menuBarHolder := self menuBar asValue.	super initialize.</body><body package="Store-UI-Graphs" selector="release">release	super release.	Registry removeDependent: self.</body></methods><methods><class-id>Store.PundleGraph</class-id> <category>updating</category><body package="Store-UI-Graphs" selector="update:with:">update: anAspect with: aParameter 	super update: anAspect with: aParameter.	anAspect == #addedPundle		ifTrue: 			[| newPundle |			newPundle := aParameter.			self addToPundleList: newPundle.			self selectPundle: newPundle].	anAspect == #removedPundle		ifTrue: 			[| oldPundle |			oldPundle := aParameter.			self removeFromPundleList: oldPundle]</body><body package="Store-UI-Graphs" selector="update:with:from:">update: aspect with: parameter from: sender 	aspect == #addedPundle		ifTrue: 			[| newPundle |			newPundle := parameter.			self addToPundleList: newPundle.			self selectPundle: newPundle.			^self].	aspect == #removedPundle		ifTrue: 			[| oldPundle |			oldPundle := parameter.			self removeFromPundleList: oldPundle.			^self].	super		update: aspect		with: parameter		from: sender</body></methods><methods><class-id>Store.PundleGraph</class-id> <category>menus</category><body package="Store-UI-Graphs" selector="bundleStructureMenuBar">bundleStructureMenuBar	"Add dynamic features to the menu bar."	| menu |	menu := self class bundleStructureMenuBarSkeleton.	menu menuItems do: [:item | self makePundleMenuDynamic: item submenu].	^menu</body><body package="Store-UI-Graphs" selector="menuBarHolder">menuBarHolder	^menuBarHolder</body></methods><methods><class-id>Store.PundleGraph</class-id> <category>accessing</category><body package="Store-UI-Graphs" selector="makeBundleStructureTool">makeBundleStructureTool	toolType := #bundleStructureTool</body><body package="Store-UI-Graphs" selector="perspective">perspective	^#tt_contains</body></methods><methods><class-id>Store.PundleGraph</class-id> <category>private</category><body package="Store-UI-Graphs" selector="addToPundleList:">addToPundleList: aPundle	self graphView focus value add: aPundle.	self updatePundleContents.</body><body package="Store-UI-Graphs" selector="removeFromPundleList:">removeFromPundleList: aPundle	self graphView focus value remove: aPundle.	self updatePundleContents.</body></methods><methods><class-id>Store.PundleGraph</class-id> <category>interface opening</category><body package="Store-UI-Graphs" selector="postOpenWith:">postOpenWith: aBuilder 	| foc windowLabel |	super postOpenWith: aBuilder.	toolType == #bundleStructureTool		ifTrue: 			[foc := self graphView focus value.			windowLabel := 'Structure of: ' , foc first itemString.			foc size &gt; 1 ifTrue: [windowLabel := windowLabel , '...'].			aBuilder window label: windowLabel.			self menuBarHolder value: self bundleStructureMenuBar].</body></methods><methods><class-id>Store.PundleGraph class</class-id> <category>instance creation</category><body package="Store-UI-Graphs" selector="open:onPundles:">open: pundleGraph onPundles: pundleCollection	| cache col |	cache := Dictionary new.	col := pundleCollection collect: [ :pun | ElementProxy element: pun cache: cache ].	pundleGraph beIndentedList.	pundleGraph focus: col.	self openOn: pundleGraph.	^pundleGraph</body><body package="Store-UI-Graphs" selector="openBundleStructureViewOn:">openBundleStructureViewOn: bundles		| pundleGraph |	pundleGraph := self new makeBundleStructureTool.	self open: pundleGraph onPundles: bundles.</body><body package="Store-UI-Graphs" selector="openOnImage">openOnImage	"self openOnImage"	self open: self new onPundles: Registry allPundles</body></methods><methods><class-id>Store.PundleGraph class</class-id> <category>class initialization</category><body package="Store-UI-Graphs" selector="initialize">initialize	"self initialize"		self initializeRelationships.	self initializePerspectives</body><body package="Store-UI-Graphs" selector="initializePerspectives">initializePerspectives	"self initializePerspectives"	^(List new) add: ((Array new: 9)			at: 1 put: #LDMPerspective;			at: 2 put: #arrRows:;			at: 3 put: #(#(#V1 #V1 'tt_contains' false false true false false));			at: 4 put: #arrLabelHints:;			at: 5 put: #();			at: 6 put: #arrRelDesc:;			at: 7 put: ((Array new: 1)				at: 1 put: ((Array new: 5)					at: 1 put: 'tt_contains';					at: 2 put: true;					at: 3 put: #solid;					at: 4 put: ColorValue blue;					at: 5 put: 1; yourself); yourself);			at: 8 put: #name:;			at: 9 put: #tt_contains; yourself) decodeAsLiteralArray; yourself</body><body package="Store-UI-Graphs" selector="initializeRelationships">initializeRelationships	"self initializeRelationships"	^(List new) add: #(#LDMFirstOrderRel #name: 'tt_contains' #description: 'contains' #reverse: nil #token: #tt_containsRel) decodeAsLiteralArray; add: #(#LDMFirstOrderRel #name: 'tt_containsR' #description: 'containsR' #reverse: nil #token: #tt_containsRRel) decodeAsLiteralArray; yourself</body></methods><methods><class-id>Store.DataElement</class-id> <category>private</category><body package="Store-DB-Subdefs" selector="convertFromXML:">convertFromXML: aString	| p element out attr value i |	p := XML.XMLParser on: aString readStream.	element := p validate: false; getNextChar; element.	out := (String new: 128) writeStream.	out nextPutAll: (self			convertXMLNameToSmalltalk: (element elementNamed: 'environment') characterData			quoted: false).	out nextPutAll: ' defineSharedVariable: ';		store: (element elementNamed: 'name') characterData asSymbol.	out crtab; nextPutAll: 'private: ';		nextPutAll: (element elementNamed: 'private') characterData.	out crtab; nextPutAll: 'constant: ';		nextPutAll: (element elementNamed: 'constant') characterData.	out crtab; nextPutAll: 'category: ';		store: (element elementNamed: 'category') characterData.	out crtab; nextPutAll: 'initializer: ';		store: (element elementNamed: 'initializer') characterData.	attr := [element elementNamed: 'attributes'] on: Error do: [:ex | ex return: nil].	attr == nil ifFalse:		[out crtab; nextPutAll: 'attributes: #('.		attr elements do: [:elm |			elm isElement ifTrue:				[out crtab: 3; nextPutAll: '#('; store: elm tag type asSymbol; space.				((elm elements contains: [:e | e isElement]) or: [elm elements isEmpty])					ifTrue: [value := (elm elements select: [:e | e isElement])							collect: [:e | e characterData]]					ifFalse:						[value := elm characterData.						i := #('nil' 'true' 'false') indexOf: value.						value := i = 0 ifTrue: [value asSymbol] ifFalse: [#(nil true false) at: i]].				out store: value; nextPutAll: ')']].		out nextPutAll: ')'].	^out contents</body><body package="Store-DB-Subdefs" selector="convertToXML:">convertToXML: aString	| parse driver data sName eName init |	parse := Compiler new parse: aString in: nil class noPattern: true notifying: nil.	parse := parse node block body statements first.	data := Dictionary new.	parse selector keywords with: parse arguments do:		[:key :value | data at: key put: value].	driver := XML.DOM_SAXDriver new.	driver 	startDocumentFragment;		startElement: 'shared-variable' atts: nil.	sName := (data at: 'defineSharedVariable:' ifAbsent: [data at: 'defineStatic:']) value asString.	self sax: driver tag: 'name' value: sName.	eName := self convertVariableNodeToXML: parse receiver.	self sax: driver tag: 'environment' value: eName.	self sax: driver tag: 'private' value: (data at: 'private:') value printString.	self sax: driver tag: 'constant' value: (data at: 'constant:') value printString.	self sax: driver tag: 'category' value: (data at: 'category:') value asString.	init := ( init := (data at: 'initializer:' ) value ) == nil		ifFalse: [ self sax: driver tag: 'initializer' value: init asString ].	driver endElement;		endDocumentFragment.	^SmalltalkWorkbench prettyPrint: driver document root</body><body package="Store-DB-Subdefs" selector="move:to:">move: obj to: imgPackage 	"Move obj, assumed to be the insanitiation of the reciever, to imgPackage."	XChangeSet current moveDataKey: self dataKey owner: self owner toPackage: imgPackage</body></methods><methods><class-id>Store.DataElement</class-id> <category>printing</category><body package="Store-DB-Subdefs" selector="displayString">displayString	^self name</body><body package="Store-DB-Subdefs" selector="printOn:">printOn: aStream	aStream nextPutAll: 'Element{';		nextPutAll: self primaryKey printString;		nextPutAll: '-';		nextPutAll: self name;		nextPutAll: '}'.</body></methods><methods><class-id>Store.DataElement</class-id> <category>support</category><body package="Store-DB-Subdefs" selector="textForItem">textForItem	^self itemString asText</body></methods><methods><class-id>Store.DataElement</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="absoluteOwnerName">absoluteOwnerName	^environmentString</body><body package="Store-DB-Subdefs" selector="dataKey">dataKey	^name asSymbol</body><body package="Store-DB-Subdefs" selector="environmentString">environmentString	^environmentString</body><body package="Store-DB-Subdefs" selector="environmentString:">environmentString: aString	environmentString := aString</body><body package="Store-DB-Subdefs" selector="inClass">inClass		"Set typeString to indicate receiver is in a Class."	typeString := 'C'.</body><body package="Store-DB-Subdefs" selector="inNameSpace">inNameSpace		"Set typeString to indicate receiver is in a NameSpace."	typeString := 'N'</body><body package="Store-DB-Subdefs" selector="key">key	^self dataKey</body><body package="Store-DB-Subdefs" selector="protocol">protocol	^protocolName isNil		ifTrue: [ #unknown ]		ifFalse: [ protocolName asSymbol ]</body><body package="Store-DB-Subdefs" selector="protocolName">protocolName	^protocolName</body><body package="Store-DB-Subdefs" selector="protocolName:">protocolName: aString	protocolName := aString</body><body package="Store-DB-Subdefs" selector="setTypeString:">setTypeString: anObject	anObject isBehavior		ifTrue: [ self inClass ]		ifFalse: [ self inNameSpace ]</body><body package="Store-DB-Subdefs" selector="stDocumentation">stDocumentation	^self commentStr isNil		ifTrue: [ '' ]		ifFalse: [ commentStr ].</body><body package="Store-DB-Subdefs" selector="textRepresentationForTag:">textRepresentationForTag: aTag		^self definition</body><body package="Store-DB-Subdefs" selector="typeString">typeString	^typeString</body><body package="Store-DB-Subdefs" selector="typeString:">typeString: aString	typeString := aString.</body></methods><methods><class-id>Store.DataElement</class-id> <category>testing</category><body package="Store-DB-Subdefs" selector="isForData">isForData	^true</body><body package="Store-DB-Subdefs" selector="isForGeneral">isForGeneral	^true</body><body package="Store-DB-Subdefs" selector="isInClass">isInClass		"Answer true if the receiver resides in a Class."	^typeString ~~ nil and: [ typeString = 'C' ].</body><body package="Store-DB-Subdefs" selector="isInNameSpace">isInNameSpace		"Answer true if the receiver resides in a NameSpace."		"This is the default."	^typeString == nil or: [ typeString = 'N' ]</body></methods><methods><class-id>Store.DataElement</class-id> <category>public interface</category><body package="Store-DB-Subdefs" selector="browseVersions">browseVersions  	TabApplicationSystemBrowser browseVersionsOfMethodOrStatic: self</body><body package="Store-DB-Subdefs" selector="loadSrc">loadSrc	"Load the datum. Answer true if the installation was successful."	IncrementNotification raiseSignal.	self nameSpace == nil		ifTrue: 			[ UnloadableDefinitionError signalWith: self.			^false			].	[ [ Compiler evaluate: self definitionStr ] 		on: VariableConfirmation do: [ :ex | ex resume: false ]	] on: UnhandledException do:		[ :e | UnloadableDefinitionError signalWith: self.		^false		]."	XChangeSet current removeDataKeyChanges: self dataKey owner: ns namedReferent.  "	^true</body><body package="Store-DB-Subdefs" selector="loadSrcIntoPackage:confirm:">loadSrcIntoPackage: imPkg confirm: aBoolean	"Load the datum. Make sure that it goes to the imPkg. and it does not	overwrites existing definition form another package."	aBoolean ifTrue: 		[ (Dialog confirm: 'Do you want to load the selected data?') 			ifFalse: [ ^self ]		].	( LoadAnalyzer canLoadDatum: self from: imPkg )		ifTrue: [ Policies packagePolicy forcePackage: imPkg while:  					[ self loadSrc ]				]</body><body package="Store-DB-Subdefs" selector="removeFromPackage:">removeFromPackage: aPackage	"For adding a removal of unloaded defintions from the change sets."	XMainChangeSet current		addRemoveStatic: self dataKey		ownerName: self environmentString		isInNameSpace: self isInNameSpace		package: aPackage</body></methods><methods><class-id>Store.DataElement</class-id> <category>converting</category><body package="Store-DB-Subdefs" selector="asDescriptor">asDescriptor	"Answer an instance of DatumDescriptor."	^self isInClass		ifTrue: [ 	DatumDescriptor fromDataKey: self dataKey className: self environmentString ]		ifFalse: [ DatumDescriptor fromDataKey: self dataKey nameSpaceName: self environmentString ]</body><body package="Store-DB-Subdefs" selector="asTag">asTag	"Answer an instance of TT_DataTag."	^self isInClass		ifTrue: [ 	DataTag newClassName: self environmentString dataKey: self dataKey ]		ifFalse: [ DataTag newNameSpaceName: self environmentString dataKey: self dataKey ]</body></methods><methods><class-id>Store.DataElement</class-id> <category>comparing</category><body package="Store-DB-Subdefs" selector="comparesTo:">comparesTo: anObject		"Answer true if anObject could be another version of the receiver."	( super comparesTo: anObject ) 		ifFalse: [ ^false ].	self isInClass = anObject isInClass		ifFalse: [ ^false ].	^self dataKey = anObject dataKey</body><body package="Store-DB-Subdefs" selector="objectIsForSelf:">objectIsForSelf: anObject		"Answer true if anObject represents the same kind of thing as the reciever."	^anObject isForData</body><body package="Store-DB-Subdefs" selector="sameAsDBThing:">sameAsDBThing: aDatum 	"When comparing with DB - the definition has it all"	"Note: at the moment, no comments for data."	^self definition = aDatum definition</body><body package="Store-DB-Subdefs" selector="sameAsImThing:">sameAsImThing: aDatum 	"When comparing with DB - the definition has it all"	"Note: at the moment, no comments for data."	^self definition = aDatum definition</body><body package="Store-DB-Subdefs" selector="sourceMatches:">sourceMatches: aDatum		"Answer wheter the source matches."		"Note: since protocol is part of the definition, we don't need to check it."	^self definition equalsAcrossPlatforms: aDatum definition</body></methods><methods><class-id>Store.DataElement</class-id> <category>fileout</category><body package="Store-DB-Subdefs" selector="fileOutOn:">fileOutOn: aFileManager	aFileManager storeObjectDefinition: self.</body></methods><methods><class-id>Store.DataElement</class-id> <category>db-utilities</category><body package="Store-DB-Subdefs" selector="containingPackages">containingPackages	^[( Data packagesContainingDatum: primaryKey )		collect: [ :id | Package aRecordWithID: id ]	]	on: self errorSignals	do: [ :ex | ex outer. OrderedCollection new ].</body></methods><methods><class-id>Store.DataElement class</class-id> <category>private-utilities</category><body package="Store-DB-Subdefs" selector="moveDatum:">moveDatum: aDatum	"Ask for destination package and move the datum."	| dPkg   dataKey |		( aDatum isNil or: [ aDatum isLoaded not ] )		ifTrue: [ ^false ].	dataKey := aDatum dataKey.	( dPkg := PackageChooser chooseOrAdd ) isNil ifTrue: [ ^false ].	XChangeSet current 		moveDataKey: dataKey		owner: aDatum owner		toPackage: dPkg.	^true</body><body package="Store-DB-Subdefs" selector="sortForLoading:">sortForLoading: aCollectionOfDBMethods	"I don't sort and I don't do windows."	^aCollectionOfDBMethods</body></methods><methods><class-id>Store.DataElement class</class-id> <category>instance creation</category><body package="Store-DB-Subdefs" selector="from:timeStamp:trace:">from: bindingReference timeStamp: timeStamp trace: oldDB		"create an instance from a InitializedVariableBinding."	| env binding sname |	env := bindingReference environment.	binding := bindingReference binding.	sname := bindingReference simpleName asString.	^self new		name: sname;		environmentString: env absoluteName;		setTypeString: env;		timeStamp: timeStamp;		definitionStr:  binding binding source;		protocolName: ( self protocolNameFor: sname in: env ); 		commentStr: nil;  	"MAY BE: binding binding comment"		setTrace: oldDB;		yourself.</body><body package="Store-DB-Subdefs" selector="fromDescriptor:timeStamp:trace:">fromDescriptor: datumDescriptor timeStamp: timeStamp trace: oldDBDatum 	| owner |	owner :=datumDescriptor owner.	^self new 		name: datumDescriptor dataKey asString;		 timeStamp: timeStamp; 		environmentString: owner absoluteName;		setTypeString: owner;		definitionStr: datumDescriptor sourceCode;		protocolName: datumDescriptor protocol; 		setTrace: oldDBDatum;		yourself</body><body package="Store-DB-Subdefs" selector="fromOwner:named:timeStamp:trace:">fromOwner: owner named: aName timeStamp: timeStamp trace: oldDBDatum 	^( self new ) name: aName asString;		 timeStamp: timeStamp; 		environmentString: owner absoluteName;		setTypeString: owner;		definitionStr: ( owner asNameSpace definitionOf: aName ifAbsent: [nil] );		protocolName: ( self protocolNameFor: aName in: owner ); 		setTrace: oldDBDatum</body><body package="Store-DB-Subdefs" selector="moveFieldsFrom:to:">moveFieldsFrom: aView to: aDBRecord	super moveFieldsFrom: aView to: aDBRecord.	aDBRecord protocolName: aView protocolName.	aDBRecord typeString: aView typeString.</body></methods><methods><class-id>Store.DataElement class</class-id> <category>public interface</category><body package="Store-DB-Subdefs" selector="loadComponents:package:">loadComponents: aSet package: aDBPackage 	"Load specified components: #definition #comment #methods #data	from aDBPackge."	| set |	self error: 'What are we doing here?'.	( set := aSet copy )		remove: #methods ifAbsent: [];		remove: #data ifAbsent: [].		super loadComponents: set package: aDBPackage.</body></methods><methods><class-id>Store.DataElement class</class-id> <category>accessing</category><body package="Store-DB-Subdefs" selector="associationClass">associationClass	^Data</body><body package="Store-DB-Subdefs" selector="commentFor:">commentFor: aBinding	^''			"until bindings have comments"</body><body package="Store-DB-Subdefs" selector="referenceColumn">referenceColumn	^#dataRef</body><body package="Store-DB-Subdefs" selector="sourcesViewClass">sourcesViewClass	^DataAndSourcesView</body></methods><methods><class-id>Store.DataElement class</class-id> <category>private</category><body package="Store-DB-Subdefs" selector="compare:key:in:">compare: dbDatum key: dataKey in: owner		"Answer true if dbDatum reflects the image."	 ( dbDatum == nil  or: [ dataKey ~= dbDatum dataKey ] )		ifTrue: [ ^false ].	^( owner asNameSpace definitionOf: dataKey ifAbsent: [ ^false ] )		= dbDatum definition</body><body package="Store-DB-Subdefs" selector="newNamed:inOwner:trace:package:">newNamed: aName inOwner: owner trace: oldDBDatum package: aDBPackage	| newDBDatum  |	newDBDatum := self				fromOwner: owner				named: aName				timeStamp: self timeStamp				trace: oldDBDatum.	(oldDBDatum notNil and: [oldDBDatum sourceCode = newDBDatum sourceCode])		ifTrue: [newDBDatum encodedDataID: oldDBDatum encodedDataID]."	newDBDatum creatorPackage: aDBPackage primaryKey.  "	newDBDatum install.	^newDBDatum</body><body package="Store-DB-Subdefs" selector="protocolNameFor:in:">protocolNameFor: aString in: owner		"Answer the protocol for aString in a namespace or class."	| protocolName |	protocolName := owner asNameSpace organization categoryOfElement: aString.	^protocolName isNil		ifTrue: [ 'unclassified' ]		ifFalse: [ protocolName asString ]</body><body package="Store-DB-Subdefs" selector="recordFromDescriptor:trace:package:">recordFromDescriptor: datumDescriptor trace: oldDBDatum package: aDBPackage	| newDBDatum  |"	Transcript show: 'Creating new data ' , owner fullName, '&gt;&gt;', aName; cr; flush. "	newDBDatum := 		self fromDescriptor: datumDescriptor 			timeStamp: self timeStamp 			trace: oldDBDatum.	( oldDBDatum notNil and: [oldDBDatum sourceCode = newDBDatum sourceCode ] )		ifTrue: [ newDBDatum encodedDataID: oldDBDatum encodedDataID ].	newDBDatum install.	^newDBDatum</body><body package="Store-DB-Subdefs" selector="recordNamed:inOwner:trace:package:">recordNamed: dataKey inOwner: owner trace: oldDBDatum package: aDBPackage	"Answer a record for aDatum. If the trace is identical as aDatum 	answer the trace instead creating a new record."	^( self compare: oldDBDatum key: dataKey in: owner )			ifTrue: [oldDBDatum]			ifFalse: 				[ self					newNamed: dataKey					inOwner: owner					trace: oldDBDatum					package: aDBPackage				]</body></methods><methods><class-id>Store.DataElement class</class-id> <category>private-garbage-collection</category><body package="Store-DB-Subdefs" selector="createIndex">createIndex 	"Create index on methodRef to speed up	garbage collection process."	^self broker createIndexForClass: self</body><body package="Store-DB-Subdefs" selector="dropIndex">dropIndex 	"Drop index on methodRef to speed up	garbage collection process."	^self broker dropIndexForClass: self</body><body package="Store-DB-Subdefs" selector="indexColumnNames">indexColumnNames	^ Array with: 'sourceCodeID'</body><body package="Store-DB-Subdefs" selector="indexName">indexName	^ '_DEF_IDX'</body></methods><methods><class-id>Store.DataElement class</class-id> <category>utilities</category><body package="Store-DB-Subdefs" selector="sortStaticsForLoading:">sortStaticsForLoading: elementCollection	"Answer elementCollection ordered by namespace using class/namespace load order."	| dict ordered |	"First group all the data by class/namespace"	dict := IdentityDictionary new.	elementCollection do:		[ :dataElement | | ns |		( ns := dataElement owner ) == nil			ifTrue: [ 	UnloadableDefinitionError signalWith: dataElement ]			ifFalse: 				[ ( dict at: ns ifAbsentPut: [ OrderedCollection new ] )					add: dataElement.				]		].	ordered := OrderedCollection new: elementCollection size.	( SystemUtils sortForLoading: dict keys ) do:		[ :ns | ordered addAll: ( dict at: ns ) ].	^ordered.</body></methods><methods><class-id>Store.DataElement class</class-id> <category>db-utilities</category><body package="Store-DB-Subdefs" selector="allVersionsNamed:in:">allVersionsNamed: aName in: ownerName	"Given a name of a dataelement answer a collection of all versions 	of the space in the database."	"self allVersionsNamed: 'DataSession' in: TT_DataView absoluteName"	^( self allVersionsNamed: aName )		select: [ :de | de environmentString = ownerName ]</body><body package="Store-DB-Subdefs" selector="selectVersionNamed:">selectVersionNamed: aName	^self shouldNotImplement</body><body package="Store-DB-Subdefs" selector="selectVersionNamed:in:">selectVersionNamed: aName in: ownerName	| list |	list := self allVersionsNamed: aName in: ownerName.	list isEmpty		ifTrue: [ Dialog warn: 'No prior versions'. ^nil ].	list size == 1		ifTrue: [ ^list first ].	 ^Dialog 		choose: 'Choose version...'		fromList: ( list collect: [ :m | m itemString ] ) values: list		lines: 10 cancel: [ ^nil ]		for: nil.</body></methods><methods><class-id>Store.DataElement class</class-id> <category>installation</category><body package="Store-DB-Subdefs" selector="fieldTypes">fieldTypes		"self fieldTypes"	| aDict  |	( aDict := super fieldTypes )		at: 'typeString' put: #Char.	self checkFieldsWith: aDict.	^aDict</body></methods><methods><class-id>Store.RepublishBundleDialog</class-id> <category>interface opening</category><body package="Store-UI" selector="localPostOpenWith:">localPostOpenWith: aBuilder	self items selectionIndexHolder onChangeSend: #newSelection to: self.	self setVisualBlocks.	self items selectionIndex: 1.</body><body package="Store-UI" selector="localRebuild">localRebuild		self setVisualBlocks.</body><body package="Store-UI" selector="windowLabel">windowLabel	^'Republishing &lt;1?package:bundle&gt;: &lt;2s&gt;' 		expandMacrosWith: self pundle isPackage 		with: self pundle name</body></methods><methods><class-id>Store.RepublishBundleDialog</class-id> <category>actions</category><body package="Store-UI" selector="addBundle">addBundle	"Add a bundle to the main bundle contents."	| name version spec |	( name := self chooseBundle ) == nil		ifTrue: [ ^self ].	( version := Bundle selectVersionOf: name ) == nil		ifTrue: [ ^self ].	spec := PublishSpecification dbPundle: version.	spec level: 1.	labelDict := nil.	items list addLast: spec.</body><body package="Store-UI" selector="addPackage">addPackage	"Add a package to the main bundle contents."	| name version spec |	( name := self choosePackage ) == nil		ifTrue: [ ^self ].	( version := Package selectVersionOf: name ) == nil		ifTrue: [ ^self ].	spec := PublishSpecification dbPundle: version.	spec level: 1.	labelDict := nil.	items list addLast: spec.</body><body package="Store-UI" selector="editProperties">editProperties	"Edit the bundles properties"	| bundle fake |	bundle := self pundle.	fake := bundle class imageClass new				name: bundle name, ' ', bundle versionString;				silentProperties: bundle properties;				yourself.	PublishedPackagePropertiesDialog 		on: fake 		postProcessingBlock: [ bundle properties: fake properties ].</body><body package="Store-UI" selector="moveDown">moveDown	"Move the selected item down in the list."	| index |	index := self items selectionIndex.	index &gt;= self items list size  		ifTrue: [ ^nil ].	self swap: index with: index + 1.</body><body package="Store-UI" selector="moveUp">moveUp	"Move the selected item up in the list."	| index |	( index := self items selectionIndex ) == 1		ifTrue: [ ^nil ].	self swap: index with: index - 1.</body><body package="Store-UI" selector="removeItem">removeItem	"Remove the selected item from the list."	| selection |	( selection := self items selection ) = nil		ifTrue: [ ^nil ].	self items selectionIndex == 1		ifTrue: [ ^Dialog warn: 'The bundle itself cannot be removed.' ].	( Dialog confirm: ( 'Remove &lt;1s&gt; from &lt;2s&gt;?' 						expandMacrosWith: selection pundle name 						with: self pundle name ) )		ifFalse: [ ^nil ].	items list remove: selection.	self updateItemList.</body><body package="Store-UI" selector="selectVersion">selectVersion	"Select a new version for an item."	| selection new |	( selection := self items selection ) = nil		ifTrue: [ ^nil ].	self items selectionIndex = 1		ifTrue: [ ^Dialog warn: 'The bundle version cannot be changed' ].	new := selection pundle selectVersion.	new == nil		ifTrue: [ ^nil ].	selection dbPundle: new.	self items list at: self items selectionIndex put: selection.	self updateSelectedItem.	self updateItemList.	self disturb</body></methods><methods><class-id>Store.RepublishBundleDialog</class-id> <category>private</category><body package="Store-UI" selector="chooseBundle">chooseBundle	| string name |	string := ''.	string := Dialog request: 'Enter bundle name' initialAnswer: string for: nil.	string isEmpty 		ifTrue: [ ^nil ].	( name := Bundle chooseNameMatching: string description: 'bundle' ) == nil		ifTrue: [ ^nil ].	^name asString</body><body package="Store-UI" selector="choosePackage">choosePackage	| string name |	string := ''.	string := Dialog request: 'Enter package name' initialAnswer: string for: nil.	string isEmpty 		ifTrue: [ ^nil ].	( name := Package chooseNameMatching: string description: 'package' ) == nil		ifTrue: [ ^nil ].	^name asString</body><body package="Store-UI" selector="choosePundle:prompt:">choosePundle: pundles prompt: prompt	pundles size == 1		ifTrue: [ ^pundles first ].	^Dialog		choose: prompt 		fromList: ( pundles collect: [ :pkg | pkg name ] )		values: pundles		lines: pundles size + 1		cancel: [ nil ]</body><body package="Store-UI" selector="details">details	"Answer a list of ids for individual pundle settings."	^#( moveUp moveDown selectVersion  removeItem )</body><body package="Store-UI" selector="newDetailState">newDetailState	| sub |	( self items list first )		"always using bundle"		publish: self publish value;		blessing: self blessingLevel value;		comment: self blessingComment value;		version: self versionString value;		yourself.	( sub := self subComponentAt: #itemsList ) == nil		ifFalse: [ sub widget updateAt: 1 ].	labelDict := nil.</body><body package="Store-UI" selector="newSelection">newSelection	| sel |	sel := self items selection.	sel == nil		ifFalse:  			[ self setDetailState.			( self items selectionIndex == 1 )				ifTrue: [ self disableDetails ]				ifFalse: [ self enableDetails ]			]		ifTrue: 			[ self disableDetails.			self disablePublishBox			]</body><body package="Store-UI" selector="setDetailState">setDetailState	| sel |	sel := self items list first.		"always using bundle"	self retractDetailInterest. 	self publish value: sel publish.	self blessingLevel value: sel blessing.	self blessingComment value: sel comment.	self versionString value: sel version.	self setDetailInterest</body><body package="Store-UI" selector="swap:with:">swap: anIndex with: bIndex	"Swap two items in the list"	| temp currentSelection |	( anIndex &lt; 2 )  |  ( bIndex &lt; 2 )		ifTrue: [ ^Dialog warn: 'The bundle cannot be demoted' ].	currentSelection := self items selection.	temp := items list at: anIndex.	items list at: anIndex put: ( items list at: bIndex ).	items list at: bIndex put: temp.	"Ensure that the list knows what the proper selection is."	self items selection: currentSelection.	self disturb.</body></methods><methods><class-id>Store.RepublishBundleDialog</class-id> <category>help</category><body package="Store-UI" selector="contentsHelp">contentsHelp^'Move up/down allows you to change the load order of the bundle contents.Select version allow you to replace a version of a component with any previously published versions.Remove allows you to remove a component from the bundle.Add Bundle and Add Package allow you to select a new component version to add to the bundle.'</body></methods><methods><class-id>Store.RepublishBundleDialog</class-id> <category>private-publishing</category><body package="Store-UI" selector="publishFromUserData">publishFromUserData	"Publish pundles contained in the user data list."	| contents coll |	coll := self items list copyFrom: 2 to: items list size.	contents := coll collect: [ :item | item pundle asDBDescription ].	self pundle 		contents: contents;		republishFromUserData: self globalOptions.</body></methods><methods><class-id>Store.RepublishBundleDialog class</class-id> <category>class initialization</category><body package="Store-UI" selector="initialize">initialize	"self initialize "	developmentSpecList := 		OrderedCollection new			add: 'Main'-&gt;#(#mainSpec #mainHelp);			add: 'Contents'-&gt;#(#contentsSpec #contentsHelp);			asArray.	runtimeSpecList := Array new: 1.</body></methods><methods><class-id>Store.RepublishBundleDialog class</class-id> <category>interface opening</category><body package="Store-UI" selector="republishBundle:">republishBundle: aBundle	| bundle coll |	( self validateForPublishing: ( Array with: aBundle ) )		ifFalse: [ ^self ].	bundle := aBundle copy.		"lets leave the real guy alone"	coll := self publishSpecsFrom: bundle.	self new openWith: coll.</body></methods><methods><class-id>Store.RepublishBundleDialog class</class-id> <category>private</category><body package="Store-UI" selector="publishSpecs:forPundle:">publishSpecs: aSpec forPundle: aPundle 	"Set the common items in the user data."	^aSpec initialize; pundle: aPundle; yourself.</body><body package="Store-UI" selector="publishSpecsFrom:">publishSpecsFrom: aBundle  	 ^PublishSpecificationList fromDbBundle: aBundle</body><body package="Store-UI" selector="userData:forPundle:">userData: anUserData forPundle: aPundle 	"Set the common items in the user data."	| mod vString pvString |	mod := false.	pvString := aPundle version.	vString := pvString isEmpty			ifTrue: [ Policies versionPolicy initialVersionForPundle: aPundle ]			ifFalse: [ Policies versionPolicy nextVersion: pvString forPundle: aPundle ].	anUserData 		at: #publish put: mod;		at: #pundle put: aPundle;		at: #comment put: '';		at: #version put: vString;		at: #parentVersion put: pvString;		at: #level put: 0;		at: #modified put: mod;		at: #description put: nil;		at: #blessing put: aPundle blessingLevelNumber.</body><body package="Store-UI" selector="userDataFrom:">userDataFrom: aDbBundle  	| dict coll |	dict := Dictionary new.	self userData: dict forPundle: aDbBundle.	dict 		at: #publish put: true;		at: #modified put: true.	coll := List with: dict.	aDbBundle contents do: 		[ :item | 	| pndl descr |		descr := item.		pndl := descr asDBComponent.		dict := Dictionary new.		self userData: dict forPundle: pndl.		dict at: #description put: descr.		dict at: #level put: 0.		coll add: dict		].	^coll</body></methods><methods><class-id>Store.ModificationSet</class-id> <category>testing</category><body package="Store-Merge" selector="hasBeenApplied">hasBeenApplied		^applied == true</body><body package="Store-Merge" selector="hasConflict">hasConflict	^mods size &gt; 1</body><body package="Store-Merge" selector="isEmpty">isEmpty		^mods isNil or: [mods isEmpty]</body><body package="Store-Merge" selector="isNoop">isNoop	"Check if this modification set is a no-op,	either by virtue of being the same as initial,	or if it is a move to initial, that is removed	from some other package but now is another."	self modificationsDo: 		[ :mod | 		( mod = initial or: 				[ initial existsInPackage and: 					[ mod existsInPackage not and: 						[ initial packageName ~= mod packageName ]]					]		)			ifFalse: [ ^false ]		].	^true</body><body package="Store-Merge" selector="isResolved">isResolved	^resolution notNil</body><body package="Store-Merge" selector="isUnresolved">isUnresolved	^self isResolved not</body></methods><methods><class-id>Store.ModificationSet</class-id> <category>printing</category><body package="Store-Merge" selector="printOn:">printOn: aStream 	super printOn: aStream.	aStream nextPutAll: '(Initial: '.	initial printOn: aStream.	self isEmpty		ifTrue: [aStream nextPutAll: ' empty mods ']		ifFalse: 			[aStream nextPutAll: ' Mods: ['.			mods				do: 					[:mod | 					mod printOn: aStream.					aStream nextPut: $ ].			aStream nextPutAll: '] '].	aStream nextPutAll: ' Resolution: '.	resolution printOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>Store.ModificationSet</class-id> <category>accessing</category><body package="Store-Merge" selector="addMod:">addMod: aMod 	(self matchingMod: aMod) isNil		ifTrue: 			[mods isNil ifTrue: [mods := List new].			aMod = initial				ifTrue: [mods addFirst: aMod]				ifFalse: [mods addLast: aMod]]		ifFalse: 			[duplicateMods isNil ifTrue: [duplicateMods := List new].			duplicateMods addLast: aMod]</body><body package="Store-Merge" selector="firstMod">firstMod	^mods isNil		ifTrue: [nil]		ifFalse: [mods first]</body><body package="Store-Merge" selector="initial">initial	^initial</body><body package="Store-Merge" selector="initial:">initial: initialMod 	initial := initialMod.	mods notNil		ifTrue: 			[| inx |			inx := mods indexOf: initialMod.			inx &gt; 1 ifTrue: [mods addFirst: (mods removeAtIndex: inx)]]</body><body package="Store-Merge" selector="markApplied">markApplied	applied := true.</body><body package="Store-Merge" selector="matchingMod:">matchingMod: aMod	"Check the defintions that are already in modifications for the class. 	If any of them is identical then there is no new conflict."	| currentSource pName |	currentSource := aMod source.	pName := aMod packageName.	currentSource isNil		ifTrue: [self modificationsDo: [:mod | (mod existsInPackage)					ifFalse: [^mod]]]		ifFalse: [self modificationsDo: [:mod | (currentSource = (mod source) and: [pName = mod packageName])					ifTrue: [^mod]]].	^nil</body><body package="Store-Merge" selector="modificationsDo:">modificationsDo: aBlock	mods isNil ifTrue: [^self].	mods do: aBlock</body><body package="Store-Merge" selector="mods:">mods: someMods	mods := someMods</body><body package="Store-Merge" selector="resolution">resolution	^resolution</body><body package="Store-Merge" selector="resolution:">resolution: aResolution 	resolution := aResolution.	(resolution notNil and: [resolution isTextModification])		ifTrue: [applied := true]		ifFalse: [applied := false]</body><body package="Store-Merge" selector="tag">tag	^tag</body><body package="Store-Merge" selector="tag:">tag: aTag	tag := aTag</body></methods><methods><class-id>Store.ModificationSet</class-id> <category>merge tool support</category><body package="Store-Merge" selector="at:">at: index 	^index = 1		ifTrue: [initial]		ifFalse: [index = self size				ifTrue: [resolution]				ifFalse: [mods at: index - ((self initialInMods) ifTrue: [0] ifFalse: [1])]]</body><body package="Store-Merge" selector="explanationOn:">explanationOn: strm 	| modifications |	modifications := preMoveMods isNil				ifTrue: [mods]				ifFalse: [preMoveMods].	strm nextPutAll: tag printString.	self hasConflict		ifTrue: [self isResolved				ifTrue: [strm nextPutAll: ' has conflicts which have been resolved.']				ifFalse: [strm nextPutAll: ' has conflicts which have not yet been resolved.']]		ifFalse: [self isResolved				ifTrue: [strm nextPutAll: ' has no conflicts and has been resolved.']				ifFalse: [strm nextPutAll: ' has no conflicts but has been unresolved.']].	strm cr.	self isResolved		ifTrue: 			[| res |			res := self resolution.			strm nextPutAll: ((modifications size = 1 and: [modifications first = res])					ifTrue: ['Automatic resolution ']					ifFalse: ['Resolution ']).			strm nextPutAll: (res isTextModification					ifTrue: ['was created by textual editing and accept.']					ifFalse: [res isMoveModification							ifTrue: ['is a package move ' , res description , '.']							ifFalse: [res existsInPackage									ifTrue: ['is ' , res description , '.']									ifFalse: ['is the removal of the definition.']]]).			strm cr.			strm nextPutAll: 'Resolution has '.			self hasBeenApplied ifFalse: [strm nextPutAll: 'not yet '].			strm nextPutAll: 'been applied to the working version (image)'.			strm cr].	strm cr.	preMoveMods notNil		ifTrue: 			[strm nextPutAll: 'Package movement was detected, displayed modifications reflect this.'.			strm cr; cr].	self tag existsInImage		ifTrue: 			[| imPkg |			imPkg := self tag containingPackage.			imPkg isNil				ifTrue: [strm nextPutAll: 'Not in a package.']				ifFalse: [strm nextPutAll: 'In package ' , imPkg name , ' in image.']]		ifFalse: [strm nextPutAll: 'Not in image.'].	strm cr; cr.	strm nextPutAll: 'Base version'.	strm cr.	(initial package notNil and: [initial existsInPackage])		ifTrue: [strm nextPutAll: '	- version ' , initial description; cr; nextPutAll: '	- published ' , initial timeStampString , '.']		ifFalse: [strm nextPutAll: '	- does not contain the definition.'].	strm cr.	self initialInMods		ifTrue: 			[strm nextPutAll: (modifications first existsInPackage					ifTrue: ['	- definition was published in version ']					ifFalse: ['	- definition was removed in version ']).			strm nextPutAll: modifications first description; cr.			strm nextPutAll: '	- conflicts with other versions since it is on another line of development.'.			strm cr].	strm cr.	modifications size &gt; 0		ifTrue: 			[strm nextPutAll: 'Modifications:'.			strm cr.			1 to: modifications size				do: 					[:index | 					| mod |					mod := modifications at: index.					strm nextPutAll: '	' , mod description; cr.					strm nextPutAll: '		- published ' , mod timeStampString , '.'; cr.					(index = 1 and: [self initialInMods])						ifTrue: [strm nextPutAll: '		- same as base version'; cr].					strm cr]].	duplicateMods size &gt; 0		ifTrue: 			[strm nextPutAll: 'Duplicate modifications not shown in the versions view:'.			strm cr.			duplicateMods				do: 					[:dmod | 					| match matchDesc |					match := self matchingMod: dmod.					matchDesc := match isNil								ifTrue: ['MATCH MISSING']								ifFalse: [match description].					strm nextPutAll: '	' , dmod description.					strm cr.					strm nextPutAll: '		- published ' , dmod timeStampString.					strm cr.					strm nextPutAll: (dmod existsInPackage							ifTrue: ['		- is a source duplicate of ' , matchDesc , '.']							ifFalse: ['		- like the displayed version ' , matchDesc , ' does not contain the definition.']).					strm cr; cr]]</body><body package="Store-Merge" selector="explanationTrees:">explanationTrees: trees	| strm |	strm := WriteStream on: String new.	self explanationOn: strm.	self explanationTrees: trees on: strm.	^strm contents</body><body package="Store-Merge" selector="explanationTrees:on:">explanationTrees: trees on: strm 	| modifications |	modifications := preMoveMods isNil				ifTrue: [mods]				ifFalse: [preMoveMods].	strm nextPutAll: 'Modification history:'.	strm cr; cr.	trees		do: 			[:treeArray | 			| pname |			pname := treeArray last package name.			((initial package notNil and: [initial package name = pname])				or: [modifications size &gt; 0 and: [(modifications detect: [:mod | mod package name = pname]							ifNone: [nil]) notNil]])				ifTrue: [self treeExplainNode: treeArray last on: strm]]</body><body package="Store-Merge" selector="isIndexForResolution:">isIndexForResolution: index 	^index = self size</body><body package="Store-Merge" selector="labelInView:">labelInView: aView 	| image |	image := resolution isNil				ifTrue: [self class unresolvedBWImage]				ifFalse: [self hasBeenApplied						ifTrue: [self class appliedBWImage]						ifFalse: [self class resolvedBWImage]].	^(LabelAndIcon with: self name attributes: aView textStyle)		icon: image</body><body package="Store-Merge" selector="labelTextForIndex:">labelTextForIndex: anIndex 	"Answer the text for a modification for text view."	| mod |	anIndex = self size		ifTrue: [ ^'Resolution ' , self resolutionLabel ].	anIndex = 1		ifTrue: 			[ ^initial description , '[ Base' , 				( initial existsInPackage ifTrue: [''] ifFalse: [' ABSENT']) , 				( self initialInMods ifTrue: [' CONFLICTING'] ifFalse: [''] ) , ']'			].	mod := self at: anIndex.	^mod description , 		( mod isMoveModification			ifTrue: ['     ']			ifFalse: [ mod existsInPackage						ifTrue: [ '      ' ]						ifFalse: [ '  [ABSENT]  ' ]					]		)</body><body package="Store-Merge" selector="name">name	^self tag name</body><body package="Store-Merge" selector="resolutionLabel">resolutionLabel	| res |	res := self resolution.	^res isNil		ifTrue: ['[UNRESOLVED]']		ifFalse: [res isTextModification				ifTrue: ['[MERGED]']				ifFalse: [res existsInPackage						ifTrue: ['= ' , res description]						ifFalse: ['[REMOVED]']]]</body><body package="Store-Merge" selector="resolutionText">resolutionText	| res |	res := self resolution.	^res isNil		ifTrue: ['*** No resolution specified ***']		ifFalse: 			[| src |			src := res source.			src isNil				ifTrue: ['*** Resolved as removal ***']				ifFalse: [src]]</body><body package="Store-Merge" selector="size">size	^mods size + ((self initialInMods) ifTrue: [1] ifFalse: [2])</body><body package="Store-Merge" selector="sourceTextForImage">sourceTextForImage	^self tag sourceTextForImage</body><body package="Store-Merge" selector="textForIndex:">textForIndex: anIndex 	| mod src |	anIndex = self size ifTrue: [^self resolutionText].	mod := self at: anIndex.	src := mod source.	^src isNil		ifTrue: ['*** Absent from this package ***']		ifFalse: [src]</body><body package="Store-Merge" selector="treeExplainNode:on:">treeExplainNode: aNode on: strm 	| pkg modifications |	modifications := preMoveMods isNil				ifTrue: [mods]				ifFalse: [preMoveMods].	aNode level timesRepeat: [strm nextPutAll: '   '].	pkg := aNode package.	strm nextPutAll: pkg itemString , '    '.	initial package = pkg ifTrue: [strm nextPutAll: '-- Base version    '].	modifications do: [:mod | mod package = pkg ifTrue: [strm nextPutAll: (mod existsInPackage					ifTrue: ['-- Modification']					ifFalse: ['-- Removal'])]].	duplicateMods size &gt; 0 ifTrue: [duplicateMods do: [:mod | mod package = pkg ifTrue: [strm nextPutAll: (mod existsInPackage						ifTrue: 							[| match matchDesc |							match := self matchingMod: mod.							matchDesc := match isNil										ifTrue: ['MATCH MISSING']										ifFalse: [match description].							'-- Same as ' , matchDesc]						ifFalse: ['-- Removal'])]]].	strm cr.	aNode children do: [:kid | self treeExplainNode: kid on: strm]</body></methods><methods><class-id>Store.ModificationSet</class-id> <category>actions</category><body package="Store-Merge" selector="analyzeMods">analyzeMods	self isEmpty		ifTrue: 			[tag := initial notNil						ifTrue: [initial tag]						ifFalse: [nil].			resolution := initial]		ifFalse: 			[mods size &gt; 1				ifTrue: 					[self analyzePackageMoves.					resolution := (mods size &gt; 1)								ifTrue: [nil]								ifFalse: [mods first]]				ifFalse: [resolution := mods first].			tag := mods first tag]</body><body package="Store-Merge" selector="analyzePackageMoves">analyzePackageMoves	"Determine if movement from one package to another should be 	considered for these modifications.  If so, add a modification that	moves the initial to any other packages.  If the definition has been	removed from all packages include a remove as an option.  For	each modification that is not a remove, provide an option for it to	be in any of the packages.  Replace the previous modifications	with the newly constructed ones."	| ipn nmods pnames remNames uniqueMods |	self isEmpty ifTrue: [^self].	ipn := initial packageName.	pnames := Set new.	remNames := Set new.	initial existsInPackage		ifTrue: [pnames add: ipn]		ifFalse: [remNames add: ipn].	mods do: [:mod | mod existsInPackage			ifTrue: [pnames add: mod packageName]			ifFalse: [remNames add: mod packageName]].	pnames size &lt;= 1 ifTrue: [^self].	nmods := OrderedCollection new.	(initial existsInPackage and: [self initialInMods not]) ifTrue: [		pnames do: [:pname | pname ~= ipn ifTrue: [			nmods add: (MoveModification new modification: initial packageName: pname)]]].	pnames detect: [:pname | (remNames includes: pname) not]		ifNone: [nmods add: (mods detect: [:mod | mod existsInPackage not])].	uniqueMods := OrderedCollection new.	mods do: [:mod | 		| src |		src := mod source.		mod existsInPackage ifTrue: [			initial source = src ifFalse: [				uniqueMods detect: [:umod | umod source = src] ifNone: [uniqueMods add: mod]]]].	(uniqueMods isEmpty and: [nmods isEmpty and: [initial existsInPackage]]) ifTrue: [uniqueMods add: initial].	uniqueMods do: [:mod |			pnames do: [:pname | 				nmods add: (MoveModification new modification: mod packageName: pname)]].	preMoveMods := mods.	self mods: nmods</body></methods><methods><class-id>Store.ModificationSet</class-id> <category>private</category><body package="Store-Merge" selector="initialInMods">initialInMods	^mods notNil and: [initial = mods first]</body></methods><methods><class-id>Store.ModificationSet class</class-id> <category>utilities</category><body package="Store-Merge" selector="environmentOrder:">environmentOrder: mods 	"Sort all of the namespaces in the list into a collection where no namespace is 	preceded by a dependant. 	I cannot use method in the SysUtils since the namespaces are not in the image"	| oc newMods names |	oc := mods copy.	newMods := OrderedCollection new: mods size.	[ oc isEmpty ] whileFalse: 		[ names := oc collect: [ :each | each record name ].		oc copy do: 			[ :each | 			( names includes: each record environmentString )				ifFalse: 					[ newMods add: each.					oc remove: each					]			]	].	^newMods</body><body package="Store-Merge" selector="sortForLoading:">sortForLoading: mods 	"Sort modification into a collection where NameSpaces are defined first and are  proceeded by their	environment and no class is preceded by a subclass or by its metaclass and methods are at the end. 	I cannot use method in the SysUtils since the namespaces/classes are not in the image"	| nameSpaceMods nameSpaceRemoves  classMods classRemoves sortedMods methodMods datumMods |	nameSpaceMods := mods select: [ :md| md tag isNameSpaceTag ].	nameSpaceRemoves := nameSpaceMods select: [ :md | md existsInPackage not ].	nameSpaceMods := nameSpaceMods select: [ :md | md existsInPackage ].	sortedMods := self environmentOrder: nameSpaceMods.	sortedMods addAll: ( mods select: [ :md| md tag isNameSpaceCommentTag ] ).	classMods := mods select: [ :md | md tag isClassTag ].	classRemoves := classMods select: [ :md | md existsInPackage not ].	classMods := classMods select: [ :md | md existsInPackage ].	sortedMods addAll: ( self superclassOrder: ( classMods select: [ :md | md tag isMeta not ] ) ).	sortedMods addAll: ( self superclassOrder: ( classMods select: [ :md | md tag isMeta ] ) ).	sortedMods addAll: ( mods select: [ :md| md tag isClassCommentTag ] ).	sortedMods addAll: nameSpaceRemoves.	sortedMods addAll: classRemoves.	methodMods := mods select: [ :md | md tag isMethodTag ].	sortedMods addAll: ( self sortMethodModifications: ( methodMods select: [ :md | md existsInPackage ] ) ).	sortedMods addAll: ( methodMods select: [ :md | md existsInPackage not ] ).	datumMods := mods select: [ :md | md tag isDataTag ].	sortedMods addAll: (datumMods select: [ :md | md existsInPackage ] ).	sortedMods addAll: (datumMods select: [ :md | md existsInPackage not ] ).	sortedMods addAll: ( mods select: [ :md | md tag isComponentTag ] ).	^sortedMods</body><body package="Store-Merge" selector="sortMethodModifications:">sortMethodModifications: aCollection 	"Make sure that all method that contain c type 	declaration are moved to the front."	| cTypes other |	cTypes := aCollection select: [:mod | mod record version = 'CTYPE'].	other := aCollection select: [:mod | (mod record version = 'CTYPE') not].	^cTypes , other</body><body package="Store-Merge" selector="superclassOrder:">superclassOrder: classMods 	"Sort all of the classes in the list into a collection where no class is 	preceded by a subclass or by its metaclass." 	"NOTE: we cannot use method in the SysUtils since the classes are not in 	the image"	| oc newMods classNames |	oc := classMods copy.	newMods := OrderedCollection new: classMods size.	[ oc isEmpty ]		whileFalse: 			[ classNames := oc collect: [ :each | each record absoluteName ].			oc copy do: 				[ :each | 				( classNames includes: each record instanceBehavior superclass )					ifFalse: 						[ newMods add: each.						oc remove: each						]				]			].	^newMods</body></methods><methods><class-id>Store.ModificationSet class</class-id> <category>instance creation</category><body package="Store-Merge" selector="tag:initial:">tag: aTag initial:  theInitial 	^(self new) tag: aTag; initial: theInitial; yourself</body></methods><methods><class-id>Store.PackageChanges</class-id> <category>private</category><body package="Store-Change Management" selector="addDataChanges">addDataChanges	"Add data changes to the change sets."			| chg datum2 |	pundle2 isLoaded		ifFalse: [ pundle2 dataWithSource ].	"cache sources"	pundle1 dataWithSource do:		[ :datum | 		chg := Change new dataKey: datum dataKey.		datum isInClass			ifTrue: [ chg classSymbol: datum absoluteOwnerName asSymbol ]			ifFalse: [ chg nameSpaceSymbol: datum absoluteOwnerName asSymbol ].		chg dataKey: datum dataKey.		( self pundle2 includesDatum:  datum )			ifTrue:				[ datum2 := self pundle2 datum: datum dataKey forOwnerNamed: datum absoluteOwnerName.				( datum sourceMatches: datum2 )					ifFalse: 						[ changeSet1 doSubdefChange: chg change.						changeSet2 doSubdefChange: chg change.						].				]			ifFalse: 				[ changeSet1 doSubdefChange: chg add.				changeSet2 doSubdefChange: chg remove.				].		IncrementNotification raiseSignal.		].	pundle2 data do:		[ :datum |  | ownerName |		ownerName := datum ownerName.		( pundle1 includesDatum: datum )			ifFalse: 				[ chg := Change new dataKey: datum dataKey.				datum isInClass					ifTrue: [ chg classSymbol: ownerName ]					ifFalse: [ chg nameSpaceSymbol: ownerName ].				changeSet2 doSubdefChange: chg add.				changeSet1 doSubdefChange: chg remove.				].		]</body><body package="Store-Change Management" selector="addDefClassChanges">addDefClassChanges	"Add def class changes to the change sets."	| chg cls2 |	pundle2 isLoaded		ifFalse: [ pundle2 classesWithSource ].		"cache definitions"	pundle1 classesWithSource do:		[ : cls1 |		chg := Change new classSymbol: cls1 absoluteName.		( pundle2 includesClassNamed: cls1 absoluteName )			ifFalse: 				[ changeSet1 doClassChange: chg add.				changeSet2 doClassChange: chg removeDefinition.				]			ifTrue: 				[ cls2 := pundle2 classInPackageNamed: cls1 absoluteName meta: false. 				( cls1 primaryKey = cls2 primaryKey )					ifFalse:						[ cls1 definition =  cls2 definition							ifFalse: 								[ changeSet1 doClassChange: chg change.								changeSet2 doClassChange: chg change.								].						( cls1 comment string equalsAcrossPlatforms:  cls2 comment string )							ifFalse: 								[ changeSet1 doClassChange: chg comment.								changeSet2 doClassChange: chg comment.								].						]				].		IncrementNotification raiseSignal.		].	pundle2 classesDefinedInPackage do:		[ : cls |		( pundle1 includesClassNamed: cls absoluteName )			ifFalse: 				[ chg := Change new classSymbol: cls absoluteName.				changeSet2 doClassChange: chg add.				changeSet1 doClassChange: chg removeDefinition.				].		].</body><body package="Store-Change Management" selector="addDefClassChangesPublished">addDefClassChangesPublished	"Add def class changes to the change sets from two published packages."	| chg cls2 classes1 classes2 |	classes1 := ( ClassRecord allInPackage: pundle1 primaryKey butNotIn: pundle2 primaryKey ).	classes2 := ( ClassRecord allInPackage: pundle2 primaryKey butNotIn: pundle1 primaryKey ).	classes1 do:		[ : cls1 |		chg := Change new classSymbol: cls1 absoluteName.		( cls2 := classes2 detect: [ :cls | cls1 quickComparesTo: cls ] ifNone: [ nil] ) == nil			ifTrue: 				[ changeSet1 doClassChange: chg add.				changeSet2 doClassChange: chg removeDefinition.				]			ifFalse:				[ classes2 remove: cls2.				cls1 definition =  cls2 definition					ifFalse: 						[ changeSet1 doClassChange: chg change.						changeSet2 doClassChange: chg.						].				cls1 comment string =  cls2 comment string					ifFalse: 						[ changeSet1 doClassChange: chg comment.						changeSet2 doClassChange: chg.						].				].		IncrementNotification raiseSignal.		].	classes2 do:		[ : cls |		chg := Change new classSymbol: cls absoluteName.		changeSet2 doClassChange: chg add.		changeSet1 doClassChange: chg removeDefinition.		IncrementNotification raiseSignal.		].</body><body package="Store-Change Management" selector="addDefNameSpaceChanges">addDefNameSpaceChanges	"Add def namespace changes to the change sets."	| chg ns2 |	pundle2 isLoaded		ifFalse: [ pundle2 nameSpacesWithSource ].		"cache definitions"	pundle1 nameSpacesWithSource do:		[ : ns1 |		chg := Change new nameSpaceSymbol: ns1 absoluteName.		( ns2 := pundle2 nameSpaceInPackageNamed: ns1 absoluteName ) ~~ nil			ifTrue: 				[ ns1 definition =  ns2 definition					ifFalse: 						[ changeSet1 doNameSpaceChange: chg change.						changeSet2 doNameSpaceChange: chg change.						].				( ns1 comment equalsAcrossPlatforms:  ns2 comment )					ifFalse: 						[ changeSet1 doNameSpaceChange: chg comment.						changeSet2 doNameSpaceChange: chg comment.						].				]			ifFalse: 				[ changeSet1 doNameSpaceChange: chg add.				changeSet2 doNameSpaceChange: chg removeDefinition.				].		IncrementNotification raiseSignal.		].	pundle2 nameSpacesDefinedInPackage do:		[ : cls |		( pundle1 includesNameSpaceNamed: cls absoluteName )			ifFalse: 				[ chg := Change new nameSpaceSymbol: cls absoluteName.				changeSet2 doNameSpaceChange: chg add.				changeSet1 doNameSpaceChange: chg removeDefinition.				].		].</body><body package="Store-Change Management" selector="addDefNameSpaceChangesPublished">addDefNameSpaceChangesPublished	"Add def class changes to the change sets from two published packages."	| chg ns2 namespaces1 namespaces2 |	namespaces1 := ( NameSpaceRecord allInPackage: pundle1 primaryKey butNotIn: pundle2 primaryKey ).	namespaces2 := ( NameSpaceRecord allInPackage: pundle2 primaryKey butNotIn: pundle1 primaryKey ).	namespaces1 do:		[ : ns1 |		chg := Change new classSymbol: ns1 absoluteName.		( ns2 := namespaces2 detect: [ :ns | ns1 quickComparesTo: ns ] ifNone: [ nil] ) == nil			ifTrue: 				[ changeSet1 doNameSpaceChange: chg add.				changeSet2 doNameSpaceChange: chg removeDefinition.				]			ifFalse:				[ namespaces2 remove: ns2.				ns1 definition =  ns2 definition					ifFalse: 						[ changeSet1 doNameSpaceChange: chg change.						changeSet2 doNameSpaceChange: chg.						].				( ns1 comment string equalsAcrossPlatforms: ns2 comment string )					ifFalse: 						[ changeSet1 doNameSpaceChange: chg comment.						changeSet2 doNameSpaceChange: chg.						].				].		IncrementNotification raiseSignal.		].	namespaces2 do:		[ : ns |		chg := Change new classSymbol: ns absoluteName.		changeSet2 doClassChange: chg add.		changeSet1 doClassChange: chg removeDefinition.		IncrementNotification raiseSignal.		].</body><body package="Store-Change Management" selector="addMethodChanges">addMethodChanges	"Add method changes to the change sets."			| chg meth2 |	pundle2 isLoaded		ifFalse: [ pundle2 methodsWithSource ].		"to cache sources"	pundle1 methodsWithSource do:		[ :meth |		chg := Change new classSymbol: meth classNameWithMeta; selector: meth selector.		( pundle2 includesMethod: meth )			ifFalse: 				[ changeSet1 doSubdefChange: chg add.				changeSet2 doSubdefChange: chg remove.				]			ifTrue:				[ meth2 := pundle2 method: meth selector forClassNamed: meth absoluteClassName meta: meth isMeta.				( meth primaryKey = meth2 primaryKey )					ifFalse:						[ ( meth sourceMatches: meth2 )							ifFalse: 								[ changeSet1 doSubdefChange: chg change.								changeSet2 doSubdefChange: chg change.								].						]				].		IncrementNotification raiseSignal.		].	pundle2 methods do:		[ :meth |		( pundle1 includesMethod: meth )			ifFalse: 				[ chg := Change new classSymbol: meth className; selector: meth selector.				changeSet2 doSubdefChange: chg add.				changeSet1 doSubdefChange: chg remove.				].		]</body><body package="Store-Change Management" selector="calcuateChanges">calcuateChanges	 ( pundle1 isLoaded or: [ pundle2 isLoaded ] )		ifTrue: 			[ self addDefClassChanges.			self addDefNameSpaceChanges.			self addMethodChanges.				self  addDataChanges.			self addOtherChanges			] 		ifFalse: [ self fromPackageDifferences: ( PackageDifferences with: pundle1 with: pundle2 ) ]</body></methods><methods><class-id>Store.PackageChanges</class-id> <category>accessing</category><body package="Store-Change Management" selector="calcItemCount">calcItemCount	"Answer a count for time to calculate changes."	^pundle1 itemCount.</body><body package="Store-Change Management" selector="itemCount">itemCount	^changeSet1 itemCount.</body></methods><methods><class-id>Store.PackageChanges</class-id> <category>fileout</category><body package="Store-Change Management" selector="fileOutChangesFor:within:on:">fileOutChangesFor: id within: aBundle on: stream	| pkg |	pkg := self pundleFor: id.	( ( UISettings preferenceFor: #fileoutOption ) == #never )		ifFalse:			[ 			stream sourceFormatter				attributeFor: #package compute: [ : obj | pkg name ];				attributeForMethods: #package compute: [ :cls :sel | pkg name ].			pkg fileOutProperties: ( self changedPropertiesFor: id ) on: stream.			].	 ( self changeSetFor: id )  fileOutOn: stream for: pkg within: aBundle.</body></methods><methods><class-id>Store.PackageChanges class</class-id> <category>instance creation</category><body package="Store-Change Management" selector="fromPackageDifferences:">fromPackageDifferences: pkgDiffs	^self basicNew fromPackageDifferences: pkgDiffs.</body></methods><methods><class-id>Store.ClassViewTabApplication</class-id> <category>componentBuilding</category><body package="Store-UI-Browser" selector="buildComponentArray">buildComponentArray	components := List new		add: self classesComponent;		add: self packageComponent;		add: self protocolsComponent;		add: self methodsComponent;		yourself.	self linkComponentsInArray: components.	self linkFirstComponentToSubcanvas.</body><body package="Store-UI-Browser" selector="componentId">componentId	^#classPackageTab</body></methods><methods><class-id>Store.ClassViewTabApplication</class-id> <category>initialization</category><body package="Store-UI-Browser" selector="initialize">initialize	super initialize. 	packageFilter := true.</body><body package="Store-UI-Browser" selector="initializeForClassNameSpaceView">initializeForClassNameSpaceView	components := List new		add: self classesComponent;		add: self packageComponent;		 add: self protocolsComponent;		add: self methodsComponent;		yourself.	self linkComponentsInArray: components.	self browser updateLists</body><body package="Store-UI-Browser" selector="initializeForClassOrNameSpace:">initializeForClassOrNameSpace: aClassOrNameSpace	aClassOrNameSpace isForClass 		ifTrue: [ aClassOrNameSpace meta: false ].	self  browser setModelFor: #default to:  aClassOrNameSpace.	components := List new		add: self packageComponent;		add: self protocolsComponent;		add: self methodsComponent;		yourself.	self linkComponentsInArray: components.	components first 		updateList.</body><body package="Store-UI-Browser" selector="initializeForClassOrNameSpaces:">initializeForClassOrNameSpaces: aCollectionOfClassOrNameSpaces	aCollectionOfClassOrNameSpaces do:		[ :cd | cd isForClass ifTrue: [ cd meta: false ] ].	classList := aCollectionOfClassOrNameSpaces.	components := List new		add: self classesComponent;		add: self packageComponent;		add: self protocolsComponent;		add: self methodsComponent;		yourself.	self linkComponentsInArray: components.	components first 		updateList.</body></methods><methods><class-id>Store.ClassViewTabApplication</class-id> <category>lists</category><body package="Store-UI-Browser" selector="allPackages">allPackages	"Answer only packages that have something in the selected	class or namespace."	| cns |	cns := self browser selectedClassOrNameSpaceFor: #default.	^cns == nil		ifTrue: [ OrderedCollection new ]		ifFalse: [ self manager packagesContaining: cns ]</body><body package="Store-UI-Browser" selector="generateMethodsFor:">generateMethodsFor: id	"Answer a method/data List for the id. "	| cns pkgs forData newList name protocols |	cns := self browser selectedModelFor: id.	pkgs := self packagesFor: cns id: id.	protocols  := browser selectedProtocolFor: id.	newList := OrderedCollection new.	( cns == nil or: [ protocols == nil or: [ protocols isEmpty ] ] )		ifTrue: [ ^newList ].	forData := ( self browser selectedModelFor: id ) isForNameSpace or: [ self browser isData ].	name := cns absoluteName.	pkgs do:		[ :pkg |		( forData			ifTrue: [protocols do: [:protocol |  newList addAll: (pkg dataForNamed: name andProtocol: protocol) ]]			ifFalse: 				[protocols do: 					[:protocol |		 			newList addAll: (pkg methodsForClassNamed: name andProtocol: protocol meta: browser isMeta)] 				]			)		]. 	^( newList asSortedCollection: [ :a :b  | a name &lt; b name ] ) asOrderedCollection.</body><body package="Store-UI-Browser" selector="generateNameSpaceClassListFor:">generateNameSpaceClassListFor: selectionId	^classList == nil		ifTrue: 			[ self manager definitionModels collect: 				[ :model | model asDescription ]			]		ifFalse: [ classList ].</body><body package="Store-UI-Browser" selector="packagesFor:id:">packagesFor: aModel id: id	^Array with: ( self browser selectedPackageFor: id )</body></methods><methods><class-id>Store.ClassViewTabApplication</class-id> <category>accessing</category><body package="Store-UI-Browser" selector="classPane">classPane	^components first helpers first</body><body package="Store-UI-Browser" selector="label">label	^'Package Classes View'</body></methods><methods><class-id>Store.ClassViewTabApplication</class-id> <category>accessing subcanvases</category><body package="Store-UI-Browser" selector="getCanvas">getCanvas	| module |	module := self classesComponent.	module	browser: self browser.	^module</body></methods><methods><class-id>Store.ClassViewTabApplication</class-id> <category>testing</category><body package="Store-UI-Browser" selector="isClassCentric">isClassCentric	^components first selection ~~ nil</body></methods><methods><class-id>OS.Filename</class-id> <category>utilities</category><body package="Store-Base" selector="contentsOfEntireBinaryFile">contentsOfEntireBinaryFile	"Answer the contents of a binary file represented by the receiver."	| stream |	stream := self readStream binary.	^[ stream contents ] 		ensure: [ stream close ]</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>private-compiling</category><body package="Store-Base" selector="compileWithoutUsingChangeFile:classified:notifying:attributes:">compileWithoutUsingChangeFile: code classified: heading notifying: requestor attributes: attributes 	| selector srcs |	self 		compile: code		notifying: requestor		attributes: attributes		selectorBlock: 			[:sel :oldMeth | 			selector := sel.			srcs := oldMeth == nil 						ifTrue: [MethodSourceCollection new]						ifFalse: [oldMeth methodSources copy]]		ifFail: [^nil].	srcs source: code.	(methodDict at: selector) sourcePointer: srcs.	self organization classify: selector under: heading.	^selector</body></methods><methods><class-id>Tools.NamedChangeSet</class-id> <category>binary storage</category><body package="Store-Base" selector="binoutOn:">binoutOn: outputStream	self timeStampFileOut.	outputStream nextPutPackage: self</body></methods><methods><class-id>Core.Object</class-id> <category>tt-utilities</category><body package="Store-Base" selector="debugVersionOnly">debugVersionOnly	"Senders of this method should be present	in the development version only."</body><body package="Store-Base" selector="defunct">defunct	"Place 'self defunct' at the beginning of methods which shouldn't be called any more."	self halt: 'Defunct method called.'</body><body package="Store-Base" selector="needsMoreWork">needsMoreWork	"Senders of this method require redesign.."</body><body package="Store-Base" selector="textRepresentation">textRepresentation	^self printString.</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>comparing</category><body package="Store-Base" selector="equalsAcrossPlatforms:">equalsAcrossPlatforms: aCharacterArray 	"Answer whether the argument and the receiver's size is the same as aCharacterArray's size, 	and each of the receiver's elements equal the corresponding element of aCharacterArray."	| eofs |	aCharacterArray isCharacters ifFalse: [ ^false ].	self size = aCharacterArray size ifFalse: [ ^false ].	eofs := Array with: Character lf with: Character cr with: ( Character value: 11 ).	self with: aCharacterArray do:		[ :char1 :char2 | 		char1 =  char2 			ifFalse: 				[ ( ( eofs includes: char1 ) and: [ eofs includes: char2 ] )					ifFalse: [ ^false ]				]		].	^true</body></methods><methods><class-id>Core.True</class-id> <category>tt-utilities</category><body package="Store-DB-BaseObjects" selector="textRepresentation">textRepresentation	^'T'</body></methods><methods><class-id>Core.Boolean class</class-id> <category>tt-utilities</category><body package="Store-DB-BaseObjects" selector="fromText:">fromText: aString	^( aString first = $T  ) | ( aString first = $t )</body></methods><methods><class-id>Core.False</class-id> <category>tt-utilities</category><body package="Store-DB-BaseObjects" selector="textRepresentation">textRepresentation	^'F'</body></methods><methods><class-id>Kernel.CodeComponent class</class-id> <category>signals</category><body package="Store-Database" selector="errorSignals">errorSignals	^Store.DbRegistry errorSignals</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>store-utilities</category><body package="Store-Database" selector="errorSignals">errorSignals	^self class errorSignals</body></methods><methods><class-id>Database.ExternalDatabaseConnection class</class-id> <category>accessing</category><body package="Store-DB-Broker" selector="storeBroker">storeBroker	^self subclassResponsibility</body></methods><methods><class-id>Database.ExternalDatabaseConnection</class-id> <category>private-accessing</category><body package="Store-DB-Broker" selector="nilParams">nilParams</body></methods><methods><class-id>Database.ExternalDatabaseConnection</class-id> <category>accessing</category><body package="Store-DB-Broker" selector="storeBroker">storeBroker	"Answer a broker for Store"	^self class storeBroker</body></methods><methods><class-id>Database.ExternalDatabaseSession</class-id> <category>private-accessing</category><body package="Store-DB-Broker" selector="cursor:">cursor: anObj</body></methods><methods><class-id>Database.ConnectionDialog class</class-id> <category>store</category><body package="Store-DB-Broker" selector="connection">connection	"Answer the opened connection or nil if the dialog was cancelled."	LastUsedProfile == nil		ifTrue: [ LastUsedProfile := ConnectionProfile new ].	^self openConnectionUsing: LastUsedProfile.</body><body package="Store-DB-Broker" selector="openConnectionUsing:">openConnectionUsing: aProfile	"Open the dialog with aProfile and then open the database connection that was selected.	Answer the opened connection or nil if the dialog was cancelled."	| profile connection |	profile := aProfile.	[ ( profile := self openProfile: profile ) == nil		ifTrue: [ ^nil ].	connection := self connect: profile.	connection == nil.	] whileTrue.	^connection.</body><body package="Store-DB-Broker" selector="openProfile:">openProfile: aProfile	"Open the connection dialog. After it is closed answer either the	connection profile with parameters selected by the user if it was accepted	or nil if the dialog was cancelled."	| instance |	instance := self new.	instance currentProfile: aProfile copy.	^instance open		ifTrue: [ instance currentProfile ]		ifFalse: [ nil ]</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>compiling</category><body package="Store-DB-Subdefs" selector="compileWithoutStoringSource:classified:">compileWithoutStoringSource: code classified: heading 	"Compile the argument, code, as source code in the context of the receiver and	install the result in the receiver's method dictionary under the classification 	indicated by the second argument, heading. nil is to be notified if an error occurs.	The argument code is either a string or an object that converts to a string or a	PositionableStream on an object that converts to a string.	Do not store source code in the changes file."	| selector |	selector := self				compile: code				notifying: nil				ifFail: [^nil].	self organization classify: selector under: heading.	^selector</body></methods><methods><class-id>Kernel.Override class</class-id> <category>management</category><body package="Store-ImageModel" selector="removeOverridesForClassOrNameSpaceDefinition:in:">removeOverridesForClassOrNameSpaceDefinition: aClassOrNameSpace in: aComponent	"Remove the override for a class or namespace definition in aComponent." 	| override |	override := ( self overriddenClassesAndNameSpaces at: aClassOrNameSpace ifAbsent: [ ^self ] ) detect:		[ :over | over includesSource: aComponent ] ifNone: [ ^self ]. 	override purge</body></methods><methods><class-id>Kernel.Override</class-id> <category>store</category><body package="Store-ImageModel" selector="addDiffTo:into:">addDiffTo: aDbPackage into: diff	"Add the appropiate diff to a difference holder."	"NOTE: called after other diffs have been calculated, so got to clean out db version."	| dbVersion |	( dbVersion := self dbVersionFrom: aDbPackage ) == nil		ifTrue: [ ^( self diffs: diff side: 2 ) add: self ].		( dbVersion sourceMatches: self )		ifTrue: [ ( self diffs: diff side: 1 ) remove: dbVersion ifAbsent: [ ] ]		ifFalse: 			[ ( self diffs: diff side: 1 ) add: dbVersion.			( self diffs: diff side: 2 ) add: self.			].</body><body package="Store-ImageModel" selector="dbVersionFrom:">dbVersionFrom: aDbPackage	"Answer a the db record from aDbPackage that the receiver represents or nil if not in aDbPackage."	self subclassResponsibility</body><body package="Store-ImageModel" selector="diffs:side:">diffs: diffs side: side	"Answer the subset of diffs that relate to the receiver for side."	self subclassResponsibility</body><body package="Store-ImageModel" selector="moveToPackage:">moveToPackage: aPackage	"Utility method that moves the current defintion to a package."	self subclassResponsibility.</body><body package="Store-ImageModel" selector="myClass">myClass    ^self implementingClass</body><body package="Store-ImageModel" selector="prerequisitesForLoading">prerequisitesForLoading	^self object prerequisitesForLoading.		"best we can do"</body><body package="Store-ImageModel" selector="primaryKey">primaryKey	^0</body><body package="Store-ImageModel" selector="sourceMatches:">sourceMatches: anObject		"Answer wheter the source matches."		"defer, since db defs and img models already know how."	^anObject sourceMatches: self.</body></methods><methods><class-id>Kernel.OverridenNameSpace</class-id> <category>store</category><body package="Store-ImageModel" selector="dbVersionFrom:">dbVersionFrom: aDbPackage	"Answer a the db record from aDbPackage that the receiver represents or nil if not in aDbPackage."	^aDbPackage nameSpaceInPackageNamed: self absoluteName</body><body package="Store-ImageModel" selector="definitionAndComment">definitionAndComment	^Store.NameSpaceRecord mergeDefinition: self text andComment: self comment</body><body package="Store-ImageModel" selector="diffs:side:">diffs: diffs side: side	"Answer the subset of diffs that relate to the receiver for side."	^diffs nameSpacesSide: side</body></methods><methods><class-id>Kernel.OverridenClass</class-id> <category>store</category><body package="Store-ImageModel" selector="dbVersionFrom:">dbVersionFrom: aDbPackage	"Answer a the db record from aDbPackage that the receiver represents or nil if not in aDbPackage."	^aDbPackage 		classInPackageNamed: self absoluteName 		meta: self isMeta</body><body package="Store-ImageModel" selector="definitionAndComment">definitionAndComment	^Store.ClassRecord mergeDefinition: self text andComment: self comment</body><body package="Store-ImageModel" selector="diffs:side:">diffs: diffs side: side	"Answer the subset of diffs that relate to the receiver for side."	^self isMeta		ifTrue: [ diffs metaSide: side ]		ifFalse: [ diffs classesSide: side ]</body></methods><methods><class-id>Kernel.OverridenMethod</class-id> <category>store</category><body package="Store-ImageModel" selector="dbVersionFrom:">dbVersionFrom: aDbPackage	"Answer a the db record from aDbPackage that the receiver represents or nil if not in aDbPackage."	^aDbPackage 		method: self selector 		forClassNamed: self implementingClass absoluteName 		meta: self isMeta</body><body package="Store-ImageModel" selector="diffs:side:">diffs: diffs side: side	"Answer the subset of diffs that relate to the receiver for side."	^diffs methodsSide: side</body><body package="Store-ImageModel" selector="moveToPackage:">moveToPackage: aPackage	"Utility method that moves the current defintion to a package."	#{XChangeSet} ifDefinedDo:		[ :xs | xs current moveSelector: self selector class: self owner toPackage: aPackage ]</body><body package="Store-ImageModel" selector="myClass">myClass	"Answer ther receiver's class. Compatibility."	^self implementingClass</body></methods><methods><class-id>Store.Model</class-id> <category>testing</category><body package="Store-ImageModel" selector="isForFile">isForFile	^false</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Store-ImageModel" selector="isDataModel">isDataModel	"Is this a Bernstein data model?"	^false</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>store</category><body package="Store-ImageModel" selector="dbVersionFrom:">dbVersionFrom: aDbPackage	"Answer a the db record from aDbPackage that the receiver represents or nil if not in aDbPackage."	^aDbPackage 		datum: self name		forNamed: self owner absoluteName</body><body package="Store-ImageModel" selector="diffs:side:">diffs: diffs side: side	"Answer the subset of diffs that relate to the receiver for side."	^diffs dataSide: side</body><body package="Store-ImageModel" selector="moveToPackage:">moveToPackage: aPackage	"Utility method that moves the current defintion to a package."	#{XChangeSet} ifDefinedDo:		[ :xs | xs current moveDataKey: self dataKey owner: self owner toPackage: aPackage ]</body><body package="Store-ImageModel" selector="sourceMatches:">sourceMatches: aDatum		"Answer wheter the source matches."	^self text equalsAcrossPlatforms: aDatum definition</body></methods><methods><class-id>Store.NameSpaceDescriptor</class-id> <category>converting</category><body package="Store-IMG-Records" selector="asCommentTag">asCommentTag	"Answer an instance of NameSpaceCommentTag"	^NameSpaceCommentTag newNameSpaceName: self absoluteName</body><body package="Store-IMG-Records" selector="asTag">asTag	"Answer an instance of TT_NameSpaceTag"	^NameSpaceTag newNameSpaceName: self absoluteName</body></methods><methods><class-id>Store.NameSpaceDescriptor</class-id> <category>accessing</category><body package="Store-IMG-Records" selector="definitionAndComment">definitionAndComment	| ns |	(ns := self nameSpace) == nil		ifTrue: [ ^'' ]		ifFalse: [ ^NameSpaceRecord mergeDefinition: ns definition andComment: ns comment ]</body></methods><methods><class-id>Store.NameSpaceDescriptor</class-id> <category>comparing</category><body package="Store-IMG-Records" selector="sameAsDBThing:">sameAsDBThing: aNameSpace	^aNameSpace sameAsImThing: self</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>store utils</category><body package="Store-IMG-Records" selector="definitionOf:ifAbsent:">definitionOf: aSymbol ifAbsent: aBlock	| binding |	( binding := self bindingFor: aSymbol ) == nil		ifTrue: [ ^aBlock value ].	^binding isForGeneral		ifTrue: [ self definitionOfStatic: binding ] 		ifFalse: [ binding value definition ]</body><body package="Store-IMG-Records" selector="removeBinding:">removeBinding: binding 	"Remove the class with the name className, and all of its subclasses, 	from the system, and note the removal in the system ChangeSet."	self removeBinding: binding recordIn: #( #file #changes )</body></methods><methods><class-id>Core.String</class-id> <category>private-store</category><body package="Store-IMG-Records" selector="textRepresentation">textRepresentation	^self</body></methods><methods><class-id>Core.Class</class-id> <category>store tools</category><body package="Store-IMG-Records" selector="classSymbol">classSymbol	^self name</body><body package="Store-IMG-Records" selector="nonMeta">nonMeta	^self</body></methods><methods><class-id>Store.ClassExtensionDescriptor</class-id> <category>accessing</category><body package="Store-IMG-Records" selector="definitionAndComment">definitionAndComment		^super definitionAndComment."	^'This class is not defined in this package'"</body></methods><methods><class-id>Core.Metaclass</class-id> <category>team tools</category><body package="Store-IMG-Records" selector="classSymbol">classSymbol	^self soleInstance name</body><body package="Store-IMG-Records" selector="nonMeta">nonMeta	^self soleInstance</body></methods><methods><class-id>Store.ClassDescriptor</class-id> <category>converting</category><body package="Store-IMG-Records" selector="asCommentTag">asCommentTag	"Answer an instance of TT_ClassCommentTag"	^ClassCommentTag newClassName: self absoluteName</body><body package="Store-IMG-Records" selector="asTag">asTag	"Answer an instance of TT_ClassTag."	^ClassTag newClassName: self absoluteName isMeta: self isMeta</body></methods><methods><class-id>Store.ClassDescriptor</class-id> <category>accessing</category><body package="Store-IMG-Records" selector="definitionAndComment">definitionAndComment	| cl |	(cl := self myClass) isNil		ifTrue: [ ^'' ]		ifFalse: [ ^ClassRecord mergeDefinition: cl definition andComment: cl comment ]</body></methods><methods><class-id>Store.ClassDescriptor</class-id> <category>comparing</category><body package="Store-IMG-Records" selector="sameAsDBThing:">sameAsDBThing: aClass	^aClass sameAsImThing: self</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>store data</category><body package="Store-IMG-Subdefs" selector="decode:">decode: aByteArray	"self decode: (self encode: self new)"	| stream bos data |	stream := ReadStream on: aByteArray asByteArray.	bos := BinaryObjectStorage onOld: stream.	data := bos next.	bos close.	^data</body><body package="Store-IMG-Subdefs" selector="encode:">encode: data	"self encode: self new"	| stream bos |	stream := WriteStream on: ByteArray new.	bos := BinaryObjectStorage onNew: stream.	bos nextPut: data.	bos close.	^stream contents</body><body package="Store-IMG-Subdefs" selector="textRepresentationDataAt:">textRepresentationDataAt: aDataKey		"Answer text for aDataKey"	^( self definitionOf: aDataKey 			ifAbsent: [ '**Unresolved**' asText ] ) asText</body></methods><methods><class-id>Store.DatumDescriptor</class-id> <category>converting</category><body package="Store-IMG-Subdefs" selector="asTag">asTag	"Answer an instance of TT_DataTag."	^self isInClass		ifTrue: [ 	DataTag newClassName: self ownerName dataKey: self dataKey ]		ifFalse: [ DataTag newNameSpaceName: self ownerName dataKey: self dataKey ]</body></methods><methods><class-id>Store.DatumDescriptor</class-id> <category>comparing</category><body package="Store-IMG-Subdefs" selector="sameAsDBThing:">sameAsDBThing: aDatum 	"When comparing with DB - the definition has it all"	"Note: at the moment, no comments for data."	^self definition = aDatum definition</body></methods><methods><class-id>Store.DatumDescriptor</class-id> <category>accessing</category><body package="Store-IMG-Subdefs" selector="textRepresentationForTag:">textRepresentationForTag: aTag	^self definition</body></methods><methods><class-id>Core.Class</class-id> <category>store data</category><body package="Store-IMG-Subdefs" selector="decode:">decode: aByteArray	"self decode: (self encode: self new)"	| stream bos data |	stream := ReadStream on: aByteArray asByteArray.	bos := BinaryObjectStorage onOld: stream.	data := bos next.	bos close.	^data</body><body package="Store-IMG-Subdefs" selector="textRepresentationDataAt:">textRepresentationDataAt: aDataKey		"Answer text for aDataKey"	^( self dataAt: aDataKey ifAbsent: [ ^'**Unresolved**' asText ] ) 		printString asText.</body></methods><methods><class-id>Store.MethodDescriptor</class-id> <category>converting</category><body package="Store-IMG-Subdefs" selector="asTag">asTag	"Answer an instance of TT_MethodTag."	^MethodTag newClassName: self fullClassName selector: self selector meta: self isMeta.</body></methods><methods><class-id>Store.MethodDescriptor</class-id> <category>comparing</category><body package="Store-IMG-Subdefs" selector="sameAsDBThing:">sameAsDBThing: aMethod 	"When comparing with DB method take protocol into account."	^aMethod sameAsSelector: self selector class: self myClass</body></methods><methods><class-id>Store.MethodDescriptor</class-id> <category>accessing</category><body package="Store-IMG-Subdefs" selector="textRepresentationForTag:">textRepresentationForTag: aTag	^self sourceCode</body></methods><methods><class-id>Tools.ChangeSetManager class</class-id> <category>utilities</category><body package="Store-IMG-Pundles" selector="publishAsFragmentChangeSet:">publishAsFragmentChangeSet: aChangeSet	| pkgDict bundles packages |	aChangeSet isEmpty		ifTrue: [ ^Dialog warn: 'This change set is empty.' ].	pkgDict := Store.Registry convertNamedChangeSet: aChangeSet.	packages := pkgDict values.	bundles := Set new.	packages do:		[ :pkg | bundles addAll: pkg allEnclosingComponents ].	bundles := bundles asOrderedCollection.	packages := packages asOrderedCollection.	Store.PublishFragmentDialog		publishFragments: bundles, packages		comments: ( ( bundles, packages ) collect: 						[:pkg | 'ChangeSet &lt;1s&gt; from &lt;2s&gt;' expandMacrosWith: aChangeSet name with: pkg parentVersionString ] )		defaultBlessing: Store.Policies mergePolicy blessingForReadyForIntegration		versions: ( ( bundles, packages ) collect:						[:pkg | pkg parentVersionString , ' + ', aChangeSet name, '.0' ] )</body></methods><methods><class-id>Store.BundleDescription</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="adjustVersion">adjustVersion	"Do nothing for bundles."</body><body package="Store-IMG-Pundles" selector="asDBDescription">asDBDescription	^Bundles new		subBundleRef: self component dbTrace		yourself</body></methods><methods><class-id>Store.BundleDescription</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="dbComponent">dbComponent	"Find a component named componentName and answer it."	^id == nil		ifTrue: [ nil ]		ifFalse: [ Bundle aRecordWithID: id ]</body></methods><methods><class-id>Store.BundleDescription</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="descriptionsAndLevels">descriptionsAndLevels	"Answer a list of pairs. The first element contains a descriptions the second the 	level on which the description was found."	| comp coll |	comp := self component.	comp isNil ifTrue: [^#()].	coll := comp descriptionsAndLevels.	coll do: [:pair | pair at: 2 put: (pair at: 2) + 1].	coll addFirst: (Array with: self with: 1).	^coll</body><body package="Store-IMG-Pundles" selector="loadFromDBWithin:">loadFromDBWithin: parentBundle	"Locate a record containig my component and load the package from it."		| key | 	key := self id.	^BundleModel binLoadFromDB: key within: parentBundle.</body></methods><methods><class-id>Store.DatabaseConnectionBundleInformation</class-id> <category>actions</category><body package="Store-IMG-Pundles" selector="addFileDescription:">addFileDescription: aFilename	"Add the file specified by aFilename to the contents"	|filename|	filename := aFilename asLogicalFileSpecification.	( self fileDescriptions contains: [ :fm | fm portableFilename = filename ] )		ifTrue: [ ^false ].		self fileDescriptions add: ( ( FileModel from: filename ) bundle: self pundle ).	self shouldTrackChanges 		ifTrue: [ self addOtherChange: BundleModel fileMark ].	^true</body></methods><methods><class-id>Store.DatabaseConnectionBundleInformation</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="fileDescriptions">fileDescriptions		fileDescriptions == nil		ifTrue: [ fileDescriptions := List new.].	^fileDescriptions</body><body package="Store-IMG-Pundles" selector="fileDescriptions:">fileDescriptions: aCollection	fileDescriptions := aCollection asList.	fileDescriptions do: [:fd | fd bundle: self pundle]</body></methods><methods><class-id>Store.DatabaseConnectionBundleInformation</class-id> <category>actions</category><body package="Store-IMG-Pundles" selector="removeFile:">removeFile: aFileDescription	"Remove aFileDescription to the contents"	aFileDescription isString		ifTrue: [ fileDescriptions do: 					[ :fd | fd portableFilename asString = aFileDescription							ifTrue: [ ^self removeFile: fd ]					].				^true				]		ifFalse: [ fileDescriptions remove: aFileDescription ifAbsent: nil ].	self shouldTrackChanges 		ifTrue: [ self addOtherChange: BundleModel fileMark ].	^true</body></methods><methods><class-id>Kernel.Parcel class</class-id> <category>api</category><body package="Store-IMG-Pundles" selector="ensureLoadedParcel:withVersion:forPundle:">ensureLoadedParcel: parcelName withVersion: versionString forPundle: aPundle	"Check if a Parcel named parcelName is loaded with an appropriate version.	 If its not then attempt to load it."	"Called while trying to meet a Store parcel prerequisite"	| newParcel |	Cursor wait showWhile:		[self withFileCachesDo: 			[newParcel := self								ensureLoadedParcel: parcelName								withVersion: versionString								for: aPundle]].	self broadcastParcels.	^newParcel</body></methods><methods><class-id>Kernel.Parcel class</class-id> <category>updating</category><body package="Store-IMG-Pundles" selector="traceChangedForComponent:">traceChangedForComponent: aCodeComponent"	self changed: #parcelTraceChanged with: aCodeComponent"</body></methods><methods><class-id>Kernel.Parcel</class-id> <category>store-utilities</category><body package="Store-IMG-Pundles" selector="classOfDbRecord">classOfDbRecord	"Answer a class which is used to represent this component type in the database."	^Store.ParcelRecord</body></methods><methods><class-id>Kernel.Parcel</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="pundleName">pundleName	"Used by parcel resolving pundle prereqs- Answers a name regardless"	( name := self bundleName ) == nil		ifTrue: 			[ ( name := self packageName ) == nil 				ifTrue: [ name := self name ].			].	^name</body></methods><methods><class-id>Store.PackageDescription</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="asDBDescription">asDBDescription	^Packages new		packageRef: self component dbTrace;		yourself.</body></methods><methods><class-id>Store.PackageDescription</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="dbComponent">dbComponent	"Find a component named componentName and answer it."	^id == nil		ifTrue: [ nil ]		ifFalse: [ Package aRecordWithID: id ]</body></methods><methods><class-id>Store.PackageDescription</class-id> <category>testing</category><body package="Store-IMG-Pundles" selector="exactLoadedComponent">exactLoadedComponent	"Find if a bundle with my id is loaded into the image."	id isNil ifTrue: [^nil].	Registry packagesDo: 		[ :pkg | 		( pkg dbTraceFor: dbIdentifier ) = id 			ifTrue: 				[ ^pkg hasBeenModified					ifTrue: [ nil ]					ifFalse: [ pkg ]				]		].	^nil</body><body package="Store-IMG-Pundles" selector="isLoaded">isLoaded	"Find if a package fulfilling 	my description is loaded into the image."	^Registry isPackageLoaded: self name</body><body package="Store-IMG-Pundles" selector="loadedComponent">loadedComponent	"Find if a package fulfilling exactly my description is loaded into the image."	componentName == nil		ifFalse: [ ^Registry packageNamed: componentName ].	id isNil ifTrue: [ ^nil ].	Registry packagesDo: 		[ :pkg | 		( pkg dbTraceFor: dbIdentifier ) = id 			ifTrue: 				[ ^pkg hasBeenModified					ifTrue: [ nil ]					ifFalse: [ pkg ]				]		].	^nil</body></methods><methods><class-id>Store.PackageDescription</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="loadFromDBWithin:">loadFromDBWithin: parentBundle	"Locate a record containig my component and load the package from it."		| key | 	key := self id.	^PackageModel binLoadFromDB: key within: parentBundle.</body></methods><methods><class-id>Store.PundleAccess class</class-id> <category>package partitioning</category><body package="Store-IMG-Pundles" selector="createPDPBundle">createPDPBundle	"Creates the PDP bundle from the tobc file created with:		( Store.Registry bundleNamed: 'PDP 3.0' ) 				tableOfBundleContentsOnFile: 'pdp.tobc'  "	| filename |	filename := ( Filename fromComponents:			( Array with: '$(VISUALWORKS)' with: 'tocs' with: 'pdp.tobc' ) ) asResolvedString.	filename asFilename exists		ifTrue: [ 	Registry executeTableOfBundleContentsFromFile: filename ].</body><body package="Store-IMG-Pundles" selector="createRBBundle">createRBBundle	"Creates the system bundle from the tobc file created with:		( Store.Registry bundleNamed: 'RefactoringBrowser' ) 				tableOfBundleContentsOnFile: 'RefactoringBrowser.tobc'  "	| filename |	filename := ( Filename fromComponents:			( Array with: '$(VISUALWORKS)' with: 'tocs' with: 'RefactoringBrowser.tobc' ) ) asResolvedString.	filename asFilename exists		ifTrue: [ 	Registry executeTableOfBundleContentsFromFile: filename ].</body><body package="Store-IMG-Pundles" selector="createToolsBundle">createToolsBundle	"Creates the Tools bundle from the tobc file created with:		( Store.Registry bundleNamed: 'Tools-IDE' ) 				tableOfBundleContentsOnFile: 'Tools-IDE.tobc'  "	| filename |	filename := ( Filename fromComponents:			( Array with: '$(VISUALWORKS)' with: 'tocs' with: 'Tools-IDE.tobc' ) ) asResolvedString.	filename asFilename exists		ifTrue: [ 	Registry executeTableOfBundleContentsFromFile: filename ].</body></methods><methods><class-id>Store.PundleAccess class</class-id> <category>parcel load/unload/save</category><body package="Store-IMG-Pundles" selector="postLoadActionFor:">postLoadActionFor: aParcel 	self createStoreBundle: aParcel</body><body package="Store-IMG-Pundles" selector="preUnloadActionFor:">preUnloadActionFor: aParcel "Removed for now... reinstate if major UI changes made	ApplicationModel checkUnloadOfApplicationsDefinedBy: aParcel."</body><body package="Store-IMG-Pundles" selector="preUpdateActionFor:">preUpdateActionFor: aParcel	"Do the part of postLoad necessary for Store to update itself."	Override registerSourceManager: Store.Registry.	self addImports.	( Store.Registry dependents includes: Store.Registry )		ifFalse: [ Store.Registry addDependent: Store.Registry ].</body></methods><methods><class-id>Store.PundleAccess class</class-id> <category>package partitioning</category><body package="Store-IMG-Pundles" selector="splitUnpackagedIntoPackages">splitUnpackagedIntoPackages	"TT_PundleAccess splitUnpackagedIntoPackages"	Root withAllNameSpacesDo: 		[ :ns  | 		ns organization categories do: 			[ :cat | | pkgName |			pkgName := cat asString copyFrom: 1 to: (cat indexOf: $- ifAbsent: [cat size + 1] )	- 1.			self moveUnpackagedCategory: cat in: ns toPackageName: pkgName 			]		].</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>package accessing</category><body package="Store-IMG-Pundles" selector="allPackagesWithNewerInDB">allPackagesWithNewerInDB	"Answer a collection of packages with newer published versions."	"Store.Registry allPackagesWithNewerInDB"	| coll |	coll := OrderedCollection new.	packages do:		[ :pkg |  | versions trace |		trace := pkg dbTrace.		versions := trace == nil			ifTrue: [ pkg class databaseClass allVersionsWithName: pkg name ]			ifFalse: [ pkg class databaseClass allVersionsWithName: pkg name after: trace ].		coll addAll: versions.		].	^coll</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>private-image delivery</category><body package="Store-IMG-Pundles" selector="checkUnpublishedPundlesOn:">checkUnpublishedPundlesOn: aStream 	| first |	first := true.	self packagesDo: [:pkg | pkg hasBeenModified			ifTrue: 				[first					ifTrue: 						[aStream nextPutAll: 'The following packages are modified:'; cr.						first := false].				aStream tab; nextPutAll: pkg name; cr]].	first ifFalse: [aStream cr].	first := true.	self bundlesDo: [:bndl | bndl hasBeenModified			ifTrue: 				[first					ifTrue: 						[aStream nextPutAll: 'The following bundles are modified:'; cr.						first := false].				aStream tab; nextPutAll: bndl name; cr]]</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>change set conversion</category><body package="Store-IMG-Pundles" selector="conversionSetForComponentChange:into:">conversionSetForComponentChange: aComponentChange into: pkgDictionary	"Private- get the appropiate package for a change, if a conversion package	doesn't exist create it and add it to pkgDictionary. Answer the changeSet, nil if not for us."	 | pkg thePackage |	pkg := aComponentChange component.	( pkg == nil or: [ pkg isPackage not ] )		ifTrue: [ ^nil ].	thePackage := pkgDictionary at: pkg name ifAbsentPut: [ pkg conversionPackage ].	^thePackage changeSet.</body><body package="Store-IMG-Pundles" selector="conversionSetForDataKey:in:into:">conversionSetForDataKey: key in: aClassOrNameSpace into: pkgDictionary	"Private- look up the appropiate package for a definition, if a conversion package	doesn't exist create it and add it to pkgDictionary. Answer the changeSet."	 | pkg thePackage |	pkg := self containingPackageForDataKey: key symbol: aClassOrNameSpace absoluteSymbol.	thePackage := pkgDictionary at: pkg name ifAbsentPut: [ pkg conversionPackage ].	^thePackage changeSet.</body><body package="Store-IMG-Pundles" selector="conversionSetForDataRemoval:into:">conversionSetForDataRemoval: aName into: pkgDictionary	"Private- look up the appropiate package for a definition, if a conversion package	doesn't exist create it and add it to pkgDictionary. Answer an array with the changeSet and the removed DatumDescriptor."	 | pkg thePackage descr |	pkg := self allPackages detect:			[ :p | ( p changeSet removedDatumDescriptors collect: [ :dd | dd fullName ] ) includes: aName ]						ifNone: [ nil ].	pkg == nil ifTrue: [ ^nil ].	thePackage := pkgDictionary at: pkg name ifAbsentPut: [ pkg conversionPackage ].	descr := pkg removedDatumDescriptors select: [ :dd | dd fullName = aName ].	^Array with: thePackage changeSet with: descr first</body><body package="Store-IMG-Pundles" selector="conversionSetForDefinition:into:">conversionSetForDefinition: aClassOrNameSpace into: pkgDictionary	"Private- look up the appropiate package for a definition, if a conversion package	doesn't exist create it and add it to pkgDictionary. Answer the changeSet."	 | pkg thePackage |	pkg := self containingPackageForSymbol: aClassOrNameSpace absoluteSymbol.	thePackage := pkgDictionary at: pkg name ifAbsentPut: [ pkg conversionPackage ].	^thePackage changeSet.</body><body package="Store-IMG-Pundles" selector="conversionSetForDefinitionRemoval:into:">conversionSetForDefinitionRemoval: aName into: pkgDictionary	"Private- look up the appropiate package for a definition, if a conversion package	doesn't exist create it and add it to pkgDictionary. Answer the changeSet."	 | pkg thePackage |	pkg := self allPackages detect:			[ :p | p changeSet removedNameSpaceOrDefinitionNames includes: aName ] ifNone: [ nil ].	pkg == nil ifTrue: [ ^nil ].	thePackage := pkgDictionary at: pkg name ifAbsentPut: [ pkg conversionPackage ].	^thePackage changeSet.</body><body package="Store-IMG-Pundles" selector="conversionSetForMethodRemoval:className:meta:into:">conversionSetForMethodRemoval: selector className: aName meta: meta into: pkgDictionary	"Private- look up the appropiate package for a method, if a conversion package	doesn't exist create it and add it to pkgDictionary. Answer the changeSet."	 | pkg thePackage descr |	pkg := self allPackages detect:			[ :p | p changeSet removedMethodDescriptors contains: 				[ :md | 				descr := md.				( ( md isMeta = meta ) &amp; ( md selector = selector ) ) 						and: [ md className = aName ]				]			] ifNone: [ nil ].	pkg == nil ifTrue: [ ^nil ].	thePackage := pkgDictionary at: pkg name ifAbsentPut: [ pkg conversionPackage ].	^thePackage changeSet</body><body package="Store-IMG-Pundles" selector="conversionSetForSelector:in:into:">conversionSetForSelector: selector in: aClass into: pkgDictionary	"Private- look up the appropiate package for a definition, if a conversion package	doesn't exist create it and add it to pkgDictionary. Answer the changeSet."	 | pkg thePackage |	pkg := self containingPackageForSelector: selector class: aClass.	thePackage := pkgDictionary at: pkg name ifAbsentPut: [ pkg conversionPackage ].	^thePackage changeSet.</body><body package="Store-IMG-Pundles" selector="convertComponentChange:into:">convertComponentChange: aComponentChange into: pkgDictionary	"Private-Add the component change to aChangeSet."	 | xcs |	xcs := self conversionSetForComponentChange: aComponentChange into: pkgDictionary.	xcs == nil		ifFalse: [ aComponentChange doChangeTo: xcs ].</body><body package="Store-IMG-Pundles" selector="convertDefinitionChanges:into:from:">convertDefinitionChanges: aClassOrNameSpace into: pkgDictionary from: aChangeSet	"Private-Look up aClassOrNameSpace that came from a ChangeSet and create changes in the appropiate packages."	 | xcs change real |	real := aClassOrNameSpace isForClass				ifTrue: [ aClassOrNameSpace instanceBehavior ]				ifFalse: [ aClassOrNameSpace ].	( aChangeSet changeTypesFor: real fullName ) isEmpty		ifTrue: [ ^self ].		"no definition changes."	xcs := self conversionSetForDefinition: real into: pkgDictionary.	change :=  aClassOrNameSpace isForClass 		ifTrue: [ Change new class: real ]		ifFalse: [ Change new nameSpace: real ].	( aChangeSet atClass: aClassOrNameSpace includes: #add )		ifTrue: 			[ xcs doChange: change add.			"Since added classes include all selectors for that class, get them here."			( real isForClass and: [  aClassOrNameSpace isMeta not ] )				ifTrue: [ self convertRestOfClassAdd: real into: pkgDictionary from: aChangeSet ].			].	( aChangeSet atClass: aClassOrNameSpace includes: #change )				ifTrue: [ xcs doChange: change change ].	( aChangeSet atClass: aClassOrNameSpace includes: #comment )		ifTrue: [ xcs doChange: change comment ].	( aChangeSet atClass: aClassOrNameSpace includes: #reorganize )		ifTrue: [ xcs doChange: change reorganize ].</body><body package="Store-IMG-Pundles" selector="convertMethodChange:into:from:">convertMethodChange: methodDescriptor into: pkgDictionary from: aChangeSet	"Private-Look up aClass that came from a ChangeSet and create changes in the appropiate packages."	 | xcs change type |	xcs := self conversionSetForSelector: methodDescriptor selector in: methodDescriptor implementingClass into: pkgDictionary.	change :=  Change new 				class: methodDescriptor implementingClass; 				selector: methodDescriptor selector.	type := aChangeSet atSelector: methodDescriptor selector class: methodDescriptor implementingClass.	change perform: type.	xcs doSubdefChange: change.</body><body package="Store-IMG-Pundles" selector="convertMethodRemoval:className:into:">convertMethodRemoval: selector className: className into: pkgDictionary	"Private- className&gt;&gt;selector was removed. Class may not exist. Figure out where it was removed from."	 | xcs name meta |	meta := className namesMetaClass.	name := SystemUtils convertFullNameToAbsolute: className asClassNameOnly.	( xcs := self conversionSetForMethodRemoval: selector className: name meta: meta into: pkgDictionary ) == nil		ifTrue: [ ^self ].	xcs doSubdefChange: ( Change new classSymbol: name asSymbol; meta: meta; selector: selector; remove ).</body><body package="Store-IMG-Pundles" selector="convertNamedChangeSet:">convertNamedChangeSet: aChangeSet	"Answer a dictionary of package copies with changelist determined by aChangeSet"	"Store.Registry convertNamedChangeSet: ( NamedChangeSet lookup: #test )"	| pkgDictionary |	pkgDictionary := Dictionary new.		aChangeSet changedNameSpaces do:		[ :ns | self convertDefinitionChanges: ns into: pkgDictionary from: aChangeSet ].	aChangeSet changedClasses do: 		[ :cls | self convertDefinitionChanges: cls into: pkgDictionary from: aChangeSet ].	aChangeSet changedMessageList do:		[ :md | self convertMethodChange: md into: pkgDictionary  from: aChangeSet ].	aChangeSet changedStatics do:		[ :name | self convertStaticChange: name into: pkgDictionary  from: aChangeSet ].	aChangeSet objectRemoves keysAndValuesDo:		[ :key :value | self convertRemoval: key type: value into: pkgDictionary ].	aChangeSet removedMethodsDo:		[ :className :selector | self convertMethodRemoval: selector className: className into: pkgDictionary ].	aChangeSet componentChangesDo:		[ :componentChange | self convertComponentChange: componentChange into: pkgDictionary ].	^pkgDictionary</body><body package="Store-IMG-Pundles" selector="convertRemoval:type:into:">convertRemoval: aString type: aSymbol into: pkgDictionary	"Private- aString names a class/namespace/static indicated by type. Figure out where it was removed from."	 | xcs name change descr array |	name := SystemUtils convertFullNameToAbsolute: aString.	change := Change new remove.	aSymbol == #variable		ifTrue:			[ ( array := self conversionSetForDataRemoval: name into: pkgDictionary ) == nil				ifTrue: [ ^self ].			xcs := array first.			descr := array last.			descr isInClass				ifTrue: [ change classSymbol: descr ownerName asSymbol ]				ifFalse: [ change nameSpaceSymbol: descr ownerName asSymbol ].			change dataKey: descr key.			xcs doSubdefChange: change.			]		ifFalse: 			[ "must be class or namespace"			( xcs := self conversionSetForDefinitionRemoval: name into: pkgDictionary ) == nil				ifTrue: [ ^self ].			aSymbol == #class				ifTrue: [ change classSymbol: name asSymbol ]				ifFalse: [ change nameSpaceSymbol: name asSymbol ].			xcs doChange: change.			].</body><body package="Store-IMG-Pundles" selector="convertRestOfClassAdd:into:from:">convertRestOfClassAdd: aClass into: pkgDictionary from: aChangeSet	"Private-Look up aClass that came from a ChangeSet and create changes in the appropiate packages."	aClass selectors do:		[ :selector | | xcs change |		xcs := self conversionSetForSelector: selector in: aClass into: pkgDictionary.		change :=  Change new class: aClass; selector: selector; add.		xcs doSubdefChange: change.		].	aClass class selectors do:		[ :selector | | xcs change |		xcs := self conversionSetForSelector: selector in: aClass into: pkgDictionary.		change :=  Change new class: aClass; selector: selector; add.		xcs doSubdefChange: change.		].</body><body package="Store-IMG-Pundles" selector="convertStaticChange:into:from:">convertStaticChange: aString into: pkgDictionary from: aChangeSet	"Private-Look up a static that came from a ChangeSet and create changes in the appropiate packages."	 | xcs change ref env |	ref := aString asStrictReference.	env := ref environment.	change := env isForClass		ifTrue: [ Change new class: env ]		ifFalse: [ Change new nameSpace: env ].	xcs := self conversionSetForDataKey: ref simpleName in: env into: pkgDictionary.	change dataKey: ref simpleName.	( aChangeSet atName: aString includes: #add )		ifTrue: [ change add ].	( aChangeSet atName: aString includes: #change )		ifTrue: [ change change ].		xcs doSubdefChange: change.</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>consistency checking</category><body package="Store-IMG-Pundles" selector="makeConsistent">makeConsistent	"Review state of the image. All Packages remove bogus changeSet references &amp; 	the Registry needs to validate nil class defs."	"Store.Registry makeConsistent"		( packages keys select: [ : key | key isSymbol ] ) do:		[ :key | 	packages at: key asString put: ( packages removeKey: key ) ].	( bundles keys select: [ : key | key isSymbol ] ) do:		[ :key | 	bundles at: key asString put: ( bundles removeKey: key ) ].	self packagesDo: 		[ :pkg | pkg makeConsistent ].	modelDictionary associationsDo:		[ :assoc | 	| pkg |		assoc value first == nil			ifTrue: 				[ ( pkg := packages detect: [ :p | p includesDefinitionOf: assoc key ] ) == nil					ifFalse: [ modelDictionary at: assoc key put: ( pkg modelAtSymbol: assoc key asSymbol ifAbsent: nil ) ]				]		]</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>utility</category><body package="Store-IMG-Pundles" selector="removeDatabaseLinks">removeDatabaseLinks	"Remove the all loaded pundles to a different database."	"Store.Registry removeDatabaseLinks"	| list ids |	list :=  self allBundles, self allPackages. 	ids := PundleModel selectDatabasesFor: list prompt: 'Select databases to unlink'.	ids == nil		ifTrue: [ ^Dialog warn: 'There are no database links.' ].	list do: [ :p | p removeDbInformationFor: ids ].</body><body package="Store-IMG-Pundles" selector="switchDatabases">switchDatabases	"Reconcile the all loaded pundles to a different database."	"Store.Registry switchDatabases"	| list ids |	list :=  self allBundles, self allPackages. 	ids := Set new.	list do: [ :p | ids addAll: p allDatabases ].	ids remove: DbRegistry dbIdentifier ifAbsent: nil.	ids := ids reject: [ :id | Dialog confirm: ( 'Maintain existing links to: &lt;1s&gt;?' expandMacrosWith: id ) ].	self switchDatabases: list remove: ids.</body><body package="Store-IMG-Pundles" selector="switchDatabases:remove:">switchDatabases: aPundleCollection remove: ids	"Reconcile the pundles in aPundleCollection to a different database."	| which trace |	which := Dialog 		choose: 'Which versions should be used to reconcile?'		labels: #( 'Use most recently published?' 'Select published versions'  'Cancel' )		values: #( #recent #select #cancel )		default: #recent.	which == #cancel		ifTrue: [ ^self ].	aPundleCollection do: [ :pundle | pundle removeDbs: ids ].		[ aPundleCollection do:		[ :pundle |		pundle dbTrace == nil			ifTrue: 				[ trace := which == #recent					ifTrue: [ pundle class databaseClass 	mostRecentVersionOfPundleWithName: pundle name ]					ifFalse: [ pundle selectVersion ].				trace == nil					ifTrue: [ Transcript cr; show: 'Could not reconcile: ', pundle name]					ifFalse: [ [ pundle reconcileWithDb: trace ] on: Error do: 								[ :e | 								Transcript cr; show: pundle name, ': ERROR reconciling: ', e description. 								e return 								]							]				]		]	]  on: DbRegistry errorSignals do:		[ :exp | exp return ].</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>table of contents</category><body package="Store-IMG-Pundles" selector="tableOfContentsTagsFrom:">tableOfContentsTagsFrom: aStream 	| pkgTags defKey |	pkgTags := OrderedCollection new: 20.		[ aStream skipSeparators.	defKey := aStream upToSeparator.	defKey = ';' ] whileFalse: 		[ | index defTag start |		index := defKey indexOf: $&gt; ifAbsent: [nil].		defTag := index notNil			ifTrue: [ MethodTag new selector: ( defKey copyFrom: index + 1 to: defKey size ) asSymbol ]			ifFalse: 				[ index := defKey indexOf: $@ ifAbsent: [nil].				index notNil					ifTrue: [ DataTag new dataKey: ( defKey copyFrom: index + 1 to: defKey size ) asSymbol ]					ifFalse: 						[ index := defKey size + 1.						defKey first = $!							ifTrue: [ NameSpaceTag new ]							ifFalse: [ ClassTag new ]						]				].		defTag isMeta: defKey first = $%.		start := ( defTag isMeta  or: [ defTag isNameSpaceTag ] )			ifTrue: [ 2 ]  ifFalse: [ 1 ].		defTag classSymbol: ( defKey copyFrom: start to: index - 1 ) asSymbol.		pkgTags add: defTag		].	^pkgTags</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>private-image delivery</category><body package="Store-IMG-Pundles" selector="zeroTraceForAll">zeroTraceForAll	"Elimate references to database  ids- neccessary when moving to	a new database."	"TT_Registry zeroTraceForAll"	self packagesDo: [:pkg | pkg setNoTrace; markNotModified].	self  bundlesDo: [:bun | bun setNoTrace; markNotModified].</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>store-utilities</category><body package="Store-IMG-Pundles" selector="classOfDbRecord">classOfDbRecord	"Answer a class which is used to represent this component type in the database."	self subclassResponsibility</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>relationships</category><body package="Store-IMG-Pundles" selector="elementLabel:">elementLabel: hints 	"This method returns a visual component used to represent me in a  browser graph."	| lab |	lab := LabelAndIcon with: ( self stringKey: hints )				attributes: ( TextAttributes styleNamed: #systemDefault ).	lab icon: ( Store.AbstractTool iconForPundle: self ).	^lab</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>load/unload</category><body package="Store-IMG-Pundles" selector="parcelOutTo:sourceFileName:">parcelOutTo: parcelFileName sourceFileName: sourceFileName	"Generic publish the parcel with sources. Don't republish."	| cWriter |	cWriter := CodeWriter new.	Cursor wait showWhile: [ self prepareCodeWriter: cWriter ].	[ cWriter 		writeToParcelFileNamed: parcelFileName asLogicalFileSpecification		sourceFileNamed: sourceFileName asLogicalFileSpecification		oldSourceIndex: ( properties at: #sourceIndex ifAbsent: nil )		hideSource: false		republish: false		backup: false.	] on: CodeWriter invalidTraceSignal		do: [ :ex | Parcel invalidNamedObjectSignal raiseWith: ex parameter ]</body><body package="Store-IMG-Pundles" selector="parcelOutToDb:">parcelOutToDb: dbParcel	"Convert the parcel to binary and install in dbParcel."	| cWriter |	cWriter := CodeWriter new.	Cursor wait showWhile: [ self prepareCodeWriter: cWriter].	[ cWriter writeForDb: dbParcel ]		on: CodeWriter invalidTraceSignal		do: [ :ex | Parcel invalidNamedObjectSignal raiseWith: ex parameter]</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>store-accessing</category><body package="Store-IMG-Pundles" selector="primaryKey">primaryKey	"unpublished"	^0</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>relationships</category><body package="Store-IMG-Pundles" selector="relatedBy:">relatedBy: token 	""	token == #tt_derivesRel ifTrue: [ ^Set new ].	token == #tt_derivesRRel ifTrue: [ ^Set with: self parentRecord ].	^super relatedBy: token</body></methods><methods><class-id>Store.DatabaseConnectionInformation class</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="changeSetClass">changeSetClass	"Answer the changeSet class for pundles."	^XChangeSet</body></methods><methods><class-id>Store.DatabaseConnectionInformation class</class-id> <category>instance creation</category><body package="Store-IMG-Pundles" selector="databaseId:dbTrace:">databaseId: aString dbTrace: anInteger	"Answer an instance of the receiver initialized (with a nil changeset)"	^self new		dbIdentifier: aString;		dbTrace: anInteger</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>actions</category><body package="Store-IMG-Pundles" selector="addOtherChange:">addOtherChange: aChangeSymbol	self changeSet addOtherChange: aChangeSymbol</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="changeSet">changeSet 	changeSet == nil		ifTrue: [ changeSet := self class changeSetClass new ].	^changeSet</body><body package="Store-IMG-Pundles" selector="changeSet:">changeSet: anXChangeSet	changeSet := anXChangeSet</body><body package="Store-IMG-Pundles" selector="changeSetifNone:">changeSetifNone: aBlock	^changeSet == nil		ifTrue: [ aBlock value ]		ifFalse: [ changeSet ]</body><body package="Store-IMG-Pundles" selector="dbTrace">dbTrace		^dbTrace</body><body package="Store-IMG-Pundles" selector="dbTrace:">dbTrace: anInteger		dbTrace == nil | self shouldTrackChanges		ifFalse: [ self addOtherChange: pundle parentChangedMark ].	dbTrace := anInteger.	versionString := nil.	self traceVersionString.		"reset the versionString cache"	self isInCurrentDatabase		ifTrue: [ 	self manager traceChangedForComponent: pundle ].</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>actions</category><body package="Store-IMG-Pundles" selector="emptyChangeSet">emptyChangeSet	changeSet := nil</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>testing</category><body package="Store-IMG-Pundles" selector="hasTrace">hasTrace	^self dbTrace notNil and: [ self dbTrace ~= 0 ]</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>utility</category><body package="Store-IMG-Pundles" selector="inspectChangeSet">inspectChangeSet		changeSet == nil		ifTrue: [ ^Dialog warn: 'No changes for ', dbIdentifier ].	changeSet inspectorClass		inspect: changeSet label: 'Changes for ', dbIdentifier.</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>testing</category><body package="Store-IMG-Pundles" selector="isChangeSetEmpty">isChangeSetEmpty		^changeSet == nil or: [ changeSet isEmpty ]</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>actions</category><body package="Store-IMG-Pundles" selector="markNotModified">markNotModified	self emptyChangeSet</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>printing</category><body package="Store-IMG-Pundles" selector="printOn:">printOn: aStream 	aStream nextPutAll: self class name asString.	aStream nextPutAll: ' ('.	dbIdentifier notNil 		ifTrue: [ aStream nextPutAll: dbIdentifier ].	aStream nextPut: $).</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>actions</category><body package="Store-IMG-Pundles" selector="setNoTrace">setNoTrace	versionString := nil.	self dbTrace: nil.</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="traceVersion">traceVersion	"Answer a string describing a version of my trace  pundle."	| pun |	[ pun := pundle tracePackage ]		on: pundle errorSignals		do: [ :ex | ^'(???)' ].	^pun  == nil		ifTrue: [ '' ]		ifFalse: [ pun version ]</body><body package="Store-IMG-Pundles" selector="traceVersionString">traceVersionString	"Answer a string describing a version of my trace  pundle. 	Use versionString cache if possible."	| pun str |	( str := versionString ) == nil		ifTrue: 			[ [ pun := pundle tracePackage ]				on: pundle errorSignals				do: [ :ex | ^'(???)' ].			str :=  ( pun  == nil					ifTrue: [ '' ]					ifFalse: [ pun versionString ] 				   ).			self versionString: str.			].	^str</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>actions</category><body package="Store-IMG-Pundles" selector="unhook">unhook	"Remove db identitity from the receiver."		dbTrace := nil.	dbIdentifier := nil.	versionString := nil.</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="versionString">versionString	"Answer the cached versionString"	^versionString == nil		ifTrue: [ self traceVersionString ]		ifFalse: [ versionString ]</body><body package="Store-IMG-Pundles" selector="versionString:">versionString: aString	"Set the cached versionString"	versionString := ( aString == nil or: [ aString isEmpty] )						ifTrue: [ nil ]						ifFalse: [ aString ]." ????	self isInCurrentDatabase		ifTrue: [ 	self manager traceChangedForComponent: pundle ]"</body></methods><methods><class-id>Store.ComponentDescription class</class-id> <category>Signal constants</category><body package="Store-IMG-Pundles" selector="cannotLoadComponentSignal">cannotLoadComponentSignal	^CannotLoadComponentSignal</body><body package="Store-IMG-Pundles" selector="cannotStoreComponentSignal">cannotStoreComponentSignal	^CannotStoreComponentSignal</body><body package="Store-IMG-Pundles" selector="cannotUnloadComponentSignal">cannotUnloadComponentSignal	^CannotUnloadComponentSignal</body><body package="Store-IMG-Pundles" selector="componentNotFoundSignal">componentNotFoundSignal	^Pundle componentNotFoundSignal</body></methods><methods><class-id>Store.ComponentDescription class</class-id> <category>instance creation</category><body package="Store-IMG-Pundles" selector="fromBos:">fromBos: aString	"This method is used by the bos reader to create 	instances while loading a bundle."	| baby |	baby := self new.	baby fileNameString: aString.	^baby</body></methods><methods><class-id>Store.ComponentDescription class</class-id> <category>parcel support</category><body package="Store-IMG-Pundles" selector="fromParcelPrerequisite:">fromParcelPrerequisite: aPreqArray	"Answer a ComponentDescription that represents the parcel prerequisite as a pundle."	"Parcel prereqs are #( name version )."	"self fromParcelPrerequisite: #( 'TestBundle876-B', '876' )"	"self fromParcelPrerequisite: #( 'TestPackage876', '876' )"	| cname version descclass |	cname := aPreqArray first.	version := aPreqArray last.	( cname copyFrom: ( cname size - 1 ) to: cname size ) = '-B'		ifTrue: 			[ descclass := BundleDescription.			cname := cname copyFrom: 1 to: ( cname size - version size - 2 ).			]		ifFalse: 			[ descclass := PackageDescription.			cname := cname copyFrom: 1 to: ( cname size - version size ).			].		^descclass new			componentName: cname;			id: version asNumber.</body></methods><methods><class-id>Store.ComponentDescription class</class-id> <category>class initialization</category><body package="Store-IMG-Pundles" selector="initialize">initialize	"self initialize"	CannotLoadComponentSignal := Object informationSignal newSignal 		notifierString: 'Cannot load a component';		nameClass: self message: #cannotLoadComponentSignal.	CannotStoreComponentSignal := Object informationSignal newSignal 		notifierString: 'Cannot store a component';		nameClass: self message: #cannotStoreComponentSignal.	CannotUnloadComponentSignal := Object informationSignal newSignal 		notifierString: 'Cannot unload a component';		nameClass: self message: #cannotUnloadComponentSignal.</body></methods><methods><class-id>Store.ComponentDescription</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="binLoadComponentFrom:">binLoadComponentFrom: anExternalHandle	self subclassResponsibility</body></methods><methods><class-id>Store.ComponentDescription</class-id> <category>binary storage</category><body package="Store-IMG-Pundles" selector="dbLoadWithin:">dbLoadWithin: parentBundle	"Load the corresponding component form the database. 	If the component cannot be found just fail loading."	^self preLoadCheck and: 		[ [ | comp |		  comp := self loadFromDBWithin: parentBundle.		  comp == nil			ifTrue: [ self class cannotLoadComponentSignal raiseWith: self ]		  	ifFalse: [ self component: comp ].		  ] on: self class componentNotFoundSignal do:			[ :ex | self failLoadingWith: ex errorString ]		]</body></methods><methods><class-id>Store.ComponentDescription</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="descriptionsAndLevels">descriptionsAndLevels	"Answer a collection of pairs. The first element is the description	the second is level (zero)."	| comp |	comp := self component.	^comp isNil 		ifTrue: [#()]		ifFalse: [OrderedCollection with: (Array with: self with: 1)]</body><body package="Store-IMG-Pundles" selector="externalHandle">externalHandle	self subclassResponsibility</body><body package="Store-IMG-Pundles" selector="externalHandleForStorage">externalHandleForStorage	self subclassResponsibility</body><body package="Store-IMG-Pundles" selector="failLoadingWith:">failLoadingWith: anErrorString	self class cannotLoadComponentSignal raiseErrorString: anErrorString</body><body package="Store-IMG-Pundles" selector="fileName">fileName	^fileName</body><body package="Store-IMG-Pundles" selector="fileName:">fileName: aFilename	fileName := aFilename tail.</body><body package="Store-IMG-Pundles" selector="fileNameString:">fileNameString: aString	fileName := aString</body></methods><methods><class-id>Store.ComponentDescription</class-id> <category>testing</category><body package="Store-IMG-Pundles" selector="hasBeenModified">hasBeenModified	"Check if the underlying package has been modified and if it is the same 	as the one described.		All new components (without trace) are considered modified."	| comp |	comp := self component.	^comp notNil and: 		[ comp hasBeenModified or: 			[ ( comp dbTraceFor: dbIdentifier ) isNil or: 				[ ( self describesComponent: comp ) not ]			]		]</body><body package="Store-IMG-Pundles" selector="isComponentLoaded">isComponentLoaded	"Answer true if the actual component is already	loaded into the image."	^self component notNil</body><body package="Store-IMG-Pundles" selector="isInCurrentDatabase">isInCurrentDatabase	^DbRegistry dbIdentifier = self dbIdentifier.</body></methods><methods><class-id>Store.ComponentDescription</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="preLoadCheck">preLoadCheck	"Answer true if there is no compatible version of the component 	already loaded into the image."	^self exactLoadedComponent isNil</body><body package="Store-IMG-Pundles" selector="publishComponent">publishComponent	"Publish the component I hold onto and modify my description	to reflect changes."	| comp | 	comp := self component.	comp storeInDB.	id := comp dbTrace.</body></methods><methods><class-id>Store.ComponentDescription</class-id> <category>binary storage</category><body package="Store-IMG-Pundles" selector="representBinaryOn:">representBinaryOn: binWriter	"When we store description we only need to know the	type of the component and the file name used for storage."	^MessageSend				receiver: self class				selector: #fromBos:				arguments: (Array with: fileName)</body></methods><methods><class-id>Store.ComponentDescription</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="updateVersion">updateVersion	"The underlying component has been published. 	Update my data to reflect this change."	| comp |	comp := self component.	comp == nil 		ifFalse: 	[ id := comp dbTraceFor: dbIdentifier ]</body></methods><methods><class-id>Store.BundleModel class</class-id> <category>binary storage</category><body package="Store-IMG-Pundles" selector="binLoadFromDB:within:">binLoadFromDB: aKey within: parentBundle	"Given a primary key get the instance of a database pundle from the database."	| dbRec |	[dbRec := self databaseClass aRecordWithID: aKey.	]	on: self errorSignals	do: [ :ex | ex outer. ^nil].	dbRec isNil 		ifTrue: [ self componentNotFoundSignal 					raiseErrorString: 'Cannot loacate a ', self descriptionString, ' with ID = ' , aKey printString ].	^self loadFromDB: dbRec within: parentBundle</body></methods><methods><class-id>Store.BundleModel class</class-id> <category>constants</category><body package="Store-IMG-Pundles" selector="databaseClass">databaseClass	^Bundle</body></methods><methods><class-id>Store.BundleModel class</class-id> <category>private-instance creation</category><body package="Store-IMG-Pundles" selector="emptyFrom:">emptyFrom: aPublishedBundle	"Create a new EMPTY bundle using aPublishedBundle. 	In order to make the change set reflect this situation 	convert the contents of aPublishedBundle into removes. 	Answer a collection of modifications."	| img |	img := self named: aPublishedBundle name.	img dbTrace: aPublishedBundle primaryKey.	^aPublishedBundle basicModificationsFor: DbRegistry dbIdentifier.</body></methods><methods><class-id>Store.BundleModel class</class-id> <category>private-utilities</category><body package="Store-IMG-Pundles" selector="loadFromDB:asDiffTo:within:">loadFromDB: aDBBundle asDiffTo: anImBundle within: parentBundle	"Load bundle content from the database but first calculate 	the difference between aDBBundle and a version of me loaded into the image."	| baby |	anImBundle runPreUnload: true.	baby := self named: aDBBundle name.	baby 		initializeFromDB: aDBBundle;		initializeFromImage: anImBundle;		loadContentsFromDBWithin: parentBundle.	( anImBundle pundlesNotIn: baby or: parentBundle ) do: 		[ :pundle | 		( pundle onlyReferencedBy: anImBundle )			ifTrue: [ pundle unloadFromImage ]		].	^baby</body></methods><methods><class-id>Store.BundleModel class</class-id> <category>binary storage</category><body package="Store-IMG-Pundles" selector="loadFromDB:within:">loadFromDB: aDBBundle within: parentBundle	"Given a published bundle create a new bundle model and load the contents. 	Answer wither the new bundle or nil."	| imgBundle |	aDBBundle checkPrerequisites		ifFalse: [ ^nil ].	aDBBundle runPreRead		ifFalse: [ ^nil ].	imgBundle := Registry bundleNamed: aDBBundle name.	imgBundle := imgBundle == nil		ifTrue: 			[ aDBBundle runPreLoad.			self loadNewFromDB: aDBBundle within: parentBundle.			]		ifFalse: [ self loadFromDB: aDBBundle asDiffTo: imgBundle within: parentBundle ].	imgBundle == nil		ifFalse:			[ imgBundle				dbTrace: aDBBundle primaryKey;				runPostLoad;				markNotModified.			].	^imgBundle</body></methods><methods><class-id>Store.BundleModel class</class-id> <category>private-utilities</category><body package="Store-IMG-Pundles" selector="loadNewFromDB:within:">loadNewFromDB: aDBBundle  within: parentBundle	"Load bundle content from the database. 	There is no existing version of me loaded into the image."	| baby |	baby := self named: aDBBundle name.	baby initializeFromDB: aDBBundle.	baby loadContentsFromDBWithin: parentBundle.	^baby</body></methods><methods><class-id>Store.BundleModel class</class-id> <category>private-instance creation</category><body package="Store-IMG-Pundles" selector="newFromBinFile:">newFromBinFile: aFilename 	"Create new instance and initilaize it form data stored in	the bos file. Do not load components."		| bos baby |	bos := BinaryObjectStorage onOld: aFilename asFilename readStream.	[baby := self readFrom: bos]		ensure: [bos close].	^baby</body></methods><methods><class-id>Store.BundleModel class</class-id> <category>binary storage</category><body package="Store-IMG-Pundles" selector="newFromDB:">newFromDB: aDBBundle 	"Given a published bundle create a new bundle model and load the contents. 	Answer either the new bundle or nil."	^self newFromDB: aDBBundle within: nil.			"This must be the top"</body><body package="Store-IMG-Pundles" selector="newFromDB:within:">newFromDB: aDBBundle within: parentBundle	"Given a published bundle create a new bundle model and load the contents as part of a larger whole.	Answer either the new bundle or nil."	( LoadDialog okToLoadBundle: aDBBundle ) 		ifFalse: [ ^nil ].	^[ self loadFromDB: aDBBundle within: parentBundle ]  on: self emergencyUnloadSignal do: 		[ :ex | ex return: nil ]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>external files</category><body package="Store-IMG-Pundles" selector="addFile:">addFile: aFileDescription	"Add a external file to the receiver."	dbInfo isEmpty		ifTrue: [ self databaseInfomationForOrCreate: self noDbSymbol ].	self databaseInformationsDo:		[ : info | info addFileDescription: aFileDescription ].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>binary storage</category><body package="Store-IMG-Pundles" selector="adjustComponents">adjustComponents	"Iterate over description and make sure that	the names of components are OK.	Descriptions for which components were loaded have	names not set up/"	self databaseInfomation adjustComponents</body></methods><methods><class-id>Store.BundleModel</class-id> <category>external files</category><body package="Store-IMG-Pundles" selector="anyFileDescriptions">anyFileDescriptions	"Answer a collection of file descriptors for any database connection"	dbInfo isEmpty		ifTrue: [ ^#( ) ].	dbInfo size &gt; 1 		ifTrue: [ dbInfo removeKey: self noDbSymbol ifAbsent: nil ].	^dbInfo values first fileDescriptions collect:		[ :desc |		desc copy			yourself		].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="asDBDescription">asDBDescription	^Bundles new"		expressionStr: condition; "	" not being used"		subBundleRef: self dbTrace		yourself</body></methods><methods><class-id>Store.BundleModel</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="changedItemCount">changedItemCount	"Answer a count of work to be done for filing out changes."	^self contents inject: 1 into:		[ :sz :pun | 		pun == nil			ifTrue: [ sz ]			ifFalse: [ sz + pun changedItemCount ]		].</body><body package="Store-IMG-Pundles" selector="changedItemCountFor:">changedItemCountFor: dbid	"Answer a count of work to be done for filing out changes."	^self contents inject: 1 into:		[ :sz :pun | 		pun == nil			ifTrue: [ sz ]			ifFalse: [ sz + ( pun changedItemCountFor: dbid ) ]		].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="classOfDbRecord">classOfDbRecord	"Answer a class which is used to represent bundles in the database."	^Bundle</body><body package="Store-IMG-Pundles" selector="comparePackages:">comparePackages: aBundle	"Compare all packages that I contain with	packages that are contained by aBundle."</body></methods><methods><class-id>Store.BundleModel</class-id> <category>compaisons</category><body package="Store-IMG-Pundles" selector="comparesTo:">comparesTo: aCodeComponent	"Answer true if the receiver is some version of aCodeComponent."	^aCodeComponent isBundle and: [ name = aCodeComponent name ].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>table of contents</category><body package="Store-IMG-Pundles" selector="completeTableOfContentsNamed:">completeTableOfContentsNamed: aString	self tableOfContentsOnFile: aString, '.toc'.	self tableOfBundleContentsOnFile: aString, '.tobc'.	( PundleParentMap on: self )		writeParentsToFile: aString, '.tbl'.</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private-differences calculation</category><body package="Store-IMG-Pundles" selector="computeDiffsBetween:into:">computeDiffsBetween: aBundle into: diffHolder 	"Since the receiver is a loaded package an argument aBundle	has to be a DB packagge."		[ diffHolder reverse.	self computeDiffsBetweenDBBundle: aBundle into: diffHolder]		ensure: [ diffHolder reverse ].	^diffHolder</body><body package="Store-IMG-Pundles" selector="computeDiffsBetweenDBBundle:into:">computeDiffsBetweenDBBundle: aBundle into: diffHolder	diffHolder methodsSide: 2 put: OrderedCollection new.	diffHolder methodsSide: 1 put: OrderedCollection new.	diffHolder dataSide: 2 put: OrderedCollection new.	diffHolder dataSide: 1 put: OrderedCollection new.	diffHolder classesSide: 2 put: OrderedCollection new.	diffHolder classesSide: 1 put: OrderedCollection new.	diffHolder metaSide: 2 put: OrderedCollection new.	diffHolder metaSide: 1 put: OrderedCollection new.	diffHolder nameSpacesSide: 2 put: OrderedCollection new.	diffHolder nameSpacesSide: 1 put: OrderedCollection new.	^diffHolder</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private - db storage</category><body package="Store-IMG-Pundles" selector="dbContent">dbContent	"Convert my component descriptions into a collection of database components."	^self contentDescriptions collect: 		[ :each | each asDBDescription ]</body><body package="Store-IMG-Pundles" selector="dbContentPundleFragments:">dbContentPundleFragments: aCollection	"Convert my component descriptions into a collection of database components,	using any existing fragments when they exist in aCollection"	^self contentDescriptions collect: 		[ :each | 		( aCollection detect: 			[ :pundle | each describesSameAs: pundle ] ifNone: [ each ]		) asDBDescription		]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>binary storage</category><body package="Store-IMG-Pundles" selector="dbLoadComponentsWithin:">dbLoadComponentsWithin: parentBundle	"Load all components from the DB.	If there is a problem while loading one of the components show  dialog and either fail loading 	this bundle and the encloasing bundles or continue."	self contentDescriptions do: 		[ :comp | 		[ comp dbLoadWithin: parentBundle ] on:  self class abortLoadingSignal do:			[ :ex | 			( self dialogForException: ex ) = #abort 				ifTrue: [ self class emergencyUnloadSignal raise ].			ex return			]		]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="emergencyUnload">emergencyUnload	"One of the components failed to load 	unload all compopnents loaded up to this point."	self contents reverseDo: 		[ :comp | comp notNil 					ifTrue: [ comp unloadFromGroup: self ] 		]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>external files</category><body package="Store-IMG-Pundles" selector="fileDescriptions">fileDescriptions	"Answer a collection of files for the current/last database connection"	| dbinfo |	^( dbinfo := self databaseInfomation ) == nil		ifTrue: [ self anyFileDescriptions ]		ifFalse: [ dbinfo fileDescriptions ].</body><body package="Store-IMG-Pundles" selector="fileDescriptions:">fileDescriptions: aCollectionOfFileModels	"Set my files to be aCollectionOfFileModels."	( self databaseInfomationOrCreate )		fileDescriptions: aCollectionOfFileModels.</body></methods><methods><class-id>Store.BundleModel</class-id> <category>printing</category><body package="Store-IMG-Pundles" selector="fileOutChangesForDb:on:within:">fileOutChangesForDb: dbid on: outputStream within: aBundle	"Write out all the changes the receiver knows about."	( ( UISettings preferenceFor: #fileoutOption ) == #never )		ifFalse: [ self fileOutChangedPropertiesForDb: dbid on: outputStream ].	self containedItems do: 		[ :pkg | pkg fileOutChangesForDb: dbid on: outputStream within: aBundle ]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private-file out</category><body package="Store-IMG-Pundles" selector="fileOutChangesOn:">fileOutChangesOn: aFileManager	Notice 		showProgress:  'Filing out changes for ', name 		complete: self changedItemCount 		while: [ self fileOutChangesOn: aFileManager within: self ]		title: 'Store'</body></methods><methods><class-id>Store.BundleModel</class-id> <category>printing</category><body package="Store-IMG-Pundles" selector="fileOutChangesOn:within:">fileOutChangesOn: outputStream within: aBundle	"Write out all the changes the receiver knows about."	| cset |	( ( UISettings preferenceFor: #fileoutOption ) == #never )		ifFalse: [ self fileOutChangedPropertiesOn: outputStream ].	self containedItems do: 		[ :pkg | pkg fileOutChangesOn: outputStream within: aBundle ].	( ( UISettings preferenceFor: #fileoutOption ) == #never )		ifFalse: 				[ cset := self changeSet.			( cset otherChangesInclude: self structureMark ) 				ifTrue: [ ( BundleStructureChange new component: self ) fileOutOn: outputStream ]			].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>initialize-release</category><body package="Store-IMG-Pundles" selector="initializeFromDB:">initializeFromDB: aDBBundle		self properties: aDBBundle properties.	self comment: aDBBundle commentOrNil.	self databaseInfomationOrCreate contentDescriptions:		( aDBBundle containedItems collect: [ :each | each asComponentDescription ] ).	self databaseInfomation fileDescriptions:		( aDBBundle files collect: [ :each | each asComponentDescription bundle: self ] ).	dbInfo removeKey: self noDbSymbol ifAbsent: nil. "now we be connected"</body><body package="Store-IMG-Pundles" selector="initializeFromImage:">initializeFromImage: anImgBundle	"Sets up the image model based on the database. Moves over database info from anImgBundle"	anImgBundle databaseInformationsDo:		[ :info | 		info isInCurrentDatabase			ifFalse: [ dbInfo at: info dbIdentifier put: info ].		].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="loadContentsFromDBWithin:">loadContentsFromDBWithin: parentBundle	"At this moment, descriptions are initialized I have to load components."	[ self dbLoadComponentsWithin: parentBundle.	self adjustComponents	] on: self class emergencyUnloadSignal do:		[:ex | 		self emergencyUnload.		ex pass		]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private-differences calculation</category><body package="Store-IMG-Pundles" selector="modifications">modifications	"Answer my content as a collection of modifications in order."	| mods |	mods := List new.	self leafItems do:		[ :pkg | mods addAll: pkg modifications ].	^mods</body><body package="Store-IMG-Pundles" selector="modificationsFor:">modificationsFor: dbid	"Answer my content as a collection of modifications in order."	| mods |	mods := List new.	mods addAll: ( self basicModificationsFor: dbid ).	self leafItems do:		[ :pkg | mods addAll: ( pkg modificationsFor: dbid ) ].	^mods</body></methods><methods><class-id>Store.BundleModel</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="pundleChangesClass">pundleChangesClass	^BundleChanges</body></methods><methods><class-id>Store.BundleModel</class-id> <category>db utilities</category><body package="Store-IMG-Pundles" selector="reconcileWithDb:">reconcileWithDb: dbPundle	"Change the receiver to reflect dbPundle as it's parent."			| dbItems |	self initializeForReconcileWith: dbPundle.	super reconcileWithDb: dbPundle.	dbItems := dbPundle containedItems.	self contentDescriptions do:		[ :desc | | comp match |		comp := desc component.		comp == nil 			ifFalse: 				[ comp hasTrace 					ifFalse:						[ ( match := dbItems detect: 							[ :dbitem |  							( ( comp isBundle == dbitem isBundle ) and: [ comp name = dbitem name ] )							] ifNone: [ nil ] ) == nil								ifFalse: 									[ comp reconcileWithDb: match.									].						].					desc  id: comp dbTrace.						"so we match"					desc dbIdentifier: dbPundle dbIdentifier.		"just in case"				].		].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>relationships</category><body package="Store-IMG-Pundles" selector="relatedBy:">relatedBy: token 	token == #tt_containsRel ifTrue: [^self contents asSet]."	token == #tt_derivesRRel ifTrue: [^G_Parent at: self ifAbsent: [G_Parent at: self put: (self class allVersionsWithPrimaryKey: self trace) asSet]]."	^super relatedBy: token</body></methods><methods><class-id>Store.BundleModel</class-id> <category>external files</category><body package="Store-IMG-Pundles" selector="removeFile:">removeFile: aFileDescription	self databaseInformationsDo:		[ :info | info removeFile: aFileDescription ].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private-validation</category><body package="Store-IMG-Pundles" selector="removeNonexistentComponentsRecursive">removeNonexistentComponentsRecursive	self databaseInformationsDo:		[ :info | info removeNonexistentComponentsRecursive ].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>parcel support</category><body package="Store-IMG-Pundles" selector="saveAsParcelFromSpecs:">saveAsParcelFromSpecs: publishSpec	"Save the receiver as a parcel -without creating the parcel in the image.	specs fullPathName is a directory/parcelName with no extension.	If specs bundleStructure is true, fill in the bundleStructure property with bundle/package contents.	If specs databaseLinks is true, save the db links for every component."	| dir link pname |	link := publishSpec databaseLinks.	 ( link &amp; self hasBeenModified )		ifTrue: 			[ ( Dialog confirm: 				( '&lt;t&gt;&lt;1s&gt; has unpublished modifications.&lt;n&gt;This means that database links will not be included.&lt;ntttt&gt;Continue?'						 expandMacrosWith: name ) )					ifFalse: [ ^self ].			link := false.			].	pname := publishSpec basePath asFilename tail.	dir := publishSpec basePath asFilename directory.	dir exists 		ifFalse:			[ ( Dialog confirm: ( 'Create directory &lt;1s&gt;?' expandMacrosWith: dir asString ) )				ifFalse: [ ^self ].			dir makeDirectory.			].	properties 		at: #bundleName put: self name;		at: #parcelName put: pname.	publishSpec bundleStructure		ifTrue: [ properties at: #bundleStructure put: ( PundleForParcel from: self saveLinks: link ) ].	[ self		parcelOutTo: ( dir construct: ( pname, '.pcl' ) ) asString		sourceFileName: ( dir construct: ( pname, '.pst' ) ) asString		parcelOptions: publishSpec.	] ensure:		[ properties			removeKey: #bundleStructure ifAbsent: [ ];			removeKey: #bundleName ifAbsent: [ ].		].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>db utilities</category><body package="Store-IMG-Pundles" selector="setNewTraceTo:">setNewTraceTo: dbPundle	"Change the receiver to reflect dbPundle as it's parent."			| dbItems |	super reconcileWithDb: dbPundle.	dbItems := dbPundle containedItems.	self contentDescriptions do:		[ :desc |  | match item |		item := desc component.		( item dbTrace == nil or: [ item dbTrace == 0 ] )			ifTrue:				[				( match := dbItems 					detect: 						[ :dbitem |  						( ( item isBundle == dbitem isBundle ) and: [ item name = dbitem name ] )						]					ifNone: [ nil ] ) == nil						ifFalse: 							[ item setNewTraceTo: match.							desc  id: item dbTrace.	"so we match"								].				].		].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private - db storage</category><body package="Store-IMG-Pundles" selector="storeInDB">storeInDB	"Store into the database all components that have been	modified then store the bundle description into the database."	Undeclared purgeUnusedBindings.	self removeNonexistentComponentsRecursive.	self validateOkayToPublish		ifTrue: [ PublishPundleDialog publishBundle: self ].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="typeStringForBlessing">typeStringForBlessing		^Blessing typeStringForBundles</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private-validation</category><body package="Store-IMG-Pundles" selector="validateLoadOrder">validateLoadOrder	"Examines NameSpace/Class prereqs to ensure that content list is in a valid order.	Answers a string of errors, or an empty string."	^self class validateLoadOrder: self leafItems.</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="validateOkayToPublish">validateOkayToPublish	| msg choice overs |	msg := 'One or more of the components in &lt;1s&gt; overrides another.&lt;n&gt;Publishing will cause one to replace the other when loading.&lt;nn&gt;It is recommend that you resolve these redundancies&lt;n&gt;before publishing.&lt;nnttttt&gt;Continue?' expandMacrosWith: self name.	self overridesSelf		ifFalse: [ ^true ].	choice := 		Dialog 			choose: msg			labels: #( 'Continue'  'View Overrides' 'Cancel' )			values: #( #yes #maybe #no )			default: #maybe.	choice == #no		ifTrue: [ ^false ].	choice == #maybe		ifTrue:			[  overs := OrderedCollection new.			self leafItems do:				[ :pkg | overs addAll: pkg overrides ].			OverrideList new openOn: overs.			^false.			].	^true</body></methods><methods><class-id>Kernel.CodeWriter</class-id> <category>api</category><body package="Store-IMG-Pundles" selector="writeForDb:">writeForDb: dbParcel 	"Store the parcel to a database record.  Answer true if successful."	| success |	analysisTracer trace: properties.	self traceNamedObjects.	newSourceKeys := IdentityDictionary new: analysisTracer compiledMethodCount * 3 // 2.	self createInternalSourceStreams.	hideOnLoad := false.	success := true.	[ self allocate.	self layout.	self storePackage.	stream close.	sourceStream close.	dbParcel blobData: stream contents.	dbParcel sourceData: sourceStream targetFile stream contents 	] ifCurtailed: [ success := false ].	^success</body></methods><methods><class-id>Store.PackageModel class</class-id> <category>binary storage</category><body package="Store-IMG-Pundles" selector="binLoadFromDB:within:">binLoadFromDB: aKey within: parentBundle	"Given a primary key get the instance of TT_Package 	from the database and load the new version."	| dbPkg |	[dbPkg := self databaseClass aRecordWithID: aKey. 	]	on: self errorSignals	do: [ :ex | ex outer. ^nil ].		dbPkg isNil 		ifTrue: [ self componentNotFoundSignal 					raiseErrorString: 'Cannot locate a package with ID = ' , aKey printString ].	^dbPkg loadSrcWithin: parentBundle warnReplace: false</body></methods><methods><class-id>Store.PackageModel class</class-id> <category>constants</category><body package="Store-IMG-Pundles" selector="databaseClass">databaseClass	^Package</body></methods><methods><class-id>Store.PackageModel class</class-id> <category>binary storage</category><body package="Store-IMG-Pundles" selector="describeBOSS:on:">describeBOSS: p on: strm	| lines | 	self shouldNotImplement.  "FOR REFERENCE ONLY"	lines := 0.	p first size &gt; 0		ifTrue: 			[strm nextPutAll: 'This package contains the classes:'.			p first				do: 					[:clsName | 					strm nextPut: Character cr.					lines := lines + 1.					lines &gt; 10 ifTrue: [strm nextPutAll: '...'. ^self].					strm nextPutAll: '   '.					strm nextPutAll: clsName].			strm nextPut: Character cr.			strm nextPut: Character cr].	strm nextPutAll: 'This package contains the methods: '.	(p at: 2)		do: 			[:sel | 			strm nextPut: Character cr.			lines := lines + 1.			lines &gt; 10 ifTrue: [strm nextPutAll: '...'. ^self].			strm nextPutAll: '   '.			strm nextPutAll: sel className.			strm nextPutAll: '&gt;&gt;'.			strm nextPutAll: sel selector].</body></methods><methods><class-id>Store.PackageModel class</class-id> <category>utilities</category><body package="Store-IMG-Pundles" selector="zeroTraceForAll">zeroTraceForAll	"self zeroTraceForAll"	Registry packagesDo: [:pkg | pkg setNoTrace].	Registry bundlesDo: [:bun | bun setNoTrace].</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="asDBDescription">asDBDescription	^( Packages new )"		expressionStr: condition; "	" not being used"		packageRef: self dbTrace;		yourself.</body><body package="Store-IMG-Pundles" selector="canReplaceVersions">canReplaceVersions	"Answer true if the users agrees to replace versions."	^self hasItselfBeenModified not or: 		[ ( Dialog				choose: 'Image package ' , self name , ' was modified.Replace it with a new version?'				labels: #('Replace' 'Cancel')				values: #(#replace #cancel)				default: #replace)				= #replace	   	]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="changedItemCount">changedItemCount	"Answer a count of work to be done for filing out changes	from the current database."	^self changeSet == nil		ifTrue: [ 0 ]		ifFalse: [ self changeSet itemCount ]</body><body package="Store-IMG-Pundles" selector="changedItemCountFor:">changedItemCountFor: dbid	"Answer a count of work to be done for filing out changes from the indicated database."	| cs |	^( cs := self changeSetFor: dbid ) == nil		ifTrue: [ 0 ]		ifFalse: [ cs itemCount ]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>public-change set access</category><body package="Store-IMG-Pundles" selector="changedMessageList">changedMessageList	^self changedMessageListFor: DbRegistry dbIdentifier</body><body package="Store-IMG-Pundles" selector="changedMessageListFor:">changedMessageListFor: dbIdentifier	| cs |	^( cs := self changeSetFor: dbIdentifier ) == nil		ifTrue: [ #( ) ]		ifFalse: [ cs modifiedMethodDescriptors ]</body><body package="Store-IMG-Pundles" selector="changedMethodList">changedMethodList	^self isChangeSetEmpty		ifTrue: [Array new]		ifFalse: [self changeSet modifiedMethodDescriptors  ]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-differences calculation</category><body package="Store-IMG-Pundles" selector="changeSetClassDiffsBetweenDBPackage:into:">changeSetClassDiffsBetweenDBPackage: aTracePackage into: diff 	"Compute differences between me and my trace package. 	Use change set."	| classes2 classes1 meta2 meta1 namespaces1 namespaces2 |	namespaces2 := self affectedNameSpaceNames.	namespaces1 := Set new: namespaces2 size.	classes2 := self affectedClassNamesMeta: false.	classes1 := Set new: classes2 size.	meta2 := self affectedClassNamesMeta: true.	meta1 := Set new: meta2 size.	aTracePackage notNil		ifTrue: 			[ namespaces2 do: 				[: nsName | | nsDb |				nsDb := aTracePackage nameSpaceInPackageNamed: nsName.				nsDb notNil ifTrue: [ namespaces1 add: nsDb ]				].			classes2 do: 				[:cName | | cdb |				cdb := aTracePackage classInPackageNamed: cName meta: false.				cdb notNil ifTrue: [ classes1 add: cdb ]				].			meta2 do: 				[:cName | | cdb |				cdb := aTracePackage classInPackageNamed: cName meta: true.				cdb notNil ifTrue: [meta1 add: cdb]				].			self removedClassOrDefinitionNames do: 				[:cName | | cdb |				cdb := aTracePackage classInPackageNamed: cName meta: false.				cdb notNil ifTrue: [ classes1 add: cdb ].				cdb := aTracePackage classInPackageNamed: cName meta: true.				cdb notNil ifTrue: [ meta1 add: cdb ]				].			self removedNameSpaceOrDefinitionNames do: 				[ :nsName | | cdb |				cdb := aTracePackage nameSpaceInPackageNamed: nsName.				cdb notNil ifTrue: [ namespaces1 add: cdb ].				]			].	diff nameSpacesSide: 2 put: ( namespaces2 collect: [:cName | NameSpaceDescriptor new fullName: cName ] ).	diff nameSpacesSide: 1 put: namespaces1.	diff classesSide: 2 put: ( classes2 collect: [:cName | ClassDescriptor fullName: cName meta: false ] ).	diff classesSide: 1 put: classes1.	diff metaSide: 2 put: (meta2 collect: [:cName | ClassDescriptor fullName: cName meta: true ] ).	diff metaSide: 1 put: meta1.</body><body package="Store-IMG-Pundles" selector="changeSetDataDiffsBetweenDBPackage:into:">changeSetDataDiffsBetweenDBPackage: aTracePackage into: diff 	"Compute differences between me and my trace package. 	Use change set."	"Get all modified data."	| data2 data1 |	data2 := self modifiedDatumDescriptors.	data1 := Set new: data2 size.	aTracePackage notNil		ifTrue: 			[ data2 do: 				[:dd | | ddb |				ddb := aTracePackage datum: dd dataKey forOwnerNamed: dd ownerName.					ddb notNil ifTrue: [ data1 add: ddb ]			].			self removedDatumDescriptors do: 				[ :dd | 	| ddb |				ddb := aTracePackage datum: dd dataKey forOwnerNamed: dd ownerName.				ddb == nil ifFalse: [ data1 add: ddb ]				]			].		"At this point data1 contains data that are only in a trace package 	and data2 data that are only the receiver."	diff dataSide: 2 put: data2.	diff dataSide: 1 put: data1.</body><body package="Store-IMG-Pundles" selector="changeSetDiffsBetweenDBPackage:into:">changeSetDiffsBetweenDBPackage: aTracePackage into: diff 	"Compute differences between me and my trace package. 	Use change set."	self changeSetClassDiffsBetweenDBPackage: aTracePackage into: diff.	self changeSetMethodDiffsBetweenDBPackage: aTracePackage into: diff.	self changeSetDataDiffsBetweenDBPackage: aTracePackage into: diff.	self computeOverrideDiffsBetweenDBPackage: aTracePackage into: diff.	^diff</body><body package="Store-IMG-Pundles" selector="changeSetMethodDiffsBetweenDBPackage:into:">changeSetMethodDiffsBetweenDBPackage: aTracePackage into: diff 	"Compute differences between me and my trace package. 	Use change set."	"Get all modified methods."	| meth2 meth1 | 	meth2 := self modifiedAndReorganizedMethodDescriptors.	meth1 := Set new: meth2 size.	aTracePackage notNil		ifTrue: 			[ meth2 do: 				[ :md | | mdb |				mdb := aTracePackage							method: md selector							forClassNamed: md className asClassNameOnly							meta: md isMeta.				mdb notNil ifTrue: [ meth1 add: mdb ]				].			self removedMethodDescriptors do: 				[ :md | | mdb |				mdb := aTracePackage							method: md selector							forClassNamed: md className asClassNameOnly							meta: md isMeta.				mdb notNil ifTrue: [ meth1 add: mdb ]				]			].		"At this point meth1 contains methods that are only in a trace package 	and meth2 methods that are only the receiver."	diff methodsSide: 2 put: meth2.	diff methodsSide: 1 put: meth1.</body></methods><methods><class-id>Store.PackageModel</class-id> <category>public-change set access</category><body package="Store-IMG-Pundles" selector="checkChangeSet">checkChangeSet	"(TT_Registry packageNamed: 'TT-Code') checkChangeSet"	(self isChangeSetEmpty) ifTrue: [^true].	^#proceed == (Dialog		choose: 'Package "', self name, '" has unpublished changes.Do you wish to discard those changes?'		labels: (Array with: 'OK' with: 'Cancel')		values: #(#proceed #cancel)		default: #cancel)</body></methods><methods><class-id>Store.PackageModel</class-id> <category>consistency checking</category><body package="Store-IMG-Pundles" selector="checkConsistencyOn:">checkConsistencyOn: aStream 	self cleanse.	self isChangeSetEmpty ifFalse: [ self changeSet checkConsistencyInPackage: self on: aStream ].	self	modelsDo: 		[ :model | 		( Registry modelsForSymbol: model absoluteSymbol ) detect: 			[ :aModel | aModel == model ] ifNone:				[ aStream nextPutAll: 'model "' , model absoluteSymbol , '" in package '.				self printOn: aStream.				aStream nextPutAll: ' is not registered'.				aStream cr				]		].</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-consistency checking</category><body package="Store-IMG-Pundles" selector="checkIfPublishedIsEqual">checkIfPublishedIsEqual	"Test is the published version contains exactly the same definitions."	| diff myParent |	myParent := self parentRecord.	myParent == nil		ifTrue: 			[ ( myParent := Package mostRecentVersionOfPundleWithName: name ) == nil 				ifFalse: [ self dbTrace: myParent primaryKey ].			].	myParent notNil		ifTrue: 			[			Notice show: 'Comparing versions of package ' , self name , '.'	while: 				[ diff := PackageDifferences new.				diff pkgSide: 2 put: self; pkgSide: 1 put: myParent.				self computeFullDiffsBetweenDBPackage: myParent into: diff				]			].	^diff</body></methods><methods><class-id>Store.PackageModel</class-id> <category>binary storage</category><body package="Store-IMG-Pundles" selector="classListForPackage">classListForPackage	^self definedClassModels collect: [:cm| cm actualClass]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="classOfDbRecord">classOfDbRecord	"Answer a class which is used to represent packages in the database."	^Package</body></methods><methods><class-id>Store.PackageModel</class-id> <category>binary storage</category><body package="Store-IMG-Pundles" selector="compiledMethods">compiledMethods	| comp |	comp := OrderedCollection new.	self classModelsDo: [:cm| comp addAll: cm compiledMethods].	^comp</body></methods><methods><class-id>Store.PackageModel</class-id> <category>table of contents</category><body package="Store-IMG-Pundles" selector="completeTableOfContentsNamed:">completeTableOfContentsNamed: aString	self tableOfContentsOnFile: aString, '.toc'.	( PundleParentMap  on: self ) writeParentsToFile: aString, '.tbl'.</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-differences calculation</category><body package="Store-IMG-Pundles" selector="computeDiffsBetween:into:">computeDiffsBetween: aPackage into: diffHolder 	"Since the receiver is a loaded package an argument aPackage 	has to be a DB packagge."		[diffHolder reverse.	self computeDiffsBetweenDBPackage: aPackage into: diffHolder]		ensure: [diffHolder reverse].	^diffHolder</body><body package="Store-IMG-Pundles" selector="computeDiffsBetweenDBPackage:into:">computeDiffsBetweenDBPackage: aDBPackage into: diff	"Store  differences between receiver and a aDBPackage 	into an instance of TT_PackageDifferences.	Store receiver's definitions as number-2 since this method	is called with arguments reversed.	The comparison is done in two steps. First we compare,	image with trace and then we compare trace	with aDBpackage and combine the restults."	|  tracePkg diff2| 	"If aDB package is a pseudo package use change set only"	(aDBPackage pseudoPackage) 		ifTrue: [^self changeSetDiffsBetweenDBPackage: aDBPackage into: diff].	((self otherChangesInclude: self parentChangedMark) 			or: [(tracePkg := self tracePackage) isNil  					or: [self userWantsFullCompare]])		ifTrue: 			["I do not have a paraent package do the full comparison"			^self computeFullDiffsBetweenDBPackage: aDBPackage into: diff].	"Calculate differences between me and the trace."	self changeSetDiffsBetweenDBPackage: tracePkg into: diff.	(aDBPackage sameAs: tracePkg) 		ifTrue: ["We are done" ^self].	"Now calculate differences between my trace and aDBPackage." 	diff2 := PackageDifferences with: aDBPackage with: tracePkg. 	diff combineDiffsFrom: diff2.	^diff</body><body package="Store-IMG-Pundles" selector="computeFullDiffsBetweenDBPackage:into:">computeFullDiffsBetweenDBPackage: aDBPackage into: diff	"Store  differences between receiver and a aDBPackage 	into an instance of TT_PackageDifferences.	Store receiver's definitions as number2 since this method	is called with arguments reversed."	| coll1 coll2 ts  | 	self debugVersionOnly.	ts := Time now.	"methods"	coll1 := aDBPackage methods asSet.	coll2 := OrderedCollection new: coll1 size.	self methods do: [:method| coll1 remove: method ifAbsent: [ coll2 add: method]]. 	"At this point coll1 contains methods that are only in aDBPackage	and coll2 methods that are only the receiver."	diff methodsSide: 2 put: coll2.	diff methodsSide: 1 put: coll1.	"data"	coll1 := aDBPackage data asSet.	coll2 := OrderedCollection new: coll1 size.	self data do: [:datum| coll1 remove: datum ifAbsent: [ coll2 add: datum]]. 	"At this point coll1 contains data that are only in aDBPackage	and coll2 data that are only the receiver."	diff dataSide: 2 put: coll2.	diff dataSide: 1 put: coll1.	"namespaces"	coll1 := aDBPackage nameSpacesDefinedInPackage copy.	coll2 := OrderedCollection new: coll1 size.	self nameSpacesDefinedInPackage do: [:x| coll1 remove: x ifAbsent: [coll2 add: x]].	diff nameSpacesSide: 2 put: coll2.	diff nameSpacesSide: 1 put: coll1.	"classes"	coll1 := aDBPackage classesDefinedInPackage copy.	coll2 := OrderedCollection new: coll1 size.	self classesDefinedInPackage do: [:x| coll1 remove: x ifAbsent: [coll2 add: x]].	diff classesSide: 2 put: coll2.	diff classesSide: 1 put: coll1.	coll1 := aDBPackage metaclassesDefinedInPackage copy.	coll2 := OrderedCollection new: coll1 size.	self metaclassesDefinedInPackage do: [:x| coll1 remove: x ifAbsent: [ coll2 add: x]].	diff metaSide: 2 put: coll2.	diff metaSide: 1 put: coll1.	self computeOverrideDiffsBetweenDBPackage: aDBPackage into: diff.	Transcript cr; show: 'Comparison done: ', (Time now subtractTime: ts) asSeconds printString.	^diff</body><body package="Store-IMG-Pundles" selector="computeOverrideDiffsBetweenDBPackage:into:">computeOverrideDiffsBetweenDBPackage: aTracePackage into: diff 	"Add overriden stuff to diff. Valid for all methods of calculation"	self overrides do:		[ :over | over addDiffTo: aTracePackage into: diff ]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>binary storage</category><body package="Store-IMG-Pundles" selector="currentTag">currentTag 	^self class currentTag</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-file out</category><body package="Store-IMG-Pundles" selector="fileOutChangesOn:within:">fileOutChangesOn: aFileManager within: aBundle	self fileOutChangesForDb: DbRegistry dbIdentifier on: aFileManager within: aBundle</body></methods><methods><class-id>Store.PackageModel</class-id> <category>binary storage</category><body package="Store-IMG-Pundles" selector="indexTag">indexTag	^self class indexTag</body></methods><methods><class-id>Store.PackageModel</class-id> <category>testing</category><body package="Store-IMG-Pundles" selector="isSaveable">isSaveable	"Answer true if ok to save"	"NOTE: must match #isSaveableWithWarning"	^( ( ( self  isNullPackage not and: [ super isSaveable ] )			and: [ self checkUndeclared not ] ) )			and: [ self hasUninstalledCode not ]</body><body package="Store-IMG-Pundles" selector="isSaveableWithWarning">isSaveableWithWarning	"Answer true if ok to save. If not, display a warning and answer false."	"NOTE: must match #isSaveable"	self  isNullPackage 		ifTrue: [ Dialog warn: 'The Null package cannot be saved.'. ^false ].	super isSaveableWithWarning		ifFalse: [ ^false ].	self checkUndeclared		ifFalse: [ Dialog warn: name, ' contains values in Undeclared. Please correct before publishing.'. ^false ].	self hasUninstalledCode		ifTrue: [ Dialog warn: name, ' has uninstalled code.'. ^false ].	^true.</body></methods><methods><class-id>Store.PackageModel</class-id> <category>binary storage</category><body package="Store-IMG-Pundles" selector="literalClassListForPackage">literalClassListForPackage	^(self definedClassModels 		collect: [:cm | cm className])			asArray</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-differences calculation</category><body package="Store-IMG-Pundles" selector="modifications">modifications	"Answer my content as a collection of modifications."	| mods |	mods := List new.	self isChangeSetEmpty ifTrue: [ ^mods ].	self changeSet modifiedTags do: 		[ :tag | mods add: 				( TextModification					tag: tag					package: self					text: tag sourceTextForImage				)		].	self changeSet removedTags do: 		[ :tag | mods add: 				( TextModification					tag: tag					package: self					text: nil				)		].	^mods</body></methods><methods><class-id>Store.PackageModel</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="pundleChangesClass">pundleChangesClass	^PackageChanges</body></methods><methods><class-id>Store.PackageModel</class-id> <category>binary storage</category><body package="Store-IMG-Pundles" selector="readFromCodeReader:">readFromCodeReader: aReader 	self comment: aReader comment.	aReader classes do: [:cl | self addFullClassSymbol: cl fullClassSymbol].	aReader extensionMethods do: [:marr | 		self addSelector: (marr at: 1)			class: (marr at: 2) mclass].	self markNotModified</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-descriptors</category><body package="Store-IMG-Pundles" selector="reorganizedMethodDescriptors">reorganizedMethodDescriptors	| parentID meths |	(DbRegistry isOnline and: [self hasTrace])		ifFalse: [^Array new].	parentID := self dbTrace.	meths := Set new. 	self changeSet reorganizedClassNames		do: 			[:cName | 			| actualClass isMeta |			isMeta := cName namesMetaClass.			actualClass := cName asClassNameOnly asStrictReference value.			isMeta ifTrue: [actualClass := actualClass class].			actualClass organization elements				do: 					[:mSym | 					| traceMethod |					traceMethod := MethodsView								methodNamed: mSym								class: cName								package: parentID.					(traceMethod notNil and: [(actualClass organization categoryOfElement: mSym)							~= traceMethod protocol])						ifTrue: [meths add: (MethodDescriptor fromSelector: mSym className: cName meta: isMeta )]]].	^meths</body></methods><methods><class-id>Store.PackageModel</class-id> <category>parcel support</category><body package="Store-IMG-Pundles" selector="saveAsParcelFromSpecs:">saveAsParcelFromSpecs: publishSpec	"Save the receiver as a parcel -without creating the parcel in the image.	specs fullPathName is a directory/parcelName with no extension."	| dir pname |	pname := publishSpec basePath asFilename tail.	dir := publishSpec basePath asFilename directory.	dir exists 		ifFalse:			[ ( Dialog confirm: ( 'Create directory &lt;1s&gt;?' expandMacrosWith: dir asString ) )				ifFalse: [ ^self ].			dir makeDirectory.			].	properties at: #packageName put: name.	self		parcelOutTo: ( dir  construct: ( pname, '.pcl' ) ) asString		sourceFileName: ( dir construct: ( pname, '.pst' ) ) asString		parcelOptions: publishSpec.</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private - db storage</category><body package="Store-IMG-Pundles" selector="storeInDB">storeInDB	"Store the source code into DB and empty the change set."	Undeclared purgeUnusedBindings.	self removeEmptyModels.	self isSaveableWithWarning		ifTrue: [ self classOfDbRecord fromPackage: self ]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>accessing- fake</category><body package="Store-IMG-Pundles" selector="typeStringForBlessing">typeStringForBlessing		^Blessing typeStringForPackages</body></methods><methods><class-id>Store.PackageModel</class-id> <category>unloading</category><body package="Store-IMG-Pundles" selector="unloadLogged:">unloadLogged: log	"TEMP- compatiblity"	self unloadFromImage		ifTrue:			[ ChangeSet unloadComponent: self.			SourceFileManager default unloadComponent: self.			].</body><body package="Store-IMG-Pundles" selector="unloadProblemsQuery:">unloadProblemsQuery: problems	| probStream |	probStream := WriteStream on: String new.	probStream nextPutAll: 'Classes in package still in use:'; cr.	problems size = 0 ifTrue: [^true].	problems size &lt; 20 		ifTrue: [problems do: [:prob| 			probStream nextPutAll: prob.			probStream cr]]		ifFalse: [1 to: 14 do: [:inx|  			probStream nextPutAll: (problems at: inx).			probStream cr].			probStream nextPutAll: '...'; cr].	^#proceed == (Dialog		choose: probStream contents		labels: (Array with: 'Proceed' with: 'Cancel')		values: #(#proceed #cancel)		default: #cancel)</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-load/unload</category><body package="Store-IMG-Pundles" selector="updateFrom:within:">updateFrom: aStoreParcelRecord within: aBundleOrNil	"Load code from aStoreParcelRecord (a fast-loading binary parcel stream) and update the system with the new code.	 Update the receiver to reflect the new code. Answer the receiver."	| aCodeReader |	aCodeReader := CodeReaderForStore new.	"First get the CodeReader to read-in all code objects into shadow namespaces	 internal to the CodeReader, leaving the system unmodified."	[ self startLoad.	self class		handleCodeReaderSignalsDo: [aCodeReader readFrom: aStoreParcelRecord]		for: aStoreParcelRecord.	] ensure: [ self endLoad ].	^self		updateCodeReadBy: aCodeReader		from: aStoreParcelRecord		within: aBundleOrNil</body></methods><methods><class-id>Kernel.CodeReader</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="createStreamFromRecord:">createStreamFromRecord: aParcelRecord 	| tmp |	stream := InternalCodeReaderStream on: aParcelRecord blobData.	tempSourceFile := aParcelRecord defaultParcelName , '.pst'.	streamDir := aParcelRecord class parcelDirectory.	streamDir exists 		ifFalse:	[ streamDir asFilename makeDirectory ].	tmp := streamDir construct: tempSourceFile.	tmp exists		ifFalse: 			[ tmp := ( tmp withEncoding: #binary ) writeStream.			[ tmp nextPutAll: aParcelRecord sourceData ]				ensure: [ tmp close ]			].</body></methods><methods><class-id>Kernel.CodeReader</class-id> <category>api</category><body package="Store-IMG-Pundles" selector="readFromRecord:">readFromRecord: aParcelRecord	self createStreamFromRecord: aParcelRecord.	[self readPackage] ensure: [stream close]</body></methods><methods><class-id>Kernel.CodeReader</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="readHeaderFromRecord:">readHeaderFromRecord: aParcelRecord	"Answer aDictionary of the header information from the Parcel data 	 contained in aParcelRecord."	| info |	info := self readInfoFromRecord: aParcelRecord.	^info 		at: #stats put: ((Dictionary new)							at: #objectSpaceSize put: objectSpaceSize;							at: #mclassNum put: mclassNum;							at: #mclassclassNum put: mclassclassNum;							at: #refNamObjNum put: refNamObjNum;							at: #numNamedObjects put: numNamedObjects;							at: #numClasses put: numClasses;							at: #numExtensionMethods put: numExtensionMethods;							at: #scopeZonesNum put: scopeZonesNum;							at: #symbolNum put: symbolNum;							at: #twoByteSymbolNum put: twoByteSymbolNum;							at: #stringNum put: stringNum;							at: #twoByteStringNum put: twoByteStringNum;							at: #byteArrayNum put: byteArrayNum;							at: #floatNum put: floatNum;							at: #doubleNum put: doubleNum;							at: #largePositiveNum put: largePositiveNum;							at: #largeNegativeNum put: largeNegativeNum;							at: #fixedNum put: fixedNum;							at: #classOrganizerNum put: classOrganizerNum;							at: #arbClassNum put: arbClassNum;							at: #arbObjectNum put: arbObjectNum;							at: #userStringsNum put: userStringsNum;							at: #namedObjectsNum put: namedObjectsNum;							yourself);		at: #sourceFile put: sourceFile;		at: #hideSource put: hideSource;		yourself</body></methods><methods><class-id>Kernel.CodeReader</class-id> <category>api</category><body package="Store-IMG-Pundles" selector="readInfoFromRecord:">readInfoFromRecord: aParcelRecord	"Answer a Dictionary of useful information from the Parcel named aParcelRecord."	| info timestamp |	info := Dictionary new.	self createStreamFromRecord: aParcelRecord.	[self readHeader.	format &gt;= 7 ifTrue:		[info at: #prerequisiteParcels put: OrderedCollection new.		[self readPrerequisites]			on: CodeReader prerequisiteSignal			do: [:ex|				ex parameter first = 'parcel'					ifTrue:						[(info at: #prerequisiteParcels)							add: (ex parameter copyFrom: 2 to: 3)]					ifFalse:						[info at: ex parameter first asSymbol							put: (ex parameter copyFrom: 2 to: ex parameter size - 1)].				ex resume]]]		ensure: [stream close].	parcelName size &gt; 0 ifTrue: [info at: #parcel put: parcelName].	versionString size &gt; 0 ifTrue: [info at: #version put: versionString].	info at: #format put: format.	timestamp := Timestamp readFromDateAndTime: (dateString, ' ', timeString) readStream.	timestamp notNil ifTrue:		[info at: #timestamp put: timestamp].	^info</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>Signal constants</category><body package="Store-IMG-Pundles" selector="abortLoadingSignal">abortLoadingSignal	^ComponentDescription cannotLoadComponentSignal.</body><body package="Store-IMG-Pundles" selector="abortUnloadingSignal">abortUnloadingSignal	^ComponentDescription cannotUnloadComponentSignal.</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>utility</category><body package="Store-IMG-Pundles" selector="allDatabasesFor:">allDatabasesFor: pundles	"Answer a list of existing db names linked to pundles."	| dbs |	dbs := Set new.	pundles do: [ :p | dbs addAll: p allDatabases ].	^dbs asSortedCollection</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="changeSetClass">changeSetClass	^XChangeSet</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>Signal constants - parcel compat</category><body package="Store-IMG-Pundles" selector="classAlreadyLoadedSignal">classAlreadyLoadedSignal	^Parcel classAlreadyLoadedSignal</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>Signal constants</category><body package="Store-IMG-Pundles" selector="compilationErrorSignal">compilationErrorSignal	^ParagraphEditor compilationErrorSignal</body><body package="Store-IMG-Pundles" selector="componentNotFoundSignal">componentNotFoundSignal	^Pundle componentNotFoundSignal</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="currentBosFormat">currentBosFormat 	^1</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>utility</category><body package="Store-IMG-Pundles" selector="databaseListFor:">databaseListFor: pundles	"Answer a list of existing db names linked to pundles."	| dbs |	dbs := Set new.	pundles do: [ :p | dbs addAll: p databaseList ].	^dbs asSortedCollection</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>Signal constants</category><body package="Store-IMG-Pundles" selector="emergencyUnloadSignal">emergencyUnloadSignal	^EmergencyUnloadSignal</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>private-loading</category><body package="Store-IMG-Pundles" selector="handlePrerequisite:">handlePrerequisite: anArray 	"With StORE loading all prereqs have been loaded before the CodeReader	 is used to load code, so we can ignore all prerequisites."	^self</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>Signal constants - parcel compat</category><body package="Store-IMG-Pundles" selector="invalidClassFormatSignal">invalidClassFormatSignal	^Parcel invalidClassFormatSignal</body><body package="Store-IMG-Pundles" selector="invalidNamedObjectSignal">invalidNamedObjectSignal	^Parcel invalidNamedObjectSignal</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>Signal constants</category><body package="Store-IMG-Pundles" selector="mismatchedDatabaseSignal">mismatchedDatabaseSignal	^Store.MismatchedDatabaseError</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>Signal constants - parcel compat</category><body package="Store-IMG-Pundles" selector="missingClassSignal">missingClassSignal	^Parcel missingClassSignal</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="allDatabases">allDatabases	"Answer an array of datbase identifiers that the receiver has links to"	^( ( dbInfo select: [ :info | info hasTrace ] )		collect: [ :info | info dbIdentifier ]	) asArray.</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-differences calculation</category><body package="Store-IMG-Pundles" selector="basicModificationsFor:">basicModificationsFor: dbid	"Answer my content as a collection of modifications."	| mods cs |	mods := List new.	cs := self changeSetFor: dbid.	cs == nil		ifTrue: [ cs :=  ( dbInfo at: self noDbSymbol ifAbsent: [ ^mods ] ) changeSet ].	cs isEmpty ifTrue: [ ^mods ].	cs modifiedTags do: 		[ :tag | mods add: 				( TextModification					tag: tag					package: self					text: ( tag sourceTextForImage: self )				)		].	cs removedTags do: 		[ :tag | mods add: 				( TextModification					tag: tag					package: self					text: nil				)		].	^mods</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-db management</category><body package="Store-IMG-Pundles" selector="canBePublishedToCurrentDatabase">canBePublishedToCurrentDatabase	"Answer true if the receiver can safely be published to the current database."	( self hasTraceFor: DbRegistry dbIdentifier )		ifTrue: [ ^true ].	^( self class databaseClass hasVersionNamed: name ) not</body><body package="Store-IMG-Pundles" selector="changeSet">changeSet	"Answer a changeset for the current/last database connection"	| dbinfo |	( dbinfo := self databaseInfomation ) == nil		ifTrue: [ dbinfo := self databaseInfomationForOrCreate: self noDbSymbol ].	^dbinfo changeSet.</body><body package="Store-IMG-Pundles" selector="changeSetFor:">changeSetFor: aDatabaseId	"Answer a changeset for the specified database connection"	| dbinfo |	^( dbinfo := self databaseInformationFor: aDatabaseId ) == nil		ifFalse: [ dbinfo changeSet ].</body></methods><methods><class-id>Store.PundleModel</class-id> <category>TEMP</category><body package="Store-IMG-Pundles" selector="convertDbInfos">convertDbInfos	| new |	new := IdentityDictionary new.	dbInfo keysAndValuesDo:		[ :key : value |		new at: key asSymbol put: value 		].	dbInfo := new.</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="databaseId">databaseId	"Answer the db identifier for the current connection, nil if none."	^self dbIdentifier</body><body package="Store-IMG-Pundles" selector="databaseId:">databaseId: dbIndentifier 	"Set the database identifier."	self dbIdentifier: dbIndentifier</body><body package="Store-IMG-Pundles" selector="databaseList">databaseList	"Answer an array of datbase identifiers wheter the receiver has links or not"	^dbInfo keys</body><body package="Store-IMG-Pundles" selector="dbTrace:">dbTrace: aKeyOfDBPackage 	"Store a key of the trace package."	self databaseInfomationOrCreate		dbTrace: aKeyOfDBPackage.</body><body package="Store-IMG-Pundles" selector="dbTraceFor:">dbTraceFor: databaseId	"Answer the db parent id for the specified database, nil if none."	| info |	^( info := self databaseInformationFor: databaseId ) == nil		ifFalse: [ info dbTrace ].</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-load/unload</category><body package="Store-IMG-Pundles" selector="doComponentLoadedActions">doComponentLoadedActions	self needsMoreWork</body><body package="Store-IMG-Pundles" selector="doComponentUpdatingActions:">doComponentUpdatingActions: codeReader	self needsMoreWork</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-db management</category><body package="Store-IMG-Pundles" selector="emptyChangeSet">emptyChangeSet	"Empty the currently active ChangeSet."	| info |	( info := self databaseInfomation ) == nil		ifFalse: 			[ self updateAfterDo:  				[ info emptyChangeSet ]			]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-file out</category><body package="Store-IMG-Pundles" selector="fileOutChangedPropertiesOn:">fileOutChangedPropertiesOn: aFileManager	"File out only changed, saveable properties to aFileManager."	self fileOutChangedPropertiesForDb: DbRegistry dbIdentifier on: aFileManager.</body><body package="Store-IMG-Pundles" selector="fileOutChangesForDb:on:">fileOutChangesForDb: dbid on: aFileManager	Notice 		showProgress:  'Filing out changes for ', name 		complete: ( self changedItemCountFor: dbid ) 		while: [ self fileOutChangesForDb: dbid on: aFileManager within: nil ]		title: 'Store'</body><body package="Store-IMG-Pundles" selector="fileOutChangesOn:">fileOutChangesOn: aFileManager	Notice 		showProgress:  'Filing out changes for ', name 		complete: self changedItemCount 		while: [ self fileOutChangesOn: aFileManager within: nil ]		title: 'Store'</body></methods><methods><class-id>Store.PundleModel</class-id> <category>testing</category><body package="Store-IMG-Pundles" selector="hasBeenModifiedIn:">hasBeenModifiedIn: aDatabaseId	"Answer true if the receiver or a subcomponent has been modified within a database."		| info |	^( info := self  databaseInformationFor: aDatabaseId ) == nil		ifTrue: [ false ]		ifFalse: [ info isChangeSetEmpty not ]</body><body package="Store-IMG-Pundles" selector="hasItselfBeenModified">hasItselfBeenModified	"Return true if the receiver itself has been modified.  Does not consider whether	 contained items have been modified"	^self isChangeSetEmpty not</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-db management</category><body package="Store-IMG-Pundles" selector="hasTrace">hasTrace	^self dbTrace notNil and: [ self dbTrace ~= 0 ]</body><body package="Store-IMG-Pundles" selector="hasTraceFor:">hasTraceFor: aString	"Answer true if the receiver has a parent in the database, aString."	| info |	^( info := self databaseInformationFor: aString ) == nil		ifTrue: [ false ]		ifFalse: [ info hasTrace ]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>public-change set access</category><body package="Store-IMG-Pundles" selector="inspectChangeSet">inspectChangeSet	self databaseInformationsDo:		[ :info | info inspectChangeSet ]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>testing</category><body package="Store-IMG-Pundles" selector="isChangeSetEmpty">isChangeSetEmpty		| info |	^( info := self databaseInfomation ) == nil		ifTrue: [ true ]		ifFalse: [ info isChangeSetEmpty ]</body><body package="Store-IMG-Pundles" selector="isConnectedToAny">isConnectedToAny	^dbInfo contains: 		[ :info | info hasTrace ].</body><body package="Store-IMG-Pundles" selector="isInCurrentDatabase">isInCurrentDatabase	^dbInfo keys includes: DbRegistry dbIdentifier</body><body package="Store-IMG-Pundles" selector="isSaveable">isSaveable	"Answer true if ok to save. If not, display a warning and answer false."	"NOTE: must match #isSaveableWithWarning"	readonly == nil		ifTrue: [ readonly := false ].	^readonly not.</body><body package="Store-IMG-Pundles" selector="isSaveableWithWarning">isSaveableWithWarning	"Answer true if ok to save. If not, display a warning and answer false."	"NOTE: must match #isSaveable"	readonly == nil		ifTrue: [ readonly := false ].	^readonly		ifTrue: [ Dialog warn: name, ' was converted from a Parcel with uninstalled code.'. false ]		ifFalse: [ true ].</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-db management</category><body package="Store-IMG-Pundles" selector="otherChangesInclude:">otherChangesInclude: aChange 	^self isChangeSetEmpty		ifTrue: [false]		ifFalse: [self changeSet otherChangesInclude: aChange]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>ownership</category><body package="Store-IMG-Pundles" selector="owner">owner	"Returns the owner of the pundle"	^Policies ownershipPolicy ownerOfPundle: self</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="parentChangedMark">parentChangedMark	^#parentChanged</body><body package="Store-IMG-Pundles" selector="parentRecord">parentRecord	"Answer an instance of the database record that echos the receiver.	Use the dbTrace field to retrieve record from the DB. For new packages/bundles trace can be nil."	| res |	Store.DbRegistry isOnline ifFalse: [ ^nil ].	self dbTrace == nil ifTrue: [ ^nil ].	( self dbIdentifier notNil and: [ self dbIdentifier = Store.DbRegistry dbIdentifier ] )		ifFalse: [ ^nil ].	[ res := self classOfDbRecord aRecordWithID: self dbTrace ]		on: self errorSignals		do: [ :ex | ex outer. ^nil ].	res == nil		ifTrue: [ ( Warning raiseSignal: ( 'Parent expected for &lt;1s&gt;, but not found.  Proceed?' expandMacrosWith: self name ) )			ifTrue: [ ^nil ]			ifFalse: [ self error: 'nil erroneously returned - call your Store administrator.'.  ] ].	^res</body><body package="Store-IMG-Pundles" selector="parentVersionString">parentVersionString	"Answer a string describing the parent version."	| trRec |	^( trRec := self parentRecord ) == nil 		ifTrue: [ '' ]		ifFalse: [ trRec version ]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>testing</category><body package="Store-IMG-Pundles" selector="pseudoPackage">pseudoPackage	"Answer false since I'm genuine."	^false</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="pundleChangesClass">pundleChangesClass	self subclassResponsibility</body></methods><methods><class-id>Store.PundleModel</class-id> <category>db utilities</category><body package="Store-IMG-Pundles" selector="reconcileWithDb">reconcileWithDb	"Select a database pundle as the new parent of the receiver."	| dbPundle |	( dbPundle := self selectVersion ) == nil		ifTrue: [ ^nil ].	self  isBundle 		ifTrue: [ self allItems do: [ :i | i setNoTrace ] ]		ifFalse: [ self setNoTrace ].	self reconcileWithDb: dbPundle.</body><body package="Store-IMG-Pundles" selector="reconcileWithDb:">reconcileWithDb: dbPundle	"Change the receiver to reflect dbPundle as it's parent."		| info |	info := self databaseInfomationOrCreate.	info dbTrace: nil.	info changeSet:		( self pundleChangesClass with: self with: dbPundle ) changeSet1.	info dbTrace: dbPundle primaryKey.	dbInfo removeKey: self noDbSymbol ifAbsent: nil. "now we be connected"</body><body package="Store-IMG-Pundles" selector="reconcileWithDbVersion:">reconcileWithDbVersion: dbPundle	"Select a database pundle as the new parent of the receiver."	self  isBundle 		ifTrue: [ self allItems do: [ :i | i setNoTrace ] ]		ifFalse: [ self setNoTrace ].	self reconcileWithDb: dbPundle.</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-db management</category><body package="Store-IMG-Pundles" selector="removeDbInformationFor:">removeDbInformationFor: aCollection	"Remove any existing infos for the list of dbs"	"Be careful not to remove the last one."	aCollection do:		[ :id | 		( dbInfo size == 1 and: [ dbInfo includesKey: id ] )			ifTrue: [ self unlinkLastLink: id ]			ifFalse: [ dbInfo removeKey: id ifAbsent: nil ]		].</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="removeDbs:">removeDbs: ids	"Removes anything associated with dbs in ids"	dbInfo keys do:		[ :key | ( ids includes: key )					ifTrue: [ dbInfo removeKey: key ]		].</body></methods><methods><class-id>Store.PundleModel</class-id> <category>TEMP</category><body package="Store-IMG-Pundles" selector="removeOtherDbInfos">removeOtherDbInfos	"Store.PundleModel allGeneralInstances do:			[ :p | p removeOtherDbInfos ]		"	| id |	id := DbRegistry dbIdentifier.	dbInfo keys do:		[ :k | k = id				ifFalse: [ dbInfo removeKey: k ]		].</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-load/unload</category><body package="Store-IMG-Pundles" selector="runClassExtensionPostLoadMethods">runClassExtensionPostLoadMethods	"Run the #postLoad: method on any classes extended with a class-side initialize method."	"We simply ignore this because for now this is already accomplished by Package&gt;&gt;#initializeClasses:.	 That method should probably have its code to initialize extended classes removed and equivalent	 code placed here." 	^self</body></methods><methods><class-id>Store.PundleModel</class-id> <category>load/unload</category><body package="Store-IMG-Pundles" selector="runPreUnloadFrom:">runPreUnloadFrom: aBundle	"Run the preUnload code for the receiver - only if aBundle is the only referent. "	( self preUnloadChecksFromBundle: aBundle )		ifFalse: [ ^false ].	^( self onlyReferencedBy: aBundle )		ifTrue: [ self runPreUnload ]		ifFalse: [ true ].</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="sameVersionAs:">sameVersionAs: aPundle		^aPundle sameVersionAsLoadedPundle: self</body><body package="Store-IMG-Pundles" selector="sameVersionAsLoadedPundle:">sameVersionAsLoadedPundle: aPundle		^aPundle name = self name</body></methods><methods><class-id>Store.PundleModel</class-id> <category>testing</category><body package="Store-IMG-Pundles" selector="sameVersionAsPublished:">sameVersionAsPublished: aDbRecord		| info |	^( info := self databaseInformationFor: aDbRecord dbIdentifier ) == nil		ifTrue: [ false ]		ifFalse: 			[ ( self hasBeenModifiedIn: aDbRecord dbIdentifier ) not				  and: [ info dbTrace = aDbRecord primaryKey ]			]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>db utilities</category><body package="Store-IMG-Pundles" selector="selectVersion">selectVersion 	"Answer the user selected published version of the receiver.	nil if none."	^self class databaseClass selectVersionOf: self name.</body><body package="Store-IMG-Pundles" selector="setNewTrace">setNewTrace	"Select a database pundle as the new parent of the receiver."	| dbPundle |	( dbPundle := self selectVersion ) == nil		ifTrue: [ ^nil ].	self  isBundle 		ifTrue: [ self allItems do: [ :i | i setNoTrace ] ].	self setNewTraceTo: dbPundle.</body><body package="Store-IMG-Pundles" selector="setNewTraceTo:">setNewTraceTo: dbPundle	"Change the receiver to reflect dbPundle as it's parent."		self databaseInfomationOrCreate		dbTrace: dbPundle primaryKey;		markNotModified.</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="setNoTrace">setNoTrace	| info |	( info := self databaseInfomation ) == nil		ifTrue: [ ^self ].		"already none"	info setNoTrace.</body></methods><methods><class-id>Store.PundleModel</class-id> <category>relationships</category><body package="Store-IMG-Pundles" selector="stringKey:">stringKey: hints 	"A string used to represent myself in browsers, for example in a menu. The 	default is to use my displayString"	^( hints includes: #blessing )		ifTrue: [ 'Image:', self versionString ]		ifFalse: [ self name, self traceVersionString "displayString" ]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="Store-IMG-Pundles" selector="textRepresentationForTag:">textRepresentationForTag: aTag 	^aTag isPropertyTag		ifTrue: [ aTag convertValue: ( self propertyAt: aTag property ifAbsent: nil ) ]		ifFalse:			[ aTag isStructureTag				ifTrue: [ aTag formatStructure: self structure ]				ifFalse: [ self error:'Invalid tag: ', aTag printString ]			].</body><body package="Store-IMG-Pundles" selector="timeStampString">timeStampString	^'(image)'</body><body package="Store-IMG-Pundles" selector="tracePackage">tracePackage		^self parentRecord</body></methods><methods><class-id>Store.PundleModel</class-id> <category>printing</category><body package="Store-IMG-Pundles" selector="traceVersionString">traceVersionString	"Answer a string describing a version of my trace 	pundle. Use cache if possible."	| info |	^( info := self databaseInfomation ) == nil		ifTrue: [ '' ]		ifFalse: [ info traceVersionString ]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-db management</category><body package="Store-IMG-Pundles" selector="unlinkLastLink:">unlinkLastLink: id	"Remove the last dbInfo. If it has something of value, move it to no db."	| theLast |	dbInfo size == 1		ifFalse: [ self notify: 'Unexpected - should be singular db' ].	theLast := dbInfo removeKey: id.	( theLast isChangeSetEmpty and: [ self isPackage ] )		ifFalse: 			[ theLast unhook.			dbInfo at: self noDbSymbol put: theLast			].</body></methods><methods><class-id>Store.PundleModel</class-id> <category>load/unload</category><body package="Store-IMG-Pundles" selector="unloadFromGroup:">unloadFromGroup: aGroup 	"aGroup asks for unloading this component. 	Obey only if aGroup is the only group that references this component."	( self onlyReferencedBy: aGroup )		ifTrue: [ self doUnloadFromImage ]</body><body package="Store-IMG-Pundles" selector="unloadProblemsQuery:header:">unloadProblemsQuery: aProblemSet header: aHeader	| probStream problems indent |	aProblemSet size = 0 ifTrue: [^true].	probStream := WriteStream on: String new.	probStream nextPutAll: aHeader;  cr.	problems := aProblemSet asSortedCollection.	problems size = 0 ifTrue: [^true].	indent := '         '.	problems size &lt; 20 		ifTrue: [problems do: [:prob| 			probStream nextPutAll: indent.			probStream nextPutAll: prob.			probStream cr]]		ifFalse: [1 to: 14 do: [:inx|  			probStream nextPutAll: indent.			probStream nextPutAll: (problems at: inx).			probStream cr].			probStream nextPutAll: '...'; cr].	^#proceed == (Dialog		choose: probStream contents		labels: (Array with: 'Proceed' with: 'Cancel')		values: #(#proceed #cancel)		default: #cancel)</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private</category><body package="Store-IMG-Pundles" selector="userWantsFullCompare">userWantsFullCompare	"Answer true if the preferences are set or the control key is down."	"(UISettings preferenceModelFor: #ttUseChangeSetsForCompare) value: false"	^(UISettings preferenceFor: #ttUseChangeSetsForCompare)		= false or: [InputState default ctrlDown]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>testing</category><body package="Store-IMG-Pundles" selector="validateDatabaseId">validateDatabaseId	"Answer tuee if the receiver is linked to the current database."	^self isInCurrentDatabase</body></methods><methods><class-id>Store.PundleModel</class-id> <category>printing</category><body package="Store-IMG-Pundles" selector="versionStringAlternate">versionStringAlternate	^( self hasBeenModified		ifTrue: [ ' - in image - ' ]		ifFalse: [ ' ' ]	), self traceVersionString</body><body package="Store-IMG-Pundles" selector="versionStringFor:">versionStringFor: dbid	| info |	info := self databaseInformationFor: dbid.	info == nil		ifTrue: [ ^'' ].	^info  traceVersionString, 		( info isChangeSetEmpty		"hasBeenModified"			ifTrue: [ '=' ]			ifFalse: [ '*' ]		)</body></methods><methods><class-id>Store.PundleModel</class-id> <category>testing</category><body package="Store-IMG-Pundles" selector="youngerThan:">youngerThan: aDBPackage	^self hasBeenModified		ifTrue: [ true ]		ifFalse: [ ( self dbTraceFor: aDBPackage dbIdentifier ) &gt;= aDBPackage primaryKey ]</body></methods><methods><class-id>Tools.VisualLauncher class</class-id> <category>generated resources</category><body package="Store-UI" selector="allPackagesIcon">allPackagesIcon	^ToolbarIconLibrary visualFor: #storeBrowser</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>store</category><body package="Store-UI" selector="areAttached">areAttached	^DbRegistry isConnected</body><body package="Store-UI" selector="notAttached">notAttached	^self areAttached not</body><body package="Store-UI" selector="openLoadedPundleGraph">openLoadedPundleGraph	"obsolete?"	Store.PundleGraph openOnImage</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>store menus</category><body package="Store-UI" selector="storeRepositoryLabelPart">storeRepositoryLabelPart	| profileName |	profileName := 'Repository'.	DbRegistry connectedProfile ifNotNil: 		[:profile | 		profile name ifNotNil: 			[:name | profileName := name]].	^profileName</body><body package="Store-UI" selector="toggleStoreConnectionItemLabel">toggleStoreConnectionItemLabel	^DbRegistry isConnected		ifTrue:  ['Disconnect from ', self storeRepositoryLabelPart]		ifFalse: ['Connect to Repository...']</body></methods><methods><class-id>UI.MultiSelectionSequenceView</class-id> <category>private</category><body package="Store-UI" selector="resetSelections">resetSelections	| old |  	old := selections copy.	old do: [:i| self retractSelectionIndex: i].	selectionIndex := self zeroIndex.</body></methods><methods><class-id>Tools.AboutVisualWorksPage class</class-id> <category>private</category><body package="Store-UI" selector="printNamesAndVersionsOf:on:">printNamesAndVersionsOf: pundleCollection on: aStream	(pundleCollection asSortedCollection: [:a :b | a name &lt;= b name]) do:		[:pundle |		aStream 			crtab; 			nextPutAll: pundle name, ' ', pundle versionString]</body></methods><methods><class-id>Tools.FileBrowser</class-id> <category>file name list</category><body package="Store-UI" selector="fileIntoPackage">fileIntoPackage	"Prompt for the package to read into. 	Read the entire file into the selected package."	| pkg |	pkg := PackageChooser chooseOrAddOnCancelDo: [ ^self ].	[ Policies packagePolicy forcePackage: pkg while: 		[Notice			show: (#FilingIntoN1S &lt;&lt; #dialogs &gt;&gt; 'Filing into&lt;n&gt;&lt;1s&gt;' expandMacrosWith: pkg name)			while: [(fileName asFilename withEncoding: self currentFileEncoding) fileIn]]	] on: RedefinitionNotification do:		[ :note | 		note currentPackage = pkg			ifFalse: [ note override install ].		note resume.		].</body></methods><methods><class-id>Tools.TabApplicationSystemBrowser class</class-id> <category>store-application configuration</category><body package="Store-UI" selector="browsePundleVersions:">browsePundleVersions: listOfPundleVersions	"Schedule the receiver with a listOfPundleVersions as its focus."	| inst |	( inst := self new )		tabApplication: ( self defaultVersionBrowserTab newOnBrowser: inst );		browsePackages: listOfPundleVersions;		open.	inst builder window label: 'Version Browser'.	^inst.</body></methods><methods><class-id>UI.PackagePropertiesDialog</class-id> <category>private</category><body package="Store-UI" selector="enableButtons">enableButtons	"Sets reset and accept button enablement. 	Since db packages cannot be edited at this time, these are always disabled."		( ( package isPackage or: [ package isBundle ] ) and: [ package isLoaded not ] )		ifTrue: 			[ ( subBuilder namedComponents at: #resetButton ) disable.			( subBuilder namedComponents at: #acceptButton ) disable.			]		ifFalse: [ super enableButtons ].</body></methods><methods><class-id>UI.ProgressWidgetView class</class-id> <category>dialogs</category><body package="Store-UI" selector="progressOpenOn:label:on:label:">progressOpenOn: aModel label: aLabel on: bModel label: bLabel	"A simple window that displays two Label and two progress views on models."	| wrapper topView upperView lowerView size graphic graphic2 upperView2 lowerView2 |	(aLabel isKindOf: VisualComponent)		ifTrue: [graphic := aLabel]		ifFalse: [graphic := aLabel asText asComposedText].	graphic2 := (bLabel isKindOf: VisualComponent)		ifTrue: [ bLabel]		ifFalse: [ bLabel asText asComposedText].	wrapper := CompositePart new.	upperView := CompositePart new.	lowerView := CompositePart new.	upperView add: graphic in: (LayoutFrame			leftFraction: 0.5			offset: (graphic bounds extent // 2) x negated			rightFraction: 0.5			offset: (graphic bounds extent // 2) x			topFraction: 0.25			offset: (graphic bounds extent // 4) y negated			bottomFraction: 0.50			offset: (graphic bounds extent // 4) y).	lowerView add: ((ProgressWidgetView model: aModel) beHorizontal; yourself) in: (0 @ 0 corner: 1 @ (1/3)).	upperView2 := CompositePart new.	lowerView2 := CompositePart new.	upperView2 add: graphic2 in: (LayoutFrame			leftFraction: 0.5			offset: (graphic2 bounds extent // 2) x negated			rightFraction: 0.5			offset: (graphic2 bounds extent // 2) x			topFraction: 0.5			offset: (graphic2 bounds extent // 4) y negated			bottomFraction: 0.95			offset: (graphic2 bounds extent // 4) y).	lowerView2 add: ((ProgressWidgetView model: bModel) beHorizontal; yourself) in: (0 @ (2/3) corner: 1 @ 1).	wrapper add: upperView in: ((LayoutFrame new) leftFraction: 0; rightFraction: 1; topFraction: 0.0; bottomFraction: 0.0 offset: graphic bounds extent y + 10; yourself).	wrapper add: lowerView borderedIn: ((LayoutFrame new) leftFraction: 0; rightFraction: 1; topFraction: 0.0 offset: graphic bounds extent y + 10; bottomFraction: 1).	wrapper add: upperView2 in: ((LayoutFrame new) leftFraction: 0; rightFraction: 1; topFraction: 0.5; bottomFraction: 0.5 offset: graphic2 bounds extent y + 5; yourself).	wrapper add: lowerView2 borderedIn: ((LayoutFrame new) leftFraction: 0; rightFraction: 1; topFraction: 0.0 offset: graphic2 bounds extent y + 10; bottomFraction: 1).	topView := ScheduledWindow new.	topView damageRepairPolicy: DoubleBufferingWindowDisplayPolicy new.	topView label: ''.	topView component: wrapper.	size := (graphic bounds extent x + graphic2 bounds extent x + 50 max: 150)				@ (graphic bounds extent y + graphic2 bounds extent y + 20 * 2 max: 50).	topView minimumSize: size; maximumSize: size.	topView openDisplayAt: Screen default bounds extent // 2.	^topView controller</body></methods><methods><class-id>Tools.BrowserHelper class</class-id> <category>store-drag drop keys</category><body package="Store-UI-Browser" selector="storeClassOrNamespaceKey">storeClassOrNamespaceKey	^#storeClassOrNamespace</body><body package="Store-UI-Browser" selector="storeMethodKey">storeMethodKey	^#storeMethodKey</body><body package="Store-UI-Browser" selector="storePackageKey">storePackageKey	^#storePackageKey</body><body package="Store-UI-Browser" selector="storeStaticKey">storeStaticKey	^#storeStatic</body></methods><methods><class-id>Tools.BrowserHelper</class-id> <category>store-menu selectors</category><body package="Store-UI-Browser" selector="allPackagesLoaded">allPackagesLoaded	self package == nil ifTrue: [ ^false ].	self packages do:		[ :pkg  | pkg isLoaded ifFalse: [ ^false ] ].	^true</body><body package="Store-UI-Browser" selector="areConnectedAndLoaded">areConnectedAndLoaded	^self isDBConnected &amp; self allPackagesLoaded.</body><body package="Store-UI-Browser" selector="areConnectedAndSelected">areConnectedAndSelected	^self isDBConnected &amp; ( self howManySelections == 1 )</body></methods><methods><class-id>Tools.BrowserHelper</class-id> <category>store-utilities</category><body package="Store-UI-Browser" selector="choosePackage:">choosePackage: packages	^self choosePackage: packages prompt: 'Select a package...'.</body><body package="Store-UI-Browser" selector="choosePackage:prompt:">choosePackage: packages prompt: prompt	packages size == 1		ifTrue: [ ^packages first ].	^Dialog		choose: prompt 		fromList: ( packages collect: [ :pkg | pkg name ] )		values: packages		lines: packages size + 1		cancel: [ nil ]</body></methods><methods><class-id>Tools.BrowserHelper</class-id> <category>store-private</category><body package="Store-UI-Browser" selector="dbManager">dbManager	^Store.DbRegistry</body></methods><methods><class-id>Tools.BrowserHelper</class-id> <category>store-utilities</category><body package="Store-UI-Browser" selector="defType">defType	^self browser defType value</body><body package="Store-UI-Browser" selector="forceIfForPackage:">forceIfForPackage: aBlock	"If a current package exists, execute aBlock forcing the package."	^( self isForPackage and: [ self  isPackageLoaded ] )		ifTrue: [ Policies packagePolicy forcePackage: self package while: aBlock ]		ifFalse: [ aBlock value ].</body></methods><methods><class-id>Tools.BrowserHelper</class-id> <category>menus accessing</category><body package="Store-UI-Browser" selector="getStoreMenuBarMenu">getStoreMenuBarMenu	| theMenu |	selectionId isInteger ifFalse: [^self getMenuBarMenu].	(theMenu := self browser getStoreMenuBarMenuFor: self menuHeader) == nil ifTrue: 		[theMenu := self class getListMenu.		 self browser setStoreMenuBarMenu: theMenu for: self menuHeader.		 self augmentMenuBarMenu: theMenu].	^theMenu</body></methods><methods><class-id>Tools.BrowserHelper</class-id> <category>store-testing</category><body package="Store-UI-Browser" selector="isDBConnected">isDBConnected		"Answer true if we are attached to the database."	^DbRegistry isOnline</body><body package="Store-UI-Browser" selector="isFilteredByPackage">isFilteredByPackage	self package == nil		ifTrue: [ ^false ].	^( self package isLoaded not ) or: [ self browser isFilteredByPackage ].</body><body package="Store-UI-Browser" selector="isForBundle">isForBundle	| pkg |	( pkg := self package ) == nil  ifTrue: [ ^false ].	^pkg isBundle</body><body package="Store-UI-Browser" selector="isForPackage">isForPackage	| pkg |	( pkg := self package ) == nil  ifTrue: [ ^false ].	^pkg isPackage</body><body package="Store-UI-Browser" selector="isPackageLoaded">isPackageLoaded	self package == nil ifTrue: [ ^false ].	^self package isLoaded</body><body package="Store-UI-Browser" selector="isPackageUnloaded">isPackageUnloaded	self package == nil ifTrue: [ ^false ].	^self package isLoaded not</body></methods><methods><class-id>Tools.BrowserHelper</class-id> <category>store-menu selectors</category><body package="Store-UI-Browser" selector="isSelectionLoaded">isSelectionLoaded	^self selection == nil		ifTrue: [ false ]		ifFalse: [ self selection isLoaded ].</body><body package="Store-UI-Browser" selector="isSelectionUnloaded">isSelectionUnloaded	^self selection == nil		ifTrue: [ false ]		ifFalse: [ self selection isLoaded not ].</body></methods><methods><class-id>Tools.BrowserHelper</class-id> <category>store-utilities</category><body package="Store-UI-Browser" selector="list">list	^module list listHolder value</body></methods><methods><class-id>Tools.BrowserHelper</class-id> <category>store-private</category><body package="Store-UI-Browser" selector="manager">manager	^self browser manager</body></methods><methods><class-id>Tools.BrowserHelper</class-id> <category>store-utilities</category><body package="Store-UI-Browser" selector="overrideActionDialog:">overrideActionDialog: overrideList	"From an overrideList, creates a dialog and answers:		true - to remove the definition from the system		false - to cancel		an override - the one to restore		a package - the one to remove the definition from."	| labels values description |	labels := OrderedCollection with: 'Remove from System'.	values := OrderedCollection with: true.	description := overrideList first objectString.	overrideList do:		[ :over |		labels add: ( 'Restore from: &lt;1s&gt;' expandMacrosWith: over packageName ).		values add: over.		labels add: ( 'Remove from: &lt;1s&gt;' expandMacrosWith: over packageName ).		values add: over package.		].  	labels add: 'Cancel'.	values add: false.	^Dialog		choose: ( '&lt;1s&gt; is Overriden' expandMacrosWith: description )		fromVerticallyAlignedButtonsWithLabels: labels		values: values		default: true.</body></methods><methods><class-id>Tools.BrowserHelper</class-id> <category>store-private</category><body package="Store-UI-Browser" selector="package">package	^self selected: #package</body><body package="Store-UI-Browser" selector="packages">packages	^Array with: self package			"Temp "</body></methods><methods><class-id>Tools.BrowserHelper</class-id> <category>utility</category><body package="Store-UI-Browser" selector="pickAClassOrNameSpace:">pickAClassOrNameSpace: prompt 	"Choose a class, namespace with a prompter."	"Prompt the user for a name or pattern. 	Answer nil if the user cancelled. 	Answer the class/namespace, if there is only one class/namespace that matches. 	If there is more than one match, prompt the user with a choice of matches, and	return the selected or an empty string. 	If there are no matches, answer the first global name that 		matches, or nil if there are none."	| destName pick matches |	destName := Dialog request: prompt for: self interfaceWindow.	destName = '' ifTrue: [^nil].	Cursor execute		showWhile: 			[| objects |			objects := Root withAllNameSpacesAndAllClasses.			matches := objects select: [:mod | (destName includes: $.)							ifFalse: [destName match: mod name]							ifTrue: [destName match: mod fullName]]].	(matches == nil or: [matches size = 0])		ifTrue: [ Dialog warn: 'No matching classes'. ^nil ].	matches size = 1 ifTrue: [^matches first].	matches := matches asSortedCollection: [:a :b | a fullName &lt; b fullName].	pick := PickASomethingDialog pickASomethingFrom: (matches collect: [:m | self decorateForAnyType: m]).	^pick value</body></methods><methods><class-id>Tools.BrowserHelper</class-id> <category>store-utilities</category><body package="Store-UI-Browser" selector="postBuildWith:">postBuildWith: aBuilder</body><body package="Store-UI-Browser" selector="queryPackageOveride:">queryPackageOveride: over	"Queries  user about override. Answers #override, #replace or #cancel."	| pkg msg |	over == nil ifTrue: [ ^#replace ].	pkg := over sources detect: [ :src | src isPackage ] ifNone: [ ^#replace ].	msg := '&lt;1s&gt; exists in &lt;2s&gt;' expandMacrosWith: over objectString with: pkg name.	^Override overrideReplaceOrCancel: msg.</body></methods><methods><class-id>Tools.BrowserHelper</class-id> <category>store-private</category><body package="Store-UI-Browser" selector="selectedVisualBlock">selectedVisualBlock		"Highlighting for package stuff."	^[ :view :index | 		| aText anItem listEntry label | 		listEntry :=  view sequence at: index.		anItem := listEntry value.		aText := self textForItem: anItem.		aText emphasizeAllWith: ( self textEmphasisForItem: anItem ).  		( label:= listEntry displayLabel: aText ) offset: label offset - (0@2).		label:= ReversingWrapper on: label.		label reverse setValue: true.		BoundedWrapper on: 	label.		]</body><body package="Store-UI-Browser" selector="setVisualBlocksWith:">setVisualBlocksWith: aBuilder		| widget |	widget := ( aBuilder componentAt: #list ) widget.	widget visualBlock: self visualBlock.	widget selectedVisualBlock: self selectedVisualBlock.</body></methods><methods><class-id>Tools.BrowserHelper</class-id> <category>store-utilities</category><body package="Store-UI-Browser" selector="showPackageList:loaded:">showPackageList: packages loaded: aBoolean	"Show a message box with packages - separating overrides if appropiate."	| str |	packages isEmpty		ifTrue: [ ^Dialog warn: 'Not yet assigned to a package' ].	str := ( String new: 50 ) writeStream.	str nextPutAll: packages first itemString; cr.	packages size &gt; 1		ifTrue: 			[ aBoolean				ifTrue: [ str nextPutAll: ( String new: packages first itemString size withAll: $_ ) ; cr ].				2 to: packages size do:					[ :index | | pkg |					pkg := packages at: index.										str nextPutAll: pkg itemString; cr					].			].	Dialog warn: str contents.</body></methods><methods><class-id>Tools.BrowserHelper</class-id> <category>private</category><body package="Store-UI-Browser" selector="spawningBrowserClass">spawningBrowserClass	^TabApplicationSystemBrowser</body></methods><methods><class-id>Tools.BrowserHelper</class-id> <category>store-drag drop keys</category><body package="Store-UI-Browser" selector="storeClassOrNamespaceKey">storeClassOrNamespaceKey	^self class storeClassOrNamespaceKey</body><body package="Store-UI-Browser" selector="storeMethodKey">storeMethodKey	^self class storeMethodKey</body><body package="Store-UI-Browser" selector="storePackageKey">storePackageKey	^self class storePackageKey</body><body package="Store-UI-Browser" selector="storeStaticKey">storeStaticKey	^self class storeStaticKey</body></methods><methods><class-id>Tools.BrowserHelper</class-id> <category>store-private</category><body package="Store-UI-Browser" selector="visualBlock">visualBlock	"Highlighting for package stuff."	^[ :view :index | 		| aText anItem listEntry label | 		listEntry :=  view sequence at: index.		anItem := listEntry value.		aText := self textForItem: anItem.		aText emphasizeAllWith: ( self textEmphasisForItem: anItem ). 		( label := listEntry displayLabel: aText ) offset: label offset - (0@2).		BoundedWrapper on: label .		]</body></methods><methods><class-id>Tools.BrowserHelper</class-id> <category>store-utilities</category><body package="Store-UI-Browser" selector="warnPackageNotLoaded">warnPackageNotLoaded	Dialog warn: 'Cannot edit unloaded package'</body></methods><methods><class-id>Tools.BrowserHelper</class-id> <category>accessing</category><body package="Store-UI-Browser" selector="window">window	^self browser builder window.</body></methods><methods><class-id>Tools.FullSystemBrowser</class-id> <category>selections</category><body package="Store-UI-Browser" selector="selectedAllMethodsFor:">selectedAllMethodsFor: id		^self selected: #allMethods for: id</body><body package="Store-UI-Browser" selector="selectedModelFor:">selectedModelFor: id 	"Set the currently selected model within an id."		^self selected: #model for: id</body><body package="Store-UI-Browser" selector="selectedPackageFor:">selectedPackageFor: id	"Answer the currently selected parcel within an id."		^self selected: #package for: id</body><body package="Store-UI-Browser" selector="setAllMethodsFor:to:">setAllMethodsFor: id to: aValue		^self setSelection: #allMethods for: id to: aValue</body><body package="Store-UI-Browser" selector="setModelFor:to:">setModelFor: id to: aValue	"Set the currently selected model within an id."		^self setSelection: #model for: id to: aValue</body><body package="Store-UI-Browser" selector="setPackageFor:to:">setPackageFor: id to: aValue	"Set the currently selected package within an id."		^self setSelection: #package for: id to: aValue</body></methods><methods><class-id>Tools.SimpleBrowserModule</class-id> <category>list accessing</category><body package="Store-UI-Browser" selector="forcedValue">forcedValue	^forcedValue</body></methods><methods><class-id>Tools.MethodsBrowserHelper</class-id> <category>store utility</category><body package="Store-UI-Browser" selector="findPackageForData:in:">findPackageForData: key in: aNameSpace	"Find and display the package for aClass&gt;&gt;selector."	| pkgs |	pkgs := Registry allContainingPackagesForDataKey: key				owner: aNameSpace namedReferent.	self showPackageList: pkgs loaded: true.</body><body package="Store-UI-Browser" selector="findPackageForSelector:in:">findPackageForSelector: selector in: aClass  	"Find and display the package for aClass&gt;&gt;selector."	| pkgs  |	pkgs := Registry allContainingPackagesForSelector: selector class: aClass.	self showPackageList: pkgs loaded: true.</body></methods><methods><class-id>Tools.TabApplicationSystemBrowser class</class-id> <category>store-application configuration</category><body package="Store-UI-Browser" selector="browseAvailableMethodsNamed:in:">browseAvailableMethodsNamed: aName in: owner	| methodNames |	( ( methodNames := Store.Method chooseAvailableMethodMatching: '*' in: owner ) == nil				or: [ methodNames isEmpty ] )		ifTrue: [ ^nil ].	methodNames do: 		[:each | | list inst |		list := Store.Method 				allMethodVersionsNamed: each 			inClass: owner absoluteName asClassNameOnly			meta: owner isMeta.					( inst := self new )			tabApplication: ( self defaultVersionBrowserTab newOnBrowser: inst );			browseMethodsOrStatics: list;			open.		inst builder window label: each, ' Version Browser'		].</body><body package="Store-UI-Browser" selector="browseNamespaceOrClassList:">browseNamespaceOrClassList: aList	| inst |	( inst := self new )		tabApplication: ( self defaultVersionBrowserTab newOnBrowser: inst );		browseNameSpacesOrClasses: aList;		open.	inst builder window label: aList first name, ' Version Browser'.	^inst.</body><body package="Store-UI-Browser" selector="browseUnloadableExecptionList:labeled:">browseUnloadableExecptionList: aList labeled: aString	| inst |	( inst := self new )		tabApplication: ( Store.UnloadableExeceptionBrowserApplication newOnBrowser: inst );		browseExceptions: aList;		open.	inst builder window label: aString.	^inst.</body><body package="Store-UI-Browser" selector="browseVersionsOfMethodNamed:in:">browseVersionsOfMethodNamed: aName in: owner	| list inst |	list := Store.Method 				allMethodVersionsNamed: aName 			inClass: owner absoluteName asClassNameOnly			meta: owner isMeta.				list isEmpty		ifTrue: [ ^Dialog warn: 'There are no published versions of ' , aName, '.'].	( inst := self new )		tabApplication: ( self defaultVersionBrowserTab newOnBrowser: inst );		browseMethodsOrStatics: list;		open.	inst builder window label: aName, ' Version Browser'.	^inst.</body><body package="Store-UI-Browser" selector="browseVersionsOfMethodNamed:inClassNamed:meta:">browseVersionsOfMethodNamed: aName inClassNamed: className meta: isMeta	| list inst |	list := Store.Method 				allMethodVersionsNamed: aName 			inClass: className			meta: isMeta.				list isEmpty		ifTrue: [ ^Dialog warn: 'There are no published versions of ' , aName, '.'].	( inst := self new )		tabApplication: ( self defaultVersionBrowserTab newOnBrowser: inst );		browseMethodsOrStatics: list;		open.	inst builder window label: aName, ' Version Browser'.	^inst.</body><body package="Store-UI-Browser" selector="browseVersionsOfMethodOrStatic:">browseVersionsOfMethodOrStatic: anObject	| inst list |	list := anObject  isForData				ifTrue: [ Store.DataElement allVersionsNamed: anObject dataKey in: anObject environmentString ]				ifFalse: 					[ Store.Method 						allMethodVersionsNamed: anObject selector 						inClass: anObject fullClassName 						meta: anObject isMeta					].	list isEmpty		ifTrue: [ ^Dialog warn: 'There are no published versions of ' , anObject fullName, '.'].	( inst := self new )		tabApplication: ( self defaultVersionBrowserTab newOnBrowser: inst );		browseMethodsOrStatics: list;		open.	inst builder window label: anObject displayString, ' Version Browser'.	^inst.</body><body package="Store-UI-Browser" selector="browseVersionsOfNamespaceOrClass:">browseVersionsOfNamespaceOrClass: anObject	| inst list |	list := anObject  isForClass				ifTrue: [ Store.ClassRecord allVersionsNamed: anObject absoluteName ]				ifFalse: [ Store.NameSpaceRecord allVersionsNamed: anObject absoluteName ].	list isEmpty		ifTrue: [ ^Dialog warn: 'There are no published versions of ' , anObject fullName, '.'].	( inst := self new )		tabApplication: ( self defaultVersionBrowserTab newOnBrowser: inst );		browseNameSpacesOrClasses: list;		open.	inst builder window label: anObject name, ' Version Browser'.	^inst.</body><body package="Store-UI-Browser" selector="browseVersionsOfPundle:">browseVersionsOfPundle: anObject	| inst list |	list := anObject  isPackage				ifTrue: [ Store.Package allVersionsWithName: anObject name ]				ifFalse: [ Store.Bundle allVersionsWithName: anObject name ].	list isEmpty		ifTrue: [ ^Dialog warn: 'There are no published versions of ' , anObject name, '.'].	( inst := self new )		tabApplication: ( self defaultVersionBrowserTab newOnBrowser: inst );		browsePackages: list;		open.	inst builder window label: anObject name, ' Version Browser'.	^inst.</body><body package="Store-UI-Browser" selector="browseVersionsOfStaticNamed:in:">browseVersionsOfStaticNamed: aName in: anObject	| inst list |	list := Store.DataElement allVersionsNamed: aName in: anObject absoluteName.	list isEmpty		ifTrue: [ ^Dialog warn: 'There are no published versions of ' , aName, '.'].	( inst := self new )		tabApplication: ( self defaultVersionBrowserTab newOnBrowser: inst );		browseMethodsOrStatics: list;		open.	inst builder window label: aName, ' Version Browser'.	^inst.</body><body package="Store-UI-Browser" selector="browseVersionsOfStaticNamed:inNamed:">browseVersionsOfStaticNamed: aName inNamed: anObjectName	| inst list |	list := Store.DataElement allVersionsNamed: aName in: anObjectName asString.	list isEmpty		ifTrue: [ ^Dialog warn: 'There are no published versions of ' , aName, '.'].	( inst := self new )		tabApplication: ( self defaultVersionBrowserTab newOnBrowser: inst );		browseMethodsOrStatics: list;		open.	inst builder window label: aName, ' Version Browser'.	^inst.</body><body package="Store-UI-Browser" selector="defaultPackageTab">defaultPackageTab		^Store.BundleTabApplication </body><body package="Store-UI-Browser" selector="defaultVersionBrowserTab">defaultVersionBrowserTab		^Store.DefinitionBrowserApplication</body><body package="Store-UI-Browser" selector="editPackage:methodOrStatics:">editPackage: pkg methodOrStatics: aCollection	| inst |	( inst := self new )		tabApplication: ( self defaultVersionBrowserTab newOnBrowser: inst );		editPackage: pkg methodsOrStatics: aCollection;		open.	inst builder window label: ' Editing ', pkg displayString.	^inst.</body><body package="Store-UI-Browser" selector="openClassOrNameSpaceView">openClassOrNameSpaceView	"self openClassOrNameSpaceView"	| inst |	^( inst := self new )		tabApplication: ( Store.ClassViewTabApplication newOnBrowser: inst );		initializeForClassNameSpaceView;		open;		yourself.</body><body package="Store-UI-Browser" selector="openOnClassOrNameSpacesView:">openOnClassOrNameSpacesView: aClassOrNameSpaceList	| inst |	^( inst := self new )		tabApplication: ( Store.ClassViewTabApplication newOnBrowser: inst );		initializeForClassOrNameSpaces: aClassOrNameSpaceList;		open;		yourself.</body><body package="Store-UI-Browser" selector="openOnClassOrNameSpaceView:">openOnClassOrNameSpaceView: aClassOrNameSpace	| inst |	^( inst := self new )		tabApplication: ( Store.ClassViewTabApplication newOnBrowser: inst );		initializeForClassOrNameSpace: aClassOrNameSpace;		open;		yourself.</body><body package="Store-UI-Browser" selector="openOnPackage:">openOnPackage: aPackage 	"self openOnPackage: ( Store.Registry allPackages first )"	^aPackage isLoaded 		ifTrue: 			[Refactory.Browser.RefactoringBrowser 				openOnEnvironment: (Refactory.Browser.PundleEnvironment new 						pundles: (List with: aPackage))]		ifFalse: [self openOnPackage: aPackage with: self defaultPackageTab]</body><body package="Store-UI-Browser" selector="openOnPackage:classOrNameSpace:">openOnPackage: aPackage  classOrNameSpace: aClassOrNameSpace	| inst |	^( inst := self new )		tabApplication: ( self defaultPackageTab newOnBrowser: inst );		initializeForPackage: aPackage classOrNameSpace: aClassOrNameSpace;		open;		yourself.</body><body package="Store-UI-Browser" selector="openOnPackage:methods:">openOnPackage: aPackage  methods: aMethodList	| inst |	^( inst := self new )		tabApplication: ( self defaultPackageTab newOnBrowser: inst );		initializeForPackage: aPackage methods: aMethodList;		open;		yourself.</body><body package="Store-UI-Browser" selector="openOnPackage:methods:label:">openOnPackage: aPackage  methods: aMethodList label: aString	^( self openOnPackage: aPackage  methods: aMethodList )		builder window label: aString;		yourself.</body><body package="Store-UI-Browser" selector="openOnPackage:owner:protocols:isData:">openOnPackage: aPackage  owner: aClassOrNameSpace protocols: aProtocolList isData: isData	| inst |	( inst := self new )		tabApplication: ( self defaultPackageTab newOnBrowser: inst );		initializeForPackage: aPackage owner: aClassOrNameSpace protocols: aProtocolList.	isData ifTrue: [ inst metaShowData ].	inst open.	^inst.</body><body package="Store-UI-Browser" selector="openOnPackage:with:">openOnPackage: aPackage  with: aBrowserTabApplicationClass	 | inst aBrowserTabApplication |	inst := self new.	aBrowserTabApplication := aBrowserTabApplicationClass newOnBrowser: inst.	^inst			tabApplication: aBrowserTabApplication;		initializeForPackage: aPackage;		open;		yourself.</body><body package="Store-UI-Browser" selector="openOnPackages">openOnPackages	"self openOnPackages"	^self openOnPackagesWith: self defaultPackageTab</body><body package="Store-UI-Browser" selector="openOnPackagesWith:">openOnPackagesWith: aBrowserTabApplicationClass	 | inst aBrowserTabApplication |	inst := self new.	aBrowserTabApplication := aBrowserTabApplicationClass newOnBrowser: inst.	^inst			tabApplication: aBrowserTabApplication;		initializeForPackages;		open;		yourself.</body></methods><methods><class-id>Tools.TabApplicationSystemBrowser</class-id> <category>change</category><body package="Store-UI-Browser" selector="updateProtocolLists">updateProtocolLists	| previousThing otherComponents module match |	previousThing := self selected: #model for: #default.	super updateProtocolLists.	(previousThing == nil or: [tabApplication == nil]) ifTrue: [^self].	"There is simply no better way."	otherComponents := tabApplication components.	module := [otherComponents at: otherComponents size - 2] 					on: SubscriptOutOfBoundsError 					do: [:ex | ^self].	match := module list list detect: [:item | item value absoluteName = previousThing absoluteName] ifNone: [^self].	module selection: match value</body></methods><methods><class-id>Tools.BrowserHelper</class-id> <category>store-utilities</category><body package="Store-UI-Comparitors" selector="itemFor:">itemFor: anItem		"Answer the receiver's equivilent of anItem. Uses #comparesTo: instead of #="	anItem == nil ifTrue: [ ^nil ].	anItem isDataModel ifFalse: [ ^anItem ].	^self itemForPackage: anItem."	^( self list detect: [ :item | item value comparesTo: anItem ] ifNone: [ nil ] ) value "</body><body package="Store-UI-Comparitors" selector="itemForPackage:">itemForPackage: aDescriptor		"default"	^aDescriptor</body></methods><methods><class-id>Lens.LensBrowsingToolModel</class-id> <category>store</category><body package="Store-UI-Graphs" selector="openInLevels:">openInLevels: levels	self selectionDo: 		[ :e | self browserModel body openAllFrom: e side: 2 levels: levels ]</body><body package="Store-UI-Graphs" selector="openOutLevels:">openOutLevels: levels	self selectionDo: 		[ :e | self browserModel body openAllFrom: e side: 1 levels: levels ]</body></methods><methods><class-id>Lens.LDMArrowView class</class-id> <category>instance creation</category><body package="Store-UI-Graphs" selector="model:fullImage:emptyImage:">model: mdl fullImage: fullImage emptyImage: emptyImage	| dv |	dv := super model: mdl.	dv beVisual: emptyImage ifTrue: fullImage.	^dv</body></methods><methods><class-id>XML.SourceScannerNodeBuilder</class-id> <category>scanning-code components</category><body package="Store-Change Management" selector="scan_pundle_loaded:">scan_pundle_loaded: anElement 	self doChange: 		( Store.PundleLoadedChange new			componentName: ( self getString: 'name' from: anElement default: nil );			componentType: ( self getSymbol: 'type' from: anElement default: '' );			databaseId: ( self getString: 'databaseId' from: anElement default: '' );			primaryKey: ( self getString: 'primaryKey' from: anElement default: '0' ) asNumber			yourself 		  )</body><body package="Store-Change Management" selector="scan_pundle_saved:">scan_pundle_saved: anElement 	self doChange: 		( Store.PundleSavedChange new			componentName: ( self getString: 'name' from: anElement default: nil );			componentType: ( self getSymbol: 'type' from: anElement default: '' );			databaseId: ( self getString: 'databaseId' from: anElement default: '' );			primaryKey: ( self getString: 'primaryKey' from: anElement default: '0' ) asNumber			yourself 		  )</body></methods><methods><class-id>Kernel.ChunkSourceFileFormat</class-id> <category>code component support</category><body package="Store-Change Management" selector="loadPundle:type:primaryKey:databaseId:on:">loadPundle: name type: pundleType primaryKey: key databaseId: databaseId on: aStream	"Add the loading of a Pundle event on a stream. "	"So it shows up in references and senders..."	Array with: CodeComponent with: #reloadPundle:named:id:fromDatabase:.	aStream nextChunkPut: 		( '#{Store.Pundle} ifDefinedDo:&lt;n&gt;[ :pundleClass |&lt;n&gt;pundleClass reloadPundle: &lt;1s&gt; named: &lt;2s&gt; id &lt;3s&gt; fromDatabase: &lt;3s&gt;&lt;n&gt;].'				expandMacrosWith: pundleType storeString				with: name				with: key storeString				with: databaseId storeString		); cr.</body><body package="Store-Change Management" selector="savePundle:type:primaryKey:databaseId:on:">savePundle: name type: pundleType primaryKey: key databaseId: databaseId on: aStream	"Add the saving of a Pundle event on a stream - action is same as loading. "	"For packages there is no difference in restoring a save and a load."	self loadPundle: name type: pundleType primaryKey: key databaseId: databaseId on: aStream</body></methods><methods><class-id>Kernel.ComponentDefinitionChange</class-id> <category>store</category><body package="Store-Change Management" selector="doChangeTo:">doChangeTo: aChangeSet	"Perfrom the receiver's change onto aChangeSet."	"Used in converting ChangeSet changes to Store changes."	| change |	change := self isForClass		ifTrue: [ Store.Change new className: definitionName meta: false ]		ifFalse: [ Store.Change new nameSpaceSymbol: definitionName ].	self preformChange: change to: aChangeSet.</body><body package="Store-Change Management" selector="preformChange:to:">preformChange: aChange to: aChangeSet	definitionChange == #added		ifTrue: [ aChange add ]		ifFalse: [ aChange remove ].		aChangeSet doChange: aChange.</body></methods><methods><class-id>Kernel.SourceFileFormat</class-id> <category>code component support</category><body package="Store-Change Management" selector="bundleStructure:on:">bundleStructure:  aBundle on: aStream	"Add the loading of a package/bundle event on a stream. "	^self subclassResponsibility</body><body package="Store-Change Management" selector="loadPundle:type:primaryKey:databaseId:on:">loadPundle: name type: pundleType primaryKey: key databaseId: databaseId on: aStream	"Add the loading of a package/bundle event on a stream. "	^self subclassResponsibility</body><body package="Store-Change Management" selector="savePundle:type:primaryKey:databaseId:on:">savePundle: name type: pundleType primaryKey: key databaseId: databaseId on: aStream	"Add the saving of a package/bundle event on a stream. "	^self subclassResponsibility</body></methods><methods><class-id>Kernel.ChangeSet class</class-id> <category>component change management</category><body package="Store-Change Management" selector="loadPundle:">loadPundle: aPundle	"Include indication that aPundle was loaded."	self changed: #loadPundle: with: ( Array with: aPundle )</body><body package="Store-Change Management" selector="savePundle:">savePundle: aPundle	"Include indication that aPundle was loaded."	self changed: #savePundle: with: ( Array with: aPundle )</body></methods><methods><class-id>Kernel.ChangeSet</class-id> <category>component change management</category><body package="Store-Change Management" selector="loadPundle:">loadPundle: aPundle	"Include indication that aPundle was loaded."	self addComponentChange:			( Store.PundleLoadedChange new				component: aPundle;				yourself 			)</body><body package="Store-Change Management" selector="savePundle:">savePundle: aPundle	"Include indication that aPundle was loaded."	self addComponentChange:			( Store.PundleSavedChange new				component: aPundle;				yourself 			)</body></methods><methods><class-id>Store.ClassChanges</class-id> <category>fileIn/Out</category><body package="Store-Change Management" selector="fileOutChangesFor:for:within:on:">fileOutChangesFor: class for: aPackage within: aBundle on: fileManager	"Write out all the changes the receiver knows about this class."	class isMeta		ifFalse:			[ self fileOutDefChanges: class on: fileManager.			self fileOutDataChangesFor: class for: aPackage within: aBundle on: fileManager.			].	self fileOutMethodChangesFor: class for: aPackage within: aBundle on: fileManager.</body><body package="Store-Change Management" selector="fileOutDefChanges:on:">fileOutDefChanges: class on: fileManager	"Write out class changes.  i.e.  new class, definition, comment, renaming.	If the class is to be initialized on fileIn, add the class to aClassCollection"	class isMeta		ifTrue: [ ^self ].		"def changes are for the class itself"	( self isAdded or: [ self isClassChangedMeta: false ] )		ifTrue: [ class fileOutDefinitionOn: fileManager ].	self isRenamed		ifTrue: [ fileManager rename: class fullName from: self oldName type: #class ]." * removes are handled by the changeSet * 	self  isDefinitionRemoved		ifTrue: [ fileManager removeObject: class fullName type: #class ]."	( self isClassCommentedMeta: class isMeta ) 		ifTrue:	[ class fileOutCommentOn: fileManager ]</body><body package="Store-Change Management" selector="fileOutMethodChangesFor:for:within:on:">fileOutMethodChangesFor: class for: aPackage within: aBundle on: fileManager	"Write out all the changes the receiver knows about this class."	| changes removes methCha |	removes := OrderedCollection new.	changes := OrderedCollection new.	methCha := self getMethodChangesMeta: class isMeta ifNone: [ nil ].	methCha notNil 		ifTrue: 			[ methCha keysAndValuesDo: 				[ :mSel :mChange | 				mChange = #remove					ifTrue: [ ( self isRemoved or: [ self isDefinitionRemoved ] ) 								ifFalse: [ removes add: mSel ]						    ]					ifFalse: [ changes add: mSel ]				]			].	changes isEmpty 		ifFalse: 			[ ( aPackage == nil or: [ aPackage isLoaded ] ) 				ifTrue: [ fileManager fileOutMessages: changes for: class ]				ifFalse: [ aPackage fileOutSelectors: changes in: class on: fileManager ]			].	removes do:		[ :selector | 		( ( aBundle ~~ nil ) and: 				[ aBundle includesSelector: selector className: symbol asString meta: class isMeta ] )			ifFalse: [ fileManager removeSelector: selector from: class ]		].	( ( self isClassReorganizedMeta: class isMeta ) and: [ class isBehavior ] )		ifTrue:			[ fileManager emphasis: #italic.			fileManager reorganizeObject: class.			fileManager emphasis: nil			].	"reinitialize metaclass if necessary"	(class isMeta and: [changes includes: #initialize]) 		ifTrue: [ fileManager initializeThisClass: 					( ( Kernel.ChangeSupportClassProxy pathString: symbol asString ) meta: false ) 			   ].</body><body package="Store-Change Management" selector="fileOutObjectType">fileOutObjectType		"Answer a symbol that represents the type of the receiver."	^#class</body></methods><methods><class-id>Store.ClassChanges</class-id> <category>accessing</category><body package="Store-Change Management" selector="modifiedTags">modifiedTags	"Answer a collection of tags for changed or add definitions, methods or data, 	not including removed definitions."	| tags |	tags := OrderedCollection new.	( self isAdded or: [ self isClassChangedMeta: false ] )		ifTrue: [ tags add: ( ClassTag newClassSymbol: symbol isMeta: false ) ].	( self isClassChangedMeta: true )		ifTrue: [ tags add: ( ClassTag newClassSymbol: symbol isMeta: true ) ].	(self isClassCommentedMeta: false)		ifTrue: [tags add: ( ClassCommentTag newClassSymbol: symbol isMeta: false ) ].	( self isClassCommentedMeta: true )		ifTrue: [ tags add: ( ClassCommentTag newClassSymbol: symbol isMeta: true ) ].	( self modifiedSelectorsMeta: false ) do: 		[ :selector | 		tags add: (MethodTag newClassSymbol: symbol isMeta: false selector: selector )		].	( self modifiedSelectorsMeta: true ) do: 		[ :selector | tags add: ( MethodTag newClassSymbol: symbol isMeta: true	selector: selector ) ].	self modifiedDataKeys do: 		[ :dataKey | tags add: ( DataTag newClassSymbol: symbol dataKey: dataKey ) ].	^tags</body><body package="Store-Change Management" selector="removedTags">removedTags	"Answer a collection of tags for removed definitions, methods or data."	| tags |	tags := OrderedCollection new.	( self isDefinitionRemoved )		ifTrue: [ tags add: (ClassTag newClassSymbol: symbol isMeta: false ) ].	(  self removedSelectorsMeta: false ) do: 		[ :selector | 		tags add: ( MethodTag newClassSymbol: symbol	isMeta: false selector: selector )		].	( self removedSelectorsMeta: true ) do: 		[ :selector | 		tags add: ( MethodTag  newClassSymbol: symbol isMeta: true selector: selector ) ].	self removedDataKeys do: 		[ :dataKey | tags add: ( DataTag newClassSymbol: symbol dataKey: dataKey ) ].	^tags</body></methods><methods><class-id>Kernel.ComponentChange</class-id> <category>store</category><body package="Store-Change Management" selector="doChangeTo:">doChangeTo: aChangeSet	"Perfrom the reciever's change onto aChangeSet."	"Used in converting ChangeSet changes to Store changes."	" self subclassResponsibility "	"default to do nothing"</body></methods><methods><class-id>Kernel.ComponentSelectorChange</class-id> <category>store</category><body package="Store-Change Management" selector="doChangeTo:">doChangeTo: aChangeSet	"Perfrom the receiver's change onto aChangeSet."	"Used in converting ChangeSet changes to Store changes."	| change |	change := Store.Change new className: definitionName meta: meta.	change selector: self selector.	self preformChange: change to: aChangeSet.</body></methods><methods><class-id>Store.NameSpaceChanges</class-id> <category>accessing</category><body package="Store-Change Management" selector="dataChanges">dataChanges	"Answer a collection of Changes for all modified/added/removed statics"	| coll |	dataChanges == nil		ifTrue: [ ^#( ) ].	coll := OrderedCollection new.	dataChanges keysAndValuesDo:		[ :key :type | 		coll add:			( Change new				nameSpaceSymbol: symbol;				dataKey: key;				perform: type;				yourself				)		].	^coll</body></methods><methods><class-id>Store.NameSpaceChanges</class-id> <category>fileIn/Out</category><body package="Store-Change Management" selector="fileOutChangesFor:for:within:on:">fileOutChangesFor: namespace for: aPackage within: aBundle on: fileManager	"Write out all the changes the receiver knows about this namespace."	self fileOutDefChanges: namespace on: fileManager.	self fileOutDataChangesFor: namespace for: aPackage within: aBundle on: fileManager.</body><body package="Store-Change Management" selector="fileOutDefChanges:on:">fileOutDefChanges: namespace on: fileManager	"Write out nanespace changes.  i.e.  new namespace, definition, comment, renaming."	self isRenamed 		ifTrue: [ fileManager rename: namespace fullName 						from: self oldName type: #nameSpace ].	( self isAdded or: [ self isDefinitionChanged ] )		ifTrue: [ namespace fileOutDefinitionOn: fileManager]." * removes are handled by the changeSet * 	self  isDefinitionRemoved		ifTrue: [ fileManager removeObject: namespace fullName type: #nameSpace ]."	self isCommented		ifTrue: [ namespace fileOutCommentOn: fileManager	]</body><body package="Store-Change Management" selector="fileOutObjectType">fileOutObjectType		"Answer a symbol that represents the type of the receiver."	^#namespace</body></methods><methods><class-id>Store.NameSpaceChanges</class-id> <category>accessing</category><body package="Store-Change Management" selector="modifiedDatumDescriptors">modifiedDatumDescriptors	^( self getDataChangesIfNone: [ ^#( ) ] ) keys collect:		[ :key  | DatumDescriptor fromDataKey: key nameSpaceName: symbol asString ].</body><body package="Store-Change Management" selector="modifiedTags">modifiedTags	"Answer a collection of tags for changed or add definitions, methods or data, 	not including removed definitions."	| tags |	tags := OrderedCollection new.	( self isAdded or: [ self isChanged ] )		ifTrue: [ tags add: ( NameSpaceTag newNameSpaceSymbol: symbol ) ].	(self isCommented )		ifTrue: [tags add: ( NameSpaceCommentTag newNameSpaceSymbol: symbol ) ].	self modifiedDataKeys do: 		[ :dataKey | tags add: ( DataTag newNameSpaceSymbol: symbol dataKey: dataKey ) ].	^tags</body></methods><methods><class-id>Store.NameSpaceChanges</class-id> <category>fileIn/Out</category><body package="Store-Change Management" selector="putDefStatsOn:">putDefStatsOn: stream 	self isAdded ifTrue: [stream nextPutAll: 'NameSpace added.'; cr].	self isRenamed ifTrue: [stream nextPutAll: 'NameSpace renamed from ', self oldName, '.'; cr].	self isDefinitionRemoved ifTrue: [stream nextPutAll: 'NameSpace definition removed.'; cr].	self isDefinitionChanged ifTrue: [stream nextPutAll: 'NameSpace redefined.'; cr].	self isRemoved ifTrue: [stream nextPutAll: 'NameSpace removed.'; cr].	self isReorganized ifTrue: [stream nextPutAll: 'NameSpace reorganized.'; cr].	self isCommented ifTrue: [stream nextPutAll: 'NameSpace comment changed.'; cr].	self isOverridden ifTrue: [ stream nextPutAll: 'NameSpace overridden.'; cr ].</body><body package="Store-Change Management" selector="putStatsOn:">putStatsOn: stream 	self putDefStatsOn: stream.	self isDataModified		ifTrue: 			[stream nextPutAll: 'Data changed:'; cr.			self putDataStatsOn: stream			].</body></methods><methods><class-id>Store.NameSpaceChanges</class-id> <category>accessing</category><body package="Store-Change Management" selector="removedTags">removedTags	"Answer a collection of tags for removed definitions or data."	| tags |	tags := OrderedCollection new.	( self isDefinitionRemoved )		ifTrue: [ tags add: ( NameSpaceTag newNameSpaceSymbol: symbol ) ].	self removedDataKeys do: 		[ :dataKey | tags add: ( DataTag newNameSpaceSymbol: symbol dataKey: dataKey ) ].	^tags</body></methods><methods><class-id>Store.XMainChangeSet</class-id> <category>public-method changes</category><body package="Store-Change Management" selector="revertData:owner:">revertData: dataKey owner: owner 	"Reload from the database the most recently loaded version of the data described. 	Assumes that we've already verified that this is actually possible. "	| tracePackage pkg |	pkg := Registry containingPackageForDataKey: dataKey symbol: owner absoluteSymbol.	Cursor wait showWhile: 		[ DbRegistry doIfOnlineImage: 			[ ( tracePackage := pkg tracePackage ) isNil				ifTrue: 					[ ^Dialog warn: 'The package containing this datakey has no parent in the database.Cannot revert datakey to previous version.'.					].			tracePackage loadData: dataKey ownerName: owner absoluteName intoPackage: pkg					ifNone: [ ^Dialog warn: 'The parent package ', tracePackage itemString, ' does not contain this data.Cannot revert method to previous version.Perhaps you want "remove..."'. ].			]		]</body><body package="Store-Change Management" selector="revertSelector:class:">revertSelector: selector class: class 	"Reload from the database the most recently loaded version of the method described. 	Assumes that we've already verified that this is actually possible. 	Answer true if sucessful."	| tracePackage pkg |	pkg := Registry containingPackageForSelector: selector class: class.	Cursor wait showWhile: 		[ DbRegistry doIfOnlineImage: 			[ ( tracePackage := pkg tracePackage ) isNil				ifTrue: 					[ Dialog warn: 'The package containing this method has no parent in the database.Cannot revert method to previous version.'.					^false.					].			tracePackage loadMethod: selector className: class absoluteName intoPackage: pkg					ifNone: [ Dialog warn: 'The parent package ', tracePackage itemString, ' does not contain this method.Cannot revert method to previous version.Perhaps you want "remove..."'.						^false ].			pkg changeSet forgetMethodChange: selector class: class.			]		].	^true</body></methods><methods><class-id>Kernel.ComponentStaticChange</class-id> <category>store</category><body package="Store-Change Management" selector="doChangeTo:">doChangeTo: aChangeSet	"Perfrom the receiver's change onto aChangeSet."	"Used in converting ChangeSet changes to Store changes."	| change |	change := Store.Change new actual: self owner.	change dataKey: self dataKey.	self preformChange: change to: aChangeSet.</body></methods><methods><class-id>Kernel.XMLSourceFileFormat</class-id> <category>code component support</category><body package="Store-Change Management" selector="loadPundle:type:primaryKey:databaseId:on:">loadPundle: name type: typeSymbol primaryKey: key databaseId: databaseId on: aStream	"Add the loading of a Pundle event on a stream. "	self checkForWrite: aStream.	aStream cr; cr.	self on: aStream tag: 'pundle-loaded' do:		[ :xml :str |		str cr.		xml on: str tag: 'name' value: name.		str cr.		xml on: str tag: 'type' value: typeSymbol.		str cr.		xml on: str tag: 'primaryKey' value: key storeString.		str cr.		xml on: str tag: 'databaseId' value: databaseId storeString.		str cr.		]</body><body package="Store-Change Management" selector="savePundle:type:primaryKey:databaseId:on:">savePundle: name type: typeSymbol primaryKey: key databaseId: databaseId on: aStream	"Add the loading of a Pundle event on a stream. "	self checkForWrite: aStream.	aStream cr; cr.	self on: aStream tag: 'pundle-saved' do:		[ :xml :str |		str cr.		xml on: str tag: 'name' value: name.		str cr.		xml on: str tag: 'type' value: typeSymbol.		str cr.		xml on: str tag: 'primaryKey' value: key storeString.		str cr.		xml on: str tag: 'databaseId' value: databaseId storeString.		str cr.		]</body></methods><methods><class-id>Kernel.SourceFileManager</class-id> <category>file out code components support</category><body package="Store-Change Management" selector="loadPundle:">loadPundle: aPundle	self 		loadPundleNamed: aPundle name		type: aPundle componentType		primaryKey: aPundle primaryKey 		databaseId: aPundle databaseId</body><body package="Store-Change Management" selector="loadPundleNamed:type:primaryKey:databaseId:">loadPundleNamed: pundleName type: typeSymbol primaryKey: anInteger databaseId: aString	self targetFile == nil		ifFalse:			[ self targetFormatter				loadPundle: pundleName				type: typeSymbol				primaryKey: anInteger				databaseId: aString 				on: self targetFile.			].</body><body package="Store-Change Management" selector="savePundle:">savePundle: aPundle	self 		savePundleNamed: aPundle name		type: aPundle componentType		primaryKey: aPundle primaryKey 		databaseId: aPundle databaseId</body><body package="Store-Change Management" selector="savePundleNamed:type:primaryKey:databaseId:">savePundleNamed: pundleName type: typeSymbol primaryKey: anInteger databaseId: aString	self targetFile == nil		ifFalse:			[ self targetFormatter				savePundle: pundleName				type: typeSymbol				primaryKey: anInteger				databaseId: aString 				on: self targetFile.			].</body></methods><methods><class-id>Store.XChangeSet</class-id> <category>private-fileIn/Out</category><body package="Store-Change Management" selector="changedDefinitionsFor:">changedDefinitionsFor: aPackage	"Answer a collection of the changed or edited classes, not including removed classes."	| defs |	( ( aPackage ~~ nil  ) and: [ aPackage isLoaded not ] )		ifTrue: [ ^Package sortForLoading: ( aPackage classesAndNameSpacesFromChanges: self ) ].	defs := OrderedCollection new.	self keysAndValuesDo: 		[ :symbol :changes |   | obj |		obj := symbol asStrictReference valueOrDo: [ nil ].		obj == nil			ifFalse:				[				( changes isForClass and: [ changes isModifiedMeta: true ] ) 						ifTrue: [ defs add: obj class]						ifFalse: [ defs add: obj ]				].		].	^( SystemUtils sortForLoading: defs ) asOrderedCollection</body></methods><methods><class-id>Store.XChangeSet</class-id> <category>public-fileIn/Out</category><body package="Store-Change Management" selector="fileOutOn:">fileOutOn: outputStream 	"Write out all the changes the receiver knows about."	self fileOutOn: outputStream for: nil within: nil</body><body package="Store-Change Management" selector="fileOutOn:classSymbol:">fileOutOn: outputStream classSymbol: classSymbol 	"Write out all the changes the receiver knows about."	| fileManager cc |	fileManager := outputStream.	fileManager deferInitializations.	cc := self at: classSymbol.	( cc isRemoved or: [ cc isDefinitionRemoved ] )		ifTrue: [ fileManager removeObject: classSymbol type: cc fileOutObjectType ]		ifFalse: 			[ | class |			class := classSymbol asStrictReference valueOrDo: 				[ ^Dialog warn: 'class ' , classSymbol , ' not longer exists' ].			cc fileOutChangesFor: class for: nil within: nil  on: fileManager.			cc fileOutChangesFor: class class for: nil within: nil  on: fileManager 			].	fileManager finishInitializations.	fileManager cr</body><body package="Store-Change Management" selector="fileOutOn:for:within:">fileOutOn: outputStream for: aPackage within: aBundle	"Write out all the changes the receiver knows about."	| fileManager |	fileManager := outputStream.	fileManager deferInitializations.	( self changedDefinitionsFor: aPackage ) do:		[ :obj |   | cset |		cset := self at: obj absoluteName asClassNameOnly asSymbol.		cset fileOutChangesFor: obj for: aPackage within: aBundle on: fileManager.		IncrementNotification raiseSignal.		].	self removedNames do:		[ :name | 		( ( aBundle ~~ nil  )  and:  [ aBundle includesDefinitionOf: name ] )			ifFalse: [ fileManager removeObject: name type: ( self at: name ) fileOutObjectType ]		].	self fileOutSpecialOn: fileManager.	fileManager finishInitializations.	fileManager cr.</body><body package="Store-Change Management" selector="fileOutOn:within:">fileOutOn: outputStream within: aBundle	"Write out all the changes the receiver knows about."	self fileOutOn: outputStream for: nil within: aBundle</body></methods><methods><class-id>Store.XChangeSet</class-id> <category>private-fileIn/Out</category><body package="Store-Change Management" selector="fileOutSpecialOn:">fileOutSpecialOn: fileManager 	"Write out any special changes the receiver knows about."</body></methods><methods><class-id>Store.XChangeSet</class-id> <category>public-lists</category><body package="Store-Change Management" selector="modifiedTags">modifiedTags	"Answer a collection of tags for changed or add class definitions,	methods or data, not including removed definitions."	| tags props |	tags := OrderedCollection new.	self keysAndValuesDo: 		[ :symbol :cc | tags addAll: cc modifiedTags ].	( props := self propertiesOrNil ) == nil		ifFalse: [ props do: [ :prop | tags add: ( PropertyTag new property: prop ) ] ].	( other ~~ nil and: [ other includes: BundleModel structureMark ] )		ifTrue: [ tags add: BundleStructureTag new ].	^tags</body><body package="Store-Change Management" selector="removedTags">removedTags	"Answer a collection of tags for removed class/namespace definitions,	methods and data."	| tags |	tags := OrderedCollection new.	self keysAndValuesDo: [ :symbol :cc | tags addAll: cc removedTags ].	^tags</body></methods><methods><class-id>Kernel.PropertyChange</class-id> <category>store</category><body package="Store-Change Management" selector="doChangeTo:">doChangeTo: aChangeSet	"Perfrom the reciever's change onto aChangeSet."	"Used in converting ChangeSet changes to Store changes."	aChangeSet addPropertyChange: property</body></methods><methods><class-id>XML.SourceNodeBuilder</class-id> <category>compiling-code components</category><body package="Store-Change Management" selector="compile_pundle_loaded:">compile_pundle_loaded: anElement	#{Store.Pundle} ifDefinedDo:		[ :pundleClass |		pundleClass			reloadPundle: ( self getSymbol: 'type' from: anElement )			named: ( self getString: 'name' from: anElement default: '' )			id: ( self getString: 'primaryKey' from: anElement default: '0' ) asInteger			fromDatabase: ( self getString: 'databaseId' from: anElement default: '' )		].</body><body package="Store-Change Management" selector="compile_pundle_saved:">compile_pundle_saved: anElement	#{Store.Pundle} ifDefinedDo:		[ :pundleClass |		pundleClass			reloadPundle: ( self getSymbol: 'type' from: anElement )			named: ( self getString: 'name' from: anElement default: '' )			id: ( self getString: 'primaryKey' from: anElement default: '0' ) asInteger			fromDatabase: ( self getString: 'databaseId' from: anElement default: '' )		].</body></methods><methods><class-id>Store.Access class</class-id> <category>filein/fileout</category><body package="Store-User Management" selector="prerequisitesForLoading">prerequisitesForLoading	^super prerequisitesForLoading		add:BasicBlessingPolicy;		add: BasicPublishPolicy;		add: BasicMergePolicy;		add: BasicOwnershipPolicy;		add: BasicPackagePolicy;		add: BasicVersionPolicy;		add: BranchingVersionPolicy;		yourself</body></methods><methods><class-id>Store.Access</class-id> <category>accessing</category><body package="Store-User Management" selector="filePolicy">filePolicy	^filePolicy</body><body package="Store-User Management" selector="filePolicy:">filePolicy: aPolicy	filePolicy := aPolicy</body></methods><methods><class-id>Kernel.SourceFileManager</class-id> <category>file out support</category><body package="Store-SourceManagement" selector="fileOutData:for:">fileOutData: aSet for: aNameSpace	"File a description of the data of aNameSpace, whose keys are in aSet, onto the	target file.  If updateSourcePointers is true, then set the methods' sourcePointers in	order to indicate where to find the source code."	^self fileOutData: aSet for: aNameSpace logging: true</body><body package="Store-SourceManagement" selector="fileOutData:for:logging:">fileOutData: aSet for: aNameSpace logging: logging	"File a description of the data of aNameSpace whose keys are in aSet onto the	target file."		aSet do:		[:key |		(aNameSpace asNameSpace includesKey: key)			ifTrue:				[self storeObjectDefinition: (aNameSpace asNameSpace fullyQualifiedReferenceOf: key).				logging ifTrue: [Transcript cr; show: aNameSpace printString , '.' , key]]			ifFalse: [Dialog warn: aNameSpace printString, '.', key, ' is not defined.']].</body></methods><methods><class-id>Kernel.BOSSWriter</class-id> <category>writing</category><body package="Store-SourceManagement" selector="nextPutPackage:withSource:">nextPutPackage: aPackage withSource: sourceMode	"Store a collection of classes and method additions. The semantics are similar to 	fileOut, i.e., only the code is written, not the values of the class 	variables or class instance variables.  The main difference is that any methods that are additions in another package are	assumed to be the responsibility of the other package and are not stored.	Method changes are shared between package i.e. they clobber each other." 	| classSet objColl  packageArray  |	packageArray := Array new: 7.	packageArray at: 1 put: aPackage classListForPackage.	packageArray at: 2 put: aPackage compiledMethods.	packageArray at: 3 put: aPackage name.	packageArray at: 4 put: aPackage comment.	packageArray at: 5 put: aPackage postLoadBlock.	packageArray at: 6 put: aPackage preUnloadBlock.	packageArray at: 7 put: aPackage currentTag.	useSource := sourceMode.	classSet := IdentitySet new: packageArray first size * 2.	classSet addAll: packageArray first.	objColl := SystemUtils sortForLoading: packageArray first.	objColl := objColl asArray.	packageArray at: 1 put: objColl.	self nextPut: packageArray do:		[objColl do:			[:c |			currentClass := c.			self trace: (BOSSContents new object: c).			self trace: c].		(packageArray at: 2) do:			[:m |			currentClass := m mclass.			self trace: m].		objColl do:			[:c |			| list |			list := c binaryInitializationMessagesFor: useSource.			list do:				[:msg |				| init |				init := Array with: #deferSend: with: msg.				self trace: init body: init class: BinaryObjectStorage indexImportSendSelf]]]</body><body package="Store-SourceManagement" selector="nextPutPackageIndex:">nextPutPackageIndex: aPackage	"Store the index to a package." 	| indexArray |	indexArray := Array new: 4.	indexArray at: 1 put: aPackage literalClassListForPackage.	indexArray at: 2 put: aPackage methods asArray.	indexArray at: 3 put: aPackage name.	indexArray at: 4 put: aPackage indexTag.	self nextPut: indexArray.  "Put table of contents"</body></methods><methods><class-id>Kernel.BOSSReader</class-id> <category>reading</category><body package="Store-SourceManagement" selector="nextPackageWithSource:">nextPackageWithSource: sourceMode	"Read a collection of classes. The semantics are equivalent to 	fileIn, i.e., only the code is read, not the values of the class 	variables or class instance variables."  	useSource := sourceMode.	readingClasses := true.	^Class commentRequestSignal		handle: [:ex | ex proceedWith: useSource ~= #discard]		do: [self readObject]</body></methods><methods><class-id>Kernel.BinaryObjectStorage</class-id> <category>reading</category><body package="Store-SourceManagement" selector="nextPackage">nextPackage	^self reader nextPackageWithSource: sourceMode</body></methods><methods><class-id>Kernel.BinaryObjectStorage</class-id> <category>writing</category><body package="Store-SourceManagement" selector="nextPutPackage:">nextPutPackage: aPackage	self writer nextPutPackage: aPackage withSource: sourceMode</body><body package="Store-SourceManagement" selector="nextPutPackageIndex:">nextPutPackageIndex: aPackage	self writer nextPutPackageIndex: aPackage</body></methods><methods><class-id>Store.AbstractTool class</class-id> <category>resources</category><body package="Store-UI" selector="bundleImageModifiedBW">bundleImageModifiedBW	"UIMaskEditor new openOnClass: self andSelector: #bundleImageModifiedBW"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 254 0 0 63 254 0 0 32 254 0 0 32 254 0 0 32 254 0 0 32 254 0 0 32 36 0 0 63 228 0 0 4 4 0 0 4 4 0 0 7 252 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI" selector="bundleImageModifiedC">bundleImageModifiedC	"UIMaskEditor new openOnClass: self andSelector: #bundleImageModifiedC"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 3) at: 1 put: ColorValue black; at: 2 put: ColorValue green; at: 3 put: ColorValue white; yourself)) usingBits: #[170 170 170 168 170 170 0 0 160 0 21 80 162 170 21 80 162 170 21 80 162 170 21 80 162 170 0 0 162 170 162 136 160 0 2 136 170 138 170 136 170 138 170 136 170 128 0 8 170 170 170 168 170 170 170 168])</body><body package="Store-UI" selector="bundleImageUnmodifiedBW">bundleImageUnmodifiedBW	"UIMaskEditor new openOnClass: self andSelector: #bundleImageUnmodifiedBW"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 63 224 0 0 32 32 0 0 32 32 0 0 32 60 0 0 32 36 0 0 32 36 0 0 63 228 0 0 4 4 0 0 4 4 0 0 7 252 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI" selector="dbBundleImageBW">dbBundleImageBW	"UIMaskEditor new openOnClass: self andSelector: #dbBundleImageBW"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 42 160 0 0 0 0 0 0 32 32 0 0 0 20 0 0 32 32 0 0 0 4 0 0 42 160 0 0 4 4 0 0 0 0 0 0 5 84 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI" selector="dbNonCodePackageImageBW">dbNonCodePackageImageBW	"UIMaskEditor new openOnClass: self andSelector: #dbNonCodePackageImageBW"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 10 168 0 0 0 4 0 0 16 0 0 0 0 8 0 0 32 0 0 0 0 16 0 0 64 0 0 0 42 160 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI" selector="dbPackageImageBW">dbPackageImageBW	"UIMaskEditor new openOnClass: self andSelector: #dbPackageImageBW"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 21 84 0 0 0 0 0 0 16 4 0 0 0 0 0 0 16 4 0 0 0 0 0 0 16 4 0 0 0 0 0 0 21 84 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI" selector="nonCodePackageImageModifiedBW">nonCodePackageImageModifiedBW	"UIMaskEditor new openOnClass: self andSelector: #nonCodePackageImageModifiedBW"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 254 0 0 0 254 0 0 15 254 0 0 8 254 0 0 16 254 0 0 16 254 0 0 32 16 0 0 32 16 0 0 64 32 0 0 127 224 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI" selector="nonCodePackageImageModifiedC">nonCodePackageImageModifiedC	"UIMaskEditor new openOnClass: self andSelector: #nonCodePackageImageModifiedC"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 3) at: 1 put: ColorValue black; at: 2 put: ColorValue green; at: 3 put: ColorValue white; yourself)) usingBits: #[170 170 170 168 170 170 0 0 170 170 21 80 170 0 21 80 170 42 21 80 168 170 21 80 168 170 0 0 162 170 168 168 162 170 168 168 138 170 162 168 128 0 2 168 170 170 170 168 170 170 170 168 170 170 170 168])</body><body package="Store-UI" selector="nonCodePackageImageUnmodifiedBW">nonCodePackageImageUnmodifiedBW	"UIMaskEditor new openOnClass: self andSelector: #nonCodePackageImageUnmodifiedBW"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 15 252 0 0 8 4 0 0 16 8 0 0 16 8 0 0 32 16 0 0 32 16 0 0 64 32 0 0 127 224 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI" selector="packageImageModifiedBW">packageImageModifiedBW	"UIMaskEditor new openOnClass: self andSelector: #packageImageModifiedBW"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 254 0 0 0 254 0 0 31 254 0 0 16 254 0 0 16 254 0 0 16 254 0 0 16 4 0 0 16 4 0 0 16 4 0 0 16 4 0 0 31 252 0 0 0 0 0 0 0 0 0 0 ])</body><body package="Store-UI" selector="packageImageModifiedC">packageImageModifiedC	"UIMaskEditor new openOnClass: self andSelector: #packageImageModifiedC"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 4) at: 1 put: (ColorValue scaledRed: 1092 scaledGreen: 1092 scaledBlue: 1092); at: 2 put: ColorValue green; at: 3 put: ColorValue black; at: 4 put: ColorValue white; yourself)) usingBits: #[255 255 255 252 255 255 0 0 255 255 21 80 252 0 21 80 252 255 21 80 252 255 21 80 252 255 0 0 252 255 255 204 252 255 255 236 252 255 255 204 252 255 255 204 252 0 0 12 255 255 255 252 255 255 255 252])</body><body package="Store-UI" selector="packageImageUnmodifiedBW">packageImageUnmodifiedBW	"UIMaskEditor new openOnClass: self andSelector: #packageImageUnmodifiedBW"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 31 252 0 0 16 4 0 0 16 4 0 0 16 4 0 0 16 4 0 0 16 4 0 0 16 4 0 0 16 4 0 0 31 252 0 0 0 0 0 0 0 0 0 0 ])</body></methods><methods><class-id>Store.AbstractTool class</class-id> <category>interface specs</category><body package="Store-UI" selector="publishPackage">publishPackage	"UIPainter new openOnClass: self andSelector: #publishPackage"	&lt;resource: #canvas&gt;	^#(#{FullSpec} 		#window: 		#(#{WindowSpec} 			#label: 'Publishing Package' 			#min: #(#{Point} 381 377 ) 			#max: #(#{Point} 381 377 ) 			#bounds: #(#{Rectangle} 371 200 752 577 ) ) 		#component: 		#(#{SpecCollection} 			#collection: #(				#(#{LabelSpec} 					#layout: #(#{Point} 12 47 ) 					#label: 'Version:' ) 				#(#{InputFieldSpec} 					#layout: #(#{LayoutFrame} 103 0 45 0 -8 1 75 0 ) 					#name: #versionString 					#model: #versionString ) 				#(#{CheckBoxSpec} 					#layout: #(#{Point} 43 82 ) 					#name: #binarySave 					#model: #binarySave 					#label: 'Binary' ) 				#(#{CheckBoxSpec} 					#layout: #(#{Point} 199 82 ) 					#name: #parcelSave 					#model: #parcelSave 					#label: 'Parcel' ) 				#(#{InputFieldSpec} 					#layout: #(#{LayoutFrame} 17 0 8 0 -17 1 31 0 ) 					#flags: 0 					#model: #dialogTitle 					#tabable: false 					#alignment: #center 					#isReadOnly: false )				#(#{LabelSpec} 					#layout: #(#{Point} 15 122 ) 					#label: 'Blessing Level:' ) 				#(#{ActionButtonSpec} 					#layout: #(#{LayoutFrame} -40 0.25 -40 1 41 0.25 -10 1 ) 					#name: #publish 					#model: #publish 					#label: 'Publish' 					#isDefault: true 					#defaultable: true ) 				#(#{ActionButtonSpec} 					#layout: #(#{LayoutFrame} -40 0.75 -40 1 40 0.75 -10 1 ) 					#name: #cancel 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) 				#(#{TextEditorSpec} 					#layout: #(#{LayoutFrame} 12 0 179 0 -14 1 -50 1 ) 					#name: #blessingComment 					#model: #blessingComment ) 				#(#{LabelSpec} 					#layout: #(#{Point} 15 148 ) 					#label: 'Blessing Comment:' ) 				#(#{DividerSpec} 					#layout: #(#{LayoutFrame} 18 0 108 0 -12 1 112 0 ) ) 				#(#{MenuButtonSpec} 					#layout: #(#{LayoutFrame} 152 0 119 0 -15 1 148 0 ) 					#name: #blessingLevelButton 					#model: #blessingLevel 					#menu: #blessingLevelMenu ) ) ) )</body></methods><methods><class-id>Store.GarbageCollectSpecEditor class</class-id> <category>interface specs</category><body package="Store-UI" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Garbage Collection' 			#min: #(#{Core.Point} 385 189 ) 			#bounds: #(#{Graphics.Rectangle} 329 228 823 636 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 23 48 ) 					#label: 'Packages' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 17 0.5 48 0 ) 					#label: 'Garbage' ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 7 0 3 0 -7 1 -38 1 ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 17 14 ) 					#label: 'Before Date:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 109 12 214 37 ) 					#name: #date 					#model: #date 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#focusOutSelector: #disturb 						#valueChangeSelector: #disturb ) 					#isReadOnly: false 					#type: #date ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 350 0 12 0 0 0.969424 37 0 ) 					#name: #blessingLevelButton 					#model: #blessingLevel 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#menu: #blessingLevelMenu ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 23 0 76 0 -18 0.5 -98 1 ) 					#name: #availablePundlesView 					#flags: 15 					#model: #availablePundles 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb 						#requestValueChangeSelector: 						#okSelection: ) 					#multipleSelections: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} -10 0.25 -68 1 0.5 0.5 ) 					#name: #addToGarbage 					#model: #addToGarbage 					#label: 'Add to garbage' 					#defaultable: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 17 0.5 78 0 -22 1 -98 1 ) 					#name: #garbageView 					#flags: 15 					#model: #garbage 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.75 -68 1 0.5 0.5 ) 					#name: #removeItem 					#model: #removeItem 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} -127 0.5 -6 1 1 1 ) 					#name: #acceptButton 					#model: #accept 					#label: 'Accept' 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 67 0.5 -6 1 0 1 ) 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 222 14 ) 					#label: 'Highest Blessing:' ) ) ) )</body></methods><methods><class-id>Store.TextDifferenceBrowser class</class-id> <category>interface specs</category><body package="Store-UI-Comparitors" selector="briefSpec">briefSpec	"UIPainter new openOnClass: self andSelector: #briefSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Text Difference Browser' 			#min: #(#Point 50 50 ) 			#bounds: #(#Rectangle 188 283 828 479 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#TextEditorSpec 					#layout: #(#LayoutFrame 0 0.00316957 2 0 0 0.496038 0 0.992126 ) 					#name: #text1Widget 					#model: #text1 					#menu: #customTextMenu ) 				#(#TextEditorSpec 					#layout: #(#LayoutFrame 0 0.499208 2 0 0 0.99683 0 0.992126 ) 					#name: #text2Widget 					#model: #text2 					#menu: #customTextMenu ) ) ) )</body></methods><methods><class-id>Store.FileDifferenceBrowser class</class-id> <category>interface specs</category><body package="Store-UI-Comparitors" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec #window: #(#WindowSpec #label: 'Text Difference Browser' #min: #(#Point 50 50 ) #bounds: #(#Rectangle 214 225 848 704 ) ) #component: #(#SpecCollection #collection: #(#(#InputFieldSpec #layout: #(#LayoutFrame 0 0.00315457 0 0.0730689 0 0.33123 0 0.135699 ) #model: #fileName1 ) #(#LabelSpec #layout: #(#LayoutOrigin 0 0.00157729 0 0.0334029 ) #label: 'Filename 1' ) #(#InputFieldSpec #layout: #(#LayoutFrame 0 0.65142 0 0.0709812 0 0.995268 0 0.135699 ) #model: #fileName2 ) #(#LabelSpec #layout: #(#LayoutOrigin 0 0.865931 0 0.0313152 ) #label: 'Filename 2' ) #(#TextEditorSpec #layout: #(#LayoutFrame 0 0.00315457 0 0.139875 0 0.496845 0 0.995825 ) #name: #text1Widget #model: #text1 ) #(#TextEditorSpec #layout: #(#LayoutFrame 0 0.498423 0 0.139875 0 0.995268 0 0.995825 ) #name: #text2Widget #model: #text2 ) #(#ActionButtonSpec #layout: #(#LayoutFrame 0 0.372425 0 0.0729167 0 0.599049 0 0.133333 ) #model: #findDiffs #label: 'Find Differences' #defaultable: true ) #(#LabelSpec #layout: #(#LayoutOrigin 0 0.22187 0 0.00833333 ) #label: 'Specify two files and/or paste text into text views' ) ) ) )</body></methods><methods><class-id>Store.MergeSelector class</class-id> <category>interface specs</category><body package="Store-Merge" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Merge Selector' 			#bounds: #(#Rectangle 236 389 593 674 ) 			#menu: #menuBar ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#SequenceViewSpec 					#layout: #(#LayoutFrame 0 0 0 0 0 1 -40 1 ) 					#name: #packagesID 					#model: #packages 					#multipleSelections: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 20 0 -35 1 91 0 0 1 ) 					#name: #mergeID 					#flags: 40 					#model: #accept 					#label: 'Accept' 					#isDefault: true 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -91 1 -35 1 -20 1 0 1.0 ) 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Store.ClassLoader class</class-id> <category>interface specs</category><body package="Store-UI" selector="loadDialog">loadDialog	"UIPainter new openOnClass: self andSelector: #loadDialog"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Load Class' 			#min: #(#{Core.Point} 338 197 ) 			#max: #(#{Core.Point} 338 197 ) 			#bounds: #(#{Graphics.Rectangle} 381 255 719 452 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 37 32 ) 					#model: #idefinition 					#label: 'Definition' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 37 60 ) 					#model: #imethods 					#label: 'Methods' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 192 35 ) 					#model: #cdefinition 					#label: 'Definition' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 192 60 ) 					#model: #cmethods 					#label: 'Methods' ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 30 8 154 95 ) 					#label: 'Instance Side' ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 187 8 311 95 ) 					#label: 'Class Side' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 33 110 ) 					#model: #comment 					#label: 'Comment' )  				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 192 109 ) 					#name: #data 					#model: #data 					#label: 'Shared Variables' )				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 7 148 117 183 ) 					#model: #loadChoosen 					#label: 'Load Chosen' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 240 147 333 183 ) 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 123 148 234 183 ) 					#model: #loadAll 					#label: 'Load All' 					#isDefault: true 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Store.PundleChangeList class</class-id> <category>resources</category><body package="Store-UI" selector="changeListMenu">changeListMenu	"MenuEditor new openOnClass: self andSelector: #changeListMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'File in/out' 				#nameKey: #fileMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Write file...' 							#value: #fileOut ) ) #(1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'Revert all' 				#nameKey: #replayAllMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'From here' 							#value: #doFromHere ) 						#(#{UI.MenuItem} 							#rawLabel: 'From the top' 							#value: #doAll ) ) #(2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'Remove All' 				#value: #removeAll ) 			#(#{UI.MenuItem} 				#rawLabel: 'Restore All' 				#value: #restoreAll ) 			#(#{UI.MenuItem} 				#rawLabel: 'Spawn all...' 				#value: #copyView ) 			#(#{UI.MenuItem} 				#rawLabel: 'Forget' 				#value: #forgetAll ) 			#(#{UI.MenuItem} 				#rawLabel: 'Revert selection' 				#value: #doThis ) 			#(#{UI.MenuItem} 				#rawLabel: 'Remove Selection' 				#value: #removeItem ) 			#(#{UI.MenuItem} 				#rawLabel: 'Restore selection' 				#value: #restoreItem ) 			#(#{UI.MenuItem} 				#rawLabel: 'Spawn selection...' 				#value: #spawnBrowserOnSelection ) 			#(#{UI.MenuItem} 				#rawLabel: 'Conflicts' 				#nameKey: #conflictsMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Check conflicts, save as...' 							#value: #check ) 						#(#{UI.MenuItem} 							#rawLabel: 'Check with system, save as...' 							#value: #checkWithSystem ) ) #(2 ) nil ) ) ) #(1 4 1 4 1 ) nil ) decodeAsLiteralArray</body><body package="Store-UI" selector="menuBar">menuBar	"MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: '&amp;File' 				#nameKey: #file 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Write file...' 							#value: #fileOut ) ) #(1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'Revert' 				#nameKey: #revert 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Selection' 							#value: #doThis ) 						#(#{UI.MenuItem} 							#rawLabel: 'All from the top' 							#value: #doAll ) 						#(#{UI.MenuItem} 							#rawLabel: 'All from here on down' 							#value: #doFromHere ) ) #(1 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'Remove' 				#nameKey: #remove 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Selection' 							#value: #removeItem ) 						#(#{UI.MenuItem} 							#rawLabel: 'All' 							#value: #removeAll ) 						#(#{UI.MenuItem} 							#rawLabel: 'All Above' 							#value: #removeAllAbove ) 						#(#{UI.MenuItem} 							#rawLabel: 'All Below' 							#value: #removeAllBelow ) 						#(#{UI.MenuItem} 							#rawLabel: 'Exchange removed' 							#value: #exchangeRemoved ) 						#(#{UI.MenuItem} 							#rawLabel: 'Same source as parent' 							#value: #removeSameSourceAsParent ) 						#(#{UI.MenuItem} 							#rawLabel: 'Different code than parent' 							#value: #removeConflictsWithParent ) 						#(#{UI.MenuItem} 							#rawLabel: 'Methods not in parent' 							#value: #removeMethodsNotInParent ) 						#(#{UI.MenuItem} 							#rawLabel: 'Everything not in parent' 							#value: #removeEverythingNotInParent ) 						#(#{UI.MenuItem} 							#rawLabel: 'Changes containing string ...' 							#value: #removeChangesContainingString ) ) #(4 1 2 2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'Forget' 				#nameKey: #forget 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Forget these' 							#value: #forgetThese ) 						#(#{UI.MenuItem} 							#rawLabel: 'Forget all' 							#value: #forgetAll ) 						#(#{UI.MenuItem} 							#rawLabel: 'Purge these' 							#nameKey: #purgeThese 							#value: #purgeThese ) 						#(#{UI.MenuItem} 							#rawLabel: 'Purge selection' 							#nameKey: #purgeSelection 							#value: #purgeSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 'Restore selection' 							#value: #restoreItem ) 						#(#{UI.MenuItem} 							#rawLabel: 'Restore all' 							#value: #restoreAll ) 						#(#{UI.MenuItem} 							#rawLabel: 'Restore changes containing string' 							#value: #restoreChangesContainingString ) ) #(2 2 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'Find' 				#nameKey: #find 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Find package...' 							#nameKey: #findPackage 							#value: #findPackage ) 						#(#{UI.MenuItem} 							#rawLabel: 'Find class ...' 							#value: #findClass ) 						#(#{UI.MenuItem} 							#rawLabel: 'Find protocol ...' 							#value: #findProtocol ) 						#(#{UI.MenuItem} 							#rawLabel: 'Find selector ...' 							#value: #findSelector ) 						#(#{UI.MenuItem} 							#rawLabel: 'Spawn selection' 							#value: #spawnBrowserOnSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 'Spawn all' 							#value: #copyView ) 						#(#{UI.MenuItem} 							#rawLabel: 'Spawn overrides containing string' 							#value: #spawnChangesContainingString ) 						#(#{UI.MenuItem} 							#rawLabel: 'Class matching' 							#nameKey: #classMatching 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: 'Instance and class' 										#nameKey: #groupClassAndMetaclass 										#value: #groupClassAndMetaclass 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 'Selected class only' 										#nameKey: #ungroupClassAndMetaclass 										#value: #ungroupClassAndMetaclass 										#indication: true ) ) #(2 ) nil ) ) 						#(#{UI.MenuItem} 							#rawLabel: 'Same package' 							#nameKey: #filterByPackage 							#value: #togglePackageFilter 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 'Same type' 							#nameKey: #filterByType 							#value: #toggleTypeFilter 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 'Same class' 							#nameKey: #filterByClass 							#value: #toggleClassFilter 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 'Same protocol' 							#nameKey: #filterByProtocol 							#value: #toggleProtocolFilter 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 'Same selector' 							#nameKey: #filterBySelector 							#value: #toggleSelectorFilter 							#indication: true ) ) #(4 3 1 5 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'Show' 				#nameKey: #show 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Show code components' 							#nameKey: #showComponent 							#value: #toggleShowComponent 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 'Show protocol' 							#nameKey: #showProtocol 							#value: #toggleShowProtocol 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 'Show conflicts' 							#nameKey: #showConflicts 							#value: #toggleShowConflicts 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 'Conflicts' 							#nameKey: #showConflicts 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: 'Vertical view' 										#nameKey: #viewConflictsVertically 										#value: #viewConflictsVertically 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 'Horizontal view' 										#nameKey: #viewConflictsHorizontally 										#value: #viewConflictsHorizontally 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 'Source differences' 										#nameKey: #highlightSourceDifferences 										#value: #highlightSourceDifferences 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 'Code differences' 										#nameKey: #highlightCodeDifferences 										#value: #highlightCodeDifferences 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 'Emphasise in list' 										#nameKey: #toggleListEmphasis 										#value: #toggleListEmphasis ) 									#(#{UI.MenuItem} 										#rawLabel: 'Indicate same methods' 										#nameKey: #toggleTypesIncludeSame 										#value: #toggleTypesIncludeSame ) 									#(#{UI.MenuItem} 										#rawLabel: 'Line-end treatment' 										#nameKey: #lineEndTreatment 										#submenu: #(#{UI.Menu} #(												#(#{UI.MenuItem} 													#rawLabel: 'As in file' 													#nameKey: #lineEndsRaw 													#value: #lineEndsRaw 													#indication: true ) 												#(#{UI.MenuItem} 													#rawLabel: 'Converted to crs' 													#nameKey: #lineEndsTreated 													#value: #lineEndsTreated 													#indication: true ) ) #(2 ) nil ) ) ) #(2 2 3 ) nil ) ) ) #(3 1 ) nil ) ) ) #(6 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.PundleChangeList class</class-id> <category>interface specs</category><body package="Store-UI" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #windowLabel 			#min: #(#{Core.Point} 300 400 ) 			#bounds: #(#{Graphics.Rectangle} 206 453 636 953 ) 			#flags: 4 			#menu: #menuBar 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 179 0 -1 1 -1 1 ) 					#name: #textCanvas 					#flags: 0 					#minorKey: #standardText ) 				#(#{UI.SequenceViewSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragOkSelector 						#wantToDrag: #dragEnterSelector 						#dragEnter: #dragOverSelector 						#dragOver: #dragStartSelector 						#doDrag: #dropSelector 						#drop: #dragExitSelector 						#dragLeave: ) 					#layout: #(#{Graphics.LayoutFrame} 2 0 2 0 -98 1 172 0 ) 					#name: #listView 					#model: #selectionInList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: 						#toggleRemoveForListController: 						#requestValueChangeSelector: #changeRequest ) 					#menu: #changeListMenuHolder ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.CheckBoxSpec} 							#layout: #(#{Core.Point} 0 30 ) 							#model: #changeTypeFilterAdaptor 							#label: 'type' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Core.Point} 0 60 ) 							#model: #classNameFilterAdaptor 							#label: 'class' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Core.Point} 0 90 ) 							#model: #protocolFilterAdaptor 							#label: 'protocol' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Core.Point} 0 120 ) 							#model: #selectorFilterAdaptor 							#label: 'selector' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Core.Point} 0 0 ) 							#model: #packageFilterAdaptor 							#label: 'package' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} -92 1 17 0 -2 1 169 0 ) ) ) ) ) )</body></methods><methods><class-id>Store.VersionBrowser class</class-id> <category>interface specs</category><body package="Store-UI" selector="simpleWindowSpec">simpleWindowSpec	"Tools.UIPainter new openOnClass: self andSelector: #simpleWindowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Version List' 			#bounds: #(#{Graphics.Rectangle} 700 525 1112 763 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #versionList 					#flags: 15 					#model: #versions 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #pundleDoubleClickAction ) 					#menu: #listMenu 					#multipleSelections: true ) ) ) )</body><body package="Store-UI" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Version List' 			#bounds: #(#{Graphics.Rectangle} 512 384 924 622 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 25 0 0 1 -2 0.4 ) 					#name: #versionList 					#flags: 15 					#model: #versions 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #updateComment 						#doubleClickSelector: #pundleDoubleClickAction ) 					#menu: #listMenu 					#multipleSelections: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0 25 0 0 1 ) 					#name: #versionListLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #VersionsC 						#defaultString: 'Versions:' 						#catalogID: #labels ) ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -2 0.4 0 1 2 0.4 ) 					#name: #ResizingSplitter1 					#horizontal: true 					#minAboveSize: 60 					#minBelowSize: 60 					#aboveWidgets: 'versionList' 					#belowWidgets: 'comment commentLabel' ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 27 0.4 0 1 0 1 ) 					#name: #comment 					#model: #comment 					#tabRequiresControl: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0 27 0.4 0 1 ) 					#name: #commentLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #CommentC 						#defaultString: 'Comment:' 						#catalogID: #labels ) ) ) ) )</body></methods><methods><class-id>Store.VersionBrowser class</class-id> <category>resources</category><body package="Store-UI" selector="listMenuSkeleton">listMenuSkeleton	"MenuEditor new openOnClass: self andSelector: #listMenuSkeleton"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'Browse' 				#value: #browsePackageVersion ) 			#(#{UI.MenuItem} 				#rawLabel: 'List Contents' 				#value: #listBundleContents ) 			#(#{UI.MenuItem} 				#rawLabel: 'Load' 				#value: #loadPundle ) 			#(#{UI.MenuItem} 				#rawLabel: 'Merge' 				#value: #mergePundleVersion ) 			#(#{UI.MenuItem} 				#rawLabel: 'Reconcile Image with Selection' 				#nameKey: #reconcile 				#value: #reconcile ) 			#(#{UI.MenuItem} 				#rawLabel: 'File Out...' 				#value: #fileOutPundle ) 			#(#{UI.MenuItem} 				#rawLabel: 'Compare With Image' 				#value: #diffPundleWithImage ) 			#(#{UI.MenuItem} 				#rawLabel: 'Compare Versions' 				#value: #diffTwoPundles ) 			#(#{UI.MenuItem} 				#rawLabel: 'Set Blessing Level...' 				#value: #setBlessingLevel ) 			#(#{UI.MenuItem} 				#rawLabel: 'Update' 				#value: #reloadVersions ) ) #(2 3 1 2 1 1 ) nil ) decodeAsLiteralArray</body><body package="Store-UI" selector="menuBarSkeleton">menuBarSkeleton	"Tools.MenuEditor new openOnClass: self andSelector: #menuBarSkeleton"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: '&amp;File' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '&amp;Load' 							#value: #loadPundle ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Merge' 							#value: #mergePundleVersion ) 						#(#{UI.MenuItem} 							#rawLabel: 'Set Blessing Level...' 							#value: #setBlessingLevel ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;File Out...' 							#value: #fileOutPundle ) 						#(#{UI.MenuItem} 							#rawLabel: 'File Out Differences...' 							#value: #fileOutTwoPundleDiff ) 						#(#{UI.MenuItem} 							#rawLabel: 'Update' 							#value: #reloadVersions ) 						#(#{UI.MenuItem} 							#rawLabel: 'E&amp;xit' 							#value: #closeRequest ) ) #(2 1 2 1 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'Examine' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Browse' 							#value: #browsePackageVersion ) 						#(#{UI.MenuItem} 							#rawLabel: 'List Contents' 							#value: #listBundleContents ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Graph Versions' 							#value: #graphPundleVersions ) 						#(#{UI.MenuItem} 							#rawLabel: 'Compare with Image' 							#value: #diffPundleWithImage ) 						#(#{UI.MenuItem} 							#rawLabel: 'Compare with Parent' 							#value: #diffPundleWithParent ) 						#(#{UI.MenuItem} 							#rawLabel: 'Compare Versions' 							#value: #diffTwoPundles ) ) #(2 1 3 ) nil ) ) ) #(2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.StoreLoggingTool class</class-id> <category>resources</category><body package="Store-Base" selector="windowMenu">windowMenu	"MenuEditor new openOnClass: self andSelector: #windowMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: '&amp;File' 				#nameKey: #file 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '&amp;Save...' 							#value: #saveOutput ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Clear log' 							#value: #clear ) 						#(#{UI.MenuItem} 							#rawLabel: 'E&amp;xit' 							#value: #closeRequest 							#shortcutKeyCharacter: $x ) ) #(2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: '&amp;Logging' 				#nameKey: #logging ) 			#(#{UI.MenuItem} 				#rawLabel: '&amp;Trace' 				#nameKey: #trace ) 			#(#{UI.MenuItem} 				#rawLabel: '&amp;Execute SQL' 				#nameKey: #execute 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '&amp;All' 							#value: #executeAll ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Selection' 							#value: #executeSelection ) ) #(2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'PostInstallation' 				#nameKey: #installMgmInfo 				#value: #installInfo 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Run' 							#value: #installInfo ) ) #(1 ) nil ) ) ) #(5 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.ConnectionDialog class</class-id> <category>interface specs</category><body package="Store-DB-BaseObjects" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Connect to Database' 			#min: #(#{Core.Point} 426 245 ) 			#max: #(#{Core.Point} 426 245 ) 			#bounds: #(#{Graphics.Rectangle} 640 512 1066 757 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.Rectangle} 140 14 320 38 ) 					#name: #connectionProfile 					#model: #connectionProfileHolder 					#type: #string 					#comboList: #connectionProfileListHolder ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.Rectangle} 140 56 310 79 ) 					#name: #databaseCombo 					#model: #databaseHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #databaseChanged ) 					#type: #string 					#comboList: #databaseListHolder ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.Rectangle} 140 85 310 109 ) 					#name: #environmentCombo 					#model: #environmentHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #environmentChanged ) 					#isReadOnly: false 					#comboList: #environmentListHolder ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.Rectangle} 140 114 310 138 ) 					#name: #userNameCombo 					#model: #userNameHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #userNameChanged ) 					#isReadOnly: false 					#comboList: #userNameListHolder ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 140 143 310 167 ) 					#name: #passwordField 					#model: #passwordHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #passwordChanged ) 					#type: #password ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 140 204 220 227 ) 					#name: #saveProfile 					#model: #saveProfile 					#label: 'Save...' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 230 204 310 227 ) 					#name: #deleteProfile 					#model: #deleteProfile 					#label: 'Delete' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 14 0 -10 1 39 0 ) 					#name: #connect 					#model: #connect 					#label: 					#(#{Kernel.UserMessage} 						#key: #Connect 						#defaultString: 'Connect' 						#catalogID: #database ) 					#isDefault: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 46 0 -10 1 71 0 ) 					#name: #cancel 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #database ) 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 80 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #interface 						#defaultString: 'Interface:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 138 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #userName 						#defaultString: 'User Name:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 167 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #password 						#defaultString: 'Password:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 109 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #environment 						#defaultString: 'Environment:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 9 0 38 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #profile 						#defaultString: 'Connection Profile:' 						#catalogID: #database ) ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 10 46 320 239 ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 196 0 0 1 ) 					#label: 'Table Owner:' ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.Rectangle} 140 173 310 196 ) 					#name: #tableOwnerCombo 					#model: #tableOwnerHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #tableOwnerChanged ) 					#isReadOnly: false 					#comboList: #tableOwnerListHolder ) ) ) )</body></methods><methods><class-id>Store.BlessingLevel class</class-id> <category>interface specs</category><body package="Store-User Management" selector="mainSpec">mainSpec	"UIPainter new openOnClass: self andSelector: #mainSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Reset Blessing Level and Comment' 			#min: #(#{Core.Point} 331 321 ) 			#bounds: #(#{Graphics.Rectangle} 159 403 630 883 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 4 0 5 0 -4 1 -83 1 ) 					#label: 'Bundle and Subcomponents' ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 -41 1 -3 1 -39 1 ) ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 11 0 25 0 -11 1 -280 1 ) 					#name: #itemsList 					#flags: 15 					#model: #items ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 0 ) 							#name: #bCommentLabel 							#label: 'Blessing comment:' ) 						#(#{UI.TextEditorSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0 19 0 0 1 0 1 ) 							#name: #blessingComment 							#model: #blessingComment 							#tabRequiresControl: true ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 11 0 -220 1 -11 1 -90 1 ) ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 -50 1 0.5 1 ) 					#model: #allBlessings 					#label: 'Set Global Blessing Level and Comment' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 -5 1 0 1 ) 					#model: #accept 					#label: 'Ok' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 -5 1 0.5 1 ) 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} -10 1 -5 1 1 1 ) 					#name: #helpAction 					#model: #helpAction 					#label: 'Help' 					#defaultable: true ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.MenuButtonSpec} 							#layout: #(#{Graphics.LayoutFrame} 100 0 0 0 0 1.0 0 1.0 ) 							#name: #blessingLevelButton 							#model: #blessingLevel 							#menu: #blessingLevelMenu ) 						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0 0 0.08 ) 							#label: 'Blessing level:' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.Rectangle} 11 223 460 248 ) ) ) ) ) )</body></methods><methods><class-id>Store.SQLBroker class</class-id> <category>interface specs</category><body package="Store-DB-Broker" selector="reconnectSpec">reconnectSpec	"UIPainter new openOnClass: self andSelector: #reconnectSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Store Connection' 			#min: #(#{Core.Point} 298 234 ) 			#max: #(#{Core.Point} 391 378 ) 			#bounds: #(#{Graphics.Rectangle} 317 195 708 573 ) 			#flags: 8 			#menu: #menuBar 			#colors: 			#(#{UI.LookPreferences} 				#setBackgroundColor: #(#{Graphics.ColorValue} 7044 7044 7044 ) ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 12 0 234 0 0 1 ) 					#label: 'Username:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 12 0 265 0 0 1 ) 					#label: 'Password:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 12 0 299 0 0 1 ) 					#label: 'Environment:' ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 37 0 -10 1 156 0 ) 					#name: #messageBox 					#model: #message 					#alignment: #center 					#isReadOnly: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 5 0 0.5 0 ) 					#label: 'Reconnecting to the Store database.' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 148 0 213 0 -16 1 237 0 ) 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #userName 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 148 0 243 0 -16 1 267 0 ) 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #password 					#type: #password ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 148 0 278 0 -16 1 302 0 ) 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #environment 					#type: #string ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 204 0 -35 1 286 0 -8 1 ) 					#model: #accept 					#label: 'Connect' 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -97 1 -35 1 -15 1 -8 1 ) 					#name: #cancel 					#model: #cancel 					#label: 'Detach' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 12 183 ) 					#label: 'Database Connect:' ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.Rectangle} 148 183 369 207 ) 					#name: #whichDriver 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #whichDriverModel ) ) ) )</body></methods><methods><class-id>Store.LoadDialog class</class-id> <category>interface specs</category><body package="Store-UI" selector="loadDialogSpec">loadDialogSpec	"UIPainter new openOnClass: self andSelector: #loadDialogSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unpublished Changes' 			#bounds: #(#{Graphics.Rectangle} 625 421 975 779 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0.5 -38 1 80 0.5 -5 1 ) 					#model: #cancel 					#label: 'Cancel' 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -80 0.5 -38 1 -10 0.5 -5 1 ) 					#model: #accept 					#label: 'Proceed' 					#isDefault: false 					#defaultable: true ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 5 0 -5 1 -45 1 ) 					#model: #text 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>Store.CommentPrompt class</class-id> <category>interface specs</category><body package="Store-UI" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Blessing Level' 			#bounds: #(#Rectangle 137 285 583 530 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#Point 12 11 ) 					#label: 'Blessing level:' ) 				#(#TextEditorSpec 					#layout: #(#LayoutFrame 9 0 63 0 -9 1 -57 1 ) 					#model: #text ) 				#(#LabelSpec 					#layout: #(#Point 12 38 ) 					#label: 'Comment:' ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -190 0.5 203 0 -126 0.5 233 0 ) 					#model: #accept 					#label: 'Accept' 					#isDefault: true 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 126 0.5 203 0 190 0.5 233 0 ) 					#model: #cancel 					#label: 'Cancel' 					#isDefault: false 					#defaultable: true ) 				#(#MenuButtonSpec 					#layout: #(#LayoutFrame 110 0 8 0 -9 1 33 0 ) 					#model: #blessingLevel 					#menu: #blessingLevelMenu ) ) ) )</body></methods><methods><class-id>Store.RepositoryManager class</class-id> <category>resources</category><body package="Store-UI" selector="menuBar">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: '&amp;File' 				#nameKey: #file 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '&amp;Load...' 							#nameKey: #fileLoad 							#value: #fileLoad 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileOpen ) ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Save...' 							#nameKey: #fileSave 							#value: #fileSave 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileSave ) ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Close' 							#nameKey: #fileClose 							#value: #fileClose ) ) #(2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: '&amp;Repository' 				#nameKey: #repository 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '&amp;New...' 							#nameKey: #repositoryNew 							#value: #repositoryNew 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #addRepository ) ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Properties...' 							#nameKey: #repositoryProperties 							#value: #repositoryProperties 							#enablementSelector: #isRepositorySelected 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #properties ) ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Remove...' 							#nameKey: #repositoryRemove 							#value: #repositoryRemove 							#enablementSelector: #isRepositorySelected ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Connect' 							#nameKey: #repositoryToggleConnection 							#value: #repositoryToggleConnection 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #repositoryConnect ) ) 						#(#{UI.MenuItem} 							#rawLabel: 'Published &amp;Items' 							#nameKey: #repositoryPublishedItems 							#value: #repositoryPublishedItems ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;More Recent Items' 							#nameKey: #repositoryMoreRecentlyPublishedItems 							#value: #repositoryMoreRecentlyPublishedItems ) ) #(1 2 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: '&amp;Help' 				#nameKey: #help 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '&amp;About VisualWorks...' 							#nameKey: #helpAbout 							#value: #helpAbout ) ) #(1 ) nil ) ) ) #(3 ) nil ) decodeAsLiteralArray</body><body package="Store-UI" selector="repositoryListMenu">repositoryListMenu	"Tools.MenuEditor new openOnClass: self andSelector: #repositoryListMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: '&amp;New...' 				#nameKey: #repositoryNew 				#value: #repositoryNew 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #addRepository ) ) 			#(#{UI.MenuItem} 				#rawLabel: '&amp;Properties...' 				#nameKey: #repositoryProperties 				#value: #repositoryProperties 				#enablementSelector: #isRepositorySelected 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #properties ) ) 			#(#{UI.MenuItem} 				#rawLabel: '&amp;Remove...' 				#nameKey: #repositoryRemove 				#value: #repositoryRemove 				#enablementSelector: #isRepositorySelected ) 			#(#{UI.MenuItem} 				#rawLabel: '&amp;Connect' 				#nameKey: #repositoryToggleConnection 				#value: #repositoryToggleConnection 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #repositoryConnect ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'Published &amp;Items' 				#nameKey: #repositoryPublishedItems 				#value: #repositoryPublishedItems ) 			#(#{UI.MenuItem} 				#rawLabel: '&amp;More Recent Items' 				#nameKey: #repositoryMoreRecentlyPublishedItems 				#value: #repositoryMoreRecentlyPublishedItems ) ) #(1 2 3 ) nil ) decodeAsLiteralArray</body><body package="Store-UI" selector="toolbarMenu">toolbarMenu	"Tools.MenuEditor new openOnClass: self andSelector: #toolbarMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: '&amp;Load...' 				#nameKey: #fileLoad 				#value: #fileLoad 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileOpen ) 				#helpText: 'Load repositories from file' ) 			#(#{UI.MenuItem} 				#rawLabel: '&amp;Save...' 				#nameKey: #fileSave 				#value: #fileSave 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileSave ) 				#helpText: 'Save repositories to file' ) 			#(#{UI.MenuItem} 				#rawLabel: '&amp;New...' 				#nameKey: #repositoryNew 				#value: #repositoryNew 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #addRepository ) 				#helpText: 'Create a new repository' ) 			#(#{UI.MenuItem} 				#rawLabel: '&amp;Properties...' 				#nameKey: #repositoryProperties 				#value: #repositoryProperties 				#enablementSelector: #isRepositorySelected 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #properties ) 				#helpText: 'Edit repository properties' ) 			#(#{UI.MenuItem} 				#rawLabel: '&amp;Connect' 				#nameKey: #repositoryToggleConnection 				#value: #repositoryToggleConnection 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #repositoryConnect ) 				#helpText: 'Connect or disconnect the selected repository' ) ) #(2 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.RepositoryManager class</class-id> <category>interface specs</category><body package="Store-UI" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Store Repositories' 			#min: #(#{Core.Point} 492 188 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 526 384 956 584 ) 			#flags: 4 			#menu: #menuBar 			#toolBar: #toolbarMenu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.DataSetSpec} 					#properties: #(#{UI.PropertyListDictionary} #allowSorting true #allowColumnReordering false #allowColumnResizing true #showVerticalLines false #rowSize 22 #showHorizontalLines false #rowLabelsAsButtons false ) 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #repositoryDataset 					#flags: 13 					#model: #repositoryListHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #repositorySelected 						#doubleClickSelector: #repositoryListDoubleClicked ) 					#menu: #repositoryListMenu 					#columns: #(						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting false #labelFromApplication false ) 							#model: #'selectedRepositoryHolder isConnected' 							#label: '' 							#labelIsImage: false 							#width: 22 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting false #labelFromApplication false ) 							#model: #'selectedRepositoryHolder name' 							#label: 'Name' 							#labelIsImage: false 							#width: 100 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting false #labelFromApplication false ) 							#model: #'selectedRepositoryHolder environment' 							#label: 'Environment' 							#labelIsImage: false 							#width: 200 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting false #labelFromApplication false ) 							#model: #'selectedRepositoryHolder userName' 							#label: 'User' 							#labelIsImage: false 							#width: 80 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) ) 					#labelsAsButtons: true ) ) ) )</body></methods><methods><class-id>Store.ElementView class</class-id> <category>resources</category><body package="Store-UI-Graphs" selector="emptyInImage">emptyInImage	"UIMaskEditor new openOnClass: self andSelector: #emptyInImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 9@9 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 8 0 0 0 20 0 0 0 34 0 0 0 65 0 0 0 255 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI-Graphs" selector="emptyOutImage">emptyOutImage	"UIMaskEditor new openOnClass: self andSelector: #emptyOutImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 9@9 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 255 128 0 0 65 0 0 0 34 0 0 0 20 0 0 0 8 0 0 0 0 0 0 0])</body><body package="Store-UI-Graphs" selector="fullInImage">fullInImage	"UIMaskEditor new openOnClass: self andSelector: #fullInImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 9@9 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 8 0 0 0 28 0 0 0 62 0 0 0 127 0 0 0 255 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="Store-UI-Graphs" selector="fullOutImage">fullOutImage	"UIMaskEditor new openOnClass: self andSelector: #fullOutImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 9@9 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 255 128 0 0 127 0 0 0 62 0 0 0 28 0 0 0 8 0 0 0 0 0 0 0])</body></methods><methods><class-id>Store.DBAccess class</class-id> <category>interface specs</category><body package="Store-Database" selector="reconnectSpec">reconnectSpec	"UIPainter new openOnClass: self andSelector: #reconnectSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Store Connection' 			#min: #(#{Core.Point} 298 234 ) 			#max: #(#{Core.Point} 391 378 ) 			#bounds: #(#{Graphics.Rectangle} 338 193 729 571 ) 			#flags: 8 			#menu: #menuBar 			#colors: 			#(#{UI.LookPreferences} 				#setBackgroundColor: #(#{Graphics.ColorValue} 7044 7044 7044 ) ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 12 0 234 0 0 1 ) 					#label: 'Username:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 12 0 265 0 0 1 ) 					#label: 'Password:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 12 0 299 0 0 1 ) 					#label: 'Environment:' ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 37 0 -10 1 156 0 ) 					#name: #messageBox 					#model: #message 					#alignment: #center 					#isReadOnly: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 5 0 0.5 0 ) 					#name: #title 					#label: 'Reconnecting to the Store database.' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 148 0 213 0 -16 1 237 0 ) 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #userName 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 148 0 243 0 -16 1 267 0 ) 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #password 					#type: #password ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 148 0 278 0 -16 1 302 0 ) 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #environment 					#type: #string ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 204 0 -35 1 286 0 -8 1 ) 					#model: #accept 					#label: 'Connect' 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -97 1 -35 1 -15 1 -8 1 ) 					#name: #cancel 					#model: #cancel 					#label: 'Detach' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 12 183 ) 					#label: 'Database Connect:' ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.Rectangle} 148 183 369 207 ) 					#name: #whichDriver 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #whichDriverModel ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 150 308 ) 					#name: #saveConnection 					#model: #saveConnection 					#label: 'Save Connection Information' ) ) ) )</body></methods><methods><class-id>Store.AbstractWindowTool class</class-id> <category>resources</category><body package="Store-UI" selector="loadedContentsMenuBarSkeleton">loadedContentsMenuBarSkeleton	"MenuEditor new openOnClass: self andSelector: #loadedContentsMenuBarSkeleton"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: '&amp;File' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '&amp;Publish...' 							#value: #storePundleInDB ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Unload' 							#value: #deletePundle ) 						#(#{UI.MenuItem} 							#rawLabel: 'Reconcile Image with Selection' 							#nameKey: #reconcile 							#value: #reconcile ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;File Out...' 							#value: #fileOutPundle ) 						#(#{UI.MenuItem} 							#rawLabel: 'File Out Changes...' 							#value: #fileOutChanges ) 						#(#{UI.MenuItem} 							#rawLabel: 'Create As Parcel...' 							#value: #createAsParcel ) 						#(#{UI.MenuItem} 							#rawLabel: 'E&amp;xit' 							#value: #closeRequest ) ) #(3 2 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'Change' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Edit Specification' 							#value: #editBundleSpecification ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Make Current' 							#value: #makeCurrentPackage ) ) #(1 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'Examine' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Browse' 							#value: #browsePackageVersion ) 						#(#{UI.MenuItem} 							#rawLabel: 'List Contents' 							#value: #listBundleContents ) 						#(#{UI.MenuItem} 							#rawLabel: 'Enclosing Bundles' 							#value: #enclosingBundles ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;List Versions' 							#value: #browseVersions ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Graph Versions' 							#value: #graphPundleVersions ) 						#(#{UI.MenuItem} 							#rawLabel: 'Compare with Parent' 							#value: #diffPundleWithParent ) 						#(#{UI.MenuItem} 							#rawLabel: 'Inspect Changes' 							#value: #inspectChangesInPundle ) 						#(#{UI.MenuItem} 							#rawLabel: 'Changed Methods' 							#value: #methodsChangesInPundle ) ) #(3 2 3 ) nil ) ) ) #(3 ) nil ) decodeAsLiteralArray</body><body package="Store-UI" selector="loadedMenuBarSkeleton">loadedMenuBarSkeleton	"MenuEditor new openOnClass: self andSelector: #loadedMenuBarSkeleton"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: '&amp;File' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '&amp;Publish...' 							#value: #storePundleInDB ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Unload' 							#value: #deletePundle ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Reconcile image with selection' 							#value: #reconcile ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;File Out...' 							#value: #fileOutPundle ) 						#(#{UI.MenuItem} 							#rawLabel: 'File Out Changes...' 							#value: #fileOutChanges ) 						#(#{UI.MenuItem} 							#rawLabel: 'Create As Parcel...' 							#value: #createAsParcel ) 						#(#{UI.MenuItem} 							#rawLabel: 'E&amp;xit' 							#value: #closeRequest ) ) #(3 2 1 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'Change' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Edit Specification' 							#value: #editBundleSpecification ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Make Current' 							#value: #makeCurrentPackage ) 						#(#{UI.MenuItem} 							#rawLabel: 'Add Package...' 							#value: #addPackage ) 						#(#{UI.MenuItem} 							#rawLabel: 'Add Bundle...' 							#value: #addBundle ) ) #(1 1 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'Examine' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Browse' 							#value: #browsePackageVersion ) 						#(#{UI.MenuItem} 							#rawLabel: 'List Contents' 							#value: #listBundleContents ) 						#(#{UI.MenuItem} 							#rawLabel: 'Enclosing Bundles' 							#value: #enclosingBundles ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;List Versions' 							#value: #browseVersions ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Graph Versions' 							#value: #graphPundleVersions ) 						#(#{UI.MenuItem} 							#rawLabel: 'Compare with Parent' 							#value: #diffPundleWithParent ) 						#(#{UI.MenuItem} 							#rawLabel: 'Inspect Changes' 							#value: #inspectChangesInPundle ) 						#(#{UI.MenuItem} 							#rawLabel: 'Changed Methods' 							#value: #methodsChangesInPundle ) ) #(3 2 3 ) nil ) ) ) #(3 ) nil ) decodeAsLiteralArray</body><body package="Store-UI" selector="loadedPopupSkeleton">loadedPopupSkeleton	"UIMenuEditor new openOnClass: self andSelector: #loadedPopupSkeleton"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#label: 'browse' ) 			#(#MenuItem 				#label: 'list contents' ) 			#(#MenuItem 				#label: 'list versions' ) 			#(#MenuItem 				#label: 'compare with parent' ) 			#(#MenuItem 				#label: 'inspect changes' ) 			#(#MenuItem 				#label: 'changed methods' ) 			#(#MenuItem 				#label: 'publish...' ) 			#(#MenuItem 				#label: 'unload' ) ) #(3 3 2 ) #(#browsePackageVersion #listBundleContents #browseVersions #diffPundleWithParent #inspectChangesInPundle #methodsChangesInPundle #storePundleInDB #deletePundle ) ) decodeAsLiteralArray</body><body package="Store-UI" selector="publishedContentsMenuBarSkeleton">publishedContentsMenuBarSkeleton	"UIMenuEditor new openOnClass: self andSelector: #publishedContentsMenuBarSkeleton"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#label: 'File' 				#accessCharacterPosition: 1 				#submenu: #(#Menu #(						#(#MenuItem 							#label: 'Load' 							#accessCharacterPosition: 1 ) 						#(#MenuItem 							#label: 'Merge' 							#accessCharacterPosition: 1 ) 						#(#MenuItem 							#label: 'Set Blessing Level' ) 						#(#MenuItem 							#label: 'File Out...' 							#accessCharacterPosition: 1 ) 						#(#MenuItem 							#label: 'Update' ) 						#(#MenuItem 							#label: 'Exit' 							#accessCharacterPosition: 2 ) ) #(2 1 1 1 1 ) #(#loadPundle #mergePundleVersion #setBlessingLevel #fileOutPundle #reloadVersions #closeRequest ) ) ) 			#(#MenuItem 				#label: 'Examine' 				#submenu: #(#Menu #(						#(#MenuItem 							#label: 'Browse' ) 						#(#MenuItem 							#label: 'List Contents' ) 						#(#MenuItem 							#label: 'List Versions' 							#accessCharacterPosition: 1 ) 						#(#MenuItem 							#label: 'Graph Versions' 							#accessCharacterPosition: 1 ) 						#(#MenuItem 							#label: 'Compare with Image' ) 						#(#MenuItem 							#label: 'Compare with Parent' ) ) #(2 2 2 ) #(#browsePackageVersion #listBundleContents #browseVersions #graphPundleVersions #diffPundleWithImage #diffPundleWithParent ) ) ) ) #(2 ) #(nil nil ) ) decodeAsLiteralArray</body><body package="Store-UI" selector="publishedContentsPopupSkeleton">publishedContentsPopupSkeleton	"UIMenuEditor new openOnClass: self andSelector: #publishedContentsPopupSkeleton"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#label: 'browse' ) 			#(#MenuItem 				#label: 'list contents' ) 			#(#MenuItem 				#label: 'list versions' ) 			#(#MenuItem 				#label: 'compare with image' ) 			#(#MenuItem 				#label: 'load' ) 			#(#MenuItem 				#label: 'merge' ) ) #(2 1 1 2 ) #(#browsePackageVersion #listBundleContents #browseVersions #diffPundleWithImage #loadPundle #mergePundleVersion ) ) decodeAsLiteralArray</body><body package="Store-UI" selector="publishedMenuBarSkeleton">publishedMenuBarSkeleton	"UIMenuEditor new openOnClass: self andSelector: #publishedMenuBarSkeleton"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#label: 'File' 				#accessCharacterPosition: 1 				#submenu: #(#Menu #(						#(#MenuItem 							#label: 'Update' ) 						#(#MenuItem 							#label: 'Exit' 							#accessCharacterPosition: 2 ) ) #(1 1 ) #(#reloadVersions #closeRequest ) ) ) 			#(#MenuItem 				#label: 'Examine' 				#submenu: #(#Menu #(						#(#MenuItem 							#label: 'List Versions' 							#accessCharacterPosition: 1 ) 						#(#MenuItem 							#label: 'Graph Versions' 							#accessCharacterPosition: 1 ) ) #(2 ) #(#browseVersions #graphPundleVersions ) ) ) ) #(2 ) #(nil nil ) ) decodeAsLiteralArray</body><body package="Store-UI" selector="publishedPopupSkeleton">publishedPopupSkeleton	"UIMenuEditor new openOnClass: self andSelector: #publishedPopupSkeleton"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#label: 'update' ) ) #(1 ) #(#reloadVersions ) ) decodeAsLiteralArray</body></methods><methods><class-id>Store.PackageBrowserHelper</class-id> <category>actions</category><body package="Store-UI-Browser" selector="editBundleSpec">editBundleSpec	&lt;menuItem: 'Edit bundle specifications...'		icon: nil		nameKey: #editBundleSpec		enablement: #isForBundle		indication: nil		menu: #(#listMenu)		position: 10.25&gt;	self  selection isLoaded		ifFalse: [ ^self warnPackageNotLoaded ].	BundleSpecEditor openOnBundle: self selection</body><body package="Store-UI-Browser" selector="loadPundle">loadPundle	&lt;menuItem: 'Load...'		icon: nil		nameKey: #loadPundle		menu: #(#listMenu)		position: 10.03&gt;	| imgPundle msg pkg |	( pkg := self package ) == nil		ifTrue: [ ^self ].	self dbManager doIfOnlineImage:		[ | pundle |		msg := '&lt;1s&gt; is not linked to the current database.&lt;n&gt;It cannot be loaded until it has been reconciled.&lt;n&gt;Do you want to do that now?' 	expandMacrosWith: pkg name.		self isPackageLoaded			ifTrue: 				[ pkg hasTrace 					ifFalse: 						[ ( Dialog confirm: msg )							ifTrue: 								[ pundle := pkg selectVersion.								pkg reconcileWithDb: pundle.								]							ifFalse: [ ^self ].						]					ifTrue: [ pundle := pkg selectVersion ]				]			ifFalse: [ pundle := pkg ].		pundle == nil			ifTrue: [ ^self ].		( imgPundle := pundle getImagePundle ) == nil			ifFalse: 				[ ( imgPundle allDatabases includes: pundle dbIdentifier )						ifFalse: 								[ ( Dialog confirm: msg )								ifTrue: 									[ imgPundle reconcileWithDb: pundle.									pundle loadSrcWithImgPundle: imgPundle									].							^self.							]						].		( Dialog confirm: 'Do you want to load ' , pundle itemString , ' ?' )			ifTrue: [ pundle loadSrcWithImgPundle: imgPundle ].		]</body><body package="Store-UI-Browser" selector="makeCurrent">makeCurrent	&lt;menuItem: 'Make current'		icon: nil		nameKey: #makeCurrent		enablement: #isForPackage		indication: nil		menu: #(#listMenu)		position: 10.28&gt;	self selections size &gt; 1		ifTrue: [ ^Dialog warn: 'Only one package can be current' ].	self isPackageLoaded		ifFalse: [ ^Dialog warn: 'Current package must be in the image.' ].	Registry currentPackage: self selection.</body><body package="Store-UI-Browser" selector="mergePundleVersion">mergePundleVersion	&lt;menuItem: 'Merge Into Image...'		icon: nil		nameKey: #mergePundle		enablement: #isPackageUnloaded		indication: nil		menu: #(#listMenu)		position: 10.08&gt;	self dbManager doIfOnlineImage: 		[ MergeTool openOnPundles: self selections ]</body><body package="Store-UI-Browser" selector="openChangeListOnChanges">openChangeListOnChanges	&lt;menuItem: 'Change List On Changes'		icon: nil		nameKey: #changeListOnChanges		menu: #(#listMenu #browse)		position: 10.02&gt;	self selection == nil		ifTrue: [ ^self ].	Store.PundleChangeList openOn: self selection.</body><body package="Store-UI-Browser" selector="renamePundle">renamePundle	&lt;menuItem: 'Rename...'		icon: nil		nameKey: #renamePundle		menu: #(#listMenu)		position: 10.04&gt;	| pkg string |	( pkg := self package ) == nil		ifTrue: [ ^self ].	string := SmalltalkWorkbench requestNewPackageName: pkg name.	string isEmpty ifTrue: [ ^self ].	( pkg isPackage		ifTrue: [ Registry packageNamed: string ]		ifFalse: [ Registry bundleNamed: string ]	) == nil		ifFalse: [ Dialog warn: string, ' already exists'.  ^self ].	pkg renameTo: string.</body><body package="Store-UI-Browser" selector="resetBlessingLevel">resetBlessingLevel	&lt;menuItem: 'Reset Blessing Level...'		icon: nil		nameKey: #resetBlessing		enablement: #isPackageUnloaded		indication: nil		menu: #(#listMenu)		position: 10.15&gt;	self dbManager doIfOnlineImage: 		[ self packages do: 			[ :pundle | self addBlessingForPundle: pundle ]		].	self browser updateText.</body><body package="Store-UI-Browser" selector="showBundleStructure">showBundleStructure	&lt;menuItem: 'Show bundle structure...'		icon: nil		nameKey: #showBundleStructure		enablement: #isForBundle		indication: nil		menu: #(#listMenu)		position: 10.26&gt;	PundleGraph openBundleStructureViewOn: self selections asOrderedCollection</body></methods><methods><class-id>Store.PackageBrowserHelper class</class-id> <category>resources</category><body package="Store-UI-Browser" selector="defTypeMenu">defTypeMenu	"MenuEditor new openOnClass: self andSelector: #defTypeMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'Package Comment' 				#nameKey: #showPackageComment 				#value: #showPackageComment ) 			#(#{UI.MenuItem} 				#rawLabel: 'Package Definition' 				#nameKey: #showPackageDefinition 				#value: #showPackageDefinition ) 			#(#{UI.MenuItem} 				#rawLabel: 'Package Properties' 				#nameKey: #showPackageProperties 				#value: #showPackageProperties ) ) #(3 ) nil ) decodeAsLiteralArray</body><body package="Store-UI-Browser" selector="listMenu">listMenu	"MenuEditor new openOnClass: self andSelector: #listMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'New' 				#nameKey: #new 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Package...' 							#nameKey: #newPackage 							#value: #newPackage ) 						#(#{UI.MenuItem} 							#rawLabel: 'Bundle...' 							#nameKey: #newBundle 							#value: #newBundle ) ) #(2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'Publish...' 				#nameKey: #storePackageInDB 				#value: #storePackageInDB ) 			#(#{UI.MenuItem} 				#rawLabel: 'Publish as parcel...' 				#nameKey: #publishAsParcel 				#value: #publishAsParcel ) 			#(#{UI.MenuItem} 				#rawLabel: 'Unload...' 				#nameKey: #deletePackage 				#value: #deletePackage ) 			#(#{UI.MenuItem} 				#rawLabel: 'File Out' 				#nameKey: #fileOut 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Package...' 							#nameKey: #fileOutPackages 							#value: #fileOutPackages ) 						#(#{UI.MenuItem} 							#rawLabel: 'Changes...' 							#nameKey: #fileOutChanges 							#value: #fileOutChanges ) 						#(#{UI.MenuItem} 							#rawLabel: 'Differences...' 							#nameKey: #fileOutDifferences 							#value: #fileOutDifferences ) ) #(3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'File into package...' 				#nameKey: #fileIntoPackage 				#value: #fileIntoPackage ) 			#(#{UI.MenuItem} 				#rawLabel: 'Versions' 				#nameKey: #versions 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'List' 							#nameKey: #browseVersions 							#value: #browseVersions ) 						#(#{UI.MenuItem} 							#rawLabel: 'Graph' 							#nameKey: #graphVersions 							#value: #graphVersions ) 						#(#{UI.MenuItem} 							#rawLabel: 'Compare with parent' 							#nameKey: #diffPackageWithParent 							#value: #diffPackageWithParent ) 						#(#{UI.MenuItem} 							#rawLabel: 'Compare with...' 							#nameKey: #diffWithVersion 							#value: #diffWithVersion ) ) #(4 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'Reconcile with Database' 				#nameKey: #reconcile 				#value: #reconcile ) 			#(#{UI.MenuItem} 				#rawLabel: 'Browse' 				#nameKey: #browse 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Changed methods' 							#nameKey: #browseChanges 							#value: #browseChanges ) 						#(#{UI.MenuItem} 							#rawLabel: 'Change set' 							#nameKey: #inspectChanges 							#value: #inspectChanges ) 						#(#{UI.MenuItem} 							#rawLabel: 'Overrides of others' 							#nameKey: #browseOverrides 							#value: #browseOverrides ) 						#(#{UI.MenuItem} 							#rawLabel: 'Overridden by others' 							#nameKey: #browseOverridden 							#value: #browseOverridden ) ) #(4 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'Spawn' 				#nameKey: #spawn 				#value: #spawn ) 			#(#{UI.MenuItem} 				#rawLabel: 'Find...' 				#nameKey: #find 				#value: #find ) 			#(#{UI.MenuItem} 				#rawLabel: 'Find Package...' 				#nameKey: #findPackage 				#value: #findPackage ) 			#(#{UI.MenuItem} 				#rawLabel: 'Enclosing bundles' 				#nameKey: #enclosingComponents 				#value: #enclosingComponents ) 			#(#{UI.MenuItem} 				#rawLabel: 'Properties' 				#nameKey: #packageProperties 				#value: #packageProperties ) ) #(4 2 2 2 4 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.LoadAnalyzer class</class-id> <category>interface specs</category><body package="Store-Database" selector="stopSpec">stopSpec	"UIPainter new openOnClass: self andSelector: #stopSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Load  Analyzer' 			#bounds: #(#Rectangle 423 252 773 610 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#TextEditorSpec 					#layout: #(#LayoutFrame 5 0 5 0 -5 1 -45 1 ) 					#model: #text 					#isReadOnly: false ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -35 0.5 -38 1 35 0.5 -5 1 ) 					#model: #accept 					#label: 'OK' 					#defaultable: true ) ) ) )</body><body package="Store-Database" selector="warningSpec">warningSpec	"UIPainter new openOnClass: self andSelector: #warningSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Load  Analyzer' 			#bounds: #(#{Graphics.Rectangle} 332 174 682 532 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 5 0 -5 1 -45 1 ) 					#model: #text 					#isReadOnly: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -80 0.5 -38 1 -10 0.5 -5 1 ) 					#model: #accept 					#label: 'Proceed' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0.5 -38 1 80 0.5 -5 1 ) 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Store.PackageProtocolBrowserHelper</class-id> <category>actions</category><body package="Store-UI-Browser" selector="moveAllToPackage">moveAllToPackage	&lt;menuItem: 'Move all to package...'		nameKey: #moveAllToPackage		menu: #(#listMenu)		position: 90.02&gt;	"Move all the methods/ data in the current protocol/category to a selected package."	| target toPackage |	self selection isNil ifTrue: [ ^self ].	self changeRequest ifFalse: [ ^self ].	target := self selectedClassOrNameSpace.	toPackage := PackageChooser chooseOrAdd.	toPackage isNil ifTrue: [ ^self ].	( self isData or: [ target isNameSpace ]  )		ifTrue: 			[ ( target asNameSpace organization listAtCategoryNamed: self selection ) do:				[ :key | 				XChangeSet current 					moveDataKey: key					owner: target					toPackage: toPackage				]			]		ifFalse: 			[ ( target organization listAtCategoryNamed: self selection ) do: 				[ :sel | 				XChangeSet current 					moveSelector: sel					class: target					toPackage: toPackage				]			].	module updateList.</body><body package="Store-UI-Browser" selector="moveToPackage">moveToPackage	&lt;menuItem: 'Move package to package...'		nameKey: #moveToPackage		menu: #(#listMenu)		position: 90.01&gt;	"Move the methods/ data in the current protocol/category from the current package to a selected package."	| target toPackage name |	self selection isNil ifTrue: [ ^self ].	self isForPackage		ifFalse: [ ^Dialog warn: 'Can not move from a bundle.' ].	self changeRequest ifFalse: [ ^self ].	target := self selectedClassOrNameSpace.	toPackage := PackageChooser chooseOrAdd.	toPackage isNil ifTrue: [ ^self ].	name := target absoluteName.	( self isData or: [ target isNameSpace ]  )		ifTrue: 			[ ( self package dataForNamed: name andProtocol: self selection ) do:				[ :dd | 				XChangeSet current 					moveDataKey: dd dataKey					owner: target					toPackage: toPackage				]			]		ifFalse: 			[ ( self package methodsForClassNamed: name andProtocol: self selection meta: self isMeta ) do: 				[ :md | 				XChangeSet current 					moveSelector: md selector					class: target					toPackage: toPackage				]			].	module updateList.</body></methods><methods><class-id>Store.PackageProtocolBrowserHelper</class-id> <category>menus</category><body package="Store-UI-Browser" selector="sort">sort	&lt;submenu: '&amp;Sort'		nameKey: #sort		menu: #(#listMenu )		position: 30.08&gt;</body></methods><methods><class-id>Store.PackageProtocolBrowserHelper</class-id> <category>sorting</category><body package="Store-UI-Browser" selector="sortAlpha">sortAlpha	&lt;menuItem: 'Alphabetical'		nameKey: #sortAlpha		enablement: nil		indication: #isSortAlpha		menu: #(#listMenu #sort)		position: 10.04&gt;	self class setSortTo: #alpha.	sortBlock := self class defaultSort.	self updateListFull.</body><body package="Store-UI-Browser" selector="sortPublicPrivate">sortPublicPrivate	&lt;menuItem: 'Public private'		nameKey: #sortSystem		enablement: nil		indication: #isSortPublicPrivate		menu: #(#listMenu #sort )		position: 10.06&gt;	self class setSortTo: #publicPrivate.	sortBlock := self class defaultSort.	self updateListFull.</body><body package="Store-UI-Browser" selector="sortSystem">sortSystem	&lt;menuItem: 'System'		nameKey: #sortSystem		enablement: nil		indication: #isSortSystem		menu: #(#listMenu #sort )		position: 10.02&gt;	self class setSortTo: #system.	sortBlock := self class defaultSort.	self updateListFull.</body></methods><methods><class-id>Store.MergeTool class</class-id> <category>interface specs</category><body package="Store-Merge" selector="newSpec">newSpec	"UIPainter new openOnClass: self andSelector: #newSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Merge Tool' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 49 440 666 918 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 6 0 6 0 0 0.494327 0 0.467532 ) 					#name: #modSetListID 					#model: #modSetList 					#tabable: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.5 5 0 0 0.988655 0 0.464286 ) 					#name: #pkgListID 					#model: #pkgList 					#tabable: true 					#menu: #packageMenu 					#multipleSelections: true ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 6 0 230 0 -1 1 -1 1 ) 					#name: #textCanvas 					#minorKey: #standardText ) ) ) )</body><body package="Store-Merge" selector="standardText">standardText	"UIPainter new openOnClass: self andSelector: #standardText"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Standard Text' 			#bounds: #(#{Graphics.Rectangle} 732 464 1123 944 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #displayTextID 					#model: #displayText 					#tabRequiresControl: true ) ) ) )</body><body package="Store-Merge" selector="threeDifferencesText">threeDifferencesText	"UIPainter new openOnClass: self andSelector: #threeDifferencesText"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Vertical Differences' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 261 353 669 833 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 19 0 -103 0.5 0 1.0 ) 					#name: #textView 					#model: #valueHolder 					#menu: #textMenuHolder 					#tabRequiresControl: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 0 -4 ) 					#name: #firstChangeLabel 					#label: #changeLabel 					#style: #small ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} -100 0.5 20 0 0 0.684564 0 0.997917 ) 					#model: #secondTextAdaptor 					#menu: #secondTextMenuHolder 					#tabRequiresControl: true ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.684375 21 0 0 1.0 0 0.997917 ) 					#model: #thirdTextAdaptor 					#menu: #thirdTextMenuHolder 					#tabRequiresControl: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.337248 -3 0 ) 					#name: #secondChangeLabel 					#label: #imageLabel 					#style: #small ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.695312 -3 0 ) 					#name: #thirdChangeLabel 					#label: #imageLabel 					#style: #small ) ) ) )</body><body package="Store-Merge" selector="twoDifferencesText">twoDifferencesText	"UIPainter new openOnClass: self andSelector: #twoDifferencesText"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Merge Tool' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 560 432 1152 810 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 3 0 -3 0.5 -3 1 ) 					#name: #displayTextID 					#model: #displayText 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestFocusOutSelector: 						#validateTextOnExit: ) 					#tabRequiresControl: true ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.5 3 0 -3 1 -3 1 ) 					#name: #conflictTextID 					#model: #conflictText 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestFocusOutSelector: 						#validateTextOnExit: ) 					#tabRequiresControl: true ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -1 0.5 0 0 1 0.5 0 1 ) 					#name: #ResizingSplitter1 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: '#displayTextID' 					#belowWidgets: '#conflictTextID' ) ) ) )</body><body package="Store-Merge" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Merge Tool' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 477 250 1094 728 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 3 0 -3 0.5 -3 0.5 ) 					#name: #modSetListID 					#model: #modSetList 					#tabable: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.5 3 0 -3 1 -3 0.5 ) 					#name: #pkgListID 					#model: #pkgList 					#tabable: true 					#menu: #packageMenu 					#multipleSelections: true ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 3 0.5 -3 1 -3 1 ) 					#name: #textCanvas 					#minorKey: #standardText ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 -1 0.5 -3 1 1 0.5 ) 					#name: #ResizingSplitter1 					#horizontal: true 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: '#modSetListID #pkgListID' 					#belowWidgets: 'textCanvas' ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -1 0.5 0 0 1 0.5 0 0.5 ) 					#name: #ResizingSplitter2 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: '#modSetListID' 					#belowWidgets: '#pkgListID' ) ) ) )</body><body package="Store-Merge" selector="windowSpecSAVE">windowSpecSAVE	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Merge Tool' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 247 413 839 791 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.5 0 0.00552486 0 1 0 0.441989 ) 					#name: #pkgListID 					#model: #pkgList 					#tabable: true 					#menu: #packageMenu 					#multipleSelections: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 0.5 0 0.444751 ) 					#name: #modSetListID 					#model: #modSetList 					#tabable: true ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.00337838 0 0.453039 0 1.00169 0 1.0 ) 					#name: #displayTextID 					#model: #displayText 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestFocusOutSelector: 						#validateTextOnExit: ) 					#tabRequiresControl: true ) ) ) )</body></methods><methods><class-id>Store.PackageClassesBrowserHelper</class-id> <category>actions</category><body package="Store-UI-Browser" selector="addNameSpace">addNameSpace	&lt;menuItem: 'Add NameSpace'		icon: nil		nameKey: #addNameSpace		enablement: #isPackageLoaded		indication: nil		menu: #(#listMenu)		position: 20.01&gt;	self browser defType value: #showDefinition.	module deselect.	self browser text value: 		( self			templateNameSpace: self environment			category: self category		)</body><body package="Store-UI-Browser" selector="availableMethods">availableMethods	&lt;menuItem: 'Browse Methods No Longer In Class...'		nameKey: #availableMethods		enablement: #isDBConnected		indication: nil		menu: #(#listMenu)		position: 50.03&gt;	| target cls |	self dbManager doIfOnlineImage: 		[  target := self selection.		target isForNameSpace ifTrue: [ ^self ].		( cls := target actual ) == nil			ifTrue: [ ^Dialog warn: ( '&lt;1s&gt; not in the image' expandMacrosWith: target name ) ].		self spawningBrowserClass browseAvailableMethodsNamed: '*'  in: cls		].</body><body package="Store-UI-Browser" selector="browseVersions">browseVersions	&lt;menuItem: 'Browse Versions'		icon: nil		nameKey: #browseVersions		menu: #(#listMenu)		position: 50.02&gt;	self selection == nil ifTrue: [ ^self ].	self dbManager doIfOnlineImage: 		[  self spawningBrowserClass browseVersionsOfNamespaceOrClass: self selection ]</body><body package="Store-UI-Browser" selector="classesView">classesView	"Spawn a browser with the selected classes/namespaces in the first pane."	&lt;menuItem: 'Classes View...'		icon: nil		nameKey: #classesView		menu: #(#listMenu)		position: 10.08&gt;	self selections == nil ifTrue: [ ^self ].	self selection isLoaded 		ifFalse: [ self warnPackageNotLoaded. ^false ].	TabApplicationSystemBrowser openOnClassOrNameSpacesView: self selections.</body><body package="Store-UI-Browser" selector="compareWithImage">compareWithImage	&lt;menuItem: 'Compare with Image'		icon: nil		nameKey: #compareWithImage		enablement: #isSelectionUnloaded		indication: nil		menu: #(#listMenu)		position: 50.03&gt;	| sel |	( ( sel := self selection ) == nil or: [ sel isLoaded ] )		ifTrue: [ ^self ].	sel actual == nil		ifTrue: [ ^Dialog warn: sel fullName, ' does not exist in the image.' ].	ComparisonBrowser compareClass: sel toClass: ( PseudoRecord fromModel: sel ).</body><body package="Store-UI-Browser" selector="compareWithVersion">compareWithVersion	"Spawn a difference browser on the selected package and a selected version."	&lt;menuItem: 'Compare with...'		icon: nil		nameKey: #compareWithVersion		menu: #(#listMenu)		position: 50.03&gt;	self dbManager doIfOnlineImage: 		[ | trace |		trace := self selectVersion: self selection.		trace == nil 	ifTrue: [ ^self ].		ComparisonBrowser compareClass: self selection toClass: trace.		].</body><body package="Store-UI-Browser" selector="extendClass">extendClass	&lt;menuItem: 'Extend Class or NameSpace...'		icon: nil		nameKey: #extendClass		enablement: #isForPackage		indication: nil		menu: #(#listMenu)		position: 20.60&gt;	| something |	( something := self pickAClassOrNameSpace: 'Enther Class or NameSpace to extend' ) == nil		ifTrue: [ ^self ].	self package modelAtFullSymbol: something absoluteSymbol hasDefinition: false.	self updateListFull.</body><body package="Store-UI-Browser" selector="findPackage">findPackage	&lt;menuItem: 'Containing package...'		icon: nil		nameKey: #findPackage		menu: #(#listMenu)		position: 50.08&gt;	| sel |	( sel := self selection ) == nil ifTrue: [ ^self ].	( sel isLoaded not and: [ sel isPseudo ] )		ifTrue: [ ^Dialog warn: 'Version is unknown' ].	self showPackageList: sel containingPackages loaded: self isPackageLoaded.</body><body package="Store-UI-Browser" selector="initializeSelections">initializeSelections	"Any of the selections which may be initialized will be initialized here."	&lt;menuItem: 'Initialize'		nameKey: #initializeSelections		enablement: #isPackageLoaded		indication: nil		menu: #(#listMenu)		position: 30.038 &gt;	self selections do: 		[ :selection |		selection isForClass				ifTrue: [ selection actual instanceBehavior initialize ]		]</body><body package="Store-UI-Browser" selector="loadSelection">loadSelection	&lt;menuItem: 'Load...'		icon: nil		nameKey: #loadSelection		enablement: #isSelectionUnloaded		indication: nil		menu: #(#listMenu)		position: 50.01&gt;	| sel pkg |	( sel  := self selection ) == nil		ifTrue: [ ^self ].	sel isLoaded ifTrue: [ ^Dialog warn: 'Selected version already loaded.' ].	sel isPseudo ifTrue: [ ^Dialog warn: 'Package does not contain the selected definition.' ].	pkg := sel package == nil		ifTrue: [ sel containingPackages last ]		ifFalse: [ sel package ].	self load: sel fromPackage: pkg.</body><body package="Store-UI-Browser" selector="moveAllToPackage">moveAllToPackage	&lt;menuItem: 'Move all to package...'		icon: nil		nameKey: #moveAllToPackage		menu: #(#listMenu)		position: 50.05&gt;	| newpackage |	self changeRequest ifFalse: [ ^self ].	self selections isEmpty ifTrue: [ ^self ].	( newpackage := PackageChooser chooseOrAdd ) == nil		ifTrue: [ ^self ].	self selections do:		[ :selection | 		XChangeSet current moveWholeObject: selection actual toPackage: newpackage.		].	module updateList.</body><body package="Store-UI-Browser" selector="moveDefinitionToPackage">moveDefinitionToPackage	&lt;menuItem: 'Move definition to package...'		icon: nil		nameKey: #moveDefinitionToPackage		menu: #(#listMenu)		position: 50.06&gt;	| newpackage |	self changeRequest ifFalse: [ ^self ].	self selections isEmpty ifTrue: [ ^self ].	( newpackage := PackageChooser chooseOrAdd ) == nil		ifTrue: [ ^self ].	self selections do:		[ :selection | 		XChangeSet current moveDefinition: selection actual toPackage: newpackage.		].	module updateList.</body><body package="Store-UI-Browser" selector="moveToPackage">moveToPackage	&lt;menuItem: 'Move package to package...'		icon: nil		nameKey: #moveToPackage		enablement: #isSelectionLoaded		indication: nil		menu: #(#listMenu)		position: 50.04&gt;	| newpackage |	self selections isEmpty ifTrue: [ ^self ].	self isForPackage		ifFalse: [ ^Dialog warn: 'Can not move from a bundle.' ].	self package isLoaded 		ifFalse: [ ^Dialog warn: 'Cannot edit database packages.' ].	self changeRequest ifFalse: [ ^self ].	( newpackage := PackageChooser chooseOrAdd ) == nil		ifTrue: [ ^self ].	self selections do:		[ :selection | 		XChangeSet current 			moveObject: selection actual instanceBehavior 			from: self package to: newpackage.		].	module updateList.</body><body package="Store-UI-Browser" selector="removeEmpty">removeEmpty	&lt;menuItem: 'Remove Empty Classes and NameSpaces'		icon: nil		nameKey: #removeEmtpy		enablement: #isForPackage		indication: nil		menu: #(#listMenu)		position: 20.70&gt;	self package removeEmptyModels.	self updateListFull.</body></methods><methods><class-id>Store.PackageClassesVersionBrowserHelper class</class-id> <category>resources</category><body package="Store-UI-Browser" selector="listMenu">listMenu	"MenuEditor new openOnClass: self andSelector: #listMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'File out as...' 				#nameKey: #fileOut 				#value: #fileOut ) 			#(#{UI.MenuItem} 				#rawLabel: 'Hardcopy' 				#nameKey: #hardcopy 				#value: #hardcopy ) 			#(#{UI.MenuItem} 				#rawLabel: 'Spawn' 				#nameKey: #spawn 				#value: #spawn ) 			#(#{UI.MenuItem} 				#rawLabel: 'Spawn hierarchy' 				#nameKey: #spawnHierarchy 				#value: #spawnHierarchy ) ) #(4 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.BundleDifferenceBrowser class</class-id> <category>interface specs</category><body package="Store-UI-Comparitors" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Bundle Difference Browser' 			#min: #(#Point 50 50 ) 			#bounds: #(#Rectangle 475 262 1109 741 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#InputFieldSpec 					#layout: #(#LayoutFrame 2 0 0 0 0 0.5 30 0 ) 					#model: #bundle1name 					#tabable: false 					#alignment: #center 					#isReadOnly: true 					#type: #string ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 2 0.5 0 0 0 1 30 0 ) 					#model: #bundle2name 					#tabable: false 					#alignment: #center 					#isReadOnly: true 					#type: #string ) 				#(#TextEditorSpec 					#layout: #(#LayoutFrame 2 0 32 0 0 0.5 -40 1 ) 					#name: #text1Widget 					#model: #text1 					#menu: #customTextMenu ) 				#(#TextEditorSpec 					#layout: #(#LayoutFrame 2 0.5 32 0 0 1 -40 1 ) 					#name: #text2Widget 					#model: #text2 					#menu: #customTextMenu ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -251 1 -36 1 -95 1 -3 1 ) 					#model: #comparePackages 					#label: 'Compare Packages' 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -85 1 -36 1 -15 1 -3 1 ) 					#model: #closeRequest 					#label: 'Close' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Store.GroupGraph class</class-id> <category>interface specs</category><body package="Store-UI-Graphs" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'User Groups' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 310 212 843 652 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 229 0 -1 1 0 1 ) 					#name: #graphView 					#flags: 0 					#majorKey: #LensGraphView 					#minorKey: #windowSpec 					#clientKey: #graphView ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 70 0.5 30 0 -3 1 220 0 ) 					#name: #userListID 					#model: #userList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #listChange ) ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 30 0 -70 0.5 220 0 ) 					#name: #groupListID 					#model: #groupList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #listChange ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 80 0.5 8 0 ) 					#label: 'Group Member:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 3 8 ) 					#label: 'Group:' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -60 0.5 42 0 60 0.5 77 0 ) 					#name: #addToGroup 					#model: #addToGroup 					#label: 'Add' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -60 0.5 75 0 60 0.5 110 0 ) 					#name: #removeFromGroup 					#model: #removeFromGroup 					#label: 'Remove' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -60 0.5 146 0 60 0.5 181 0 ) 					#name: #newUser 					#model: #newUser 					#label: 'New User...' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -60 0.5 179 0 60 0.5 214 0 ) 					#name: #newGroup 					#model: #newGroup 					#label: 'New Group...' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Store.GroupGraph class</class-id> <category>resources</category><body package="Store-UI-Graphs" selector="menuBarSkeleton">menuBarSkeleton	"UIMenuEditor new openOnClass: self andSelector: #menuBarSkeleton"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#label: 'File' 				#accessCharacterPosition: 1 				#submenu: #(#Menu #(						#(#MenuItem 							#label: 'Exit' 							#accessCharacterPosition: 2 ) ) #(1 ) #(#closeRequest ) ) ) ) #(1 ) #(nil ) ) decodeAsLiteralArray</body></methods><methods><class-id>Store.PrivilegeGraph class</class-id> <category>interface specs</category><body package="Store-UI-Graphs" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'User / Group Privliges' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 700 525 1233 965 ) 			#flags: 4 			#menu: #menuBar 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 70 0.5 30 0 -3 1 220 0 ) 					#name: #packageID 					#model: #packageList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #listChange 						#requestValueChangeSelector: #listChange ) 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 30 0 -70 0.5 220 0 ) 					#name: #userGroupListID 					#model: #userGroupList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #listChange ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 70 0.5 8 0 ) 					#name: #pundleLabel 					#label: 'Package:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 3 8 ) 					#name: #Label2 					#label: 'User/Group:' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -60 0.5 37 0 60 0.5 72 0 ) 					#name: #assignOwner 					#model: #assignOwner 					#label: 'Make Owner' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -60 0.5 84 0 60 0.5 119 0 ) 					#name: #grantRead 					#model: #grantRead 					#label: 'Grant Read' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -60 0.5 131 0 60 0.5 166 0 ) 					#name: #grantPublish 					#model: #grantPublish 					#label: 'Grant Publish' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -60 0.5 178 0 60 0.5 213 0 ) 					#name: #revokeRights 					#model: #revokeRights 					#label: 'Revoke Rights' 					#defaultable: true ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 7 0 227 0 -3 1 0 0.978972 ) 					#name: #privilegeText 					#model: #privilegeText 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>Store.PrivilegeGraph class</class-id> <category>resources</category><body package="Store-UI-Graphs" selector="menuBarSkeleton">menuBarSkeleton	"UIMenuEditor new openOnClass: self andSelector: #menuBarSkeleton"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#label: 'File' 				#accessCharacterPosition: 1 				#submenu: #(#Menu #(						#(#MenuItem 							#label: 'Exit' 							#accessCharacterPosition: 2 ) ) #(1 ) #(#closeRequest ) ) ) ) #(1 ) #(nil ) ) decodeAsLiteralArray</body></methods><methods><class-id>Store.PackageMethodsBrowserHelper</class-id> <category>menus</category><body package="Store-UI-Browser" selector="browseImageVersions">browseImageVersions	&lt;menuItem: 'Browse Image Versions...'		icon: nil		nameKey: #browseImageVersions		menu: #(#listMenu)		position: 50.02&gt;	| sel |	( sel := self selection ) == nil		ifTrue: [ ^self ].	sel isForMethod ifFalse: [ ^self ].	ChangeList new openOn: 		( ChangeScanner scanForSelector: sel selector class: sel owner )</body><body package="Store-UI-Browser" selector="browseVersions">browseVersions	&lt;menuItem: 'Browse Versions...'		icon: nil		nameKey: #browseVersions		menu: #(#listMenu)		position: 50.01&gt;	self selection == nil		ifTrue: [ ^self ].	DbRegistry doIfOnlineImage: 		[ self spawningBrowserClass browseVersionsOfMethodOrStatic: self selection ].</body><body package="Store-UI-Browser" selector="compareWithImage">compareWithImage	&lt;menuItem: 'Compare with image'		icon: nil		nameKey: #compareWithImage		menu: #(#listMenu)		position: 50.04&gt;	self selection == nil		ifTrue: [ ^self ].	DbRegistry doIfOnlineImage:  		[  self selection isLoaded 			ifTrue: [ ^Dialog warn: 'Selection already loaded.' ].		ComparisonBrowser compareMethod: self selection toMethod: self selection asDescriptor.		].</body><body package="Store-UI-Browser" selector="compareWithVersion">compareWithVersion	"Spawn a difference browser on the selected package and a selected version."	&lt;menuItem: 'Compare with...'		icon: nil		nameKey: #compareWithVersion		menu: #(#listMenu)		position: 50.05&gt;	self dbManager doIfOnlineImage: 		[ | trace |		trace := self selectVersion: self selection.		trace == nil 	ifTrue: [ ^self ].		ComparisonBrowser compareMethod: self selection toMethod: trace.		].</body><body package="Store-UI-Browser" selector="findPackage">findPackage	&lt;menuItem: 'Containing package'		icon: nil		nameKey: #findPackage		enablement: nil		indication: nil		menu: #(#listMenu)		position: 60.05&gt;	| pkgs sel |	( sel := self selection ) == nil		ifTrue: [ ^self ].	pkgs := sel containingPackages.	self showPackageList: pkgs loaded:  self isPackageLoaded.</body><body package="Store-UI-Browser" selector="inspectData">inspectData	&lt;menuItem: 'Inspect Shared Variable'		nameKey: #inspectData		enablement: #selectionIsforData		indication: nil		menu: #(#listMenu)		position: 30.06&gt;	self selection == nil ifTrue: [ ^self ].	self selection isLoaded		ifFalse: [  ^self warnPackageNotLoaded ].	( self selection nameSpace bindingFor: self selection dataKey ) inspect</body><body package="Store-UI-Browser" selector="loadSelection">loadSelection	&lt;menuItem: 'Load...'		icon: nil		nameKey: #loadSelection		enablement: #isSelectionUnloaded		indication: nil		menu: #(#listMenu)		position: 50.06&gt;	( ( self selections isEmpty )  |  ( self package == nil ) )		ifTrue: [ ^self ].	self isForPackage 		ifFalse: [ ^Dialog warn: 'You must select the package being loaded.' ].	DbRegistry doIfOnlineImage:  		[  self package isLoaded 			ifTrue: [ ^Dialog warn: 'Selection already loaded.' ].		self loadList: self selections.		].</body><body package="Store-UI-Browser" selector="moveToPackage">moveToPackage	&lt;menuItem: 'Move to Package...'		nameKey: #moveToPackage		enablement: #isPackageLoaded		indication: nil		menu: #(#listMenu)		position: 60.01&gt;	| pkg |	self changeRequest ifFalse: [ ^self ].	self selection isLoaded		ifFalse: [ ^Dialog warn: 'Current selection is not loaded.' ].	( pkg := PackageChooser chooseOrAdd ) == nil		 ifTrue: [ ^false ].	self selections do:		[ :sel |		sel isForData			ifTrue: [ XChangeSet current moveDataKey: sel dataKey owner: sel owner toPackage: pkg ]			ifFalse: [ XChangeSet current moveSelector: sel selector class: sel myClass toPackage: pkg ].		].	module updateList.</body><body package="Store-UI-Browser" selector="openResourceEditor">openResourceEditor	&lt;menuItem: 'Edit Resource'		nameKey: #openResourceEditor		menu: #(#listMenu)		position: 35.1&gt;	self isData ifTrue: [ ^nil ].	^super openResourceEditor</body><body package="Store-UI-Browser" selector="revert">revert	&lt;menuItem: 'Revert...'		nameKey: #revertToPreviousVersion		enablement: #areConnectedAndLoaded		indication: nil		menu: #(#listMenu)		position: 50.08&gt;	( ( self selections isEmpty )  |  ( self package == nil ) )		ifTrue: [ ^self ].	self changeRequest ifFalse: [ ^self ].	self selection isLoaded		ifFalse: [ ^Dialog warn: 'The parent is not known. Please browse versions and select one to load.' ].	DbRegistry doIfOnlineImage:  		[  (Dialog confirm: 'Do you want to replace this with the stored version?') 			ifFalse: [ ^self ].		self selection isForData			ifTrue: [ XChangeSet current revertData: self selection dataKey owner: self selection owner ]			ifFalse: [ XChangeSet current revertSelector: self selection selector class: self selection myClass ].		module updateList.		].</body></methods><methods><class-id>Store.PackageMethodsEditorHelper class</class-id> <category>resources</category><body package="Store-UI-Browser" selector="listMenu">listMenu	"MenuEditor new openOnClass: self andSelector: #listMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'Remove From Package' 				#nameKey: #removeFromPackage 				#value: #removeFromPackage ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.BundleTabApplication class</class-id> <category>resources</category><body package="Store-UI-Browser" selector="packageIcon">packageIcon	"UIMaskEditor new openOnClass: self andSelector: #packageIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 24@24 depth: 1 bitsPerPixel: 1 palette: (Core.MappedPalette withColors: ((Core.Array new: 2) at: 1 put: Graphics.ColorValue white; at: 2 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4227); yourself)) usingBits: #[0 0 0 0 0 0 0 0 0 31 248 0 0 31 248 0 15 255 248 0 15 255 248 0 12 31 248 0 12 31 248 0 12 31 248 0 12 31 248 0 12 0 48 0 12 0 48 0 12 0 48 0 12 0 48 0 12 0 48 0 15 255 240 0 15 255 240 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body></methods><methods><class-id>Store.PackageVersionBrowserHelper</class-id> <category>actions</category><body package="Store-UI-Browser" selector="reconcile">reconcile	&lt;menuItem: 'Reconcile image with selection'		icon: nil		nameKey: #reconcile		menu: #(#listMenu)		position: 10.28&gt;	| dbVersion imgVersion |	( dbVersion := self selection ) == nil		ifTrue: [ ^self ].	( imgVersion := dbVersion getImagePundle ) == nil		ifTrue: [ ^Dialog warn: 'There is no image version to reconcile.' ].		imgVersion reconcileWithDbVersion: dbVersion</body><body package="Store-UI-Browser" selector="republish">republish	&lt;menuItem: 'Republish Bundle...'		icon: nil		nameKey: #republish		enablement: #isForBundle		indication: nil		menu: #(#listMenu)		position: 10.25&gt;	RepublishBundleDialog republishBundle: self selection</body></methods><methods><class-id>Store.PackageVersionBrowserHelper class</class-id> <category>resources</category><body package="Store-UI-Browser" selector="listMenu">listMenu	"MenuEditor new openOnClass: self andSelector: #listMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'File out...' 				#nameKey: #fileOutPackages 				#value: #fileOutPackages ) 			#(#{UI.MenuItem} 				#rawLabel: 'File out differences...' 				#nameKey: #fileOutDifferences 				#value: #fileOutDifferences ) 			#(#{UI.MenuItem} 				#rawLabel: 'Graph versions' 				#nameKey: #graphVersions 				#value: #graphVersions ) 			#(#{UI.MenuItem} 				#rawLabel: 'Compare with Parent' 				#nameKey: #diffPackageWithParent 				#value: #diffPackageWithParent ) 			#(#{UI.MenuItem} 				#rawLabel: 'Compare with...' 				#nameKey: #diffWithVersion 				#value: #diffWithVersion ) 			#(#{UI.MenuItem} 				#rawLabel: 'Browse' 				#nameKey: #spawn 				#value: #spawn ) 			#(#{UI.MenuItem} 				#rawLabel: 'Enclosing bundles' 				#nameKey: #enclosingComponents 				#value: #enclosingComponents ) 			#(#{UI.MenuItem} 				#rawLabel: 'Properties...' 				#nameKey: #packageProperties 				#value: #packageProperties ) ) #(2 3 1 2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.UnloadableExeceptionBrowserHelper class</class-id> <category>resources</category><body package="Store-UI-Browser" selector="listMenu">listMenu	"MenuEditor new openOnClass: self andSelector: #listMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'Load' 				#nameKey: #loadDefinition 				#value: #loadDefinition ) 			#(#{UI.MenuItem} 				#rawLabel: 'Remove From Package' 				#nameKey: #removeFromPackage 				#value: #removeFromPackage ) 			#(#{UI.MenuItem} 				#rawLabel: 'Fileout....' 				#nameKey: #fileOut 				#value: #fileOut ) 			#(#{UI.MenuItem} 				#rawLabel: 'Browse Versions' 				#nameKey: #browseVersions 				#value: #browseVersions ) 			#(#{UI.MenuItem} 				#rawLabel: 'Help....' 				#nameKey: #help 				#value: #help ) ) #(3 1 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.VersionGraph class</class-id> <category>interface specs</category><body package="Store-UI-Graphs" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Version Graph' 			#min: #(#Point 589 194 ) 			#bounds: #(#Rectangle 412 517 1001 819 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#SubCanvasSpec 					#layout: #(#LayoutFrame 0 0 0 0 0 1 0 1 ) 					#name: #graphView 					#flags: 0 					#majorKey: #'LensGraphView' 					#minorKey: #windowSpec 					#clientKey: #graphView ) ) ) )</body></methods><methods><class-id>Store.VersionGraph class</class-id> <category>resources</category><body package="Store-UI-Graphs" selector="menuBarSkeleton">menuBarSkeleton	"UIMenuEditor new openOnClass: self andSelector: #menuBarSkeleton"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#label: 'File' 				#accessCharacterPosition: 1 				#submenu: #(#Menu #(						#(#MenuItem 							#label: 'Load...' 							#accessCharacterPosition: 1 ) 						#(#MenuItem 							#label: 'Merge' 							#accessCharacterPosition: 1 ) 						#(#MenuItem 							#label: 'Set Blessing Level' ) 						#(#MenuItem 							#label: 'File Out...' 							#accessCharacterPosition: 1 ) 						#(#MenuItem 							#label: 'File Out Differences...' ) 						#(#MenuItem 							#label: 'Update' ) 						#(#MenuItem 							#label: 'Exit' 							#accessCharacterPosition: 2 ) ) #(2 1 2 1 1 ) #(#loadPundle #mergePundleVersion #setBlessingLevel #fileOutPundle #fileOutTwoPundleDiff #reloadVersions #closeRequest ) ) ) 			#(#MenuItem 				#label: 'Examine' 				#submenu: #(#Menu #(						#(#MenuItem 							#label: 'Browse' ) 						#(#MenuItem 							#label: 'List Contents' ) 						#(#MenuItem 							#label: 'List Versions' ) 						#(#MenuItem 							#label: 'Compare with Image' ) 						#(#MenuItem 							#label: 'Compare with Parent' ) 						#(#MenuItem 							#label: 'Compare Versions' ) ) #(2 1 3 ) #(#browsePackageVersion #listBundleContents #browseVersions #diffPundleWithImage #diffPundleWithParent #diffTwoPundles ) ) ) 			#(#MenuItem 				#label: 'Graph' 				#submenu: #(#Menu #(						#(#MenuItem 							#label: 'Open One Out' ) 						#(#MenuItem 							#label: 'Open One In' ) 						#(#MenuItem 							#label: 'Open Four Out' ) 						#(#MenuItem 							#label: 'Open Four In' ) 						#(#MenuItem 							#label: 'Open All Out' ) 						#(#MenuItem 							#label: 'Open All In' ) ) #(2 2 2 ) #(#openOneOut #openOneIn #open4Out #open4In #openAllOut #openAllIn ) ) ) ) #(3 ) #(nil nil nil ) ) decodeAsLiteralArray</body></methods><methods><class-id>Store.PackageMethodsVersionBrowserHelper</class-id> <category>menus</category><body package="Store-UI-Browser" selector="findPackage">findPackage	&lt;menuItem: 'Containing packages...'		icon: nil		nameKey: #findPackage		enablement: nil		indication: nil		menu: #(#listMenu)		position: 60.05&gt;	| packages sel browser |	( sel := self selection ) == nil		ifTrue: [ ^self ].	packages := sel containingPackages.	packages isEmpty		ifTrue: [ ^Dialog warn: 'No package in the database owns this method.' ].	browser := self spawningBrowserClass browsePundleVersions: packages.	browser builder window label: ( 'Packages containing &lt;1s&gt;' expandMacrosWith: sel fullDisplayString )</body><body package="Store-UI-Browser" selector="loadSelection">loadSelection	&lt;menuItem: 'Load...'		icon: nil		nameKey: #loadSelection		menu: #(#listMenu)		position: 50.06&gt;	| sel pkg owner |	( sel := self selection ) == nil		ifTrue: [ ^self ].	sel isLoaded 		ifTrue: [ ^Dialog warn: 'Selection already loaded.' ].	owner := sel isForMethod		ifTrue: [ sel implementingClass ]		ifFalse: [ sel owner ].	owner == nil		ifTrue: [ ^Dialog warn: ( 'Cannot load because &lt;1s&gt; is not loaded.'										expandMacrosWith: sel ownerName ) ].	pkg := self choosePackage: ( Registry packagesContaining: owner ).	pkg == nil		ifTrue: [ ^self ].	DbRegistry doIfOnlineImage: [ sel loadSrcInto: pkg ].</body></methods><methods><class-id>Store.PackageMethodsVersionBrowserHelper class</class-id> <category>resources</category><body package="Store-UI-Browser" selector="listMenu">listMenu	"MenuEditor new openOnClass: self andSelector: #listMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'File out as...' 				#nameKey: #fileOut 				#value: #fileOut ) 			#(#{UI.MenuItem} 				#rawLabel: 'Hardcopy' 				#nameKey: #hardcopy 				#value: #hardcopy ) 			#(#{UI.MenuItem} 				#rawLabel: 'Spawn' 				#nameKey: #spawn 				#value: #spawn ) ) #(3 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.ComparisonBrowser class</class-id> <category>interface specs</category><body package="Store-UI-Comparitors" selector="windowSpec0">windowSpec0	"UIPainter new openOnClass: self andSelector: #windowSpec0"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #windowLabel 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 325 275 879 674 ) 			#flags: 4 			#menu: #menuBar 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 0.5 0 1 ) 					#name: #text1 					#model: #text1 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#textAccepted: ) 					#menu: #textMenu 					#isReadOnly: false ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.5 0 0 0 1 0 1 ) 					#name: #text2 					#model: #text2 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#textAccepted2: ) 					#menu: #textMenu 					#isReadOnly: false ) ) ) )</body><body package="Store-UI-Comparitors" selector="windowSpec2">windowSpec2	"UIPainter new openOnClass: self andSelector: #windowSpec2"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #windowLabel 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 800 600 1354 999 ) 			#flags: 4 			#menu: #menuBar 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 0.5 0 0.384798 ) 					#flags: 0 					#minorKey: #list1 					#clientKey: #component1 ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.5 0 0 0 1 0 0.384798 ) 					#flags: 0 					#minorKey: #list2 					#clientKey: #component2 ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0.453682 0 0.5 0 1 ) 					#name: #text1 					#model: #text1 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#textAccepted: ) 					#menu: #textMenu 					#isReadOnly: false 					#tabRequiresControl: true ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.5 0 0.453682 0 1 0 1 ) 					#name: #text2 					#model: #text2 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#textAccepted2: ) 					#menu: #textMenu 					#isReadOnly: false 					#tabRequiresControl: true ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 15 0 -27 0.453682 100 0 -4 0.453682 ) 					#name: #instanceButton 					#model: #meta 					#label: 'instance' 					#select: #instance ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 129 0 -27 0.453682 200 0 -4 0.453682 ) 					#name: #classButton 					#model: #meta 					#label: 'class' 					#select: #class ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 225 0 -27 0.453682 375 0 -4 0.453682 ) 					#name: #dataButton 					#model: #meta 					#label: 'shared variables' 					#select: #data ) ) ) )</body><body package="Store-UI-Comparitors" selector="windowSpec3">windowSpec3	"UIPainter new openOnClass: self andSelector: #windowSpec3"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #windowLabel 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 380 213 934 612 ) 			#flags: 4 			#menu: #menuBar 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.00180505 0 0 0 0.341155 0 0.457364 ) 					#flags: 0 					#minorKey: #list1 					#clientKey: #component1 ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.33213 0 0 0 0.669675 0 0.100775 ) 					#flags: 0 					#minorKey: #list2 					#clientKey: #component2 ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.669675 0 0 0 1.0 0 0.452196 ) 					#flags: 0 					#minorKey: #list3 					#clientKey: #component3 ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 -0.00180505 0 0.452196 0 0.498195 0 1.00775 ) 					#name: #text1 					#model: #text1 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#textAccepted: ) 					#menu: #textMenu 					#isReadOnly: false ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.33574 0 0.103359 0 0.67148 0 0.452196 ) 					#flags: 0 					#minorKey: #list5 					#clientKey: #component5 ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.49639 0 0.452196 0 1.0 0 1.00775 ) 					#name: #text2 					#model: #text2 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#textAccepted2: ) 					#menu: #textMenu 					#isReadOnly: false ) ) ) )</body><body package="Store-UI-Comparitors" selector="windowSpec3NEW">windowSpec3NEW	"UIPainter new openOnClass: self andSelector: #windowSpec3"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #windowLabel 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 380 213 934 612 ) 			#flags: 4 			#menu: #menuBar 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.00180505 0 0 0 0.341155 0 0.457364 ) 					#flags: 0 					#minorKey: #list1 					#clientKey: #component1 ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.33213 0 0 0 0.669675 0 0.100775 ) 					#flags: 0 					#minorKey: #list2 					#clientKey: #component2 ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.669675 0 0 0 1.0 0 0.452196 ) 					#flags: 0 					#minorKey: #list3 					#clientKey: #component3 ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 -0.00180505 0 0.452196 0 0.498195 0 1.00775 ) 					#name: #text1 					#model: #text1 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#textAccepted: ) 					#menu: #textMenu 					#isReadOnly: false ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.33574 0 0.103359 0 0.67148 0 0.452196 ) 					#flags: 0 					#minorKey: #list5 					#clientKey: #component5 ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.49639 0 0.452196 0 1.0 0 1.00775 ) 					#name: #text2 					#model: #text2 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#textAccepted: ) 					#menu: #textMenu 					#isReadOnly: false ) ) ) )</body><body package="Store-UI-Comparitors" selector="windowSpec3x3">windowSpec3x3	"UIPainter new openOnClass: self andSelector: #windowSpec3"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #windowLabel 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 235 185 789 584 ) 			#flags: 4 			#menu: #menuBar 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{UI.LayoutFrame} 0 0.00180505 0 0 0 0.330325 0 0.219638 ) 					#flags: 0 					#minorKey: #list1 					#clientKey: #component1 ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{UI.LayoutFrame} 0 0.33213 0 0.0 0 0.66787 0 0.219638 ) 					#flags: 0 					#minorKey: #list2 					#clientKey: #component2 ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{UI.LayoutFrame} 0 0.66787 0 0.0 0 1.0 0 0.219638 ) 					#flags: 0 					#minorKey: #list3 					#clientKey: #component3 ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{UI.LayoutFrame} 0 -0.00180505 0 0.452196 0 0.498195 0 1.00775 ) 					#name: #text1 					#model: #text1 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#textAccepted: ) 					#menu: #textMenu 					#isReadOnly: false ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{UI.LayoutFrame} 0 0.00180505 0 0.219638 0 0.330325 0 0.452196 ) 					#flags: 0 					#minorKey: #list4 					#clientKey: #component4 ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{UI.LayoutFrame} 0 0.33574 0 0.219638 0 0.67148 0 0.452196 ) 					#flags: 0 					#minorKey: #list5 					#clientKey: #component5 ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{UI.LayoutFrame} 0 0.67148 0 0.219638 0 1.00361 0 0.452196 ) 					#flags: 0 					#minorKey: #list6 					#clientKey: #component6 ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{UI.LayoutFrame} 0 0.49639 0 0.452196 0 1.0 0 1.00775 ) 					#name: #text2 					#model: #text2 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#textAccepted: ) 					#menu: #textMenu 					#isReadOnly: false ) ) ) )</body></methods><methods><class-id>Store.ComparisonBrowser class</class-id> <category>resources</category><body package="Store-UI-Comparitors" selector="viewMenu">viewMenu	"MenuEditor new openOnClass: self andSelector: #viewMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'Show All' 				#nameKey: #showAll 				#value: #showAll ) 			#(#{UI.MenuItem} 				#rawLabel: 'Show Conflicts' 				#nameKey: #showConflicts 				#value: #showConflicts ) 			#(#{UI.MenuItem} 				#rawLabel: 'Show Source Differences' 				#nameKey: #showSourceDifferences 				#value: #showSourceDifferences ) 			#(#{UI.MenuItem} 				#rawLabel: 'Show Code Differences' 				#nameKey: #showCodeDifferences 				#value: #showCodeDifferences ) ) #(2 2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.MiniRepositoryManager class</class-id> <category>resources</category><body package="Store-UI" selector="repositoryMenu">repositoryMenu	"Tools.MenuEditor new openOnClass: self andSelector: #repositoryMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: '&amp;New...' 				#nameKey: #repositoryNew 				#value: #repositoryNew ) 			#(#{UI.MenuItem} 				#rawLabel: '&amp;Properties...' 				#nameKey: #repositoryProperties 				#value: #repositoryProperties 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #properties ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'Pu&amp;blished Items' 				#nameKey: #repositoryPublishedItems 				#value: #repositoryPublishedItems ) 			#(#{UI.MenuItem} 				#rawLabel: '&amp;More Recent Items' 				#nameKey: #repositoryMoreRecentlyPublishedItems 				#value: #repositoryMoreRecentlyPublishedItems ) 			#(#{UI.MenuItem} 				#rawLabel: '&amp;Load...' 				#nameKey: #repositoryLoad 				#value: #repositoryLoad 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileOpen ) ) 			#(#{UI.MenuItem} 				#rawLabel: '&amp;Save...' 				#nameKey: #repositoryLoad 				#value: #repositorySave 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileSave ) ) 			#(#{UI.MenuItem} 				#rawLabel: '&amp;Open Repository Manager' 				#nameKey: #openRepositoryManager 				#value: #openRepositoryManager 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #store ) ) ) #(1 3 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.MiniRepositoryManager class</class-id> <category>interface specs</category><body package="Store-UI" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 512 384 712 584 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 					#layout: #(#{Graphics.Rectangle} 0 -1 21 23 ) 					#name: #storeIcon 					#label: #storeIcon 					#hasCharacterOrientedLabel: false ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 20 0 0 0 0 1 21 0 ) 					#name: #label 					#flags: 0 					#model: #labelHolder 					#helpText: 'Store repositories. Left-click to connect, right-click to manage.' 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>Store.PundleComponent class</class-id> <category>interface specs</category><body package="Store-UI" selector="pundleComponentSpec">pundleComponentSpec	"Tools.UIPainter new openOnClass: self andSelector: #pundleComponentSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Published Items' 			#bounds: #(#{Graphics.Rectangle} 512 384 745 746 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #pundleSubcanvas 					#flags: 0 					#clientKey: #pundleModule ) ) ) )</body></methods><methods><class-id>Store.UISettings class</class-id> <category>interface specs</category><body package="Store-UI" selector="binaryLoadSpec">binaryLoadSpec	"UIPainter new openOnClass: self andSelector: #binaryLoadSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#min: #(#{Core.Point} 50 50 ) 			#bounds: #(#{Graphics.Rectangle} 576 432 833 692 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Core.Point} 10 240 ) 					#name: #acceptButton 					#flags: 40 					#model: #binaryLoadAccept 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#tabable: true 					#label: 'Accept' 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Core.Point} 101 240 ) 					#name: #resetButton 					#flags: 40 					#model: #binaryLoadReset 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#tabable: true 					#label: 'Reset' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Core.Point} 185 240 ) 					#model: #helpAction 					#tabable: true 					#label: 'Help' 					#defaultable: true ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 8 0 3 0 -8 1 96 0 ) 					#label: 'Binary Loading' ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 30 33 ) 					#model: #allowBinaryLoadingEditing 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#label: 'Allow binary loading' 					#select: true ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 30 59 ) 					#model: #allowBinaryLoadingEditing 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#label: 'Never load binary' 					#select: false ) ) ) )</body><body package="Store-UI" selector="databaseSpec">databaseSpec	"UIPainter new openOnClass: self andSelector: #databaseSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#min: #(#{Core.Point} 274 270 ) 			#bounds: #(#{Graphics.Rectangle} 640 512 914 782 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Core.Point} 10 240 ) 					#name: #acceptButton 					#flags: 40 					#model: #databaseAccept 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: 'Accept' 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Core.Point} 101 240 ) 					#name: #resetButton 					#flags: 40 					#model: #databaseReset 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: 'Reset' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Core.Point} 185 240 ) 					#model: #helpAction 					#label: 'Help' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 13 86 ) 					#label: 'Database table owner:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 13 151 ) 					#label: 'Parcel Directory:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 13 0 111 0 -111 1 132 0 ) 					#model: #tablePrefix 					#menu: #fieldMenu 					#isReadOnly: true 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 13 0 180 0 -15 1 201 0 ) 					#model: #packageDirEditing 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#menu: #fieldMenu 					#type: #string ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 13 24 ) 					#label: 'Database Identifier:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 13 49 163 70 ) 					#model: #databaseIdentifier 					#menu: #fieldMenu 					#isReadOnly: true ) ) ) )</body><body package="Store-UI" selector="fileoutOptionSpec">fileoutOptionSpec	"UIPainter new openOnClass: self andSelector: #fileoutOptionSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#min: #(#{Core.Point} 50 50 ) 			#bounds: #(#{Graphics.Rectangle} 429 137 686 397 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.0505837 0 0.853846 ) 					#name: #acceptButton 					#flags: 40 					#model: #fileoutOptionAccept 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#tabable: true 					#label: 'Accept' 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.412451 0 0.853846 ) 					#name: #resetButton 					#flags: 40 					#model: #fileoutOptionReset 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#tabable: true 					#label: 'Reset' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.731517 0 0.853846 ) 					#model: #helpAction 					#tabable: true 					#label: 'Help' 					#defaultable: true ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0428016 0 0.0307692 0 0.968872 0 0.488461 ) 					#label: 'Include Package Information Fileout Option' ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.105058 0 0.130769 ) 					#model: #fileoutOptionEditing 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#label: 'Never' 					#select: #never ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.105058 0 0.242308 ) 					#model: #fileoutOptionEditing 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#label: 'Package fileouts Only' 					#select: #storeOnly ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.105058 0 0.353846 ) 					#model: #fileoutOptionEditing 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#label: 'All Fileouts' 					#select: #always ) ) ) )</body><body package="Store-UI" selector="newClassSpec">newClassSpec	"UIPainter new openOnClass: self andSelector: #newClassSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Unlabeled Canvas' 			#min: #(#Point 50 50 ) 			#bounds: #(#Rectangle 236 399 493 659 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#ActionButtonSpec 					#layout: #(#Point 10 240 ) 					#name: #acceptButton 					#flags: 40 					#model: #newClassAccept 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #undisturb ) 					#tabable: true 					#label: 'Accept' 					#isDefault: true 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Point 101 240 ) 					#name: #resetButton 					#flags: 40 					#model: #newClassReset 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #undisturb ) 					#tabable: true 					#label: 'Reset' 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Point 185 240 ) 					#model: #helpAction 					#tabable: true 					#label: 'Help' 					#defaultable: true ) 				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 8 0 3 0 -8 1 96 0 ) 					#label: 'Package for a New Class' ) 				#(#RadioButtonSpec 					#layout: #(#Point 30 33 ) 					#model: #newClassUseCurrentEditing 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #disturb ) 					#label: 'Current package; if (none), then prompt' 					#select: true ) 				#(#RadioButtonSpec 					#layout: #(#Point 30 59 ) 					#model: #newClassUseCurrentEditing 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #disturb ) 					#label: 'Always prompt' 					#select: false ) ) ) )</body><body package="Store-UI" selector="newDatumSpec">newDatumSpec	"UIPainter new openOnClass: self andSelector: #newDatumSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#min: #(#{Core.Point} 50 50 ) 			#bounds: #(#{Graphics.Rectangle} 476 312 733 572 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 8 0 3 0 -8 1 210 0 ) 					#label: 'Package for a New Shared Variable' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Core.Point} 10 240 ) 					#name: #acceptButton 					#flags: 40 					#model: #newDatumAccept 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#tabable: true 					#label: 'Accept' 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Core.Point} 101 240 ) 					#name: #resetButton 					#flags: 40 					#model: #newDatumReset 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#tabable: true 					#label: 'Reset' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Core.Point} 185 240 ) 					#model: #helpAction 					#tabable: true 					#label: 'Help' 					#defaultable: true ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 27 32 ) 					#model: #datumPlacementEditing 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#label: 'Current package; if (none), then prompt' 					#select: #currentINAU ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 27 60 ) 					#model: #datumPlacementEditing 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#label: 'Current package; if (none), use the class'' package' 					#select: #currentINUTCP ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 27 88 ) 					#model: #datumPlacementEditing 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#label: 'Class'' package' 					#select: #useTCP ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 27 116 ) 					#model: #datumPlacementEditing 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#label: 'Class'' package if same as current' 					#select: #useTCPIC ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 27 144 ) 					#model: #datumPlacementEditing 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#label: 'Class'' package if same as current or (none)' 					#select: #useTCPICON ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 27 172 ) 					#model: #datumPlacementEditing 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#label: 'Always prompt for package' 					#select: #alwaysAsk ) ) ) )</body><body package="Store-UI" selector="newMethodSpec">newMethodSpec	"UIPainter new openOnClass: self andSelector: #newMethodSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Unlabeled Canvas' 			#min: #(#Point 50 50 ) 			#bounds: #(#Rectangle 284 226 541 486 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 8 0 3 0 -8 1 210 0 ) 					#label: 'Package for a New Method' ) 				#(#ActionButtonSpec 					#layout: #(#Point 10 240 ) 					#name: #acceptButton 					#flags: 40 					#model: #newMethodAccept 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #undisturb ) 					#tabable: true 					#label: 'Accept' 					#isDefault: true 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Point 101 240 ) 					#name: #resetButton 					#flags: 40 					#model: #newMethodReset 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #undisturb ) 					#tabable: true 					#label: 'Reset' 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Point 185 240 ) 					#model: #helpAction 					#tabable: true 					#label: 'Help' 					#defaultable: true ) 				#(#RadioButtonSpec 					#layout: #(#Point 27 32 ) 					#model: #methodPlacementEditing 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #disturb ) 					#label: 'Current package; if (none), then prompt' 					#select: #currentINAU ) 				#(#RadioButtonSpec 					#layout: #(#Point 27 60 ) 					#model: #methodPlacementEditing 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #disturb ) 					#label: 'Current package; if (none), use the class'' package' 					#select: #currentINUTCP ) 				#(#RadioButtonSpec 					#layout: #(#Point 27 88 ) 					#model: #methodPlacementEditing 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #disturb ) 					#label: 'Class'' package' 					#select: #useTCP ) 				#(#RadioButtonSpec 					#layout: #(#Point 27 116 ) 					#model: #methodPlacementEditing 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #disturb ) 					#label: 'Class'' package if same as current' 					#select: #useTCPIC ) 				#(#RadioButtonSpec 					#layout: #(#Point 27 144 ) 					#model: #methodPlacementEditing 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #disturb ) 					#label: 'Class'' package if same as current or (none)' 					#select: #useTCPICON ) 				#(#RadioButtonSpec 					#layout: #(#Point 27 172 ) 					#model: #methodPlacementEditing 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #disturb ) 					#label: 'Always prompt for package' 					#select: #alwaysAsk ) ) ) )</body><body package="Store-UI" selector="packageCompareSpec">packageCompareSpec	"UIPainter new openOnClass: self andSelector: #packageCompareSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Unlabeled Canvas' 			#min: #(#Point 50 50 ) 			#bounds: #(#Rectangle 84 131 341 391 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#ActionButtonSpec 					#layout: #(#Point 10 240 ) 					#name: #acceptButton 					#flags: 40 					#model: #packageCompareAccept 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #undisturb ) 					#tabable: true 					#label: 'Accept' 					#isDefault: true 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Point 101 240 ) 					#name: #resetButton 					#flags: 40 					#model: #packageCompareReset 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #undisturb ) 					#tabable: true 					#label: 'Reset' 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Point 185 240 ) 					#model: #helpAction 					#tabable: true 					#label: 'Help' 					#defaultable: true ) 				#(#RadioButtonSpec 					#layout: #(#Point 30 33 ) 					#model: #ttUseChangeSetsForCompareEditing 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #disturb ) 					#label: 'Optimize speed: use change set to compute changes' 					#select: true ) 				#(#RadioButtonSpec 					#layout: #(#Point 30 60 ) 					#model: #ttUseChangeSetsForCompareEditing 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #disturb ) 					#label: 'Debugging option: consult database to compute changes' 					#select: false ) 				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 8 0 8 0 -8 1 94 0 ) 					#label: 'Publishing and Comparing Packages' ) ) ) )</body><body package="Store-UI" selector="prereqOptionsSpec">prereqOptionsSpec	"UIPainter new openOnClass: self andSelector: #prereqOptionsSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Prerequisite Loading' 			#min: #(#{Core.Point} 50 50 ) 			#bounds: #(#{Graphics.Rectangle} 576 432 833 692 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0466926 0 0.0307692 0 0.961089 0 0.496154 ) 					#label: 'Version Selection' ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.105058 0 0.126923 ) 					#name: #ask 					#model: #versionSelectionEditing 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #versionSelectionChanged ) 					#label: 'Ask' 					#select: #ask ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.105058 0 0.223077 ) 					#name: #latest 					#model: #versionSelectionEditing 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #versionSelectionChanged ) 					#label: 'Latest with blessing level equal to or higher than...' 					#select: #latest ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.175097 0 0.338462 0 0.863813 0 0.430769 ) 					#name: #blessingLevel 					#model: #blessingLevelEditing 					#menu: #blessingLevelMenu ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0428016 0 0.546154 0 0.96498 0 0.819231 ) 					#name: #GroupBox1 					#label: 'When loading #any' ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.105058 0 0.630769 ) 					#model: #searchOrderEditing 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#label: 'Search Bundles &amp; Packages first' 					#select: #pundlesFirst ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.105058 0 0.711538 ) 					#model: #searchOrderEditing 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#label: 'Search Parcels first' 					#select: #parcelsFirst ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.0466926 0 0.884615 ) 					#name: #acceptButton 					#flags: 40 					#model: #prereqOptionAccept 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#tabable: true 					#label: 'Accept' 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.389105 0 0.884615 ) 					#name: #resetButton 					#flags: 40 					#model: #prereqOptionReset 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#tabable: true 					#label: 'Reset' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.727626 0 0.884615 ) 					#model: #helpAction 					#tabable: true 					#label: 'Help' 					#defaultable: true ) ) ) )</body><body package="Store-UI" selector="toolOptionSpec">toolOptionSpec	"UIPainter new openOnClass: self andSelector: #toolOptionSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Unlabeled Canvas' 			#min: #(#Point 50 50 ) 			#bounds: #(#Rectangle 576 342 833 602 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#ActionButtonSpec 					#layout: #(#Point 10 240 ) 					#name: #acceptButton 					#flags: 40 					#model: #toolOptionAccept 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #undisturb ) 					#tabable: true 					#label: 'Accept' 					#isDefault: true 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Point 101 240 ) 					#name: #resetButton 					#flags: 40 					#model: #toolOptionReset 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #undisturb ) 					#tabable: true 					#label: 'Reset' 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Point 185 240 ) 					#model: #helpAction 					#tabable: true 					#label: 'Help' 					#defaultable: true ) 				#(#RadioButtonSpec 					#layout: #(#Point 30 33 ) 					#model: #ttShowPackageCommentsEditing 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #disturb ) 					#label: 'Show versions and blessing comments' 					#select: true ) 				#(#RadioButtonSpec 					#layout: #(#Point 30 60 ) 					#model: #ttShowPackageCommentsEditing 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #disturb ) 					#label: 'Show only versions' 					#select: false ) 				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 8 0 8 0 -8 1 94 0 ) 					#label: 'Version Browser Format' ) ) ) )</body><body package="Store-UI" selector="versionBrowserSpec">versionBrowserSpec	"UIPainter new openOnClass: self andSelector: #versionBrowserSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Unlabeled Canvas' 			#min: #(#Point 50 50 ) 			#bounds: #(#Rectangle 67 138 324 398 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#ActionButtonSpec 					#layout: #(#Point 10 240 ) 					#name: #acceptButton 					#flags: 40 					#model: #versionBrowserAccept 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #undisturb ) 					#tabable: true 					#label: 'Accept' 					#isDefault: true 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Point 101 240 ) 					#name: #resetButton 					#flags: 40 					#model: #versionBrowserReset 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #undisturb ) 					#tabable: true 					#label: 'Reset' 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Point 185 240 ) 					#model: #helpAction 					#tabable: true 					#label: 'Help' 					#defaultable: true ) 				#(#RadioButtonSpec 					#layout: #(#Point 30 33 ) 					#model: #versionManagerViewEditing 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #disturb ) 					#label: 'as a list' 					#select: #listPresentation ) 				#(#RadioButtonSpec 					#layout: #(#Point 30 59 ) 					#model: #versionManagerViewEditing 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #disturb ) 					#label: 'as an indented list' 					#select: #indentedPresentation ) 				#(#RadioButtonSpec 					#layout: #(#Point 30 85 ) 					#model: #versionManagerViewEditing 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #disturb ) 					#label: 'as a graph' 					#select: #graphPresentation ) 				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 8 0 8 0 -8 1 120 0 ) 					#label: 'Present Package Versions...' ) ) ) )</body></methods><methods><class-id>Store.NameSpaceLoader class</class-id> <category>interface specs</category><body package="Store-UI" selector="loadDialog">loadDialog	"UIPainter new openOnClass: self andSelector: #loadDialog"	&lt;resource: #canvas&gt;	^#(#{FullSpec} 		#window: 		#(#{WindowSpec} 			#label: 'Load NameSpace' 			#min: #(#{Point} 341 192 ) 			#max: #(#{Point} 341 192 ) 			#bounds: #(#{Rectangle} 203 167 544 359 ) 			#isEventDriven: true ) 		#component: 		#(#{SpecCollection} 			#collection: #(				#(#{CheckBoxSpec} 					#layout: #(#{Point} 98 22 ) 					#model: #definition 					#label: 'Definition' ) 				#(#{CheckBoxSpec} 					#layout: #(#{Point} 98 59 ) 					#model: #data 					#label: 'Data' ) 				#(#{CheckBoxSpec} 					#layout: #(#{Point} 98 97 ) 					#model: #comment 					#label: 'Comment' ) 				#(#{ActionButtonSpec} 					#layout: #(#{Rectangle} 7 148 117 183 ) 					#model: #loadChoosen 					#label: 'Load Chosen' 					#defaultable: true ) 				#(#{ActionButtonSpec} 					#layout: #(#{Rectangle} 240 147 333 183 ) 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) 				#(#{ActionButtonSpec} 					#layout: #(#{Rectangle} 123 148 234 183 ) 					#model: #loadAll 					#label: 'Load All' 					#isDefault: true 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Store.PundlesTool class</class-id> <category>interface specs</category><body package="Store-UI" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Unlabeled Canvas' 			#min: #(#Point 40 20 ) 			#bounds: #(#Rectangle 471 509 697 869 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#SubCanvasSpec 					#layout: #(#LayoutFrame 0 0 0 0 0 1 0 1 ) 					#majorKey: #'PundleComponent' 					#minorKey: #pundleComponentSpec 					#clientKey: #pundleClientApp ) ) ) )</body></methods><methods><class-id>Store.PublishedPundlesTool class</class-id> <category>interface specs</category><body package="Store-UI" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 384 288 1024 768 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 25 0 -2 0.4 0 1 ) 					#name: #pundleClient 					#flags: 0 					#majorKey: #{Store.PundleComponent} 					#minorKey: #pundleComponentSpec 					#clientKey: #pundleClientApp ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0 25 0 0 1 ) 					#name: #pundleClientLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #BundlesAndPackagesC 						#defaultString: 'Bundles and Packages:' 						#catalogID: #labels ) ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -2 0.4 0 0 2 0.4 0 1 ) 					#name: #ResizingSplitter 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'pundleClient' 					#belowWidgets: 'versionClient' ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.4 0 0 0 1 0 1 ) 					#name: #versionClient 					#flags: 0 					#majorKey: #{Store.VersionBrowser} 					#minorKey: #windowSpec 					#clientKey: #versionClientApp ) ) ) )</body></methods><methods><class-id>Store.PublishedPundlesTool class</class-id> <category>resources</category><body package="Store-UI" selector="publishedMenuBarSkeleton">publishedMenuBarSkeleton	"MenuEditor new openOnClass: self andSelector: #publishedMenuBarSkeleton"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: '&amp;File' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '&amp;Load' 							#value: #loadPundle ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Merge Into Image' 							#value: #mergePundleVersion ) 						#(#{UI.MenuItem} 							#rawLabel: 'Reconcile Image with Selection' 							#nameKey: #reconcile 							#value: #reconcile ) 						#(#{UI.MenuItem} 							#rawLabel: 'Reset Blessing Level' 							#value: #setBlessingLevel ) 						#(#{UI.MenuItem} 							#rawLabel: 'Republish Bundle...' 							#nameKey: #republish 							#value: #republish ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;File Out...' 							#value: #fileOutPundle ) 						#(#{UI.MenuItem} 							#rawLabel: 'File Out Differences...' 							#value: #fileOutTwoPundleDiff ) 						#(#{UI.MenuItem} 							#rawLabel: 'Update' 							#value: #reloadVersions ) 						#(#{UI.MenuItem} 							#rawLabel: 'E&amp;xit' 							#value: #closeRequest ) ) #(3 2 2 1 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'Examine' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Browse' 							#value: #browsePackageVersion ) 						#(#{UI.MenuItem} 							#rawLabel: 'List Contents' 							#value: #listBundleContents ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;List Versions' 							#value: #browseVersions ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Graph Versions' 							#value: #graphPundleVersions ) 						#(#{UI.MenuItem} 							#rawLabel: 'Compare with Image' 							#value: #diffPundleWithImage ) 						#(#{UI.MenuItem} 							#rawLabel: 'Compare with Parent' 							#value: #diffPundleWithParent ) 						#(#{UI.MenuItem} 							#rawLabel: 'Compare Versions' 							#value: #diffTwoPundles ) ) #(2 2 3 ) nil ) ) ) #(2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.PublishPundleDialog class</class-id> <category>interface specs</category><body package="Store-UI" selector="activeAreaSpec">activeAreaSpec	"UIPainter new openOnClass: self andSelector: #activeAreaSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #windowLabel 			#min: #(#{Core.Point} 332 332 ) 			#bounds: #(#{Graphics.Rectangle} 276 144 748 624 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 7 0 -2 1 -7 1 ) 					#name: #activeComponents 					#flags: 0 ) ) ) )</body><body package="Store-UI" selector="filesSpec">filesSpec	"Tools.UIPainter new openOnClass: self andSelector: #filesSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #publishPundles #defaultString: 'Publish Pundles'  #catalogID: #store)  			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 800 512 1272 992 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.00847458 0 0.0104167 0 0.991525 0 0.91875 ) 					#label: #(#{Kernel.UserMessage} #key: #publishFiles #defaultString: 'Publish Files'  #catalogID: #store) ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0233051 0 0.0520833 0 0.976695 0 0.625 ) 					#name: #fileList 					#model: #files ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.0275424 0 0.941667 ) 					#model: #accept 					#label: #(#{Kernel.UserMessage} #key: #publish #defaultString: 'Publish'  #catalogID: #store)					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.438559 0 0.941667 ) 					#model: #cancel 					#label: #(#{Kernel.UserMessage} #key: #cancel #defaultString: 'Cancel'  #catalogID: #store)					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.864407 0 0.941667 ) 					#name: #helpAction 					#model: #helpAction 					#label: #(#{Kernel.UserMessage} #key: #help #defaultString: 'Help'  #catalogID: #store)					#defaultable: true ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: #(#{Kernel.UserMessage} #key: #publishFiles #defaultString: 'Publish Files'  #catalogID: #store) ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0708333 0 0.4 ) 							#name: #publishAllYes 							#model: #publishAllYes 							#label: #(#{Kernel.UserMessage} #key: #publishAll #defaultString: 'Publish All'  #catalogID: #store) 							#defaultable: true ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.5 0 0.383333 ) 							#name: #publishAllNo 							#model: #publishAllNo 							#label: #(#{Kernel.UserMessage} #key: #dontPublishAny #defaultString: 'Dont Publish Any'  #catalogID: #store)							#defaultable: true ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 0 0.245763 0 0.645833 0 0.826271 0 0.770833 ) 						#name: #Composite1 ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: #(#{Kernel.UserMessage} #key: #currentSelection #defaultString: 'Current Selection' #catalogID: #store)) 						#(#{UI.RadioButtonSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.05 0 0.42 ) 							#name: #publishYes 							#model: #publish 							#label: #(#{Kernel.UserMessage} #key: #publishSelection #defaultString: 'Publish Selection'  #catalogID: #store)							#select: true ) 						#(#{UI.RadioButtonSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.5625 0 0.42 ) 							#name: #publishNo 							#model: #publish 							#label: #(#{Kernel.UserMessage} #key: #doNotPublish #defaultString: 'Do not publish' #catalogID: #store)							#select: false ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 0 0.245763 0 0.791667 0 0.830508 0 0.89375 ) 						#name: #Composite2 ) ) ) ) )</body><body package="Store-UI" selector="mainSpec">mainSpec	"UIPainter new openOnClass: self andSelector: #mainSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Publish Pundles' 			#min: #(#{Core.Point} 331 321 ) 			#bounds: #(#{Graphics.Rectangle} 531 166 1002 646 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 4 0 5 0 -4 1 -83 1 ) 					#label: 'Publish Bundles and Packages' ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 -41 1 -3 1 -39 1 ) ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 11 0 25 0 -11 1 -280 1 ) 					#name: #itemsList 					#flags: 15 					#model: #items ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.Rectangle} 0 0 90 25 ) 							#name: #binarySave 							#model: #binarySave 							#label: 'Publish Binary' ) 						#(#{UI.MenuButtonSpec} 							#layout: #(#{Graphics.LayoutFrame} 100 0 -25 1 0 1 0 1 ) 							#name: #blessingLevelButton 							#model: #blessingLevel 							#menu: #blessingLevelMenu ) 						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 -23 1 ) 							#label: 'Blessing level:' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 11 0 -275 1 -11 1 -225 1 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 0 ) 							#name: #bCommentLabel 							#label: 'Blessing comment:' ) 						#(#{UI.TextEditorSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0 19 0 0 1 0 1 ) 							#name: #blessingComment 							#model: #blessingComment 							#tabRequiresControl: true ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 11 0 -220 1 -11 1 -90 1 ) ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 -50 1 0.5 1 ) 					#model: #allBlessings 					#label: 'Set Global Blessing Level and Comment' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 -5 1 0 1 ) 					#model: #accept 					#label: 'Publish' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 -5 1 0.5 1 ) 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} -10 1 -5 1 1 1 ) 					#name: #helpAction 					#model: #helpAction 					#label: 'Help' 					#defaultable: true ) ) ) )</body><body package="Store-UI" selector="parcelSpec">parcelSpec	"UIPainter new openOnClass: self andSelector: #parcelSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Publish' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 489 157 961 637 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 4 0 5 0 -4 1 -39 1 ) 					#label: 'Parcel options' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 11 80 ) 					#name: #parcelWarningMessage 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#ColorValue #red ) ) 					#label: #parcelWarningMessage ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 11 25 ) 					#name: #parcelSave 					#model: #parcelSave 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #parcelSaveChanged ) 					#label: 'Publish Parcel' ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 3 ) 							#label: 'Parcel Path:' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 100 0 0 0 0 1 25 0 ) 							#name: #parcelDirectory 							#flags: 40 							#model: #parcelDirectory ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 11 0 50 0 -11 1 75 0 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: 'Store options' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0787037 0 0.253333 ) 							#name: #bundleStructure 							#model: #bundleStructure 							#callbacksSpec: 							#(#{UI.UIEventCallbackSubSpec} 								#valueChangeSelector: #bundleStructureChanged ) 							#label: 'Include bundle structure' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.174699 0 0.537634 ) 							#name: #databaseLinks 							#model: #databaseLinks 							#label: 'With database links' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 15 0 0 0.333333 -5 0.5 75 0.333333 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: 'Source options' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0722892 0 0.198276 ) 							#name: #parcelSaveSource 							#model: #parcelSaveSource 							#callbacksSpec: 							#(#{UI.UIEventCallbackSubSpec} 								#valueChangeSelector: #parcelSaveSourceChanged ) 							#label: 'Save source file' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.174699 0 0.422414 ) 							#name: #parcelHideSource 							#model: #parcelHideSource 							#label: 'Hide source on load' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.174699 0 0.681034 ) 							#name: #parcelPadded 							#model: #parcelPadded 							#label: 'Pad source' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 15 0 0 0.583333 -5 0.5 80 0.583333 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: 'Miscellaeonous Options' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0843373 0 0.2 ) 							#name: #parcelRepublish 							#model: #parcelRepublish 							#label: 'Republish' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0843373 0 0.448 ) 							#name: #parcelBackup 							#model: #parcelBackup 							#label: 'Backup' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0843373 0 0.712 ) 							#name: #parcelOverwrite 							#model: #parcelOverwrite 							#label: 'Overwrite existing files' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 5 0.5 0 0.583333 -15 1 80 0.583333 ) ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 -5 1 0 1 ) 					#model: #accept 					#label: 'Publish' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 -5 1 0.5 1 ) 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} -10 1 -5 1 1 1 ) 					#model: #helpAction 					#label: 'Help' 					#defaultable: true ) ) ) )</body><body package="Store-UI" selector="publishSpec">publishSpec	"UIPainter new openOnClass: self andSelector: #publishSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Publish Pundles' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 400 143 872 623 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 4 0 5 0 -4 1 -39 1 ) 					#label: 'Publish Bundles and Packages' ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 11 0 25 0 -11 1 -180 1 ) 					#name: #itemsList 					#model: #items ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: 'Publish Unmodifed Pundles' ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0692641 0 0.394737 ) 							#name: #publishAllYes 							#model: #publishAllYes 							#label: 'Publish All' 							#defaultable: true ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.424242 0 0.381579 ) 							#name: #publishAllNo 							#model: #publishAllNo 							#label: 'Publish Only Modified' 							#defaultable: true ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} -120 0.5 -170 1 120 0.5 -110 1 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: 'Current Selection' ) 						#(#{UI.RadioButtonSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.051948 0 0.419355 ) 							#name: #publishYes 							#model: #publish 							#label: 'Publish Selection' 							#select: true ) 						#(#{UI.RadioButtonSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.562771 0 0.419355 ) 							#name: #publishNo 							#model: #publish 							#label: 'Do not publish' 							#select: false ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} -120 0.5 -100 1 120 0.5 -50 1 ) ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 -5 1 0 1 ) 					#model: #accept 					#label: 'Publish' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 -5 1 0.5 1 ) 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} -10 1 -5 1 1 1 ) 					#name: #helpAction 					#model: #helpAction 					#label: 'Help' 					#defaultable: true ) ) ) )</body><body package="Store-UI" selector="versionSpec">versionSpec	"UIPainter new openOnClass: self andSelector: #versionSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Publish Pundles' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 527 149 999 629 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 4 0 5 0 -4 1 -39 1 ) 					#label: 'Set Bundles and Packages Versions' ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 11 0 25 0 -11 1 -130 1 ) 					#name: #itemsList 					#flags: 15 					#model: #items ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 100 0 0 0 0 1 25 0 ) 							#name: #versionStringBox 							#model: #versionString ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 3 ) 							#name: #vStringLabel 							#label: 'Version:' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 11 0 -115 1 -11 1 -85 1 ) ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 -50 1 0.5 1 ) 					#model: #allVersions 					#label: 'Set Global Version' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 -5 1 0 1 ) 					#model: #accept 					#label: 'Publish' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 -5 1 0.5 1 ) 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} -10 1 -5 1 1 1 ) 					#name: #helpAction 					#model: #helpAction 					#label: 'Help' 					#defaultable: true ) ) ) )</body><body package="Store-UI" selector="windowNotebookSpec">windowNotebookSpec	"UIPainter new openOnClass: self andSelector: #windowNotebookSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #windowLabel 			#min: #(#{Core.Point} 506 364 ) 			#bounds: #(#{Graphics.Rectangle} 207 144 817 624 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.NoteBookSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 5 0 -4 1 -10 1 ) 					#name: #notebook 					#model: #preferenceMasterList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: #requestSliceChange ) 					#rightInset: 120 					#bottomInset: 0 ) ) ) )</body></methods><methods><class-id>Store.PublishFragmentDialog class</class-id> <category>interface specs</category><body package="Store-UI" selector="mainSpec">mainSpec	"UIPainter new openOnClass: self andSelector: #mainSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Publish Pundles' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 527 219 985 699 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 4 0 5 0 -4 1 -83 1 ) 					#label: 'Publish Bundles and Packages' ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 -41 1 -3 1 -39 1 ) ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 11 0 25 0 -11 1 -265 1 ) 					#name: #itemsList 					#flags: 15 					#model: #items ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.MenuButtonSpec} 							#layout: #(#{Graphics.LayoutFrame} 100 0 0 0 0 1 25 0 ) 							#name: #blessingLevelButton 							#model: #blessingLevel 							#menu: #blessingLevelMenu ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 3 ) 							#label: 'Blessing level:' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 11 0 -255 1 -11 1 -230 1 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.TextEditorSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0 19 0 0 1 0 1 ) 							#name: #blessingComment 							#model: #blessingComment 							#tabRequiresControl: true ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 0 ) 							#name: #bCommentLabel 							#label: 'Blessing comment:' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 11 0 -225 1 -11 1 -90 1 ) ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 -50 1 0.5 1 ) 					#model: #allBlessings 					#label: 'Set Global Blessing Level and Comment' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 -5 1 0 1 ) 					#model: #accept 					#label: 'Publish' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 -5 1 0.5 1 ) 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} -10 1 -5 1 1 1 ) 					#name: #helpAction 					#model: #helpAction 					#label: 'Help' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Store.PublishPackageDialog class</class-id> <category>interface specs</category><body package="Store-UI" selector="mainSpec">mainSpec	"UIPainter new openOnClass: self andSelector: #mainSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Publish Pundles' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 283 171 741 597 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 4 0 5 0 -4 1 -40 1 ) 					#label: 'Publish Package' ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 2 ) 							#label: 'Version:' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 89 0 0 0 0 1.0 25 0 ) 							#name: #versionString 							#model: #versionString ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 11 0 25 0 -11 1 50 0 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 2 ) 							#label: 'Blessing level:' ) 						#(#{UI.MenuButtonSpec} 							#layout: #(#{Graphics.LayoutFrame} 89 0 0 0 0 1.0 25 0 ) 							#name: #blessingLevelButton 							#model: #blessingLevel 							#menu: #blessingLevelMenu ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 11 0 60 0 -11 1 85 0 ) ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 95 ) 					#name: #binarySave 					#model: #binarySave 					#label: 'Publish Binary' ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 0 0 ) 							#name: #bCommentLabel 							#label: 'Blessing comment:' ) 						#(#{UI.TextEditorSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 20 0 0 1.0 0 1.0 ) 							#name: #blessingComment 							#model: #blessingComment 							#tabRequiresControl: true ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 11 0 115 0 -11 1 -50 1 ) ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 -5 1 0 1 ) 					#model: #accept 					#label: 'Publish' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 -5 1 0.5 1 ) 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} -10 1 -5 1 1 1 ) 					#name: #helpAction 					#model: #helpAction 					#label: 'Help' 					#defaultable: true ) ) ) )</body><body package="Store-UI" selector="parcelSpec">parcelSpec	"UIPainter new openOnClass: self andSelector: #parcelSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Publish' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 261 376 681 856 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 4 0 5 0 -4 1 -40 1 ) 					#label: 'Parcel options' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 11 80 ) 					#name: #parcelWarningMessage 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#ColorValue #red ) ) 					#label: #parcelWarningMessage ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 11 25 ) 					#name: #parcelSave 					#model: #parcelSave 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #parcelSaveChanged ) 					#label: 'Publish Parcel' ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0 0 0.129032 ) 							#label: 'Parcel Path:' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 100 0 0 0 0 1 0 1 ) 							#name: #parcelDirectory 							#flags: 40 							#model: #parcelDirectory ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 11 0 50 0 -11 1 75 0 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: 'Source options' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0722892 0 0.198276 ) 							#name: #parcelSaveSource 							#model: #parcelSaveSource 							#callbacksSpec: 							#(#{UI.UIEventCallbackSubSpec} 								#valueChangeSelector: #parcelSaveSourceChanged ) 							#label: 'Save source file' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.174699 0 0.422414 ) 							#name: #parcelHideSource 							#model: #parcelHideSource 							#label: 'Hide source on load' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.174699 0 0.681034 ) 							#name: #parcelPadded 							#model: #parcelPadded 							#label: 'Pad source' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} -80 0.5 5 0.3 80 0.5 85 0.3 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: 'Miscellaeonous Options' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0843373 0 0.2 ) 							#name: #parcelRepublish 							#model: #parcelRepublish 							#label: 'Republish' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0843373 0 0.448 ) 							#name: #parcelBackup 							#model: #parcelBackup 							#label: 'Backup' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0843373 0 0.712 ) 							#name: #parcelOverwrite 							#model: #parcelOverwrite 							#label: 'Overwrite existing files' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} -80 0.5 0 0.583333 80 0.5 80 0.583333 ) ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 -5 1 0 1 ) 					#model: #accept 					#label: 'Publish' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 -5 1 0.5 1 ) 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} -10 1 -5 1 1 1 ) 					#model: #helpAction 					#label: 'Help' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Store.BlessingDialog class</class-id> <category>interface specs</category><body package="Store-UI" selector="mainSpec">mainSpec	"UIPainter new openOnClass: self andSelector: #mainSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Reset Blessing Level' 			#min: #(#{Core.Point} 471 480 ) 			#max: #(#{Core.Point} 471 480 ) 			#bounds: #(#{Graphics.Rectangle} 277 144 748 624 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 -41 1 -3 1 -39 1 ) ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 11 0 25 0 -11 1 -260 1 ) 					#name: #itemsList 					#flags: 15 					#model: #items 					#multipleSelections: false 					#selectionType: #checkMark ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 0 ) 							#name: #bCommentLabel 							#label: 'Blessing comment:' ) 						#(#{UI.TextEditorSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0 19 0 0 1 0 1 ) 							#name: #blessingComment 							#model: #blessingComment 							#tabRequiresControl: true ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 11 0 -220 1 -11 1 -90 1 ) ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 -50 1 0.5 1 ) 					#model: #allBlessings 					#label: 'Set Global Blessing Level and Comment' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 -5 1 0 1 ) 					#model: #accept 					#label: 'OK' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 -5 1 0.5 1 ) 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} -10 1 -5 1 1 1 ) 					#name: #helpAction 					#model: #helpAction 					#label: 'Help' 					#defaultable: true ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.MenuButtonSpec} 							#layout: #(#{Graphics.LayoutFrame} 89 0 0 0 0 1.0 0 1.0 ) 							#name: #blessingLevelButton 							#model: #blessingLevel 							#menu: #blessingLevelMenu ) 						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0 0 0.0769231 ) 							#label: 'Blessing level:' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 11 0 -250 1 -11 1 -225 1 ) ) ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 4 0 5 0 -4 1 -83 1 ) 					#label: 'Bundle and Components' ) ) ) )</body><body package="Store-UI" selector="publishSpec">publishSpec	"UIPainter new openOnClass: self andSelector: #publishSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Publish Pundles' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 287 347 759 827 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 -5 1 0 1 ) 					#model: #accept 					#label: 'Ok' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 -5 1 0.5 1 ) 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.00847458 0 0.0104167 0 0.991525 0 0.91875 ) 					#label: 'Bundle and Components' ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0233051 0 0.0520833 0 0.976695 0 0.635417 ) 					#name: #itemsList 					#model: #items ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: 'Current Selection' ) 						#(#{UI.RadioButtonSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.05 0 0.411765 ) 							#name: #publishYes 							#model: #publish 							#label: 'Reset Selection' 							#select: true ) 						#(#{UI.RadioButtonSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.5625 0 0.411765 ) 							#name: #publishNo 							#model: #publish 							#label: 'Do Not Reset' 							#select: false ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 0 0.245763 0 0.791667 0 0.754237 0 0.895833 ) ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} -10 1 -5 1 1 1 ) 					#name: #helpAction 					#model: #helpAction 					#label: 'Help' 					#defaultable: true ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: 'Rest Modifed Pundles' ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0575 0 0.362069 ) 							#name: #publishAllYes 							#model: #publishAllYes 							#label: 'Reset All' 							#defaultable: true ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.305 0 0.362069 ) 							#name: #publishAllNo 							#model: #publishAllNo 							#label: 'Reset Only Modified' 							#defaultable: true ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.655 0 0.362069 ) 							#name: #resetBundleOnly 							#model: #resetBundleOnly 							#label: 'Reset Bundle Only' 							#defaultable: true ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} -200 0.5 0 0.65 200 0.5 0 0.775 ) ) ) ) ) )</body></methods><methods><class-id>Store.DatabaseMessageBox class</class-id> <category>interface specs</category><body package="Store-Database" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #Title 			#min: #(#{Core.Point} 397 188 ) 			#max: #(#{Core.Point} 397 188 ) 			#bounds: #(#{Graphics.Rectangle} 483 493 880 681 ) 			#flags: 4 ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.Rectangle} 6 1 392 131 ) 					#name: #errorMessage 					#model: #errorMessage 					#isReadOnly: true 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 6 141 97 165 ) 					#name: #ok 					#model: #ok 					#label: 'OK' 					#isDefault: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 153 141 244 164 ) 					#name: #copyToClipboard 					#model: #copyToClipboard 					#label: 'Copy Message' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 301 141 392 164 ) 					#name: #openNotifier 					#model: #openNotifier 					#label: 'Debug' ) ) ) )</body><body package="Store-Database" selector="windowSpecOrig">windowSpecOrig	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Database Error Message' 			#min: #(#{Core.Point} 397 188 ) 			#max: #(#{Core.Point} 397 188 ) 			#bounds: #(#{Graphics.Rectangle} 396 293 793 481 ) 			#flags: 4 			#menu: #windowMenu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0151134 0 0.0421687 0 0.987405 0 0.795181 ) 					#name: #errorMessage 					#model: #errorMessage 					#isReadOnly: true 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.753149 0 0.837349 0 0.987405 0 0.975904 ) 					#name: #ok 					#model: #ok 					#label: 'OK' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Store.DatabaseMessageBox class</class-id> <category>resources</category><body package="Store-Database" selector="windowMenu">windowMenu	"MenuEditor new openOnClass: self andSelector: #windowMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: '&amp;Additional Information' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '&amp;Copy to Clipboard' 							#value: #copyToClipboard ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Open Notifier...' 							#value: #openNotifier ) ) #(2 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.RepositoryPropertiesDialog class</class-id> <category>interface specs</category><body package="Store-UI" selector="windowSpec">windowSpec	"UI.FullSpec class new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Repository Properties' 			#min: #(#{Core.Point} 410 201 ) 			#max: #(#{Core.Point} 410 201 ) 			#bounds: #(#{Graphics.Rectangle} 512 384 922 585 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 130 15 300 40 ) 					#name: #nameField 					#model: #nameHolder ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.Rectangle} 130 45 300 70 ) 					#name: #databaseCombo 					#model: #databaseHolder 					#type: #string 					#comboList: #databaseListHolder ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 130 75 300 100 ) 					#name: #environmentField 					#model: #environmentHolder ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 130 105 300 130 ) 					#name: #userNameField 					#model: #userNameHolder ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 130 135 300 160 ) 					#name: #passwordField 					#model: #passwordHolder 					#type: #password ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 130 165 300 190 ) 					#name: #tableOwnerField 					#model: #tableOwnerHolder ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 14 0 -10 1 39 0 ) 					#name: #accept 					#model: #ok 					#label: 					#(#{Kernel.UserMessage} 						#key: #OK 						#defaultString: 'OK' 						#catalogID: #database ) 					#isDefault: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 46 0 -10 1 71 0 ) 					#name: #cancel 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #database ) 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 40 0 0 1 ) 					#name: #Label1 					#label: 'Name:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 70 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #interface 						#defaultString: 'Interface:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 130 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #userName 						#defaultString: 'User Name:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 160 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #password 						#defaultString: 'Password:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 100 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #environment 						#defaultString: 'Environment:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 190 0 0 1 ) 					#label: 'Table Owner:' ) ) ) )</body></methods><methods><class-id>Tools.StoreRepositoryListPage class</class-id> <category>interface specs</category><body package="Store-UI" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 1024 768 ) 			#bounds: #(#{Graphics.Rectangle} 512 384 850 672 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.DataSetSpec} 					#properties: #(#{UI.PropertyListDictionary} #showHorizontalLines false #allowColumnResizing true #rowSize 25 #showVerticalLines false #allowColumnReordering false ) 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 -30 1 ) 					#name: #repositoryListDataset 					#flags: 13 					#model: #repositoryListHolder 					#columns: #(						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false #allowSorting false #allowResizing false ) 							#model: #'repositoryHolder name' 							#label: 'Name' 							#labelIsImage: false 							#width: 100 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting false #labelFromApplication false ) 							#model: #'repositoryHolder environment' 							#label: 'Environment' 							#labelIsImage: false 							#width: 200 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) ) 					#labelsAsButtons: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -25 1 -3 0.333333 0 1 ) 					#name: #addButton 					#model: #addRepository 					#label: 'Add...' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.333333 -25 1 -2 0.666666 0 1 ) 					#name: #removeButton 					#model: #removeRepository 					#label: 'Remove...' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.666666 -25 1 0 1 0 1 ) 					#name: #propertiesButton 					#model: #repositoryProperties 					#label: 'Properties...' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Store.PundleGraph class</class-id> <category>interface specs</category><body package="Store-UI-Graphs" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Loaded Items' 			#min: #(#Point 40 20 ) 			#bounds: #(#Rectangle 427 376 672 725 ) 			#flags: 4 			#menu: #menuBarHolder ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#SubCanvasSpec 					#layout: #(#LayoutFrame 0 0 0 0 0 1 0 1 ) 					#name: #graphView 					#flags: 0 					#majorKey: #'LensGraphView' 					#minorKey: #windowSpec 					#clientKey: #graphView ) ) ) )</body></methods><methods><class-id>Store.PundleGraph class</class-id> <category>resources</category><body package="Store-UI-Graphs" selector="bundleStructureMenu">bundleStructureMenu	"MenuEditor new openOnClass: self andSelector: #bundleStructureMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'Load...' 				#value: #loadPundle ) 			#(#{UI.MenuItem} 				#rawLabel: 'Merge' 				#value: #mergePundleVersion ) 			#(#{UI.MenuItem} 				#rawLabel: 'Publish...' 				#value: #storePundleInDB ) 			#(#{UI.MenuItem} 				#rawLabel: 'File Out...' 				#value: #fileOutPundle ) 			#(#{UI.MenuItem} 				#rawLabel: 'File Out Changes...' 				#value: #fileOutChanges ) 			#(#{UI.MenuItem} 				#rawLabel: 'Browse' 				#value: #browsePackageVersion ) 			#(#{UI.MenuItem} 				#rawLabel: 'Show structure' 				#value: #showBundleStructure ) 			#(#{UI.MenuItem} 				#rawLabel: 'Inspect Changes' 				#value: #diffPundleWithParent ) 			#(#{UI.MenuItem} 				#rawLabel: 'List Versions' 				#value: #browseVersions ) 			#(#{UI.MenuItem} 				#rawLabel: 'Graph Versions' 				#value: #graphPundleVersions ) 			#(#{UI.MenuItem} 				#rawLabel: 'Set Blessing Level' 				#value: #setBlessingLevel ) 			#(#{UI.MenuItem} 				#rawLabel: 'Compare' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'With Trace' 							#value: #diffPundleWithParent ) 						#(#{UI.MenuItem} 							#rawLabel: 'With Image' 							#value: #diffPundleWithImage ) ) #(2 ) nil ) ) ) #(2 1 2 3 2 2 ) nil ) decodeAsLiteralArray</body><body package="Store-UI-Graphs" selector="bundleStructureMenuBarSkeleton">bundleStructureMenuBarSkeleton	"MenuEditor new openOnClass: self andSelector: #bundleStructureMenuBarSkeleton"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: '&amp;File' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '&amp;Load...' 							#value: #loadPundle ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Merge' 							#value: #mergePundleVersion ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Publish...' 							#value: #storePundleInDB ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;File Out...' 							#value: #fileOutPundle ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;File Out Changes...' 							#value: #fileOutChanges ) 						#(#{UI.MenuItem} 							#rawLabel: 'E&amp;xit' 							#value: #closeRequest ) ) #(2 1 2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: '&amp;Items' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '&amp;Browse' 							#value: #browsePackageVersion ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Show structure' 							#value: #showBundleStructure ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Inspect Changes' 							#value: #diffPundleWithParent ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;List Versions' 							#value: #browseVersions ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Graph Versions' 							#value: #graphPundleVersions ) 						#(#{UI.MenuItem} 							#rawLabel: 'Set Blessing Level' 							#value: #setBlessingLevel ) ) #(3 2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: '&amp;Compare' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'With &amp;Trace' 							#value: #diffPundleWithParent ) 						#(#{UI.MenuItem} 							#rawLabel: 'With &amp;Image' 							#value: #diffPundleWithImage ) ) #(2 ) nil ) ) ) #(3 ) nil ) decodeAsLiteralArray</body><body package="Store-UI-Graphs" selector="menu">menu	"MenuEditor new openOnClass: self andSelector: #menu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'Publish...' 				#value: #storePundleInDB ) 			#(#{UI.MenuItem} 				#rawLabel: 'File Out...' 				#value: #fileOutPundle ) 			#(#{UI.MenuItem} 				#rawLabel: 'File Out Changes...' 				#value: #fileOutChanges ) 			#(#{UI.MenuItem} 				#rawLabel: 'Add' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Package...' 							#value: #addPackage ) 						#(#{UI.MenuItem} 							#rawLabel: 'Bundle...' 							#value: #addBundle ) ) #(2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'Unload...' 				#value: #deletePundle ) 			#(#{UI.MenuItem} 				#rawLabel: 'Browse' 				#value: #browsePackageVersion ) 			#(#{UI.MenuItem} 				#rawLabel: 'Edit specification' 				#value: #editBundleSpecification ) 			#(#{UI.MenuItem} 				#rawLabel: 'Inspect Changes' 				#value: #diffPundleWithParent ) 			#(#{UI.MenuItem} 				#rawLabel: 'Make Current' 				#value: #makeCurrentPackage ) 			#(#{UI.MenuItem} 				#rawLabel: 'List Versions' 				#value: #browseVersions ) 			#(#{UI.MenuItem} 				#rawLabel: 'Graph Versions' 				#value: #graphPundleVersions ) ) #(1 2 5 1 2 ) nil ) decodeAsLiteralArray</body><body package="Store-UI-Graphs" selector="menuBarSkeleton">menuBarSkeleton	"MenuEditor new openOnClass: self andSelector: #menuBarSkeleton"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: '&amp;File' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '&amp;Publish...' 							#value: #storePundleInDB ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;File Out...' 							#value: #fileOutPundle ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;File Out Changes...' 							#value: #fileOutChanges ) 						#(#{UI.MenuItem} 							#rawLabel: 'E&amp;xit' 							#value: #closeRequest ) ) #(1 2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: '&amp;Items' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Add' 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: 'Package...' 										#value: #addPackage ) 									#(#{UI.MenuItem} 										#rawLabel: 'Bundle...' 										#value: #addBundle ) ) #(2 ) nil ) ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Unload...' 							#value: #deletePundle ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Browse' 							#value: #browsePackageVersion ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Show Structure' 							#value: #showBundleStructure ) 						#(#{UI.MenuItem} 							#rawLabel: 'Edit Specification' 							#value: #editBundleSpecification ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Inspect Changes' 							#value: #diffPundleWithParent ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Make Current' 							#value: #makeCurrentPackage ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;List Versions' 							#value: #browseVersions ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Graph Versions' 							#value: #graphPundleVersions ) ) #(6 1 2 ) nil ) ) ) #(2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.RepublishBundleDialog class</class-id> <category>interface specs</category><body package="Store-UI" selector="contentsSpec">contentsSpec	"UIPainter new openOnClass: self andSelector: #contentsSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Republish Bundle' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 576 384 1048 864 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.00847458 0 0.0104167 0 0.991525 0 0.91875 ) 					#label: 'Set Bundle Contents' ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0233051 0 0.05 0 0.966102 0 0.74375 ) 					#name: #itemsList 					#flags: 15 					#model: #items 					#menu: #itemMenu ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0720339 0 0.766667 0 0.243644 0 0.814583 ) 					#name: #moveUp 					#model: #moveUp 					#label: 'Move Up' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.29661 0 0.766667 0 0.46822 0 0.814583 ) 					#name: #moveDown 					#model: #moveDown 					#label: 'Move Down' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.519068 0 0.766667 0 0.70339 0 0.814583 ) 					#name: #selectVersion 					#model: #selectVersion 					#label: 'Select Version...' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.758475 0 0.766667 0 0.930085 0 0.814583 ) 					#name: #removeItem 					#model: #removeItem 					#label: 'Remove...' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.192797 0 0.85 0 0.364407 0 0.897917 ) 					#name: #addBundle 					#model: #addBundle 					#label: 'Add Bundle...' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.637712 0 0.85 0 0.82839 0 0.897917 ) 					#name: #addPackage 					#model: #addPackage 					#label: 'Add Package...' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.0211864 0 0.941667 ) 					#model: #accept 					#label: 'Publish' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.442797 0 0.941667 ) 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.864407 0 0.941667 ) 					#name: #helpAction 					#model: #helpAction 					#label: 'Help' 					#defaultable: true ) ) ) )</body><body package="Store-UI" selector="mainSpec">mainSpec	"UIPainter new openOnClass: self andSelector: #mainSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Republish Bundle' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 495 363 953 789 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 4 0 5 0 -4 1 -40 1 ) 					#label: 'Republish Bundle' ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 2 ) 							#label: 'Version:' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 89 0 0 0 0 1.0 25 0 ) 							#name: #versionString 							#model: #versionString ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 11 0 25 0 -11 1 50 0 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 2 ) 							#label: 'Blessing level:' ) 						#(#{UI.MenuButtonSpec} 							#layout: #(#{Graphics.LayoutFrame} 89 0 0 0 0 1.0 25 0 ) 							#name: #blessingLevelButton 							#model: #blessingLevel 							#menu: #blessingLevelMenu ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 11 0 60 0 -11 1 85 0 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 0 0 ) 							#name: #bCommentLabel 							#label: 'Blessing comment:' ) 						#(#{UI.TextEditorSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 20 0 0 1.0 0 1.0 ) 							#name: #blessingComment 							#model: #blessingComment 							#tabRequiresControl: true ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 12 0 123 0 -11 1 -50 1 ) ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 -5 1 0 1 ) 					#model: #accept 					#label: 'Publish' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 -5 1 0.5 1 ) 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} -10 1 -5 1 1 1 ) 					#name: #helpAction 					#model: #helpAction 					#label: 'Help' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 101 97 205 121 ) 					#name: #editProperties 					#model: #editProperties 					#label: 'Edit Properties...' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Store.RepublishBundleDialog class</class-id> <category>resources</category><body package="Store-UI" selector="itemMenu">itemMenu	"MenuEditor new openOnClass: self andSelector: #itemMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'Select Version...' 				#nameKey: #selectVersion 				#value: #selectVersion ) 			#(#{UI.MenuItem} 				#rawLabel: 'Move Up' 				#nameKey: #moveUp 				#value: #moveUp ) 			#(#{UI.MenuItem} 				#rawLabel: 'Move Down' 				#nameKey: #moveDown 				#value: #moveDown ) 			#(#{UI.MenuItem} 				#rawLabel: 'Remove' 				#nameKey: #removeItem 				#value: #removeItem ) ) #(1 3 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Store.ModificationSet class</class-id> <category>resources</category><body package="Store-Merge" selector="appliedBWImage">appliedBWImage	"UIMaskEditor new openOnClass: self andSelector: #appliedBWImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 127 252 0 0 127 252 0 0 127 252 0 0 127 252 0 0 127 252 0 0 127 252 0 0 127 252 0 0 127 252 0 0 127 252 0 0 127 252 0 0 127 252 0 0 127 252 0 0 0 0 0 0])</body><body package="Store-Merge" selector="resolvedBWImage">resolvedBWImage	"UIMaskEditor new openOnClass: self andSelector: #resolvedBWImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 127 252 0 0 192 6 0 0 120 60 0 0 78 228 0 0 71 132 0 0 67 132 0 0 67 132 0 0 71 196 0 0 76 124 0 0 92 52 0 0 64 4 0 0 127 252 0 0 0 0 0 0])</body><body package="Store-Merge" selector="unresolvedBWImage">unresolvedBWImage	"UIMaskEditor new openOnClass: self andSelector: #unresolvedBWImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 127 252 0 0 64 4 0 0 64 4 0 0 64 4 0 0 64 4 0 0 64 4 0 0 64 4 0 0 64 4 0 0 64 4 0 0 64 4 0 0 64 4 0 0 127 252 0 0 0 0 0 0])</body></methods><methods><class-id>Tools.ChangeSetManager</class-id> <category>actions</category><body package="Store-IMG-Pundles" selector="publishFragment">publishFragment	"Publish the current change set as a fragment."	&lt;menuItem: 'Publish as Fra&amp;gment...'		nameKey: #publishFragment		menu: #(#listMenu)		position: 35.01&gt;	self class publishAsFragmentChangeSet: self currentPackage</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>store menus</category><body package="Store-UI" selector="administration">administration	&lt;submenu: '&amp;Administration'		nameKey: #administration		menu: #(#menuBar #store)		position: 90.01&gt;</body><body package="Store-UI" selector="browseClassDefinitions">browseClassDefinitions	&lt;menuItem: 'Class named...'		icon: nil		nameKey: #browseClassDefinitions		enablement: #areAttached		indication: nil		menu: #(#menuBar #store #browseDefinitions)		position: 90.03&gt;	| name list |	name  := Dialog request: 'Class name'.	name isEmpty ifTrue: [ ^self ].	( name := Store.ClassRecord chooseNameMatching: name description: 'class' ) == nil		ifTrue: [ ^self ].	list := Store.ClassRecord allVersionsNamed: name.	list isEmpty ifTrue: [ ^Dialog warn: name, ' has not been published.' ].	TabApplicationSystemBrowser browseNamespaceOrClassList: list.</body><body package="Store-UI" selector="browseDefinitions">browseDefinitions	&lt;submenu: 'Browse &amp;Definitions'		nameKey: #browseDefinitions		menu: #(#menuBar #store)		position: 20.09&gt;</body><body package="Store-UI" selector="browseNameSpaceDefinitions">browseNameSpaceDefinitions	&lt;menuItem: 'NameSpace named...'		icon: nil		nameKey: #browseNameSpaceDefinitions		enablement: #areAttached		indication: nil		menu: #(#menuBar #store #browseDefinitions)		position: 90.02&gt;	| name list |	name  := Dialog request: 'NameSpace name'.	name isEmpty ifTrue: [ ^self ].	( name := Store.NameSpaceRecord chooseNameMatching: name description: 'namespace' ) == nil		ifTrue: [ ^self ].	list := Store.NameSpaceRecord allVersionsNamed: name.	list isEmpty ifTrue: [ ^Dialog warn: name, ' has not been published.' ].	TabApplicationSystemBrowser browseNamespaceOrClassList: list.</body><body package="Store-UI" selector="browseSelector">browseSelector	&lt;menuItem: 'Selector...'		icon: nil		nameKey: #browseSelector		enablement: #areAttached		indication: nil		menu: #(#menuBar #store #browseDefinitions)		position: 90.03&gt;	| name list classes cls |	name := ParagraphEditor currentSelection.	name  := Dialog request: 'Selector'.	name isEmpty ifTrue: [ ^self ].	( name := Store.Method chooseNameMatching: name description: 'selector' ) == nil		ifTrue: [ ^nil ].	list := Store.Method allVersionsWithName: name.	classes := list collect: [ :m | m classNameWithMeta asSymbol ].	classes := classes asSet asSortedCollection asOrderedCollection.	cls := classes size == 1		ifTrue: [ classes first ]		ifFalse: 			[ Dialog 				choose: ( '#&lt;1s&gt; in which class...'  expandMacrosWith: name )				fromList: classes values: classes				lines: 10 cancel: [ ^nil ]				for: nil.			].	TabApplicationSystemBrowser 		browseVersionsOfMethodNamed: name		inClassNamed: cls asClassNameOnly		meta: cls namesMetaClass</body><body package="Store-UI" selector="browseStatic">browseStatic	&lt;menuItem: 'Shared Variable...'		icon: nil		nameKey: #browseStatic		enablement: #areAttached		indication: nil		menu: #(#menuBar #store #browseDefinitions)		position: 90.05&gt;	| name list owners owner |	name := ParagraphEditor currentSelection.	name  := Dialog request: 'Shared Variable'.	name isEmpty ifTrue: [ ^self ].	( name := Store.DataElement chooseNameMatching: name description: 'shared variable' ) == nil		ifTrue: [ ^nil ].	list := Store.DataElement allVersionsWithName: name.	owners := list collect: [ :m | m ownerName asSymbol ].	owners := owners asSet asSortedCollection asOrderedCollection.	owner := owners size == 1		ifTrue: [ owners first ]		ifFalse: 			[ Dialog 				choose: ( '#&lt;1s&gt; in which class...'  expandMacrosWith: name )				fromList: owners values: owners				lines: 10 cancel: [ ^nil ]				for: nil.			].	TabApplicationSystemBrowser 		browseVersionsOfStaticNamed: name		inNamed: owner</body><body package="Store-UI" selector="browseUnpackaged">browseUnpackaged	&lt;menuItem: 'Browse &amp;Unpackaged'		icon: nil		nameKey: nil		menu: #(#menuBar #store)		position: 20.07&gt;	Store.PundleAccess moveUnpackagedToNullPackage.	Refactory.Browser.RefactoringBrowser openOnEnvironment:  (Refactory.Browser.PundleEnvironment new pundles: (List with: Store.Registry nullPackage))</body><body package="Store-UI" selector="bundleOwnershipManagement">bundleOwnershipManagement	&lt;menuItem: '&amp;Bundle Ownership'		icon: nil		nameKey: #bundleOwnershipManagement		enablement: #areAttached		indication: nil		menu: #(#menuBar #store #administration)		position: 90.05&gt;	Store.DbRegistry doIfImageAdministrator:		[ Store.BundlePrivilegeGraph open ] label: 'manage bundle ownership'.</body><body package="Store-UI" selector="checkConsistency">checkConsistency	&lt;menuItem: 'Check Consistency'		icon: nil		nameKey: nil		menu: #(#menuBar #store)		position: 90.99&gt;	| strm warning |	strm := WriteStream on: String new.	Cursor wait showWhile: [ Registry checkConsistencyOn: strm ].	warning := strm contents.	Dialog warn: 		( warning size = 0			ifTrue: [ 'Everything checks out fine' ]			ifFalse: [ warning ] )</body><body package="Store-UI" selector="currentPackage">currentPackage	&lt;menuItem: '&amp;Current Package...'		icon: nil 		nameKey: #currentPackage		menu: #(#menuBar #store)		position: 50.05&gt;	| pkg |	pkg := Registry currentPackage.	pkg := PackageChooser		chooseOrAdd: ( 'Current Package: ', pkg name )		 withDefault: pkg 		onCancelDo: [ ^self ].	Registry currentPackage: pkg.</body><body package="Store-UI" selector="openGarbageCollectionDialog">openGarbageCollectionDialog	&lt;menuItem: '&amp;Garbage Collection'		icon: nil		nameKey: nil		enablement: #areAttached		indication: nil		menu: #(#menuBar #store #administration)		position: 90.99&gt;	Store.DbRegistry doIfImageAdministrator:		[ Store.GarbageCollectSpecEditor open ] label: 'run garbage collection'.</body><body package="Store-UI" selector="openLoadedItems">openLoadedItems	&lt;menuItem: '&amp;Loaded Items'		icon: nil		nameKey: nil		menu: #(#menuBar #store)		position: 20.01&gt;	Store.PundlesTool openOnAllLoadedPundles</body><body package="Store-UI" selector="openMergeTool">openMergeTool	&lt;menuItem: 'Merge &amp;Tool'		icon: nil		nameKey: nil		enablement: #areAttached		indication: nil		menu: #(#menuBar #store )		position: 20.09&gt;	Store.MergeTool open.</body><body package="Store-UI" selector="openPublishedItems">openPublishedItems	&lt;menuItem: '&amp;Published Items'		icon: nil		nameKey: nil		enablement: #areAttached		indication: nil		menu: #(#menuBar #store)		position: 20.02&gt;	DbRegistry doIfOnlineImage: 		[ Store.PublishedPundlesTool openOnAllPublishedPundles ]</body><body package="Store-UI" selector="openRecentPublishedItems">openRecentPublishedItems	&lt;menuItem: '&amp;More Recently Published Items'		icon: nil		nameKey: nil		enablement: #areAttached		indication: nil		menu: #(#menuBar #store)		position: 20.05&gt;	| list list2 |	DbRegistry doIfOnlineImage: 		[ list := (Registry allPackagesWithNewerInDB collect: [ :pkg | pkg name ]) asSet.		list2  := (Registry allBundlesWithNewerInDB collect: [ :bundle | bundle name ]) asSet.		Store.PublishedPundlesTool openOnBundles: list2 packages: list title: 'More Recently Published Items'		]</body><body package="Store-UI" selector="openUISettings">openUISettings	&lt;menuItem: '&amp;Settings'		icon: nil		nameKey: nil		menu: #(#menuBar #store)		position: 50.01&gt;	SettingsManager 		openOrRaise: VisualWorksSettings 		selectPage: #(#store)</body><body package="Store-UI" selector="packageOwnershipManagement">packageOwnershipManagement	&lt;menuItem: 'Package &amp;Ownership'		icon: nil		nameKey: #packageOwnershipManagement		enablement: #areAttached		indication: nil		menu: #(#menuBar #store #administration)		position: 90.05&gt;	Store.DbRegistry doIfImageAdministrator:		[ Store.PrivilegeGraph open ] label: 'manage ownership'.</body><body package="Store-UI" selector="removeDatabaseLinks">removeDatabaseLinks	&lt;menuItem: 'Remove Database Links...'		icon: nil		nameKey: nil		menu: #(#menuBar #store)		position: 90.10&gt;	Store.Registry removeDatabaseLinks.</body><body package="Store-UI" selector="renameBundleInDatabase">renameBundleInDatabase	&lt;menuItem: 'Rename Bundle in Database...'		icon: nil		nameKey: #renameBundle		enablement: #areAttached		indication: nil		menu: #(#menuBar #store #administration)		position: 90.10&gt;	Store.DbRegistry doIfImageAdministrator:		[ ( Dialog confirm: 'Renaming a bundle in the database will require all existing images to rename to match.&lt;ntttttttt&gt;Continue?' expandMacros )			ifFalse: [ ^self ].		Store.Bundle rename.		] label: 'rename bundles'.</body><body package="Store-UI" selector="renamePackageInDatabase">renamePackageInDatabase	&lt;menuItem: 'Rename Package in Database...'		icon: nil		nameKey: #renamePackage		enablement: #areAttached		indication: nil		menu: #(#menuBar #store #administration)		position: 90.11&gt;	Store.DbRegistry doIfImageAdministrator:		[ ( Dialog confirm: 'Renaming a package in the database will require all existing images to rename to match.&lt;ntttttttt&gt;Continue?' expandMacros )			ifFalse: [ ^self ].		Store.Package rename		] label: 'rename packages'.</body><body package="Store-UI" selector="store">store	&lt;submenu: 'St&amp;ore'		nameKey: #store		menu: #(#menuBar)		position: 10.035&gt;</body><body package="Store-UI" selector="switchDatabases">switchDatabases	&lt;menuItem: 'Switch Databases'		icon: nil		nameKey: nil		enablement: #areAttached		indication: nil		menu: #(#menuBar #store)		position: 90.08&gt;	Store.Registry switchDatabases.</body><body package="Store-UI" selector="toggleStoreRepositoryConnection">toggleStoreRepositoryConnection	&lt;menuItem: #toggleStoreConnectionItemLabel		nameKey: nil		menu: #(#menuBar #store)		position: 10.5&gt;	DbRegistry isConnected 		ifTrue: [DbRegistry disconnect]		ifFalse: [DbRegistry restoreConnection]</body><body package="Store-UI" selector="userGroupManagement">userGroupManagement	&lt;menuItem: 'User/Group &amp;Management'		icon: nil		nameKey: #userGroupManagement		enablement: #areAttached		indication: nil		menu: #(#menuBar #store #administration)		position: 90.03&gt;	Store.DbRegistry doIfImageAdministrator:		[ Store.GroupGraph open ] label: 'manage user/groups'.</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-store</category><body package="Store-UI" selector="store05ParcelDirectory">store05ParcelDirectory	&lt;setting: #(store parcelDirectory)&gt;	^(StringSetting forNameOfDirectory on: (Store.UISettings preferenceModelFor: #packageDir))		label: 'Parcel Directory'</body><body package="Store-UI" selector="store10AllowBinaryLoading">store10AllowBinaryLoading	&lt;setting: #(store allowBinaryLoading)&gt;	^(BooleanSetting on: Store.Policies publishPolicy aspect: #allowBinaryLoading)		label: #allowBinaryLoading &lt;&lt; #labels &gt;&gt; 'Allow binary loading';		helpText: #store10AllowBinaryLoading &lt;&lt; #dialogs &gt;&gt; 'When enabled, Store will load binary all packages that were saved binary. When disabled, Store will load source code in all cases.'</body><body package="Store-UI" selector="store10PropertiesPublishingPolicy">store10PropertiesPublishingPolicy	&lt;setting: #(#store #propertiesPublishing #propertiesPublishingPolicy)&gt;	^((EnumerationSetting 			choices: #(#bossOnly #tableOnly #bossAndTable)			labels: #('Save properties in backward compatible format' 'Save properties as searchable records' 'Both of the above')) 		on: Store.Pundle aspect: #propertiesPublishingPolicy)		label: 'Properties Publishing Policy';		helpText: #store10PropertiesPublishingPolicy &lt;&lt; #store &gt;&gt; 'Before VW7.3, pundle properties were saved as a single blob. Their names and values were not separately accessible in the database. Beginning with VW 7.3, the properties can be saved individually, to a new dedicated database table, and can be individually searched and retrieved.Save properties in backward compatible format - The old way (pre-VW7.3). The entire dictionary is BOSSed to a single record in the DB, and individual properties cannot be separately queried before loading. This setting is available for those who cannot change their repository schema. Loading is exclusively from BOSSed properties.Save properties as searchable records - Properties are saved the new way and the old way. This setting is recommended for shops who must also support code developed before VW7.3. Loading is as described in Table only.Both of the above - The new way. Properties are saved individually, each to its own record in the new DB table. This setting is recommended for shops supporting only VW7.3 and higher applications. Loading is first from Table. If no related property records are found in the table, loading proceeds from BOSS. Older published code will of course have only BOSSed properties.'</body><body package="Store-UI" selector="store15UseFastComparison">store15UseFastComparison	&lt;setting: #(store useFastComparison)&gt;	^(BooleanSetting on: (Store.UISettings preferenceModelFor: #ttUseChangeSetsForCompare))		label: #UseFastComparison &lt;&lt; #labels &gt;&gt; 'Use fast comparison';		helpText: #store15UseFastComparison &lt;&lt; #dialogs &gt;&gt; 'This option chooses how Store determines changes that need to be published.  When on, Store uses change sets, when off, it compares code in the image with the database.Usually fast comparison should be turned on.  This results in much faster performance when publishing and when comparing a loaded package with a version in the database.Occasionally you may encounter a bug that causes the change set of a package to enter an incorrect state.  In this case, publishing the package may not publish all changed definitions, and comparing the in-image package with a database version may likewise fail to compute the correct result.To cause the publish and compare operations to ignore the damaged change set, turn this setting off.  This forces these operations to compare the in-image version directly with the database version rather than consulting the change set to find out what has changed since the package was loaded.'</body><body package="Store-UI" selector="store50NewClassPackage">store50NewClassPackage	&lt;setting: #(store packageDefaults newClassPackage)&gt;	^((EnumerationSetting 				keys: #(#current #prompt)				choices: #(true false)				labels: #('Current' 'Prompt'))			on: (Store.UISettings preferenceModelFor: #newClassUseCurrent))		label: 'For a new class'</body><body package="Store-UI" selector="store52NewMethodPackage">store52NewMethodPackage	&lt;setting: #(store packageDefaults newMethodPackage)&gt;	^((EnumerationSetting 				choices: #(currentINAU #currentINUTCP #useTCP #useTCPIC #useTCPICON #alwaysAsk)				labels: #('Current' 'Current or class package' 'Class package' 'Class if same as current' 'Class if same as current or none' 'Always prompt'))			on: (Store.UISettings preferenceModelFor: #methodPlacement))		label: 'For a new method'</body><body package="Store-UI" selector="store54NewSharedPackage">store54NewSharedPackage	&lt;setting: #(store packageDefaults newSharedPackage)&gt;	^((EnumerationSetting 				choices: #(currentINAU #currentINUTCP #useTCP #useTCPIC #useTCPICON #alwaysAsk)				labels: #('Current' 'Current or class package' 'Class package' 'Class if same as current' 'Class if same as current or none' 'Always prompt'))			on: (Store.UISettings preferenceModelFor: #datumPlacement))		label: 'For a new variable'</body><body package="Store-UI" selector="store80IncludePackageIntoFileout">store80IncludePackageIntoFileout	&lt;setting: #(store includePackageIntoFileout)&gt;	| adaptor |	adaptor := (PluggableAdaptor on: (Store.UISettings preferenceModelFor: #fileoutOption))		getBlock: [:m | m value]		putBlock: 			[:m :v | m value: v.			v == #always				ifTrue: [Registry installCallBacksForFileout]				ifFalse: [Registry removeCallBacksForFileout]]		updateBlock: [:m :a :p | true].	^((EnumerationSetting 				choices: #(never storeOnly always)				labels: #('Never' 'For package fileouts' 'Always'))			on: adaptor)		label: 'File out package information'</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="Store-UI" selector="storePackageDefaultPage">storePackageDefaultPage	&lt;settingsPage: #(store packageDefaults)&gt;	^ModularSettingsPage new		label: #StoreDefaultPackage &lt;&lt; #labels &gt;&gt; 'Default Package';		icon: (ListIconLibrary visualFor: #store);		settings: (self settingsWithPrefix: #(store packageDefaults))</body><body package="Store-UI" selector="storePage">storePage	&lt;settingsPage: #(store)&gt;	^ModularSettingsPage new		label: #Store &lt;&lt; #labels &gt;&gt; 'Store';		icon: (ListIconLibrary visualFor: #store);		settings: (self settingsWithPrefix: #(store))</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-store</category><body package="Store-UI" selector="storePrerequisitesBlessingLevel">storePrerequisitesBlessingLevel	&lt;setting: #(store prerequisites blessingLevel)&gt;	| levels choices labels keys |	levels := Store.Policies blessingPolicy blessings asSortedCollection.	choices := levels collect: [:each | each level].	labels := levels collect: [:each | each name].	keys := levels collect: [:each | each level printString asSymbol].	^((EnumerationSetting keys: keys choices: choices labels: labels)			on: Store.Policies prerequisitePolicy aspect: #blessingLevel)		label: '...with blessing level at least'</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="Store-UI" selector="storePrerequisitesPage">storePrerequisitesPage	&lt;settingsPage: #(store prerequisites)&gt;	| version level |	version := EnumerationSettingRadioModule 				on: (self settingWithId: #(#store #prerequisites #versionSelection)).	level := EnumerationSettingModule 				on: (self settingWithId: #(#store #prerequisites #blessingLevel)).	^(ModularSettingsPage new)		label: #Prerequisites &lt;&lt; #labels &gt;&gt; 'Prerequisites';		icon: (ListIconLibrary visualFor: #store);		addModule: version;		addModule: level;		when: version valueHolder valueSatisfies: [:v | v = #latest] enable: level;		useRadioButtonsForEnumerations;		addAllSettings: (self settingsWithPrefix: #(#store #prerequisites)					except: #(#versionSelection #blessingLevel))</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-store</category><body package="Store-UI" selector="storePrerequisitesSeachOrder">storePrerequisitesSeachOrder	&lt;setting: #(store prerequisites searchOrder)&gt;	^((EnumerationSetting 				choices: #(pundlesFirst parcelsFirst)				labels: #('Search bundes and packages first' 'Search parcels first'))			on: Store.Policies prerequisitePolicy aspect: #searchOrder)		label: 'To load #any prerequisite'</body><body package="Store-UI" selector="storePrerequisitesVersionSelection">storePrerequisitesVersionSelection	&lt;setting: #(store prerequisites versionSelection)&gt;	^((EnumerationSetting 				choices: #(ask latest)				labels: #('Always prompt for version' 'Load latest version...'))			on: Store.Policies prerequisitePolicy aspect: #versionSelection)		label: 'When loading a prerequisite'</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="Store-UI" selector="storePropertiesPublishingPolicy">storePropertiesPublishingPolicy	&lt;settingsPage: #(store propertiesPublishing)&gt;	^ModularSettingsPage new		label: #PropertiesPublishingPolicy &lt;&lt; #labels &gt;&gt; 'Properties Publishing Policy';		icon: (ListIconLibrary visualFor: #store);		useRadioButtonsForEnumerations;		settings: (self settingsWithPrefix: #(store propertiesPublishing))</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-store</category><body package="Store-UI" selector="storeRepositories">storeRepositories	&lt;setting: #(store repositories)&gt;	^StoreRepositoryListSetting new</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="Store-UI" selector="storeRepositoriesPage">storeRepositoriesPage	&lt;settingsPage: #(store repositories)&gt;	^StoreRepositoryListPage new		label: #StoreRepositories &lt;&lt; #labels &gt;&gt; 'Repositories';		icon: (ListIconLibrary visualFor: #store);		setting: (self settingWithId: #(store repositories))</body></methods><methods><class-id>Tools.ToolbarIconLibrary class</class-id> <category>resources</category><body package="Store-UI" selector="storeBrowser20x20">storeBrowser20x20	"UIMaskEditor new openOnClass: self andSelector: #storeBrowser20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 8) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 4491 scaledGreen: 6077 scaledBlue: 6605); at: 3 put: (Graphics.ColorValue scaledRed: 6869 scaledGreen: 6869 scaledBlue: 6869); at: 4 put: (Graphics.ColorValue scaledRed: 8191 scaledGreen: 8191 scaledBlue: 4227); at: 5 put: (Graphics.ColorValue scaledRed: 3170 scaledGreen: 3170 scaledBlue: 3170); at: 6 put: Graphics.ColorValue white; at: 7 put: (Graphics.ColorValue scaledRed: 6341 scaledGreen: 6341 scaledBlue: 3170); at: 8 put: (Graphics.ColorValue scaledRed: 2113 scaledGreen: 2113 scaledBlue: 2113); yourself)) usingBits: (ByteArray fromPackedString: 'UUUUUUUUUUUUUP@@UUUUUUUUUUUUUP@@UUUUUUUUUUUUUP@@UUUUUUUUUUUUUP@@UUU7UUUW]UUUUP@@UU]SAUU5LEUUUP@@UU\6AUU3XEUUUP@@UUT@UUUPAUUUUP@@UT\3AEQ3LDUUUP@@UWL6XE\3Y UUUP@@UP@@@E@@@@UUAP@@UUUUUUUUUUUPT@@@UP@EUUT@AUTET@@@TADPUU@QDEAUUP@@@UTQ@@EUDPUUUP@@@UDQAPEQDPUUUP@@@QDRAPDQD UUUP@@TAD UU@QHEUUUP@@UP@EUUT@AUUUUP@@UUUUUUUUUUUUUP@@'))</body><body package="Store-UI" selector="storeBrowser20x20mask">storeBrowser20x20mask	"UIMaskEditor new openOnClass: self andSelector: #storeBrowser20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 12 24 0 0 30 60 0 0 30 60 0 0 12 24 0 0 63 126 0 0 63 126 0 0 63 126 32 0 0 0 80 0 56 56 144 0 124 125 0 0 255 254 0 0 254 254 0 0 254 254 0 0 124 124 0 0 56 56 0 0 0 0 0 0])</body></methods><methods><class-id>Tools.AboutVisualWorksPage class</class-id> <category>system information</category><body package="Store-UI" selector="printBundlesOn:">printBundlesOn: aStream	&lt;systemInformation: 2.1&gt;	aStream nextPutAllText: 'Bundles:' asText allBold.	self printNamesAndVersionsOf: Store.Registry allBundles on: aStream.	aStream cr</body><body package="Store-UI" selector="printPackagesOn:">printPackagesOn: aStream	&lt;systemInformation: 2.2&gt;	aStream nextPutAllText: 'Packages:' asText allBold.	self printNamesAndVersionsOf: Store.Registry allPackages on: aStream.	aStream cr</body></methods><methods><class-id>Tools.VisualLauncherToolDock</class-id> <category>component definitions</category><body package="Store-UI" selector="miniRepositoryManager">miniRepositoryManager	&lt;component: 20 class: #{Store.MiniRepositoryManager} spec: #windowSpec&gt;	^self newTool: Store.MiniRepositoryManager</body></methods><methods><class-id>Tools.MethodListBrowserHelper</class-id> <category>store menus</category><body package="Store-UI-Browser" selector="browseVersions">browseVersions	&lt;menuItem: 'Browse Versions'		icon: nil		nameKey: nil		menu: #(#listMenu)		position: 90.02&gt;	 self selection == nil ifTrue: [ ^self ].	DbRegistry doIfOnlineImage: 		[ ( self targetClassOrNameSpace isForNameSpace or: [ self isData ] )			ifTrue: 				[ self spawningBrowserClass 					browseVersionsOfStaticNamed: self selection name 					in: self selection environment				]			ifFalse: 				[ self spawningBrowserClass 					browseVersionsOfMethodNamed: self selection selector 					in: self selection implementingClass				]		].</body><body package="Store-UI-Browser" selector="findPackage">findPackage	&lt;menuItem: 'Containing package'		icon: nil		nameKey: nil		menu: #(#listMenu)		position: 90.08&gt;	"Check the containing package(s) for the selector."	| target |	self selection == nil ifTrue: [ ^self ].	target := self targetClassOrNameSpace.	target isForNameSpace		ifTrue: [  self findPackageForData: self selection name in: target ]		ifFalse: [ self findPackageForSelector: self selection selector in: target ]</body><body package="Store-UI-Browser" selector="moveToPackage">moveToPackage	"Ask for destination package and move selector(s)." 	&lt;menuItem: 'Move to package...'		nameKey: #moveToPackage		enablement: #hasSelections		indication: nil		menu: #(#listMenu)		position: 90.06&gt;	| dPkg items |	self changeRequest ifFalse: [ ^self ].	( items := self selections ) isEmpty ifTrue: [ ^self ]. 	( dPkg := PackageChooser chooseOrAdd ) isNil ifTrue: [ ^self ].	items do: 		[:item|		item isBindingReference			ifTrue: 				[  Store.XChangeSet current 					moveDataKey: item name 					owner: item environment 					toPackage: dPkg 				]			ifFalse: 				[ Store.XChangeSet current 					moveSelector: item selector 					class: item  implementingClass 					toPackage: dPkg 				]			].	module updateList.</body><body package="Store-UI-Browser" selector="revert">revert	&lt;menuItem: 'Revert' 		icon: nil		nameKey: nil		enablement: #areConnectedAndSelected		indication: nil		menu: #(#listMenu)		position: 90.04&gt;	| md |	self changeRequest ifFalse: [ ^self ].	( md := self selection ) == nil		ifTrue: [ ^self ].	DbRegistry doIfOnlineImage:  		[  (Dialog confirm: 'Do you want to replace this method with the stored version?') 			ifFalse: [ ^self ].	md isBindingReference		ifTrue: [  Store.XChangeSet current revertData: md name owner: md environment ]		ifFalse: [ Store.XChangeSet current revertSelector: md selector class: md implementingClass ].		module updateList.		].</body></methods><methods><class-id>Tools.ProtocolBrowserHelper</class-id> <category>store menus</category><body package="Store-UI-Browser" selector="moveAllToPackage">moveAllToPackage	&lt;menuItem: 'Move to package...'		nameKey: #moveAllToPackage		menu: #(#listMenu)		position: 90.02&gt;	"Move all the methods in the current protocol to a selected package."	| target toPackage |	self selection isNil ifTrue: [ ^self ].	( target := self targetClassOrNameSpace ) == nil ifTrue: [ ^self ].	self changeRequest ifFalse: [ ^self ]. 	toPackage := PackageChooser chooseOrAdd.	toPackage isNil ifTrue: [ ^self ].	target isForNameSpace		ifTrue:			[ ( target organization listAtCategoryNamed: self selection ) do: 				[ :sel | 					Store.XChangeSet current 						moveDataKey: sel						owner: target namedReferent						toPackage: toPackage				]			]		ifFalse:			[ ( target organization listAtCategoryNamed: self selection ) do: 				[ :sel | 					Store.XChangeSet current 						moveSelector: sel						class: target						toPackage: toPackage				]			].	module updateList.</body></methods><methods><class-id>Tools.DebugContextsBrowserHelper</class-id> <category>actions</category><body package="Store-UI-Browser" selector="browseVersions">browseVersions	&lt;menuItem: 'Browse Versions'		icon: nil		nameKey: nil		enablement: #areConnectedAndSelected		indication: nil		menu: #(#contextMenu)		position: 20.09&gt;	 | context selector mclass |	( context := self selection ) == nil 		ifTrue: [ ^false ].	selector := ( self definitionOf: context ) selector.	mclass := context mclass.	( selector == nil ) | ( mclass == nil )		ifTrue: [ ^false ].	DbRegistry doIfOnlineImage: 		[ self spawningBrowserClass 			browseVersionsOfMethodNamed: selector 			in: mclass		].</body><body package="Store-UI-Browser" selector="findPackage">findPackage	&lt;menuItem: 'Containing package'		icon: nil		nameKey: #findPackage		menu: #(#contextMenu)		position: 20.14&gt;	 | context selector mclass pkgs |	context := self selection.	selector := ( self definitionOf: context ) selector.	mclass := context mclass.	( selector == nil ) | ( mclass == nil )		ifTrue: [ ^false ].	pkgs := Registry allContainingPackagesForSelector: selector class: mclass.	self showPackageList: pkgs loaded:true.</body><body package="Store-UI-Browser" selector="revert">revert	&lt;menuItem: 'Revert'		icon: nil		nameKey: nil		enablement: #areConnectedAndSelected		indication: nil		menu: #(#contextMenu)		position: 20.12&gt;	 | context selector mclass |	self changeRequest ifFalse: [ ^self ].	context := self selection.	selector := ( self definitionOf: context ) selector.	mclass := context mclass.	( selector == nil ) | ( mclass == nil )		ifTrue: [ ^false ].	DbRegistry doIfOnlineImage:		[  ( Store.XChangeSet current revertSelector: selector class: mclass )			ifTrue: [ self replaceContext: context forSelector: selector class: mclass ]		].</body></methods><methods><class-id>Tools.SelectorBrowserHelper</class-id> <category>store menus</category><body package="Store-UI-Browser" selector="browseVersions">browseVersions	&lt;menuItem: 'Browse Versions'		icon: nil		nameKey: nil		menu: #(#listMenu)		position: 90.02&gt;	 | target |	self selection == nil ifTrue: [ ^self ].	target := self targetClassOrNameSpace.	DbRegistry doIfOnlineImage: 		[ ( target isForNameSpace or: [ self isData ] )			ifTrue:				[ self spawningBrowserClass 					browseVersionsOfStaticNamed: self selection asString 					in: target				]			ifFalse:				[ self spawningBrowserClass 					browseVersionsOfMethodNamed: self selector asString 					in: target				]		].</body><body package="Store-UI-Browser" selector="findPackage">findPackage	&lt;menuItem: 'Containing package...'		icon: nil		nameKey: nil		menu: #(#listMenu)		position: 90.08&gt;	"Check the containing package(s) for the selector."	| target |	self selection == nil ifTrue: [ ^self ].	target := self targetClassOrNameSpace.	target isForNameSpace		ifTrue: [ self findPackageForData: self selection in: target ]		ifFalse: [ self findPackageForSelector: self selector in: target ]</body><body package="Store-UI-Browser" selector="moveToPackage">moveToPackage	&lt;menuItem: 'Move to package...'		icon: nil		nameKey: nil		menu: #(#listMenu) 		position: 90.06&gt;	"Ask for destination package and move selector(s)."	| dPkg sel target |	self changeRequest ifFalse: [^self].	( sel := self selection ) == nil ifTrue: [ ^self ]. 	( dPkg := PackageChooser chooseOrAdd) isNil ifTrue: [ ^self ].	target := self targetClassOrNameSpace.	target isForNameSpace		ifTrue:  [ Store.XChangeSet current 					moveDataKey: sel owner: target namedReferent toPackage: dPkg ]		ifFalse: [ Store.XChangeSet current moveSelector: self selector class: target toPackage: dPkg ].	module updateList.</body><body package="Store-UI-Browser" selector="revert">revert	&lt;menuItem: 'Revert...'		icon: nil		nameKey: nil		menu: #(#listMenu)		position: 90.04&gt;	| sel owner |	self changeRequest ifFalse: [ ^self ].	( sel := self selection ) == nil		ifTrue: [ ^self ].	owner := self selectedClassOrNameSpace.	DbRegistry doIfOnlineImage:  		[  ( Dialog confirm: 'Do you want to replace this method with the stored version?' ) 			ifFalse: [ ^self ].		( owner isForNameSpace or: [ self isData ] )			ifTrue: [ Store.XChangeSet current revertData: sel owner: owner ]			ifFalse: [ Store.XChangeSet current revertSelector: self selector class: owner ].		module updateList.		].</body></methods><methods><class-id>Tools.ClassesBrowserHelper</class-id> <category>store menus</category><body package="Store-UI-Browser" selector="availableMethods">availableMethods	&lt;menuItem: 'Browse Methods No Longer In Class...'		nameKey: #availableMethods		menu: #(#listMenu)		position: 90.02&gt;	| target |	self dbManager doIfOnlineImage: 		[  target := self targetClassOrNameSpace.		target isForNameSpace ifTrue: [ ^self ].		self spawningBrowserClass browseAvailableMethodsNamed: '*'  in: target		].</body><body package="Store-UI-Browser" selector="browseVersions">browseVersions	&lt;menuItem: 'Versions...'		nameKey: nil		enablement: #areConnectedAndSelected		indication: nil		menu: #(#listMenu)		position: 90.01&gt;	DbRegistry doIfOnlineImage: 		[ self selection notNil			ifTrue: [  self spawningBrowserClass browseVersionsOfNamespaceOrClass: self selection ]		]</body></methods><methods><class-id>Tools.ClassesBrowserHelper</class-id> <category>actions</category><body package="Store-UI-Browser" selector="classesView">classesView	"Spawn a browser with the selected classes/namespaces in the first pane."	&lt;menuItem: 'Classes View...'		icon: nil		nameKey: #classesView		menu: #(#listMenu)		position: 10.08&gt;	self selections == nil ifTrue: [ ^self ].	TabApplicationSystemBrowser openOnClassOrNameSpacesView: 		( self selections collect: [ :sel | Store.PseudoRecord fromModel: sel ] ).</body></methods><methods><class-id>Tools.ClassesBrowserHelper</class-id> <category>store menus</category><body package="Store-UI-Browser" selector="findPackage">findPackage	"Display a list of package that the selected item belongs to."	&lt;menuItem: 'Containing package...'		icon: nil		nameKey: nil		menu: #(#listMenu)		position: 90.04&gt;	| pkgs |	self selection == nil ifTrue: [ ^self ].	pkgs := Registry allContainingPackagesForClassOrNameSpace: self selectedItem.	self showPackageList: pkgs loaded:true.</body><body package="Store-UI-Browser" selector="moveAllToPackage">moveAllToPackage	&lt;menuItem: 'Move all to package...'		icon: nil		nameKey: #moveAllToPackage		menu: #(#listMenu)		position: 90.02&gt; 	| newpackage object |	self selection == nil ifTrue: [ ^self ].	self changeRequest ifFalse: [ ^self ].	( newpackage := PackageChooser chooseOrAdd ) == nil		ifTrue: [ ^self ].	( object := self selectedItem ) == nil			ifTrue: [ ^Dialog warn: 'No longer exists.' for: self interfaceWindow ].	Store.XChangeSet current moveWholeObject: object toPackage: newpackage.</body><body package="Store-UI-Browser" selector="moveDefinitionToPackage">moveDefinitionToPackage	&lt;menuItem: 'Move definition to package...'		icon: nil		nameKey: #moveDefinitionToPackage		menu: #(#listMenu)		position: 90.03&gt; 	| newpackage object |	self selection == nil ifTrue: [ ^self ].	self changeRequest ifFalse: [ ^self ].	( newpackage := PackageChooser chooseOrAdd ) == nil		ifTrue: [ ^self ].	( object := self selectedItem ) == nil			ifTrue: [ ^Dialog warn: 'No longer exists.' for: self interfaceWindow ].	Store.XChangeSet current moveDefinition: object toPackage: newpackage.</body></methods><methods><class-id>Tools.SimpleBrowserModule class</class-id> <category>interface specs</category><body package="Store-UI-Comparitors" selector="buttonSpec">buttonSpec	"UIPainter new openOnClass: self andSelector: #buttonSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 449 232 649 432 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragOkSelector 						#wantToDrag: #dragEnterSelector 						#dragEnter: #dragOverSelector 						#dragOver: #dragStartSelector 						#doDrag: #dropSelector 						#drop: #dragExitSelector 						#dragLeave: ) 					#layout: #(#{Graphics.LayoutFrame} 2 0 1 0 -1 1 -172 1 ) 					#name: #list 					#flags: 4 					#model: #list 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: 						#testChangeSelection: ) 					#tabable: false 					#menu: #listMenu 					#multipleSelections: false 					#selectionType: #normalSelection ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 6 0 -52 1 0 0.5 ) 					#name: #instanceButton 					#model: #meta 					#label: 'instance' 					#select: #instance ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.03 -20 1 0 0.5 ) 					#name: #classButton 					#model: #meta 					#label: 'class' 					#select: #class ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 6 0 -84 1 0 0.5 ) 					#name: #dataButton 					#model: #meta 					#label: 'statics' 					#select: #data ) ) ) )</body></methods><initialize><class-id>Store.AbstractTool</class-id></initialize><initialize><class-id>Store.PublishedPackagePropertiesDialog</class-id></initialize><initialize><class-id>Store.SQLBroker</class-id></initialize><initialize><class-id>Store.PundleParent</class-id></initialize><initialize><class-id>Store.BundleParent</class-id></initialize><initialize><class-id>Store.PackageParent</class-id></initialize><initialize><class-id>Store.ElementView</class-id></initialize><initialize><class-id>Store.DBAccess</class-id></initialize><initialize><class-id>Store.PackageProtocolBrowserHelper</class-id></initialize><initialize><class-id>Store.MergeTool</class-id></initialize><initialize><class-id>Store.GroupGraph</class-id></initialize><initialize><class-id>Store.PrivilegeGraph</class-id></initialize><initialize><class-id>Store.Pundle</class-id></initialize><initialize><class-id>Store.Package</class-id></initialize><initialize><class-id>Store.Bundle</class-id></initialize><initialize><class-id>Store.VersionGraph</class-id></initialize><initialize><class-id>Store.MiniRepositoryManager</class-id></initialize><initialize><class-id>Store.UISettings</class-id></initialize><initialize><class-id>Store.PublishPundleDialog</class-id></initialize><initialize><class-id>Store.PublishFragmentDialog</class-id></initialize><initialize><class-id>Store.PublishPackageDialog</class-id></initialize><initialize><class-id>Store.BlessingDialog</class-id></initialize><initialize><class-id>Store.PundleGraph</class-id></initialize><initialize><class-id>Store.RepublishBundleDialog</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>GenericSettingDescriptor</name><environment>Tools</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id position definingMethod </inst-vars><class-inst-vars></class-inst-vars><imports>			XML.Element			XML.Attribute			</imports><category>Tools-Settings</category><attributes><package>Tools-Settings</package></attributes></class><class><name>Filename</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>osName publicName logicalName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>ClassDescription</name><environment>Core</environment><super>Core.Behavior</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instanceVariables organization </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Override</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sources definition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class><class><name>OverridenMethod</name><environment>Kernel</environment><super>Kernel.Override</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector protocol instVarNames </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class><class><name>GeneralNameSpace</name><environment>Kernel</environment><super>Core.KeyedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>organization bindings specificImports generalImports </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>StoreError</name><environment>Store</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>SourceNodeBuilder</name><environment>XML</environment><super>XML.XMLNodeBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Source Code</category><attributes><package>XML-source</package></attributes></class><class><name>Model</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>DatumDescriptor</name><environment>Store</environment><super>Store.PseudoRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dataKey nameSpaceName className </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Subdefs</category><attributes><package>PackageCategories</package></attributes></class><class><name>ClassChanges</name><environment>Store</environment><super>Store.Changes</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methodChanges metaMethodChanges </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>XChangeSet</name><environment>Store</environment><super>Core.IdentityDictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>other properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>OverridenStatic</name><environment>Kernel</environment><super>Kernel.Override</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class><class><name>True</name><environment>Core</environment><super>Core.Boolean</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>BOSSWriter</name><environment>Kernel</environment><super>Kernel.BOSSTransporter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>headers bodies objects baseIndex currentClass recentClasses nextRecentClass bodySize nilIndex traceClasses registry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class><class><name>SourceFileManager</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>files names writableIndices openIndices currentTarget isPadding sourceFormatters sourceToCopy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>Kernel-Support</package></attributes></class><class><name>XMainChangeSet</name><environment>Store</environment><super>Store.XChangeSet</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>reorganizeSystem specialDoIts </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>NameSpaceChanges</name><environment>Store</environment><super>Store.Changes</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>NameSpaceDescriptor</name><environment>Store</environment><super>Store.PseudoRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fullName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Records</category><attributes><package>PackageCategories</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Notification</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>BrowserTabApplication</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>components canvas browser blankCategoryCanvas indexOfCategoryCanvas icon categoryIcon emphasizer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>False</name><environment>Core</environment><super>Core.Boolean</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>SourceFileFormat</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objectProperties methodProperties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>Kernel-Support</package></attributes></class><class><name>XMLSourceFileFormat</name><environment>Kernel</environment><super>Kernel.SourceFileFormat</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state docName cachedFile cachedParser </inst-vars><class-inst-vars></class-inst-vars><imports>			private XML.*			</imports><category>Kernel-Support</category><attributes><package>XML-source</package></attributes></class><class><name>ChunkSourceFileFormat</name><environment>Kernel</environment><super>Kernel.SourceFileFormat</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>Kernel-Support</package></attributes></class><class><name>SourceScannerNodeBuilder</name><environment>XML</environment><super>XML.XMLNodeBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectors currentFile currentPosition positions changeBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Source Code</category><attributes><package>XML-source</package></attributes></class><class><name>OverridenNameSpace</name><environment>Kernel</environment><super>Kernel.Override</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comment documentation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>BinaryObjectStorage</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream platformDescription initialPosition readerClass writerClass sourceMode readerMap writerMap nextIndex registry versionReaders classVarLists expectCycles mapXeroxToUnicode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class><class><name>ComponentChange</name><environment>Kernel</environment><super>Kernel.Change</super><private>false</private><indexed-type>none</indexed-type><inst-vars>componentType componentName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Component Changes</category><attributes><package>System-Code Component Changes</package></attributes></class><class><name>ComponentDefinitionChange</name><environment>Kernel</environment><super>Kernel.ComponentChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definitionName definitionChange </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Component Changes</category><attributes><package>System-Code Component Changes</package></attributes></class><class><name>ComponentStaticChange</name><environment>Kernel</environment><super>Kernel.ComponentSubDefinitionChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Component Changes</category><attributes><package>System-Code Component Changes</package></attributes></class><class><name>ComponentLoadedChange</name><environment>Kernel</environment><super>Kernel.ComponentChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Component Changes</category><attributes><package>System-Code Component Changes</package></attributes></class><class><name>PundleAccess</name><environment>Store</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packages bundles modelDictionary currentPackage nullPackage containedItemsCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>ClassDescriptor</name><environment>Store</environment><super>Store.PseudoRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fullClassName meta cachedName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Records</category><attributes><package>PackageCategories</package></attributes></class><class><name>Access</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blessingPolicy mergePolicy packagePolicy versionPolicy publishPolicy ownershipPolicy prerequisitePolicy filePolicy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>LoggingTool</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Logging Tool</category><attributes><package>LoggingTool</package></attributes></class><class><name>FileBrowser</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fileName list myPattern selectionState autoRead lastModified currentFileEncoding defaultEncodings patternAspect </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class><class><name>AbstractChangeList</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value listName changes selectionIndex list filter removed filterList filterKey changeDict checkSystem fieldList selectionInList verticalConflicts differencesMode classesDistinct menuBar menus </inst-vars><class-inst-vars></class-inst-vars><imports>			XML.MalformedSignal			</imports><category>Tools-Changes</category><attributes><package>Tools-Changes</package></attributes></class><class><name>TabbedDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>list disturbed subBuilder </inst-vars><class-inst-vars>developmentSpecList runtimeSpecList </class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>OldBrowsers</package></attributes></class><class><name>SettingsManagerPage</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>manager id position label icon children definingMethod </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Settings-UI</category><attributes><package>Tools-Settings</package></attributes></class><class><name>VisualLauncherToolDock</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tools </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector toolDock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>CodeReader</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream pointer format parcelName versionString dateString timeString numNamedObjects numClasses numExtensionMethods definedObjects definedBindings definedExternals classes classSelectors categories packageEnvironment packageUndeclared extensionMethods objectSpaceSize objectSpace symbolNum twoByteSymbolNum stringNum twoByteStringNum byteArrayNum floatNum doubleNum fixedNum largePositiveNum largeNegativeNum mclassNum mclassclassNum refNamObjNum scopeZonesNum defObjOrganizerNum classOrganizerNum arbClassNum arbObjectNum messageSendIndices properties userStringsNum namedObjects namedObjectsNum postLoadObjects streamDir sourceFile hideSource importMaps overriddenExtensions versionSelectionBlock warningSuppressionBlock preReadBlock currentSuperclass mustRecompile lateOperations updates tempSourceFile </inst-vars><class-inst-vars></class-inst-vars><imports>			Behavior.*			</imports><category>System-Code Storage</category><attributes><package>System-Code Storage</package></attributes></class><class><name>CodeComponent</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Components</category><attributes><package>System-Code Components</package></attributes></class><class><name>Parcel</name><environment>Kernel</environment><super>Kernel.CodeComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definedObjects definedClasses definedBindings classSelectors namedObjects dirty loaded </inst-vars><class-inst-vars>parcels classParcelMap parcelFileInfoCache parcelFileDirectoryCache </class-inst-vars><imports></imports><category>System-Code Components</category><attributes><package>System-Code Components</package></attributes></class><class><name>ExternalDatabaseSession</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection query queryFragments bindInput bindTemplate bindOutput useNamedOutputBinding bindValues resultTemplate allocateForEachRow blockFactor numColumns columnDescriptions rowAdaptors rowBuffersHolder bufferIndex answerStream currentRow </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>ClassExtensionDescriptor</name><environment>Store</environment><super>Store.ClassDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Records</category><attributes><package>PackageCategories</package></attributes></class><class><name>ChangeSetManager</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>listModel listMenu menuBar currentSetIcon </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Changes</category><attributes><package>Tools-Changes</package></attributes></class><class><name>ChangeSet</name><environment>Kernel</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objectChanges objectRemoves componentChanges specialDoIts initializationOrder </inst-vars><class-inst-vars>dependents </class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>System-Changes</package></attributes></class><class><name>NamedChangeSet</name><environment>Tools</environment><super>Kernel.ChangeSet</super><private>false</private><indexed-type>none</indexed-type><inst-vars>changeSetName lastChange lastFileOut lastFileOutName dirty comment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>System-Changes</package></attributes></class><class><name>MultiSelectionSequenceView</name><environment>UI</environment><super>UI.SequenceView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selections lastSelectionIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>PropertyChange</name><environment>Kernel</environment><super>Kernel.ComponentChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>property value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Component Changes</category><attributes><package>System-Code Component Changes</package></attributes></class><class><name>ComponentDescription</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dbIdentifier id componentName fileName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>BundleDescription</name><environment>Store</environment><super>Store.ComponentDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>ConnectionDialog</name><environment>Database</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connectionProfileListHolder connectionProfileHolder databaseListHolder databaseHolder environmentListHolder environmentHolder userNameListHolder userNameHolder passwordHolder currentProfileHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Connection Dialog</category><attributes><package>Database</package></attributes></class><class><name>LDMElementView</name><environment>Lens</environment><super>UI.CompositeView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents element hasIn hasOut povIcons firstPovIconX touchFlag selected label recycle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Components</category><attributes><package>LDM-Framework</package></attributes></class><class><name>ExternalDatabaseConnection</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transaction username password environment transactionCoordinator cachedSession isolationLevel </inst-vars><class-inst-vars>environmentMap xif xifMap </class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>MethodDescriptor</name><environment>Store</environment><super>Store.PseudoRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector protocol fullClassName meta </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Subdefs</category><attributes><package>PackageCategories</package></attributes></class><class><name>LDMIndentedListBuilder</name><environment>Lens</environment><super>Lens.LDMAbstractVisualBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bottom referenceConnections </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Browsing</category><attributes><package>LDM-Framework</package></attributes></class><class><name>Metaclass</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thisClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>SimpleBrowserModule</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>list forcedValue nextModule browser selectionCandidates helpers deselectNext cachedComponents allowsMultiSelect specName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>Tools-Name Spaces</package></attributes></class><class><name>ConnectionProfile</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name driverClassName environment userName password originalName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Connection Dialog</category><attributes><package>Database</package></attributes></class><class><name>LensBrowsingToolModel</name><environment>Lens</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Support</category><attributes><package>LDM-Framework</package></attributes></class><class><name>PackagePropertiesDialog</name><environment>UI</environment><super>UI.TabbedDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>package properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>OldBrowsers</package></attributes></class><class><name>FullSystemBrowser</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>componentDictionary components coordinator text inBatchMode meta defType toolBar selectionDictionary disableBatchUpdates ignoreNamepaceChanges listMenuMap menuBarMenuMap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>Tools-Name Spaces</package></attributes></class><class><name>TabApplicationSystemBrowser</name><environment>Tools</environment><super>Tools.FullSystemBrowser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tabApplication </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>BOSSReader</name><environment>Kernel</environment><super>Kernel.BOSSTransporter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>readingClasses headers objects baseIndex recentClasses compiledCode deferredSends </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class><class><name>PackageDescription</name><environment>Store</environment><super>Store.ComponentDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>DictionaryInspector</name><environment>Tools</environment><super>Tools.Inspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Inspector</category><attributes><package>Tools-Inspector</package></attributes></class><class><name>PundleModel</name><environment>Store</environment><super>Kernel.CodeComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dbInfo readonly </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>BundleModel</name><environment>Store</environment><super>Store.PundleModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>PackageModel</name><environment>Store</environment><super>Store.PundleModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>models </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>BrowserHelper</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>module selectionId attribute </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>Tools-Name Spaces</package></attributes></class><class><name>ClassesBrowserHelper</name><environment>Tools</environment><super>Tools.BrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lastSelection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>NameSpaceCategoryBrowserHelper</name><environment>Tools</environment><super>Tools.ClassesBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>ProtocolBrowserHelper</name><environment>Tools</environment><super>Tools.BrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>MethodsBrowserHelper</name><environment>Tools</environment><super>Tools.BrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>Tools-Name Spaces</package></attributes></class><class><name>SelectorBrowserHelper</name><environment>Tools</environment><super>Tools.MethodsBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>DebugContextsBrowserHelper</name><environment>Tools</environment><super>Tools.MethodsBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stackSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>Tools-Programming</package></attributes></class><class><name>MethodListBrowserHelper</name><environment>Tools</environment><super>Tools.MethodsBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label baseList initialSelection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>OverridenClass</name><environment>Kernel</environment><super>Kernel.Override</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>comment documentation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class><class><name>DatabaseConnectionInformation</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundle dbIdentifier dbTrace changeSet versionString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>DatabaseConnectionBundleInformation</name><environment>Store</environment><super>Store.DatabaseConnectionInformation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contentDescriptions fileDescriptions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>LogEnvironment</name><environment>Tools</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>debugStream debugCategories debugClasses trace logFileName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Logging Tool</category><attributes><package>LoggingTool</package></attributes></class><class><name>ComponentSelectorChange</name><environment>Kernel</environment><super>Kernel.ComponentSubDefinitionChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector meta </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Component Changes</category><attributes><package>System-Code Component Changes</package></attributes></class><class><name>List</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents collection limit collectionSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Collections</category><attributes><package>UIBasics-Collections</package></attributes></class><class><name>SequenceController</name><environment>UI</environment><super>UI.ControllerWithMenu</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyboardProcessor outside searchString keyboardHook doStringSearching dispatcher dragDropCallbacks selectOnDownWithDrag autoSelect </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>UIBasics-Controllers</category><attributes><package>UIBasics-Controllers</package></attributes></class><class><name>Emphasizer</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>CodeWriter</name><environment>Kernel</environment><super>Kernel.ObjectTracer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definedObjects classes extendedClasses extensionMethods exclusionset definedBindings scopeZones currentClass objectSpace analysisTracer symbolNum stringNum byteArrayNum floatNum doubleNum largePositiveNum largeNegativeNum mclassNum mclassclassNum refNamObjNum scopeZonesNum defObjOrganizerNum classOrganizerNum arbObjectNum arbClassNum stream sourceStream sourceName hideOnLoad pointer currentKey properties prerequisites namedObjects newSourceKeys dateString timeString scratchDictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Storage</category><attributes><package>System-Code Storage</package></attributes></class></st-source>