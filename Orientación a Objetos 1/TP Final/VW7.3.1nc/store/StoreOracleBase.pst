<?xml version="1.0"?><st-source><!-- Name: StoreOracleBaseNotice: Copyright © 1999-2005 Cincom Systems, Inc.  All Rights Reserved.Comment: This parcel contains the interface that allows StORE to work with an Oracle database.DbIdentifier: bear73DbTrace: 53312DevelopmentPrerequisites: #(#(#any 'StoreBase' ''))PackageName: StoreOracleParcel: #('StoreOracleBase')ParcelName: StoreOracleBasePrerequisiteParcels: #(#('StoreBase' ''))PrintStringCache: (7.3.1 - 1.0,bobw)Version: 7.3.1Date: 5:51:10 pm April 10, 2005 --><time-stamp>From VisualWorks®, 7.3.1 of April 10, 2005 on April 10, 2005 at 5:51:10 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SQLAssistOracle</name><environment>Store</environment><super>Store.SQLAssist</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreOracle</category><attributes><package>StoreOracle</package></attributes></class><comment><class-id>Store.SQLAssistOracle</class-id><body>Sql generator for Oracle. At the moment, no differences between Oracle and the default.</body></comment><class><name>OracleBroker</name><environment>Store</environment><super>Store.SQLBroker</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreOracle</category><attributes><package>StoreOracle</package></attributes></class><comment><class-id>Store.OracleBroker</class-id><body>Interface to Oracle database.Class Variables:	Signals	&lt;SignalCollection of: Signal&gt;  Oracle signals</body></comment><shared-variable><name>Signals</name><environment>Store.OracleBroker</environment><private>false</private><constant>false</constant><category>signals</category><attributes><package>StoreOracle</package></attributes></shared-variable><methods><class-id>Store.OracleBroker class</class-id> <category>error handling</category><body package="StoreOracle" selector="alreadyExistErrors">alreadyExistErrors	^ Array with: self objectAlreadyExistisErrorNumber</body><body package="StoreOracle" selector="brokerSignals">brokerSignals	"self brokerSignals"	^Signals isNil 		ifTrue: [ Signals := self signalCollection]		ifFalse: [ Signals ]</body><body package="StoreOracle" selector="cannotCloseCursorErrorCode">cannotCloseCursorErrorCode	"Answer a number that database uses in case whe the cursor cannot be closed."	^ 1041</body><body package="StoreOracle" selector="doesNotExistErrors">doesNotExistErrors	^ Array with: self objectAlreadyGoneErrorNumber			with: self specifiedindexDoesntExistisErrorNumber 			with: self sequenceDoesNotExistErrorNumber			with: self tableSpaceDoesntExistisErrorNumber</body><body package="StoreOracle" selector="grantRevokeToFromYourselfError">grantRevokeToFromYourselfError	^ 1749</body><body package="StoreOracle" selector="invalidObjectErrorNumber">invalidObjectErrorNumber	^ self objectAlreadyGoneErrorNumber</body><body package="StoreOracle" selector="isNotLoggedOnSignal:">isNotLoggedOnSignal: exception	^ ( exception parameter notNil  and: 		[ exception parameter isEmpty not and: 			[  self notLoggedOnErrorCode = exception parameter first dbmsErrorCode abs ]		] )</body><body package="StoreOracle" selector="isServerDeadSignals:">isServerDeadSignals: exception	^ ( exception parameter notNil  and: [ exception parameter isEmpty not and: [  self serverDiedErrorCodes includes: exception parameter first dbmsErrorCode abs]])</body><body package="StoreOracle" selector="isSessionInvalidSignal:">isSessionInvalidSignal: ex	^ ( ex parameter isNil and:[ ex getSignal = self connectionClass invalidSessionStateSignal ]).</body><body package="StoreOracle" selector="notLoggedOnErrorCode">notLoggedOnErrorCode	"Answer a number that database uses in case where the user is not logged on.	This could happen when the server kicked us off but is still on line."	^ 1012</body><body package="StoreOracle" selector="objectAlreadyExistisErrorNumber">objectAlreadyExistisErrorNumber	^ 955</body><body package="StoreOracle" selector="objectAlreadyGoneErrorNumber">objectAlreadyGoneErrorNumber	^942</body><body package="StoreOracle" selector="reconnectSignals:">reconnectSignals: ex	^( ( self isSessionInvalidSignal: ex ) or: [  self isServerDeadSignals: ex ] )			or: [ self isNotLoggedOnSignal: ex ]</body><body package="StoreOracle" selector="sequenceDoesNotExistErrorNumber">sequenceDoesNotExistErrorNumber	^ 2289</body><body package="StoreOracle" selector="serverDiedErrorCodes">serverDiedErrorCodes	"Answer a number that database uses in case of 	server going away while we are connected."	^ Set with: 3113 with: 3114</body><body package="StoreOracle" selector="signalCollection">signalCollection	^ (SignalCollection new: 6)		add: self connectionClass unableToExecuteSQLSignal;		add: self connectionClass unableToOpenCursorSignal;		add: CProcedureType externalAccessFailedSignal;		add: self connectionClass invalidSessionStateSignal;		add: self connectionClass unableToPrepareSignal;		add: self connectionClass unableToCloseCursorSignal;		yourself</body><body package="StoreOracle" selector="specifiedindexDoesntExistisErrorNumber">specifiedindexDoesntExistisErrorNumber	^ 1418</body><body package="StoreOracle" selector="tableSpaceAlreadyExistisErrorNumber">tableSpaceAlreadyExistisErrorNumber	^ 1543</body><body package="StoreOracle" selector="tableSpaceDoesntExistisErrorNumber">tableSpaceDoesntExistisErrorNumber	^ 959</body><body package="StoreOracle" selector="userDoesNotExistErrorNumber">userDoesNotExistErrorNumber	^ 1918</body></methods><methods><class-id>Store.OracleBroker class</class-id> <category>create objects</category><body package="StoreOracle" selector="createDatabaseSequence:">createDatabaseSequence: aClass 	self performCreate: [	self processSQL: 'CREATE SEQUENCE ' , ( self sequenceNameWithPrefix: aClass)]		for: aClass name</body><body package="StoreOracle" selector="createDatabaseTable:">createDatabaseTable: aClass	"Creates a corresponding database table."	| aKeyCollection aStream  |	aKeyCollection := OrderedCollection new.	aStream := (String new: 100) writeStream.	aStream nextPutAll: 			(self createDatabaseTableColumnsFor: aClass 									keyNames: aKeyCollection).	aStream nextPutAll: 			(self createTablePrimaryKeySectionFor: aClass 									keys: aKeyCollection).	self createTable: (self tableNameWithPrefix: aClass) 			columns: '(', aStream contents.</body><body package="StoreOracle" selector="createMethodRetrievalIndex:">createMethodRetrievalIndex: aClass	"self createMethodRetrievalIndex"	self createIndex: self tablePrefix , '.',  aClass indexName			onTable: (self tableName: aClass) 			columns: aClass indexColumnNames</body><body package="StoreOracle" selector="createTablePrimaryKeySectionFor:keys:">createTablePrimaryKeySectionFor: aClass keys: aKeyCollection	| aStream pkStream str |	aStream := (String new: 100 ) writeStream.	aKeyCollection isEmpty 		ifFalse: 			[aStream nextPutAll: '  PRIMARY KEY ('.			pkStream := (String new: 100) writeStream.			aKeyCollection do: [:each | pkStream nextPutAll: each , ', '].			pkStream skip: -2.			aStream nextPutAll: pkStream contents , ')'.			str := aClass indexParameters.			str notNil 				ifTrue: 					[aStream cr.					aStream nextPutAll: '  USING INDEX '; nextPutAll: str; space]			].		aStream nextPutAll: ')'; cr.		aStream nextPutAll: 'PCTFREE 10 PCTUSED 60 '.		str := aClass tableSpaceName.		str notNil			ifTrue: 				[aStream cr.				aStream nextPutAll: 'TABLESPACE '. 				aStream nextPutAll: str; space].		str := aClass storageParameters.		str notNil 			ifTrue: 				[aStream cr.				aStream nextPutAll: str]			ifFalse: 	[aStream skip: -2.]. 	^ aStream contents.</body><body package="StoreOracle" selector="installPhysicalSpaces">installPhysicalSpaces	"Create the physical Oracle table spaces used by Store."	| path  fileName1 fileName2 |	DbRegistry goToScript		ifFalse: [ (Dialog confirm: 'Create tablespaces? (Answer no only if they have already been created)')  ifFalse: [ ^true ]].	path := Dialog request: 'Please, enter directory for the table spaces.' initialAnswer: ''.	path isEmpty ifTrue: [ ^nil ].	fileName1 := path asFilename constructString: self fileNameForBlobs, '.dbf'.	fileName2 := path asFilename constructString: self fileNameForClasses, '.dbf'.	^[ 	 Transcript cr; show: 'Creating tablespace ' , self fileNameForClasses.		self  processSQL: 		'CREATE TABLESPACE ', self fileNameForClasses, 		' DATAFILE ''',  fileName2,''' 		SIZE ', self spaceForClasses, '  REUSE		DEFAULT STORAGE (INITIAL 1M NEXT 512K PCTINCREASE 1)'.				Transcript cr; show: 'Creating tablespace ' , self fileNameForBlobs.		self processSQL: 		'CREATE TABLESPACE ', self fileNameForBlobs, 		' DATAFILE ''',  fileName1,''' 		SIZE ', self spaceForBlobs, '  REUSE		DEFAULT STORAGE (INITIAL 1M NEXT 512K PCTINCREASE 1)'.		self processSQL:		'ALTER DATABASE DATAFILE ''', fileName1,'''   AUTOEXTEND ON'.		self processSQL:		'ALTER DATABASE DATAFILE ''', fileName2,'''  AUTOEXTEND ON'.		true	] 	on: Error 	do: [ :exp |  		exp parameter first dbmsErrorCode == self tableSpaceAlreadyExistisErrorNumber 			ifTrue: [ Transcript show: exp description.  true]			ifFalse: [ Dialog warn: exp description. nil ]		].</body><body package="StoreOracle" selector="spaceForBlobs">spaceForBlobs	^ '16M'</body><body package="StoreOracle" selector="spaceForClasses">spaceForClasses	^ '32M'</body></methods><methods><class-id>Store.OracleBroker class</class-id> <category>accessing</category><body package="StoreOracle" selector="databaseName">databaseName	^'Oracle'</body><body package="StoreOracle" selector="fullTableName:">fullTableName: aClass	^self tableNameWithPrefix: aClass</body><body package="StoreOracle" selector="getBlobData:">getBlobData: aData	^ aData</body><body package="StoreOracle" selector="indexNameFor:">indexNameFor: aClass	^ (self tableNameWithPrefix: aClass), aClass indexName.</body><body package="StoreOracle" selector="needsSequenceFor:">needsSequenceFor: aClass	^ aClass needsSequence</body></methods><methods><class-id>Store.OracleBroker class</class-id> <category>private-accessing</category><body package="StoreOracle" selector="dismissSession:">dismissSession: aSession	[aSession dismiss]	on: (SignalCollection			with: self connectionClass unableToCloseCursorSignal			with: self connectionClass unableToCancelCursorSignal)	do: [ :ex | ex return ]</body><body package="StoreOracle" selector="getNewSession">getNewSession	| session |	session := self connection getSession.	session maxLongBytes: self maxLongBytes.	^session</body><body package="StoreOracle" selector="resetSessionCursorFor:">resetSessionCursorFor: aSession	aSession notNil 		ifTrue: 			[ aSession cursor: nil.]</body><body package="StoreOracle" selector="sequenceGeneratorSession:forClass:">sequenceGeneratorSession: session forClass: aClass	^self safelyExecuteBlock: [		session isNil			ifTrue: 				[ | newSession |				newSession := self getNewSession.				newSession bindOutput: nil;					bindInput: nil;					prepare: ( self nextIDQuery: aClass );					blockFactor: 1.				newSession				]			ifFalse:				[ session ]	]</body></methods><methods><class-id>Store.OracleBroker class</class-id> <category>drop objects</category><body package="StoreOracle" selector="dropDatabase:">dropDatabase: dbName	Transcript cr; show: 'Dropping tablespace ' , dbName.	self performDrop: [ self processSQL:  ('DROP TABLESPACE ', dbName, ' INCLUDING CONTENTS')]		for: dbName.	Transcript show: 'Tablespace dropped'; cr.</body><body package="StoreOracle" selector="dropDatabaseFor:">dropDatabaseFor: aClass	self dropDatabase: aClass databaseName</body><body package="StoreOracle" selector="dropIndexForClass:">dropIndexForClass: aClass	self dropIndexForClass: aClass index: aClass indexName.</body><body package="StoreOracle" selector="dropIndexForClass:index:">dropIndexForClass: aClass index: aName	self performDrop:[self processSQL: 'DROP INDEX ' , self tablePrefix, '.', aName]		for: (aClass name, aName)</body><body package="StoreOracle" selector="dropSequenceForClass:">dropSequenceForClass: aClass 	Transcript cr; show: 'Dropping sequence for ' , aClass name.	self performDrop: [self processSQL: 'DROP SEQUENCE ' , (self tableNameWithPrefix: aClass), 'Seq'.]		for: aClass name.</body><body package="StoreOracle" selector="dropTableForClass:">dropTableForClass: aClass 	self dropTable: (self tableNameWithPrefix: aClass)</body><body package="StoreOracle" selector="dropUser:">dropUser: aName	Transcript cr; show: 'Dropping user ' , aName.	self performDrop: [ self processSQL:  ('DROP USER ', aName )]		for: aName</body><body package="StoreOracle" selector="dropViewForClass:">dropViewForClass: aClass	self dropView: (self tableNameWithPrefix: aClass)</body></methods><methods><class-id>Store.OracleBroker class</class-id> <category>grant statements</category><body package="StoreOracle" selector="grant:on:columnList:to:">grant: aPermissionList on: aTableName columnList: aColumnList  to: aUserNameList	"Assigns permissions to users."	| aStream  |	aStream := (String new: 100) writeStream.	aStream nextPutAll:  'GRANT ' .	aPermissionList do: [ :each | aStream nextPutAll: (each, ', ')].	aStream skip: -2.	aStream nextPutAll:  ' ( '.	aColumnList do: [ :each | aStream nextPutAll: (each, ', ')].	aStream skip: -2.	aStream nextPutAll:  ' ) '.	aStream nextPutAll:  (' ON ' , aTableName ).	aStream nextPutAll:  ( ' TO ').	aUserNameList do: [ :each | aStream nextPutAll: (each, ', ')].	aStream skip: -2.	self processGrantStatement: aStream contents.</body><body package="StoreOracle" selector="processGrantStatement:">processGrantStatement: aString	[		self processSQL:  aString	]	on:  self connectionClass unableToExecuteSQLSignal	do: [ :exception | 		((exception parameter at: 1) dbmsErrorCode == self grantRevokeToFromYourselfError) 			ifTrue: [ exception return ]			ifFalse: [Dialog warn: (self messageFor: exception).]	].</body></methods><methods><class-id>Store.OracleBroker class</class-id> <category>queries</category><body package="StoreOracle" selector="newSQLFor:">newSQLFor: aClass	^ self sqlAssistClass 		newSQLFor: aClass 		table: ( self tableNameWithPrefix: aClass )</body><body package="StoreOracle" selector="nextIDQuery:">nextIDQuery: aClass	^( ( self sqlAssistClass newSQLFor: self table: 'sys.dual' )			select:   ( Array with: ( self sequenceNameWithPrefix: aClass), '.NextVal ')  ).</body><body package="StoreOracle" selector="sqlAssistClass">sqlAssistClass	^SQLAssistOracle</body></methods><methods><class-id>Store.OracleBroker class</class-id> <category>private</category><body package="StoreOracle" selector="typeToStringMap">typeToStringMap	"Etb Modified - PHM	Adds new types:		- PrimaryKeyInteger		- PrimaryKeyString"	^ (Dictionary new )		at: #String put: 'Varchar (255)';		at: #PrimaryKey put: 'Integer NOT NULL';		at: #PrimaryKeyInteger put: 'Integer NOT NULL';	 	at: #PrimaryKeyString put: 'Varchar (255) NOT NULL';	 	at: #PrimaryKeyShortString put: 'Varchar (50) NOT NULL';	 	at: #Text put: 'Long';	 	at: #Long put: 'Long';	 	at: #BinData put: 'Long Raw';	 	at: #Integer put: 'Integer';	 	at: #PrimaryKeyChar put: 'char(1)';		at: #Char put: 'char (1)';		at: #String32 put: 'varchar (32)' ;		yourself.</body></methods><methods><class-id>Store.OracleBroker class</class-id> <category>sql processing</category><body package="StoreOracle" selector="safelyExecuteBlock:">safelyExecuteBlock: aBlock 	"Catch errors that arise when server dies while we are still connected. 	If a such error is detected, we close connection and try to reconnect."	( ( DbRegistry connectionOrNil == nil ) or: [ DbRegistry isOnline not ] )		ifTrue: [ ^self currentlyNotConnectedSignal raiseSignal ].	^ [ [ Cursor database showWhile: [ aBlock value ] ] 		on: self brokerSignals		do: 	[ :ex | 			DbRegistry debug ifTrue: [ self hardHalt].			(self reconnectSignals: ex )				ifTrue: 					[DbRegistry goOffLine.					(Dialog confirm: 'Currently disconnected. Do you want to reconnect?')						ifTrue: 							[DbRegistry reconnect ifTrue: [ ex retry]].					self currentlyNotConnectedSignal raiseSignal ].			ex pass		] ] on: UnhandledException do: 			[ :ex | 			( ControlInterrupt handles: ex parameter ) 				ifTrue: [ ex pass ].			self processPublishException: ex  note: ''.			self currentlyNotConnectedSignal raiseSignal.			^nil			].</body></methods><methods><class-id>Database.OracleConnection class</class-id> <category>accessing</category><body package="StoreOracle" selector="storeBroker">storeBroker	"Answer a broker class for Store"	^Store.OracleBroker</body></methods><methods><class-id>Database.OracleConnection</class-id> <category>private-accessing</category><body package="StoreOracle" selector="nilParams">nilParams		self lda: nil</body></methods><methods><class-id>Database.OracleConnection</class-id> <category>accessing</category><body package="StoreOracle" selector="storeBroker">storeBroker	^Store.OracleBroker</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>OracleConnection</name><environment>Database</environment><super>Database.ExternalDatabaseConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>henvHolder herrHolder hsvcctxHolder hsrvrHolder hsessHolder htxnHolder executionMode transactionMode authenticationMode </inst-vars><class-inst-vars>signalMap libraryInitialized </class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><class><name>SQLAssist</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tableName tableClass sqlStream alias </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Broker</category><attributes><package>Store-DB-Broker</package></attributes></class><class><name>SQLBroker</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Broker</category><attributes><package>Store-DB-Broker</package></attributes></class></st-source>