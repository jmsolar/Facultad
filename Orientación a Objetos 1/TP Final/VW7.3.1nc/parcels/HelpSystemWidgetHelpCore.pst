<?xml version="1.0"?><st-source><!-- Name: Arbor Help System Widget Help CoreNotice: Copyright © 2005 Cincom Systems, Inc.  All Rights Reserved.Comment: The core classes supporting widget-based help (formerly known as 'real-time help', or RTH).  Contains the detection and dispatching engine, but no help lookup/maintenance facilities.  This module is useful standalone for applications that wish to serve their own help, possibly through dynamic help text generation.DbIdentifier: bear73DbTrace: 52924PackageName: Arbor Help System Widget Help CoreParcel: #('Arbor Help System Widget Help Core')ParcelName: Arbor Help System Widget Help CorePrintStringCache: (7.4 - 1.0,bobw)Version: 7.3.1Pre-Load Block: 	[ :pkg |  ]Post-Load Block: 	[ :pkg |  #{VWHelp.AHSUtils} value postLoadActionFor:pkg]Date: 7:17:55 pm April 10, 2005 --><time-stamp>From VisualWorks®, 7.3.1 of April 10, 2005 on April 10, 2005 at 7:17:55 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>VWHelp</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.XML.*			private Smalltalk.*			</imports><category>Help-Namespace</category><attributes><package>Arbor Help System Widget Help Core</package></attributes></name-space><class><name>AHSWHCBalloonSensor</name><environment>VWHelp</environment><super>UI.WindowSensor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Widget Help-Core</category><attributes><package>Arbor Help System Widget Help Core</package></attributes></class><comment><class-id>VWHelp.AHSWHCBalloonSensor</class-id><body>Copyright Ó 1994, 1995 Arbor Intelligent Systems, Inc.This class is the sensor for AHSBalloon window.  It dispatches activity to the balloon windows parent while the balloon window is open.</body></comment><class><name>AHSBalloonTextComposition</name><environment>VWHelp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ct box w h maxWidth lines pt sz wb shift widget style processor text </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Widget Help-Core</category><attributes><package>Arbor Help System Widget Help Core</package></attributes></class><comment><class-id>VWHelp.AHSBalloonTextComposition</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:ct	&lt;ClassOfVariable&gt;	description of variable's functionbox	&lt;ClassOfVariable&gt;	description of variable's functionw	&lt;ClassOfVariable&gt;	description of variable's functionh	&lt;ClassOfVariable&gt;	description of variable's functionmaxWidth	&lt;ClassOfVariable&gt;	description of variable's functionlines	&lt;ClassOfVariable&gt;	description of variable's functionpt	&lt;ClassOfVariable&gt;	description of variable's functionsz	&lt;ClassOfVariable&gt;	description of variable's functionwb	&lt;ClassOfVariable&gt;	description of variable's functionshift	&lt;ClassOfVariable&gt;	description of variable's functionwidget	&lt;ClassOfVariable&gt;	description of variable's functionstyle	&lt;ClassOfVariable&gt;	description of variable's functionprocessor	&lt;ClassOfVariable&gt;	description of variable's functiontext	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>AHSUtils</name><environment>VWHelp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Widget Help-Core</category><attributes><package>Arbor Help System Widget Help Core</package></attributes></class><comment><class-id>VWHelp.AHSUtils</class-id><body>Copyright Ó 1994 Arbor Intelligent Systems, Inc.Assorted utilities for the help system.</body></comment><class><name>AHSWHCEventDispatcher</name><environment>VWHelp</environment><super>UI.EventDispatcher</super><private>false</private><indexed-type>none</indexed-type><inst-vars>helpProcessor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Widget Help-Core</category><attributes><package>Arbor Help System Widget Help Core</package></attributes></class><comment><class-id>VWHelp.AHSWHCEventDispatcher</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:helpProcessor	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>AHSWHCGlobalHelp</name><environment>VWHelp</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Widget Help-Core</category><attributes><package>Arbor Help System Widget Help Core</package></attributes></class><comment><class-id>VWHelp.AHSWHCGlobalHelp</class-id><body>Copyright Ó 1994, 1995 Arbor Intelligent Systems, Inc.This class provides a window which displays help for all open windows.Instance Variables:Class Variables:BroadcastModel	&lt;ClassOfVariable&gt;	description of variable''s function</body></comment><class><name>AHSWHCProcessor</name><environment>VWHelp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>window helpText focusChanged lastFocus lastState waitingOnBalloon extendedHelpRequest editHelpRequest toggleBubbleRequest </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Widget Help-Core</category><attributes><package>Arbor Help System Widget Help Core</package></attributes></class><comment><class-id>VWHelp.AHSWHCProcessor</class-id><body>Copyright © 1994, 1995 Arbor Intelligent Systems, Inc.This class is responsible for keeping track of where the cursor is located and whether help for the widget that contains the cursor (if any) should be displayed.Instance Variables:window	&lt;ClassOfVariable&gt;	description of variable's functionhelpText	&lt;ClassOfVariable&gt;	description of variable's functionfocusChanged	&lt;ClassOfVariable&gt;	description of variable's functionlastFocus	&lt;ClassOfVariable&gt;	description of variable's functionlastState	&lt;ClassOfVariable&gt;	description of variable's functionwaitingOnBalloon	&lt;ClassOfVariable&gt;	description of variable's functionextendedHelpRequest	&lt;ClassOfVariable&gt;	description of variable's functioneditHelpRequest	&lt;ClassOfVariable&gt;	description of variable's functiontoggleBubbleRequest	&lt;ClassOfVariable&gt;	description of variable's functionClass Variables:AHSIcon	&lt;ClassOfVariable&gt;	description of variable''s functionBalloon	&lt;ClassOfVariable&gt;	description of variable''s functionBalloonDisplayDelay	&lt;ClassOfVariable&gt;	description of variable''s functionBalloonHelpEnabledModel	&lt;ClassOfVariable&gt;	description of variable''s functionBalloonKillDelay	&lt;ClassOfVariable&gt;	description of variable''s functionCachedBalloonText	&lt;ClassOfVariable&gt;	description of variable''s functionHelpEnabledModel	&lt;ClassOfVariable&gt;	description of variable''s functionRegisteredMenuView	&lt;ClassOfVariable&gt;	description of variable''s functionRestrictBalloonToCondensedText	&lt;ClassOfVariable&gt;	description of variable''s functionTmpStorage	&lt;ClassOfVariable&gt;	description of variable''s functionWidgetHelpEnabledModel	&lt;ClassOfVariable&gt;	description of variable''s function</body></comment><class><name>AHSWHCTransientWindow</name><environment>VWHelp</environment><super>UI.TransientWindow</super><private>false</private><indexed-type>none</indexed-type><inst-vars>spawningView </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Widget Help-Core</category><attributes><package>Arbor Help System Widget Help Core</package></attributes></class><comment><class-id>VWHelp.AHSWHCTransientWindow</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:spawningView	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>AHSWHCBalloonWindow</name><environment>VWHelp</environment><super>Graphics.Window</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parentWindow mapStatus </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Widget Help-Core</category><attributes><package>Arbor Help System Widget Help Core</package></attributes></class><comment><class-id>VWHelp.AHSWHCBalloonWindow</class-id><body>Copyright Ó 1994, 1995 Arbor Intelligent Systems, Inc.This class is used to display balloon help.Instance Variables:parentWindow	&lt;ClassOfVariable&gt;	description of variable's functionmapStatus	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>AHSWHCWeakValueHolder</name><environment>VWHelp</environment><super>UI.ValueHolder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>interests selectors accessLock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Widget Help-Core</category><attributes><package>Arbor Help System Widget Help Core</package></attributes></class><comment><class-id>VWHelp.AHSWHCWeakValueHolder</class-id><body>Copyright Ó 1994, 1995 Arbor Intelligent Systems, Inc.This class is an implementation of a value holder with weak interests.  Used for AHSLauncher allowEditingModel and helpEnabledModel so that AHSWHCProcessor instances don't hang around.Instance Variables:	interests		&lt;WeakArray&gt;	selectors		&lt;Array&gt;	accessLock 	&lt;RecursionLock&gt;</body></comment><class><name>AHSWHCWindowSensor</name><environment>VWHelp</environment><super>UI.ApplicationWindowSensor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>helpProcessor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Widget Help-Core</category><attributes><package>Arbor Help System Widget Help Core</package></attributes></class><comment><class-id>VWHelp.AHSWHCWindowSensor</class-id><body>Copyright Ó 1994 Arbor Intelligent Systems, Inc.This class is responsible for storing the help processor and notifying the help processor when it's time to process widget help.Instance Variables:	helpProcessor &lt;AHSWHCProcessor&gt;  The help processor associated to the window</body></comment><shared-variable><name>BroadcastModel</name><environment>VWHelp.AHSWHCGlobalHelp</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Arbor Help System Widget Help Core</package></attributes></shared-variable><shared-variable><name>RestrictBalloonToCondensedText</name><environment>VWHelp.AHSWHCProcessor</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Arbor Help System Widget Help Core</package></attributes></shared-variable><shared-variable><name>BalloonHelpEnabledModel</name><environment>VWHelp.AHSWHCProcessor</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Arbor Help System Widget Help Core</package></attributes></shared-variable><shared-variable><name>AHSIcon</name><environment>VWHelp.AHSWHCProcessor</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Arbor Help System Widget Help Core</package></attributes></shared-variable><shared-variable><name>HelpEnabledModel</name><environment>VWHelp.AHSWHCProcessor</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Arbor Help System Widget Help Core</package></attributes></shared-variable><shared-variable><name>WidgetHelpEnabledModel</name><environment>VWHelp.AHSWHCProcessor</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Arbor Help System Widget Help Core</package></attributes></shared-variable><shared-variable><name>BalloonKillDelay</name><environment>VWHelp.AHSWHCProcessor</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Arbor Help System Widget Help Core</package></attributes></shared-variable><shared-variable><name>CachedBalloonText</name><environment>VWHelp.AHSWHCProcessor</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Arbor Help System Widget Help Core</package></attributes></shared-variable><shared-variable><name>TmpStorage</name><environment>VWHelp.AHSWHCProcessor</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Arbor Help System Widget Help Core</package></attributes></shared-variable><shared-variable><name>Balloon</name><environment>VWHelp.AHSWHCProcessor</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Arbor Help System Widget Help Core</package></attributes></shared-variable><shared-variable><name>BalloonDisplayDelay</name><environment>VWHelp.AHSWHCProcessor</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Arbor Help System Widget Help Core</package></attributes></shared-variable><shared-variable><name>RegisteredMenuView</name><environment>VWHelp.AHSWHCProcessor</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Arbor Help System Widget Help Core</package></attributes></shared-variable><methods><class-id>VWHelp.AHSWHCBalloonSensor</class-id> <category>event processing</category><body package="Arbor Help System Widget Help Core" selector="eventButtonPress:">eventButtonPress: anEvent 	| cp |	self window parentWindow sensor eventButtonPress: anEvent.	OSHandle currentOS == #mac		ifTrue: 			[self window parentWindow isOpen ifFalse: [^self window unmap].			cp := InputSensor cursorPoint.			(self window parentWindow displayBox containsPoint: cp) not				ifTrue: 					[self window unmap.	"find the window the cursor is over"					ScheduledControllers updateControllerOrder.					ScheduledControllers scheduledControllers do: [:c | (c view displayBox containsPoint: cp)							ifTrue: [^c view raise]]]]</body><body package="Arbor Help System Widget Help Core" selector="eventButtonRelease:">eventButtonRelease: anEvent 	self window parentWindow sensor eventButtonRelease: anEvent.</body><body package="Arbor Help System Widget Help Core" selector="eventEnter:">eventEnter: event 	| parent menuWindow |	parent := self window parentWindow.	menuWindow := AHSWHCProcessor registeredMenuView.	(menuWindow isNil or: [menuWindow isOpen not])		ifTrue: [parent becomeActive]		ifFalse: [menuWindow becomeActive].</body><body package="Arbor Help System Widget Help Core" selector="eventKeyPress:">eventKeyPress: event	self window parentWindow sensor eventKeyPress: event</body><body package="Arbor Help System Widget Help Core" selector="eventKeyRelease:">eventKeyRelease: event 	self window parentWindow sensor eventKeyRelease: event</body><body package="Arbor Help System Widget Help Core" selector="eventMouseMoved:">eventMouseMoved: event	self window parentWindow sensor eventMouseMoved: event.</body><body package="Arbor Help System Widget Help Core" selector="forceActive:">forceActive: aMenu	aMenu becomeActive</body></methods><methods><class-id>VWHelp.AHSBalloonTextComposition</class-id> <category>accessing</category><body package="Arbor Help System Widget Help Core" selector="box">box	^ box</body><body package="Arbor Help System Widget Help Core" selector="composedText">composedText	^ ct</body><body package="Arbor Help System Widget Help Core" selector="widget">widget	^ widget</body></methods><methods><class-id>VWHelp.AHSBalloonTextComposition</class-id> <category>actions</category><body package="Arbor Help System Widget Help Core" selector="composeBalloon">composeBalloon	style := self balloonTextStyle.	maxWidth := (ComposedText 					withText: text					style: style) width.	lines := 1.	[w := maxWidth // lines + 20.	ct := ComposedText 				withText: text				style: style				compositionWidth: w.	h := ct height.	w &gt; 175 and: [w &gt; (h + h)]] whileTrue: [lines := lines + 1].	h := ct height.	box := 5 @ (h + 10) negated extent: (ct width + 10) @ (h + 10).	box := box translatedBy: processor applicationWindow globalOrigin - (5 @ 1).	pt := processor applicationWindow sensor cursorPoint + processor applicationWindow globalOrigin.	sz := Screen default bounds extent // 2.	wb := widget localPointToGlobal: widget bounds.	(widget isKindOf: MenuView) ifTrue: [wb := widget displayBoxOfView: widget].	"If the widget is large, display the balloon over the cursor point so it's not too far away."	(wb extent x &gt; 200 or: [wb extent y &gt; 200]) 		ifTrue: [shift := processor applicationWindow sensor cursorPoint + (20 @ 10)]		ifFalse: 			["In lower right corner of the screen, display balloon at upper left of widget."			(pt x &gt;= sz x and: [pt y &gt;= sz y]) ifTrue: [shift := wb bottomLeft - (box extent x @ 0)].			"In upper right corner of the screen, display balloon at lower left of widget."			(pt x &gt;= sz x and: [pt y &lt; sz y]) ifTrue: [shift := wb topLeft - (box extent x @ box extent y negated)].			"In lower left corner of the screen, display balloon at upper right of widget."			(pt x &lt; sz x and: [pt y &gt;= sz y]) ifTrue: [shift := wb bottomRight].			"In upper left corner of the screen, display balloon at lower right of widget."			(pt x &lt; sz x and: [pt y &lt; sz y]) ifTrue: [shift := wb topRight + (0 @ box extent y)]].	(widget isKindOf: MenuView) ifTrue: [shift := wb topLeft - (box extent x @ box extent y negated) - processor applicationWindow globalOrigin].	box := (box translatedBy: shift) rounded.</body></methods><methods><class-id>VWHelp.AHSBalloonTextComposition</class-id> <category>instance creation</category><body package="Arbor Help System Widget Help Core" selector="setText:widget:processor:">setText: aText widget: aWidget processor: anAHSWHCProcessor	text := aText.	processor := anAHSWHCProcessor.	widget := aWidget isNil				ifTrue: [processor applicationWindow]				ifFalse: [aWidget].</body></methods><methods><class-id>VWHelp.AHSBalloonTextComposition</class-id> <category>balloon help</category><body package="Arbor Help System Widget Help Core" selector="balloonTextStyle">balloonTextStyle	^(TextAttributes styleNamed: #'Arbor-10')		fontAttributeForLeading: #normal;		topLeading: 0;		bottomLeading: 0;		install</body></methods><methods><class-id>VWHelp.AHSBalloonTextComposition class</class-id> <category>instance creation</category><body package="Arbor Help System Widget Help Core" selector="composeBalloonFor:on:processor:">composeBalloonFor: aText on: aWidget processor: anAHSWHCProcessor	^ (self		forText: aText		widget: aWidget		processor: anAHSWHCProcessor) composeBalloon</body><body package="Arbor Help System Widget Help Core" selector="forText:widget:processor:">forText: aText widget: aWidget processor: anAHSWHCProcessor	^ self new		setText: aText		widget: aWidget		processor: anAHSWHCProcessor</body></methods><methods><class-id>VWHelp.AHSUtils class</class-id> <category>text utilities</category><body package="Arbor Help System Widget Help Core" selector="deepCopyOfRunArray:">deepCopyOfRunArray: aRunArray	| copy copyBlock |	aRunArray isNil		ifTrue: [^aRunArray].	copy := aRunArray copy.		"the runs and values of the RunArray are now shallow copied"		"copy the values deeper"	copyBlock := [:item |					(item isSymbol not and: [item isSequenceable])						ifTrue: [item collect: [:val | copyBlock value: val]]						ifFalse: [							item aisIsAssociation								ifTrue: [item species key: item key copy value: item value copy]								ifFalse: [item copy]]].	1 to: copy values size do: [:i |		copy values			at: i			put: (copyBlock value: (copy values at: i))].	^copy</body><body package="Arbor Help System Widget Help Core" selector="deepCopyOfText:">deepCopyOfText: aText	|copy |	aText isNil		ifTrue: [^aText].	copy := aText asText copy.	copy setString: copy string setRuns: (self deepCopyOfRunArray: copy runs).	^copy</body><body package="Arbor Help System Widget Help Core" selector="runArray:equals:">runArray: runArray1 equals: runArray2	"Given 2 RunArrays, answer true if they are completely equal.  This is equivalent to using #=, but can be much faster."	^runArray1 runs = runArray2 runs		and: [runArray1 values = runArray2 values]</body><body package="Arbor Help System Widget Help Core" selector="text:equals:">text: text1 equals: text2	"Given 2 Texts, answer true if the text is completely equal.  Don't use Text&gt;&gt;= because subclasses may invoke this method which would result in recursion."	^text1 species = text2 species		and: [text1 string = text2 string		and: [self runArray: text1 runs equals: text2 runs]]</body><body package="Arbor Help System Widget Help Core" selector="version">version	"This is a tricky question.  AHS is comprised of about 5 different modules, each with its own unique version history.  So this method should only be invoked for things that want to know the generic release level for everything, not a specific version number for a particular module."	^'3.0'</body></methods><methods><class-id>VWHelp.AHSUtils class</class-id> <category>utilities</category><body package="Arbor Help System Widget Help Core" selector="defaultHelpProcessorClass">defaultHelpProcessorClass	^#{AHSProcessorWithEditing} valueOrDo: [#{AHSWHCProcessor} valueOrDo: [nil]]</body></methods><methods><class-id>VWHelp.AHSUtils class</class-id> <category>parcel load/unload/save</category><body package="Arbor Help System Widget Help Core" selector="postLoadActionFor:">postLoadActionFor: aParcel	"Add the VWHelp namespace to the Smalltalk namespace imports. This is	needed so UI and Tools classes can access AHSPreference resources"	| nameSpaces |	nameSpaces := Array					with:Smalltalk					with:UI.	nameSpaces do:		[:aNamespace |		| tokens token |		tokens := aNamespace  importString tokensBasedOn: (Character space).		token := tokens detect: [:e | (e indexOfSubCollection: 'VWHelp.*' startingAt: 1) ~= 0] 					ifNone: [nil].		token isNil			ifTrue:				[ | strm |				strm := WriteStream on: (String new: 50).				tokens do: [:ea | strm nextPutAll: (ea, ' ')].				strm nextPutAll: 'private VWHelp.* '.				aNamespace  imports: strm contents				]		].</body></methods><methods><class-id>VWHelp.AHSWHCEventDispatcher</class-id> <category>accessing</category><body package="Arbor Help System Widget Help Core" selector="helpProcessor">helpProcessor	^helpProcessor isNil		ifTrue: [helpProcessor := AHSUtils defaultHelpProcessorClass new setWindow: self window]		ifFalse: [helpProcessor]</body><body package="Arbor Help System Widget Help Core" selector="pollForHelp">pollForHelp	self helpProcessor processPollForHelpEvent</body></methods><methods><class-id>VWHelp.AHSWHCEventDispatcher</class-id> <category>event dispatching</category><body package="Arbor Help System Widget Help Core" selector="dispatchEvent:">dispatchEvent: event 	"If the event indicates exiting the window logic dictates we will want to close the balloon.  However, OS implementations for window opening cause problems.  In MS Windows, when a balloon opens, it gets an enter event and the host window gets an exit event - in such a case we do NOT want to close the balloon or the balloon will just flash briefly on the screen before closing.  UNIX systems generally don't exhibit this behavior, so in the case of UNIX we will close the balloon when an exit event occurs."	(event isWindowExit and: 			[self helpProcessor balloonHelpEnabled and: [OSHandle currentOS == #unix]]) 		ifTrue: [self helpProcessor hideBalloon].	super dispatchEvent: event.	(event isKindOf: KeyPressedEvent) 		ifTrue: 			[(#(#Help #F1) includes: event keyValue) 				ifTrue: [^self helpProcessor extendedHelpRequest].			event keyValue == #F2 ifTrue: [^self helpProcessor editHelpRequest].			event keyValue == #F3 ifTrue: [^self helpProcessor toggleBubbleRequest]].	(event isButtonReleasedEvent 		or: [(event isKindOf: WindowEnterEvent) or: [event isKindOf: MouseMovedEvent]]) 			ifTrue: [^self pollForHelp]</body></methods><methods><class-id>VWHelp.AHSWHCEventDispatcher</class-id> <category>private</category><body package="Arbor Help System Widget Help Core" selector="helpProcessor:">helpProcessor: aHelpProcessor	helpProcessor := aHelpProcessor</body></methods><methods><class-id>VWHelp.AHSWHCGlobalHelp</class-id> <category>interface opening</category><body package="Arbor Help System Widget Help Core" selector="postBuildWith:">postBuildWith: aBuilder	super postBuildWith: aBuilder.	aBuilder window icon: AHSWHCProcessor reducedHelpWindowIcon.</body><body package="Arbor Help System Widget Help Core" selector="postOpenWith:">postOpenWith: aBuilder	super postOpenWith: aBuilder.	self ahsWindow ahsProcessor helpTextModel: self class broadcastModel.	aBuilder window		sendWindowEvents: #(enter exit);		application: self.</body><body package="Arbor Help System Widget Help Core" selector="preBuildWith:">preBuildWith: aBuilder	super preBuildWith: aBuilder.	aBuilder aspectAt: #ahsText put: self class broadcastModel.	aBuilder aspectAt: #ahsFlag put: AHSWHCProcessor helpEnabledModel.</body></methods><methods><class-id>VWHelp.AHSWHCGlobalHelp</class-id> <category>events</category><body package="Arbor Help System Widget Help Core" selector="windowEvent:from:">windowEvent: anEvent from: anApplicationWindow 	"Clear the help text whenever the window is exited or entered."	super windowEvent: anEvent from: anApplicationWindow.	(anApplicationWindow == self builder window		and: [anEvent key = #enter or: [anEvent key = #exit]])			ifTrue: [anApplicationWindow ahsProcessor helpText: '' focus: nil state: #default].</body></methods><methods><class-id>VWHelp.AHSWHCGlobalHelp class</class-id> <category>broadcasting help</category><body package="Arbor Help System Widget Help Core" selector="broadcastHelp:">broadcastHelp: aText	"Post aText as a broadcasted help value."	(AHSUtils text: self broadcastModel value equals: aText) not		ifTrue: [self broadcastModel value: aText]</body><body package="Arbor Help System Widget Help Core" selector="broadcastModel">broadcastModel	^BroadcastModel</body></methods><methods><class-id>VWHelp.AHSWHCGlobalHelp class</class-id> <category>interface specs</category><body package="Arbor Help System Widget Help Core" selector="windowSpec">windowSpec	^AHSWHCProcessor ahsSpec</body></methods><methods><class-id>VWHelp.AHSWHCGlobalHelp class</class-id> <category>class initialization</category><body package="Arbor Help System Widget Help Core" selector="initialize">initialize	BroadcastModel := ValueHolder new</body></methods><methods><class-id>VWHelp.AHSWHCGlobalHelp class</class-id> <category>help info (AHS)</category><body package="Arbor Help System Widget Help Core" selector="arborHelpEnabled">arborHelpEnabled	^true</body></methods><methods><class-id>VWHelp.AHSWHCProcessor</class-id> <category>accessing</category><body package="Arbor Help System Widget Help Core" selector="balloon">balloon	^self class balloon</body><body package="Arbor Help System Widget Help Core" selector="balloonHelpEnabled">balloonHelpEnabled	^self class balloonHelpEnabled</body><body package="Arbor Help System Widget Help Core" selector="balloonHelpEnabled:">balloonHelpEnabled: aBoolean	self class balloonHelpEnabled: aBoolean</body><body package="Arbor Help System Widget Help Core" selector="balloonHelpEnabledModel">balloonHelpEnabledModel	"Answer the value model which indicates whether balloon help is currently active or inactive."	^self class balloonHelpEnabledModel</body><body package="Arbor Help System Widget Help Core" selector="cachedBalloonText">cachedBalloonText	^self class cachedBalloonText</body><body package="Arbor Help System Widget Help Core" selector="cachedBalloonText:">cachedBalloonText: aText	^self class cachedBalloonText: aText</body><body package="Arbor Help System Widget Help Core" selector="editHelpRequest">editHelpRequest	editHelpRequest := true.	self pollForHelp</body><body package="Arbor Help System Widget Help Core" selector="extendedHelpRequest">extendedHelpRequest	extendedHelpRequest := true.	self pollForHelp</body><body package="Arbor Help System Widget Help Core" selector="focusChanged">focusChanged	focusChanged := true.	self processPollForHelpEvent</body><body package="Arbor Help System Widget Help Core" selector="helpEnabled">helpEnabled	"Answer true if the user wishes to have help lookup performed."	^self class helpEnabled</body><body package="Arbor Help System Widget Help Core" selector="helpEnabled:">helpEnabled: aBoolean	"Set whether or not to display help."	self helpFlag value: aBoolean</body><body package="Arbor Help System Widget Help Core" selector="helpEnabledModel">helpEnabledModel	"Answer the value model which indicates whether the entire help system is currently active or inactive."	^self class helpEnabledModel</body><body package="Arbor Help System Widget Help Core" selector="helpFlag">helpFlag	"Answer the help flag value model, which indicates whether widget help is currently active or inactive."	^self widgetHelpEnabledModel</body><body package="Arbor Help System Widget Help Core" selector="helpText">helpText	"Answer the help text value model, which contains the current help text"	^helpText</body><body package="Arbor Help System Widget Help Core" selector="helpTextModel:">helpTextModel: aValueHolder	"Set the help text value model, which will contain the current help text"	helpText := aValueHolder</body><body package="Arbor Help System Widget Help Core" selector="registeredMenuView">registeredMenuView	^self class registeredMenuView</body><body package="Arbor Help System Widget Help Core" selector="registeredMenuView:">registeredMenuView: aMenuView	^self class registeredMenuView: aMenuView</body><body package="Arbor Help System Widget Help Core" selector="resetEditHelpRequest">resetEditHelpRequest	editHelpRequest := false</body><body package="Arbor Help System Widget Help Core" selector="resetExtendedHelpRequest">resetExtendedHelpRequest	extendedHelpRequest := false</body><body package="Arbor Help System Widget Help Core" selector="resetFocusChanged">resetFocusChanged	focusChanged := false</body><body package="Arbor Help System Widget Help Core" selector="resetToggleBubbleRequest">resetToggleBubbleRequest	toggleBubbleRequest := false</body><body package="Arbor Help System Widget Help Core" selector="restrictBalloonToCondensedText">restrictBalloonToCondensedText	^self class restrictBalloonToCondensedText</body><body package="Arbor Help System Widget Help Core" selector="sourceModel">sourceModel	"Answer the application source model"	^self applicationWindow ahsClient</body><body package="Arbor Help System Widget Help Core" selector="toggleBubbleRequest">toggleBubbleRequest	toggleBubbleRequest := true.	self pollForHelp</body><body package="Arbor Help System Widget Help Core" selector="widgetHelpEnabled">widgetHelpEnabled	^self class widgetHelpEnabled</body><body package="Arbor Help System Widget Help Core" selector="widgetHelpEnabled:">widgetHelpEnabled: aBoolean	self class widgetHelpEnabled: aBoolean.</body><body package="Arbor Help System Widget Help Core" selector="widgetHelpEnabledModel">widgetHelpEnabledModel	"Answer the value model which indicates whether widget help is currently active or inactive."	^self class widgetHelpEnabledModel</body></methods><methods><class-id>VWHelp.AHSWHCProcessor</class-id> <category>testing</category><body package="Arbor Help System Widget Help Core" selector="didFocusChange">didFocusChange 	^focusChanged == true</body><body package="Arbor Help System Widget Help Core" selector="editHelpRequestIsActive">editHelpRequestIsActive	^editHelpRequest == true</body><body package="Arbor Help System Widget Help Core" selector="extendedHelpRequestIsActive">extendedHelpRequestIsActive	^extendedHelpRequest == true</body><body package="Arbor Help System Widget Help Core" selector="isInterestingText:">isInterestingText: aText	^aText ~= (self getHelpTextForID: #ahsBackground) and: [aText asString ~= '']</body><body package="Arbor Help System Widget Help Core" selector="toggleBubbleRequestIsActive">toggleBubbleRequestIsActive	^toggleBubbleRequest == true</body></methods><methods><class-id>VWHelp.AHSWHCProcessor</class-id> <category>balloon help</category><body package="Arbor Help System Widget Help Core" selector="balloonDisplayProcessFor:">balloonDisplayProcessFor: aBalloonComposition 	| aRectangle aWidget |	aRectangle := aBalloonComposition box.	aWidget := aBalloonComposition widget.	^[	(self helpEnabled and: [self balloonHelpEnabled]) 			ifTrue: [				self waitToDisplay.				(self balloon)					displayBox: aRectangle;					map.				(aWidget isKindOf: MenuView) ifTrue: [aWidget submenuClosed].				self balloon graphicsContext display: aBalloonComposition composedText					at: 5 @ 5.				(0 @ 0 extent: aRectangle extent - 1) 					displayStrokedOn: self balloon graphicsContext.				(0 @ 0 extent: aRectangle extent - 2) 					displayStrokedOn: self balloon graphicsContext.				(Delay forMilliseconds: self class balloonKillDelay) wait.				self hideBalloon].		waitingOnBalloon := nil] newProcess</body><body package="Arbor Help System Widget Help Core" selector="clearBalloonWindow">clearBalloonWindow	self balloon background: self class balloonColor.	self balloon parentWindow: self applicationWindow.	self balloon graphicsContext clear</body><body package="Arbor Help System Widget Help Core" selector="displayBalloonComposition:">displayBalloonComposition: aBalloonComposition	self clearBalloonWindow.	waitingOnBalloon notNil ifTrue: 		[waitingOnBalloon terminate.		waitingOnBalloon := nil].	(waitingOnBalloon := self balloonDisplayProcessFor: aBalloonComposition) resume.</body><body package="Arbor Help System Widget Help Core" selector="hideBalloon">hideBalloon	self class hideBalloon</body><body package="Arbor Help System Widget Help Core" selector="hideBalloonText:">hideBalloonText: aText	self		hideBalloon;		cachedBalloonText: aText.</body><body package="Arbor Help System Widget Help Core" selector="primShowBalloon:on:">primShowBalloon: aText on: wrapper 	| balloonComposition |	aText = self cachedBalloonText ifTrue: [^ self].	self cachedBalloonText: aText.	balloonComposition := AHSBalloonTextComposition							composeBalloonFor: aText							on: wrapper							processor: self.	self displayBalloonComposition: balloonComposition.</body><body package="Arbor Help System Widget Help Core" selector="showBalloon:on:">showBalloon: aTextOrAHSTextBinder on: wrapper 	| txt |	self balloonHelpEnabled ifFalse: [^self].	txt := (aTextOrAHSTextBinder hasCondensedText 				or: [self restrictBalloonToCondensedText not]) 					ifTrue: [aTextOrAHSTextBinder condensedText]					ifFalse: [''].	(self isInterestingText: txt) 		ifTrue: [self primShowBalloon: txt on: wrapper]		ifFalse: [self hideBalloonText: txt]</body><body package="Arbor Help System Widget Help Core" selector="waitToDisplay">waitToDisplay	self balloon isMapped ifTrue: [^ self].	(Delay forMilliseconds: self class balloonDisplayDelay) wait.</body></methods><methods><class-id>VWHelp.AHSWHCProcessor</class-id> <category>private</category><body package="Arbor Help System Widget Help Core" selector="applicationWindow">applicationWindow	"Answer the application window"	^window</body><body package="Arbor Help System Widget Help Core" selector="applyHelpOffText">applyHelpOffText	"Set the help text to display the default 'help off' string.  We coerce the display because if #widgetHelpEnabled is false then the display wouldn't otherwise occur."	| txt |	txt := self			helpText: (self getHelpTextForID: #HELPOFF ifNil: '')			focus: nil			id: #HELPOFF			state: #default			client: self sourceModel.	txt notNil ifTrue: [helpText value: txt fullText].</body><body package="Arbor Help System Widget Help Core" selector="canOpenOutliner">canOpenOutliner	"Private - Answer true if the system can open an outliner."	^self extendedHelpRequestIsActive and: [self outliner notNil]</body><body package="Arbor Help System Widget Help Core" selector="changeOccurredInWidget:state:">changeOccurredInWidget: aWidget state: aState	"Private - Answer true if the widget or state for which help is being displayed is different from aWidget or aState."	^aWidget ~= lastFocus or: [lastState ~= aState]</body><body package="Arbor Help System Widget Help Core" selector="component:containsMousePosition:">component: aVisPart containsMousePosition: aPoint	"is the mouse positioned over aVisPart?	aVisPart must be able to respond to isVisible"	| pt |	(aVisPart isNil or: [aVisPart isVisible not]) ifTrue: [^ false].	pt := self messageNotUnderstoodSignal			handle: 				[:ex | 				ex parameter selector == #container					ifTrue: [ex returnWith: aPoint]					ifFalse: [ex reject]]			do: 				[aVisPart container notNil					ifTrue: [aVisPart container globalPointToLocal: aPoint]					ifFalse: [aPoint]].	^ aVisPart bounds containsPoint: pt</body><body package="Arbor Help System Widget Help Core" selector="componentAt:">componentAt: aSymbol	"Answer the component named aSymbol in the application source"	^Object errorSignal		handle: [:ex |  ex returnWith: nil]		do: [self sourceModel widgetWithID: aSymbol]</body><body package="Arbor Help System Widget Help Core" selector="currentConsumerPosition">currentConsumerPosition	"Returns the origin of the current keyboard consumer in the current window's coordinate 	system."	| consumer |	consumer := self getConsumerFor: self applicationWindow model.	^consumer isNil		ifTrue: [Point zero]		ifFalse: [consumer view ahsActivityPoint]</body><body package="Arbor Help System Widget Help Core" selector="currentHelpCache">currentHelpCache	"Private - Answer the current help cache maintained by the storage manager.  This message	 assumes that a storage manager exists."	^ self storageManager currentHelpCache</body><body package="Arbor Help System Widget Help Core" selector="defaultWidgetHelpInfoFor:state:className:">defaultWidgetHelpInfoFor: ahsID state: widgetState className: widgetClassName	"Private - Answer the default widget help string if available, otherwise answer nil."	| helpString |	self haveStorageManager		ifTrue: [			helpString := self currentHelpCache								helpTextForID: ahsID								state: widgetState								className: widgetClassName		].	^ helpString</body><body package="Arbor Help System Widget Help Core" selector="findClientFor:">findClientFor: menuButtonView	"Private - Answer the client associated with the given menuButtonView.  The 	 result will be the closest client in the visual hierarchy."	| comp client |	comp := menuButtonView.	client := nil.	[comp notNil and: [client isNil]]		whileTrue: [ 		     client := comp ahsClient.			comp := comp container		].	^ client</body><body package="Arbor Help System Widget Help Core" selector="findHelpTextForID:state:client:">findHelpTextForID: ahsID state: widgetState client: widgetClient	"Private - Answer the help text associated with the given widgetState and widgetClient.	 If no help text is defined, get the default text, if any."	| helpString |	helpString := self sourceModel						ahsHelpTextForID: ahsID						state: widgetState						client: widgetClient.	helpString isNil		ifTrue: [helpString := self 									defaultWidgetHelpInfoFor: ahsID 									state: widgetState 									className: widgetClient class fullName].	^ helpString</body><body package="Arbor Help System Widget Help Core" selector="findItemIDFor:">findItemIDFor: menuButtonView	"Private - Answer the ahsID associated with the currently selected item in menuButtonView.."	| comp ahsID |	comp := menuButtonView.	ahsID := nil.	[comp notNil and: [ahsID isNil]]				whileTrue: [ 			ahsID := comp ahsID.			comp := comp container		].	^ ahsID</body><body package="Arbor Help System Widget Help Core" selector="findMenuItemHelpDataFor:client:id:">findMenuItemHelpDataFor: aMenuItemString client: menuClient id: ahsID	"Private - Answer an association containing the widget key and its associated help	 text.  Answers nil if nothing appropriate can be found."	| possibleKeys helpString |	possibleKeys := self menuItemKeysFrom: aMenuItemString string.	possibleKeys		do: [:thisKey |			helpString := self findHelpTextForID: ahsID state: thisKey client: menuClient.			helpString notNil				ifTrue: [^ Association key: thisKey value: helpString asAHSTextBinder]		].	^ nil</body><body package="Arbor Help System Widget Help Core" selector="getConsumerFor:">getConsumerFor: aModel	"Private - Answer the consumer associated with aModel.	  The check for ApplicationCanvas is for Argos support."	^ aModel builder keyboardProcessor currentConsumer</body><body package="Arbor Help System Widget Help Core" selector="haveStorageManager">haveStorageManager	"Private - Answer true if a storage manager is defined."	^ self storageManager notNil</body><body package="Arbor Help System Widget Help Core" selector="isEventPending">isEventPending	^(self applicationWindow sensor metaInput conform:		[:each |			(each key == #block				and: [(each value isKindOf: MessageSend)							and: [each value selector == #processPollForHelpEvent]])			not])		not</body><body package="Arbor Help System Widget Help Core" selector="menuItemKeysFrom:">menuItemKeysFrom: menuLabelString	"Private - Answer an ordered collection of menu items keys which will be used to find help	 for the currently active widget.  The keys are derived from the menu item label string contained	  in menuLabelString."	| possibleKeys |	possibleKeys := OrderedCollection new.	possibleKeys		add: menuLabelString trimExteriorBlanks asSymbol;		addAll: (self parseItemsFrom: menuLabelString);		add: #default.	^ possibleKeys.</body><body package="Arbor Help System Widget Help Core" selector="outliner">outliner	"Private - Answer the class which edits outlines."	^ self class outlinerClass</body><body package="Arbor Help System Widget Help Core" selector="parseItemsFrom:">parseItemsFrom: aString	"Private - Answer a collection of menu item names found in aString.  aString will	 be in the form 'Menu/item 1/item 2/ ..."	| labelString items idx |	labelString := aString string.	items := OrderedCollection new.	[(idx := labelString indexOf: $/) &gt; 0]		whileTrue: [ 			labelString := labelString copyFrom: (idx + 1) to: labelString size.			items add: labelString asSymbol].	^items</body><body package="Arbor Help System Widget Help Core" selector="setWindow:">setWindow: aWindow	window := aWindow</body><body package="Arbor Help System Widget Help Core" selector="storageManager">storageManager	"Private - Answer the storage manager associated with the receiver, or nil if	 unavailable."	^ self class storageManagerClass</body></methods><methods><class-id>VWHelp.AHSWHCProcessor</class-id> <category>help</category><body package="Arbor Help System Widget Help Core" selector="currentSource:">currentSource: temps	"The current source is the top of the source stack"	|sourceStack|	sourceStack := temps at: #sourceStack.	^sourceStack isEmpty		ifFalse: [sourceStack last]</body><body package="Arbor Help System Widget Help Core" selector="getHelpTextForID:">getHelpTextForID: aSymbol	"Answer a text / or nil if not found"	| help |	help := self sourceModel ahsHelpTextForID: aSymbol				state: #default				client: self sourceModel.	help isNil		ifTrue: [help := self 							defaultWidgetHelpInfoFor: aSymbol 							state: #default 							className: self sourceModel class fullName].	^help</body><body package="Arbor Help System Widget Help Core" selector="getHelpTextForID:ifNil:">getHelpTextForID: aSymbol ifNil: aTextOrString	"Answer the help text defined for aSymbol.  If no text is defined, answer aTextOrString."	| txt |	^(txt := self getHelpTextForID: aSymbol) isNil		ifTrue: [aTextOrString]		ifFalse: [txt]</body><body package="Arbor Help System Widget Help Core" selector="getNoHelpForFocus:">getNoHelpForFocus: temps	"selects the messages for the case when there is no help for a widget."	|noHelpMsg index client focus|	focus := temps at: #focus.	client := temps at: #focusClient.	noHelpMsg := self sourceModel					ahsHelpTextForComponent: focus					offset: (temps at: #mousePt)					client: client. "This client helps to uniquely identify the component"	noHelpMsg isNil		ifTrue: [noHelpMsg := self 								defaultWidgetHelpInfoFor: #ahsNoHelpFor								state: #default								className: self sourceModel class fullName].	noHelpMsg isNil		ifTrue: [^''].			"Replace the special sequence %s with the id"	index := noHelpMsg findString: '%s' startingAt: 1.	index ~= 0		ifTrue: [noHelpMsg := noHelpMsg copyReplaceFrom: index to: index + 1 with: (focus ahsID asText allBold)].	^noHelpMsg</body><body package="Arbor Help System Widget Help Core" selector="helpFor:temps:">helpFor: aVisComp temps: temps	"Answer the help, whether it's a block or MessageSend to execute, an Array, a Text, or nil"	|help ahsID ahsState helpKey stateArray client openEditorBlock |	client := self currentSource: temps.	ahsID := aVisComp ahsID.	ahsState := aVisComp ahsStateAt: (temps at: #mousePt).	stateArray := self class stateToArrayWithDefault: ahsState.		"Check to see if we should open a widget help editor"	(openEditorBlock :=  self openEditorBlockForVisualComponent: aVisComp temps: temps) notNil		ifTrue: [^openEditorBlock].	self extendedHelpRequestIsActive		ifTrue: [					"stateArray is an array of states in order of preference"					"First ask the source model"				help := self sourceModel ahsOutlineLinkForComponent: aVisComp offset: (temps at: #mousePt) client: client.				(help isNil and: [self haveStorageManager])					ifTrue: [stateArray detect: [:sym |							help isNil								ifTrue: [help := self currentHelpCache									outlineLinkForID: ahsID									state: sym									className: client class fullName].							help notNil]						ifNone: []].				help notNil						ifTrue: [  "If help first starts with a $#, then it's										a message selector for custom behavior"							help first first == $#								ifTrue: [^self messageSendForReceiver: client														selector:															(help first copyFrom: 2																	to: help first size) asSymbol														id: ahsID														state: ahsState]								ifFalse: [									self canOpenOutliner ifTrue: [											^[self outliner openOutlineNamed: help first												topicNumber: (help at: 2)												modal: self applicationWindow isModalDialog]]]]].			"ahsState is an array of states in order of preference"	helpKey := Array with: ahsID with: ahsState.	help := self sourceModel				ahsHelpTextForComponent: aVisComp				offset: (temps at: #mousePt)				client: client.	(help isNil and: [self haveStorageManager])		ifTrue: [stateArray detect: [:sym |				helpKey := Array with: ahsID with: sym.				help := self currentHelpCache							helpTextForID: ahsID							state: sym							className: client class fullName.				help notNil]			ifNone: []].	^help notNil		ifTrue: [Array with: client						with: helpKey						with: help]</body><body package="Arbor Help System Widget Help Core" selector="helpText:focus:id:state:client:">helpText: aText focus: aWidget id: id state: state client: client	"Update the help text, using aWidget (which can be nil) as the balloon focus,	the id and state and are passed to the source model to give it a chance to override the text,	and client is used "	|locText|	locText := self sourceModel					ahsHelpRequest: aText					widgetID: id					state: state					client: client.	locText isNil		ifTrue: [^nil]. "vetoed by the sourceModel"	self helpText: locText focus: aWidget state: state.	^locText</body><body package="Arbor Help System Widget Help Core" selector="helpText:focus:state:">helpText: aTextOrAHSTextBinder focus: aWidget state: ahsState 	"Change the help text without letting the source model override,	and use aWidget as the focus for balloon help"	| fullText |	(self changeOccurredInWidget: aWidget state: ahsState) ifFalse: [^self].	fullText := AHSUtils deepCopyOfText: aTextOrAHSTextBinder fullText.	lastFocus := aWidget.	lastState := aWidget isNil ifFalse: [ahsState].	AHSWHCGlobalHelp broadcastHelp: fullText.	self showBalloon: aTextOrAHSTextBinder on: aWidget.	self widgetHelpEnabled		ifTrue: [			(AHSUtils text: helpText value equals: fullText) not 				ifTrue: [helpText value: fullText]].</body><body package="Arbor Help System Widget Help Core" selector="menuItemSelected:label:">menuItemSelected: menuButtonView label: aString 	"A menu item has been selected in a menu of menuButtonView. 	menuButtonView is in a window whose application has the receiver as 	its AHSHelpProcessor. Check for and process help for this menu item"	self menuItemSelected: menuButtonView label: aString focus: menuButtonView</body><body package="Arbor Help System Widget Help Core" selector="menuItemSelected:label:focus:">menuItemSelected: menuButtonView label: aString focus: menuView 	"A menu item has been selected in a menu of menuButtonView. 	menuButtonView is in a window whose application has the receiver as 	its AHSHelpProcessor. Check for and process help for this menu item"	| client id helpData |	self helpEnabled ifFalse: [^self].	client := self findClientFor: menuButtonView.	id := self findItemIDFor: menuButtonView.	helpData := self 				findMenuItemHelpDataFor: aString				client: client				id: id.	helpData notNil 		ifTrue: 			[self 				helpText: helpData value				focus: menuView				id: id				state: helpData key				client: client]</body><body package="Arbor Help System Widget Help Core" selector="messageSendForReceiver:selector:id:state:">messageSendForReceiver: rcvr selector: sel id: id state: state	^[Object messageNotUnderstoodSignal		handle: [:ex | Dialog						warn: rcvr printString ,								': ' , ex errorString]		do: [ |numberOfParameters|				numberOfParameters := sel occurrencesOf: $:.				numberOfParameters = 0					ifTrue: [rcvr perform: sel].				numberOfParameters = 1					ifTrue: [rcvr perform: sel									with: id].				numberOfParameters = 2					ifTrue: [rcvr perform: sel								with: id								with: state]]]</body><body package="Arbor Help System Widget Help Core" selector="openEditorBlockForVisualComponent:temps:">openEditorBlockForVisualComponent: aVisComp temps: temps	"Answer a block to open a widget help editor or nil if not appropriate"	^nil</body><body package="Arbor Help System Widget Help Core" selector="pollCompCollection:temps:">pollCompCollection: aSeqColl temps: temps	"Check to see if we need to display help information by polling the collection of VisualComponents in aSeqColl.	Answer the help or nil"	|i help mousePt|	mousePt := temps at: #mousePt.	i := aSeqColl size.	[i &gt;= 1]		whileTrue: [|component|				component := aSeqColl at: i.				(self component: component containsMousePosition: mousePt)					ifTrue: [|client cmpHelp|								(client := component ahsClient) notNil								ifTrue: [self pushSource: client temps: temps].							component ahsID notNil								ifTrue: [temps at: #focus put: component;											at: #focusClient put: (self currentSource: temps).										help := self helpFor: component temps: temps].								"Check for a single component before checking for multiple components.								Assumption is component is 'distinguished', taking priority over								a collection of components"							component ahsHasComponent 								ifTrue: [cmpHelp := self pollCompCollection: (Array with: component component) temps: temps]								ifFalse: [component ahsHasComponents												ifTrue: [cmpHelp := self pollCompCollection: component components temps: temps]].							client notNil								ifTrue: [self popSource: temps].							cmpHelp notNil								ifTrue: [^cmpHelp].							help notNil								ifTrue: [^help]].				i := i - 1].	^nil</body><body package="Arbor Help System Widget Help Core" selector="pollForHelp">pollForHelp	"Check to see if we need to display help information"	ScheduledControllers inActiveControllerProcess		ifTrue: [self processPollForHelpEvent]		ifFalse: [		"can assume the window is _not_ event driven"				Object errorSignal					handle: [:ex | Transcript show: 'error handled in AHSWHCProcessor&gt;pollForHelp'; cr;									show: ex errorString; cr; cr.								ex return]					do: [self isEventPending							ifTrue: [^self].						self applicationWindow sensor							addMetaInput: #block-&gt;							(MessageSend receiver: self								selector: #processPollForHelpEvent)]]</body><body package="Arbor Help System Widget Help Core" selector="popSource:">popSource: temps	|sourceStack|	sourceStack := temps at: #sourceStack.	^sourceStack isEmpty		ifFalse: [sourceStack removeLast]</body><body package="Arbor Help System Widget Help Core" selector="processPollForHelpEvent">processPollForHelpEvent	"Check to see if we need to display help information"	| win help mousePt temps focus |	win := self applicationWindow.	temps := Dictionary new.	mousePt := temps at: #mousePt				put: (self didFocusChange 						ifTrue: [self currentConsumerPosition]						ifFalse: [win sensor cursorPoint]).	"window-relative coordinates"	self resetFocusChanged.	(win isOpen and: [win isActive and: [win bounds containsPoint: mousePt]]) 		ifFalse: [^self].	self toggleBubbleRequestIsActive 		ifTrue: 			[self resetToggleBubbleRequest.			^self balloonHelpEnabled: self balloonHelpEnabled not].	temps at: #sourceStack put: OrderedCollection new.	help := self pollCompCollection: (Array with: win) temps: temps.	self		resetExtendedHelpRequest;		resetEditHelpRequest.	(#(#AHSPBlock #BlockClosure #MessageSend) includes: help class name) 		ifTrue: [^help value].	focus := temps at: #focus.	focus isNil 		ifTrue: 			["only happens if the mouse gets outside of the window"			^self].	self helpEnabled 		ifTrue: 			[help isNil 				ifTrue: 					[self 						helpText: (self getNoHelpForFocus: temps)						focus: focus						id: #ahsNoHelpFor						state: #default						client: self sourceModel]				ifFalse: 					["Assume help is #(client lookupKey text)"					self 						helpText: (help at: 3)						focus: focus						id: (help at: 2) first						state: ((help at: 2) at: 2)						client: help first]]</body><body package="Arbor Help System Widget Help Core" selector="pushSource:temps:">pushSource: aModel temps: temps	|sourceStack|	sourceStack := temps at: #sourceStack.	sourceStack addLast: aModel</body></methods><methods><class-id>VWHelp.AHSWHCProcessor</class-id> <category>initialize-release</category><body package="Arbor Help System Widget Help Core" selector="initialize">initialize	"Initialize the help processor to default values"	helpText := String new asValue.	self helpEnabledModel onChangeSend: #helpEnabledChanged to: self.	self widgetHelpEnabledModel onChangeSend: #helpEnabledChanged to: self.</body></methods><methods><class-id>VWHelp.AHSWHCProcessor</class-id> <category>finalization</category><body package="Arbor Help System Widget Help Core" selector="executor">executor	^nil</body></methods><methods><class-id>VWHelp.AHSWHCProcessor</class-id> <category>change messages</category><body package="Arbor Help System Widget Help Core" selector="helpEnabledChanged">helpEnabledChanged	"The global 'help enabled' flag has changed state.  Respond accordingly."	self applicationWindow isNil ifTrue: [^self].	(self helpEnabled and: [self widgetHelpEnabled])		ifTrue: [self helpText value: '']		ifFalse: [self applyHelpOffText]</body></methods><methods><class-id>VWHelp.AHSWHCProcessor class</class-id> <category>updating</category><body package="Arbor Help System Widget Help Core" selector="update:">update: anAspectSymbol	anAspectSymbol == #ElementExpired		ifTrue: [TmpStorage removeAllSuchThat: [:elm | elm first includes: 0]]</body></methods><methods><class-id>VWHelp.AHSWHCProcessor class</class-id> <category>resources</category><body package="Arbor Help System Widget Help Core" selector="reducedHelpIcon">reducedHelpIcon	^OpaqueImage		figure: self reducedHelpImage		shape: self reducedHelpMask</body><body package="Arbor Help System Widget Help Core" selector="reducedHelpWindowIcon">reducedHelpWindowIcon	^(Icon		figure: self reducedHelpImage		shape: self reducedHelpMask) cleanFigure</body></methods><methods><class-id>VWHelp.AHSWHCProcessor class</class-id> <category>default classes</category><body package="Arbor Help System Widget Help Core" selector="eventDispatcherClass">eventDispatcherClass	^AHSWHCEventDispatcher</body><body package="Arbor Help System Widget Help Core" selector="outlinerClass">outlinerClass	^#{AHSOutlineViewer} valueOrDo: [nil]</body><body package="Arbor Help System Widget Help Core" selector="storageManagerClass">storageManagerClass	"Answer the default class to use for the help storage manager class"	^#{AHSStorageManager} valueOrDo: [nil]</body><body package="Arbor Help System Widget Help Core" selector="windowSensorClass">windowSensorClass	^AHSWHCWindowSensor</body></methods><methods><class-id>VWHelp.AHSWHCProcessor class</class-id> <category>class accessing</category><body package="Arbor Help System Widget Help Core" selector="ahsIcon">ahsIcon	"UIMaskEditor new openOnClass: self andSelector: #ahsIcon"	^AHSIcon</body><body package="Arbor Help System Widget Help Core" selector="balloon">balloon	self balloonHelpEnabled not ifTrue: [^nil].	(Balloon isNil or: [Balloon key isNil]) 		ifTrue: 			["Regenerate the balloon on image start up."			self createBalloon].	^Balloon</body><body package="Arbor Help System Widget Help Core" selector="balloonColor">balloonColor	^(ColorValue red: 1.0 green: 1.0 blue: 0.75)</body><body package="Arbor Help System Widget Help Core" selector="balloonDisplayDelay">balloonDisplayDelay	"Answer the millisecond value to be used to determine how long the mouse must be over a widget before balloon help is displayed."	BalloonDisplayDelay isNil ifTrue: [BalloonDisplayDelay := self defaultBalloonDisplayDelay].	^ BalloonDisplayDelay</body><body package="Arbor Help System Widget Help Core" selector="balloonDisplayDelay:">balloonDisplayDelay: anInteger	"Set the millisecond value to be used to determine how long the mouse must be over a widget before balloon help is displayed."	BalloonDisplayDelay := anInteger</body><body package="Arbor Help System Widget Help Core" selector="balloonHelpEnabled">balloonHelpEnabled	^BalloonHelpEnabledModel value</body><body package="Arbor Help System Widget Help Core" selector="balloonHelpEnabled:">balloonHelpEnabled: aBoolean 	self balloonHelpEnabled ~= aBoolean 		ifTrue: [self balloonHelpEnabledModel value: aBoolean]</body><body package="Arbor Help System Widget Help Core" selector="balloonHelpEnabledModel">balloonHelpEnabledModel	^BalloonHelpEnabledModel</body><body package="Arbor Help System Widget Help Core" selector="balloonKillDelay">balloonKillDelay	"Answer the millisecond value to be used to determine how long a balloon help window may remain visible in the absence of any help activity."	BalloonKillDelay isNil ifTrue: [BalloonKillDelay := self defaultBalloonKillDelay].	^ BalloonKillDelay</body><body package="Arbor Help System Widget Help Core" selector="balloonKillDelay:">balloonKillDelay: anInteger	"Set the millisecond value to be used to determine how long a balloon window may remain visible in the absence of any help activity."	BalloonKillDelay := anInteger</body><body package="Arbor Help System Widget Help Core" selector="cachedBalloonText">cachedBalloonText	^CachedBalloonText</body><body package="Arbor Help System Widget Help Core" selector="cachedBalloonText:">cachedBalloonText: aText	^CachedBalloonText := aText</body><body package="Arbor Help System Widget Help Core" selector="helpEnabled">helpEnabled	^self helpEnabledModel value</body><body package="Arbor Help System Widget Help Core" selector="helpEnabled:">helpEnabled: aBoolean	self helpEnabled ~= aBoolean 		ifTrue: [self helpEnabledModel value: aBoolean]</body><body package="Arbor Help System Widget Help Core" selector="helpEnabledModel">helpEnabledModel	^HelpEnabledModel</body><body package="Arbor Help System Widget Help Core" selector="registeredMenuView">registeredMenuView	^RegisteredMenuView</body><body package="Arbor Help System Widget Help Core" selector="registeredMenuView:">registeredMenuView: aMenuView	self balloon notNil ifTrue: [ 		aMenuView isNil			ifTrue: [self hideBalloon]			ifFalse: [				Balloon sensor forceActive: aMenuView.				self cachedBalloonText: nil]].	^RegisteredMenuView := aMenuView</body><body package="Arbor Help System Widget Help Core" selector="restrictBalloonToCondensedText">restrictBalloonToCondensedText	^RestrictBalloonToCondensedText</body><body package="Arbor Help System Widget Help Core" selector="restrictBalloonToCondensedText:">restrictBalloonToCondensedText: aBoolean 	RestrictBalloonToCondensedText := aBoolean</body><body package="Arbor Help System Widget Help Core" selector="widgetHelpEnabled">widgetHelpEnabled	^WidgetHelpEnabledModel value</body><body package="Arbor Help System Widget Help Core" selector="widgetHelpEnabled:">widgetHelpEnabled: aBoolean 	self widgetHelpEnabled ~= aBoolean 		ifTrue: [self widgetHelpEnabledModel value: aBoolean]</body><body package="Arbor Help System Widget Help Core" selector="widgetHelpEnabledModel">widgetHelpEnabledModel	^WidgetHelpEnabledModel</body></methods><methods><class-id>VWHelp.AHSWHCProcessor class</class-id> <category>private</category><body package="Arbor Help System Widget Help Core" selector="createBalloon">createBalloon	Balloon := AHSWHCBalloonWindow new.	Balloon windowType: #popUp;		displayBox: (100 @ 100 extent: 100 @ 100);		createSurface</body></methods><methods><class-id>VWHelp.AHSWHCProcessor class</class-id> <category>balloon help</category><body package="Arbor Help System Widget Help Core" selector="closeBalloon">closeBalloon	self hideBalloon.	Balloon close.	Balloon := nil.	CachedBalloonText := nil</body><body package="Arbor Help System Widget Help Core" selector="hideBalloon">hideBalloon	Object errorSignal 		handle: [:ex | ]		do: [Balloon unmap].</body></methods><methods><class-id>VWHelp.AHSWHCProcessor class</class-id> <category>change messages</category><body package="Arbor Help System Widget Help Core" selector="balloonHelpEnabledChanged">balloonHelpEnabledChanged	self balloonHelpEnabled 		ifTrue: [self createBalloon]		ifFalse: [self closeBalloon]</body><body package="Arbor Help System Widget Help Core" selector="helpEnabledChanged">helpEnabledChanged	(self helpEnabled not and: [self balloonHelpEnabled and: [Balloon notNil]]) 		ifTrue: [self closeBalloon]</body><body package="Arbor Help System Widget Help Core" selector="widgetHelpEnabledChanged">widgetHelpEnabledChanged</body></methods><methods><class-id>VWHelp.AHSWHCProcessor class</class-id> <category>utility</category><body package="Arbor Help System Widget Help Core" selector="bossInMacHelp">bossInMacHelp	"Answer the file-in string to install the Mac help code"	"self bossInMacHelp"	^'|fn cxt file|	"Try to find the filename in the context stack, which works since we''re in the middle of a file-in"	file := ''machelp.bos''.	cxt := thisContext.	fn := nil.	[cxt notNil and: [fn isNil]]		whileTrue: [((cxt receiver isKindOf: PeekableStream) and: [cxt receiver respondsTo: #ioConnection])						ifTrue: [fn := cxt receiver ioConnection name]						ifFalse: [cxt := cxt sender]].	fn notNil		ifTrue: [fn := fn asFilename directory constructString: file.				fn asFilename exists ifFalse: [fn := nil]].	fn isNil		ifTrue: ["look in current directory"				file asFilename exists					ifTrue: [fn := file]					ifFalse: [	fn := Dialog requestFileName: ''Where is the file machelp.bos?''								default: file								version: #mustBeOld								ifFail: [nil]]].	fn notNil		ifTrue: [ExternalInterface bossIn: fn]!'</body><body package="Arbor Help System Widget Help Core" selector="install:">install: selector	"Get the file-in string from LibraryObjects so it doesn't end up in the customer's image"	^((self respondsTo: #controller) and: [self controller respondsTo: #objectNamed:ifAbsent:])		ifTrue: [self controller objectNamed: selector ifAbsent: [String new]]		ifFalse: [String new]</body><body package="Arbor Help System Widget Help Core" selector="stateToArrayWithDefault:">stateToArrayWithDefault: aState	"Answer an array of sybols with #default as the last symbol"	"aState is &lt;Symbol | (Array of: Symbol)&gt;, and may or may not include #default"	^aState isSymbol		ifTrue: [aState = #default				ifTrue: [Array with: #default]				ifFalse: [Array with: aState with: #default]]		ifFalse: [(aState includes: #default)					ifTrue: [aState]					ifFalse: [aState copyWith: #default]].</body></methods><methods><class-id>VWHelp.AHSWHCProcessor class</class-id> <category>defaults</category><body package="Arbor Help System Widget Help Core" selector="defaultBalloonDisplayDelay">defaultBalloonDisplayDelay	"Answer the default millisecond value to be used to determine how long the mouse must be over a widget before balloon help is displayed."	^500</body><body package="Arbor Help System Widget Help Core" selector="defaultBalloonKillDelay">defaultBalloonKillDelay	"Answer the default millisecond value to be used to determine how long a help balloon should remain visible in the absence of any activity.."	^4000</body></methods><methods><class-id>VWHelp.AHSWHCProcessor class</class-id> <category>help enabling</category><body package="Arbor Help System Widget Help Core" selector="postOpenEnableHelpFor:">postOpenEnableHelpFor: aModel 	| helpProc entry |	(aModel builder window model ~= aModel and: 			["Probably a subcanvas"			aModel builder window model builder source ~= aModel]) 		ifTrue: 			["AppModel opened as dialog?"			^self].	entry := TmpStorage detect: [:each | each first first == aModel]				ifNone: [nil].	entry isNil ifTrue: [^self].	"Could happen if the #preBuildEnableHelpFor: was not invoked"	helpProc := entry at: 2.	entry first removeDependent: self.	TmpStorage remove: entry.	helpProc setWindow: aModel ahsWindow.	aModel ahsWindow isEventDriven		ifTrue: 			[| dispatcher |			dispatcher := self eventDispatcherClass on: aModel ahsWindow controller.			dispatcher				helpProcessor: helpProc;				dispatchUnknownEvents: aModel ahsWindow controller dispatcher 							dispatchUnknownEvents.			aModel ahsWindow controller dispatcher: dispatcher]		ifFalse: 			["Set up a replacement sensor, but copy inst vars over so we don't lose metaInput, etc."			| newSensor oldSensor |			newSensor := self windowSensorClass new helpProcessor: helpProc.			oldSensor := aModel ahsWindow sensor.			1 to: newSensor class superclass instSize				do: [:i | newSensor instVarAt: i put: (oldSensor instVarAt: i)].			oldSensor become: newSensor].	(helpProc helpEnabled not or: [helpProc widgetHelpEnabled not])		ifTrue: [helpProc applyHelpOffText].	"Work around a VW bug where in an event environment: if a dialog is opened from another dialog it doesn't get the enter event that makes the window the current window.  AHS will only display help for Window class&gt;&gt;currentWindow."	aModel ahsWindow becomeActive</body><body package="Arbor Help System Widget Help Core" selector="preBuildEnableHelpFor:">preBuildEnableHelpFor: aModel	"Locate a help processor.  If one is not found, create one and add it to TmpStorage.  Locating the correct help processor can be rather convoluted - note that this method may be called by both top-level models as well as subcanvases.  In addition, this method could be called by nested window openings so that the #postOpen has not yet been performed.  In general, do the following:	- check to see if the window is defined		- if not, create a help processor entry &amp; install in temp storage		- if so, try to locate a help processor in the temporary storage			- verify by checking aModel builder window model against temp storage values.			- if found, use it			- if none, then maybe a spurious subcanvas prebuild without an owner, so install 'bogus' mappings into the builder""This method operates under the premise that if the window is nil it's a top-level build, and if it's non-nil it's a subcanvas build."	|helpProc window |	(window := aModel ahsWindow) isNil		ifTrue: [|array|			helpProc := aModel class ahsProcessorClass new.				"create an entry in temp storage. Put aModel in a WeakArray so				we don't get old AHSWHCProcessor instances hanging around in TmpStorage				if we never make it to postOpenEnalbleHelpFor: for some reason. See update:				for the finalization procedure.				We have to put helpProc in a strong Array so it doesn't expire between now				and postBuildEnableHelpFor:"			array := Array with: (WeakArray with: aModel) with: helpProc.			array first addDependent: self.			TmpStorage add: array]		ifFalse: [			(helpProc := aModel ahsWindow ahsProcessor) isNil				ifTrue: [| entry |					entry := TmpStorage								detect: [:eachArray |	eachArray first first == window model]								ifNone: [nil].					entry notNil ifTrue: [helpProc := entry at: 2]]].	aModel builder		aspectAt: #ahsFlag put: (helpProc notNil ifTrue: [helpProc helpFlag] ifFalse: [false asValue]);		aspectAt: #ahsText put: (helpProc notNil ifTrue: [helpProc helpText] ifFalse: ['No help processor!' asValue]);		visualAt: #ahsIcon put: self ahsIcon;		subCanvasAt: nil at: #ahsSpec put: self ahsSpec.</body></methods><methods><class-id>VWHelp.AHSWHCProcessor class</class-id> <category>interface specs</category><body package="Arbor Help System Widget Help Core" selector="ahsSpec">ahsSpec	"Default to using the text and icon spec."	^self ahsTextAndIconSpec</body></methods><methods><class-id>VWHelp.AHSWHCProcessor class</class-id> <category>instance creation</category><body package="Arbor Help System Widget Help Core" selector="new">new	^super new initialize</body></methods><methods><class-id>VWHelp.AHSWHCProcessor class</class-id> <category>class initialization</category><body package="Arbor Help System Widget Help Core" selector="initialize">initialize	"self initialize"	TmpStorage := OrderedCollection new.	AHSIcon := self helpIcon0.	"modify this to switch the icon"	HelpEnabledModel := AHSWHCWeakValueHolder with: false.	HelpEnabledModel onChangeSend: #helpEnabledChanged to: self.	BalloonHelpEnabledModel := AHSWHCWeakValueHolder with: false.	BalloonHelpEnabledModel onChangeSend: #balloonHelpEnabledChanged to: self.	WidgetHelpEnabledModel := AHSWHCWeakValueHolder with: false.	WidgetHelpEnabledModel onChangeSend: #widgetHelpEnabledChanged to: self.	RestrictBalloonToCondensedText := false.	CachedBalloonText := #{Smalltalk.Text} value new.	BalloonDisplayDelay := nil.	BalloonKillDelay := nil.	Balloon := nil</body></methods><methods><class-id>VWHelp.AHSWHCTransientWindow</class-id> <category>private</category><body package="Arbor Help System Widget Help Core" selector="privateClose">privateClose	"VWHelp addition to enable clean unload of the containing Widget Help parcel"	#{UI.InputManager} value default releaseWindow: self.	self key isNil	ifFalse:[self primClose].	self becomeInactive</body></methods><methods><class-id>VWHelp.AHSWHCTransientWindow</class-id> <category>accessing</category><body package="Arbor Help System Widget Help Core" selector="spawningView">spawningView	^spawningView</body><body package="Arbor Help System Widget Help Core" selector="spawningView:">spawningView: aView	spawningView := aView.</body></methods><methods><class-id>VWHelp.AHSWHCTransientWindow</class-id> <category>initialize-release</category><body package="Arbor Help System Widget Help Core" selector="recycleTransient">recycleTransient	super recycleTransient.	self spawningView: nil.</body></methods><methods><class-id>VWHelp.AHSWHCTransientWindow class</class-id> <category>class initialization</category><body package="Arbor Help System Widget Help Core" selector="emptyCaches">emptyCaches	"Clear the caches."	CachedPopUp := nil.	CachedPostedMenu := nil.</body><body package="Arbor Help System Widget Help Core" selector="initialize">initialize	self emptyCaches.</body><body package="Arbor Help System Widget Help Core" selector="obsolete">obsolete	"The class is going away..."	self resetCaches.	super obsolete.</body><body package="Arbor Help System Widget Help Core" selector="resetCaches">resetCaches	"Clear the caches and insert TransientWindow instances in them."	self emptyCaches.	(TransientWindow aPopUpIn: (0 @ 0 extent: 120 @ 120))		windowManager: NullWindowManager new;		recycleTransient.	(TransientWindow aPostedMenuIn: (0 @ 0 extent: 120 @ 120))		windowManager: NullWindowManager new;		recycleTransient</body></methods><methods><class-id>VWHelp.AHSWHCBalloonWindow</class-id> <category>accessing</category><body package="Arbor Help System Widget Help Core" selector="map">map	"Don't use my parent's implementation since that causes the parent window to become deactivated."	self setHostBackgroundColor.	self primMap.</body><body package="Arbor Help System Widget Help Core" selector="parentWindow">parentWindow	^parentWindow</body><body package="Arbor Help System Widget Help Core" selector="parentWindow:">parentWindow: aWindow	parentWindow := aWindow</body><body package="Arbor Help System Widget Help Core" selector="primMap">primMap	| result |	mapStatus := true.	result := super primMap.	"Work around a VW bug in an event environment: if this window is opened from a dialog it doesn't get the enter event which triggers the parentWindow to become active.  So we coerce the parentWindow being made active here.  Note that there are extra caveats for when this window is opened from a menu - see AHSWHCBalloonSensor&gt;&gt;enterEvent: for details."	self parentWindow becomeActive.	^result</body><body package="Arbor Help System Widget Help Core" selector="unmap">unmap	mapStatus := false.	^ super unmap</body></methods><methods><class-id>VWHelp.AHSWHCBalloonWindow</class-id> <category>testing</category><body package="Arbor Help System Widget Help Core" selector="isMapped">isMapped	^ mapStatus = true</body></methods><methods><class-id>VWHelp.AHSWHCBalloonWindow</class-id> <category>private</category><body package="Arbor Help System Widget Help Core" selector="sensorClass">sensorClass	"Answer what kind of sensor is preferred for this window"	^AHSWHCBalloonSensor</body></methods><methods><class-id>VWHelp.AHSWHCWeakValueHolder</class-id> <category>changing</category><body package="Arbor Help System Widget Help Core" selector="changed:">changed: anAspectSymbol	anAspectSymbol == #value		ifTrue: [accessLock critical: [					interests with: selectors do: [:obj :sel |						obj == 0 ifFalse: [obj perform: sel]]]].	^super changed: anAspectSymbol</body></methods><methods><class-id>VWHelp.AHSWHCWeakValueHolder</class-id> <category>updating</category><body package="Arbor Help System Widget Help Core" selector="update:with:from:">update: anAspectSymbol with: aParameter from: aSender	"Finalize all finalizable entries of aSender."	(aSender == interests and: [anAspectSymbol = #ElementExpired])		ifTrue: [self finalizeElements]		ifFalse: [^self]</body></methods><methods><class-id>VWHelp.AHSWHCWeakValueHolder</class-id> <category>private</category><body package="Arbor Help System Widget Help Core" selector="breakDependents">breakDependents	super breakDependents.	accessLock critical: [		interests := WeakArray new.		selectors := Array new]</body></methods><methods><class-id>VWHelp.AHSWHCWeakValueHolder</class-id> <category>finalization</category><body package="Arbor Help System Widget Help Core" selector="finalizeElements">finalizeElements	|deathMarker|	accessLock critical: [	deathMarker := 1.	[deathMarker ~= 0]		whileTrue: [(deathMarker := interests								indexOf: 0								replaceWith: nil								startingAt: deathMarker								stoppingAt: interests size) = 0						ifFalse: 							[selectors at: deathMarker put: nil]].	interests := WeakArray withAll: (interests copyWithout: nil).	interests addDependent: self.	selectors := selectors copyWithout: nil]</body></methods><methods><class-id>VWHelp.AHSWHCWeakValueHolder</class-id> <category>interests</category><body package="Arbor Help System Widget Help Core" selector="onChangeSend:to:">onChangeSend: aSymbol to: anObject 	"Arrange to receive a message with aSymbol when the value aspect 	changes on anObject."	|newInterests|	accessLock critical: [	newInterests := WeakArray new: interests size + 1.	newInterests		replaceFrom: 1		to: interests size		with: interests		startingAt: 1.	newInterests at: newInterests size put: anObject.	interests := newInterests.	interests addDependent: self.	selectors := selectors copyWith: aSymbol]</body><body package="Arbor Help System Widget Help Core" selector="retractInterestsFor:">retractInterestsFor: anObject 	"Undo a send of onChangeSend:to:."	|index|	accessLock critical: [	index := interests indexOf: anObject ifAbsent: [^nil].	interests := WeakArray withAll:			(interests copyFrom: 1 to: index - 1) ,			(interests copyFrom: index + 1 to: interests size).	selectors := (selectors copyFrom: 1 to: index - 1) ,			(selectors copyFrom: index + 1 to: selectors size)]</body></methods><methods><class-id>VWHelp.AHSWHCWeakValueHolder</class-id> <category>initialize-release</category><body package="Arbor Help System Widget Help Core" selector="initialize">initialize	super initialize.	interests := WeakArray new.	selectors := Array new.	accessLock := RecursionLock new</body></methods><methods><class-id>VWHelp.AHSWHCWindowSensor</class-id> <category>event processing</category><body package="Arbor Help System Widget Help Core" selector="eventButtonRelease:">eventButtonRelease: event	"A mouse button has been released while the cursor is in this window. Do 	whatever is appropriate.  In the default system, we pause a moment so that	the user process has time to register a fast mouse click."	ButtonDelay wait.	ButtonDelay wait.	self pollForHelp</body><body package="Arbor Help System Widget Help Core" selector="eventEnter:">eventEnter: event	"This window has become the current mouse focus."		"We need to poll for help after an enter event in order to update the help		after a Menu is closed, but AFTER the parent window is made active so the		pollForHelp will pay attention"	super eventEnter: event.	self pollForHelp</body><body package="Arbor Help System Widget Help Core" selector="eventExit:">eventExit: event 	"This window is no longer the current mouse focus."	self helpProcessor balloonHelpEnabled 		ifTrue: [self helpProcessor hideBalloon].	super eventExit: event</body><body package="Arbor Help System Widget Help Core" selector="eventMouseMoved:">eventMouseMoved: event	"The mouse has changed position or a certain time has elapsed.  	Test whether another poll for help is needed."	self pollForHelp.	super eventMouseMoved: event</body><body package="Arbor Help System Widget Help Core" selector="keyAt:character:alternative:down:">keyAt: keyNumber character: aCharacter alternative: alternativeCharacter down: isDownTransition 	"If the key pressed was #Help, #F1, or alt-? remember that"	isDownTransition 		ifTrue: 			[| n |			(aCharacter isInteger and: [aCharacter &gt; 0]) 				ifTrue: [n := InputState keyNameFor: aCharacter]				ifFalse: [n := aCharacter].			(n == #Help 				or: [n == #F1 or: [(n == $/ or: [n == $?]) and: [InputState default altDown]]]) 					ifTrue: [self extendedHelpRequest]					ifFalse: 						[n == #F2 							ifTrue: [self editHelpRequest]							ifFalse: 								[n == #F3 									ifTrue: [self toggleBubbleRequest]									ifFalse: 										[super 											keyAt: keyNumber											character: aCharacter											alternative: alternativeCharacter											down: isDownTransition]]]]		ifFalse: 			[super 				keyAt: keyNumber				character: aCharacter				alternative: alternativeCharacter				down: isDownTransition]</body></methods><methods><class-id>VWHelp.AHSWHCWindowSensor</class-id> <category>accessing</category><body package="Arbor Help System Widget Help Core" selector="editHelpRequest">editHelpRequest	self helpProcessor notNil ifTrue: [self helpProcessor editHelpRequest]</body><body package="Arbor Help System Widget Help Core" selector="extendedHelpRequest">extendedHelpRequest	self helpProcessor notNil ifTrue: [self helpProcessor extendedHelpRequest]</body><body package="Arbor Help System Widget Help Core" selector="helpProcessor">helpProcessor	^(helpProcessor isNil			and: [self window model notNil "model is nil during close"					and: [self window model class ahsProcessorClass notNil]])		ifTrue: [helpProcessor := self window model class ahsProcessorClass new setWindow: self window]		ifFalse: [helpProcessor]</body><body package="Arbor Help System Widget Help Core" selector="pollForHelp">pollForHelp	self helpProcessor notNil		ifTrue: [self helpProcessor pollForHelp]</body><body package="Arbor Help System Widget Help Core" selector="toggleBubbleRequest">toggleBubbleRequest	self helpProcessor notNil ifTrue: [self helpProcessor toggleBubbleRequest]</body></methods><methods><class-id>VWHelp.AHSWHCWindowSensor</class-id> <category>private</category><body package="Arbor Help System Widget Help Core" selector="helpProcessor:">helpProcessor: aHelpProcessor	helpProcessor := aHelpProcessor</body></methods><methods><class-id>Core.LookupKey</class-id> <category>Arbor Core adds</category><body package="Arbor Help System Widget Help Core" selector="aisIsAssociation">aisIsAssociation	^true</body></methods><methods><class-id>UI.ScheduledWindow class</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsPredefinedStates">ahsPredefinedStates	"Answer an array of predefined states"	^#()</body></methods><methods><class-id>UI.ScheduledWindow</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsActivityPoint">ahsActivityPoint	"Answer a window-relative point which indicates the location considered active.  Windows by themselves don't have such a point."	^0@0</body><body package="Arbor Help System Widget Help Core" selector="ahsClient">ahsClient	^self model</body><body package="Arbor Help System Widget Help Core" selector="ahsCursorState">ahsCursorState	"Answer the ahsState value as it applies to the current cursor position."	^self ahsStateAt: self sensor cursorPoint</body><body package="Arbor Help System Widget Help Core" selector="ahsHasComponent">ahsHasComponent	^true</body><body package="Arbor Help System Widget Help Core" selector="ahsID">ahsID	^#ahsBackground</body><body package="Arbor Help System Widget Help Core" selector="ahsPredefinedStates">ahsPredefinedStates	^self class ahsPredefinedStates</body><body package="Arbor Help System Widget Help Core" selector="ahsProcessor">ahsProcessor	"Answer the AHSProcessor or nil if there isn't one"	^Object messageNotUnderstoodSignal		handle: [:ex | ex returnWith: nil]		do: [self isEventDriven				ifTrue: [self controller dispatcher helpProcessor]				ifFalse: [self sensor helpProcessor]]</body><body package="Arbor Help System Widget Help Core" selector="ahsState">ahsState	^#default</body><body package="Arbor Help System Widget Help Core" selector="ahsStateAt:">ahsStateAt: aWindowRelativePoint	^self ahsState</body><body package="Arbor Help System Widget Help Core" selector="container">container	^nil</body></methods><methods><class-id>UI.ScheduledWindow</class-id> <category>AHSWHC mods</category><body package="Arbor Help System Widget Help Core" selector="processEvent:">processEvent: anEvent	"Dispatch the event to the appropriate method."	| type |	type := anEvent key.	type == #resize		ifTrue:			[self extentEvent: anEvent value.			^self updateEvent: type].	type == #close		ifTrue:	[^self controller close].	type == #destroy		ifTrue:	[^self processDestroyEvent: anEvent value].	type == #doubleClick		ifTrue: [^self downcastLocalEvent: type with: nil at: anEvent value from: self].	(type == #collapse or: [type == #exit or: [type == #move]])		ifTrue:	[^self updateEvent: type].	type == #eventUnknown		ifTrue: [^self unknownEvent: anEvent value].	"AHS: The following code was added to implement #block events"	"----- start here -----"	anEvent key == #block		ifTrue: [anEvent value value].	"----- end here -----"</body></methods><methods><class-id>UI.MenuView</class-id> <category>AHSWHC mods</category><body package="Arbor Help System Widget Help Core" selector="ahsProcessor">ahsProcessor	"Answer my help processor, if I have one."	| tc |	^(((tc := self topComponent) respondsTo: #spawningView)		and: [tc spawningView notNil		and: [(tc := tc spawningView topComponent) respondsTo: #ahsProcessor]])			ifTrue: [tc ahsProcessor]			ifFalse: [nil]</body><body package="Arbor Help System Widget Help Core" selector="ahsUpdateMenuHelpFor:">ahsUpdateMenuHelpFor: aMenuItemView	"Update the help (if present) to reflect aMenuItemView."	| helpProcessor view |	(helpProcessor := self ahsProcessor) isNil ifTrue: [^self].	view := self topComponent spawningView.	aMenuItemView isNil		ifTrue: [helpProcessor menuItemSelected: view label: #default]		ifFalse: 	[| menuView key |			menuView := aMenuItemView menuView.			key := aMenuItemView menuItem label.			[menuView parentMenuItemView isNil]				whileFalse: 					[menuView := menuView parentMenuItemView menuView.					key := menuView highlightedMenuItemView model label , '/' , key].			menuView parentMenuBarButtonView notNil				ifTrue: [key := menuView parentMenuBarButtonView label text asString, '/', key].			helpProcessor menuItemSelected: view label: key focus: self].</body><body package="Arbor Help System Widget Help Core" selector="highlightedMenuItemView:">highlightedMenuItemView: aMenuItemView	"Set the MenuItemView that is currently highlighted by the user.  A parameter of nil indicates no MenuItemView is currently hilighted.	MenuItemViews do NOT redisplay on their own initiative, we send them redisplay messages."	| helpProc |	highlightedMenuItemView == nil ifFalse: [		| theLastHighlightedView |		theLastHighlightedView := highlightedMenuItemView.		highlightedMenuItemView := nil.		theLastHighlightedView resignSelection.		theLastHighlightedView redisplay].	highlightedMenuItemView := aMenuItemView.	aMenuItemView == nil ifFalse: [		aMenuItemView redisplay.		selectedValue := self menu valueForMenuItem: aMenuItemView menuItem].	"-- AHS added: start here --"	(helpProc := self ahsProcessor) notNil ifTrue: [		helpProc registeredMenuView: self topComponent.		self submenuClosed].	(aMenuItemView notNil or: [(self bounds containsPoint: self controller sensor cursorPoint) not])		ifTrue: [			self ahsUpdateMenuHelpFor: (aMenuItemView isNil												ifTrue: [self parentMenuItemView]												ifFalse: [aMenuItemView])].	"-- end here --"</body><body package="Arbor Help System Widget Help Core" selector="mapAndStartup:">mapAndStartup: aWindow	"Map the menu window onto the screen and startup the controller."	"-- AHS added: start here --"	| helpProcessor |	helpProcessor := self ahsProcessor.	helpProcessor notNil ifTrue: [helpProcessor registeredMenuView: aWindow].	"-- end here --"	[aWindow scheduleWindow.	aWindow map.	self controller startUp] ensure: 		[self menuWindowRecycle: aWindow.		"-- AHS added: start here --"		helpProcessor notNil ifTrue: [helpProcessor registeredMenuView: nil].		"-- end here --"		parentMenuItemView ifNotNil: 			[parentMenuItemView menuView submenuClosed.			"-- AHS added: start here --"			(helpProcessor notNil and: [parentMenuItemView menuView topComponent isOpen]) ifTrue: 			[helpProcessor registeredMenuView: parentMenuItemView menuView topComponent].			"-- end here --"].		Screen default receiveAndProcessAllEvents]</body><body package="Arbor Help System Widget Help Core" selector="menuWindowOn:in:">menuWindowOn: screen in: aRectangle 	"Answer a window for use in placing the receiver on screen with aRectangle for a displayBox."	"There is no protocol to specify what screen you want the window on so the screen parameter must be ignored for now."	"Posted menus are required to support keyboard, but popups might not."	"-- AHS modified --"	^self supportsKeyboard 		ifTrue: [(#{AHSWHCTransientWindow} valueOrDo: [TransientWindow]) aPostedMenuIn: aRectangle]		ifFalse: [(#{AHSWHCTransientWindow} valueOrDo: [TransientWindow]) aPopUpIn: aRectangle]</body><body package="Arbor Help System Widget Help Core" selector="noSelectedMenuItem">noSelectedMenuItem	"No MenuItem was fully selected by the user so no selection was made from the menu.  This message is sent by the MenuItemView."	selectedValue := nil.	selectionFinal := true.	"-- AHS added: start here --"	self ahsUpdateMenuHelpFor: self parentMenuItemView.	"-- end here --"</body><body package="Arbor Help System Widget Help Core" selector="setColorsInMenuWindow:from:">setColorsInMenuWindow: aWindow from: spawningViewOrNil	"Set the color preferences for the menu window.  If non-nil, spawningViewOrNil is the view that	spawned the menu."	| thePaintPreferences theBackgroundColor |	thePaintPreferences := (parentMenuItemView == nil		ifTrue: [| widgetPolicyView |			"The nil check is here to support the backward compatibility of the openAt: message."			widgetPolicyView := spawningViewOrNil == nil ifTrue: [aWindow] ifFalse: [spawningViewOrNil].			widgetPolicyView paintPreferences]		ifFalse: [parentMenuItemView paintPreferences]).	aWindow paintPreferences: thePaintPreferences.	theBackgroundColor := model backgroundColor.	theBackgroundColor == nil ifTrue: [		theBackgroundColor := thePaintPreferences matchAt: self primarySymbolicBackground].	aWindow background: theBackgroundColor.	"-- AHS added: start here"	(aWindow respondsTo: #spawningView:) ifTrue: [		spawningViewOrNil = self parentMenuItemView			ifTrue: [| tc |				((tc := self parentMenuItemView menuView topComponent) respondsTo: #spawningView)					ifTrue: [aWindow spawningView: tc spawningView]					ifFalse: [aWindow spawningView: nil]]			ifFalse: [aWindow spawningView: spawningViewOrNil]].	"-- end here --"</body></methods><methods><class-id>UI.BooleanWidgetView class</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsPredefinedStates">ahsPredefinedStates	^#(on)</body></methods><methods><class-id>UI.BooleanWidgetView</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsState">ahsState	^self isSelected		ifTrue: [#on]		ifFalse: [#default]</body></methods><methods><class-id>UI.ApplicationModel class</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsProcessorClass">ahsProcessorClass	"To enable the Arbor Help System for the receiver, either override this method and answer 	 a specific class to use (typically AHSWHCProcessor or a subclass), or override the arborHelpEnabled 	 method to answer true."	^self arborHelpEnabled 		ifTrue: [(#{AHSUtils} valueOrDo: [^nil]) defaultHelpProcessorClass]		ifFalse: [nil]</body><body package="Arbor Help System Widget Help Core" selector="arborHelpEnabled">arborHelpEnabled	"Answer true if the Arbor Help System is to be enabled for this application.  The default is false."	^false</body></methods><methods><class-id>UI.ApplicationModel</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsHelpRequest:widgetID:state:client:">ahsHelpRequest: aText widgetID: id state: state client: client	"Hook to give the window's application model a chance to override help	AFTER the help system has done its normal lookup.	Arbor Help System is about to display the help aText in either	a text widget or balloon. id and state were used to lookup aText	in the help associated with client, which is this application model or	a subcanvas' application model.	This is the application model's chance to veto or modify the help.	Answer nil to prevent the help from being displayed (in which case	the help text widget will not be touched), or answer	a Text object, either aText or a different one to be displayed instead.	The default is to answer aText"	^aText</body><body package="Arbor Help System Widget Help Core" selector="ahsHelpTextForComponent:offset:client:">ahsHelpTextForComponent: aVisualComponent offset: aPoint client: client	"Hook to give the top application model a chance to override the lookup of help.  If answers a Text, then will use that text instead of the normal help system lookup.  client is the applicationModel that defines aVisualComponent, and aPoint is the 'interesting' location offset from the component's origin.  aVisualComponent is guaranteed to answer a non-nil ahsID.  The application model has the option of overriding this method or ahsHelpTextForID:state:client:."	"The default implementation is to iterate over the states calling ahsHelpTextForID:state:client:, defaulting to #default"	|ahsState stateArray helpText |	ahsState := aVisualComponent ahsStateAt: aPoint.	stateArray := #{VWHelp.AHSWHCProcessor} value stateToArrayWithDefault: ahsState.	stateArray do: [:state |		helpText := self ahsHelpTextForID: aVisualComponent ahsID state: state client: client.		helpText notNil ifTrue: [^helpText]].	^nil</body><body package="Arbor Help System Widget Help Core" selector="ahsHelpTextForID:state:client:">ahsHelpTextForID: id state: state client: client	"Hook to give the top application model a chance to override the lookup of help.	If answers a Text, then will use that text instead of the normal help system lookup"	"The application model has the option of overriding this method or ahsHelpTextForComponent:client:"	^nil</body><body package="Arbor Help System Widget Help Core" selector="ahsOutlineLinkForComponent:offset:client:">ahsOutlineLinkForComponent: aVisualComponent offset: aPoint client: client	"Hook to give the top application model a chance to override the lookup of help.  If answers an outline link, then will use that instead of the normal help system lookup.  The application model has the option of overriding this method or ahsOutlineLinkForID:state:client:.  An outline link is of the form &lt;Array with: String with: (nil | Integer)&gt;.  The first String is either an outline name or, if it's a Symbol, will be interpreted as a message selector for custom F1 behavior."	"The default implementation is to iterate over the states calling ahsOutlineLinkForID:state:client:, defaulting to #default"	|ahsState stateArray link |	ahsState := aVisualComponent ahsStateAt: aPoint.	stateArray := #{VWHelp.AHSWHCProcessor} value stateToArrayWithDefault: ahsState.	stateArray do: [:state |		link := self ahsOutlineLinkForID: aVisualComponent ahsID state: state client: client.		link notNil ifTrue: [^link]].	^nil</body><body package="Arbor Help System Widget Help Core" selector="ahsOutlineLinkForID:state:client:">ahsOutlineLinkForID: id state: state client: client	"Hook to give the top application model a chance to override the lookup of help.	If answers an outline link, then will use that instead of the normal help system lookup"	"The application model has the option of overriding this method or ahsOutlineLinkForComponent:client:"	"An outline link is of the form &lt;Array with: String with: (nil | Integer)&gt;.	The first String is either an outline name or, if it's a Symbol, will be interpreted as a message selector for	custom F1 behavior"	^nil</body><body package="Arbor Help System Widget Help Core" selector="ahsWindow">ahsWindow	^self builder isNil		ifTrue: [nil]		ifFalse: [self builder window]</body></methods><methods><class-id>UI.ApplicationModel</class-id> <category>AHSWHC mods</category><body package="Arbor Help System Widget Help Core" selector="postOpenWith:">postOpenWith: aBuilder 	"This message is sent by the builder after it has opened a completed 	window."	^self messageNotUnderstoodSignal		handle: [:ex | ex parameter selector == #ahsProcessorClass						ifTrue: [ex return]						ifFalse: [ex reject]]		do: [ |hlpClass|			(hlpClass := self class ahsProcessorClass) notNil				ifTrue: [hlpClass postOpenEnableHelpFor: self]]</body><body package="Arbor Help System Widget Help Core" selector="preBuildWith:">preBuildWith: aBuilder 	"This message is sent by the builder prior to beginning construction 	of either a SubCanvas or a complete window."	^self messageNotUnderstoodSignal		handle: [:ex | ex parameter selector == #ahsProcessorClass						ifTrue: [ex return]						ifFalse: [ex reject]]		do: [ |hlpClass|			(hlpClass := self class ahsProcessorClass) notNil				ifTrue: [hlpClass preBuildEnableHelpFor: self]]</body></methods><methods><class-id>UI.ApplicationModel</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="widgetWithID:">widgetWithID: aSymbol	^self builder componentAt: aSymbol</body></methods><methods><class-id>UI.ToggleButtonController</class-id> <category>AHSWHC mods</category><body package="Arbor Help System Widget Help Core" selector="pressAction">pressAction	"Do the action associated with pressing the button."	view isEnabled ifFalse: [^self].	self requestValueChange		ifTrue: [| rv |				((rv := view getReferenceValue) == nil or: [rv isKindOf: Boolean])					ifTrue: [model value == nil								ifTrue: [model value: true]								ifFalse: [model value: model value not]]					ifFalse: [model value: rv].				self valueChange.				"-- AHS added: start here --"				"Must check for nil in case this button closes the window"				(self view notNil and: [self view topComponent respondsTo: #ahsProcessor])					ifTrue: [ |helpProc|							helpProc := self view topComponent ahsProcessor.							helpProc notNil								ifTrue: [helpProc focusChanged]].				"-- end here --"				self view invalidate]</body></methods><methods><class-id>Core.Object</class-id> <category>Arbor Core adds</category><body package="Arbor Help System Widget Help Core" selector="aisIsAssociation">aisIsAssociation	^false</body></methods><methods><class-id>UI.MenuBarWrapper class</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsPredefinedStates">ahsPredefinedStates	"Answer an array of predefined states"	^#()</body></methods><methods><class-id>UI.MenuBarWrapper</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsID">ahsID		^#menuBar</body><body package="Arbor Help System Widget Help Core" selector="ahsStateAt:">ahsStateAt: aWindowRelativePoint	| borderedWrapper |	borderedWrapper := self component hitDetect: (self component globalPointToLocal: aWindowRelativePoint).	^borderedWrapper isNil		ifTrue: [#default]		ifFalse: [ |menuBarButtonView|			menuBarButtonView := borderedWrapper component.			menuBarButtonView label text  asSymbol]</body></methods><methods><class-id>UI.View</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsCursorState">ahsCursorState	"Answer the ahsState value as it applies to the current cursor position."	^self ahsStateAt: (self localPointToGlobal: self controller sensor cursorPoint)</body></methods><methods><class-id>UI.ComboBoxSpec</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsStateAt:for:">ahsStateAt: aWidgetRelativePoint for: aComboBoxView	|val|	val := aComboBoxView editor model value.	^(val isNil or: [val displayString isEmpty])		ifTrue: [#default]		ifFalse: [val displayString asSymbol]</body></methods><methods><class-id>UI.SequenceController</class-id> <category>AHSWHC mods</category><body package="Arbor Help System Widget Help Core" selector="processKeyboardEvent:">processKeyboardEvent: anEvent	[| event keyValue |	event := anEvent.	keyboardHook isNil ifFalse: [event := keyboardHook value: event value: self].	event isNil ifTrue: [^self].	(keyboardProcessor isBackTab: anEvent) ifTrue: 		[view triggerEvent: #backTabbed.		^keyboardProcessor prevFieldFrom: self].	keyValue := event keyValue.	(keyValue isKindOf: Character) ifFalse: 		[keyValue == #Down ifTrue: [^self selectTheNext].		keyValue == #Up ifTrue: [^self selectThePrev].		keyValue == #Left ifTrue: [^self selectTheHPrev].		keyValue == #Right ifTrue: [^self selectTheHNext].		keyValue == #PageDown ifTrue: [^self selectNextPage].		keyValue == #PageUp ifTrue: [^self selectPrevPage].		keyValue == #Home ifTrue: [^self selectTheFirst].		keyValue == #End ifTrue: [^self selectTheLast].		^self].	keyValue == Character tab ifTrue: 		[view triggerEvent: #tabbed.		^keyboardProcessor nextFieldFrom: self].	keyValue == Character cr ifTrue: 		[keyboardProcessor focusIsShifting: true.		self selectTarget.		keyboardProcessor focusIsShifting ifTrue: [keyboardProcessor doDefaultAction].		keyboardProcessor focusIsShifting: false.		^self].	keyValue == Character space ifTrue: [^self pressActionWithEvent: event].	self searchChar: keyValue]		ensure: [			"AHS: Added"			"-- start here --"			(self view notNil and: [self view topComponent respondsTo: #ahsProcessor])				ifTrue: [|helpProc|					helpProc := self view topComponent ahsProcessor.					helpProc notNil						ifTrue: [helpProc focusChanged]]			"-- end here --"]</body><body package="Arbor Help System Widget Help Core" selector="toggleTarget">toggleTarget	| index |	searchString := nil.	index := view targetIndex.	index = view zeroIndex ifTrue: [^self].	self requestValueChange		ifTrue: 			[	self toggleAt: index.				self valueChange.				"AHS added: start here"				(self view notNil						and: [self view topComponent respondsTo: #ahsProcessor])					ifTrue: 						[|helpProc|						helpProc := self view topComponent ahsProcessor.						helpProc notNil							ifTrue: [helpProc focusChanged]].				"end here"]</body></methods><methods><class-id>UI.RadioButtonSpec class</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsPredefinedStates">ahsPredefinedStates	^#(disabled on)</body></methods><methods><class-id>UI.RadioButtonSpec</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsStateAt:for:">ahsStateAt: aWidgetRelativePoint for: aRadioButtonView	^aRadioButtonView isSelected		ifTrue: [#on]		ifFalse: [#default]</body></methods><methods><class-id>Graphics.VisualComponent class</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsPredefinedStates">ahsPredefinedStates	"Answer the state symbols, other than #default, that are predefined for this type of widget"	^#()</body></methods><methods><class-id>Graphics.VisualComponent</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsActivityPoint">ahsActivityPoint	"Answer a window-relative point which indicates the location in the widget that is considered active.  This value may be used when performing help lookup due to keyboard activity rather than mouse activity."	^self localPointToGlobal: self bounds origin</body><body package="Arbor Help System Widget Help Core" selector="ahsClient">ahsClient	"Answer the object used as a source for getting help information.	The client's class is used as a key for real-time help storage"	^nil</body><body package="Arbor Help System Widget Help Core" selector="ahsCursorState">ahsCursorState	"Answer the ahsState value as it applies to the current cursor position."	^self ahsStateAt: (self localPointToGlobal: 0@0)</body><body package="Arbor Help System Widget Help Core" selector="ahsHasComponent">ahsHasComponent	"Answer whether I have a distinguished component that I	can answer with the message #component"	^false</body><body package="Arbor Help System Widget Help Core" selector="ahsHasComponents">ahsHasComponents	"Answer whether I have components that I	can answer with the message #components"	^false</body><body package="Arbor Help System Widget Help Core" selector="ahsID">ahsID	"Answer a Symbol used to identify the receiver for purposes of looking	up help info. Answer nil if no help can be associated with the receiver"	^nil</body><body package="Arbor Help System Widget Help Core" selector="ahsPredefinedStates">ahsPredefinedStates	"Answer the state symbols, other than #default, that are predefined for this type of widget"	^self class ahsPredefinedStates</body><body package="Arbor Help System Widget Help Core" selector="ahsState">ahsState	"See #ahsStateAt:"	^#default</body><body package="Arbor Help System Widget Help Core" selector="ahsStateAt:">ahsStateAt: aWindowRelativePoint	"Answer a Symbol that denotes the state of the receiver with respect to aWindowRelativePoint, a point that is window-relative.  Alternatively, answer an array of symbols that denote multiple states, given in the order of preference, as in the case of tables"	^self ahsState</body></methods><methods><class-id>UI.TextEditorView</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsID">ahsID	"Override ComposedTextView, since my SpecWrapper handles the id"	^nil</body><body package="Arbor Help System Widget Help Core" selector="preferredBounds">preferredBounds	"The preferred bounds really should include the inset area (which is always subtracted from the clipping box before displaying)."	| box |	box := displayContents preferredBounds expandedBy: self paragraphInset.	^box translatedBy: box origin negated</body></methods><methods><class-id>UI.SequenceViewSpec class</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsPredefinedStates">ahsPredefinedStates	^#(disabled empty)</body></methods><methods><class-id>UI.SequenceViewSpec</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsStateAt:for:">ahsStateAt: aWidgetRelativePoint for: aSequenceView	| index |	aSequenceView sequence isEmpty		ifTrue: [^#empty].	(aSequenceView bounds containsPoint: aWidgetRelativePoint)		ifFalse: [^#default].	index := aSequenceView elementIndexFor: aWidgetRelativePoint.	^(aSequenceView sequence size &gt;= index)		ifTrue: [(aSequenceView displayStringAt: index) asSymbol]		ifFalse: [#default]</body></methods><methods><class-id>UI.DataSetSpec</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsStateAt:for:">ahsStateAt: aWidgetRelativePoint for: aDataSetView	|index  |		"To change so that the state is directed by the cursor			and not the selection, substitute the following			to determine the index:"	"(aDataSetView containsPoint: aWidgetRelativePoint)		ifFalse: [^#default].	index := aDataSetView cellIndexFor: aWidgetRelativePoint.	^Array with: index printString asSymbol			with: (0 @ index y) printString asSymbol			with: (index x @ 0) printString asSymbol"	index := aDataSetView editCell.	^index isNil		ifTrue: [#default]		ifFalse: [Array with: index printString asSymbol						with: (0 @ index y) printString asSymbol						with: (index x @ 0) printString asSymbol]</body></methods><methods><class-id>UI.SelectionView</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsActivityPoint">ahsActivityPoint	"Answer a window-relative point which indicates the location in the widget that is considered active.  This value may be used when performing help lookup due to keyboard activity rather than mouse activity."	^self targetIndex = self zeroIndex		ifTrue: [super ahsActivityPoint]		ifFalse: [self localPointToGlobal: (self boundsOfElementIndex: self targetIndex inBounds: self bounds) origin]</body></methods><methods><class-id>UI.NoteBookSpec class</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsPredefinedStates">ahsPredefinedStates	^#(disabled defaultRight defaultBottom)</body></methods><methods><class-id>UI.NoteBookSpec</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsStateAt:for:">ahsStateAt: aWidgetRelativePoint for: aNoteBookComposite	| index local |	local := aNoteBookComposite rightTabBar				globalPointToLocal: (aNoteBookComposite localPointToGlobal: aWidgetRelativePoint).	(aNoteBookComposite rightTabBar containsPoint: local)		ifTrue: [			index := aNoteBookComposite rightTabBar elementIndexFor: local.			^(index between: 1 and: aNoteBookComposite rightTabBar numberOfElements)				ifTrue: [(aNoteBookComposite rightTabBar displayStringAt: index) asSymbol]				ifFalse: [#defaultRight]].	local := aNoteBookComposite bottomTabBar				globalPointToLocal: (aNoteBookComposite localPointToGlobal: aWidgetRelativePoint).	(aNoteBookComposite bottomTabBar containsPoint: local)		ifTrue: [			index := aNoteBookComposite bottomTabBar elementIndexFor: local.			^(index between: 1 and: aNoteBookComposite bottomTabBar numberOfElements)				ifTrue: [(aNoteBookComposite bottomTabBar displayStringAt: index) asSymbol]				ifFalse: [#defaultBottom]].	self majorTabsOnRight		ifTrue: [((index := aNoteBookComposite rightTabBar selectionIndex) isZero not								"index can be 1 but the sequence can still be empty"							and: [aNoteBookComposite rightTabBar sequence isEmpty not])						ifTrue: [^(aNoteBookComposite rightTabBar displayStringAt: index) asSymbol]]		ifFalse: [((index := aNoteBookComposite bottomTabBar selectionIndex) isZero not								"index can be 1 but the sequence can still be empty"							and: [aNoteBookComposite bottomTabBar sequence isEmpty not])						ifTrue: [^(aNoteBookComposite bottomTabBar displayStringAt: index) asSymbol]].	^#default</body></methods><methods><class-id>UI.ComposedTextView</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsID">ahsID	^#value</body></methods><methods><class-id>Core.String</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="condensedText">condensedText	"Make myself protocol-compatible with AHSTextBinder."	^self asText condensedText</body><body package="Arbor Help System Widget Help Core" selector="fullText">fullText	"Make myself protocol-compatible with AHSTextBinder."	^self asText fullText</body><body package="Arbor Help System Widget Help Core" selector="hasCondensedText">hasCondensedText	"Make myself protocol-compatible with AHSTextBinder."	^false</body><body package="Arbor Help System Widget Help Core" selector="trimExteriorBlanks">trimExteriorBlanks	| size index space |	(size := self size) == 0 ifTrue: [^self].	index := 1.	space := Character space.	[(self at: index) = space] whileTrue: [		index = size ifTrue: [^''].		index := index + 1].	[(self at: size) = space] whileTrue: [		index = size ifTrue: [^''].		size := size - 1].	^self copyFrom: index to: size</body></methods><methods><class-id>UI.NamedSpec class</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsPredefinedStates">ahsPredefinedStates	^#(disabled)</body></methods><methods><class-id>UI.NamedSpec</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsID">ahsID	^self name</body><body package="Arbor Help System Widget Help Core" selector="ahsPredefinedStates">ahsPredefinedStates	"Answer an array of predefined states"	^ self class ahsPredefinedStates</body><body package="Arbor Help System Widget Help Core" selector="ahsStateAt:for:">ahsStateAt: aWidgetRelativePoint for: aVisualPart	"Answer a Symbol identifying the state of the receiver for the	purposes of looking up context-sensitive help"	^#default</body></methods><methods><class-id>UI.MenuButtonSpec</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsStateAt:for:">ahsStateAt: aWidgetRelativePoint for: aMenuButtonView 	^aMenuButtonView label isNil		ifTrue: [#default]		ifFalse: [self hasCharacterOrientedLabel					ifTrue: [aMenuButtonView label text isEmpty								ifTrue: [#default]								ifFalse: [aMenuButtonView label text asSymbol]]					ifFalse: [#default]]</body></methods><methods><class-id>UI.SpecWrapper</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsID">ahsID	^self spec ahsID</body><body package="Arbor Help System Widget Help Core" selector="ahsPredefinedStates">ahsPredefinedStates	"Answer an array of predefined states"	^self spec class ahsPredefinedStates</body><body package="Arbor Help System Widget Help Core" selector="ahsStateAt:">ahsStateAt: aWindowRelativePoint	^self isEnabled		ifTrue: [self spec ahsStateAt: (self component globalPointToLocal: aWindowRelativePoint) for: self widget]		ifFalse: [#disabled]</body></methods><methods><class-id>UI.SubCanvas</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsClient">ahsClient	^client</body><body package="Arbor Help System Widget Help Core" selector="aisClient">aisClient	^client</body><body package="Arbor Help System Widget Help Core" selector="aisClient:">aisClient: anAppModel	client := anAppModel.</body></methods><methods><class-id>Core.Text</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="condensedText">condensedText	"Make myself protocol-compatible with AHSTextBinder."	^self</body><body package="Arbor Help System Widget Help Core" selector="fullText">fullText	"Make myself protocol-compatible with AHSTextBinder."	^self</body><body package="Arbor Help System Widget Help Core" selector="hasCondensedText">hasCondensedText	"Make myself protocol-compatible with AHSTextBinder."	^false</body></methods><methods><class-id>UI.RadioButtonController</class-id> <category>AHSWHC mods</category><body package="Arbor Help System Widget Help Core" selector="pressAction">pressAction	"Do the action associated with pressing the button."	view isEnabled ifFalse: [^self].	self requestValueChange ifTrue: 		[| referenceValue |		referenceValue := view getReferenceValue.		referenceValue = model value ifFalse: [model value: referenceValue].		self valueChange.		"-- AHS added: start here --"		"Must check for nil in case this button closes the window"		(self view notNil 		and: [self view topComponent respondsTo: #ahsProcessor]) ifTrue: 			[|helpProc|			helpProc := self view topComponent ahsProcessor.			helpProc notNil ifTrue: [helpProc focusChanged]].		"-- end here --"]</body></methods><methods><class-id>UI.BorderDecorator</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsHasComponent">ahsHasComponent	^true</body></methods><methods><class-id>Graphics.CompositePart</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsHasComponents">ahsHasComponents	^true</body></methods><methods><class-id>UI.MenuItem class</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsPredefinedStates">ahsPredefinedStates	"Support for ToolBars (who, for some oddball reason, have a MenuItem in the SpecWrapper spec inst var)"	^#()</body></methods><methods><class-id>UI.MenuItem</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsID">ahsID	"Support for ToolBars (who, for some oddball reason, have a MenuItem in the SpecWrapper spec inst var)"	^self nameKey isNil		ifTrue: [self label asSymbol]		ifFalse: [self nameKey asSymbol]</body><body package="Arbor Help System Widget Help Core" selector="ahsStateAt:for:">ahsStateAt: aWidgetRelativePoint for: aVisualPart	"Support for ToolBars (who, for some oddball reason, have a MenuItem in the SpecWrapper spec inst var)"	^#default</body></methods><methods><class-id>UI.TableView</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsActivityPoint">ahsActivityPoint	"Answer a window-relative point which indicates the location in the widget that is considered active.  This value may be used when performing help lookup due to keyboard activity rather than mouse activity."	^self targetIndex = self zeroIndex		ifTrue: [super ahsActivityPoint]		ifFalse: [self localPointToGlobal: (self boundsOfElementIndex: self targetIndex inBounds: self bounds) origin]</body></methods><methods><class-id>UI.CheckBoxSpec class</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsPredefinedStates">ahsPredefinedStates	^#(disabled on)</body></methods><methods><class-id>UI.CheckBoxSpec</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsStateAt:for:">ahsStateAt: aWidgetRelativePoint for: aCheckBoxView	^aCheckBoxView isSelected		ifTrue: [#on]		ifFalse: [#default]</body></methods><methods><class-id>UI.TriggerButtonController</class-id> <category>AHSWHC mods</category><body package="Arbor Help System Widget Help Core" selector="pressAction">pressAction	view isEnabled ifFalse: [^self].	self requestValueChange		ifTrue: [model value: model value not.				self valueChange.			"-- AHS added: start here --"				"Must check for nil in case this button closes the window"			(self view notNil and: [self view topComponent respondsTo: #ahsProcessor])				ifTrue: [ |helpProc|						helpProc := self view topComponent ahsProcessor.						helpProc notNil							ifTrue: [helpProc focusChanged]].				"-- end here --"]</body></methods><methods><class-id>Core.SharedQueue</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="conform:">conform: aBlock	"Answer true if aBlock evaluates to true for each element.	Answer false as soon as aBlock evaluates to false for any element"	^[accessProtect		critical:			[contents do: [:each |				(aBlock value: each)					ifFalse: [^false]].			true]] valueUninterruptably</body></methods><methods><class-id>UI.KeyboardProcessor</class-id> <category>AHSWHC mods</category><body package="Arbor Help System Widget Help Core" selector="setActive:">setActive: aController	currentConsumer == aController ifTrue: [^self].	(currentConsumer == nil or: [currentConsumer = 0])		ifFalse: [currentConsumer deactivate].	self setCurrentConsumer: aController.	currentConsumer == nil		ifFalse: [currentConsumer activate].	"-- AHS added: start here --"	(aController notNil		and: [aController view isOpen			and: [aController view topComponent respondsTo: #ahsProcessor]])		ifTrue: 			[| helpProc |			helpProc := aController view topComponent ahsProcessor.			helpProc notNil				ifTrue: [helpProc focusChanged]]	"-- end here --"</body></methods><methods><class-id>UI.ApplicationWindow</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsClient">ahsClient	^self model builder source</body></methods><methods><class-id>UI.ApplicationWindow</class-id> <category>AHSWHC mods</category><body package="Arbor Help System Widget Help Core" selector="processEvent:">processEvent: anEvent 	"The following has proved to be helpful when debugging this code:	| w1 a1 |	(w1 := ApplicationWindow new)		sendWindowEvents: #(#bounds #resize #enter #exit					#close #collapse #expand #reopen					#hibernate #release);		application: (a1 := ApplicationModel new).	ApplicationWindow new		receiveWindowEvents: #(#bounds #resize #enter #exit					#close #collapse #expand #reopen					#hibernate #release);		windowEventBlock: [:x :y :z | Transcript cr; show: y printString];		application: a1.	w1 open"	| type |	(anEvent isKindOf: Event) ifTrue: [^self].	type := anEvent key.	type == #resize		ifTrue:			[self extentEvent: anEvent value.			self updateEvent: type].	(type == #collapse or: [type == #exit or: [type == #move]])		ifTrue: [self updateEvent: type].	type == #close		ifTrue:			[self controller closeNoTerminate. "The closeNoTerminate will report the event if closing really happens."			^self].	type == #destroy		ifTrue:	[self processDestroyEvent: anEvent value].	type == #enter		ifTrue: [(activationNotification == true and: [component notNil])				ifTrue: [component downcastEvent: #activate with: nil from: self]].	type == #exit		ifTrue: [(activationNotification == true and: [component notNil])				ifTrue: [component downcastEvent: #deactivate with: nil from: self]].	type == #doubleClick		ifTrue: [self downcastLocalEvent: type with: nil at: anEvent value from: self].	type == #eventUnknown		ifTrue: [self unknownEvent: anEvent value].	"AHS: The following code was added to implement #block events"	"----- start here -----"	anEvent key == #block		ifTrue: [anEvent value value].	"----- end here -----"	self reportWindowEvent: type with: anEvent value</body></methods><methods><class-id>UI.TableViewSpec</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsStateAt:for:">ahsStateAt: aWidgetRelativePoint for: aTableView	| index |	(aTableView containsPoint: aWidgetRelativePoint)		ifFalse: [^#default].	index := aTableView elementIndexFor: aWidgetRelativePoint.	^index = Point zero		ifTrue: [#default]		ifFalse: 			[self selectionStyle == #row				ifTrue: [Array with: index printString asSymbol								with: (0 @ index y) printString asSymbol								with: (index x @ 0) printString asSymbol]				ifFalse: [Array with: index printString asSymbol								with: (index x @ 0) printString asSymbol								with: (0 @ index y) printString asSymbol]]</body></methods><methods><class-id>Graphics.Wrapper</class-id> <category>AHSWHC adds</category><body package="Arbor Help System Widget Help Core" selector="ahsHasComponent">ahsHasComponent	^true</body></methods><methods><class-id>VWHelp.AHSWHCProcessor class</class-id> <category>resources</category><body package="Arbor Help System Widget Help Core" selector="helpIcon0">helpIcon0	"UIMaskEditor new openOnClass: self andSelector: #helpIcon0"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 32@32 depth: 4 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 11) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 6007 scaledGreen: 6007 scaledBlue: 6007); at: 3 put: (ColorValue scaledRed: 7645 scaledGreen: 7645 scaledBlue: 7645); at: 4 put: (ColorValue scaledRed: 3276 scaledGreen: 3276 scaledBlue: 8191); at: 5 put: (ColorValue scaledRed: 3276 scaledGreen: 3276 scaledBlue: 6135); at: 6 put: (ColorValue scaledRed: 6553 scaledGreen: 6553 scaledBlue: 6553); at: 7 put: ColorValue white; at: 8 put: (ColorValue scaledRed: 1638 scaledGreen: 1638 scaledBlue: 8191); at: 9 put: ColorValue lightGray; at: 10 put: ColorValue blue; at: 11 put: (ColorValue scaledRed: 3276 scaledGreen: 1638 scaledBlue: 8191); yourself)) usingBits: (ByteArray fromPackedString: '&amp;Y&amp;Y&amp;Y$@@@@@@@@I&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y$@A&amp;Y&amp;Y&amp;X@@@"H"I&amp;Y&amp;Y$@A&amp;Y&amp;Y&amp;Y&amp;Y @@BH"Y&amp;Y&amp;PA&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;@@BI&amp;Y&amp;Y$FY&amp;Y @@A&amp;Y&amp;Y&amp;@@"Y&amp;Y&amp;PA&amp;Y&amp;@@@@A&amp;Y&amp;Y @I^Y&amp;Y$FY&amp;X@BH @A&amp;Y&amp;Y @I&amp;Y&amp;XA&amp;Y&amp;X@Y"@@Y&amp;Y&amp;X@BY&amp;Y]PY&amp;Y&amp;@FZH@FY&amp;Y&amp;@@&amp;Y&amp;Q FY&amp;Y BH"@A&amp;Y&amp;Y @I&amp;Y^H@FY&amp;X@"H FY&amp;Y&amp;X@BY&amp;S"@A&amp;Y BH!PA&amp;Y&amp;Y&amp;@@&amp;Y$X @@@@@"H@FY&amp;Y&amp;X@@I&amp;Y"H @@@BH@@Y&amp;Y&amp;Y @@&amp;Y&amp;X"FZH"H @Y&amp;Y&amp;Y&amp;@@@I&amp;Y&amp;HY%"H"H@FY&amp;Y&amp;X@@@&amp;Y&amp;Y"H"H"H!PY&amp;Y&amp;X@@@BY&amp;Y&amp;X"H"H"H FY&amp;X@@@BY&amp;Y&amp;Y&amp;H"H"H"HA&amp;Y @@@I&amp;Y&amp;Y&amp;Y!9&amp;Y&amp;Y&amp;PY&amp;X@@I&amp;Y&amp;Y&amp;Y&amp;X&amp;Y&amp;Y&amp;Y$@@@@@&amp;Y&amp;Y&amp;Y&amp;Y^I&amp;Y&amp;Y&amp;Y@@@@@I&amp;Y&amp;Y&amp;Y&amp;Z"Y&amp;Y&amp;Y&amp;PA&amp;X@BY&amp;Y&amp;Y&amp;Y%H&amp;Y&amp;Y&amp;Y@FY&amp;X@BY&amp;Y&amp;Y&amp;Y^I&amp;Y&amp;Y&amp;PY&amp;Y&amp;X@&amp;Y&amp;Y&amp;Y&amp;Y!9&amp;Y&amp;Y$FY&amp;Y&amp;@I&amp;Y&amp;Y&amp;Y%8NY&amp;Y&amp;YA&amp;Y&amp;Y BY&amp;Y&amp;Y&amp;Y&amp;D&amp;Y&amp;Y&amp;PA&amp;Y&amp;@@&amp;Y&amp;Y&amp;Y&amp;YEY&amp;Y&amp;Y$@A&amp;X@@I&amp;Y&amp;Y&amp;Y&amp;X"Y&amp;Y&amp;Y@@@@@@&amp;Y&amp;Y&amp;Y&amp;Y&amp;S&amp;Y&amp;Y&amp;Y@@@@BY&amp;Y&amp;Y&amp;Y&amp;Y&amp;T&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y$b'))</body><body package="Arbor Help System Widget Help Core" selector="reducedHelpImage">reducedHelpImage	"UIMaskEditor new openOnClass: self andSelector: #reducedHelpImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 24@24 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 7) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 6007 scaledGreen: 6007 scaledBlue: 6007); at: 3 put: (ColorValue scaledRed: 7645 scaledGreen: 7645 scaledBlue: 7645); at: 4 put: ColorValue white; at: 5 put: (ColorValue scaledRed: 1638 scaledGreen: 1638 scaledBlue: 8191); at: 6 put: ColorValue lightGray; at: 7 put: ColorValue blue; yourself)) usingBits: (ByteArray fromPackedString: 'L3L3L3L3L3L3L3L3M&amp;Y&amp;Y @@@@@FY&amp;Y#M&amp;Y&amp;@CL3L3L@UUY#M&amp;Y L3L3L3L0@EY#M&amp;XCL3@@@3L3@EY#M&amp;XCL3AUTCL3L@Y#M&amp;TCL3@2TCL3L@Y#M&amp;TCL3AUTCL3L@Y#M$TCL3AUTCL3L@Y#M!T@@@AU@3L3@@Y#M%UP@@UPL3L0@FY#M%L5UUTCL3L@A&amp;Y#M%UUUU@3L3@@A&amp;Y#M%UUUU@3L0@FY&amp;Y#M%Y&amp;Y&amp;@3L@Y&amp;Y&amp;Y#MEY&amp;Y&amp;X@@@Y&amp;Y&amp;Y#M%Y&amp;Y&amp;@CL@Y&amp;Y&amp;Y#MEY&amp;Y&amp;@3L0A&amp;Y&amp;Y#M%Y&amp;Y&amp;@3L0A&amp;Y&amp;Y#M%Y&amp;Y&amp;@3L0A&amp;Y&amp;Y#M&amp;U&amp;Y&amp;@CL@Y&amp;Y&amp;Y#M&amp;U&amp;Y&amp;X@@@Y&amp;Y&amp;Y#M&amp;Y&amp;Y&amp;Y A&amp;Y&amp;Y&amp;Y#L3L3L3L3L3L3L3L3'))</body><body package="Arbor Help System Widget Help Core" selector="reducedHelpMask">reducedHelpMask	"UIMaskEditor new openOnClass: self andSelector: #reducedHelpMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 24@24 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 127 255 254 0 127 255 254 0 127 255 254 0 127 255 254 0 127 255 254 0 127 255 254 0 127 255 254 0 127 255 254 0 127 255 254 0 127 255 254 0 127 255 254 0 127 255 254 0 127 255 254 0 127 255 254 0 127 255 254 0 127 255 254 0 127 255 254 0 127 255 254 0 127 255 254 0 127 255 254 0 127 255 254 0 127 255 254 0 0 0 0 0])</body></methods><methods><class-id>VWHelp.AHSWHCProcessor class</class-id> <category>interface specs</category><body package="Arbor Help System Widget Help Core" selector="ahsTextAndIconSpec">ahsTextAndIconSpec	"UIPainter new openOnClass: self andSelector: #ahsTextAndIconSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Arbor Help System' 			#min: #(#Point 50 42 ) 			#bounds: #(#Rectangle 751 175 1154 238 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#CheckBoxSpec 					#layout: #(#AlignmentOrigin 0 0 0 0.5 0 0.5 ) 					#name: #ahsFlag 					#model: #ahsFlag 					#tabable: false 					#label: #ahsIcon 					#hasCharacterOrientedLabel: false 					#style: #default ) 				#(#TextEditorSpec 					#layout: #(#LayoutFrame 58 0 0 0 0 1 0 1 ) 					#name: #ahsText 					#flags: 4 					#isOpaque: true 					#model: #ahsText 					#style: #'Arbor-12-Squeeze' 					#isReadOnly: true ) ) ) )</body><body package="Arbor Help System Widget Help Core" selector="ahsTextOnlySpec">ahsTextOnlySpec	"UIPainter new openOnClass: self andSelector: #ahsTextOnlySpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Arbor Help System' 			#min: #(#Point 50 42 ) 			#bounds: #(#Rectangle 786 525 1189 580 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#TextEditorSpec 					#layout: #(#LayoutFrame 0 0 0 0 0 1 0 1 ) 					#name: #ahsText 					#flags: 4 					#isOpaque: true 					#model: #ahsText 					#style: #'Arbor-12-Squeeze' 					#isReadOnly: true ) ) ) )</body></methods><initialize><class-id>VWHelp.AHSWHCGlobalHelp</class-id></initialize><initialize><class-id>VWHelp.AHSWHCProcessor</class-id></initialize><initialize><class-id>VWHelp.AHSWHCTransientWindow</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>SequenceController</name><environment>UI</environment><super>UI.ControllerWithMenu</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyboardProcessor outside searchString keyboardHook doStringSearching dispatcher dragDropCallbacks selectOnDownWithDrag autoSelect </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>UIBasics-Controllers</category><attributes><package>UIBasics-Controllers</package></attributes></class><class><name>ToggleButtonController</name><environment>UI</environment><super>UI.BasicButtonController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Controllers</category><attributes><package>UIBasics-Controllers</package></attributes></class><class><name>VisualComponent</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>RadioButtonController</name><environment>UI</environment><super>UI.ToggleButtonController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Controllers</category><attributes><package>UIBasics-Controllers</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>WindowSensor</name><environment>UI</environment><super>UI.InputSensor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyboard metaInput damage damageLock invalidationSuppressed skipNextDamage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>OS-Window System</package></attributes></class><class><name>TriggerButtonController</name><environment>UI</environment><super>UI.BasicButtonController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Controllers</category><attributes><package>UIBasics-Controllers</package></attributes></class><class><name>CompositePart</name><environment>Graphics</environment><super>Graphics.VisualPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>components preferredBounds </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>Text</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string runs </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>EventDispatcher</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>windowController currentMouseConsumer grabbingMouse keyboardProcessor lastControlObject trapList state repairDamageWhenDebugging flushQueueAfterError distributeEventsWhenDebugging dragDropInProgress dragDropTracker dispatchUnknownEvents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events-Support</category><attributes><package>Interface-Events-Support</package></attributes></class><class><name>LookupKey</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>SubCanvas</name><environment>UI</environment><super>Graphics.CompositePart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>client </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>MenuView</name><environment>UI</environment><super>UI.CompositeView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuItemViews parentMenuItemView selectedValue selectionFinal highlightedMenuItemView usedSelectionMemory parentMenuBarButtonView commonTextIndent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>NamedSpec</name><environment>UI</environment><super>UI.ComponentSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name flags isOpaque colors </inst-vars><class-inst-vars>paletteIcon </class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>RadioButtonSpec</name><environment>UI</environment><super>UI.ButtonSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>select </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>TableViewSpec</name><environment>UI</environment><super>UI.MenuComponentSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>style showHGrid showVGrid selectionStyle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>DataSetSpec</name><environment>UI</environment><super>UI.MenuComponentSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>columns verticalPolicy horizontalPolicy multipleSelections labelsAsButtons </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>SequenceViewSpec</name><environment>UI</environment><super>UI.MenuComponentSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>multipleSelections style useModifierKeys selectionType autoSelect </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>CheckBoxSpec</name><environment>UI</environment><super>UI.ButtonSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>ComboBoxSpec</name><environment>UI</environment><super>UI.InputFieldSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comboList readSelector printSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>Window</name><environment>Graphics</environment><super>Graphics.DisplaySurface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inputOrigin creationOrigin sensor iconic windowType effectiveWindowType statusLineHeight allowsStatusLine mapped eventHandlers windowManager </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>OS-Window System</package></attributes></class><class><name>MenuButtonSpec</name><environment>UI</environment><super>UI.ButtonSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menu isList isPopUp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>Wrapper</name><environment>Graphics</environment><super>Graphics.VisualPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>component </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>SpecWrapper</name><environment>UI</environment><super>UI.WidgetWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>spec </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Support</category><attributes><package>UIBuilder-Support</package></attributes></class><class><name>SharedQueue</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contents accessProtect readSynch </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Processes</category><attributes><package>Kernel-Processes</package></attributes></class><class><name>View</name><environment>UI</environment><super>Graphics.DependentPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controller properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>BooleanWidgetView</name><environment>UI</environment><super>UI.View</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transitionHolder latestValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>TableView</name><environment>UI</environment><super>UI.AutoScrollingView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state table columnInfo rowInfo selectionChannel selectionIndex targetIndex grid columnWidths rowHeights visualBlock textStyle displayStringSelector showCGrid showRGrid strokedSelection isSlave lpDictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>TransientWindow</name><environment>UI</environment><super>Graphics.Window</super><private>false</private><indexed-type>none</indexed-type><inst-vars>component paintPreferences isEventDriven controller </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>SelectionView</name><environment>UI</environment><super>UI.ScrollingView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sequence selectionChannel selectionIndex targetIndex grid textStyle displayStringSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>MenuBarWrapper</name><environment>UI</environment><super>Graphics.BorderedWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>MenuItem</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>enabled label adornment nameKey value position helpText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Menus</category><attributes><package>Interface-Menus</package></attributes></class><class><name>ComposedTextView</name><environment>UI</environment><super>UI.AutoScrollingView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>displayContents startBlock stopBlock selectionShowing displaySelection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>TextEditorView</name><environment>UI</environment><super>UI.ComposedTextView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state helpText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>BorderDecorator</name><environment>UI</environment><super>Graphics.CompositePart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>component widgetFlags policy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>NoteBookSpec</name><environment>UI</environment><super>UI.WidgetSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>secondModel style labels binderSide binderWidth majorTabsOnRight rightInset bottomInset tabsOnTop verticalTabOrientation binderMode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>KeyboardProcessor</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyboardConsumers currentConsumer default cancel keyboardHook focusIsShifting currentConsumerChannel acceptOnControlChange menuBar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>ScheduledWindow</name><environment>UI</environment><super>Graphics.Window</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label icon minimumSize maximumSize component lookPreferences paintPreferences edgeDecorationPolicy widgetPolicy controller model damageRepairPolicy masterWindow </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>ApplicationWindow</name><environment>UI</environment><super>UI.ScheduledWindow</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyboardProcessor application sendWindowEvents receiveWindowEvents windowEventBlock damageRepairIsLazy activationNotification isEventDriven toolbarVisible dropTarget dragDropInProgress dragDropTracker </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>ValueHolder</name><environment>UI</environment><super>UI.ValueModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Support</category><attributes><package>Interface-Support</package></attributes></class><class><name>ApplicationWindowSensor</name><environment>UI</environment><super>UI.WindowSensor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class></st-source>