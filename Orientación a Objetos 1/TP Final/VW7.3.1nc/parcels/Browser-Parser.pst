<?xml version="1.0"?><st-source><!-- Name: Browser-ParserNotice: Copyright © 2002-2005 Cincom Systems, Inc.  All Rights Reserved.Comment: The parser for the Refactoring Browser. It contains both the ability to parse Smalltalk and also to rewrite Smalltalk code. The refactorings use this rewriting behavior to perform the source code transformations.DbIdentifier: bear73DbTrace: 50536DevelopmentPrerequisites: #(#(#any 'Browser-Namespace' ''))PackageName: Browser-ParserParcel: #('Browser-Parser')PrerequisiteParcels: #(#('Browser-Namespace' ''))PrintStringCache: (7.3 - 1.4,bobw)Version: 7.3.1Date: 5:51:32 pm April 10, 2005 --><time-stamp>From VisualWorks®, 7.3.1 of April 10, 2005 on April 10, 2005 at 5:51:32 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>RBProgramNodeVisitor</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parse Tree Matching</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBProgramNodeVisitor</class-id><body>RBProgramNodeVisitor is an abstract visitor for the RBProgramNodes.</body></comment><class><name>RBConfigurableFormatter</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBProgramNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>codeStream indent lookaheadCode originalSource lineStart </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBConfigurableFormatter</class-id><body>RBConfigurableFormatter formats the Refactoring Browser's parse trees. It has many more formatting options than the default formatter used by the RB. To change the RB to use this formatter, execute "RBProgramNode formatterClass: RBConfigurableFormatter". For some refactorings the RB must reformat the code after the change, so it is good to have a formatter configured to your tastes.Instance Variables:	codeStream	&lt;PositionableStream&gt;	the stream we are writing our output to	indent	&lt;Integer&gt;	how many times are we indenting a new line -- indents are normally tabs but could be any whitespace string	lineStart	&lt;Integer&gt;	the position of the character that started the current line. This is used for calculating the line length.	lookaheadCode	&lt;Dictionary key: RBProgramNode value: String&gt;	sometimes we need to lookahead while formatting, this dictionary contains the nodes that have already been formatted by lookahead	originalSource	&lt;String&gt;	the original source before we started formatting. This is used to extract the comments from the original source.</body></comment><class><name>RBFormatter</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBProgramNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>codeStream lineStart firstLineLength tabs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBFormatter</class-id><body>RBFormatter formats a parse tree. It is an example of a Visitor. This is rarely called directly. Sending 'formattedCode' to a parse tree uses this algorithm to return a pretty-printed version.Instance Variables:	codeStream	&lt;PositionableStream&gt;	The buffer where the output is accumulated.	firstLineLength	&lt;Integer&gt;	The length of the first line of a message send.	lineStart	&lt;Integer&gt;	The position of the current line's start.	tabs	&lt;Integer&gt;	The number of tabs currently indented.</body></comment><class><name>RBParseTreeRule</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>searchTree owner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parse Tree Matching</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBParseTreeRule</class-id><body>RBParseTreeRule is the abstract superclass of all of the parse tree searching rules. A parse tree rule is the first class representation of a particular rule to search for. The owner of a rule is the algorithm that actually executes the search. This arrangement allows multiple searches to be conducted by a single Searcher.Instance Variables:	owner	&lt;ParseTreeSearcher&gt;	The searcher that is actually performing the search.	searchTree	&lt;RBProgramNode&gt;	The parse tree to be searched.</body></comment><class><name>RBSearchRule</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBParseTreeRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>answerBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parse Tree Matching</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBSearchRule</class-id><body>RBSearchRule is a parse tree rule that simply searches for matches to the rule. Every time a match is found, answerBlock is evaluated with the node that matches and the cureent answer. This two-argument approach allows a collection to be formed from all of the matches (Think inject:into:).Instance Variables:	answerBlock	&lt;BlockClosure&gt;	Block to evaluate with the matching node and the current answer.</body></comment><class><name>RBReplaceRule</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBParseTreeRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>verificationBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parse Tree Matching</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBReplaceRule</class-id><body>RBReplaceRule is the abstract superclass of all of the transforming rules. The rules change the source code by replacing the node that matches the rule. Subclasses implement different strategies for this replacement.Subclasses must implement the following messages:	matching		foundMatchFor:Instance Variables:	verificationBlock	&lt;BlockClosure&gt;	Is evaluated with the matching node. This allows for further verification of a match beyond simple tree matching.</body></comment><class><name>RBStringReplaceRule</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBReplaceRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>replaceTree </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parse Tree Matching</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBStringReplaceRule</class-id><body>RBStringReplaceRule replaces a matched tree with another tree (which may include metavariable from the matching tree). This is a very succint syntax for specifying most rewrites.Instance Variables:	replaceTree	&lt;RBProgramNode&gt;	The tree to replace the matched tree with.</body></comment><class><name>RBBlockReplaceRule</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBReplaceRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>replaceBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parse Tree Matching</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBBlockReplaceRule</class-id><body>RBBlockReplaceRule replaces the matching node by the result of evaluating replaceBlock. This allows arbitrary computation to come up with a replacement.Instance Variables:	replaceBlock	&lt;BlockClosure&gt;	The block that returns the node to replace to matching node with.</body></comment><class><name>RBProgramNode</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent comments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBProgramNode</class-id><body>RBProgramNode is an abstract class that represents an abstract syntax tree node in a Smalltalk program.Subclasses must implement the following messages:	accessing		start		stop	visitor		acceptVisitor:The #start and #stop methods are used to find the source that corresponds to this node. "source copyFrom: self start to: self stop" should return the source for this node.The #acceptVisitor: method is used by RBProgramNodeVisitors (the visitor pattern). This will also require updating all the RBProgramNodeVisitors so that they know of the new node.Subclasses might also want to redefine match:inContext: and copyInContext: to do parse tree searching and replacing.Subclasses that contain other nodes should override equalTo:withMapping: to compare nodes while ignoring renaming temporary variables, and children that returns a collection of our children nodes.Instance Variables:	comments	&lt;Collection of: Interval&gt;	the intervals in the source that have comments for this node	parent	&lt;RBProgramNode&gt;	the node we're contained inShared Variables:	FormatterClass	&lt;Behavior&gt;	the formatter class that is used when we are formatted</body></comment><class><name>RBReturnNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBProgramNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>return value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBReturnNode</class-id><body>RBReturnNode is an AST node that represents a return expression.Instance Variables:	return	&lt;Integer&gt;	the position of the ^ character	value	&lt;RBValueNode&gt;	the value that is being returned</body></comment><class><name>RBValueNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBProgramNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parentheses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBValueNode</class-id><body>RBValueNode is an abstract class that represents a node that returns some value.Subclasses must implement the following messages:	accessing		startWithoutParentheses		stopWithoutParentheses	testing		needsParenthesisInstance Variables:	parentheses	&lt;SequenceableCollection of: Inteval&gt;	the positions of the parethesis around this node. We need a collection of intervals for stupid code such as "((3 + 4))" that has multiple parethesis around the same expression.</body></comment><class><name>RBCascadeNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>messages semicolons </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBCascadeNode</class-id><body>RBCascadeNode is an AST node for cascaded messages (e.g., "self print1 ; print2").Instance Variables:	messages	&lt;SequenceableCollection of: RBMessageNode&gt;	the messages 	semicolons	&lt;SequenceableCollection of: Integer&gt;	positions of the ; between messages</body></comment><class><name>RBOptimizedNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>left right body </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBOptimizedNode</class-id><body>RBOptimizedNode is an AST node that represents IBM's ##(...) expressions. These expressions are evaluated at compile time and directly inserted into the method.Instance Variables:	body	&lt;RBSequenceNode&gt;	the body of the expression	left	&lt;Integer&gt;	position of the ##( characters	right	&lt;Integer&gt;	position of )</body></comment><class><name>RBMessageNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>receiver selector selectorParts arguments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBMessageNode</class-id><body>RBMessageNode is an AST node that represents a message send.Instance Variables:	arguments	&lt;SequenceableCollection of: RBValueNode&gt;	our argument nodes	receiver	&lt;RBValueNode&gt;	the receiver's node	selector	&lt;Symbol | nil&gt;	the selector we're sending (cached)	selectorParts	&lt;SequenceableCollection of: RBValueToken&gt;	the tokens for each keyword</body></comment><class><name>RBPatternMessageNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBMessageNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isList isCascadeList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBPatternMessageNode</class-id><body>RBPatternMessageNode is a RBMessageNode that will match other message nodes without their selectors being equal. Instance Variables:	isCascadeList	&lt;Boolean&gt;	are we matching a list of message nodes in a cascaded message	isList	&lt;Boolean&gt;	are we matching each keyword or matching all keywords together (e.g., `keyword1: would match a one argument method whereas `@keywords: would match 0 or more arguments)</body></comment><class><name>RBSequenceNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBProgramNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>leftBar rightBar statements periods temporaries </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBSequenceNode</class-id><body>RBSequenceNode is an AST node that represents a sequence of statements. Both RBBlockNodes and RBMethodNodes contain these.Instance Variables:	leftBar	&lt;Integer | nil&gt;	the position of the left | in the temporaries definition	periods	&lt;SequenceableCollection of: Integer&gt;	the positions of all the periods that separate the statements	rightBar	&lt;Integer | nil&gt;	the position of the right | in the temporaries definition	statements	&lt;SequenceableCollection of: RBStatementNode&gt;	the statement nodes	temporaries	&lt;SequenceableCollection of: RBVariableNode&gt;	the temporaries defined</body></comment><class><name>RBLiteralNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><class><name>RBLiteralArrayNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBLiteralNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isByteArray stop contents start </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><class><name>RBAssignmentNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>variable assignment value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBAssignmentNode</class-id><body>RBAssignmentNode is an AST node for assignment statementsInstance Variables:	assignment	&lt;Integer&gt;	position of the :=	value	&lt;RBValueNode&gt;	the value that we're assigning	variable	&lt;RBVariableNode&gt;	the variable being assigned</body></comment><class><name>RBSmallDictionary</name><environment>Refactory.Browser</environment><super>Core.KeyedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keys values size </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parse Tree Matching</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBSmallDictionary</class-id><body>RBSmallDictionary is a special dictionary optimized for small collections. In addition to the normal dictionary protocol, it also supports an #empty message which "empties" the collection but may hang on to the original elements (so it could collect garbage). Without #empty we would either need to create a new dictionary or explicitly remove everything from the dictionary. Both of these take more time and #empty.Instance Variables:	keys	&lt;Array of: Object&gt;	array of keys (we don't use Associations for our key value pairs)	size	&lt;Integer&gt;	the size of the dictionary	values	&lt;Array of: Object&gt;	array of our values</body></comment><class><name>ParseTreeSearcher</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBProgramNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>searches answer argumentSearches context messages </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parse Tree Matching</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.ParseTreeSearcher</class-id><body>ParseTreeSearcher walks over a normal source code parse tree using the visitor pattern, and then matches these nodes against the meta-nodes using the match:inContext: methods defined for the meta-nodes.Instance Variables:	answer	&lt;Object&gt;	the "answer" that is propagated between matches	argumentSearches	&lt;Collection of: (Association key: RBProgramNode value: BlockClosure)&gt;	argument searches (search for the BRProgramNode and perform the BlockClosure when its found)	context	&lt;RBSmallDictionary&gt;	a dictionary that contains what each meta-node matches against. This could be a normal Dictionary that is created for each search, but is created once and reused (efficiency).	messages	&lt;Collection&gt;	the sent messages in our searches	searches	&lt;Collection of: (Association key: RBProgramNode value: BlockClosure)&gt;	non-argument searches (search for the BRProgramNode and perform the BlockClosure when its found)</body></comment><class><name>RBToken</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourcePointer comments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Scanner</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBToken</class-id><body>RBToken is the abstract superclass of all of the RB tokens. These tokens (unlike the standard parser's) remember where they came from in the original source code.Subclasses must implement the following messages:	accessing		lengthInstance Variables:	sourcePointer	&lt;Integer&gt;	The position in the original source code where this token began.</body></comment><class><name>RBOptimizedToken</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBToken</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Scanner</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBOptimizedToken</class-id><body>RBOptimizedToken is the first-class representation of IBM's Optimized expressions (e.g. ##(...)). See RBOptimizedNode for more information.</body></comment><class><name>RBAssignmentToken</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBToken</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Scanner</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBAssignmentToken</class-id><body>RBAssignmentToken is the first-class representation of the assignment token ':='</body></comment><class><name>RBValueToken</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBToken</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Scanner</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBValueToken</class-id><body>RBValueToken is the abstract superclass of all tokens that have additional information attached. For example, the BinarySelector token holds onto the actual character (e.g. $+).Instance Variables:	value	&lt;String&gt;	The value of this token</body></comment><class><name>RBBinarySelectorToken</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueToken</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Scanner</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBBinarySelectorToken</class-id><body>RBBinarySelectorToken is the first-class representation of a binary selector (e.g. +)</body></comment><class><name>RBPatternBlockToken</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueToken</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Scanner</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBPatternBlockToken</class-id><body>RBPatternBlockToken is the first-class representation of the pattern block token.</body></comment><class><name>RBIdentifierToken</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueToken</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Scanner</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBIdentifierToken</class-id><body>RBIdentifierToken is the first class representation of an identifier token (e.g. Class)</body></comment><class><name>RBLiteralToken</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueToken</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stopPosition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Scanner</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBLiteralToken</class-id><body>RBLiteralToken is the first-class representation of a literal token (entire literals, even literal arrays, are a single token in the ST80 grammar.).Instance Variables:	stopPosition	&lt;Integer&gt;	The position within the source code where the token terminates.</body></comment><class><name>RBNumberLiteralToken</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBLiteralToken</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Scanner</category><attributes><package>Browser-Parser</package></attributes></class><class><name>RBKeywordToken</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueToken</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Scanner</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBKeywordToken</class-id><body>RBKeywordToken is the first-class representation of a keyword token (e.g. add:)</body></comment><class><name>RBLiteralArrayToken</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueToken</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Scanner</category><attributes><package>Browser-Parser</package></attributes></class><class><name>RBParser</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scanner currentToken nextToken emptyStatements errorBlock tags source comments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBParser</class-id><body>RBParser takes a source code string and generates an AST for it. This is a hand-written, recursive descent parser and has been optimized for speed. The simplest way to call this is either 'RBParser parseExpression: aString' if you want the AST for an expression, or 'RBParser parseMethod: aString' if you want to parse an entire method.Instance Variables:	currentToken	&lt;RBToken&gt;	The current token being processed.	emptyStatements	&lt;Boolean&gt;	True if empty statements are allowed. In IBM, they are, in VW they aren't.	errorBlock	&lt;BlockClosure&gt;	The block to evaluate on a syntax error.	nextToken	&lt;RBToken&gt;	The next token that will be processed. This allows one-token lookahead.	scanner	&lt;RBScanner&gt;	The scanner that generates a stream of tokens to parse.	source	&lt;String&gt;	The source code to parse	tags	&lt;Collection of: Interval&gt;	The source intervals of the tags appearing at the top of a method (e.g. Primitive calls)Shared Variables:	ParserType	&lt;Symbol&gt;	the type code we are parsing</body></comment><class><name>RBVariableNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>token </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBVariableNode</class-id><body>RBVariableNode is an AST node that represent a variable (global, inst var, temp, etc.).Instance Variables:	token	&lt;RBValueToken&gt;	the token that contains our name and position</body></comment><class><name>RBStringReplacement</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>startPosition stopPosition string </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBStringReplacement</class-id><body>RBStringReplacement represents replacing source in the original method with a different string. These are used when reformatting code after a parse tree change has been made. Depending on the change, it may be possible to minimally change the parse tree without needing to format it.Instance Variables:	startPosition	&lt;Integer&gt;	the start position in the original source	stopPosition	&lt;Integer&gt;	the end position in the original source	string	&lt;String&gt;	replaces everything from the startPosition to the endPosition with this string</body></comment><class><name>RBScanner</name><environment>Refactory.Browser</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream buffer tokenStart currentCharacter characterType classificationTable numberType separatorsInLiterals extendedLiterals comments errorBlock nameSpaceCharacter </inst-vars><class-inst-vars>classificationTable </class-inst-vars><imports></imports><category>Browser-Scanner</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBScanner</class-id><body>RBScanner is a stream that returns a sequence of token from the string that it is created on. The tokens know where they came from in the source code and which comments were attached to them.Instance Variables:	buffer	&lt;PositionableStream&gt;	Accumulates the text for the current token.	characterType	&lt;ByteSymbol&gt;	The type of the next character. (e.g. #alphabetic, etc.)	classificationTable	&lt;Array of: Symbol&gt;	Mapping from Character values to their characterType.	comments	&lt;Collection of: Interval&gt;	Source intervals of scanned comments that must be attached to the next token.	currentCharacter	&lt;Character&gt;	The character currently being processed.	errorBlock	&lt;BlockClosure&gt;	The block to execute on lexical errors.	extendedLiterals	&lt;Boolean&gt;	True if IBM-type literals are allowed. In VW, this is false.	nameSpaceCharacter	&lt;Character&gt;	The character used to separate namespaces.	numberType	&lt;ByteSymbol&gt;	The method to perform: to scan a number. 	separatorsInLiterals	&lt;Boolean&gt;	True if separators are allowed within literals.	stream	&lt;PositionableStream&gt;	Contains the text to be scanned.	tokenStart	&lt;Integer&gt;	The source position of the beginning of the current tokenClass Instance Variables:	classificationTable	&lt;Array&gt;		the default classification table for all charactersShared Variables:	PatternVariableCharacter	&lt;Character&gt;	the character that starts a pattern node</body></comment><class><name>RBPatternScanner</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Scanner</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBPatternScanner</class-id><body>RBPatternScanner is a subclass of RBScanner that allows the extended syntax of pattern matching trees.</body></comment><class><name>RBSpecialCharacterToken</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueToken</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Scanner</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBSpecialCharacterToken</class-id><body>RBSpecialCharacterToken is the first class representation of special characters.</body></comment><class><name>RBPatternVariableNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBVariableNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>recurseInto isList isLiteral isStatement isAnything </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBPatternVariableNode</class-id><body>RBPatternVariableNode is an AST node that is used to match several other types of nodes (literals, variables, value nodes, statement nodes, and sequences of statement nodes).The different types of matches are determined by the name of the node. If the name contains a # character, then it will match a literal. If it contains, a . then it matches statements. If it contains no extra characters, then it matches only variables. These options are mutually exclusive.The @ character can be combined with the name to match lists of items. If combined with the . character, then it will match a list of statement nodes (0 or more). If used without the . or # character, then it matches anything except for list of statements. Combining the @ with the # is not supported.Adding another ` in the name will cause the search/replace to look for more matches inside the node that this node matched. This option should not be used for top level expressions since that would cause infinite recursion (e.g., searching only for "``@anything").Instance Variables:	isAnything	&lt;Boolean&gt;	can we match any type of node	isList	&lt;Boolean&gt;	can we match a list of items (@)	isLiteral	&lt;Boolean&gt;	only match a literal node (#)	isStatement	&lt;Boolean&gt;	only match statements (.)	recurseInto	&lt;Boolean&gt;	search for more matches in the node we match (`)</body></comment><class><name>ParseTreeRewriter</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ParseTreeSearcher</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tree </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parse Tree Matching</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.ParseTreeRewriter</class-id><body>ParseTreeRewriter walks over and transforms its RBProgramNode (tree). If the tree is modified, then answer is set to true, and the modified tree can be retrieved by the #tree method.Instance Variables:	tree	&lt;RBProgramNode&gt;	the parse tree we're transforming</body></comment><class><name>RBMultiKeywordLiteralToken</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBLiteralToken</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Scanner</category><attributes><package>Browser-Parser</package></attributes></class><class><name>RBMethodNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBProgramNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector selectorParts body source arguments tags replacements nodeReplacements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBMethodNode</class-id><body>RBMethodNode is the AST that represents a Smalltalk method.Instance Variables:	arguments	&lt;SequenceableCollection of: RBVariableNode&gt;	the arguments to the method	body	&lt;BRSequenceNode&gt;	the body/statements of the method	nodeReplacements	&lt;Dictionary&gt;	a dictionary of oldNode -&gt; newNode replacements	replacements	&lt;Collection of: RBStringReplacement&gt;	the collection of string replacements for each node replacement in the parse tree	selector	&lt;Symbol | nil&gt;	the method name (cached)	selectorParts	&lt;SequenceableCollection of: RBValueToken&gt;	the tokens for the selector keywords	source	&lt;String&gt;	the source we compiled	tags	&lt;Collection of: Interval&gt;	the source location of any resource/primitive tags</body></comment><class><name>RBPatternMethodNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBMethodNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBPatternMethodNode</class-id><body>RBPatternMethodNode is a RBMethodNode that will match other method nodes without their selectors being equal. Instance Variables:	isList	&lt;Boolean&gt;	are we matching each keyword or matching all keywords together (e.g., `keyword1: would match a one argument method whereas `@keywords: would match 0 or more arguments)</body></comment><class><name>RBBlockNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>left right colons body arguments bar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBBlockNode</class-id><body>RBBlockNode is an AST node that represents a block "[...]".Instance Variables:	arguments	&lt;SequenceableCollection of: RBVariableNode&gt;	the arguments for the block	bar	&lt;Integer | nil&gt;	position of the | after the arguments	body	&lt;RBSequenceNode&gt;	the code inside the block	colons	&lt;SequenceableCollection of: Integer&gt;	positions of each : before each argument	left	&lt;Integer&gt;	position of [	right	&lt;Integer&gt;	position of ]</body></comment><class><name>RBReadBeforeWrittenTester</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBProgramNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>read checkNewTemps scopeStack </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parse Tree Matching</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBReadBeforeWrittenTester</class-id><body>RBReadBeforeWrittenTester is a visitor that identifies variables that may have been read before they are initialized.Instance Variables:	checkNewTemps	&lt;Boolean&gt;	description of checkNewTemps	read	&lt;Collection&gt;	description of read	scopeStack	&lt;OrderedCollection&gt;	description of scopeStack</body></comment><class><name>RBPatternParser</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBPatternParser</class-id><body>RBPatternParser is a subclass of RBParser that allows the extended syntax that creates matching trees. These trees can be used by the ParseTreeMatcher to search and transform source code.</body></comment><class><name>RBPatternBlockNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBBlockNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>valueBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parse Tree Matching</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBPatternBlockNode</class-id><body>RBPatternBlockNode is the node in matching parse trees (it never occurs in normal Smalltalk code) that executes a block to determine if a match occurs. valueBlock takes two arguments, the first is the actual node that we are trying to match against, and second node is the dictionary that contains all the metavariable bindings that the matcher has made thus far.Instance Variables:	valueBlock	&lt;BlockClosure&gt;	The block to execute when attempting to match this to a node.</body></comment><class><name>RBPatternWrapperBlockNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBPatternBlockNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>wrappedNode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parse Tree Matching</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBPatternWrapperBlockNode</class-id><body>RBPatternWrapperBlockNode allows further matching using a block after a node has been matched by a pattern node.Instance Variables:	wrappedNode	&lt;RBProgramNode&gt;	The original pattern node to match</body></comment><class><name>RBLiteralValueNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBLiteralNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>token </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBLiteralValueNode</class-id><body>RBLiteralNode is an AST node that represents literals (e.g., #foo, #(1 2 3), true, etc.).Instance Variables:	token	&lt;RBLiteralToken&gt;	the token that contains the literal value as well as its source positions</body></comment><shared-variable><name>ParserType</name><environment>Refactory.Browser.RBParser</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Browser-Parser</package></attributes></shared-variable><shared-variable><name>TraditionalBinaryPrecedence</name><environment>Refactory.Browser.RBConfigurableFormatter</environment><private>true</private><constant>false</constant><category>settings</category><initializer>#(#($| $&amp; $?) #($= $~ $&lt; $&gt;) #($- $+) #($* $/ $% $\) #($@))</initializer><attributes><package>Browser-Parser</package></attributes></shared-variable><shared-variable><name>NewLinesAfterMethodPattern</name><environment>Refactory.Browser.RBConfigurableFormatter</environment><private>false</private><constant>false</constant><category>settings</category><initializer>1</initializer><attributes><package>Browser-Parser</package></attributes></shared-variable><shared-variable><name>NewLineBeforeFirstKeyword</name><environment>Refactory.Browser.RBConfigurableFormatter</environment><private>false</private><constant>false</constant><category>settings</category><initializer>true</initializer><attributes><package>Browser-Parser</package></attributes></shared-variable><shared-variable><name>StringFollowingReturn</name><environment>Refactory.Browser.RBConfigurableFormatter</environment><private>true</private><constant>false</constant><category>settings</category><initializer>String new</initializer><attributes><package>Browser-Parser</package></attributes></shared-variable><shared-variable><name>RetainBlankLinesBetweenStatements</name><environment>Refactory.Browser.RBConfigurableFormatter</environment><private>false</private><constant>false</constant><category>settings</category><initializer>false</initializer><attributes><package>Browser-Parser</package></attributes></shared-variable><shared-variable><name>PeriodsAtEndOfMethod</name><environment>Refactory.Browser.RBConfigurableFormatter</environment><private>false</private><constant>false</constant><category>settings</category><initializer>false</initializer><attributes><package>Browser-Parser</package></attributes></shared-variable><shared-variable><name>FormatCommentWithStatements</name><environment>Refactory.Browser.RBConfigurableFormatter</environment><private>false</private><constant>false</constant><category>settings</category><initializer>true</initializer><attributes><package>Browser-Parser</package></attributes></shared-variable><shared-variable><name>NewLinesAfterMethodComment</name><environment>Refactory.Browser.RBConfigurableFormatter</environment><private>false</private><constant>false</constant><category>settings</category><initializer>2</initializer><attributes><package>Browser-Parser</package></attributes></shared-variable><shared-variable><name>NewLineBeforeFirstCascade</name><environment>Refactory.Browser.RBConfigurableFormatter</environment><private>false</private><constant>false</constant><category>settings</category><initializer>true</initializer><attributes><package>Browser-Parser</package></attributes></shared-variable><shared-variable><name>StringInsideBlocks</name><environment>Refactory.Browser.RBConfigurableFormatter</environment><private>true</private><constant>false</constant><category>settings</category><initializer>String new</initializer><attributes><package>Browser-Parser</package></attributes></shared-variable><shared-variable><name>IndentString</name><environment>Refactory.Browser.RBConfigurableFormatter</environment><private>true</private><constant>false</constant><category>settings</category><initializer>String with: Character tab</initializer><attributes><package>Browser-Parser</package></attributes></shared-variable><shared-variable><name>NewLineAfterCascade</name><environment>Refactory.Browser.RBConfigurableFormatter</environment><private>false</private><constant>false</constant><category>settings</category><initializer>true</initializer><attributes><package>Browser-Parser</package></attributes></shared-variable><shared-variable><name>NumberOfArgumentsForMultiLine</name><environment>Refactory.Browser.RBConfigurableFormatter</environment><private>false</private><constant>false</constant><category>settings</category><initializer>2</initializer><attributes><package>Browser-Parser</package></attributes></shared-variable><shared-variable><name>StringInsideParentheses</name><environment>Refactory.Browser.RBConfigurableFormatter</environment><private>true</private><constant>false</constant><category>settings</category><initializer>String new</initializer><attributes><package>Browser-Parser</package></attributes></shared-variable><shared-variable><name>UseTraditionalBinaryPrecedenceForParentheses</name><environment>Refactory.Browser.RBConfigurableFormatter</environment><private>true</private><constant>false</constant><category>settings</category><initializer>true</initializer><attributes><package>Browser-Parser</package></attributes></shared-variable><shared-variable><name>IndentsForKeywords</name><environment>Refactory.Browser.RBConfigurableFormatter</environment><private>false</private><constant>false</constant><category>settings</category><initializer>1</initializer><attributes><package>Browser-Parser</package></attributes></shared-variable><shared-variable><name>NewLinesAfterTemporaries</name><environment>Refactory.Browser.RBConfigurableFormatter</environment><private>false</private><constant>false</constant><category>settings</category><initializer>1</initializer><attributes><package>Browser-Parser</package></attributes></shared-variable><shared-variable><name>MethodSignatureOnMultipleLines</name><environment>Refactory.Browser.RBConfigurableFormatter</environment><private>false</private><constant>false</constant><category>settings</category><initializer>false</initializer><attributes><package>Browser-Parser</package></attributes></shared-variable><shared-variable><name>MaxLineLength</name><environment>Refactory.Browser.RBConfigurableFormatter</environment><private>false</private><constant>false</constant><category>settings</category><initializer>75</initializer><attributes><package>Browser-Parser</package></attributes></shared-variable><shared-variable><name>LineUpBlockBrackets</name><environment>Refactory.Browser.RBConfigurableFormatter</environment><private>false</private><constant>false</constant><category>settings</category><initializer>false</initializer><attributes><package>Browser-Parser</package></attributes></shared-variable><shared-variable><name>MinimumNewLinesBetweenStatements</name><environment>Refactory.Browser.RBConfigurableFormatter</environment><private>false</private><constant>false</constant><category>settings</category><initializer>1</initializer><attributes><package>Browser-Parser</package></attributes></shared-variable><shared-variable><name>PeriodsAtEndOfBlock</name><environment>Refactory.Browser.RBConfigurableFormatter</environment><private>false</private><constant>false</constant><category>settings</category><initializer>false</initializer><attributes><package>Browser-Parser</package></attributes></shared-variable><shared-variable><name>PeriodsAsTerminators</name><environment>Refactory.Browser.RBConfigurableFormatter</environment><private>false</private><constant>false</constant><category>settings</category><initializer>false</initializer><attributes><package>Browser-Parser</package></attributes></shared-variable><shared-variable><name>PatternVariableCharacter</name><environment>Refactory.Browser.RBScanner</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Browser-Parser</package></attributes></shared-variable><shared-variable><name>FormatterClass</name><environment>Refactory.Browser.RBProgramNode</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Browser-Parser</package></attributes></shared-variable><methods><class-id>Refactory.Browser.RBProgramNodeVisitor</class-id> <category>visitor-double dispatching</category><body package="Browser-Parser" selector="acceptAssignmentNode:">acceptAssignmentNode: anAssignmentNode 	self visitNode: anAssignmentNode variable.	self visitNode: anAssignmentNode value</body><body package="Browser-Parser" selector="acceptBlockNode:">acceptBlockNode: aBlockNode 	self visitArguments: aBlockNode arguments.	self visitNode: aBlockNode body</body><body package="Browser-Parser" selector="acceptCascadeNode:">acceptCascadeNode: aCascadeNode 	aCascadeNode messages do: [:each | self visitNode: each]</body><body package="Browser-Parser" selector="acceptLiteralArrayNode:">acceptLiteralArrayNode: aRBLiteralArrayNode 	aRBLiteralArrayNode contents do: [:each | self visitNode: each]</body><body package="Browser-Parser" selector="acceptLiteralNode:">acceptLiteralNode: aLiteralNode</body><body package="Browser-Parser" selector="acceptMessageNode:">acceptMessageNode: aMessageNode 	(aMessageNode isCascaded not or: [aMessageNode isFirstCascaded]) 		ifTrue: [self visitNode: aMessageNode receiver].	aMessageNode arguments do: [:each | self visitNode: each]</body><body package="Browser-Parser" selector="acceptMethodNode:">acceptMethodNode: aMethodNode 	self visitArguments: aMethodNode arguments.	self visitNode: aMethodNode body</body><body package="Browser-Parser" selector="acceptOptimizedNode:">acceptOptimizedNode: anOptimizedNode 	self visitNode: anOptimizedNode body</body><body package="Browser-Parser" selector="acceptPatternBlockNode:">acceptPatternBlockNode: aRBPatternBlockNode 	self visitArguments: aRBPatternBlockNode arguments.	self visitNode: aRBPatternBlockNode body</body><body package="Browser-Parser" selector="acceptPatternWrapperBlockNode:">acceptPatternWrapperBlockNode: aRBPatternWrapperBlockNode 	self visitNode: aRBPatternWrapperBlockNode wrappedNode.	self visitArguments: aRBPatternWrapperBlockNode arguments.	self visitNode: aRBPatternWrapperBlockNode body</body><body package="Browser-Parser" selector="acceptReturnNode:">acceptReturnNode: aReturnNode 	self visitNode: aReturnNode value</body><body package="Browser-Parser" selector="acceptSequenceNode:">acceptSequenceNode: aSequenceNode 	self visitArguments: aSequenceNode temporaries.	aSequenceNode statements do: [:each | self visitNode: each]</body><body package="Browser-Parser" selector="acceptVariableNode:">acceptVariableNode: aVariableNode</body></methods><methods><class-id>Refactory.Browser.RBProgramNodeVisitor</class-id> <category>initialize-release</category><body package="Browser-Parser" selector="initialize">initialize</body></methods><methods><class-id>Refactory.Browser.RBProgramNodeVisitor</class-id> <category>visiting</category><body package="Browser-Parser" selector="visitArgument:">visitArgument: each 	"Here to allow subclasses to detect arguments or temporaries."	^self visitNode: each</body><body package="Browser-Parser" selector="visitArguments:">visitArguments: aNodeCollection 	^aNodeCollection do: [:each | self visitArgument: each]</body><body package="Browser-Parser" selector="visitNode:">visitNode: aNode 	^aNode acceptVisitor: self</body></methods><methods><class-id>Refactory.Browser.RBProgramNodeVisitor class</class-id> <category>instance creation</category><body package="Browser-Parser" selector="new">new	^super new initialize</body></methods><methods><class-id>Refactory.Browser.RBConfigurableFormatter</class-id> <category>private-formatting</category><body package="Browser-Parser" selector="addNewLinesBeforeStatementStartingAt:">addNewLinesBeforeStatementStartingAt: anInteger 	| newLines |	newLines := MinimumNewLinesBetweenStatements 				max: (RetainBlankLinesBetweenStatements 						ifTrue: [self newLinesBeforeStartingAt: anInteger]						ifFalse: [0]).	newLines = 0 ifTrue: [self space] ifFalse: [self newLines: newLines]</body><body package="Browser-Parser" selector="formatBlock:">formatBlock: aBlockNode	(LineUpBlockBrackets and: [self willBeMultiline: aBlockNode body]) ifTrue:			[self newLine] ifFalse: [codeStream nextPutAll: StringInsideBlocks].	self formatBlockArgumentsFor: aBlockNode.	self visitNode: aBlockNode body.	^(LineUpBlockBrackets and: [self willBeMultiline: aBlockNode body]) ifTrue:			[self newLine] ifFalse: [codeStream nextPutAll: StringInsideBlocks]</body><body package="Browser-Parser" selector="formatBlockArgumentsFor:">formatBlockArgumentsFor: aBlockNode	aBlockNode arguments isEmpty ifTrue: [^self].	aBlockNode arguments		do:			[:each | 			codeStream nextPut: $:.			self visitNode: each.			FormatCommentWithStatements ifTrue: [self formatCommentsFor: each].			self space].	codeStream nextPutAll: '| '.	(self willBeMultiline: aBlockNode body) ifTrue: [self newLine]</body><body package="Browser-Parser" selector="formatCommentsFor:">formatCommentsFor: aNode 	originalSource isNil ifTrue: [^self].	aNode comments do: 			[:each | 			codeStream				space;				nextPutAll: (originalSource copyFrom: each first to: each last)]</body><body package="Browser-Parser" selector="formatMethodBodyFor:">formatMethodBodyFor: aMethodNode 	self		indentAround: 			[self newLines: NewLinesAfterMethodPattern.			self formatMethodCommentFor: aMethodNode.			self formatTagsFor: aMethodNode.			self visitNode: aMethodNode body]</body><body package="Browser-Parser" selector="formatMethodCommentFor:">formatMethodCommentFor: aMethodNode	originalSource isNil ifTrue: [^self].	(FormatCommentWithStatements		ifTrue: [aMethodNode methodComments]		ifFalse: [aMethodNode comments])		do:			[:each | 			codeStream				nextPutAll:					(originalSource						copyFrom: each first						to: each last).			self newLines: NewLinesAfterMethodComment]</body><body package="Browser-Parser" selector="formatMethodPatternFor:">formatMethodPatternFor: aMethodNode 	aMethodNode arguments isEmpty		ifTrue: [codeStream nextPutAll: aMethodNode selector]		ifFalse: 			[self				with: aMethodNode selectorParts				and: aMethodNode arguments				do: 					[:key :arg | 					codeStream nextPutAll: key value.					self space.					self visitNode: arg]				separatedBy: 					[MethodSignatureOnMultipleLines						ifTrue: [self newLine]						ifFalse: [self space]]]</body><body package="Browser-Parser" selector="formatSelectorAndArguments:">formatSelectorAndArguments: aMessageNode 	| newLineBetweenArguments |	newLineBetweenArguments := self isMultiLineMessage: aMessageNode.	self indent: IndentsForKeywords		around: 			[self 				formatSelectorAndArguments: aMessageNode				firstSeparator: (newLineBetweenArguments &amp; NewLineBeforeFirstKeyword 						ifTrue: [[self newLine]]						ifFalse: [[self space]])				restSeparator: (newLineBetweenArguments 						ifTrue: [[self newLine]]						ifFalse: [[self space]])]</body><body package="Browser-Parser" selector="formatSelectorAndArguments:firstSeparator:restSeparator:">formatSelectorAndArguments: aMessageNode firstSeparator: firstBlock restSeparator: restBlock 	| separatorBlock |	separatorBlock := firstBlock.	aMessageNode isUnary 		ifTrue: 			[(self isLineTooLong: aMessageNode selector) 				ifTrue: [self newLine]				ifFalse: [separatorBlock value].			codeStream nextPutAll: aMessageNode selector]		ifFalse: 			[aMessageNode selectorParts with: aMessageNode arguments				do: 					[:selector :argument | 					(self isLineTooLong: selector value) 						ifTrue: [self newLine]						ifFalse: [separatorBlock value].					separatorBlock := restBlock.					self indentAround: 							[codeStream nextPutAll: selector value.							((self willBeMultiline: argument) 								or: [self isLineTooLong: (self formattedSourceFor: argument)]) 									ifTrue: [self newLine]									ifFalse: [self space].							self visitNode: argument]]]</body><body package="Browser-Parser" selector="formatSequenceCommentsFor:">formatSequenceCommentsFor: aSequenceNode	originalSource isNil ifTrue: [^self].	aSequenceNode comments		do:			[:each | 			codeStream				nextPutAll:					(originalSource						copyFrom: each first						to: each last).			self newLine]</body><body package="Browser-Parser" selector="formatSequenceNodeStatementsFor:">formatSequenceNodeStatementsFor: aSequenceNode 	| statements |	statements := aSequenceNode statements.	statements isEmpty ifTrue: [^self].	1 to: statements size		do: 			[:i | 			self visitNode: (statements at: i).			(i &lt; statements size or: 					[aSequenceNode parent ifNil: [self class periodsAsTerminators]						ifNotNil: 							[:parent | 							parent isBlock 								ifTrue: [self class periodsAtEndOfBlock]								ifFalse: [self class periodsAtEndOfMethod]]]) 				ifTrue: [codeStream nextPut: $.].			self formatStatementCommentsFor: (statements at: i).			i &lt; statements size 				ifTrue: 					[self addNewLinesBeforeStatementStartingAt: (statements at: i + 1) start]]</body><body package="Browser-Parser" selector="formatStatementCommentsFor:">formatStatementCommentsFor: aStatementNode	originalSource isNil ifTrue: [^self].	FormatCommentWithStatements ifFalse: [^self].	aStatementNode statementComments		do:			[:each | 			codeStream				tab;				nextPutAll:						(originalSource								copyFrom: each first								to: each last)]</body><body package="Browser-Parser" selector="formatTagsFor:">formatTagsFor: aMethodNode	aMethodNode primitiveSources do:			[:each | 			codeStream nextPutAll: each.			self newLine]</body><body package="Browser-Parser" selector="formatTemporariesFor:">formatTemporariesFor: aSequenceNode	aSequenceNode temporaries isEmpty ifTrue: [^self].	self		bracketWith: '|'		around:			[self space.			aSequenceNode temporaries				do:					[:each | 					self visitNode: each.					FormatCommentWithStatements ifTrue: [self formatCommentsFor: each].					self space]].	self newLines: NewLinesAfterTemporaries</body><body package="Browser-Parser" selector="isMultiLineMessage:">isMultiLineMessage: aMessageNode 	| messageStream |	aMessageNode arguments size &gt;= NumberOfArgumentsForMultiLine 		ifTrue: [^true].	(aMessageNode arguments anySatisfy: 			[:each | 			self indent: IndentsForKeywords + 1 around: [self willBeMultiline: each]]) 		ifTrue: [^true].	aMessageNode isUnary ifTrue: [^self isLineTooLong: aMessageNode selector].	messageStream := WriteStream on: (String new: 100).	self 		with: aMessageNode selectorParts		and: aMessageNode arguments		do: 			[:sel :arg | 			messageStream				nextPutAll: sel value;				space;				nextPutAll: (self formattedSourceFor: arg)]		separatedBy: [messageStream space].	^self isLineTooLong: messageStream contents</body></methods><methods><class-id>Refactory.Browser.RBConfigurableFormatter</class-id> <category>private</category><body package="Browser-Parser" selector="bracketWith:around:">bracketWith: bracketString around: aBlock 	bracketString isEmpty ifTrue: [^aBlock value].	codeStream nextPut: bracketString first.	^aBlock ensure: [codeStream nextPut: bracketString last]</body><body package="Browser-Parser" selector="currentLineLength">currentLineLength	^codeStream position - lineStart</body><body package="Browser-Parser" selector="formattedSourceFor:">formattedSourceFor: aNode 	^lookaheadCode at: aNode		ifAbsentPut: [self class format: aNode withIndents: indent]</body><body package="Browser-Parser" selector="indent:around:">indent: anInteger around: aBlock 	indent := indent + anInteger.	^aBlock ensure: [indent := indent - anInteger]</body><body package="Browser-Parser" selector="indentAround:">indentAround: aBlock 	self indent: 1 around: aBlock</body><body package="Browser-Parser" selector="isLineTooLong:">isLineTooLong: aString 	^self currentLineLength + aString size &gt;= MaxLineLength</body><body package="Browser-Parser" selector="needsParenthesisFor:">needsParenthesisFor: aNode 	| parent grandparent |	parent := aNode parent.	(parent isNil or: [parent isMessage not]) ifTrue: [^false].	(aNode isMessage and: [parent isMessage and: [parent receiver == aNode]]) 		ifTrue: 			[grandparent := parent parent.			(grandparent notNil and: [grandparent isCascade]) ifTrue: [^true]].	aNode precedence &lt; parent precedence ifTrue: [^false].	(parent receiver ~~ aNode and: [aNode precedence &gt;= parent precedence]) 		ifTrue: [^true].	(parent receiver == aNode 		and: [aNode precedence &gt; parent precedence or: [aNode isKeyword]]) 			ifTrue: [^true].	aNode isBinary ifFalse: [^false].	^UseTraditionalBinaryPrecedenceForParentheses 		and: [self precedenceOf: parent selector greaterThan: aNode selector]</body><body package="Browser-Parser" selector="newLine">newLine	self newLines: 1</body><body package="Browser-Parser" selector="newLines:">newLines: anInteger 	anInteger + IndentString size = 0 ifTrue: [codeStream space].	anInteger timesRepeat: [codeStream cr].	lineStart := codeStream position.	indent timesRepeat: [codeStream nextPutAll: IndentString]</body><body package="Browser-Parser" selector="newLinesBeforeStartingAt:">newLinesBeforeStartingAt: anIndex 	| count cr lf index char |	(anIndex isNil or: [anIndex &gt; originalSource size]) ifTrue: [^0].	cr := Character value: 13.	lf := Character value: 10.	count := 0.	index := anIndex - 1.	[index &gt; 0 and: [(char := originalSource at: index) isSeparator]] 		whileTrue: 			[char == lf 				ifTrue: 					[count := count + 1.					(originalSource at: (index - 1 max: 1)) == cr ifTrue: [index := index - 1]].			char == cr ifTrue: [count := count + 1].			index := index - 1].	^count</body><body package="Browser-Parser" selector="precedenceOf:greaterThan:">precedenceOf: parentSelector greaterThan: childSelector 	"Put parenthesis around things that are preceived to have 'lower' precedence. For example, 'a + b * c' 	-&gt; '(a + b) * c' but 'a * b + c' -&gt; 'a * b + c'"	| childIndex parentIndex |	childIndex := 0.	parentIndex := 0.	1 to: TraditionalBinaryPrecedence size		do: 			[:i | 			((TraditionalBinaryPrecedence at: i) includes: parentSelector first) 				ifTrue: [parentIndex := i].			((TraditionalBinaryPrecedence at: i) includes: childSelector first) 				ifTrue: [childIndex := i]].	^childIndex &lt; parentIndex</body><body package="Browser-Parser" selector="space">space	codeStream space</body><body package="Browser-Parser" selector="willBeMultiline:">willBeMultiline: aNode 	^(self formattedSourceFor: aNode) includes: Character cr</body><body package="Browser-Parser" selector="writeString:">writeString: aString 	| index |	index := aString lastIndexOf: Character cr ifAbsent: [0].	codeStream nextPutAll: aString.	index &gt; 0 		ifTrue: [lineStart := codeStream position - (aString size - index)]</body></methods><methods><class-id>Refactory.Browser.RBConfigurableFormatter</class-id> <category>initialize-release</category><body package="Browser-Parser" selector="indent:">indent: anInteger	indent := anInteger</body><body package="Browser-Parser" selector="initialize">initialize	super initialize.	lineStart := 0.	indent := 0.	lookaheadCode := IdentityDictionary new.	codeStream := WriteStream on: (String new: 256)</body></methods><methods><class-id>Refactory.Browser.RBConfigurableFormatter</class-id> <category>visiting</category><body package="Browser-Parser" selector="visitNode:">visitNode: aNode	| needsParenthesis |	(lookaheadCode includesKey: aNode)		ifTrue: [^self writeString: (lookaheadCode at: aNode)].	needsParenthesis := self needsParenthesisFor: aNode.	self		bracketWith:			(needsParenthesis				ifTrue: ['()']				ifFalse: [''])		around:			[needsParenthesis ifTrue: [codeStream nextPutAll: StringInsideParentheses].			super visitNode: aNode.			(FormatCommentWithStatements or: [aNode isMethod or: [aNode isSequence]])				ifFalse: [self formatCommentsFor: aNode].			needsParenthesis				ifTrue: [codeStream nextPutAll: StringInsideParentheses]]</body></methods><methods><class-id>Refactory.Browser.RBConfigurableFormatter</class-id> <category>visitor-double dispatching</category><body package="Browser-Parser" selector="acceptAssignmentNode:">acceptAssignmentNode: anAssignmentNode 	self visitNode: anAssignmentNode variable.	codeStream nextPutAll: ' := '.	self visitNode: anAssignmentNode value</body><body package="Browser-Parser" selector="acceptBlockNode:">acceptBlockNode: aBlockNode	self bracketWith: '[]' around: [self formatBlock: aBlockNode]</body><body package="Browser-Parser" selector="acceptCascadeNode:">acceptCascadeNode: aCascadeNode 	self visitNode: aCascadeNode receiver.	self indentAround: 			[NewLineBeforeFirstCascade ifTrue: [self newLine] ifFalse: [self space].			aCascadeNode messages do: 					[:each | 					self indentAround: 							[self 								formatSelectorAndArguments: each								firstSeparator: []								restSeparator: ((self isMultiLineMessage: each) 										ifTrue: [[self newLine]]										ifFalse: [[self space]])]]				separatedBy: 					[codeStream nextPut: $;.					NewLineAfterCascade ifTrue: [self newLine] ifFalse: [self space]]]</body><body package="Browser-Parser" selector="acceptLiteralArrayNode:">acceptLiteralArrayNode: aRBArrayLiteralNode 	| brackets |	codeStream nextPut: $#.	brackets := aRBArrayLiteralNode isForByteArray 				ifTrue: ['[]']				ifFalse: ['()'].	self bracketWith: brackets		around: 			[aRBArrayLiteralNode contents do: [:each | self visitNode: each]				separatedBy: [self space]]</body><body package="Browser-Parser" selector="acceptLiteralNode:">acceptLiteralNode: aLiteralNode 	self writeString: aLiteralNode token storeString</body><body package="Browser-Parser" selector="acceptMessageNode:">acceptMessageNode: aMessageNode 	self visitNode: aMessageNode receiver.	self formatSelectorAndArguments: aMessageNode</body><body package="Browser-Parser" selector="acceptMethodNode:">acceptMethodNode: aMethodNode 	self formatMethodPatternFor: aMethodNode.	self formatMethodBodyFor: aMethodNode</body><body package="Browser-Parser" selector="acceptOptimizedNode:">acceptOptimizedNode: anOptimizedNode	codeStream nextPutAll: '##'.	self 		bracketWith: '()' 		around: [self indentAround: [self visitNode: anOptimizedNode body]]</body><body package="Browser-Parser" selector="acceptPatternBlockNode:">acceptPatternBlockNode: aRBPatternBlockNode 	codeStream nextPut: $`.	self 		bracketWith: '{}' 		around: [self formatBlock: aRBPatternBlockNode]</body><body package="Browser-Parser" selector="acceptPatternWrapperBlockNode:">acceptPatternWrapperBlockNode: aRBPatternWrapperBlockNode	self visitNode: aRBPatternWrapperBlockNode wrappedNode.	codeStream nextPut: $`.	self 		bracketWith: '{}' 		around: [self formatBlock: aRBPatternWrapperBlockNode]</body><body package="Browser-Parser" selector="acceptReturnNode:">acceptReturnNode: aReturnNode 	codeStream		nextPut: $^;		nextPutAll: StringFollowingReturn.	self visitNode: aReturnNode value</body><body package="Browser-Parser" selector="acceptSequenceNode:">acceptSequenceNode: aSequenceNode 	self formatTemporariesFor: aSequenceNode.	self formatSequenceCommentsFor: aSequenceNode.	self formatSequenceNodeStatementsFor: aSequenceNode</body><body package="Browser-Parser" selector="acceptVariableNode:">acceptVariableNode: aVariableNode 	codeStream nextPutAll: aVariableNode name</body></methods><methods><class-id>Refactory.Browser.RBConfigurableFormatter</class-id> <category>utility</category><body package="Browser-Parser" selector="with:and:do:separatedBy:">with: firstCollection and: secondCollection do: aBlock separatedBy: separatorBlock 	firstCollection isEmpty ifTrue: [^self].	aBlock		value: firstCollection first		value: secondCollection first.	2		to: firstCollection size		do: 			[:i | 			separatorBlock value.			aBlock				value: (firstCollection at: i)				value: (secondCollection at: i)]</body></methods><methods><class-id>Refactory.Browser.RBConfigurableFormatter</class-id> <category>public interface</category><body package="Browser-Parser" selector="format:">format: aParseTree 	originalSource := aParseTree source.	self visitNode: aParseTree.	^codeStream contents</body></methods><methods><class-id>Refactory.Browser.RBConfigurableFormatter class</class-id> <category>settings</category><body package="Browser-Parser" selector="formatCommentWithStatements">formatCommentWithStatements	^FormatCommentWithStatements</body><body package="Browser-Parser" selector="formatCommentWithStatements:">formatCommentWithStatements: aBoolean 	FormatCommentWithStatements := aBoolean</body><body package="Browser-Parser" selector="indentsForKeywords">indentsForKeywords	^IndentsForKeywords</body><body package="Browser-Parser" selector="indentsForKeywords:">indentsForKeywords: anInteger	IndentsForKeywords := anInteger</body><body package="Browser-Parser" selector="indentString">indentString	^IndentString</body><body package="Browser-Parser" selector="indentString:">indentString: aString	IndentString := aString</body><body package="Browser-Parser" selector="lineUpBlockBrackets">lineUpBlockBrackets	^LineUpBlockBrackets</body><body package="Browser-Parser" selector="lineUpBlockBrackets:">lineUpBlockBrackets: aBoolean	LineUpBlockBrackets := aBoolean</body><body package="Browser-Parser" selector="maxLineLength">maxLineLength	^MaxLineLength</body><body package="Browser-Parser" selector="maxLineLength:">maxLineLength: anInteger 	MaxLineLength := anInteger</body><body package="Browser-Parser" selector="methodSignatureOnMultipleLines">methodSignatureOnMultipleLines	^MethodSignatureOnMultipleLines</body><body package="Browser-Parser" selector="methodSignatureOnMultipleLines:">methodSignatureOnMultipleLines: aBoolean	MethodSignatureOnMultipleLines := aBoolean</body><body package="Browser-Parser" selector="minimumNewLinesBetweenStatements">minimumNewLinesBetweenStatements	^MinimumNewLinesBetweenStatements</body><body package="Browser-Parser" selector="minimumNewLinesBetweenStatements:">minimumNewLinesBetweenStatements: anInteger 	MinimumNewLinesBetweenStatements := anInteger</body><body package="Browser-Parser" selector="newLineAfterCascade">newLineAfterCascade	^NewLineAfterCascade</body><body package="Browser-Parser" selector="newLineAfterCascade:">newLineAfterCascade: aBoolean	NewLineAfterCascade := aBoolean</body><body package="Browser-Parser" selector="newLineBeforeFirstCascade">newLineBeforeFirstCascade	^NewLineBeforeFirstCascade</body><body package="Browser-Parser" selector="newLineBeforeFirstCascade:">newLineBeforeFirstCascade: aBoolean	NewLineBeforeFirstCascade := aBoolean</body><body package="Browser-Parser" selector="newLineBeforeFirstKeyword">newLineBeforeFirstKeyword	^NewLineBeforeFirstKeyword</body><body package="Browser-Parser" selector="newLineBeforeFirstKeyword:">newLineBeforeFirstKeyword: aBoolean	NewLineBeforeFirstKeyword := aBoolean</body><body package="Browser-Parser" selector="newLinesAfterMethodComment">newLinesAfterMethodComment	 ^NewLinesAfterMethodComment</body><body package="Browser-Parser" selector="newLinesAfterMethodComment:">newLinesAfterMethodComment: anInteger	 NewLinesAfterMethodComment := anInteger.</body><body package="Browser-Parser" selector="newLinesAfterMethodPattern">newLinesAfterMethodPattern	^NewLinesAfterMethodPattern</body><body package="Browser-Parser" selector="newLinesAfterMethodPattern:">newLinesAfterMethodPattern: anInteger	NewLinesAfterMethodPattern := anInteger</body><body package="Browser-Parser" selector="newLinesAfterTemporaries">newLinesAfterTemporaries	^NewLinesAfterTemporaries</body><body package="Browser-Parser" selector="newLinesAfterTemporaries:">newLinesAfterTemporaries: anInteger	NewLinesAfterTemporaries := anInteger</body><body package="Browser-Parser" selector="numberOfArgumentsForMultiLine">numberOfArgumentsForMultiLine	^NumberOfArgumentsForMultiLine</body><body package="Browser-Parser" selector="numberOfArgumentsForMultiLine:">numberOfArgumentsForMultiLine: anInteger	NumberOfArgumentsForMultiLine := anInteger</body><body package="Browser-Parser" selector="periodsAsTerminators">periodsAsTerminators	^PeriodsAtEndOfBlock and: [PeriodsAtEndOfMethod]</body><body package="Browser-Parser" selector="periodsAsTerminators:">periodsAsTerminators: aBoolean 	PeriodsAtEndOfBlock := aBoolean.	PeriodsAtEndOfMethod := aBoolean</body><body package="Browser-Parser" selector="periodsAtEndOfBlock">periodsAtEndOfBlock	^PeriodsAtEndOfBlock</body><body package="Browser-Parser" selector="periodsAtEndOfBlock:">periodsAtEndOfBlock: aBoolean 	PeriodsAtEndOfBlock := aBoolean</body><body package="Browser-Parser" selector="periodsAtEndOfMethod">periodsAtEndOfMethod	^PeriodsAtEndOfMethod</body><body package="Browser-Parser" selector="periodsAtEndOfMethod:">periodsAtEndOfMethod: aBoolean 	PeriodsAtEndOfMethod := aBoolean</body><body package="Browser-Parser" selector="retainBlankLinesBetweenStatements">retainBlankLinesBetweenStatements	^RetainBlankLinesBetweenStatements</body><body package="Browser-Parser" selector="retainBlankLinesBetweenStatements:">retainBlankLinesBetweenStatements: aBoolean	RetainBlankLinesBetweenStatements := aBoolean</body><body package="Browser-Parser" selector="stringFollowingReturn">stringFollowingReturn	^StringFollowingReturn</body><body package="Browser-Parser" selector="stringFollowingReturn:">stringFollowingReturn: aString	StringFollowingReturn := aString</body><body package="Browser-Parser" selector="stringInsideBlocks">stringInsideBlocks	^StringInsideBlocks</body><body package="Browser-Parser" selector="stringInsideBlocks:">stringInsideBlocks: aString 	StringInsideBlocks := aString</body><body package="Browser-Parser" selector="stringInsideParentheses">stringInsideParentheses	^StringInsideParentheses</body><body package="Browser-Parser" selector="stringInsideParentheses:">stringInsideParentheses: aString 	StringInsideParentheses := aString</body><body package="Browser-Parser" selector="traditionalBinaryPrecedence">traditionalBinaryPrecedence	^TraditionalBinaryPrecedence</body><body package="Browser-Parser" selector="traditionalBinaryPrecedence:">traditionalBinaryPrecedence: anArray	TraditionalBinaryPrecedence := anArray</body><body package="Browser-Parser" selector="useTraditionalBinaryPrecedenceForParentheses">useTraditionalBinaryPrecedenceForParentheses	^UseTraditionalBinaryPrecedenceForParentheses</body><body package="Browser-Parser" selector="useTraditionalBinaryPrecedenceForParentheses:">useTraditionalBinaryPrecedenceForParentheses: aBoolean 	UseTraditionalBinaryPrecedenceForParentheses := aBoolean</body></methods><methods><class-id>Refactory.Browser.RBConfigurableFormatter class</class-id> <category>public interface</category><body package="Browser-Parser" selector="format:">format: aParseTree 	^self format: aParseTree withIndents: 0</body><body package="Browser-Parser" selector="format:withIndents:">format: aParseTree withIndents: anInteger 	^(self new)		indent: anInteger;		format: aParseTree</body></methods><methods><class-id>Refactory.Browser.RBFormatter</class-id> <category>visitor-double dispatching</category><body package="Browser-Parser" selector="acceptAssignmentNode:">acceptAssignmentNode: anAssignmentNode 	self indent: 2		while: 			[self visitNode: anAssignmentNode variable.			codeStream nextPutAll: ' := '.			self visitNode: anAssignmentNode value]</body><body package="Browser-Parser" selector="acceptBlockNode:">acceptBlockNode: aBlockNode 	self 		acceptBlockNode: aBlockNode		startBlockString: '['		endBlockString: ']'</body><body package="Browser-Parser" selector="acceptBlockNode:startBlockString:endBlockString:">acceptBlockNode: aBlockNode startBlockString: startBlockString endBlockString: endBlockString 	| seqNode multiline formattedBody formatter |	seqNode := aBlockNode body.	formatter := (self copy)				lineStart: 0;				yourself.	formattedBody := formatter format: seqNode.	multiline := self lineLength + formattedBody size &gt; self maxLineSize 				or: [formatter isMultiLine].	multiline ifTrue: [self indent].	codeStream nextPutAll: startBlockString.	aBlockNode arguments do: 			[:each | 			codeStream nextPut: $:.			self visitNode: each.			codeStream nextPut: $ ].	aBlockNode arguments notEmpty 		ifTrue: 			[codeStream nextPutAll: '| '.			multiline ifTrue: [self indent]].	codeStream		nextPutAll: formattedBody;		nextPutAll: endBlockString</body><body package="Browser-Parser" selector="acceptCascadeNode:">acceptCascadeNode: aCascadeNode 	| messages |	messages := aCascadeNode messages.	self visitNode: messages first receiver.	self indentWhile: 			[self 				for: messages				do: 					[:each | 					self						indent;						indentWhile: [self formatMessage: each cascade: true]]				separatedBy: [codeStream nextPut: $;]]</body><body package="Browser-Parser" selector="acceptLiteralArrayNode:">acceptLiteralArrayNode: aRBArrayLiteralNode 	codeStream nextPutAll: (aRBArrayLiteralNode isForByteArray 				ifTrue: ['#[']				ifFalse: ['#(']).	self 		for: aRBArrayLiteralNode contents		do: [:each | self visitNode: each]		separatedBy: [codeStream nextPut: $ ].	codeStream 		nextPut: (aRBArrayLiteralNode isForByteArray ifTrue: [$]] ifFalse: [$)])</body><body package="Browser-Parser" selector="acceptLiteralNode:">acceptLiteralNode: aLiteralNode 	aLiteralNode token storeOn: codeStream</body><body package="Browser-Parser" selector="acceptMessageNode:">acceptMessageNode: aMessageNode 	| newFormatter code |	newFormatter := self copy.	code := newFormatter format: aMessageNode receiver.	codeStream nextPutAll: code.	codeStream nextPut: $ .	newFormatter isMultiLine		ifTrue: [lineStart := codeStream position - newFormatter lastLineLength].	self indent: (newFormatter isMultiLine ifTrue: [2] ifFalse: [1])		while: [self formatMessage: aMessageNode cascade: false]</body><body package="Browser-Parser" selector="acceptMethodNode:">acceptMethodNode: aMethodNode 	self formatMethodPatternFor: aMethodNode.	self indentWhile: 			[self formatMethodCommentFor: aMethodNode indentBefore: true.			self indent.			self tagBeforeTemporaries ifTrue: [self formatTagFor: aMethodNode].			aMethodNode body statements notEmpty 				ifTrue: [self visitNode: aMethodNode body]]</body><body package="Browser-Parser" selector="acceptOptimizedNode:">acceptOptimizedNode: anOptimizedNode 	codeStream nextPutAll: '##('.	self visitNode: anOptimizedNode body.	codeStream nextPut: $)</body><body package="Browser-Parser" selector="acceptPatternBlockNode:">acceptPatternBlockNode: aRBPatternBlockNode 	self 		acceptBlockNode: aRBPatternBlockNode		startBlockString: '`{'		endBlockString: '}'</body><body package="Browser-Parser" selector="acceptPatternWrapperBlockNode:">acceptPatternWrapperBlockNode: aRBPatternWrapperBlockNode 	self visitNode: aRBPatternWrapperBlockNode wrappedNode.	self 		acceptBlockNode: aRBPatternWrapperBlockNode		startBlockString: '`{'		endBlockString: '}'</body><body package="Browser-Parser" selector="acceptReturnNode:">acceptReturnNode: aReturnNode 	codeStream nextPut: $^.	self visitNode: aReturnNode value</body><body package="Browser-Parser" selector="acceptSequenceNode:">acceptSequenceNode: aSequenceNode 	self formatMethodCommentFor: aSequenceNode indentBefore: false.	self formatTemporariesFor: aSequenceNode.	self tagBeforeTemporaries 		ifFalse: 			[| parent |			parent := aSequenceNode parent.			(parent notNil and: [parent isMethod]) ifTrue: [self formatTagFor: parent]].	self formatStatementsFor: aSequenceNode</body><body package="Browser-Parser" selector="acceptVariableNode:">acceptVariableNode: aVariableNode 	codeStream nextPutAll: aVariableNode name</body></methods><methods><class-id>Refactory.Browser.RBFormatter</class-id> <category>accessing</category><body package="Browser-Parser" selector="firstLineLength">firstLineLength	^firstLineLength isNil		ifTrue: [codeStream position]		ifFalse: [firstLineLength]</body><body package="Browser-Parser" selector="format:">format: aNode 	self visitNode: aNode.	^codeStream contents</body><body package="Browser-Parser" selector="isMultiLine">isMultiLine	^firstLineLength notNil</body><body package="Browser-Parser" selector="lastLineLength">lastLineLength	^codeStream position - (lineStart max: 0)</body></methods><methods><class-id>Refactory.Browser.RBFormatter</class-id> <category>private</category><body package="Browser-Parser" selector="for:do:separatedBy:">for: aValue do: doBlock separatedBy: separatorBlock 	"This is implemented here since IBM Smalltalk doesn't implement a do:separatedBy: method"	aValue isEmpty ifTrue: [^self].	1 to: aValue size - 1		do: 			[:i | 			doBlock value: (aValue at: i).			separatorBlock value].	doBlock value: aValue last</body><body package="Browser-Parser" selector="indent">indent	firstLineLength isNil ifTrue: [firstLineLength := codeStream position].	codeStream cr.	tabs timesRepeat: [codeStream tab].	lineStart := codeStream position</body><body package="Browser-Parser" selector="indent:while:">indent: anInteger while: aBlock 	tabs := tabs + anInteger.	aBlock value.	tabs := tabs - anInteger</body><body package="Browser-Parser" selector="indentWhile:">indentWhile: aBlock 	self indent: 1 while: aBlock</body><body package="Browser-Parser" selector="lineLength">lineLength	^codeStream position - lineStart</body><body package="Browser-Parser" selector="lineStart:">lineStart: aPosition 	lineStart := aPosition</body><body package="Browser-Parser" selector="maximumArgumentsPerLine">maximumArgumentsPerLine	^2</body><body package="Browser-Parser" selector="maxLineSize">maxLineSize	^75</body><body package="Browser-Parser" selector="needsParenthesisFor:">needsParenthesisFor: aNode 	| parent grandparent |	aNode isValue ifFalse: [^false].	parent := aNode parent.	parent isNil ifTrue: [^false].	(aNode isMessage and: [parent isMessage and: [parent receiver == aNode]])		ifTrue: 			[grandparent := parent parent.			(grandparent notNil and: [grandparent isCascade]) ifTrue: [^true]].	aNode precedence &lt; parent precedence ifTrue: [^false].	aNode isAssignment &amp; parent isAssignment ifTrue: [^false].	aNode isAssignment | aNode isCascade ifTrue: [^true].	aNode precedence == 0 ifTrue: [^false].	aNode isMessage ifFalse: [^true].	aNode precedence = parent precedence ifFalse: [^true].	aNode isUnary ifTrue: [^false].	aNode isKeyword ifTrue: [^true].	parent receiver == aNode ifFalse: [^true].	^self precedenceOf: parent selector greaterThan: aNode selector</body><body package="Browser-Parser" selector="precedenceOf:greaterThan:">precedenceOf: parentSelector greaterThan: childSelector 	"Put parenthesis around things that are preceived to have 'lower' precedence. For example, 'a + b * c' 	-&gt; '(a + b) * c' but 'a * b + c' -&gt; 'a * b + c'"	| childIndex parentIndex operators |	operators := #(#($| $&amp; $?) #($= $~ $&lt; $&gt;) #($- $+) #($* $/ $% $\) #($@)).	childIndex := 0.	parentIndex := 0.	1 to: operators size		do: 			[:i | 			((operators at: i) includes: parentSelector first) 				ifTrue: [parentIndex := i].			((operators at: i) includes: childSelector first) 				ifTrue: [childIndex := i]].	^childIndex &lt; parentIndex</body><body package="Browser-Parser" selector="selectorsToLeaveOnLine">selectorsToLeaveOnLine	^#(#to:do: #to:by: #to:by:do:)</body><body package="Browser-Parser" selector="selectorsToStartOnNewLine">selectorsToStartOnNewLine	^#(#ifTrue:ifFalse: #ifFalse:ifTrue: #ifTrue: #ifFalse:)</body></methods><methods><class-id>Refactory.Browser.RBFormatter</class-id> <category>private-formatting</category><body package="Browser-Parser" selector="formatMessage:cascade:">formatMessage: aMessageNode cascade: cascadeBoolean 	| selectorParts arguments multiLine formattedArgs indentFirst firstArgLength length |	selectorParts := aMessageNode selectorParts.	arguments := aMessageNode arguments.	formattedArgs := OrderedCollection new.	multiLine := aMessageNode selector numArgs &gt; self maximumArgumentsPerLine.	length := aMessageNode selector size + arguments size + 1.	firstArgLength := 0.	self indentWhile: 			[1 to: arguments size				do: 					[:i | 					| formatter string |					formatter := (self copy)								lineStart: (selectorParts at: i) length negated;								yourself.					string := formatter format: (arguments at: i).					formattedArgs add: string.					i == 1 ifTrue: [firstArgLength := formatter firstLineLength].					length := length + string size.					multiLine := multiLine or: [formatter isMultiLine]]].	multiLine := multiLine or: [length + self lineLength &gt; self maxLineSize].	indentFirst := cascadeBoolean not and: 					[multiLine and: 							[(self startMessageSendOnNewLine: aMessageNode) or: 									[self lineLength + selectorParts first length + 2 + firstArgLength 										&gt; self maxLineSize]]].	indentFirst ifTrue: [self indent].	self 		formatMessageSelector: selectorParts		withArguments: formattedArgs		multiline: multiLine</body><body package="Browser-Parser" selector="formatMessageSelector:withArguments:multiline:">formatMessageSelector: selectorParts withArguments: formattedArgs multiline: multiLine 	formattedArgs isEmpty 		ifTrue: [codeStream nextPutAll: selectorParts first value]		ifFalse: 			[1 to: formattedArgs size				do: 					[:i | 					i ~~ 1 &amp; multiLine not ifTrue: [codeStream nextPut: $ ].					codeStream 						nextPutAll: (selectorParts at: i) value;						nextPut: $ ;						nextPutAll: (formattedArgs at: i).					(multiLine and: [i &lt; formattedArgs size]) ifTrue: [self indent]]]</body><body package="Browser-Parser" selector="formatMethodCommentFor:indentBefore:">formatMethodCommentFor: aNode indentBefore: aBoolean 	| source |	source := aNode source.	source isNil ifTrue: [^self].	aNode methodComments do: 			[:each | 			aBoolean ifTrue: [self indent].			codeStream				nextPutAll: (aNode source copyFrom: each first to: each last);				cr.			aBoolean ifFalse: [self indent]]</body><body package="Browser-Parser" selector="formatMethodPatternFor:">formatMethodPatternFor: aMethodNode 	| selectorParts arguments |	selectorParts := aMethodNode selectorParts.	arguments := aMethodNode arguments.	arguments isEmpty 		ifTrue: [codeStream nextPutAll: selectorParts first value]		ifFalse: 			[selectorParts with: arguments				do: 					[:selector :arg | 					codeStream						nextPutAll: selector value;						nextPut: $ .					self visitArgument: arg.					codeStream nextPut: $ ]]</body><body package="Browser-Parser" selector="formatStatementCommentFor:">formatStatementCommentFor: aNode 	| source |	source := aNode source.	source isNil ifTrue: [^self].	aNode statementComments do: 			[:each | 			| crs |			crs := self newLinesFor: source startingAt: each first.			(crs - 1 max: 0) timesRepeat: [codeStream cr].			crs == 0 ifTrue: [codeStream tab] ifFalse: [self indent].			codeStream nextPutAll: (source copyFrom: each first to: each last)]</body><body package="Browser-Parser" selector="formatStatementsFor:">formatStatementsFor: aSequenceNode 	| statements |	statements := aSequenceNode statements.	statements isEmpty ifTrue: [^self].	1 to: statements size - 1		do: 			[:i | 			self visitNode: (statements at: i).			codeStream nextPut: $..			self formatStatementCommentFor: (statements at: i).			self indent].	self visitNode: statements last.	self formatStatementCommentFor: statements last</body><body package="Browser-Parser" selector="formatTagFor:">formatTagFor: aMethodNode 	| primitiveSources |	primitiveSources := aMethodNode primitiveSources.	primitiveSources do: 			[:each | 			codeStream nextPutAll: each.			self indent]</body><body package="Browser-Parser" selector="formatTemporariesFor:">formatTemporariesFor: aSequenceNode 	| temps |	temps := aSequenceNode temporaries.	temps isEmpty ifTrue: [^self].	codeStream nextPutAll: '| '.	temps do: 			[:each | 			self visitArgument: each.			codeStream nextPut: $ ].	codeStream nextPut: $|.	self indent</body><body package="Browser-Parser" selector="newLinesFor:startingAt:">newLinesFor: aString startingAt: anIndex 	| count cr lf index char |	cr := Character value: 13.	lf := Character value: 10.	count := 0.	index := anIndex - 1.	[index &gt; 0 and: 			[char := aString at: index.			char isSeparator]] 		whileTrue: 			[char == lf 				ifTrue: 					[count := count + 1.					(aString at: (index - 1 max: 1)) == cr ifTrue: [index := index - 1]].			char == cr ifTrue: [count := count + 1].			index := index - 1].	^count</body></methods><methods><class-id>Refactory.Browser.RBFormatter</class-id> <category>initialize-release</category><body package="Browser-Parser" selector="initialize">initialize	super initialize.	codeStream := WriteStream on: (String new: 60).	tabs := 0.	lineStart := 0</body></methods><methods><class-id>Refactory.Browser.RBFormatter</class-id> <category>copying</category><body package="Browser-Parser" selector="postCopy">postCopy	super postCopy.	lineStart := self lineLength negated.	codeStream := WriteStream on: (String new: 60).	firstLineLength := nil</body></methods><methods><class-id>Refactory.Browser.RBFormatter</class-id> <category>testing</category><body package="Browser-Parser" selector="startMessageSendOnNewLine:">startMessageSendOnNewLine: aMessageNode 	(self selectorsToStartOnNewLine includes: aMessageNode selector) 		ifTrue: [^true].	(self selectorsToLeaveOnLine includes: aMessageNode selector) 		ifTrue: [^false].	^aMessageNode selector numArgs &gt; self maximumArgumentsPerLine</body><body package="Browser-Parser" selector="tagBeforeTemporaries">tagBeforeTemporaries	^RBParser isVisualWorks</body></methods><methods><class-id>Refactory.Browser.RBFormatter</class-id> <category>visiting</category><body package="Browser-Parser" selector="visitNode:">visitNode: aNode 	| parenthesis |	parenthesis := self needsParenthesisFor: aNode.	parenthesis ifTrue: [codeStream nextPut: $(].	aNode acceptVisitor: self.	parenthesis ifTrue: [codeStream nextPut: $)]</body></methods><methods><class-id>Refactory.Browser.RBParseTreeRule</class-id> <category>matching</category><body package="Browser-Parser" selector="canMatch:">canMatch: aProgramNode 	^true</body><body package="Browser-Parser" selector="foundMatchFor:">foundMatchFor: aProgramNode	^aProgramNode</body><body package="Browser-Parser" selector="performOn:">performOn: aProgramNode 	self context empty.	^((searchTree match: aProgramNode inContext: self context) 		and: [self canMatch: aProgramNode]) 			ifTrue: 				[owner recursivelySearchInContext.				self foundMatchFor: aProgramNode]			ifFalse: [nil]</body></methods><methods><class-id>Refactory.Browser.RBParseTreeRule</class-id> <category>private</category><body package="Browser-Parser" selector="context">context	^owner context</body></methods><methods><class-id>Refactory.Browser.RBParseTreeRule</class-id> <category>initialize-release</category><body package="Browser-Parser" selector="initialize">initialize</body><body package="Browser-Parser" selector="methodSearchString:">methodSearchString: aString 	searchTree := RBParser parseRewriteMethod: aString</body><body package="Browser-Parser" selector="owner:">owner: aParseTreeSearcher	owner := aParseTreeSearcher</body><body package="Browser-Parser" selector="searchString:">searchString: aString 	searchTree := RBParser parseRewriteExpression: aString</body></methods><methods><class-id>Refactory.Browser.RBParseTreeRule</class-id> <category>accessing</category><body package="Browser-Parser" selector="sentMessages">sentMessages	^searchTree sentMessages</body></methods><methods><class-id>Refactory.Browser.RBParseTreeRule class</class-id> <category>instance creation</category><body package="Browser-Parser" selector="methodSearch:">methodSearch: aString 	^(self new)		methodSearchString: aString;		yourself</body><body package="Browser-Parser" selector="new">new	^(super new)		initialize;		yourself</body><body package="Browser-Parser" selector="search:">search: aString 	^(self new)		searchString: aString;		yourself</body></methods><methods><class-id>Refactory.Browser.RBSearchRule</class-id> <category>testing</category><body package="Browser-Parser" selector="canMatch:">canMatch: aProgramNode 	owner answer: (answerBlock value: aProgramNode value: owner answer).	^true</body></methods><methods><class-id>Refactory.Browser.RBSearchRule</class-id> <category>initialize-release</category><body package="Browser-Parser" selector="searchFor:thenDo:">searchFor: aString thenDo: aBlock 	self searchString: aString.	answerBlock := aBlock</body><body package="Browser-Parser" selector="searchForMethod:thenDo:">searchForMethod: aString thenDo: aBlock 	self methodSearchString: aString.	answerBlock := aBlock</body><body package="Browser-Parser" selector="searchForTree:thenDo:">searchForTree: aBRProgramNode thenDo: aBlock 	searchTree := aBRProgramNode.	answerBlock := aBlock</body></methods><methods><class-id>Refactory.Browser.RBSearchRule class</class-id> <category>instance creation</category><body package="Browser-Parser" selector="searchFor:thenDo:">searchFor: aString thenDo: aBlock 	^self new searchFor: aString thenDo: aBlock</body><body package="Browser-Parser" selector="searchForMethod:thenDo:">searchForMethod: aString thenDo: aBlock 	^self new searchForMethod: aString thenDo: aBlock</body><body package="Browser-Parser" selector="searchForTree:thenDo:">searchForTree: aBRProgramNode thenDo: aBlock 	^self new searchForTree: aBRProgramNode thenDo: aBlock</body></methods><methods><class-id>Refactory.Browser.RBReplaceRule</class-id> <category>matching</category><body package="Browser-Parser" selector="canMatch:">canMatch: aProgramNode 	^verificationBlock value: aProgramNode</body><body package="Browser-Parser" selector="foundMatchFor:">foundMatchFor: aProgramNode 	self subclassResponsibility</body><body package="Browser-Parser" selector="replace:with:">replace: aProgramNode with: newNode 	aProgramNode replaceMethodSource: newNode</body></methods><methods><class-id>Refactory.Browser.RBReplaceRule</class-id> <category>initialize-release</category><body package="Browser-Parser" selector="initialize">initialize	super initialize.	verificationBlock := [:aNode | true]</body></methods><methods><class-id>Refactory.Browser.RBStringReplaceRule</class-id> <category>initialize-release</category><body package="Browser-Parser" selector="methodReplaceString:">methodReplaceString: replaceString 	replaceTree := RBParser parseRewriteMethod: replaceString</body><body package="Browser-Parser" selector="replaceString:">replaceString: replaceString 	replaceTree := RBParser parseRewriteExpression: replaceString.	searchTree isSequence = replaceTree isSequence 		ifFalse: 			[searchTree isSequence 				ifTrue: [replaceTree := RBSequenceNode statements: (Array with: replaceTree)]				ifFalse: [searchTree := RBSequenceNode statements: (Array with: searchTree)]]</body><body package="Browser-Parser" selector="searchFor:replaceWith:">searchFor: searchString replaceWith: replaceString 	self searchString: searchString.	self replaceString: replaceString</body><body package="Browser-Parser" selector="searchFor:replaceWith:when:">searchFor: searchString replaceWith: replaceString when: aBlock 	self searchFor: searchString replaceWith: replaceString.	verificationBlock := aBlock</body><body package="Browser-Parser" selector="searchForMethod:replaceWith:">searchForMethod: searchString replaceWith: replaceString 	self methodSearchString: searchString.	self methodReplaceString: replaceString</body><body package="Browser-Parser" selector="searchForMethod:replaceWith:when:">searchForMethod: searchString replaceWith: replaceString when: aBlock 	self searchForMethod: searchString replaceWith: replaceString.	verificationBlock := aBlock</body><body package="Browser-Parser" selector="searchForTree:replaceWith:">searchForTree: aBRProgramNode replaceWith: replaceNode 	searchTree := aBRProgramNode.	replaceTree := replaceNode</body><body package="Browser-Parser" selector="searchForTree:replaceWith:when:">searchForTree: aBRProgramNode replaceWith: replaceString when: aBlock 	self searchForTree: aBRProgramNode replaceWith: replaceString.	verificationBlock := aBlock</body></methods><methods><class-id>Refactory.Browser.RBStringReplaceRule</class-id> <category>matching</category><body package="Browser-Parser" selector="foundMatchFor:">foundMatchFor: aProgramNode 	| newNode |	newNode := replaceTree copyInContext: self context.	aProgramNode replaceMethodSource: newNode.	newNode copyCommentsFrom: aProgramNode.	^newNode</body></methods><methods><class-id>Refactory.Browser.RBStringReplaceRule class</class-id> <category>instance creation</category><body package="Browser-Parser" selector="searchFor:replaceWith:">searchFor: searchString replaceWith: replaceString 	^self new searchFor: searchString replaceWith: replaceString</body><body package="Browser-Parser" selector="searchFor:replaceWith:when:">searchFor: searchString replaceWith: replaceString when: aBlock 	^self new 		searchFor: searchString		replaceWith: replaceString		when: aBlock</body><body package="Browser-Parser" selector="searchForMethod:replaceWith:">searchForMethod: searchString replaceWith: replaceString 	^(self new)		searchForMethod: searchString replaceWith: replaceString;		yourself</body><body package="Browser-Parser" selector="searchForMethod:replaceWith:when:">searchForMethod: searchString replaceWith: replaceString when: aBlock 	^self new 		searchForMethod: searchString		replaceWith: replaceString		when: aBlock</body><body package="Browser-Parser" selector="searchForTree:replaceWith:">searchForTree: aRBProgramNode replaceWith: replaceString 	^self new searchForTree: aRBProgramNode replaceWith: replaceString</body><body package="Browser-Parser" selector="searchForTree:replaceWith:when:">searchForTree: aRBProgramNode replaceWith: replaceString when: aBlock 	^self new 		searchForTree: aRBProgramNode		replaceWith: replaceString		when: aBlock</body></methods><methods><class-id>Refactory.Browser.RBBlockReplaceRule</class-id> <category>initialize-release</category><body package="Browser-Parser" selector="initialize">initialize	super initialize.	replaceBlock := [:aNode | aNode]</body><body package="Browser-Parser" selector="searchFor:replaceWith:">searchFor: searchString replaceWith: aBlock 	self searchString: searchString.	replaceBlock := aBlock</body><body package="Browser-Parser" selector="searchFor:replaceWith:when:">searchFor: searchString replaceWith: replBlock when: verifyBlock 	self searchFor: searchString replaceWith: replBlock.	verificationBlock := verifyBlock</body><body package="Browser-Parser" selector="searchForMethod:replaceWith:">searchForMethod: searchString replaceWith: aBlock 	self methodSearchString: searchString.	replaceBlock := aBlock</body><body package="Browser-Parser" selector="searchForMethod:replaceWith:when:">searchForMethod: searchString replaceWith: replBlock when: verifyBlock 	self searchForMethod: searchString replaceWith: replBlock.	verificationBlock := verifyBlock</body><body package="Browser-Parser" selector="searchForTree:replaceWith:">searchForTree: aBRProgramNode replaceWith: aBlock 	searchTree := aBRProgramNode.	replaceBlock := aBlock</body><body package="Browser-Parser" selector="searchForTree:replaceWith:when:">searchForTree: aBRProgramNode replaceWith: replBlock when: verifyBlock 	self searchForTree: aBRProgramNode replaceWith: replBlock.	verificationBlock := verifyBlock</body></methods><methods><class-id>Refactory.Browser.RBBlockReplaceRule</class-id> <category>matching</category><body package="Browser-Parser" selector="foundMatchFor:">foundMatchFor: aProgramNode 	| newNode |	newNode := replaceBlock value: aProgramNode.	aProgramNode replaceMethodSource: newNode.	^newNode</body></methods><methods><class-id>Refactory.Browser.RBBlockReplaceRule class</class-id> <category>instance creation</category><body package="Browser-Parser" selector="searchFor:replaceWith:">searchFor: searchString replaceWith: replaceBlock 	^self new searchFor: searchString replaceWith: replaceBlock</body><body package="Browser-Parser" selector="searchFor:replaceWith:when:">searchFor: searchString replaceWith: replaceBlock when: aBlock 	^self new 		searchFor: searchString		replaceWith: replaceBlock		when: aBlock</body><body package="Browser-Parser" selector="searchForMethod:replaceWith:">searchForMethod: searchString replaceWith: replaceBlock 	^self new searchForMethod: searchString replaceWith: replaceBlock</body><body package="Browser-Parser" selector="searchForMethod:replaceWith:when:">searchForMethod: searchString replaceWith: replaceBlock when: aBlock 	^self new 		searchForMethod: searchString		replaceWith: replaceBlock		when: aBlock</body><body package="Browser-Parser" selector="searchForTree:replaceWith:">searchForTree: aRBProgramNode replaceWith: replaceBlock 	^self new searchForTree: aRBProgramNode replaceWith: replaceBlock</body><body package="Browser-Parser" selector="searchForTree:replaceWith:when:">searchForTree: aRBProgramNode replaceWith: replaceBlock when: aBlock 	^self new 		searchForTree: aRBProgramNode		replaceWith: replaceBlock		when: aBlock</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>visitor</category><body package="Browser-Parser" selector="acceptVisitor:">acceptVisitor: aProgramNodeVisitor 	self subclassResponsibility</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>accessing</category><body package="Browser-Parser" selector="allArgumentVariables">allArgumentVariables	| children |	children := self children.	children isEmpty ifTrue: [^#()].	^children inject: OrderedCollection new		into: 			[:vars :each | 			vars				addAll: each allArgumentVariables;				yourself]</body><body package="Browser-Parser" selector="allDefinedVariables">allDefinedVariables	| children |	children := self children.	children isEmpty ifTrue: [^#()].	^children inject: OrderedCollection new		into: 			[:vars :each | 			vars				addAll: each allDefinedVariables;				yourself]</body><body package="Browser-Parser" selector="allTemporaryVariables">allTemporaryVariables	| children |	children := self children.	children isEmpty ifTrue: [^#()].	^children inject: OrderedCollection new		into: 			[:vars :each | 			vars				addAll: each allTemporaryVariables;				yourself]</body><body package="Browser-Parser" selector="asReturn">asReturn	"Change the current node to a return node."	parent isNil 		ifTrue: [self error: (#CannotChangeWithoutParent &lt;&lt; #browser &gt;&gt; 'Cannot change to a return without a parent node.')].	parent isSequence 		ifFalse: [self error: (#ParentMustBeSequence &lt;&lt; #browser &gt;&gt; 'Parent node must be a sequence node.')].	(parent isLast: self) ifFalse: [self error: (#ReturnNodeMustBeLast &lt;&lt; #browser &gt;&gt; 'Return node must be last.')].	^parent addReturn</body><body package="Browser-Parser" selector="blockVariables">blockVariables	^parent isNil ifTrue: [#()] ifFalse: [parent blockVariables]</body><body package="Browser-Parser" selector="children">children	^#()</body><body package="Browser-Parser" selector="comments">comments	^comments isNil ifTrue: [#()] ifFalse: [comments]</body><body package="Browser-Parser" selector="comments:">comments: aCollection	comments := aCollection</body><body package="Browser-Parser" selector="formattedCode">formattedCode	^self formatterClass new format: self</body><body package="Browser-Parser" selector="formatterClass">formatterClass	^self class formatterClass</body><body package="Browser-Parser" selector="mappingFor:">mappingFor: aNode	| method |	method := self methodNode.	method isNil ifTrue: [^aNode].	^method mappingFor: aNode</body><body package="Browser-Parser" selector="methodComments">methodComments	^self comments</body><body package="Browser-Parser" selector="methodNode">methodNode	^parent isNil ifTrue: [nil] ifFalse: [parent methodNode]</body><body package="Browser-Parser" selector="newSource">newSource	^self formattedCode</body><body package="Browser-Parser" selector="parent">parent	^parent</body><body package="Browser-Parser" selector="parent:">parent: aRBProgramNode 	parent := aRBProgramNode</body><body package="Browser-Parser" selector="precedence">precedence	^6</body><body package="Browser-Parser" selector="sentMessages">sentMessages	| messages |	messages := Set new.	self children do: [:each | messages addAll: each sentMessages].	^messages</body><body package="Browser-Parser" selector="source">source	^parent notNil ifTrue: [parent source] ifFalse: [nil]</body><body package="Browser-Parser" selector="sourceInterval">sourceInterval	^self start to: self stop</body><body package="Browser-Parser" selector="start">start	self subclassResponsibility</body><body package="Browser-Parser" selector="statementComments">statementComments	| statementComments |	statementComments := OrderedCollection withAll: self comments.	self children do: [:each | statementComments addAll: each statementComments].	^statementComments asSortedCollection: [:a :b | a first &lt; b first]</body><body package="Browser-Parser" selector="stop">stop	self subclassResponsibility</body><body package="Browser-Parser" selector="temporaryVariables">temporaryVariables	^parent isNil ifTrue: [#()] ifFalse: [parent temporaryVariables]</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>testing</category><body package="Browser-Parser" selector="assigns:">assigns: aVariableName 	^self children anySatisfy: [:each | each assigns: aVariableName]</body><body package="Browser-Parser" selector="containedBy:">containedBy: anInterval 	^anInterval first &lt;= self start and: [anInterval last &gt;= self stop]</body><body package="Browser-Parser" selector="containsReturn">containsReturn	^self children anySatisfy: [:each | each containsReturn]</body><body package="Browser-Parser" selector="defines:">defines: aName	^false</body><body package="Browser-Parser" selector="directlyUses:">directlyUses: aNode	^true</body><body package="Browser-Parser" selector="evaluatedFirst:">evaluatedFirst: aNode 	self children do: 			[:each | 			each == aNode ifTrue: [^true].			each isImmediateNode ifFalse: [^false]].	^false</body><body package="Browser-Parser" selector="intersectsInterval:">intersectsInterval: anInterval 	^(anInterval first between: self start and: self stop) 		or: [self start between: anInterval first and: anInterval last]</body><body package="Browser-Parser" selector="isAssignment">isAssignment	^false</body><body package="Browser-Parser" selector="isBlock">isBlock	^false</body><body package="Browser-Parser" selector="isCascade">isCascade	^false</body><body package="Browser-Parser" selector="isDirectlyUsed">isDirectlyUsed	"This node is directly used as an argument, receiver, or part of an assignment."	^parent isNil ifTrue: [false] ifFalse: [parent directlyUses: self]</body><body package="Browser-Parser" selector="isEvaluatedFirst">isEvaluatedFirst	"Return true if we are the first thing evaluated in this statement."	^parent isNil or: [parent isSequence or: [parent evaluatedFirst: self]]</body><body package="Browser-Parser" selector="isImmediateNode">isImmediateNode	^false</body><body package="Browser-Parser" selector="isLast:">isLast: aNode 	| children |	children := self children.	^children notEmpty and: [children last == aNode]</body><body package="Browser-Parser" selector="isLiteralArray">isLiteralArray	^false</body><body package="Browser-Parser" selector="isLiteralNode">isLiteralNode	^false</body><body package="Browser-Parser" selector="isMessage">isMessage	^false</body><body package="Browser-Parser" selector="isMethod">isMethod	^false</body><body package="Browser-Parser" selector="isReturn">isReturn	^false</body><body package="Browser-Parser" selector="isSequence">isSequence	^false</body><body package="Browser-Parser" selector="isUsed">isUsed	"Answer true if this node could be used as part of another expression. For example, you could use the 	result of this node as a receiver of a message, an argument, the right part of an assignment, or the 	return value of a block. This differs from isDirectlyUsed in that it is conservative since it also includes 	return values of blocks."	^parent isNil ifTrue: [false] ifFalse: [parent uses: self]</body><body package="Browser-Parser" selector="isValue">isValue	^false</body><body package="Browser-Parser" selector="isVariable">isVariable	^false</body><body package="Browser-Parser" selector="lastIsReturn">lastIsReturn	^self isReturn</body><body package="Browser-Parser" selector="references:">references: aVariableName 	^self children anySatisfy: [:each | each references: aVariableName]</body><body package="Browser-Parser" selector="uses:">uses: aNode	^true</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>querying</category><body package="Browser-Parser" selector="bestNodeFor:">bestNodeFor: anInterval 	| selectedChildren |	(self intersectsInterval: anInterval) ifFalse: [^nil].	(self containedBy: anInterval) ifTrue: [^self].	selectedChildren := self children 				select: [:each | each intersectsInterval: anInterval].	^selectedChildren size == 1 		ifTrue: [selectedChildren first bestNodeFor: anInterval]		ifFalse: [self]</body><body package="Browser-Parser" selector="selfMessages">selfMessages	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: 'self `@msg: ``@args'		do: 			[:aNode :answer | 			answer				add: aNode selector;				yourself].	^searcher executeTree: self initialAnswer: Set new</body><body package="Browser-Parser" selector="statementNode">statementNode	"Return your topmost node that is contained by a sequence node."	(parent isNil or: [parent isSequence]) ifTrue: [^self].	^parent statementNode</body><body package="Browser-Parser" selector="superMessages">superMessages	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: 'super `@msg: ``@args'		do: 			[:aNode :answer | 			answer				add: aNode selector;				yourself].	^searcher executeTree: self initialAnswer: Set new</body><body package="Browser-Parser" selector="whichNodeIsContainedBy:">whichNodeIsContainedBy: anInterval 	| selectedChildren |	(self intersectsInterval: anInterval) ifFalse: [^nil].	(self containedBy: anInterval) ifTrue: [^self].	selectedChildren := self children 				select: [:each | each intersectsInterval: anInterval].	^selectedChildren size == 1 		ifTrue: [selectedChildren first whichNodeIsContainedBy: anInterval]		ifFalse: [nil]</body><body package="Browser-Parser" selector="whoDefines:">whoDefines: aName 	^(self defines: aName) 		ifTrue: [self]		ifFalse: [parent notNil ifTrue: [parent whoDefines: aName] ifFalse: [nil]]</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>meta variable-accessing</category><body package="Browser-Parser" selector="cascadeListCharacter">cascadeListCharacter	^$;</body><body package="Browser-Parser" selector="listCharacter">listCharacter	^$@</body><body package="Browser-Parser" selector="literalCharacter">literalCharacter	^$#</body><body package="Browser-Parser" selector="recurseIntoCharacter">recurseIntoCharacter	^$`</body><body package="Browser-Parser" selector="statementCharacter">statementCharacter	^$.</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>enumeration</category><body package="Browser-Parser" selector="collect:">collect: aBlock 	"Hacked to fit collection protocols"	^aBlock value: self</body><body package="Browser-Parser" selector="do:">do: aBlock 	"Hacked to fit collection protocols"	aBlock value: self</body><body package="Browser-Parser" selector="size">size	"Hacked to fit collection protocols"	^1</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>copying</category><body package="Browser-Parser" selector="copyCommentsFrom:">copyCommentsFrom: aNode 	"Add all comments from aNode to us. If we already have the comment, then don't add it."	| newComments |	newComments := OrderedCollection new.	aNode nodesDo: [:each | newComments addAll: each comments].	self nodesDo: 			[:each | 			each comments do: [:comment | newComments remove: comment ifAbsent: []]].	newComments isEmpty ifTrue: [^self].	newComments := newComments asSortedCollection: [:a :b | a first &lt; b first].	self comments: newComments</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>matching</category><body package="Browser-Parser" selector="copyInContext:">copyInContext: aDictionary	^self copy</body><body package="Browser-Parser" selector="copyList:inContext:">copyList: matchNodes inContext: aDictionary 	| newNodes |	newNodes := OrderedCollection new.	matchNodes do: 			[:each | 			| object |			object := each copyInContext: aDictionary.			newNodes addAll: object].	^newNodes</body><body package="Browser-Parser" selector="match:inContext:">match: aNode inContext: aDictionary 	^self = aNode</body><body package="Browser-Parser" selector="matchList:against:inContext:">matchList: matchNodes against: programNodes inContext: aDictionary 	^self		matchList: matchNodes		index: 1		against: programNodes		index: 1		inContext: aDictionary</body><body package="Browser-Parser" selector="matchList:index:against:index:inContext:">matchList: matchNodes index: matchIndex against: programNodes index: programIndex inContext: aDictionary 	| node currentIndex currentDictionary nodes |	matchNodes size &lt; matchIndex ifTrue: [^programNodes size &lt; programIndex].	node := matchNodes at: matchIndex.	node isList 		ifTrue: 			[currentIndex := programIndex - 1.						[currentDictionary := aDictionary copy.			programNodes size &lt; currentIndex or: 					[nodes := programNodes copyFrom: programIndex to: currentIndex.					(currentDictionary at: node ifAbsentPut: [nodes]) = nodes and: 							[(self 								matchList: matchNodes								index: matchIndex + 1								against: programNodes								index: currentIndex + 1								inContext: currentDictionary) 									ifTrue: 										[currentDictionary 											keysAndValuesDo: [:key :value | aDictionary at: key put: value].										^true].							false]]] 					whileFalse: [currentIndex := currentIndex + 1].			^false].	programNodes size &lt; programIndex ifTrue: [^false].	(node match: (programNodes at: programIndex) inContext: aDictionary) 		ifFalse: [^false].	^self 		matchList: matchNodes		index: matchIndex + 1		against: programNodes		index: programIndex + 1		inContext: aDictionary</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>comparing</category><body package="Browser-Parser" selector="equalTo:exceptForVariables:">equalTo: aNode exceptForVariables: variableNameCollection 	| dictionary |	dictionary := Dictionary new.	(self equalTo: aNode withMapping: dictionary) ifFalse: [^false].	dictionary keysAndValuesDo: 			[:key :value | 			(key = value or: [variableNameCollection includes: key]) ifFalse: [^false]].	^true</body><body package="Browser-Parser" selector="equalTo:withMapping:">equalTo: aNode withMapping: aDictionary 	^self = aNode</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>testing-matching</category><body package="Browser-Parser" selector="canMatchMethod:">canMatchMethod: aCompiledMethod 	^self sentMessages allSatisfy: 			[:each | 			(self class optimizedSelectors includes: each) 				or: [aCompiledMethod refersToLiteral: each]]</body><body package="Browser-Parser" selector="isList">isList	^false</body><body package="Browser-Parser" selector="isPatternNode">isPatternNode	^false</body><body package="Browser-Parser" selector="recurseInto">recurseInto	^false</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>iterating</category><body package="Browser-Parser" selector="nodesDo:">nodesDo: aBlock 	aBlock value: self.	self children do: [:each | each nodesDo: aBlock]</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>printing</category><body package="Browser-Parser" selector="printOn:">printOn: aStream 	aStream		nextPutAll: self class fullName;		nextPut: $(;		nextPutAll: self formattedCode;		nextPut: $)</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>replacing</category><body package="Browser-Parser" selector="addReplacement:">addReplacement: aStringReplacement	parent isNil ifTrue: [^self].	parent addReplacement: aStringReplacement</body><body package="Browser-Parser" selector="clearReplacements">clearReplacements	parent isNil ifTrue: [^self].	parent clearReplacements</body><body package="Browser-Parser" selector="removeDeadCode">removeDeadCode	self children do: [:each | each removeDeadCode]</body><body package="Browser-Parser" selector="replaceMethodSource:">replaceMethodSource: aNode 	"We are being replaced with aNode -- if possible try to perform an in place edit of the source."	| method |	method := self methodNode.	method notNil ifTrue: [method map: self to: aNode].	aNode parent: self parent.	[self replaceSourceWith: aNode] on: Error		do: 			[:ex | 			self clearReplacements.			ex return]</body><body package="Browser-Parser" selector="replaceNode:withNode:">replaceNode: aNode withNode: anotherNode 	self error: (#IDontStoreOtherNodes &lt;&lt; #browser &gt;&gt; 'I don''t store other nodes')</body><body package="Browser-Parser" selector="replaceWith:">replaceWith: aNode 	parent isNil ifTrue: [self error: (#ThisNodeHasNoParent &lt;&lt; #browser &gt;&gt; 'This node doesn''t have a parent')].	self replaceMethodSource: aNode.	parent replaceNode: self withNode: aNode</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>private-replacing</category><body package="Browser-Parser" selector="replaceSourceFrom:">replaceSourceFrom: aNode 	self clearReplacements</body><body package="Browser-Parser" selector="replaceSourceWith:">replaceSourceWith: aNode 	aNode replaceSourceFrom: self</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>deprecated</category><body package="Browser-Parser" selector="isImmediate">isImmediate	^self isImmediateNode</body><body package="Browser-Parser" selector="isLiteral">isLiteral	^self isLiteralNode</body></methods><methods><class-id>Refactory.Browser.RBProgramNode class</class-id> <category>accessing</category><body package="Browser-Parser" selector="formatterClass">formatterClass	^FormatterClass isNil ifTrue: [RBFormatter] ifFalse: [FormatterClass]</body><body package="Browser-Parser" selector="formatterClass:">formatterClass: aClass 	FormatterClass := aClass</body><body package="Browser-Parser" selector="optimizedSelectors">optimizedSelectors	^#(#ifTrue: #ifTrue:ifFalse: #ifFalse: #ifFalse:ifTrue: #whileTrue: #whileTrue #whileFalse: #whileFalse #to:do: #to:by:do: #and: #or: #repeat #timesRepeat:)</body></methods><methods><class-id>Refactory.Browser.RBReturnNode</class-id> <category>comparing</category><body package="Browser-Parser" selector="=">= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	^self value = anObject value</body><body package="Browser-Parser" selector="equalTo:withMapping:">equalTo: anObject withMapping: aDictionary 	^self class = anObject class 		and: [self value equalTo: anObject value withMapping: aDictionary]</body><body package="Browser-Parser" selector="hash">hash	^self value hash</body></methods><methods><class-id>Refactory.Browser.RBReturnNode</class-id> <category>visitor</category><body package="Browser-Parser" selector="acceptVisitor:">acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptReturnNode: self</body></methods><methods><class-id>Refactory.Browser.RBReturnNode</class-id> <category>accessing</category><body package="Browser-Parser" selector="children">children	^Array with: value</body><body package="Browser-Parser" selector="start">start	^return</body><body package="Browser-Parser" selector="stop">stop	^value stop</body><body package="Browser-Parser" selector="value">value	^value</body><body package="Browser-Parser" selector="value:">value: valueNode 	value := valueNode.	value parent: self</body></methods><methods><class-id>Refactory.Browser.RBReturnNode</class-id> <category>testing</category><body package="Browser-Parser" selector="containsReturn">containsReturn	^true</body><body package="Browser-Parser" selector="isReturn">isReturn	^true</body></methods><methods><class-id>Refactory.Browser.RBReturnNode</class-id> <category>matching</category><body package="Browser-Parser" selector="copyInContext:">copyInContext: aDictionary 	^(self class new)		value: (value copyInContext: aDictionary);		yourself</body><body package="Browser-Parser" selector="match:inContext:">match: aNode inContext: aDictionary 	aNode class == self class ifFalse: [^false].	^value match: aNode value inContext: aDictionary</body></methods><methods><class-id>Refactory.Browser.RBReturnNode</class-id> <category>copying</category><body package="Browser-Parser" selector="postCopy">postCopy	super postCopy.	value := value copy</body></methods><methods><class-id>Refactory.Browser.RBReturnNode</class-id> <category>replacing</category><body package="Browser-Parser" selector="replaceNode:withNode:">replaceNode: aNode withNode: anotherNode 	value == aNode ifTrue: [self value: anotherNode]</body></methods><methods><class-id>Refactory.Browser.RBReturnNode</class-id> <category>initialize-release</category><body package="Browser-Parser" selector="return:value:">return: returnInteger value: aValueNode 	return := returnInteger.	self value: aValueNode</body></methods><methods><class-id>Refactory.Browser.RBReturnNode class</class-id> <category>instance creation</category><body package="Browser-Parser" selector="return:value:">return: returnInteger value: aValueNode 	^self new return: returnInteger value: aValueNode</body><body package="Browser-Parser" selector="value:">value: aNode	^self return: nil value: aNode</body></methods><methods><class-id>Refactory.Browser.RBValueNode</class-id> <category>accessing</category><body package="Browser-Parser" selector="addParenthesis:">addParenthesis: anInterval 	parentheses isNil ifTrue: [parentheses := OrderedCollection new: 1].	parentheses add: anInterval</body><body package="Browser-Parser" selector="parentheses">parentheses	^parentheses isNil ifTrue: [#()] ifFalse: [parentheses]</body><body package="Browser-Parser" selector="start">start	^parentheses isNil 		ifTrue: [self startWithoutParentheses]		ifFalse: [parentheses last first]</body><body package="Browser-Parser" selector="startWithoutParentheses">startWithoutParentheses	^self subclassResponsibility</body><body package="Browser-Parser" selector="stop">stop	^parentheses isNil		ifTrue: [self stopWithoutParentheses]		ifFalse: [parentheses last last]</body><body package="Browser-Parser" selector="stopWithoutParentheses">stopWithoutParentheses	^self subclassResponsibility</body></methods><methods><class-id>Refactory.Browser.RBValueNode</class-id> <category>testing</category><body package="Browser-Parser" selector="containedBy:">containedBy: anInterval 	^anInterval first &lt;= self startWithoutParentheses 		and: [anInterval last &gt;= self stopWithoutParentheses]</body><body package="Browser-Parser" selector="hasParentheses">hasParentheses	^self parentheses notEmpty</body><body package="Browser-Parser" selector="isValue">isValue	^true</body><body package="Browser-Parser" selector="needsParenthesis">needsParenthesis	^self subclassResponsibility</body></methods><methods><class-id>Refactory.Browser.RBCascadeNode</class-id> <category>comparing</category><body package="Browser-Parser" selector="=">= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	self messages size = anObject messages size ifFalse: [^false].	1 to: self messages size		do: [:i | (self messages at: i) = (anObject messages at: i) ifFalse: [^false]].	^true</body><body package="Browser-Parser" selector="equalTo:withMapping:">equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [^false].	self messages size == anObject messages size ifFalse: [^false].	1 to: self messages size		do: 			[:i | 			((self messages at: i) equalTo: (anObject messages at: i)				withMapping: aDictionary) ifFalse: [^false]].	^true</body><body package="Browser-Parser" selector="hash">hash	^self messages hash</body></methods><methods><class-id>Refactory.Browser.RBCascadeNode</class-id> <category>visitor</category><body package="Browser-Parser" selector="acceptVisitor:">acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptCascadeNode: self</body></methods><methods><class-id>Refactory.Browser.RBCascadeNode</class-id> <category>querying</category><body package="Browser-Parser" selector="bestNodeFor:">bestNodeFor: anInterval 	| selectedChildren |	(self intersectsInterval: anInterval) ifFalse: [^nil].	(self containedBy: anInterval) ifTrue: [^self].	messages 		reverseDo: [:each | (each containedBy: anInterval) ifTrue: [^each]].	selectedChildren := (messages 				collect: [:each | each bestNodeFor: anInterval]) 					reject: [:each | each isNil].	^selectedChildren detect: [:each | true] ifNone: [nil]</body><body package="Browser-Parser" selector="whichNodeIsContainedBy:">whichNodeIsContainedBy: anInterval 	| selectedChildren |	(self intersectsInterval: anInterval) ifFalse: [^nil].	(self containedBy: anInterval) ifTrue: [^self].	messages 		reverseDo: [:each | (each containedBy: anInterval) ifTrue: [^each]].	selectedChildren := (messages 				collect: [:each | each whichNodeIsContainedBy: anInterval]) 					reject: [:each | each isNil].	^selectedChildren detect: [:each | true] ifNone: [nil]</body></methods><methods><class-id>Refactory.Browser.RBCascadeNode</class-id> <category>accessing</category><body package="Browser-Parser" selector="children">children	^self messages</body><body package="Browser-Parser" selector="messages">messages	^messages</body><body package="Browser-Parser" selector="messages:">messages: messageNodeCollection 	messages := messageNodeCollection.	messages do: [:each | each parent: self]</body><body package="Browser-Parser" selector="precedence">precedence	^4</body><body package="Browser-Parser" selector="receiver">receiver	^self messages first receiver</body><body package="Browser-Parser" selector="startWithoutParentheses">startWithoutParentheses	^messages first start</body><body package="Browser-Parser" selector="statementComments">statementComments	| statementComments |	statementComments := OrderedCollection withAll: self comments.	statementComments addAll: messages first receiver statementComments.	messages do: 			[:each | 			each arguments 				do: [:arg | statementComments addAll: arg statementComments]].	^statementComments asSortedCollection: [:a :b | a first &lt; b first]</body><body package="Browser-Parser" selector="stopWithoutParentheses">stopWithoutParentheses	^messages last stop</body></methods><methods><class-id>Refactory.Browser.RBCascadeNode</class-id> <category>testing</category><body package="Browser-Parser" selector="directlyUses:">directlyUses: aNode 	^messages last = aNode and: [self isDirectlyUsed]</body><body package="Browser-Parser" selector="isCascade">isCascade	^true</body><body package="Browser-Parser" selector="needsParenthesis">needsParenthesis	^parent isNil 		ifTrue: [false]		ifFalse: [self precedence &gt; parent precedence]</body><body package="Browser-Parser" selector="uses:">uses: aNode 	^messages last = aNode and: [self isUsed]</body></methods><methods><class-id>Refactory.Browser.RBCascadeNode</class-id> <category>initialize-release</category><body package="Browser-Parser" selector="messages:semicolons:">messages: messageNodes semicolons: integerCollection 	self messages: messageNodes.	semicolons := integerCollection</body></methods><methods><class-id>Refactory.Browser.RBCascadeNode</class-id> <category>copying</category><body package="Browser-Parser" selector="postCopy">postCopy	super postCopy.	messages := messages collect: [:each | each copy]</body></methods><methods><class-id>Refactory.Browser.RBCascadeNode</class-id> <category>replacing</category><body package="Browser-Parser" selector="replaceNode:withNode:">replaceNode: aNode withNode: anotherNode 	self messages: (messages 				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])</body></methods><methods><class-id>Refactory.Browser.RBCascadeNode</class-id> <category>matching</category><body package="Browser-Parser" selector="copyInContext:">copyInContext: aDictionary 	^(self class new)		messages: (self copyList: messages inContext: aDictionary);		yourself</body><body package="Browser-Parser" selector="match:inContext:">match: aNode inContext: aDictionary 	aNode class == self class ifFalse: [^false].	^self 		matchList: messages		against: aNode messages		inContext: aDictionary</body></methods><methods><class-id>Refactory.Browser.RBCascadeNode class</class-id> <category>instance creation</category><body package="Browser-Parser" selector="messages:">messages: messageNodes 	^self new messages: messageNodes</body><body package="Browser-Parser" selector="messages:semicolons:">messages: messageNodes semicolons: integerCollection 	^self new messages: messageNodes semicolons: integerCollection</body></methods><methods><class-id>Refactory.Browser.RBOptimizedNode</class-id> <category>comparing</category><body package="Browser-Parser" selector="=">= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	^self body = anObject body</body><body package="Browser-Parser" selector="equalTo:withMapping:">equalTo: anObject withMapping: aDictionary 	^self class = anObject class 		and: [self body equalTo: anObject body withMapping: aDictionary]</body><body package="Browser-Parser" selector="hash">hash	^self body hash</body></methods><methods><class-id>Refactory.Browser.RBOptimizedNode</class-id> <category>visitor</category><body package="Browser-Parser" selector="acceptVisitor:">acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptOptimizedNode: self</body></methods><methods><class-id>Refactory.Browser.RBOptimizedNode</class-id> <category>accessing</category><body package="Browser-Parser" selector="arguments">arguments	^#()</body><body package="Browser-Parser" selector="body">body	^body</body><body package="Browser-Parser" selector="body:">body: stmtsNode 	body := stmtsNode.	body parent: self</body><body package="Browser-Parser" selector="children">children	^Array with: body</body><body package="Browser-Parser" selector="precedence">precedence	^0</body><body package="Browser-Parser" selector="startWithoutParentheses">startWithoutParentheses	^left</body><body package="Browser-Parser" selector="stopWithoutParentheses">stopWithoutParentheses	^right</body></methods><methods><class-id>Refactory.Browser.RBOptimizedNode</class-id> <category>matching</category><body package="Browser-Parser" selector="copyInContext:">copyInContext: aDictionary 	^self class body: (body copyInContext: aDictionary)</body><body package="Browser-Parser" selector="match:inContext:">match: aNode inContext: aDictionary 	aNode class == self class ifFalse: [^false].	^body match: aNode body inContext: aDictionary</body></methods><methods><class-id>Refactory.Browser.RBOptimizedNode</class-id> <category>testing</category><body package="Browser-Parser" selector="isImmediateNode">isImmediateNode	^true</body><body package="Browser-Parser" selector="needsParenthesis">needsParenthesis	^false</body></methods><methods><class-id>Refactory.Browser.RBOptimizedNode</class-id> <category>initialize-release</category><body package="Browser-Parser" selector="left:body:right:">left: leftInteger body: aSequenceNode right: rightInteger 	left := leftInteger.	self body: aSequenceNode.	right := rightInteger</body></methods><methods><class-id>Refactory.Browser.RBOptimizedNode</class-id> <category>replacing</category><body package="Browser-Parser" selector="replaceNode:withNode:">replaceNode: aNode withNode: anotherNode 	body == aNode ifTrue: [self body: anotherNode]</body></methods><methods><class-id>Refactory.Browser.RBOptimizedNode class</class-id> <category>instance creation</category><body package="Browser-Parser" selector="body:">body: aSequenceNode 	^self new body: aSequenceNode</body><body package="Browser-Parser" selector="left:body:right:">left: leftInteger body: aSequenceNode right: rightInteger 	^(self new)		left: leftInteger			body: aSequenceNode			right: rightInteger;		yourself</body></methods><methods><class-id>Refactory.Browser.RBMessageNode</class-id> <category>comparing</category><body package="Browser-Parser" selector="=">= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	(self receiver = anObject receiver 		and: [self selector = anObject selector]) ifFalse: [^false].	1 to: self arguments size		do: [:i | (self arguments at: i) = (anObject arguments at: i) ifFalse: [^false]].	^true</body><body package="Browser-Parser" selector="equalTo:withMapping:">equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [^false].	((self receiver equalTo: anObject receiver withMapping: aDictionary)		and: [self selector = anObject selector]) ifFalse: [^false].	1 to: self arguments size		do: 			[:i | 			((self arguments at: i) equalTo: (anObject arguments at: i)				withMapping: aDictionary) ifFalse: [^false]].	^true</body><body package="Browser-Parser" selector="hash">hash	^(self receiver hash bitXor: self selector hash) 		bitXor: (self arguments isEmpty 				ifTrue: [0]				ifFalse: [self arguments first hash])</body></methods><methods><class-id>Refactory.Browser.RBMessageNode</class-id> <category>visitor</category><body package="Browser-Parser" selector="acceptVisitor:">acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptMessageNode: self</body></methods><methods><class-id>Refactory.Browser.RBMessageNode</class-id> <category>accessing</category><body package="Browser-Parser" selector="arguments">arguments	^arguments isNil ifTrue: [#()] ifFalse: [arguments]</body><body package="Browser-Parser" selector="arguments:">arguments: argCollection 	arguments := argCollection.	arguments do: [:each | each parent: self]</body><body package="Browser-Parser" selector="children">children	^(OrderedCollection with: self receiver)		addAll: self arguments;		yourself</body><body package="Browser-Parser" selector="numArgs">numArgs	^self selector numArgs</body><body package="Browser-Parser" selector="precedence">precedence	^self isUnary 		ifTrue: [1]		ifFalse: [self isKeyword ifTrue: [3] ifFalse: [2]]</body><body package="Browser-Parser" selector="receiver">receiver	^receiver</body><body package="Browser-Parser" selector="receiver:">receiver: aValueNode 	receiver := aValueNode.	receiver parent: self</body><body package="Browser-Parser" selector="renameSelector:andArguments:">renameSelector: newSelector andArguments: varNodeCollection 	self		arguments: varNodeCollection;		selector: newSelector</body><body package="Browser-Parser" selector="selector">selector	^selector isNil		ifTrue: [selector := self buildSelector]		ifFalse: [selector]</body><body package="Browser-Parser" selector="selector:">selector: aSelector 	| keywords numArgs |	keywords := aSelector keywords.	numArgs := aSelector numArgs.	numArgs == arguments size 		ifFalse: 			[self 				error: (#AssignmentWithWrongArgNumber &lt;&lt; #browser &gt;&gt; 'Attempting to assign selector with wrong number of arguments.')].	selectorParts := numArgs == 0 				ifTrue: [Array with: (RBIdentifierToken value: keywords first start: nil)]				ifFalse: 					[keywords first last == $: 						ifTrue: [keywords collect: [:each | RBKeywordToken value: each start: nil]]						ifFalse: [Array with: (RBBinarySelectorToken value: aSelector start: nil)]].	selector := aSelector</body><body package="Browser-Parser" selector="sentMessages">sentMessages	^(super sentMessages)		add: self selector;		yourself</body><body package="Browser-Parser" selector="startWithoutParentheses">startWithoutParentheses	^receiver start</body><body package="Browser-Parser" selector="stopWithoutParentheses">stopWithoutParentheses	^arguments isEmpty 		ifTrue: [selectorParts first stop]		ifFalse: [arguments last stop]</body></methods><methods><class-id>Refactory.Browser.RBMessageNode</class-id> <category>querying</category><body package="Browser-Parser" selector="bestNodeFor:">bestNodeFor: anInterval 	(self intersectsInterval: anInterval) ifFalse: [^nil].	(self containedBy: anInterval) ifTrue: [^self].	selectorParts do: 			[:each | 			((anInterval first between: each start and: each stop) 				or: [each start between: anInterval first and: anInterval last]) 					ifTrue: [^self]].	self children do: 			[:each | 			| node |			node := each bestNodeFor: anInterval.			node notNil ifTrue: [^node]]</body></methods><methods><class-id>Refactory.Browser.RBMessageNode</class-id> <category>private</category><body package="Browser-Parser" selector="buildSelector">buildSelector	| selectorStream |	selectorStream := WriteStream on: (String new: 50).	selectorParts do: [:each | selectorStream nextPutAll: each value].	^selectorStream contents asSymbol</body><body package="Browser-Parser" selector="selectorParts">selectorParts	^selectorParts</body><body package="Browser-Parser" selector="selectorParts:">selectorParts: tokenCollection 	selectorParts := tokenCollection</body></methods><methods><class-id>Refactory.Browser.RBMessageNode</class-id> <category>testing</category><body package="Browser-Parser" selector="isBinary">isBinary	^(self isUnary or: [self isKeyword]) not</body><body package="Browser-Parser" selector="isCascaded">isCascaded	^parent notNil and: [parent isCascade]</body><body package="Browser-Parser" selector="isFirstCascaded">isFirstCascaded	^self isCascaded and: [parent messages first == self]</body><body package="Browser-Parser" selector="isKeyword">isKeyword	^selectorParts first value last == $:</body><body package="Browser-Parser" selector="isMessage">isMessage	^true</body><body package="Browser-Parser" selector="isUnary">isUnary	^arguments isEmpty</body><body package="Browser-Parser" selector="lastIsReturn">lastIsReturn	^(#(#ifTrue:ifFalse: #ifFalse:ifTrue:) includes: self selector) and: 			[arguments first isBlock and: 					[arguments first body lastIsReturn						and: [arguments last isBlock and: [arguments last body lastIsReturn]]]]</body><body package="Browser-Parser" selector="needsParenthesis">needsParenthesis	^parent isNil 		ifTrue: [false]		ifFalse: 			[self precedence &gt; parent precedence 				or: [self precedence = parent precedence and: [self isUnary not]]]</body></methods><methods><class-id>Refactory.Browser.RBMessageNode</class-id> <category>matching</category><body package="Browser-Parser" selector="copyInContext:">copyInContext: aDictionary 	^(self class new)		receiver: (receiver copyInContext: aDictionary);		selectorParts: (selectorParts collect: [:each | each removePositions]);		arguments: (arguments collect: [:each | each copyInContext: aDictionary]);		yourself</body><body package="Browser-Parser" selector="match:inContext:">match: aNode inContext: aDictionary 	aNode class == self class ifFalse: [^false].	self selector == aNode selector ifFalse: [^false].	(receiver match: aNode receiver inContext: aDictionary) ifFalse: [^false].	1 to: arguments size		do: 			[:i | 			((arguments at: i) match: (aNode arguments at: i) inContext: aDictionary)				ifFalse: [^false]].	^true</body></methods><methods><class-id>Refactory.Browser.RBMessageNode</class-id> <category>copying</category><body package="Browser-Parser" selector="postCopy">postCopy	super postCopy.	receiver := receiver copy.	arguments := arguments collect: [:each | each copy]</body></methods><methods><class-id>Refactory.Browser.RBMessageNode</class-id> <category>initialize-release</category><body package="Browser-Parser" selector="receiver:selectorParts:arguments:">receiver: aValueNode selectorParts: keywordTokens arguments: valueNodes 	self receiver: aValueNode.	selectorParts := keywordTokens.	self arguments: valueNodes</body></methods><methods><class-id>Refactory.Browser.RBMessageNode</class-id> <category>replacing</category><body package="Browser-Parser" selector="replaceNode:withNode:">replaceNode: aNode withNode: anotherNode 	"If we're inside a cascade node and are changing the receiver, change all the receivers"	receiver == aNode 		ifTrue: 			[self receiver: anotherNode.			(parent notNil and: [parent isCascade]) 				ifTrue: [parent messages do: [:each | each receiver: anotherNode]]].	self arguments: (arguments 				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])</body></methods><methods><class-id>Refactory.Browser.RBMessageNode</class-id> <category>private-replacing</category><body package="Browser-Parser" selector="isContainmentReplacement:">isContainmentReplacement: aNode 	^(self mappingFor: self receiver) = aNode 		or: [self arguments anySatisfy: [:each | (self mappingFor: each) = aNode]]</body><body package="Browser-Parser" selector="replaceContainmentSourceWith:">replaceContainmentSourceWith: aNode 	| originalNode needsParenthesis |	needsParenthesis := aNode hasParentheses not and: [aNode needsParenthesis].	originalNode := (self mappingFor: self receiver) = aNode 				ifTrue: [self receiver]				ifFalse: [self arguments detect: [:each | (self mappingFor: each) = aNode]].	self		addReplacement: (RBStringReplacement 					replaceFrom: self start					to: originalNode start - 1					with: (needsParenthesis ifTrue: ['('] ifFalse: ['']));		addReplacement: (RBStringReplacement 					replaceFrom: originalNode stop + 1					to: self stop					with: (needsParenthesis ifTrue: [')'] ifFalse: ['']))</body><body package="Browser-Parser" selector="replaceSourceWith:">replaceSourceWith: aNode 	(self isContainmentReplacement: aNode) 		ifTrue: [^self replaceContainmentSourceWith: aNode].	aNode isMessage ifFalse: [^super replaceSourceWith: aNode].	^self replaceSourceWithMessageNode: aNode</body><body package="Browser-Parser" selector="replaceSourceWithMessageNode:">replaceSourceWithMessageNode: aNode 	| isBinaryToKeyword |	self numArgs = aNode numArgs ifFalse: [^super replaceSourceWith: aNode].	(self mappingFor: self receiver) = aNode receiver 		ifFalse: [^super replaceSourceWith: aNode].	self arguments with: aNode arguments		do: [:old :new | (self mappingFor: old) = new ifFalse: [^super replaceSourceWith: aNode]].	(isBinaryToKeyword := self isBinary and: [aNode isKeyword]) 		ifTrue: 			[(self hasParentheses not and: [self parent precedence &lt;= aNode precedence]) 				ifTrue: 					[self						addReplacement: (RBStringReplacement 									replaceFrom: self start									to: self start - 1									with: '(');						addReplacement: (RBStringReplacement 									replaceFrom: self stop + 1									to: self stop									with: ')')]].	self selectorParts with: aNode selectorParts		do: 			[:old :new | 			old value ~= new value 				ifTrue: 					[self addReplacement: (RBStringReplacement 								replaceFrom: old start								to: old stop								with: ((isBinaryToKeyword 										and: [(self source at: old start - 1) isSeparator not]) 											ifTrue: [' ' , new value]											ifFalse: [new value]))]]</body></methods><methods><class-id>Refactory.Browser.RBMessageNode class</class-id> <category>instance creation</category><body package="Browser-Parser" selector="receiver:selector:">receiver: aValueNode selector: aSymbol 	^self 		receiver: aValueNode		selector: aSymbol		arguments: #()</body><body package="Browser-Parser" selector="receiver:selector:arguments:">receiver: aValueNode selector: aSymbol arguments: valueNodes 	^(self new)		receiver: aValueNode;		arguments: valueNodes;		selector: aSymbol;		yourself</body><body package="Browser-Parser" selector="receiver:selectorParts:arguments:">receiver: aValueNode selectorParts: keywordTokens arguments: valueNodes 	^(self new)		receiver: aValueNode			selectorParts: keywordTokens			arguments: valueNodes;		yourself</body></methods><methods><class-id>Refactory.Browser.RBPatternMessageNode</class-id> <category>matching</category><body package="Browser-Parser" selector="copyInContext:">copyInContext: aDictionary 	| selectors |	self isList ifTrue: [^aDictionary at: self].	selectors := self isSelectorList 				ifTrue: [(aDictionary at: selectorParts first value) keywords]				ifFalse: [selectorParts collect: [:each | aDictionary at: each value]].	^(RBMessageNode new)		receiver: (receiver copyInContext: aDictionary);		selectorParts: (selectors collect: 						[:each | 						(each last == $: ifTrue: [RBKeywordToken] ifFalse: [RBIdentifierToken]) 							value: each							start: nil]);		arguments: (self copyList: arguments inContext: aDictionary);		yourself</body><body package="Browser-Parser" selector="match:inContext:">match: aNode inContext: aDictionary 	aNode class == self matchingClass ifFalse: [^false].	(receiver match: aNode receiver inContext: aDictionary) ifFalse: [^false].	self isSelectorList 		ifTrue: 			[^(aDictionary at: selectorParts first value ifAbsentPut: [aNode selector]) 				== aNode selector and: 						[(aDictionary at: arguments first ifAbsentPut: [aNode arguments]) 							= aNode arguments]].	^self matchArgumentsAgainst: aNode inContext: aDictionary</body><body package="Browser-Parser" selector="matchArgumentsAgainst:inContext:">matchArgumentsAgainst: aNode inContext: aDictionary 	self arguments size == aNode arguments size ifFalse: [^false].	(self matchSelectorAgainst: aNode inContext: aDictionary) 		ifFalse: [^false].	1 to: arguments size		do: 			[:i | 			((arguments at: i) match: (aNode arguments at: i) inContext: aDictionary) 				ifFalse: [^false]].	^true</body><body package="Browser-Parser" selector="matchSelectorAgainst:inContext:">matchSelectorAgainst: aNode inContext: aDictionary 	| keyword |	1 to: selectorParts size		do: 			[:i | 			keyword := selectorParts at: i.			(aDictionary at: keyword value				ifAbsentPut: 					[keyword isPatternVariable 						ifTrue: [(aNode selectorParts at: i) value]						ifFalse: [keyword value]]) 					= (aNode selectorParts at: i) value ifFalse: [^false]].	^true</body></methods><methods><class-id>Refactory.Browser.RBPatternMessageNode</class-id> <category>testing-matching</category><body package="Browser-Parser" selector="isList">isList	^isCascadeList and: [parent notNil and: [parent isCascade]]</body><body package="Browser-Parser" selector="isPatternNode">isPatternNode	^true</body><body package="Browser-Parser" selector="isSelectorList">isSelectorList	^isList</body></methods><methods><class-id>Refactory.Browser.RBPatternMessageNode</class-id> <category>private</category><body package="Browser-Parser" selector="matchingClass">matchingClass	^RBMessageNode</body></methods><methods><class-id>Refactory.Browser.RBPatternMessageNode</class-id> <category>initialize-release</category><body package="Browser-Parser" selector="receiver:selectorParts:arguments:">receiver: aValueNode selectorParts: keywordTokens arguments: valueNodes 	| message |	super 		receiver: aValueNode		selectorParts: keywordTokens		arguments: valueNodes.	isCascadeList := isList := false.	message := keywordTokens first value.	2 to: message size		do: 			[:i | 			| character |			character := message at: i.			character == self listCharacter 				ifTrue: [isList := true]				ifFalse: 					[character == self cascadeListCharacter 						ifTrue: [isCascadeList := true]						ifFalse: [^self]]]</body></methods><methods><class-id>Refactory.Browser.RBPatternMessageNode</class-id> <category>accessing</category><body package="Browser-Parser" selector="sentMessages">sentMessages	^(super sentMessages)		remove: self selector ifAbsent: [];		yourself</body></methods><methods><class-id>Refactory.Browser.RBPatternMessageNode class</class-id> <category>instance creation</category><body package="Browser-Parser" selector="receiver:selectorParts:arguments:">receiver: aValueNode selectorParts: keywordTokens arguments: valueNodes 	^(keywordTokens anySatisfy: [:each | each isPatternVariable]) 		ifTrue: 			[super 				receiver: aValueNode				selectorParts: keywordTokens				arguments: valueNodes]		ifFalse: 			[RBMessageNode 				receiver: aValueNode				selectorParts: keywordTokens				arguments: valueNodes]</body></methods><methods><class-id>Refactory.Browser.RBSequenceNode</class-id> <category>comparing</category><body package="Browser-Parser" selector="=">= anObject 	"Can't send = to the temporaries and statements collection since they might change from arrays to OCs"	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	self temporaries size = anObject temporaries size ifFalse: [^false].	1 to: self temporaries size		do: 			[:i | 			(self temporaries at: i) = (anObject temporaries at: i) ifFalse: [^false]].	self statements size = anObject statements size ifFalse: [^false].	1 to: self statements size		do: [:i | (self statements at: i) = (anObject statements at: i) ifFalse: [^false]].	^true</body><body package="Browser-Parser" selector="equalTo:withMapping:">equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [^false].	self statements size == anObject statements size ifFalse: [^false].	1 to: self statements size		do: 			[:i | 			((self statements at: i) equalTo: (anObject statements at: i)				withMapping: aDictionary) ifFalse: [^false]].	aDictionary values asSet size = aDictionary size ifFalse: [^false].	"Not a one-to-one mapping"	self temporaries		do: [:each | aDictionary removeKey: each name ifAbsent: []].	^true</body><body package="Browser-Parser" selector="hash">hash	^self temporaries hash bitXor: (self statements isEmpty 				ifTrue: [0]				ifFalse: [self statements first hash])</body></methods><methods><class-id>Refactory.Browser.RBSequenceNode</class-id> <category>visitor</category><body package="Browser-Parser" selector="acceptVisitor:">acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptSequenceNode: self</body></methods><methods><class-id>Refactory.Browser.RBSequenceNode</class-id> <category>adding nodes</category><body package="Browser-Parser" selector="addNode:">addNode: aNode 	aNode parent: self.	(statements notEmpty and: [statements last isReturn]) 		ifTrue: [self error: (#CannotAddStmtAfterReturn &lt;&lt; #browser &gt;&gt; 'Cannot add statement after return node')].	statements := (statements asOrderedCollection)				add: aNode;				yourself</body><body package="Browser-Parser" selector="addNode:before:">addNode: aNode before: anotherNode 	| index |	index := self indexOfNode: anotherNode.	index = 0 ifTrue: [^self addNode: aNode].	statements := (statements asOrderedCollection)				add: aNode beforeIndex: index;				yourself.	aNode parent: self</body><body package="Browser-Parser" selector="addNodeFirst:">addNodeFirst: aNode 	aNode parent: self.	statements := (statements asOrderedCollection)				addFirst: aNode;				yourself</body><body package="Browser-Parser" selector="addNodes:">addNodes: aCollection 	aCollection do: [:each | each parent: self].	(statements notEmpty and: [statements last isReturn]) 		ifTrue: [self error: (#CannotAddStmtAfterReturn &lt;&lt; #browser &gt;&gt; 'Cannot add statement after return node')].	statements := (statements asOrderedCollection)				addAll: aCollection;				yourself</body><body package="Browser-Parser" selector="addNodes:before:">addNodes: aCollection before: anotherNode 	aCollection do: [:each | self addNode: each before: anotherNode]</body><body package="Browser-Parser" selector="addNodesFirst:">addNodesFirst: aCollection 	aCollection do: [:each | each parent: self].	statements := (statements asOrderedCollection)				addAllFirst: aCollection;				yourself</body><body package="Browser-Parser" selector="addSelfReturn">addSelfReturn	| node |	self lastIsReturn ifTrue: [^self].	node := RBReturnNode value: (RBVariableNode named: 'self').	self addNode: node</body><body package="Browser-Parser" selector="addTemporariesNamed:">addTemporariesNamed: aCollection 	aCollection do: [:each | self addTemporaryNamed: each]</body><body package="Browser-Parser" selector="addTemporaryNamed:">addTemporaryNamed: aString 	| variableNode |	variableNode := RBVariableNode named: aString.	variableNode parent: self.	temporaries := temporaries copyWith: variableNode</body></methods><methods><class-id>Refactory.Browser.RBSequenceNode</class-id> <category>accessing</category><body package="Browser-Parser" selector="addReturn">addReturn	| node |	statements isEmpty ifTrue: [^nil].	statements last isReturn ifTrue: [^statements last].	node := RBReturnNode value: statements last.	statements at: statements size put: node.	node parent: self.	^node</body><body package="Browser-Parser" selector="allDefinedVariables">allDefinedVariables	^(self temporaryNames asOrderedCollection)		addAll: super allDefinedVariables;		yourself</body><body package="Browser-Parser" selector="allTemporaryVariables">allTemporaryVariables	^(self temporaryNames asOrderedCollection)		addAll: super allTemporaryVariables;		yourself</body><body package="Browser-Parser" selector="children">children	^(OrderedCollection new)		addAll: self temporaries;		addAll: self statements;		yourself</body><body package="Browser-Parser" selector="methodComments">methodComments	| methodComments |	methodComments := OrderedCollection withAll: self comments.	temporaries do: [:each | methodComments addAll: each comments].	(parent notNil and: [parent isBlock]) 		ifTrue: [parent arguments do: [:each | methodComments addAll: each comments]].	^methodComments asSortedCollection: [:a :b | a first &lt; b first]</body><body package="Browser-Parser" selector="periods:">periods: anObject	periods := anObject</body><body package="Browser-Parser" selector="removeTemporaryNamed:">removeTemporaryNamed: aName 	temporaries := temporaries reject: [:each | each name = aName]</body><body package="Browser-Parser" selector="start">start	^leftBar isNil 		ifTrue: [statements isEmpty ifTrue: [1] ifFalse: [statements first start]]		ifFalse: [leftBar]</body><body package="Browser-Parser" selector="statements">statements	^statements</body><body package="Browser-Parser" selector="statements:">statements: stmtCollection 	statements := stmtCollection.	statements do: [:each | each parent: self]</body><body package="Browser-Parser" selector="stop">stop	^(periods isEmpty ifTrue: [0] ifFalse: [periods last]) 		max: (statements isEmpty ifTrue: [0] ifFalse: [statements last stop])</body><body package="Browser-Parser" selector="temporaries">temporaries	^temporaries</body><body package="Browser-Parser" selector="temporaries:">temporaries: tempCollection 	temporaries := tempCollection.	temporaries do: [:each | each parent: self]</body><body package="Browser-Parser" selector="temporaryNames">temporaryNames	^temporaries collect: [:each | each name]</body><body package="Browser-Parser" selector="temporaryVariables">temporaryVariables	^(super temporaryVariables asOrderedCollection)		addAll: self temporaryNames;		yourself</body></methods><methods><class-id>Refactory.Browser.RBSequenceNode</class-id> <category>querying</category><body package="Browser-Parser" selector="bestNodeFor:">bestNodeFor: anInterval 	| node |	node := super bestNodeFor: anInterval.	node == self 		ifTrue: 			[(temporaries isEmpty and: [statements size == 1]) 				ifTrue: [^statements first]].	^node</body><body package="Browser-Parser" selector="whichNodeIsContainedBy:">whichNodeIsContainedBy: anInterval 	| node |	node := super whichNodeIsContainedBy: anInterval.	node == self 		ifTrue: 			[(temporaries isEmpty and: [statements size == 1]) 				ifTrue: [^statements first]].	^node</body></methods><methods><class-id>Refactory.Browser.RBSequenceNode</class-id> <category>matching</category><body package="Browser-Parser" selector="copyInContext:">copyInContext: aDictionary 	^(self class new)		temporaries: (self copyList: temporaries inContext: aDictionary);		statements: (self copyList: statements inContext: aDictionary);		yourself</body><body package="Browser-Parser" selector="match:inContext:">match: aNode inContext: aDictionary 	self class == aNode class ifFalse: [^false].	^(self 		matchList: temporaries		against: aNode temporaries		inContext: aDictionary) and: 				[self 					matchList: statements					against: aNode statements					inContext: aDictionary]</body></methods><methods><class-id>Refactory.Browser.RBSequenceNode</class-id> <category>testing</category><body package="Browser-Parser" selector="defines:">defines: aName 	^temporaries anySatisfy: [:each | each name = aName]</body><body package="Browser-Parser" selector="directlyUses:">directlyUses: aNode 	^false</body><body package="Browser-Parser" selector="isLast:">isLast: aNode 	| last |	statements isEmpty ifTrue: [^false].	last := statements last.	^last == aNode or: 			[last isMessage and: 					[(#(#ifTrue:ifFalse: #ifFalse:ifTrue:) includes: last selector) 						and: [last arguments anySatisfy: [:each | each isLast: aNode]]]]</body><body package="Browser-Parser" selector="isSequence">isSequence	^true</body><body package="Browser-Parser" selector="lastIsReturn">lastIsReturn	^statements notEmpty and: [statements last lastIsReturn]</body><body package="Browser-Parser" selector="references:">references: aVariableName 	^statements anySatisfy: [:each | each references: aVariableName]</body><body package="Browser-Parser" selector="uses:">uses: aNode 	statements isEmpty ifTrue: [^false].	aNode == statements last ifFalse: [^false].	^self isUsed</body></methods><methods><class-id>Refactory.Browser.RBSequenceNode</class-id> <category>private</category><body package="Browser-Parser" selector="indexOfNode:">indexOfNode: aNode 	"Try to find the node by first looking for ==, and then for ="	^(1 to: statements size) detect: [:each | (statements at: each) == aNode]		ifNone: [statements indexOf: aNode]</body></methods><methods><class-id>Refactory.Browser.RBSequenceNode</class-id> <category>initialize-release</category><body package="Browser-Parser" selector="leftBar:temporaries:rightBar:">leftBar: leftInteger temporaries: variableNodes rightBar: rightInteger 	leftBar := leftInteger.	self temporaries: variableNodes.	rightBar := rightInteger</body></methods><methods><class-id>Refactory.Browser.RBSequenceNode</class-id> <category>copying</category><body package="Browser-Parser" selector="postCopy">postCopy	super postCopy.	temporaries := temporaries collect: [:each | each copy].	statements := statements collect: [:each | each copy]</body></methods><methods><class-id>Refactory.Browser.RBSequenceNode</class-id> <category>replacing</category><body package="Browser-Parser" selector="removeDeadCode">removeDeadCode	(self isUsed ifTrue: [statements size - 1] ifFalse: [statements size]) 		to: 1		by: -1		do: 			[:i | 			(statements at: i) isImmediateNode 				ifTrue: 					[self clearReplacements.					statements removeAtIndex: i]].	super removeDeadCode</body><body package="Browser-Parser" selector="removeNode:">removeNode: aNode	self replaceNode: aNode withNodes: #()</body><body package="Browser-Parser" selector="replaceNode:withNode:">replaceNode: aNode withNode: anotherNode 	self statements: (statements 				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]]).	self temporaries: (temporaries 				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])</body><body package="Browser-Parser" selector="replaceNode:withNodes:">replaceNode: aNode withNodes: aCollection 	| index newStatements |	self clearReplacements.	index := self indexOfNode: aNode.	newStatements := OrderedCollection new: statements size + aCollection size.	1 to: index - 1 do: [:i | newStatements add: (statements at: i)].	newStatements addAll: aCollection.	index + 1 to: statements size		do: [:i | newStatements add: (statements at: i)].	aCollection do: [:each | each parent: self].	statements := newStatements</body></methods><methods><class-id>Refactory.Browser.RBSequenceNode class</class-id> <category>instance creation</category><body package="Browser-Parser" selector="leftBar:temporaries:rightBar:">leftBar: leftInteger temporaries: variableNodes rightBar: rightInteger 	^(self new)		leftBar: leftInteger			temporaries: variableNodes			rightBar: rightInteger;		yourself</body><body package="Browser-Parser" selector="statements:">statements: statementNodes 	^self temporaries: #() statements: statementNodes</body><body package="Browser-Parser" selector="temporaries:statements:">temporaries: variableNodes statements: statementNodes 	^(self new)		temporaries: variableNodes;		statements: statementNodes;		yourself</body></methods><methods><class-id>Refactory.Browser.RBLiteralNode</class-id> <category>comparing</category><body package="Browser-Parser" selector="=">= anObject 	self == anObject ifTrue: [^true].	^self class == anObject class</body><body package="Browser-Parser" selector="hash">hash	^self value hash</body></methods><methods><class-id>Refactory.Browser.RBLiteralNode</class-id> <category>testing</category><body package="Browser-Parser" selector="isImmediateNode">isImmediateNode	^true</body><body package="Browser-Parser" selector="isLiteralNode">isLiteralNode	^true</body><body package="Browser-Parser" selector="needsParenthesis">needsParenthesis	^false</body></methods><methods><class-id>Refactory.Browser.RBLiteralNode</class-id> <category>accessing</category><body package="Browser-Parser" selector="precedence">precedence	^0</body><body package="Browser-Parser" selector="value">value	^self subclassResponsibility</body></methods><methods><class-id>Refactory.Browser.RBLiteralNode</class-id> <category>private-replacing</category><body package="Browser-Parser" selector="replaceSourceFrom:">replaceSourceFrom: aNode 	self addReplacement: (RBStringReplacement 				replaceFrom: aNode start				to: aNode stop				with: self formattedCode)</body><body package="Browser-Parser" selector="replaceSourceWith:">replaceSourceWith: aNode 	self addReplacement: (RBStringReplacement 				replaceFrom: self start				to: self stop				with: aNode formattedCode)</body></methods><methods><class-id>Refactory.Browser.RBLiteralNode class</class-id> <category>instance creation</category><body package="Browser-Parser" selector="literalToken:">literalToken: aLiteralToken 	^(aLiteralToken realValue class == Array 		or: [aLiteralToken realValue class == ByteArray]) 			ifTrue: 				[RBLiteralArrayNode 					startPosition: aLiteralToken start					contents: (aLiteralToken value asArray 							collect: [:each | RBLiteralNode literalToken: each])					stopPosition: aLiteralToken stop					isByteArray: aLiteralToken value class ~~ Array]			ifFalse: [RBLiteralValueNode literalToken: aLiteralToken]</body><body package="Browser-Parser" selector="value:">value: aValue 	^((aValue class == Array or: [aValue class == ByteArray]) 		ifTrue: [RBLiteralArrayNode]		ifFalse: [RBLiteralValueNode]) value: aValue</body></methods><methods><class-id>Refactory.Browser.RBLiteralArrayNode</class-id> <category>copying</category><body package="Browser-Parser" selector="postCopy">postCopy	super postCopy.	contents := contents collect: [:each | each copy]</body></methods><methods><class-id>Refactory.Browser.RBLiteralArrayNode</class-id> <category>accessing</category><body package="Browser-Parser" selector="children">children	^contents</body><body package="Browser-Parser" selector="contents">contents	^contents</body><body package="Browser-Parser" selector="startWithoutParentheses">startWithoutParentheses	^start</body><body package="Browser-Parser" selector="stopWithoutParentheses">stopWithoutParentheses	^stop</body><body package="Browser-Parser" selector="value">value	| array |	array := (isByteArray ifTrue: [ByteArray] ifFalse: [Array]) 				new: contents size.	1 to: contents size		do: [:each | array at: each put: (contents at: each) value].	^array</body></methods><methods><class-id>Refactory.Browser.RBLiteralArrayNode</class-id> <category>initialize-release</category><body package="Browser-Parser" selector="contents:">contents: aRBLiteralNodeCollection 	contents := aRBLiteralNodeCollection.	contents do: [:each | each parent: self]</body><body package="Browser-Parser" selector="startPosition:contents:stopPosition:isByteArray:">startPosition: startInteger contents: anArray stopPosition: stopInteger isByteArray: aBoolean 	start := startInteger.	self contents: anArray.	stop := stopInteger.	isByteArray := aBoolean</body></methods><methods><class-id>Refactory.Browser.RBLiteralArrayNode</class-id> <category>replacing</category><body package="Browser-Parser" selector="replaceNode:withNode:">replaceNode: aNode withNode: anotherNode 	self contents: (contents 				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])</body></methods><methods><class-id>Refactory.Browser.RBLiteralArrayNode</class-id> <category>comparing</category><body package="Browser-Parser" selector="=">= anObject 	super = anObject ifFalse: [^false].	self isForByteArray = anObject isForByteArray ifFalse: [^false].	self contents size = anObject contents size ifFalse: [^false].	1 to: self contents size		do: [:i | (self contents at: i) = (anObject contents at: i) ifFalse: [^false]].	^true</body><body package="Browser-Parser" selector="equalTo:withMapping:">equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [^false].	self isForByteArray = anObject isForByteArray ifFalse: [^false].	self contents size = anObject contents size ifFalse: [^false].	1 to: self contents size		do: 			[:i | 			((self contents at: i) equalTo: (anObject contents at: i)				withMapping: aDictionary) ifFalse: [^false]].	^true</body></methods><methods><class-id>Refactory.Browser.RBLiteralArrayNode</class-id> <category>testing</category><body package="Browser-Parser" selector="isForByteArray">isForByteArray	^isByteArray</body><body package="Browser-Parser" selector="isLiteralArray">isLiteralArray	^true</body></methods><methods><class-id>Refactory.Browser.RBLiteralArrayNode</class-id> <category>visitor</category><body package="Browser-Parser" selector="acceptVisitor:">acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptLiteralArrayNode: self</body></methods><methods><class-id>Refactory.Browser.RBLiteralArrayNode</class-id> <category>matching</category><body package="Browser-Parser" selector="copyInContext:">copyInContext: aDictionary 	^self class 		startPosition: nil		contents: (self copyList: contents inContext: aDictionary)		stopPosition: nil		isByteArray: isByteArray</body><body package="Browser-Parser" selector="match:inContext:">match: aNode inContext: aDictionary 	aNode class == self class ifFalse: [^false].	self isForByteArray = aNode isForByteArray ifFalse: [^false].	^self 		matchList: contents		against: aNode contents		inContext: aDictionary</body></methods><methods><class-id>Refactory.Browser.RBLiteralArrayNode</class-id> <category>private-replacing</category><body package="Browser-Parser" selector="replaceSourceWith:">replaceSourceWith: aNode 	(self class = aNode class and: 			[self isForByteArray = aNode isForByteArray 				and: [self contents size = aNode contents size]]) 		ifFalse: [^super replaceSourceWith: aNode].	1 to: self contents size		do: 			[:i | 			(self contents at: i) = (aNode contents at: i) 				ifFalse: [(self contents at: i) replaceSourceWith: (aNode contents at: i)]]</body></methods><methods><class-id>Refactory.Browser.RBLiteralArrayNode class</class-id> <category>instance creation</category><body package="Browser-Parser" selector="startPosition:contents:stopPosition:isByteArray:">startPosition: startInteger contents: anArray stopPosition: stopInteger isByteArray: aBoolean 	^(self new)		startPosition: startInteger			contents: anArray			stopPosition: stopInteger			isByteArray: aBoolean;		yourself</body><body package="Browser-Parser" selector="value:">value: aValue 	^(self new)		startPosition: nil			contents: (aValue asArray collect: [:each | RBLiteralNode value: each])			stopPosition: nil			isByteArray: aValue class ~~ Array;		yourself</body></methods><methods><class-id>Refactory.Browser.RBAssignmentNode</class-id> <category>comparing</category><body package="Browser-Parser" selector="=">= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	^self variable = anObject variable and: [self value = anObject value]</body><body package="Browser-Parser" selector="equalTo:withMapping:">equalTo: anObject withMapping: aDictionary 	^self class = anObject class and: 			[(self variable equalTo: anObject variable withMapping: aDictionary) 				and: [self value equalTo: anObject value withMapping: aDictionary]]</body><body package="Browser-Parser" selector="hash">hash	^self variable hash bitXor: self value hash</body></methods><methods><class-id>Refactory.Browser.RBAssignmentNode</class-id> <category>visitor</category><body package="Browser-Parser" selector="acceptVisitor:">acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptAssignmentNode: self</body></methods><methods><class-id>Refactory.Browser.RBAssignmentNode</class-id> <category>testing</category><body package="Browser-Parser" selector="assigns:">assigns: aVariableName 	^variable name = aVariableName or: [value assigns: aVariableName]</body><body package="Browser-Parser" selector="directlyUses:">directlyUses: aNode 	^aNode = value ifTrue: [true] ifFalse: [self isDirectlyUsed]</body><body package="Browser-Parser" selector="isAssignment">isAssignment	^true</body><body package="Browser-Parser" selector="needsParenthesis">needsParenthesis	^parent isNil 		ifTrue: [false]		ifFalse: [self precedence &gt; parent precedence]</body><body package="Browser-Parser" selector="uses:">uses: aNode 	^aNode = value ifTrue: [true] ifFalse: [self isUsed]</body></methods><methods><class-id>Refactory.Browser.RBAssignmentNode</class-id> <category>querying</category><body package="Browser-Parser" selector="bestNodeFor:">bestNodeFor: anInterval 	(self intersectsInterval: anInterval) ifFalse: [^nil].	(self containedBy: anInterval) ifTrue: [^self].	assignment isNil ifTrue: [^super bestNodeFor: anInterval].	((anInterval first between: assignment and: assignment + 1) 		or: [assignment between: anInterval first and: anInterval last]) 			ifTrue: [^self].	self children do: 			[:each | 			| node |			node := each bestNodeFor: anInterval.			node notNil ifTrue: [^node]]</body></methods><methods><class-id>Refactory.Browser.RBAssignmentNode</class-id> <category>accessing</category><body package="Browser-Parser" selector="assignmentPosition">assignmentPosition	^assignment</body><body package="Browser-Parser" selector="children">children	^Array with: value with: variable</body><body package="Browser-Parser" selector="precedence">precedence	^5</body><body package="Browser-Parser" selector="startWithoutParentheses">startWithoutParentheses	^variable start</body><body package="Browser-Parser" selector="stopWithoutParentheses">stopWithoutParentheses	^value stop</body><body package="Browser-Parser" selector="value">value	^value</body><body package="Browser-Parser" selector="value:">value: aValueNode 	value := aValueNode.	value parent: self</body><body package="Browser-Parser" selector="variable">variable	^variable</body><body package="Browser-Parser" selector="variable:">variable: varNode 	variable := varNode.	variable parent: self</body></methods><methods><class-id>Refactory.Browser.RBAssignmentNode</class-id> <category>matching</category><body package="Browser-Parser" selector="copyInContext:">copyInContext: aDictionary 	^(self class new)		variable: (variable copyInContext: aDictionary);		value: (value copyInContext: aDictionary);		yourself</body><body package="Browser-Parser" selector="match:inContext:">match: aNode inContext: aDictionary 	aNode class == self class ifFalse: [^false].	^(variable match: aNode variable inContext: aDictionary)		and: [value match: aNode value inContext: aDictionary]</body></methods><methods><class-id>Refactory.Browser.RBAssignmentNode</class-id> <category>copying</category><body package="Browser-Parser" selector="postCopy">postCopy	super postCopy.	variable := variable postCopy.	value := value postCopy</body></methods><methods><class-id>Refactory.Browser.RBAssignmentNode</class-id> <category>replacing</category><body package="Browser-Parser" selector="replaceNode:withNode:">replaceNode: aNode withNode: anotherNode 	value == aNode ifTrue: [self value: anotherNode].	variable == aNode ifTrue: [self variable: anotherNode]</body><body package="Browser-Parser" selector="replaceSourceWith:">replaceSourceWith: aNode 	"Check if we are being replaced with a setter message send. If so, create the replacements to edit the original source."	aNode isMessage ifFalse: [^super replaceSourceWith: aNode].	aNode receiver isVariable ifFalse: [^super replaceSourceWith: aNode].	aNode numArgs = 1 ifFalse: [^super replaceSourceWith: aNode].	(self mappingFor: self value) = aNode arguments first 		ifFalse: [^super replaceSourceWith: aNode].	(self value hasParentheses not 		and: [aNode arguments first precedence &gt;= aNode precedence]) 			ifTrue: 				[self					addReplacement: (RBStringReplacement 								replaceFrom: self value start								to: self value start - 1								with: '(');					addReplacement: (RBStringReplacement 								replaceFrom: self value stop + 1								to: self value stop								with: ')')].	self addReplacement: (RBStringReplacement 				replaceFrom: self variable start				to: self assignmentPosition + 1				with: aNode receiver name , ' ' , aNode selector)</body></methods><methods><class-id>Refactory.Browser.RBAssignmentNode</class-id> <category>initialize-release</category><body package="Browser-Parser" selector="variable:value:position:">variable: aVariableNode value: aValueNode position: anInteger 	self variable: aVariableNode.	self value: aValueNode.	assignment := anInteger</body></methods><methods><class-id>Refactory.Browser.RBAssignmentNode class</class-id> <category>instance creation</category><body package="Browser-Parser" selector="variable:value:">variable: aVariableNode value: aValueNode 	^self 		variable: aVariableNode		value: aValueNode		position: nil</body><body package="Browser-Parser" selector="variable:value:position:">variable: aVariableNode value: aValueNode position: anInteger 	^(self new)		variable: aVariableNode			value: aValueNode			position: anInteger;		yourself</body></methods><methods><class-id>Refactory.Browser.RBSmallDictionary</class-id> <category>adding</category><body package="Browser-Parser" selector="add:">add: anAssociation 	self at: anAssociation key put: anAssociation value.	^anAssociation</body><body package="Browser-Parser" selector="at:put:">at: key put: value 	| index |	index := self findIndexFor: key.	^index == 0 		ifTrue: [self privateAt: key put: value]		ifFalse: [values at: index put: value]</body></methods><methods><class-id>Refactory.Browser.RBSmallDictionary</class-id> <category>enumerating</category><body package="Browser-Parser" selector="associationsDo:">associationsDo: aBlock 	self keysAndValuesDo: [:key :value | aBlock value: key -&gt; value]</body><body package="Browser-Parser" selector="do:">do: aBlock 	1 to: size do: [:i | aBlock value: (values at: i)]</body><body package="Browser-Parser" selector="keysAndValuesDo:">keysAndValuesDo: aBlock 	1 to: size do: [:i | aBlock value: (keys at: i) value: (values at: i)]</body><body package="Browser-Parser" selector="keysDo:">keysDo: aBlock 	1 to: size do: [:i | aBlock value: (keys at: i)]</body></methods><methods><class-id>Refactory.Browser.RBSmallDictionary</class-id> <category>accessing</category><body package="Browser-Parser" selector="at:ifAbsent:">at: key ifAbsent: aBlock 	| index |	index := self findIndexFor: key.	^index == 0 ifTrue: [aBlock value] ifFalse: [values at: index]</body><body package="Browser-Parser" selector="at:ifAbsentPut:">at: key ifAbsentPut: aBlock 	| index |	index := self findIndexFor: key.	^index == 0 		ifTrue: [self privateAt: key put: aBlock value]		ifFalse: [values at: index]</body><body package="Browser-Parser" selector="empty">empty	size := 0</body><body package="Browser-Parser" selector="size">size	^size</body></methods><methods><class-id>Refactory.Browser.RBSmallDictionary</class-id> <category>private</category><body package="Browser-Parser" selector="findIndexFor:">findIndexFor: aKey 	1 to: size do: [:i | (keys at: i) = aKey ifTrue: [^i]].	^0</body><body package="Browser-Parser" selector="growKeysAndValues">growKeysAndValues	self growTo: size * 2</body><body package="Browser-Parser" selector="growTo:">growTo: aSize 	| newKeys newValues |	newKeys := Array new: aSize.	newValues := Array new: aSize.	1 to: size		do: 			[:i | 			newKeys at: i put: (keys at: i).			newValues at: i put: (values at: i)].	keys := newKeys.	values := newValues</body><body package="Browser-Parser" selector="privateAt:put:">privateAt: key put: value 	size == keys size ifTrue: [self growKeysAndValues].	size := size + 1.	keys at: size put: key.	^values at: size put: value</body></methods><methods><class-id>Refactory.Browser.RBSmallDictionary</class-id> <category>testing</category><body package="Browser-Parser" selector="includesKey:">includesKey: aKey 	^(self findIndexFor: aKey) ~~ 0</body></methods><methods><class-id>Refactory.Browser.RBSmallDictionary</class-id> <category>initialize-release</category><body package="Browser-Parser" selector="initialize">initialize	keys := Array new: 2.	values := Array new: 2.	size := 0</body></methods><methods><class-id>Refactory.Browser.RBSmallDictionary</class-id> <category>copying</category><body package="Browser-Parser" selector="postCopy">postCopy	super postCopy.	keys := keys copy.	values := values copy</body></methods><methods><class-id>Refactory.Browser.RBSmallDictionary</class-id> <category>removing</category><body package="Browser-Parser" selector="remove:ifAbsent:">remove: oldObject ifAbsent: anExceptionBlock 	self removeKey: oldObject key ifAbsent: anExceptionBlock.	^oldObject</body><body package="Browser-Parser" selector="removeKey:ifAbsent:">removeKey: key ifAbsent: aBlock 	| index value |	index := self findIndexFor: key.	index == 0 ifTrue: [^aBlock value].	value := values at: index.	index to: size - 1		do: 			[:i | 			keys at: i put: (keys at: i + 1).			values at: i put: (values at: i + 1)].	keys at: size put: nil.	values at: size put: nil.	size := size - 1.	^value</body></methods><methods><class-id>Refactory.Browser.RBSmallDictionary class</class-id> <category>instance creation</category><body package="Browser-Parser" selector="new">new	^self basicNew initialize</body><body package="Browser-Parser" selector="new:">new: aSize 	"Ignore the size"	^self basicNew initialize</body></methods><methods><class-id>Refactory.Browser.ParseTreeSearcher</class-id> <category>accessing</category><body package="Browser-Parser" selector="addArgumentRule:">addArgumentRule: aParseTreeRule 	argumentSearches add: aParseTreeRule.	aParseTreeRule owner: self</body><body package="Browser-Parser" selector="addArgumentRules:">addArgumentRules: ruleCollection 	ruleCollection do: [:each | self addArgumentRule: each]</body><body package="Browser-Parser" selector="addRule:">addRule: aParseTreeRule 	searches add: aParseTreeRule.	aParseTreeRule owner: self</body><body package="Browser-Parser" selector="addRules:">addRules: ruleCollection 	ruleCollection do: [:each | self addRule: each]</body><body package="Browser-Parser" selector="answer">answer	^answer</body><body package="Browser-Parser" selector="context">context	^context</body><body package="Browser-Parser" selector="executeMethod:initialAnswer:">executeMethod: aParseTree initialAnswer: anObject 	answer := anObject.	searches detect: [:each | (each performOn: aParseTree) notNil] ifNone: [].	^answer</body><body package="Browser-Parser" selector="executeTree:">executeTree: aParseTree 	"Save our current context, in case someone is performing another search inside a match."	| oldContext |	oldContext := context.	context := RBSmallDictionary new.	self visitNode: aParseTree.	context := oldContext.	^answer</body><body package="Browser-Parser" selector="executeTree:initialAnswer:">executeTree: aParseTree initialAnswer: aValue 	answer := aValue.	^self executeTree: aParseTree</body><body package="Browser-Parser" selector="messages">messages	messages notNil ifTrue: [^messages].	argumentSearches notEmpty ifTrue: [^messages := #()].	messages := Set new.	searches do: 			[:each | 			| searchMessages |			searchMessages := each sentMessages.			RBProgramNode optimizedSelectors 				do: [:sel | searchMessages remove: sel ifAbsent: []].			searchMessages isEmpty ifTrue: [^messages := #()].			messages addAll: searchMessages].	^messages := messages asArray</body></methods><methods><class-id>Refactory.Browser.ParseTreeSearcher</class-id> <category>initialize-release</category><body package="Browser-Parser" selector="answer:">answer: anObject	answer := anObject</body><body package="Browser-Parser" selector="initialize">initialize	super initialize.	context := RBSmallDictionary new.	searches := OrderedCollection new.	argumentSearches := OrderedCollection new: 0.	answer := nil</body></methods><methods><class-id>Refactory.Browser.ParseTreeSearcher</class-id> <category>testing</category><body package="Browser-Parser" selector="canMatchMethod:">canMatchMethod: aCompiledMethod 	^self messages isEmpty 		or: [self messages anySatisfy: [:each | aCompiledMethod sendsSelector: each]]</body></methods><methods><class-id>Refactory.Browser.ParseTreeSearcher</class-id> <category>private</category><body package="Browser-Parser" selector="foundMatch">foundMatch</body><body package="Browser-Parser" selector="lookForMoreMatchesInContext:">lookForMoreMatchesInContext: oldContext 	oldContext keysAndValuesDo: 			[:key :value | 			(key isString not and: [key recurseInto]) 				ifTrue: [value do: [:each | self visitNode: each]]]</body><body package="Browser-Parser" selector="performSearches:on:">performSearches: aSearchCollection on: aNode 	| value |	1 to: aSearchCollection size		do: 			[:i | 			value := (aSearchCollection at: i) performOn: aNode.			value notNil 				ifTrue: 					[self foundMatch.					^value]].	^nil</body><body package="Browser-Parser" selector="recursivelySearchInContext">recursivelySearchInContext	"We need to save the matched context since the other searches might overwrite it."	| oldContext |	oldContext := context.	context := RBSmallDictionary new.	self lookForMoreMatchesInContext: oldContext.	context := oldContext</body></methods><methods><class-id>Refactory.Browser.ParseTreeSearcher</class-id> <category>searching</category><body package="Browser-Parser" selector="matches:do:">matches: aString do: aBlock 	self addRule: (RBSearchRule searchFor: aString thenDo: aBlock)</body><body package="Browser-Parser" selector="matchesAnyArgumentOf:do:">matchesAnyArgumentOf: stringCollection do: aBlock 	stringCollection do: [:each | self matchesArgument: each do: aBlock]</body><body package="Browser-Parser" selector="matchesAnyMethodOf:do:">matchesAnyMethodOf: aStringCollection do: aBlock 	aStringCollection do: [:each | self matchesMethod: each do: aBlock]</body><body package="Browser-Parser" selector="matchesAnyOf:do:">matchesAnyOf: aStringCollection do: aBlock 	aStringCollection do: [:each | self matches: each do: aBlock]</body><body package="Browser-Parser" selector="matchesAnyTreeOf:do:">matchesAnyTreeOf: treeCollection do: aBlock 	treeCollection do: [:each | self matchesTree: each do: aBlock]</body><body package="Browser-Parser" selector="matchesArgument:do:">matchesArgument: aString do: aBlock 	self addArgumentRule: (RBSearchRule searchFor: aString thenDo: aBlock)</body><body package="Browser-Parser" selector="matchesArgumentTree:do:">matchesArgumentTree: aBRProgramNode do: aBlock 	self 		addArgumentRule: (RBSearchRule searchForTree: aBRProgramNode thenDo: aBlock)</body><body package="Browser-Parser" selector="matchesMethod:do:">matchesMethod: aString do: aBlock 	self addRule: (RBSearchRule searchForMethod: aString thenDo: aBlock)</body><body package="Browser-Parser" selector="matchesTree:do:">matchesTree: aBRProgramNode do: aBlock 	self addRule: (RBSearchRule searchForTree: aBRProgramNode thenDo: aBlock)</body></methods><methods><class-id>Refactory.Browser.ParseTreeSearcher</class-id> <category>visiting</category><body package="Browser-Parser" selector="visitArgument:">visitArgument: aNode 	| value |	value := self performSearches: argumentSearches on: aNode.	^value isNil 		ifTrue: 			[aNode acceptVisitor: self.			aNode]		ifFalse: [value]</body><body package="Browser-Parser" selector="visitNode:">visitNode: aNode 	| value |	value := self performSearches: searches on: aNode.	^value isNil 		ifTrue: 			[aNode acceptVisitor: self.			aNode]		ifFalse: [value]</body></methods><methods><class-id>Refactory.Browser.ParseTreeSearcher class</class-id> <category>private</category><body package="Browser-Parser" selector="buildSelectorString:">buildSelectorString: aSelector 	| stream keywords |	aSelector numArgs = 0 ifTrue: [^aSelector].	stream := WriteStream on: String new.	keywords := aSelector keywords.	1 to: keywords size		do: 			[:i | 			stream				nextPutAll: (keywords at: i);				nextPutAll: ' ``@arg';				nextPutAll: i printString;				nextPut: $ ].	^stream contents</body><body package="Browser-Parser" selector="buildSelectorTree:">buildSelectorTree: aSelector 	aSelector isEmpty ifTrue: [^nil].	^RBParser parseRewriteExpression: '``@receiver ' 				, (self buildSelectorString: aSelector)		onError: [:err :pos | ^nil]</body><body package="Browser-Parser" selector="buildTree:method:">buildTree: aString method: aBoolean 	^aBoolean 		ifTrue: [RBParser parseRewriteMethod: aString]		ifFalse: [RBParser parseRewriteExpression: aString]</body></methods><methods><class-id>Refactory.Browser.ParseTreeSearcher class</class-id> <category>instance creation</category><body package="Browser-Parser" selector="getterMethod:">getterMethod: aVarName 	^(self new)		matchesMethod: '`method ^' , aVarName do: [:aNode :ans | aNode selector];		yourself</body><body package="Browser-Parser" selector="justSendsSuper">justSendsSuper	^(self new)		matchesAnyMethodOf: 				#('`@method: `@Args ^super `@method: `@Args' 				'`@method: `@Args super `@method: `@Args')			do: [:aNode :ans | true];		yourself</body><body package="Browser-Parser" selector="returnSetterMethod:">returnSetterMethod: aVarName 	^(self new)		matchesMethod: '`method: `Arg ^' , aVarName , ' := `Arg'			do: [:aNode :ans | aNode selector];		yourself</body><body package="Browser-Parser" selector="setterMethod:">setterMethod: aVarName 	^(self new)		matchesAnyMethodOf: (Array with: '`method: `Arg ' , aVarName , ' := `Arg'					with: '`method: `Arg ^' , aVarName , ' := `Arg')			do: [:aNode :ans | aNode selector];		yourself</body></methods><methods><class-id>Refactory.Browser.ParseTreeSearcher class</class-id> <category>accessing</category><body package="Browser-Parser" selector="treeMatching:in:">treeMatching: aString in: aParseTree 	(self new)		matches: aString do: [:aNode :answer | ^aNode];		executeTree: aParseTree.	^nil</body><body package="Browser-Parser" selector="treeMatchingStatements:in:">treeMatchingStatements: aString in: aParseTree 	| notifier tree |	notifier := self new.	tree := RBParser parseExpression: aString.	tree isSequence 		ifFalse: [tree := RBSequenceNode statements: (Array with: tree)].	tree temporaries: (Array with: (RBPatternVariableNode named: '`@temps')).	tree addNodeFirst: (RBPatternVariableNode named: '`@.S1').	tree lastIsReturn 		ifFalse: [tree addNode: (RBPatternVariableNode named: '`@.S2')].	notifier matchesTree: tree		do: [:aNode :answer | ^RBParser parseExpression: aString].	notifier executeTree: aParseTree.	^nil</body></methods><methods><class-id>Refactory.Browser.RBToken</class-id> <category>testing</category><body package="Browser-Parser" selector="isAssignment">isAssignment	^false</body><body package="Browser-Parser" selector="isBinary">isBinary	^false</body><body package="Browser-Parser" selector="isIdentifier">isIdentifier	^false</body><body package="Browser-Parser" selector="isKeyword">isKeyword	^false</body><body package="Browser-Parser" selector="isLiteral">isLiteral	^self isLiteralToken</body><body package="Browser-Parser" selector="isLiteralArrayToken">isLiteralArrayToken	^false</body><body package="Browser-Parser" selector="isLiteralToken">isLiteralToken	^false</body><body package="Browser-Parser" selector="isOptimized">isOptimized	^false</body><body package="Browser-Parser" selector="isPatternBlock">isPatternBlock	^false</body><body package="Browser-Parser" selector="isPatternVariable">isPatternVariable	^false</body><body package="Browser-Parser" selector="isSpecial">isSpecial	^false</body></methods><methods><class-id>Refactory.Browser.RBToken</class-id> <category>accessing</category><body package="Browser-Parser" selector="comments">comments	^comments</body><body package="Browser-Parser" selector="comments:">comments: anObject	comments := anObject</body><body package="Browser-Parser" selector="length">length	^self subclassResponsibility</body><body package="Browser-Parser" selector="removePositions">removePositions	sourcePointer := nil</body><body package="Browser-Parser" selector="start">start	^sourcePointer</body><body package="Browser-Parser" selector="stop">stop	^self start + self length - 1</body></methods><methods><class-id>Refactory.Browser.RBToken</class-id> <category>printing</category><body package="Browser-Parser" selector="printOn:">printOn: aStream 	aStream		nextPut: $ ;		nextPutAll: self class name</body></methods><methods><class-id>Refactory.Browser.RBToken</class-id> <category>initialize-release</category><body package="Browser-Parser" selector="start:">start: anInteger 	sourcePointer := anInteger</body></methods><methods><class-id>Refactory.Browser.RBToken class</class-id> <category>instance creation</category><body package="Browser-Parser" selector="start:">start: anInterval 	^self new start: anInterval</body></methods><methods><class-id>Refactory.Browser.RBOptimizedToken</class-id> <category>testing</category><body package="Browser-Parser" selector="isOptimized">isOptimized	^true</body></methods><methods><class-id>Refactory.Browser.RBOptimizedToken</class-id> <category>private</category><body package="Browser-Parser" selector="length">length	^3</body></methods><methods><class-id>Refactory.Browser.RBAssignmentToken</class-id> <category>testing</category><body package="Browser-Parser" selector="isAssignment">isAssignment	^true</body></methods><methods><class-id>Refactory.Browser.RBAssignmentToken</class-id> <category>private</category><body package="Browser-Parser" selector="length">length	^2</body></methods><methods><class-id>Refactory.Browser.RBValueToken</class-id> <category>private</category><body package="Browser-Parser" selector="length">length	^value size</body></methods><methods><class-id>Refactory.Browser.RBValueToken</class-id> <category>printing</category><body package="Browser-Parser" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	value printOn: aStream.	aStream nextPutAll: ')'</body></methods><methods><class-id>Refactory.Browser.RBValueToken</class-id> <category>accessing</category><body package="Browser-Parser" selector="value">value	^value</body><body package="Browser-Parser" selector="value:">value: anObject	value := anObject</body></methods><methods><class-id>Refactory.Browser.RBValueToken</class-id> <category>initialize-release</category><body package="Browser-Parser" selector="value:start:">value: aString start: anInteger 	value := aString.	sourcePointer := anInteger</body></methods><methods><class-id>Refactory.Browser.RBValueToken class</class-id> <category>instance creation</category><body package="Browser-Parser" selector="value:start:">value: aString start: anInteger 	^self new value: aString start: anInteger</body></methods><methods><class-id>Refactory.Browser.RBBinarySelectorToken</class-id> <category>testing</category><body package="Browser-Parser" selector="isBinary">isBinary	^true</body></methods><methods><class-id>Refactory.Browser.RBPatternBlockToken</class-id> <category>testing</category><body package="Browser-Parser" selector="isPatternBlock">isPatternBlock	^true</body></methods><methods><class-id>Refactory.Browser.RBIdentifierToken</class-id> <category>testing</category><body package="Browser-Parser" selector="isIdentifier">isIdentifier	^true</body><body package="Browser-Parser" selector="isPatternVariable">isPatternVariable	^value first == RBScanner patternVariableCharacter</body></methods><methods><class-id>Refactory.Browser.RBLiteralToken</class-id> <category>testing</category><body package="Browser-Parser" selector="isLiteralToken">isLiteralToken	^true</body><body package="Browser-Parser" selector="isMultiKeyword">isMultiKeyword	^false</body></methods><methods><class-id>Refactory.Browser.RBLiteralToken</class-id> <category>private</category><body package="Browser-Parser" selector="length">length	^stopPosition - self start + 1</body></methods><methods><class-id>Refactory.Browser.RBLiteralToken</class-id> <category>accessing</category><body package="Browser-Parser" selector="realValue">realValue	^value</body><body package="Browser-Parser" selector="stop:">stop: anObject 	stopPosition := anObject</body></methods><methods><class-id>Refactory.Browser.RBLiteralToken</class-id> <category>initialize-release</category><body package="Browser-Parser" selector="value:start:stop:">value: aString start: anInteger stop: stopInteger 	value := aString.	sourcePointer := anInteger.	stopPosition := stopInteger</body></methods><methods><class-id>Refactory.Browser.RBLiteralToken</class-id> <category>printing</category><body package="Browser-Parser" selector="storeOn:">storeOn: aStream 	value isSymbol 		ifTrue: 			[aStream nextPut: $#.			((RBScanner isSelector: value) and: [value ~~ #'||']) 				ifTrue: [aStream nextPutAll: value]				ifFalse: [value asString printOn: aStream].			^self].	value class == Character 		ifTrue: 			[aStream				nextPut: $$;				nextPut: value.			^self].	value storeOn: aStream</body></methods><methods><class-id>Refactory.Browser.RBLiteralToken class</class-id> <category>instance creation</category><body package="Browser-Parser" selector="value:">value: anObject 	| literal |	literal := anObject class == Array 				ifTrue: [anObject collect: [:each | self value: each]]				ifFalse: [anObject].	^self 		value: literal		start: nil		stop: nil</body><body package="Browser-Parser" selector="value:start:stop:">value: aString start: anInteger stop: stopInteger 	^(self new)		value: aString			start: anInteger			stop: stopInteger;		yourself</body></methods><methods><class-id>Refactory.Browser.RBNumberLiteralToken</class-id> <category>accessing</category><body package="Browser-Parser" selector="source">source	^source</body></methods><methods><class-id>Refactory.Browser.RBNumberLiteralToken</class-id> <category>initialize-release</category><body package="Browser-Parser" selector="source:">source: aString 	source := aString</body></methods><methods><class-id>Refactory.Browser.RBNumberLiteralToken</class-id> <category>printing</category><body package="Browser-Parser" selector="storeOn:">storeOn: aStream 	aStream nextPutAll: source</body></methods><methods><class-id>Refactory.Browser.RBNumberLiteralToken class</class-id> <category>instance creation</category><body package="Browser-Parser" selector="value:start:stop:source:">value: aNumber start: anInteger stop: stopInteger source: sourceString 	^(self 		value: aNumber		start: anInteger		stop: stopInteger)		source: sourceString;		yourself</body></methods><methods><class-id>Refactory.Browser.RBKeywordToken</class-id> <category>testing</category><body package="Browser-Parser" selector="isKeyword">isKeyword	^true</body><body package="Browser-Parser" selector="isPatternVariable">isPatternVariable	^value first == RBScanner patternVariableCharacter</body></methods><methods><class-id>Refactory.Browser.RBLiteralArrayToken</class-id> <category>testing</category><body package="Browser-Parser" selector="isForByteArray">isForByteArray	^value last = $[</body><body package="Browser-Parser" selector="isLiteralArrayToken">isLiteralArrayToken	^true</body></methods><methods><class-id>Refactory.Browser.RBParser</class-id> <category>private</category><body package="Browser-Parser" selector="addCommentsTo:">addCommentsTo: aNode	aNode comments: aNode comments , comments.	comments := OrderedCollection new</body><body package="Browser-Parser" selector="nextToken">nextToken	^nextToken isNil ifTrue: [nextToken := scanner next] ifFalse: [nextToken]</body><body package="Browser-Parser" selector="patchLiteralArrayToken">patchLiteralArrayToken	self class isVisualWorks 		ifTrue: [self patchVisualWorksLiteralArrayToken ifTrue: [^self]].	(currentToken isIdentifier 		or: [currentToken isBinary or: [currentToken isKeyword]]) 			ifFalse: [^self parserError: (#InvalidToken &lt;&lt; #browser &gt;&gt; 'Invalid token')].	currentToken := RBLiteralToken 				value: currentToken value asSymbol				start: currentToken start				stop: currentToken stop</body><body package="Browser-Parser" selector="patchLiteralMessage">patchLiteralMessage	currentToken value == true 		ifTrue: 			[^currentToken := RBIdentifierToken value: 'true' start: currentToken start].	currentToken value == false 		ifTrue: 			[^currentToken := RBIdentifierToken value: 'false' start: currentToken start].	currentToken value == nil 		ifTrue: 			[^currentToken := RBIdentifierToken value: 'nil' start: currentToken start]</body><body package="Browser-Parser" selector="patchNegativeLiteral">patchNegativeLiteral	"Handle the special negative number case for binary message sends."	(currentToken value isKindOf: Number) ifFalse: [^self].	currentToken value &lt;= 0 ifFalse: [^self].	currentToken value = 0 		ifTrue: 			[(source notNil and: 					[source notEmpty 						and: [(source at: (currentToken start min: source size)) == $-]]) 				ifFalse: [^self]].	nextToken := currentToken.	currentToken := RBBinarySelectorToken value: #- start: nextToken start.	nextToken value: nextToken value negated.	(nextToken isKindOf: RBNumberLiteralToken) 		ifTrue: 			[nextToken source: (nextToken source copyFrom: 2 to: nextToken source size)].	nextToken start: nextToken start + 1</body><body package="Browser-Parser" selector="patchVisualWorksLiteralArrayToken">patchVisualWorksLiteralArrayToken	"VW allows for non-standard literals such as #(Foo.bar a:= : ;) which is equivalent to  #('Foo.bar' #a: #= #':' #';')"	(currentToken isIdentifier and: 			[self nextToken isAssignment 				and: [currentToken stop + 1 = self nextToken start]]) 		ifTrue: 			[currentToken := RBLiteralToken 						value: (currentToken value , ':') asSymbol						start: currentToken start						stop: self nextToken start.			nextToken := RBLiteralToken 						value: #=						start: nextToken stop						stop: nextToken stop.			^true].	currentToken isAssignment 		ifTrue: 			[currentToken := RBLiteralToken 						value: #':'						start: currentToken start						stop: currentToken start.			nextToken := RBLiteralToken 						value: #=						start: currentToken stop						stop: currentToken stop.			^true].	currentToken isSpecial 		ifTrue: 			[currentToken := RBLiteralToken 						value: (String with: currentToken value) asSymbol						start: currentToken start						stop: currentToken stop.			^true].	(currentToken isIdentifier and: [currentToken value includes: $.]) 		ifTrue: 			[currentToken := RBLiteralToken 						value: currentToken value						start: currentToken start						stop: currentToken stop.			^true].	^false</body><body package="Browser-Parser" selector="step">step	(currentToken notNil and: [currentToken comments notNil]) 		ifTrue: [comments addAll: currentToken comments].	nextToken notNil 		ifTrue: 			[currentToken := nextToken.			nextToken := nil]		ifFalse: [currentToken := scanner next]</body></methods><methods><class-id>Refactory.Browser.RBParser</class-id> <category>private-classes</category><body package="Browser-Parser" selector="assignmentNodeClass">assignmentNodeClass	^RBAssignmentNode</body><body package="Browser-Parser" selector="blockNodeClass">blockNodeClass	^RBBlockNode</body><body package="Browser-Parser" selector="cascadeNodeClass">cascadeNodeClass	^RBCascadeNode</body><body package="Browser-Parser" selector="literalArrayNodeClass">literalArrayNodeClass	^RBLiteralArrayNode</body><body package="Browser-Parser" selector="literalNodeClass">literalNodeClass	^RBLiteralNode</body><body package="Browser-Parser" selector="messageNodeClass">messageNodeClass	^RBMessageNode</body><body package="Browser-Parser" selector="methodNodeClass">methodNodeClass	^RBMethodNode</body><body package="Browser-Parser" selector="optimizedNodeClass">optimizedNodeClass	^RBOptimizedNode</body><body package="Browser-Parser" selector="returnNodeClass">returnNodeClass	^RBReturnNode</body><body package="Browser-Parser" selector="sequenceNodeClass">sequenceNodeClass	^RBSequenceNode</body><body package="Browser-Parser" selector="variableNodeClass">variableNodeClass	^RBVariableNode</body></methods><methods><class-id>Refactory.Browser.RBParser</class-id> <category>testing</category><body package="Browser-Parser" selector="atEnd">atEnd	^currentToken class == RBToken</body><body package="Browser-Parser" selector="canHaveStatementsAfterReturn">canHaveStatementsAfterReturn	^false</body></methods><methods><class-id>Refactory.Browser.RBParser</class-id> <category>accessing</category><body package="Browser-Parser" selector="errorBlock:">errorBlock: aBlock 	errorBlock := aBlock.	scanner notNil ifTrue: [scanner errorBlock: aBlock]</body><body package="Browser-Parser" selector="initializeParserWith:">initializeParserWith: aString 	source := aString.	self scanner: (self scannerClass on: (ReadStream on: aString)				errorBlock: self errorBlock)</body><body package="Browser-Parser" selector="parseExpression:">parseExpression: aString 	| node |	node := self parseStatements: false.	(RBMethodNode selector: #noMethod body: node) source: aString.	"Make the sequence node have a method node as its parent"	self atEnd ifFalse: [self parserError: (#UnknownInputAtEnd &lt;&lt; #browser &gt;&gt; 'Unknown input at end')].	^node</body><body package="Browser-Parser" selector="parseMethod:">parseMethod: aString 	| node |	node := self parseMethod.	self atEnd ifFalse: [self parserError: (#UnknownInputAtEnd &lt;&lt; #browser &gt;&gt; 'Unknown input at end')].	node source: aString.	^node</body><body package="Browser-Parser" selector="scannerClass">scannerClass	^RBScanner</body></methods><methods><class-id>Refactory.Browser.RBParser</class-id> <category>error handling</category><body package="Browser-Parser" selector="errorBlock">errorBlock	^errorBlock isNil ifTrue: [[:message :position | ]] ifFalse: [errorBlock]</body><body package="Browser-Parser" selector="errorPosition">errorPosition	^currentToken start</body><body package="Browser-Parser" selector="parserError:">parserError: aString 	"Evaluate the block. If it returns raise an error"	self errorBlock value: aString value: self errorPosition.	self error: aString</body></methods><methods><class-id>Refactory.Browser.RBParser</class-id> <category>initialize-release</category><body package="Browser-Parser" selector="initializeForIBM">initializeForIBM	comments := OrderedCollection new.	emptyStatements := true.	scanner notNil ifTrue: [scanner initializeForIBM]</body><body package="Browser-Parser" selector="initializeForVisualWorks">initializeForVisualWorks	comments := OrderedCollection new.	emptyStatements := false.	scanner notNil ifTrue: [scanner initializeForVisualWorks]</body><body package="Browser-Parser" selector="scanner:">scanner: aScanner 	scanner := aScanner.	tags := nil.	self class isIBM 		ifTrue: [self initializeForIBM]		ifFalse: [self initializeForVisualWorks].	self step</body></methods><methods><class-id>Refactory.Browser.RBParser</class-id> <category>private-parsing</category><body package="Browser-Parser" selector="parseArgs">parseArgs	| args |	args := OrderedCollection new.	[currentToken isIdentifier] whileTrue: [args add: self parseVariableNode].	^args</body><body package="Browser-Parser" selector="parseAssignment">parseAssignment	"Need one token lookahead to see if we have a ':='. This method could 	make it possible to assign the literals true, false and nil."	| node position |	(currentToken isIdentifier and: [self nextToken isAssignment]) 		ifFalse: [^self parseCascadeMessage].	node := self parseVariableNode.	position := currentToken start.	self step.	^self assignmentNodeClass 		variable: node		value: self parseAssignment		position: position</body><body package="Browser-Parser" selector="parseBinaryMessage">parseBinaryMessage	| node |	node := self parseUnaryMessage.		[currentToken isLiteralToken ifTrue: [self patchNegativeLiteral].	currentToken isBinary] 			whileTrue: [node := self parseBinaryMessageWith: node].	^node</body><body package="Browser-Parser" selector="parseBinaryMessageWith:">parseBinaryMessageWith: aNode 	| binaryToken |	binaryToken := currentToken.	self step.	^self messageNodeClass 		receiver: aNode		selectorParts: (Array with: binaryToken)		arguments: (Array with: self parseUnaryMessage)</body><body package="Browser-Parser" selector="parseBinaryPattern">parseBinaryPattern	| binaryToken node args |	currentToken isBinary		ifFalse: [self parserError: (#MessagePatternExpected &lt;&lt; #browser &gt;&gt; 'Message pattern expected')].	binaryToken := currentToken.	self step.	args := Array with: self parseVariableNode.	node := self methodNodeClass		selectorParts: (Array with: binaryToken)		arguments: args.	node comments: node comments , args last comments.	args last comments: nil.	^node</body><body package="Browser-Parser" selector="parseBlock">parseBlock	| position node |	position := currentToken start.	self step.	node := self blockNodeClass new. 	self parseBlockArgsInto: node.	node left: position.	node body: (self parseStatements: false).	(currentToken isSpecial and: [currentToken value == $]])		ifFalse: [self parserError: (#CloseBracketExpected &lt;&lt; #browser &gt;&gt; ''']'' expected')].	node right: currentToken start.	self step.	^node</body><body package="Browser-Parser" selector="parseBlockArgsInto:">parseBlockArgsInto: node 	| verticalBar args colons |	args := OrderedCollection new: 2.	colons := OrderedCollection new: 2.	verticalBar := false.	[currentToken isSpecial and: [currentToken value == $:]] whileTrue: 			[colons add: currentToken start.			self step.	":"			verticalBar := true.			args add: self parseVariableNode].	verticalBar 		ifTrue: 			[currentToken isBinary 				ifTrue: 					[node bar: currentToken start.					currentToken value == #| 						ifTrue: [self step]						ifFalse: 							[currentToken value == #'||' 								ifTrue: 									["Hack the current token to be the start 									of temps bar"									currentToken										value: #|;										start: currentToken start + 1]								ifFalse: [self parserError: (#BarExpected &lt;&lt; #browser &gt;&gt; '''|'' expected')]]]				ifFalse: 					[(currentToken isSpecial and: [currentToken value == $]]) 						ifFalse: [self parserError: (#BarExpected &lt;&lt; #browser &gt;&gt; '''|'' expected')]]].	node		arguments: args;		colons: colons.	^node</body><body package="Browser-Parser" selector="parseCascadeMessage">parseCascadeMessage	| node receiver messages semicolons |	node := self parseKeywordMessage.	(currentToken isSpecial 		and: [currentToken value == $; and: [node isMessage]]) ifFalse: [^node].	receiver := node receiver.	messages := OrderedCollection new: 3.	semicolons := OrderedCollection new: 3.	messages add: node.	[currentToken isSpecial and: [currentToken value == $;]] whileTrue: 			[semicolons add: currentToken start.			self step.			messages add: (currentToken isIdentifier 						ifTrue: [self parseUnaryMessageWith: receiver]						ifFalse: 							[currentToken isKeyword 								ifTrue: [self parseKeywordMessageWith: receiver]								ifFalse: 									[| temp |									currentToken isLiteralToken ifTrue: [self patchNegativeLiteral].									currentToken isBinary ifFalse: [self parserError: (#MessageExpected &lt;&lt; #browser &gt;&gt; 'Message expected')].									temp := self parseBinaryMessageWith: receiver.									temp == receiver ifTrue: [self parserError: (#MessageExpected &lt;&lt; #browser &gt;&gt; 'Message expected')].									temp]])].	^self cascadeNodeClass messages: messages semicolons: semicolons</body><body package="Browser-Parser" selector="parseKeywordMessage">parseKeywordMessage	^self parseKeywordMessageWith: self parseBinaryMessage</body><body package="Browser-Parser" selector="parseKeywordMessageWith:">parseKeywordMessageWith: node 	| args isKeyword keywords |	args := OrderedCollection new: 3.	keywords := OrderedCollection new: 3.	isKeyword := false.	[currentToken isKeyword] whileTrue: 			[keywords add: currentToken.			self step.			args add: self parseBinaryMessage.			isKeyword := true].	^isKeyword 		ifTrue: 			[self messageNodeClass 				receiver: node				selectorParts: keywords				arguments: args]		ifFalse: [node]</body><body package="Browser-Parser" selector="parseKeywordPattern">parseKeywordPattern	| keywords args node |	keywords := OrderedCollection new: 2.	args := OrderedCollection new: 2.	[currentToken isKeyword]		whileTrue:			[keywords add: currentToken.			self step.			args add: self parseVariableNode].	node := self methodNodeClass		selectorParts: keywords		arguments: args.	node comments: (node comments, args last comments).	args last comments: nil.	^node</body><body package="Browser-Parser" selector="parseLiteralArray">parseLiteralArray	| stream start stop |	start := currentToken start.	stream := WriteStream on: (Array new: 5).	self step.	[self atEnd or: [currentToken isSpecial and: [currentToken value = $)]]] 		whileFalse: [stream nextPut: self parseLiteralArrayObject].	(currentToken isSpecial and: [currentToken value == $)]) 		ifFalse: [self parserError: (#CloseParenExpected &lt;&lt; #browser &gt;&gt; ''')'' expected')].	stop := currentToken stop.	self step.	^self literalArrayNodeClass 		startPosition: start		contents: stream contents		stopPosition: stop		isByteArray: false</body><body package="Browser-Parser" selector="parseLiteralArrayObject">parseLiteralArrayObject	currentToken isSpecial 		ifTrue: 			[currentToken value == $( ifTrue: [^self parseLiteralArray].			currentToken value == $[ ifTrue: [^self parseLiteralByteArray]].	currentToken isLiteralArrayToken 		ifTrue: 			[^currentToken isForByteArray 				ifTrue: [self parseLiteralByteArray]				ifFalse: [self parseLiteralArray]].	currentToken isOptimized ifTrue: [^self parseOptimizedExpression].	currentToken isLiteralToken ifFalse: [self patchLiteralArrayToken].	^self parsePrimitiveLiteral</body><body package="Browser-Parser" selector="parseLiteralByteArray">parseLiteralByteArray	| stream start stop |	start := currentToken start.	stream := WriteStream on: (Array new: 5).	self step.	[self atEnd or: [currentToken isSpecial and: [currentToken value = $]]]] 		whileFalse: [stream nextPut: self parseLiteralByteArrayObject].	(currentToken isSpecial and: [currentToken value == $]]) 		ifFalse: [self parserError: (#CloseBracketExpected &lt;&lt; #browser &gt;&gt; ''']'' expected')].	stop := currentToken stop.	self step.	^self literalArrayNodeClass 		startPosition: start		contents: stream contents		stopPosition: stop		isByteArray: true</body><body package="Browser-Parser" selector="parseLiteralByteArrayObject">parseLiteralByteArrayObject	(currentToken isLiteralToken and: 			[currentToken value isInteger and: [currentToken value between: 0 and: 255]]) 		ifFalse: [self parserError: (#Expecting8bitInteger &lt;&lt; #browser &gt;&gt; 'Expecting 8-bit integer')].	^self parsePrimitiveLiteral</body><body package="Browser-Parser" selector="parseMessagePattern">parseMessagePattern	currentToken isLiteralToken ifTrue: [self patchLiteralMessage].	^currentToken isIdentifier 		ifTrue: [self parseUnaryPattern]		ifFalse: 			[currentToken isKeyword 				ifTrue: [self parseKeywordPattern]				ifFalse: [self parseBinaryPattern]]</body><body package="Browser-Parser" selector="parseMethod">parseMethod	| methodNode | 	methodNode := self parseMessagePattern.	self parseResourceTag.	self addCommentsTo: methodNode.	methodNode body: (self parseStatements: true).	methodNode tags: tags.	^methodNode</body><body package="Browser-Parser" selector="parseOptimizedExpression">parseOptimizedExpression	| position node |	position := currentToken start.	self step.	node := self optimizedNodeClass 				left: position				body: (self parseStatements: false)				right: currentToken start.	(currentToken isSpecial and: [currentToken value == $)]) 		ifFalse: [self parserError: (#CloseParenExpected &lt;&lt; #browser &gt;&gt; ''')'' expected')].	self step.	^node</body><body package="Browser-Parser" selector="parseParenthesizedExpression">parseParenthesizedExpression	| leftParen node |	leftParen := currentToken start.	self step.	node := self parseAssignment.	^(currentToken isSpecial and: [currentToken value == $)])		ifTrue: 			[node addParenthesis: (leftParen to: currentToken start).			self step.			node]		ifFalse: [self parserError: (#CloseParenExpected &lt;&lt; #browser &gt;&gt; ''')'' expected')]</body><body package="Browser-Parser" selector="parsePrimitiveIdentifier">parsePrimitiveIdentifier	| token node |	token := currentToken.	self step.	node := self variableNodeClass identifierToken: token.	self addCommentsTo: node.	^node</body><body package="Browser-Parser" selector="parsePrimitiveLiteral">parsePrimitiveLiteral	| token |	token := currentToken.	self step.	^self literalNodeClass literalToken: token</body><body package="Browser-Parser" selector="parsePrimitiveObject">parsePrimitiveObject	currentToken isIdentifier ifTrue: [^self parsePrimitiveIdentifier].	(currentToken isLiteralToken and: [currentToken isMultiKeyword not]) 		ifTrue: [^self parsePrimitiveLiteral].	currentToken isLiteralArrayToken 		ifTrue: 			[^currentToken isForByteArray 				ifTrue: [self parseLiteralByteArray]				ifFalse: [self parseLiteralArray]].	currentToken isSpecial 		ifTrue: 			[currentToken value == $[ ifTrue: [^self parseBlock].			currentToken value == $( ifTrue: [^self parseParenthesizedExpression]].	currentToken isOptimized ifTrue: [^self parseOptimizedExpression].	self parserError: (#VariableExpected &lt;&lt; #browser &gt;&gt; 'Variable expected')</body><body package="Browser-Parser" selector="parseResourceTag">parseResourceTag	| start stop |	[currentToken isBinary and: [currentToken value == #&lt;]] whileTrue: 			[start := currentToken start.			stop := scanner skipUntil: $&gt;.			tags isNil 				ifTrue: [tags := OrderedCollection with: (start to: stop)]				ifFalse: [tags add: (start to: stop)].			self step]</body><body package="Browser-Parser" selector="parseStatementList:into:">parseStatementList: tagBoolean into: sequenceNode 	| statements return periods returnPosition node |	return := false.	statements := OrderedCollection new.	periods := OrderedCollection new.	self addCommentsTo: sequenceNode.	tagBoolean ifTrue: [self parseResourceTag].		[self atEnd 		or: [currentToken isSpecial and: ['])}' includes: currentToken value]]] 			whileFalse: 				[return ifTrue: [self parserError: (#EndOfStmtList &lt;&lt; #browser &gt;&gt; 'End of statement list encounted')].				(currentToken isSpecial and: [currentToken value == $^]) 					ifTrue: 						[returnPosition := currentToken start.						self step.						node := self returnNodeClass return: returnPosition									value: self parseAssignment.						statements add: node.						return := self canHaveStatementsAfterReturn not]					ifFalse: 						[node := self parseAssignment.						statements add: node].				(currentToken isSpecial and: [currentToken value == $.]) 					ifTrue: 						[periods add: currentToken start.						self step.						self addCommentsTo: node]					ifFalse: [return := true].				emptyStatements 					ifTrue: 						[[currentToken isSpecial and: [currentToken value == $.]] whileTrue: 								[periods add: currentToken start.								self step]]].	statements notEmpty ifTrue: [self addCommentsTo: statements last].	sequenceNode		statements: statements;		periods: periods.	^sequenceNode</body><body package="Browser-Parser" selector="parseStatements:">parseStatements: tagBoolean 	| args leftBar rightBar |	args := #().	leftBar := rightBar := nil.	currentToken isBinary 		ifTrue: 			[currentToken value == #| 				ifTrue: 					[leftBar := currentToken start.					self step.					args := self parseArgs.					(currentToken isBinary and: [currentToken value = #|]) 						ifFalse: [self parserError: (#BarExpected &lt;&lt; #browser &gt;&gt; '''|'' expected')].					rightBar := currentToken start.					self step]				ifFalse: 					[currentToken value == #'||' 						ifTrue: 							[rightBar := (leftBar := currentToken start) + 1.							self step]]].	^self parseStatementList: tagBoolean		into: (self sequenceNodeClass 				leftBar: leftBar				temporaries: args				rightBar: rightBar)</body><body package="Browser-Parser" selector="parseUnaryMessage">parseUnaryMessage	| node |	node := self parsePrimitiveObject.	self addCommentsTo: node.	[currentToken isLiteralToken ifTrue: [self patchLiteralMessage].	currentToken isIdentifier] 			whileTrue: [node := self parseUnaryMessageWith: node].	self addCommentsTo: node.	^node</body><body package="Browser-Parser" selector="parseUnaryMessageWith:">parseUnaryMessageWith: aNode 	| selector |	selector := currentToken.	self step.	^self messageNodeClass 		receiver: aNode		selectorParts: (Array with: selector)		arguments: #()</body><body package="Browser-Parser" selector="parseUnaryPattern">parseUnaryPattern	| selector |	selector := currentToken.	self step.	^self methodNodeClass selectorParts: (Array with: selector) arguments: #()</body><body package="Browser-Parser" selector="parseVariableNode">parseVariableNode	currentToken isIdentifier 		ifFalse: [self parserError: (#VariableNameExpected &lt;&lt; #browser &gt;&gt; 'Variable name expected')].	^self parsePrimitiveIdentifier</body></methods><methods><class-id>Refactory.Browser.RBParser class</class-id> <category>class initialization</category><body package="Browser-Parser" selector="initialize">initialize	"Try to determine which image we're running in"	ParserType := #VisualWorks</body></methods><methods><class-id>Refactory.Browser.RBParser class</class-id> <category>testing</category><body package="Browser-Parser" selector="isIBM">isIBM	^ParserType == #IBM</body><body package="Browser-Parser" selector="isVisualWorks">isVisualWorks	^ParserType == #VisualWorks</body></methods><methods><class-id>Refactory.Browser.RBParser class</class-id> <category>accessing</category><body package="Browser-Parser" selector="parseExpression:">parseExpression: aString 	^self parseExpression: aString onError: nil</body><body package="Browser-Parser" selector="parseExpression:onError:">parseExpression: aString onError: aBlock 	| node parser |	parser := self new.	parser errorBlock: aBlock.	parser initializeParserWith: aString.	node := parser parseExpression: aString.	^(node statements size == 1 and: [node temporaries isEmpty]) 		ifTrue: [node statements first]		ifFalse: [node]</body><body package="Browser-Parser" selector="parseMethod:">parseMethod: aString 	^self parseMethod: aString onError: nil</body><body package="Browser-Parser" selector="parseMethod:onError:">parseMethod: aString onError: aBlock 	| parser |	parser := self new.	parser errorBlock: aBlock.	parser initializeParserWith: aString.	^parser parseMethod: aString</body><body package="Browser-Parser" selector="parseRewriteExpression:">parseRewriteExpression: aString 	^self parseRewriteExpression: aString onError: nil</body><body package="Browser-Parser" selector="parseRewriteExpression:onError:">parseRewriteExpression: aString onError: aBlock 	^RBPatternParser parseExpression: aString onError: aBlock</body><body package="Browser-Parser" selector="parseRewriteMethod:">parseRewriteMethod: aString 	^self parseRewriteMethod: aString onError: nil</body><body package="Browser-Parser" selector="parseRewriteMethod:onError:">parseRewriteMethod: aString onError: aBlock 	^RBPatternParser parseMethod: aString onError: aBlock</body></methods><methods><class-id>Refactory.Browser.RBParser class</class-id> <category>parsing</category><body package="Browser-Parser" selector="parseMethodPattern:">parseMethodPattern: aString 	| parser |	parser := self new.	parser errorBlock: [:error :position | ^nil].	parser initializeParserWith: aString.	^parser parseMessagePattern selector</body></methods><methods><class-id>Refactory.Browser.RBVariableNode</class-id> <category>comparing</category><body package="Browser-Parser" selector="=">= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	^self name = anObject name</body><body package="Browser-Parser" selector="equalTo:withMapping:">equalTo: anObject withMapping: aDictionary 	^self class = anObject class and: 			[(aDictionary at: self name ifAbsentPut: [anObject name]) = anObject name]</body><body package="Browser-Parser" selector="hash">hash	^self name hash</body></methods><methods><class-id>Refactory.Browser.RBVariableNode</class-id> <category>visitor</category><body package="Browser-Parser" selector="acceptVisitor:">acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptVariableNode: self</body></methods><methods><class-id>Refactory.Browser.RBVariableNode</class-id> <category>matching</category><body package="Browser-Parser" selector="copyInContext:">copyInContext: aDictionary 	^self class identifierToken: token removePositions</body></methods><methods><class-id>Refactory.Browser.RBVariableNode</class-id> <category>initialize-release</category><body package="Browser-Parser" selector="identifierToken:">identifierToken: anIdentifierToken 	token := anIdentifierToken</body></methods><methods><class-id>Refactory.Browser.RBVariableNode</class-id> <category>testing</category><body package="Browser-Parser" selector="isImmediateNode">isImmediateNode	^true</body><body package="Browser-Parser" selector="isVariable">isVariable	^true</body><body package="Browser-Parser" selector="needsParenthesis">needsParenthesis	^false</body><body package="Browser-Parser" selector="references:">references: aVariableName 	^self name = aVariableName</body></methods><methods><class-id>Refactory.Browser.RBVariableNode</class-id> <category>accessing</category><body package="Browser-Parser" selector="name">name	^token value</body><body package="Browser-Parser" selector="precedence">precedence	^0</body><body package="Browser-Parser" selector="startWithoutParentheses">startWithoutParentheses	^token start</body><body package="Browser-Parser" selector="stopWithoutParentheses">stopWithoutParentheses	^token stop</body></methods><methods><class-id>Refactory.Browser.RBVariableNode</class-id> <category>replacing</category><body package="Browser-Parser" selector="replaceSourceFrom:">replaceSourceFrom: aNode 	self addReplacement: (RBStringReplacement 				replaceFrom: aNode start				to: aNode stop				with: self name)</body><body package="Browser-Parser" selector="replaceSourceWith:">replaceSourceWith: aNode	self addReplacement: (RBStringReplacement 				replaceFrom: self start				to: self stop				with: aNode formattedCode)</body></methods><methods><class-id>Refactory.Browser.RBVariableNode class</class-id> <category>instance creation</category><body package="Browser-Parser" selector="identifierToken:">identifierToken: anIdentifierToken 	^(self new)		identifierToken: anIdentifierToken;		yourself</body><body package="Browser-Parser" selector="named:">named: aString 	^self identifierToken: (RBIdentifierToken value: aString start: 0)</body></methods><methods><class-id>Refactory.Browser.RBStringReplacement</class-id> <category>accessing</category><body package="Browser-Parser" selector="startPosition">startPosition	^startPosition</body><body package="Browser-Parser" selector="stopPosition">stopPosition	^stopPosition</body><body package="Browser-Parser" selector="string">string	^string</body></methods><methods><class-id>Refactory.Browser.RBStringReplacement</class-id> <category>initialize-release</category><body package="Browser-Parser" selector="startPosition:">startPosition: anInteger 	startPosition := anInteger</body><body package="Browser-Parser" selector="stopPosition:">stopPosition: anInteger 	stopPosition := anInteger</body><body package="Browser-Parser" selector="string:">string: aString 	string := aString</body></methods><methods><class-id>Refactory.Browser.RBStringReplacement class</class-id> <category>instance creation</category><body package="Browser-Parser" selector="replaceFrom:to:with:">replaceFrom: startInteger to: stopInteger with: aString 	^(self new)		startPosition: startInteger;		stopPosition: stopInteger;		string: aString;		yourself</body></methods><methods><class-id>Refactory.Browser.RBScanner</class-id> <category>testing</category><body package="Browser-Parser" selector="atEnd">atEnd	^characterType == #eof</body><body package="Browser-Parser" selector="isReadable">isReadable	^true</body><body package="Browser-Parser" selector="isWritable">isWritable	^false</body></methods><methods><class-id>Refactory.Browser.RBScanner</class-id> <category>accessing</category><body package="Browser-Parser" selector="contents">contents	| contentsStream |	contentsStream := WriteStream on: (Array new: 50).	self do: [:each | contentsStream nextPut: each].	^contentsStream contents</body><body package="Browser-Parser" selector="errorBlock:">errorBlock: aBlock 	errorBlock := aBlock</body><body package="Browser-Parser" selector="flush">flush</body><body package="Browser-Parser" selector="getComments">getComments	| oldComments |	comments isEmpty ifTrue: [^nil].	oldComments := comments.	comments := OrderedCollection new: 1.	^oldComments</body><body package="Browser-Parser" selector="next">next	| token |	buffer reset.	tokenStart := stream position.	token := characterType == #eof 				ifTrue: 					[RBToken start: tokenStart + 1	"The EOF token should occur after the end of input"]				ifFalse: [self scanToken].	self stripSeparators.	token comments: self getComments.	^token</body><body package="Browser-Parser" selector="nextPut:">nextPut: anObject 	"Provide an error notification that the receiver does not	implement this message."	self shouldNotImplement</body><body package="Browser-Parser" selector="scanToken">scanToken	"fast-n-ugly. Don't write stuff like this. Has been found to cause cancer in laboratory rats. Basically a 	case statement. Didn't use Dictionary because lookup is pretty slow."	characterType == #alphabetic ifTrue: [^self scanIdentifierOrKeyword].	(characterType == #digit 		or: [currentCharacter == $- and: [(self classify: stream peek) == #digit]]) 			ifTrue: [^self scanNumber].	characterType == #binary ifTrue: [^self scanBinary: RBBinarySelectorToken].	characterType == #special ifTrue: [^self scanSpecialCharacter].	currentCharacter == $' ifTrue: [^self scanLiteralString].	currentCharacter == $# ifTrue: [^self scanLiteral].	currentCharacter == $$ ifTrue: [^self scanLiteralCharacter].	^self scannerError: (#UnknownCharacter &lt;&lt; #browser &gt;&gt; 'Unknown character')</body><body package="Browser-Parser" selector="skipUntil:">skipUntil: aCharacter 	| position |	(stream skipThrough: aCharacter) isNil 		ifTrue: [self scannerError: ((#x1sNotFound &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; not found')			expandMacrosWith: (String with: aCharacter))].	position := stream position.	self step.	self stripSeparators.	^position</body></methods><methods><class-id>Refactory.Browser.RBScanner</class-id> <category>private</category><body package="Browser-Parser" selector="classify:">classify: aCharacter 	| index |	aCharacter isNil ifTrue: [^nil].	index := aCharacter asInteger.	index == 0 ifTrue: [^#separator].	index &gt; 255 		ifTrue: 			[^aCharacter isLetter 				ifTrue: [#alphabetic]				ifFalse: [aCharacter isSeparator ifTrue: [#separator] ifFalse: [nil]]].	^classificationTable at: index</body><body package="Browser-Parser" selector="previousStepPosition">previousStepPosition	^characterType == #eof 		ifTrue: [stream position]		ifFalse: [stream position - 1]</body><body package="Browser-Parser" selector="step">step	stream atEnd 		ifTrue: 			[characterType := #eof.			^currentCharacter := nil].	currentCharacter := stream next.	characterType := self classify: currentCharacter.	^currentCharacter</body></methods><methods><class-id>Refactory.Browser.RBScanner</class-id> <category>error handling</category><body package="Browser-Parser" selector="errorBlock">errorBlock	^errorBlock isNil ifTrue: [[:message :position | ]] ifFalse: [errorBlock]</body><body package="Browser-Parser" selector="errorPosition">errorPosition	^stream position</body><body package="Browser-Parser" selector="scannerError:">scannerError: aString 	"Evaluate the block. If it returns raise an error"	self errorBlock value: aString value: self errorPosition.	self error: aString</body></methods><methods><class-id>Refactory.Browser.RBScanner</class-id> <category>initialize-release</category><body package="Browser-Parser" selector="initializeForIBM">initializeForIBM	numberType := #scanNumberIBM.	separatorsInLiterals := false.	extendedLiterals := true.	nameSpaceCharacter := $:</body><body package="Browser-Parser" selector="initializeForVisualWorks">initializeForVisualWorks	numberType := #scanNumberVisualWorks.	separatorsInLiterals := true.	extendedLiterals := false.	nameSpaceCharacter := $.</body><body package="Browser-Parser" selector="on:">on: aStream 	buffer := WriteStream on: (String new: 60).	stream := aStream.	classificationTable := self class classificationTable.	comments := OrderedCollection new.	RBParser isIBM 		ifTrue: [self initializeForIBM]		ifFalse: [self initializeForVisualWorks]</body></methods><methods><class-id>Refactory.Browser.RBScanner</class-id> <category>private-scanning</category><body package="Browser-Parser" selector="scanAnySymbol">scanAnySymbol	characterType == #alphabetic ifTrue: [^self scanSymbol].	characterType == #binary ifTrue: [^self scanBinary: RBLiteralToken].	^RBToken new</body><body package="Browser-Parser" selector="scanBinary:">scanBinary: aClass 	"This doesn't parse according to the ANSI draft. It only parses 1 or 2 letter binary tokens."	| val |	buffer nextPut: currentCharacter.	self step.	(characterType == #binary and: [currentCharacter ~~ $-]) 		ifTrue: 			[buffer nextPut: currentCharacter.			self step].	val := buffer contents.	val := val asSymbol.	^aClass value: val start: tokenStart</body><body package="Browser-Parser" selector="scanExponentMultipler">scanExponentMultipler	| exponent isExpNegative position |	currentCharacter == $e		ifTrue: 			[position := stream position.			self step.			(isExpNegative := currentCharacter == $-) ifTrue: [self step].			exponent := self scanNumberOfBase: 10.			exponent isNil				ifTrue: 					["Did not read a valid exponent, e must be start of a message send"					stream position: position - 1.					self step.					exponent := 0]				ifFalse: [isExpNegative ifTrue: [exponent := exponent negated]]]		ifFalse: [exponent := 0].	^10 raisedToInteger: exponent</body><body package="Browser-Parser" selector="scanExtendedLiterals">scanExtendedLiterals	| token |	self step.	separatorsInLiterals ifTrue: [self stripSeparators].	token := characterType == #alphabetic 				ifTrue: [self scanSymbol]				ifFalse: 					[characterType == #binary 						ifTrue: [(self scanBinary: RBLiteralToken) stop: self previousStepPosition]						ifFalse: 							[currentCharacter == $' 								ifTrue: [self scanStringSymbol]								ifFalse: 									[currentCharacter == $( 										ifTrue: 											[self step.											^RBOptimizedToken start: tokenStart]]]].	token isNil ifTrue: [self scannerError: (#ExpectingAnExtendedLiteral &lt;&lt; #browser &gt;&gt; 'Expecting an extended literal')].	token value: ((Smalltalk at: #EsAtom) intern: token value asString).	^token</body><body package="Browser-Parser" selector="scanIdentifierOrKeyword">scanIdentifierOrKeyword	| token name |	self scanName.	currentCharacter == nameSpaceCharacter 		ifTrue: 			[token := self scanNameSpaceName.			token notNil ifTrue: [^token]].	(currentCharacter == $: and: [stream peek ~~ $=]) 		ifTrue: [^self scanKeyword].	name := buffer contents.	name = 'true' 		ifTrue: 			[^RBLiteralToken 				value: true				start: tokenStart				stop: self previousStepPosition].	name = 'false' 		ifTrue: 			[^RBLiteralToken 				value: false				start: tokenStart				stop: self previousStepPosition].	name = 'nil' 		ifTrue: 			[^RBLiteralToken 				value: nil				start: tokenStart				stop: self previousStepPosition].	^RBIdentifierToken value: name start: tokenStart</body><body package="Browser-Parser" selector="scanKeyword">scanKeyword	| outputPosition inputPosition name |	[currentCharacter == $:] whileTrue: 			[buffer nextPut: currentCharacter.			outputPosition := buffer position.			inputPosition := stream position.			self step.	":"			[characterType == #alphabetic] whileTrue: [self scanName]].	buffer position: outputPosition.	stream position: inputPosition.	self step.	name := buffer contents.	^(name occurrencesOf: $:) == 1 		ifTrue: [RBKeywordToken value: name start: tokenStart]		ifFalse: 			[RBMultiKeywordLiteralToken 				value: name asSymbol				start: tokenStart				stop: tokenStart + name size - 1]</body><body package="Browser-Parser" selector="scanLiteral">scanLiteral	self step.	separatorsInLiterals ifTrue: [self stripSeparators].	characterType == #alphabetic ifTrue: [^self scanSymbol].	characterType == #binary 		ifTrue: [^(self scanBinary: RBLiteralToken) stop: self previousStepPosition].	currentCharacter == $' ifTrue: [^self scanStringSymbol].	(currentCharacter == $( or: [currentCharacter == $[]) 		ifTrue: [^self scanLiteralArrayToken].	(separatorsInLiterals and: [currentCharacter == ${]) 		ifTrue: [^self scanQualifiedReference].	(extendedLiterals and: [currentCharacter == $#]) 		ifTrue: [^self scanExtendedLiterals].	self scannerError: (#ExpectingALiteralType &lt;&lt; #browser &gt;&gt; 'Expecting a literal type')</body><body package="Browser-Parser" selector="scanLiteralArrayToken">scanLiteralArrayToken	| token |	token := RBLiteralArrayToken 				value: (String with: $# with: currentCharacter)				start: tokenStart.	self step.	^token</body><body package="Browser-Parser" selector="scanLiteralCharacter">scanLiteralCharacter	| token |	self step.	"$"	token := RBLiteralToken 				value: currentCharacter				start: tokenStart				stop: stream position.	self step.	"char"	^token</body><body package="Browser-Parser" selector="scanLiteralString">scanLiteralString	self step.		[currentCharacter isNil 		ifTrue: [self scannerError: (#UnmatchedQuoteInString &lt;&lt; #browser &gt;&gt; 'Unmatched '' in string literal.')].	currentCharacter == $' and: [self step ~~ $']] 			whileFalse: 				[buffer nextPut: currentCharacter.				self step].	^RBLiteralToken 		value: buffer contents		start: tokenStart		stop: self previousStepPosition</body><body package="Browser-Parser" selector="scanName">scanName	[characterType == #alphabetic or: [characterType == #digit]] whileTrue: 			[buffer nextPut: currentCharacter.			self step]</body><body package="Browser-Parser" selector="scanNameSpaceName">scanNameSpaceName	extendedLiterals 		ifTrue: 			[stream peek == $: ifFalse: [^nil].			buffer next: 2 put: $:.			self step]		ifFalse: 			[(stream atEnd or: [(self classify: stream peek) ~~ #alphabetic]) 				ifTrue: [^nil].			buffer nextPut: $.].	self step.	self scanName.	currentCharacter == nameSpaceCharacter ifTrue: [self scanNameSpaceName].	^RBIdentifierToken value: buffer contents start: tokenStart</body><body package="Browser-Parser" selector="scanNumber">scanNumber	| start number stop string currentPosition |	start := stream position.	number := self perform: numberType.	currentPosition := stream position.	stop := self atEnd ifTrue: [currentPosition] ifFalse: [currentPosition - 1].	stream position: start - 1.	string := stream next: stop - start + 1.	stream position: currentPosition.	^RBNumberLiteralToken 		value: number		start: start		stop: stop		source: string</body><body package="Browser-Parser" selector="scanNumberIBM">scanNumberIBM	| number isNegative |	isNegative := false.	currentCharacter == $- 		ifTrue: 			[isNegative := true.			self step].	number := self scanNumberWithoutExponent.	^(isNegative ifTrue: [number negated] ifFalse: [number]) 		* self scanExponentMultipler</body><body package="Browser-Parser" selector="scanNumberOfBase:">scanNumberOfBase: anInteger 	"Scan a number. Return the number or nil if the current input isn't a valid number."	| number digits fraction isFloat succeeded |	digits := '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' copyFrom: 1 to: anInteger.	number := 0.	succeeded := false.	[digits includes: currentCharacter] whileTrue: 			[number := number * anInteger + (digits indexOf: currentCharacter) - 1.			self step.			succeeded := true].	succeeded ifFalse: [^nil].	isFloat := false.	(currentCharacter == $. and: [digits includes: stream peek]) 		ifTrue: 			[self step.			isFloat := true.			fraction := 1 / anInteger.			[digits includes: currentCharacter] whileTrue: 					[number := number + (((digits indexOf: currentCharacter) - 1) * fraction).					fraction := fraction / anInteger.					self step]].	^isFloat ifTrue: [number asFloat] ifFalse: [number]</body><body package="Browser-Parser" selector="scanNumberVisualWorks">scanNumberVisualWorks	| number |	stream skip: -1.	number := Number readSmalltalkSyntaxFrom: stream.	self step.	^number</body><body package="Browser-Parser" selector="scanNumberWithoutExponent">scanNumberWithoutExponent	"Scan an IBM number with the radix -- don't scan the exponent though"	| number base |	base := self scanNumberOfBase: 10.	(currentCharacter == $r and: [base isInteger]) 		ifTrue: 			[| position |			position := stream position.			self step.			number := self scanNumberOfBase: base.			number isNil 				ifTrue: 					["Did not read a correct number, r must be start of a message send."					stream position: position - 1.					self step.					number := base]]		ifFalse: [number := base].	^number</body><body package="Browser-Parser" selector="scanPatternVariable">scanPatternVariable	buffer nextPut: currentCharacter.	self step.	currentCharacter == ${ 		ifTrue: 			[self step.			^RBPatternBlockToken value: '`{' start: tokenStart].	[characterType == #alphabetic] whileFalse: 			[characterType == #eof 				ifTrue: [self scannerError: (#MetaVariableExpected &lt;&lt; #browser &gt;&gt; 'Meta variable expected')].			buffer nextPut: currentCharacter.			self step].	^self scanIdentifierOrKeyword</body><body package="Browser-Parser" selector="scanQualifiedReference">scanQualifiedReference	| nameToken |	self step.	"{"	self stripSeparators.	nameToken := self scanIdentifierOrKeyword.	(nameToken isIdentifier and: [nameToken value notEmpty]) 		ifFalse: [self scannerError: (#InvalidNameInQRef &lt;&lt; #browser &gt;&gt; 'Invalid name in qualified reference')].	self stripSeparators.	currentCharacter == $} ifFalse: [self scannerError: (#CloseBraceExpected &lt;&lt; #browser &gt;&gt; '} expected')].	self step.	"}"	^RBLiteralToken 		value: (BindingReference pathString: nameToken value)		start: tokenStart		stop: self previousStepPosition</body><body package="Browser-Parser" selector="scanSpecialCharacter">scanSpecialCharacter	| character |	currentCharacter == $: 		ifTrue: 			[self step.			^currentCharacter == $= 				ifTrue: 					[self step.					RBAssignmentToken start: tokenStart]				ifFalse: [RBSpecialCharacterToken value: $: start: tokenStart]].	character := currentCharacter.	self step.	^RBSpecialCharacterToken value: character start: tokenStart</body><body package="Browser-Parser" selector="scanStringSymbol">scanStringSymbol	| literalToken |	literalToken := self scanLiteralString.	literalToken value: literalToken value asSymbol.	^literalToken</body><body package="Browser-Parser" selector="scanSymbol">scanSymbol	| lastPosition hasColon value startPosition |	hasColon := false.	startPosition := lastPosition := stream position.	[characterType == #alphabetic] whileTrue: 			[self scanName.			currentCharacter == $: 				ifTrue: 					[buffer nextPut: $:.					hasColon := true.					lastPosition := stream position.					self step]].	value := buffer contents.	(hasColon and: [value last ~~ $:]) 		ifTrue: 			[stream position: lastPosition.			self step.			value := value copyFrom: 1 to: lastPosition - startPosition + 1].	^RBLiteralToken 		value: value asSymbol		start: tokenStart		stop: self previousStepPosition</body><body package="Browser-Parser" selector="stripComment">stripComment	| start stop |	start := stream position.	[self step == $"] whileFalse: 			[characterType == #eof				ifTrue: [self scannerError: (#UnmatchedQuoteInComment &lt;&lt; #browser &gt;&gt; 'Unmatched " in comment.')]].	stop := stream position.	self step.	comments add: (start to: stop)</body><body package="Browser-Parser" selector="stripSeparators">stripSeparators		[[characterType == #separator] whileTrue: [self step].	currentCharacter == $"] 			whileTrue: [self stripComment]</body></methods><methods><class-id>Refactory.Browser.RBScanner class</class-id> <category>accessing</category><body package="Browser-Parser" selector="classificationTable">classificationTable	classificationTable isNil ifTrue: [self initializeClassificationTable].	^classificationTable</body><body package="Browser-Parser" selector="patternVariableCharacter">patternVariableCharacter	^PatternVariableCharacter</body></methods><methods><class-id>Refactory.Browser.RBScanner class</class-id> <category>class initialization</category><body package="Browser-Parser" selector="initialize">initialize	self initializeClassificationTable</body><body package="Browser-Parser" selector="initializeChars:to:">initializeChars: characters to: aSymbol 	characters do: [:c | classificationTable at: c asInteger put: aSymbol]</body><body package="Browser-Parser" selector="initializeClassificationTable">initializeClassificationTable	| allCharacters |	PatternVariableCharacter := $`.	classificationTable := Array new: 255.	allCharacters := (1 to: 255) collect: [:i | Character value: i].	self initializeChars: (allCharacters select: [:each | each isLetter])		to: #alphabetic.	self initializeChars: '_' to: #alphabetic.	self initializeChars: '01234567890' to: #digit.	self initializeChars: '!%&amp;*+,-/&lt;=&gt;?@\~|' to: #binary.	classificationTable at: 177 put: #binary.	"plus-or-minus"	classificationTable at: 183 put: #binary.	"centered dot"	classificationTable at: 215 put: #binary.	"times"	classificationTable at: 247 put: #binary.	"divide"	self initializeChars: '().:;[]^' to: #special.	self initializeChars: (allCharacters select: [:each | each isSeparator])		to: #separator</body></methods><methods><class-id>Refactory.Browser.RBScanner class</class-id> <category>testing</category><body package="Browser-Parser" selector="isSelector:">isSelector: aSymbol 	| scanner token |	scanner := self basicNew.	scanner on: (ReadStream on: aSymbol asString).	scanner step.	token := scanner scanAnySymbol.	token isLiteralToken ifFalse: [^false].	token value isEmpty ifTrue: [^false].	^scanner atEnd</body><body package="Browser-Parser" selector="isVariable:">isVariable: aString 	| scanner token |	scanner := self on: (ReadStream on: aString) errorBlock: [:s :p | ^false].	token := scanner next.	token isIdentifier ifFalse: [^false].	(token start = 1 and: [token stop = aString size]) ifFalse: [^false].	^(aString includes: $.) not</body></methods><methods><class-id>Refactory.Browser.RBScanner class</class-id> <category>instance creation</category><body package="Browser-Parser" selector="on:">on: aStream 	| str |	str := self basicNew on: aStream.	str		step;		stripSeparators.	^str</body><body package="Browser-Parser" selector="on:errorBlock:">on: aStream errorBlock: aBlock 	| str |	str := self basicNew on: aStream.	str		errorBlock: aBlock;		step;		stripSeparators.	^str</body></methods><methods><class-id>Refactory.Browser.RBPatternScanner</class-id> <category>accessing</category><body package="Browser-Parser" selector="scanToken">scanToken	currentCharacter == PatternVariableCharacter 		ifTrue: [^self scanPatternVariable].	currentCharacter == $} ifTrue: [^self scanSpecialCharacter].	^super scanToken</body></methods><methods><class-id>Refactory.Browser.RBSpecialCharacterToken</class-id> <category>testing</category><body package="Browser-Parser" selector="isSpecial">isSpecial	^true</body></methods><methods><class-id>Refactory.Browser.RBSpecialCharacterToken</class-id> <category>private</category><body package="Browser-Parser" selector="length">length	^1</body></methods><methods><class-id>Refactory.Browser.RBPatternVariableNode</class-id> <category>initialize-release</category><body package="Browser-Parser" selector="identifierToken:">identifierToken: anIdentifierToken 	super identifierToken: anIdentifierToken.	self initializePatternVariables</body><body package="Browser-Parser" selector="initializePatternVariables">initializePatternVariables	| name |	name := self name.	isAnything := isList := isLiteral := isStatement := recurseInto := false.	2 to: name size		do: 			[:i | 			| character |			character := name at: i.			character == self listCharacter 				ifTrue: [isAnything := isList := true]				ifFalse: 					[character == self literalCharacter 						ifTrue: [isLiteral := true]						ifFalse: 							[character == self statementCharacter 								ifTrue: [isStatement := true]								ifFalse: 									[character == self recurseIntoCharacter 										ifTrue: [recurseInto := true]										ifFalse: [^self]]]]]</body></methods><methods><class-id>Refactory.Browser.RBPatternVariableNode</class-id> <category>testing-matching</category><body package="Browser-Parser" selector="isAnything">isAnything	^isAnything</body><body package="Browser-Parser" selector="isList">isList	^isList</body><body package="Browser-Parser" selector="isLiteralNode">isLiteralNode	^isLiteral</body><body package="Browser-Parser" selector="isPatternNode">isPatternNode	^true</body><body package="Browser-Parser" selector="isStatement">isStatement	^isStatement</body><body package="Browser-Parser" selector="recurseInto">recurseInto	^recurseInto</body></methods><methods><class-id>Refactory.Browser.RBPatternVariableNode</class-id> <category>private</category><body package="Browser-Parser" selector="matchingClass">matchingClass	^RBVariableNode</body></methods><methods><class-id>Refactory.Browser.RBPatternVariableNode</class-id> <category>matching</category><body package="Browser-Parser" selector="copyInContext:">copyInContext: aDictionary 	^(aDictionary at: self) copy</body><body package="Browser-Parser" selector="match:inContext:">match: aNode inContext: aDictionary 	self isAnything 		ifTrue: [^(aDictionary at: self ifAbsentPut: [aNode]) = aNode].	self isLiteralNode ifTrue: [^self matchLiteral: aNode inContext: aDictionary].	self isStatement 		ifTrue: [^self matchStatement: aNode inContext: aDictionary].	aNode class == self matchingClass ifFalse: [^false].	^(aDictionary at: self ifAbsentPut: [aNode]) = aNode</body><body package="Browser-Parser" selector="matchLiteral:inContext:">matchLiteral: aNode inContext: aDictionary 	^aNode isLiteralNode		and: [(aDictionary at: self ifAbsentPut: [aNode]) = aNode]</body><body package="Browser-Parser" selector="matchStatement:inContext:">matchStatement: aNode inContext: aDictionary 	(aNode parent notNil and: [aNode parent isSequence]) ifFalse: [^false].	^(aDictionary at: self ifAbsentPut: [aNode]) = aNode</body></methods><methods><class-id>Refactory.Browser.RBPatternVariableNode</class-id> <category>accessing</category><body package="Browser-Parser" selector="parent:">parent: aBRProgramNode 	"Fix the case where '``@node' should match a single node, not a sequence node."	super parent: aBRProgramNode.	parent isSequence 		ifTrue: 			[(self isStatement or: [parent temporaries includes: self]) 				ifFalse: [isList := false]]</body></methods><methods><class-id>Refactory.Browser.RBPatternVariableNode class</class-id> <category>instance creation</category><body package="Browser-Parser" selector="identifierToken:">identifierToken: anIdentifierToken 	^anIdentifierToken isPatternVariable 		ifTrue: [super identifierToken: anIdentifierToken]		ifFalse: [RBVariableNode identifierToken: anIdentifierToken]</body></methods><methods><class-id>Refactory.Browser.ParseTreeRewriter</class-id> <category>visitor-double dispatching</category><body package="Browser-Parser" selector="acceptAssignmentNode:">acceptAssignmentNode: anAssignmentNode 	anAssignmentNode variable: (self visitNode: anAssignmentNode variable).	anAssignmentNode value: (self visitNode: anAssignmentNode value)</body><body package="Browser-Parser" selector="acceptBlockNode:">acceptBlockNode: aBlockNode 	aBlockNode arguments: (self visitArguments: aBlockNode arguments).	aBlockNode body: (self visitNode: aBlockNode body)</body><body package="Browser-Parser" selector="acceptCascadeNode:">acceptCascadeNode: aCascadeNode 	| newMessages notFound |	newMessages := OrderedCollection new: aCascadeNode messages size.	notFound := OrderedCollection new: aCascadeNode messages size.	aCascadeNode messages do: 			[:each | 			| newNode |			newNode := self performSearches: searches on: each.			newNode isNil 				ifTrue: 					[newNode := each.					notFound add: newNode].			newNode isMessage 				ifTrue: [newMessages add: newNode]				ifFalse: 					[newNode isCascade 						ifTrue: [newMessages addAll: newNode messages]						ifFalse: 							[Transcript								cr; 								show: (#CannotReplaceMsgInCascade &lt;&lt; #browser &gt;&gt; 'Cannot replace message node inside of cascaded node with non-message node.').							newMessages add: each]]].	notFound size == aCascadeNode messages size 		ifTrue: 			[| receiver |			receiver := self visitNode: aCascadeNode messages first receiver.			newMessages do: [:each | each receiver: receiver]].	notFound 		do: [:each | each arguments: (each arguments collect: [:arg | self visitNode: arg])].	aCascadeNode messages: newMessages</body><body package="Browser-Parser" selector="acceptLiteralArrayNode:">acceptLiteralArrayNode: aRBArrayLiteralNode 	aRBArrayLiteralNode contents: (aRBArrayLiteralNode contents 				collect: [:each | self visitNode: each])</body><body package="Browser-Parser" selector="acceptMessageNode:">acceptMessageNode: aMessageNode 	aMessageNode receiver: (self visitNode: aMessageNode receiver).	aMessageNode 		arguments: (aMessageNode arguments collect: [:each | self visitNode: each])</body><body package="Browser-Parser" selector="acceptMethodNode:">acceptMethodNode: aMethodNode 	aMethodNode arguments: (self visitArguments: aMethodNode arguments).	aMethodNode body: (self visitNode: aMethodNode body)</body><body package="Browser-Parser" selector="acceptOptimizedNode:">acceptOptimizedNode: anOptimizedNode 	anOptimizedNode body: (self visitNode: anOptimizedNode body)</body><body package="Browser-Parser" selector="acceptReturnNode:">acceptReturnNode: aReturnNode 	aReturnNode value: (self visitNode: aReturnNode value)</body><body package="Browser-Parser" selector="acceptSequenceNode:">acceptSequenceNode: aSequenceNode 	aSequenceNode 		temporaries: (self visitArguments: aSequenceNode temporaries).	aSequenceNode statements: (aSequenceNode statements 				collect: [:each | self visitNode: each])</body></methods><methods><class-id>Refactory.Browser.ParseTreeRewriter</class-id> <category>accessing</category><body package="Browser-Parser" selector="executeTree:">executeTree: aParseTree 	| oldContext |	oldContext := context.	context := RBSmallDictionary new.	answer := false.	tree := self visitNode: aParseTree.	context := oldContext.	^answer</body><body package="Browser-Parser" selector="tree">tree	^tree</body></methods><methods><class-id>Refactory.Browser.ParseTreeRewriter</class-id> <category>private</category><body package="Browser-Parser" selector="foundMatch">foundMatch	answer := true</body><body package="Browser-Parser" selector="lookForMoreMatchesInContext:">lookForMoreMatchesInContext: oldContext 	oldContext keysAndValuesDo: 			[:key :value | 			(key isString not and: [key recurseInto]) 				ifTrue: 					[oldContext at: key put: (value collect: [:each | self visitNode: each])]]</body></methods><methods><class-id>Refactory.Browser.ParseTreeRewriter</class-id> <category>replacing</category><body package="Browser-Parser" selector="replace:with:">replace: searchString with: replaceString 	self addRule: (RBStringReplaceRule searchFor: searchString				replaceWith: replaceString)</body><body package="Browser-Parser" selector="replace:with:when:">replace: searchString with: replaceString when: aBlock 	self addRule: (RBStringReplaceRule 				searchFor: searchString				replaceWith: replaceString				when: aBlock)</body><body package="Browser-Parser" selector="replace:withValueFrom:">replace: searchString withValueFrom: replaceBlock 	self addRule: (RBBlockReplaceRule searchFor: searchString				replaceWith: replaceBlock)</body><body package="Browser-Parser" selector="replace:withValueFrom:when:">replace: searchString withValueFrom: replaceBlock when: conditionBlock 	self addRule: (RBBlockReplaceRule 				searchFor: searchString				replaceWith: replaceBlock				when: conditionBlock)</body><body package="Browser-Parser" selector="replaceArgument:with:">replaceArgument: searchString with: replaceString 	self addArgumentRule: (RBStringReplaceRule searchFor: searchString				replaceWith: replaceString)</body><body package="Browser-Parser" selector="replaceArgument:with:when:">replaceArgument: searchString with: replaceString when: aBlock 	self addArgumentRule: (RBStringReplaceRule 				searchFor: searchString				replaceWith: replaceString				when: aBlock)</body><body package="Browser-Parser" selector="replaceArgument:withValueFrom:">replaceArgument: searchString withValueFrom: replaceBlock 	self addArgumentRule: (RBBlockReplaceRule searchFor: searchString				replaceWith: replaceBlock)</body><body package="Browser-Parser" selector="replaceArgument:withValueFrom:when:">replaceArgument: searchString withValueFrom: replaceBlock when: conditionBlock 	self addArgumentRule: (RBBlockReplaceRule 				searchFor: searchString				replaceWith: replaceBlock				when: conditionBlock)</body><body package="Browser-Parser" selector="replaceMethod:with:">replaceMethod: searchString with: replaceString 	self addRule: (RBStringReplaceRule searchForMethod: searchString				replaceWith: replaceString)</body><body package="Browser-Parser" selector="replaceMethod:with:when:">replaceMethod: searchString with: replaceString when: aBlock 	self addRule: (RBStringReplaceRule 				searchForMethod: searchString				replaceWith: replaceString				when: aBlock)</body><body package="Browser-Parser" selector="replaceMethod:withValueFrom:">replaceMethod: searchString withValueFrom: replaceBlock 	self addRule: (RBBlockReplaceRule searchForMethod: searchString				replaceWith: replaceBlock)</body><body package="Browser-Parser" selector="replaceMethod:withValueFrom:when:">replaceMethod: searchString withValueFrom: replaceBlock when: conditionBlock 	self addRule: (RBBlockReplaceRule 				searchForMethod: searchString				replaceWith: replaceBlock				when: conditionBlock)</body><body package="Browser-Parser" selector="replaceTree:withTree:">replaceTree: searchTree withTree: replaceTree 	self addRule: (RBStringReplaceRule searchForTree: searchTree				replaceWith: replaceTree)</body><body package="Browser-Parser" selector="replaceTree:withTree:when:">replaceTree: searchTree withTree: replaceTree when: aBlock 	self addRule: (RBStringReplaceRule 				searchForTree: searchTree				replaceWith: replaceTree				when: aBlock)</body></methods><methods><class-id>Refactory.Browser.ParseTreeRewriter</class-id> <category>visiting</category><body package="Browser-Parser" selector="visitArguments:">visitArguments: aNodeCollection 	^aNodeCollection collect: [:each | self visitArgument: each]</body></methods><methods><class-id>Refactory.Browser.ParseTreeRewriter class</class-id> <category>instance creation</category><body package="Browser-Parser" selector="removeTemporaryNamed:">removeTemporaryNamed: aName 	| rewriteRule |	rewriteRule := self new.	rewriteRule replace: '| `@temps1 ' , aName , ' `@temps2 | ``@.Statements'		with: '| `@temps1  `@temps2 | ``@.Statements'.	^rewriteRule</body><body package="Browser-Parser" selector="rename:to:">rename: varName to: newVarName 	| rewriteRule |	rewriteRule := self new.	rewriteRule		replace: varName with: newVarName;		replaceArgument: varName with: newVarName.	^rewriteRule</body><body package="Browser-Parser" selector="rename:to:handler:">rename: varName to: newVarName handler: aBlock 	"Rename varName to newVarName, evaluating aBlock if there is a 	temporary variable with the same name as newVarName. This 	does not change temporary variables with varName."	| rewriteRule |	rewriteRule := self new.	rewriteRule		replace: varName with: newVarName;		replaceArgument: newVarName			withValueFrom: 				[:aNode | 				aBlock value.				aNode].	^rewriteRule</body><body package="Browser-Parser" selector="replace:with:method:">replace: code with: newCode method: aBoolean 	| rewriteRule |	rewriteRule := self new.	aBoolean 		ifTrue: [rewriteRule replaceMethod: code with: newCode]		ifFalse: [rewriteRule replace: code with: newCode].	^rewriteRule</body><body package="Browser-Parser" selector="replaceLiteral:with:">replaceLiteral: literal with: newLiteral 	| rewriteRule |	rewriteRule := self new.	rewriteRule replaceTree: (RBLiteralNode value: literal)		withTree: (RBLiteralNode value: newLiteral).	^rewriteRule</body><body package="Browser-Parser" selector="variable:getter:setter:">variable: aVarName getter: getMethod setter: setMethod 	| rewriteRule |	rewriteRule := self new.	rewriteRule		replace: aVarName , ' := ``@object'			with: 'self ' , setMethod , ' ``@object';		replace: aVarName with: 'self ' , getMethod.	^rewriteRule</body></methods><methods><class-id>Refactory.Browser.ParseTreeRewriter class</class-id> <category>accessing</category><body package="Browser-Parser" selector="replace:with:in:">replace: code with: newCode in: aParseTree 	^(self 		replace: code		with: newCode		method: false)		executeTree: aParseTree;		tree</body><body package="Browser-Parser" selector="replace:with:in:onInterval:">replace: code with: newCode in: aParseTree onInterval: anInterval 	| rewriteRule |	rewriteRule := self new.	^rewriteRule		replace: code			with: newCode			when: [:aNode | aNode intersectsInterval: anInterval];		executeTree: aParseTree;		tree</body><body package="Browser-Parser" selector="replaceStatements:with:in:onInterval:">replaceStatements: code with: newCode in: aParseTree onInterval: anInterval 	| tree replaceStmt |	tree := self buildTree: code method: false.	tree isSequence 		ifFalse: [tree := RBSequenceNode statements: (Array with: tree)].	tree temporaries: (Array with: (RBPatternVariableNode named: '`@temps')).	tree addNodeFirst: (RBPatternVariableNode named: '`@.S1').	tree lastIsReturn 		ifTrue: [replaceStmt := '| `@temps | `@.S1. ^' , newCode]		ifFalse: 			[tree addNode: (RBPatternVariableNode named: '`@.S2').			replaceStmt := '| `@temps | `@.S1. ' , newCode , '. `@.S2'].	^self 		replace: tree formattedCode		with: replaceStmt		in: aParseTree		onInterval: anInterval</body></methods><methods><class-id>Refactory.Browser.RBMultiKeywordLiteralToken</class-id> <category>testing</category><body package="Browser-Parser" selector="isMultiKeyword">isMultiKeyword	^true</body></methods><methods><class-id>Refactory.Browser.RBMethodNode</class-id> <category>comparing</category><body package="Browser-Parser" selector="=">= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	(self selector = anObject selector and: [self body = anObject body]) 		ifFalse: [^false].	1 to: self arguments size		do: [:i | (self arguments at: i) = (anObject arguments at: i) ifFalse: [^false]].	^true</body><body package="Browser-Parser" selector="equalTo:withMapping:">equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [^false].	(self selector = anObject selector 		and: [self body equalTo: anObject body withMapping: aDictionary]) 			ifFalse: [^false].	1 to: self arguments size		do: 			[:i | 			((self arguments at: i) equalTo: (anObject arguments at: i)				withMapping: aDictionary) ifFalse: [^false].			aDictionary removeKey: (self arguments at: i) name].	^self primitiveSources = anObject primitiveSources</body><body package="Browser-Parser" selector="hash">hash	^(self selector hash bitXor: self body hash) bitXor: self arguments hash</body></methods><methods><class-id>Refactory.Browser.RBMethodNode</class-id> <category>visitor</category><body package="Browser-Parser" selector="acceptVisitor:">acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptMethodNode: self</body></methods><methods><class-id>Refactory.Browser.RBMethodNode</class-id> <category>accessing</category><body package="Browser-Parser" selector="addNode:">addNode: aNode 	^body addNode: aNode</body><body package="Browser-Parser" selector="addReturn">addReturn	body addReturn</body><body package="Browser-Parser" selector="addSelfReturn">addSelfReturn	^body addSelfReturn</body><body package="Browser-Parser" selector="allArgumentVariables">allArgumentVariables	^(self argumentNames asOrderedCollection)		addAll: super allArgumentVariables;		yourself</body><body package="Browser-Parser" selector="allDefinedVariables">allDefinedVariables	^(self argumentNames asOrderedCollection)		addAll: super allDefinedVariables;		yourself</body><body package="Browser-Parser" selector="argumentNames">argumentNames	^self arguments collect: [:each | each name]</body><body package="Browser-Parser" selector="arguments">arguments	^arguments</body><body package="Browser-Parser" selector="arguments:">arguments: variableNodes 	arguments := variableNodes.	arguments do: [:each | each parent: self]</body><body package="Browser-Parser" selector="body">body	^body</body><body package="Browser-Parser" selector="body:">body: stmtsNode 	body := stmtsNode.	body parent: self</body><body package="Browser-Parser" selector="children">children	^self arguments copyWith: self body</body><body package="Browser-Parser" selector="methodComments">methodComments	| methodComments |	methodComments := OrderedCollection withAll: self comments.	arguments do: [:each | methodComments addAll: each comments].	^methodComments asSortedCollection: [:a :b | a first &lt; b first]</body><body package="Browser-Parser" selector="methodNode">methodNode	^self</body><body package="Browser-Parser" selector="newSource">newSource	replacements isNil ifTrue: [^self formattedCode].	^[self reformatSource] on: Error do: [:ex | ex return: self formattedCode]</body><body package="Browser-Parser" selector="numArgs">numArgs	^self selector numArgs</body><body package="Browser-Parser" selector="primitiveSources">primitiveSources	^self tags 		collect: [:each | self source copyFrom: each first to: each last]</body><body package="Browser-Parser" selector="renameSelector:andArguments:">renameSelector: newSelector andArguments: varNodeCollection 	| oldSelectorParts oldArguments |	oldSelectorParts := selectorParts.	oldArguments := arguments.	self		arguments: varNodeCollection;		selector: newSelector.	self changeSourceSelectors: oldSelectorParts arguments: oldArguments</body><body package="Browser-Parser" selector="selector">selector	^selector isNil		ifTrue: [selector := self buildSelector]		ifFalse: [selector]</body><body package="Browser-Parser" selector="selector:">selector: aSelector 	| keywords numArgs |	keywords := aSelector keywords.	numArgs := aSelector numArgs.	numArgs == arguments size 		ifFalse: 			[self 				error: (#AssignmentWithWrongArgNumber &lt;&lt; #browser &gt;&gt; 'Attempting to assign selector with wrong number of arguments.')].	selectorParts := numArgs == 0 				ifTrue: [Array with: (RBIdentifierToken value: keywords first start: nil)]				ifFalse: 					[keywords first last == $: 						ifTrue: [keywords collect: [:each | RBKeywordToken value: each start: nil]]						ifFalse: [Array with: (RBBinarySelectorToken value: aSelector start: nil)]].	selector := aSelector</body><body package="Browser-Parser" selector="source">source	^source</body><body package="Browser-Parser" selector="source:">source: anObject	source := anObject</body><body package="Browser-Parser" selector="start">start	^1</body><body package="Browser-Parser" selector="stop">stop	^source size</body><body package="Browser-Parser" selector="tags">tags	^tags isNil ifTrue: [#()] ifFalse: [tags]</body><body package="Browser-Parser" selector="tags:">tags: aCollectionOfIntervals 	tags := aCollectionOfIntervals</body></methods><methods><class-id>Refactory.Browser.RBMethodNode</class-id> <category>private</category><body package="Browser-Parser" selector="buildSelector">buildSelector	| selectorStream |	selectorStream := WriteStream on: (String new: 50).	selectorParts do: [:each | selectorStream nextPutAll: each value].	^selectorStream contents asSymbol</body><body package="Browser-Parser" selector="reformatSource">reformatSource	| newSource stream |	stream := WriteStream on: (String new: source size + 100).	stream 		nextPutAll: (source copyFrom: (replacements inject: 1						into: 							[:sum :each | 							stream								nextPutAll: (source copyFrom: sum to: each startPosition - 1);								nextPutAll: each string.							each stopPosition + 1])				to: source size).	newSource := stream contents.	self 		= (RBParser parseMethod: newSource onError: [:s :p | ^self formattedCode]) 			ifFalse: [^self formattedCode].	"Sanity check -- make sure the formatted code is = self"	^newSource</body><body package="Browser-Parser" selector="selectorParts">selectorParts	^selectorParts</body><body package="Browser-Parser" selector="selectorParts:">selectorParts: tokenCollection 	selectorParts := tokenCollection</body></methods><methods><class-id>Refactory.Browser.RBMethodNode</class-id> <category>matching</category><body package="Browser-Parser" selector="copyInContext:">copyInContext: aDictionary 	^(self class new)		selectorParts: (selectorParts collect: [:each | each removePositions]);		arguments: (arguments collect: [:each | each copyInContext: aDictionary]);		body: (body copyInContext: aDictionary);		source: (aDictionary at: '-source-');		yourself</body><body package="Browser-Parser" selector="match:inContext:">match: aNode inContext: aDictionary 	self class == aNode class ifFalse: [^false].	aDictionary at: '-source-' put: aNode source.	self selector == aNode selector ifFalse: [^false].	^(self 		matchList: arguments		against: aNode arguments		inContext: aDictionary) 			and: [body match: aNode body inContext: aDictionary]</body></methods><methods><class-id>Refactory.Browser.RBMethodNode</class-id> <category>testing</category><body package="Browser-Parser" selector="defines:">defines: aName 	^arguments anySatisfy: [:each | each name = aName]</body><body package="Browser-Parser" selector="isLast:">isLast: aNode 	^body isLast: aNode</body><body package="Browser-Parser" selector="isMethod">isMethod	^true</body><body package="Browser-Parser" selector="isPrimitive">isPrimitive	^tags notNil and: 			[tags notEmpty 				and: [self primitiveSources anySatisfy: [:each | '*primitive*' match: each]]]</body><body package="Browser-Parser" selector="lastIsReturn">lastIsReturn	^body lastIsReturn</body><body package="Browser-Parser" selector="references:">references: aVariableName 	^body references: aVariableName</body><body package="Browser-Parser" selector="uses:">uses: aNode 	^body == aNode and: [aNode lastIsReturn]</body></methods><methods><class-id>Refactory.Browser.RBMethodNode</class-id> <category>copying</category><body package="Browser-Parser" selector="postCopy">postCopy	super postCopy.	body := body copy.	arguments := arguments collect: [:each | each copy]</body></methods><methods><class-id>Refactory.Browser.RBMethodNode</class-id> <category>replacing</category><body package="Browser-Parser" selector="addReplacement:">addReplacement: aStringReplacement 	replacements isNil ifTrue: [^self].	replacements add: aStringReplacement</body><body package="Browser-Parser" selector="clearReplacements">clearReplacements	replacements := nil</body><body package="Browser-Parser" selector="map:to:">map: oldNode to: newNode 	nodeReplacements at: oldNode put: newNode</body><body package="Browser-Parser" selector="mappingFor:">mappingFor: oldNode 	^nodeReplacements at: oldNode ifAbsent: [oldNode]</body><body package="Browser-Parser" selector="replaceNode:withNode:">replaceNode: aNode withNode: anotherNode 	aNode == body ifTrue: [self body: anotherNode].	self arguments: (arguments 				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])</body></methods><methods><class-id>Refactory.Browser.RBMethodNode</class-id> <category>initialize-release</category><body package="Browser-Parser" selector="initialize">initialize	replacements := SortedCollection sortBlock: 					[:a :b | 					a startPosition &lt; b startPosition 						or: [a startPosition = b startPosition and: [a stopPosition &lt; b stopPosition]]].	nodeReplacements := IdentityDictionary new</body><body package="Browser-Parser" selector="selectorParts:arguments:">selectorParts: tokenCollection arguments: variableNodes 	selectorParts := tokenCollection.	self arguments: variableNodes</body></methods><methods><class-id>Refactory.Browser.RBMethodNode</class-id> <category>printing</category><body package="Browser-Parser" selector="printOn:">printOn: aStream 	aStream nextPutAll: self formattedCode</body></methods><methods><class-id>Refactory.Browser.RBMethodNode</class-id> <category>private-replacing</category><body package="Browser-Parser" selector="changeSourceSelectors:arguments:">changeSourceSelectors: oldSelectorParts arguments: oldArguments 		[oldSelectorParts size = selectorParts size ifFalse: [^self].	oldArguments size = arguments size ifFalse: [^self].	oldSelectorParts with: selectorParts		do: 			[:old :new | 			self addReplacement: (RBStringReplacement 						replaceFrom: old start						to: old stop						with: new value)].	oldArguments with: arguments		do: 			[:old :new | 			self addReplacement: (RBStringReplacement 						replaceFrom: old start						to: old stop						with: new value)]] 			on: Error			do: [:ex | ex return]</body></methods><methods><class-id>Refactory.Browser.RBMethodNode class</class-id> <category>instance creation</category><body package="Browser-Parser" selector="new">new	^(super new)		initialize;		yourself</body><body package="Browser-Parser" selector="selector:arguments:body:">selector: aSymbol arguments: variableNodes body: aSequenceNode 	^(self new)		arguments: variableNodes;		selector: aSymbol;		body: aSequenceNode;		yourself</body><body package="Browser-Parser" selector="selector:body:">selector: aSymbol body: aSequenceNode 	^self 		selector: aSymbol		arguments: #()		body: aSequenceNode</body><body package="Browser-Parser" selector="selectorParts:arguments:">selectorParts: tokenCollection arguments: variableNodes 	^(self new)		selectorParts: tokenCollection arguments: variableNodes;		yourself</body></methods><methods><class-id>Refactory.Browser.RBPatternMethodNode</class-id> <category>matching</category><body package="Browser-Parser" selector="copyInContext:">copyInContext: aDictionary 	| selectors |	selectors := self isSelectorList 				ifTrue: [(aDictionary at: selectorParts first value) keywords]				ifFalse: [selectorParts collect: [:each | aDictionary at: each value]].	^(RBMethodNode new)		selectorParts: (selectors collect: 						[:each | 						(each last == $: ifTrue: [RBKeywordToken] ifFalse: [RBIdentifierToken]) 							value: each							start: nil]);		arguments: (self copyList: arguments inContext: aDictionary);		body: (body copyInContext: aDictionary);		source: (aDictionary at: '-source-');		yourself</body><body package="Browser-Parser" selector="match:inContext:">match: aNode inContext: aDictionary 	aNode class == self matchingClass ifFalse: [^false].	aDictionary at: '-source-' put: aNode source.	self isSelectorList 		ifTrue: 			[^(aDictionary at: selectorParts first value ifAbsentPut: [aNode selector]) 				= aNode selector and: 						[(aDictionary at: arguments first ifAbsentPut: [aNode arguments]) 							= aNode arguments and: [body match: aNode body inContext: aDictionary]]].	^(self matchArgumentsAgainst: aNode inContext: aDictionary) 		and: [body match: aNode body inContext: aDictionary]</body><body package="Browser-Parser" selector="matchArgumentsAgainst:inContext:">matchArgumentsAgainst: aNode inContext: aDictionary 	self arguments size == aNode arguments size ifFalse: [^false].	(self matchSelectorAgainst: aNode inContext: aDictionary) 		ifFalse: [^false].	1 to: arguments size		do: 			[:i | 			((arguments at: i) match: (aNode arguments at: i) inContext: aDictionary) 				ifFalse: [^false]].	^true</body><body package="Browser-Parser" selector="matchSelectorAgainst:inContext:">matchSelectorAgainst: aNode inContext: aDictionary 	| keyword |	1 to: selectorParts size		do: 			[:i | 			keyword := selectorParts at: i.			(aDictionary at: keyword value				ifAbsentPut: 					[keyword isPatternVariable 						ifTrue: [(aNode selectorParts at: i) value]						ifFalse: [keyword value]]) 					= (aNode selectorParts at: i) value ifFalse: [^false]].	^true</body></methods><methods><class-id>Refactory.Browser.RBPatternMethodNode</class-id> <category>testing-matching</category><body package="Browser-Parser" selector="isPatternNode">isPatternNode	^true</body></methods><methods><class-id>Refactory.Browser.RBPatternMethodNode</class-id> <category>testing</category><body package="Browser-Parser" selector="isSelectorList">isSelectorList	^isList</body></methods><methods><class-id>Refactory.Browser.RBPatternMethodNode</class-id> <category>private</category><body package="Browser-Parser" selector="matchingClass">matchingClass	^RBMethodNode</body></methods><methods><class-id>Refactory.Browser.RBPatternMethodNode</class-id> <category>initialize-release</category><body package="Browser-Parser" selector="selectorParts:arguments:">selectorParts: tokenCollection arguments: variableNodes 	super selectorParts: tokenCollection arguments: variableNodes.	isList := (tokenCollection first value at: 2) == self listCharacter</body></methods><methods><class-id>Refactory.Browser.RBPatternMethodNode class</class-id> <category>instance creation</category><body package="Browser-Parser" selector="selectorParts:arguments:">selectorParts: tokenCollection arguments: variableNodes 	^(tokenCollection anySatisfy: [:each | each isPatternVariable]) 		ifTrue: [super selectorParts: tokenCollection arguments: variableNodes]		ifFalse: 			[RBMethodNode selectorParts: tokenCollection arguments: variableNodes]</body></methods><methods><class-id>Refactory.Browser.RBBlockNode</class-id> <category>comparing</category><body package="Browser-Parser" selector="=">= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	self body = anObject body ifFalse: [^false].	self arguments size = anObject arguments size ifFalse: [^false].	1 to: self arguments size		do: [:i | (self arguments at: i) = (anObject arguments at: i) ifFalse: [^false]].	^true</body><body package="Browser-Parser" selector="equalTo:withMapping:">equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [^false].	self arguments size = anObject arguments size ifFalse: [^false].	1 to: self arguments size		do: 			[:i | 			((self arguments at: i) equalTo: (anObject arguments at: i)				withMapping: aDictionary) ifFalse: [^false]].	(self body equalTo: anObject body withMapping: aDictionary)		ifFalse: [^false].	self arguments do: [:each | aDictionary removeKey: each name].	^true</body><body package="Browser-Parser" selector="hash">hash	^self arguments hash bitXor: self body hash</body></methods><methods><class-id>Refactory.Browser.RBBlockNode</class-id> <category>visitor</category><body package="Browser-Parser" selector="acceptVisitor:">acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptBlockNode: self</body></methods><methods><class-id>Refactory.Browser.RBBlockNode</class-id> <category>accessing</category><body package="Browser-Parser" selector="allArgumentVariables">allArgumentVariables	^(self argumentNames asOrderedCollection)		addAll: super allArgumentVariables;		yourself</body><body package="Browser-Parser" selector="allDefinedVariables">allDefinedVariables	^(self argumentNames asOrderedCollection)		addAll: super allDefinedVariables;		yourself</body><body package="Browser-Parser" selector="argumentNames">argumentNames	^self arguments collect: [:each | each name]</body><body package="Browser-Parser" selector="arguments">arguments	^arguments</body><body package="Browser-Parser" selector="arguments:">arguments: argCollection 	arguments := argCollection.	arguments do: [:each | each parent: self]</body><body package="Browser-Parser" selector="bar">bar	^bar</body><body package="Browser-Parser" selector="bar:">bar: anObject	bar := anObject</body><body package="Browser-Parser" selector="blockVariables">blockVariables	| vars |	vars := super blockVariables asOrderedCollection.	vars addAll: self argumentNames.	^vars</body><body package="Browser-Parser" selector="body">body	^body</body><body package="Browser-Parser" selector="body:">body: stmtsNode 	body := stmtsNode.	body parent: self</body><body package="Browser-Parser" selector="children">children	^self arguments copyWith: self body</body><body package="Browser-Parser" selector="colons:">colons: aCollection 	colons := aCollection</body><body package="Browser-Parser" selector="left">left	^left</body><body package="Browser-Parser" selector="left:">left: anObject	left := anObject</body><body package="Browser-Parser" selector="precedence">precedence	^0</body><body package="Browser-Parser" selector="right">right	^right</body><body package="Browser-Parser" selector="right:">right: anObject	right := anObject</body><body package="Browser-Parser" selector="startWithoutParentheses">startWithoutParentheses	^left</body><body package="Browser-Parser" selector="statementComments">statementComments	^self comments</body><body package="Browser-Parser" selector="stopWithoutParentheses">stopWithoutParentheses	^right</body></methods><methods><class-id>Refactory.Browser.RBBlockNode</class-id> <category>matching</category><body package="Browser-Parser" selector="copyInContext:">copyInContext: aDictionary 	^(self class new)		arguments: (self copyList: arguments inContext: aDictionary);		body: (body copyInContext: aDictionary);		yourself</body><body package="Browser-Parser" selector="match:inContext:">match: aNode inContext: aDictionary 	aNode class == self class ifFalse: [^false].	^(self 		matchList: arguments		against: aNode arguments		inContext: aDictionary) 			and: [body match: aNode body inContext: aDictionary]</body></methods><methods><class-id>Refactory.Browser.RBBlockNode</class-id> <category>testing</category><body package="Browser-Parser" selector="defines:">defines: aName 	^arguments anySatisfy: [:each | each name = aName]</body><body package="Browser-Parser" selector="directlyUses:">directlyUses: aNode 	^false</body><body package="Browser-Parser" selector="isBlock">isBlock	^true</body><body package="Browser-Parser" selector="isImmediateNode">isImmediateNode	^true</body><body package="Browser-Parser" selector="isLast:">isLast: aNode 	^body isLast: aNode</body><body package="Browser-Parser" selector="needsParenthesis">needsParenthesis	^false</body><body package="Browser-Parser" selector="references:">references: aVariableName 	^body references: aVariableName</body><body package="Browser-Parser" selector="uses:">uses: aNode 	aNode = body ifFalse: [^false].	^parent isMessage 		ifTrue: 			[(#(#ifTrue:ifFalse: #ifTrue: #ifFalse: #ifFalse:ifTrue:) 				includes: parent selector) not 				or: [parent isUsed]]		ifFalse: [self isUsed]</body></methods><methods><class-id>Refactory.Browser.RBBlockNode</class-id> <category>copying</category><body package="Browser-Parser" selector="postCopy">postCopy	super postCopy.	arguments := arguments collect: [:each | each copy].	body := body copy</body></methods><methods><class-id>Refactory.Browser.RBBlockNode</class-id> <category>replacing</category><body package="Browser-Parser" selector="replaceNode:withNode:">replaceNode: aNode withNode: anotherNode 	body == aNode ifTrue: [self body: anotherNode].	self arguments: (arguments 				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])</body></methods><methods><class-id>Refactory.Browser.RBBlockNode class</class-id> <category>instance creation</category><body package="Browser-Parser" selector="arguments:body:">arguments: argNodes body: sequenceNode 	^(self new)		arguments: argNodes;		body: sequenceNode;		yourself</body><body package="Browser-Parser" selector="body:">body: sequenceNode 	^self arguments: #() body: sequenceNode</body></methods><methods><class-id>Refactory.Browser.RBReadBeforeWrittenTester</class-id> <category>visitor-double dispatching</category><body package="Browser-Parser" selector="acceptAssignmentNode:">acceptAssignmentNode: anAssignmentNode 	self visitNode: anAssignmentNode value.	self variableWritten: anAssignmentNode</body><body package="Browser-Parser" selector="acceptBlockNode:">acceptBlockNode: aBlockNode 	self processBlock: aBlockNode</body><body package="Browser-Parser" selector="acceptMessageNode:">acceptMessageNode: aMessageNode 	((#(#whileTrue: #whileFalse: #whileTrue #whileFalse) 		includes: aMessageNode selector) and: [aMessageNode receiver isBlock]) 		ifTrue: [self executeTree: aMessageNode receiver body]		ifFalse: 			[(aMessageNode isCascaded not or: [aMessageNode isFirstCascaded]) 				ifTrue: [self visitNode: aMessageNode receiver]].	((#(#ifTrue:ifFalse: #ifFalse:ifTrue:) includes: aMessageNode selector) 		and: [aMessageNode arguments allSatisfy: [:each | each isBlock]]) 			ifTrue: [^self processIfTrueIfFalse: aMessageNode].	aMessageNode arguments do: [:each | self visitNode: each]</body><body package="Browser-Parser" selector="acceptSequenceNode:">acceptSequenceNode: aSequenceNode 	self processStatementNode: aSequenceNode</body><body package="Browser-Parser" selector="acceptVariableNode:">acceptVariableNode: aVariableNode 	self variableRead: aVariableNode</body></methods><methods><class-id>Refactory.Browser.RBReadBeforeWrittenTester</class-id> <category>initialize-release</category><body package="Browser-Parser" selector="checkNewTemps:">checkNewTemps: aBoolean 	checkNewTemps := aBoolean</body><body package="Browser-Parser" selector="initialize">initialize	super initialize.	scopeStack := OrderedCollection with: Dictionary new.	read := Set new.	checkNewTemps := true</body><body package="Browser-Parser" selector="initializeVars:">initializeVars: varNames 	varNames do: [:each | self currentScope at: each put: nil]</body></methods><methods><class-id>Refactory.Browser.RBReadBeforeWrittenTester</class-id> <category>private</category><body package="Browser-Parser" selector="copyDictionary:">copyDictionary: aDictionary 	"We could send aDictionary the copy message, but that doesn't copy the associations."	| newDictionary |	newDictionary := Dictionary new: aDictionary size.	aDictionary 		keysAndValuesDo: [:key :value | newDictionary at: key put: value].	^newDictionary</body><body package="Browser-Parser" selector="createScope">createScope	scopeStack add: (self copyDictionary: scopeStack last)</body><body package="Browser-Parser" selector="currentScope">currentScope	^scopeStack last</body><body package="Browser-Parser" selector="processBlock:">processBlock: aNode 	| newScope |	self createScope.	self executeTree: aNode body.	newScope := self removeScope.	newScope keysAndValuesDo: 			[:key :value | 			(value == true and: [(self currentScope at: key) isNil]) 				ifTrue: [self currentScope at: key put: value]]</body><body package="Browser-Parser" selector="processIfTrueIfFalse:">processIfTrueIfFalse: aNode 	| trueScope falseScope |	self createScope.	self executeTree: aNode arguments first body.	trueScope := self removeScope.	self createScope.	self executeTree: aNode arguments last body.	falseScope := self removeScope.	self currentScope keysAndValuesDo: 			[:key :value | 			value isNil 				ifTrue: 					[(trueScope at: key) == (falseScope at: key) 						ifTrue: [self currentScope at: key put: (trueScope at: key)]						ifFalse: 							[((trueScope at: key) == true or: [(falseScope at: key) == true]) 								ifTrue: [self currentScope at: key put: true]]]]</body><body package="Browser-Parser" selector="processStatementNode:">processStatementNode: aNode 	| temps |	(checkNewTemps not or: [aNode temporaries isEmpty]) 		ifTrue: 			[aNode statements do: [:each | self executeTree: each].			^self].	self createScope.	temps := aNode temporaries collect: [:each | each name].	self initializeVars: temps.	aNode statements do: [:each | self executeTree: each].	self removeScope keysAndValuesDo: 			[:key :value | 			(temps includes: key) 				ifTrue: [value == true ifTrue: [read add: key]]				ifFalse: 					[(self currentScope at: key) isNil 						ifTrue: [self currentScope at: key put: value]]]</body><body package="Browser-Parser" selector="removeScope">removeScope	^scopeStack removeLast</body><body package="Browser-Parser" selector="variableRead:">variableRead: aNode 	(self currentScope includesKey: aNode name) 		ifTrue: 			[(self currentScope at: aNode name) isNil 				ifTrue: [self currentScope at: aNode name put: true]]</body><body package="Browser-Parser" selector="variableWritten:">variableWritten: aNode 	(self currentScope includesKey: aNode variable name) 		ifTrue: 			[(self currentScope at: aNode variable name) isNil 				ifTrue: [self currentScope at: aNode variable name put: false]]</body></methods><methods><class-id>Refactory.Browser.RBReadBeforeWrittenTester</class-id> <category>accessing</category><body package="Browser-Parser" selector="executeTree:">executeTree: aParseTree 	^self visitNode: aParseTree</body><body package="Browser-Parser" selector="read">read	self currentScope		keysAndValuesDo: [:key :value | value == true ifTrue: [read add: key]].	^read</body></methods><methods><class-id>Refactory.Browser.RBReadBeforeWrittenTester class</class-id> <category>accessing</category><body package="Browser-Parser" selector="isVariable:readBeforeWrittenIn:">isVariable: aString readBeforeWrittenIn: aBRProgramNode 	^(self isVariable: aString writtenBeforeReadIn: aBRProgramNode) not</body><body package="Browser-Parser" selector="isVariable:writtenBeforeReadIn:">isVariable: aString writtenBeforeReadIn: aBRProgramNode 	^(self readBeforeWritten: (Array with: aString) in: aBRProgramNode) 		isEmpty</body><body package="Browser-Parser" selector="readBeforeWritten:in:">readBeforeWritten: varNames in: aParseTree 	^(self new)		checkNewTemps: false;		initializeVars: varNames;		executeTree: aParseTree;		read</body><body package="Browser-Parser" selector="variablesReadBeforeWrittenIn:">variablesReadBeforeWrittenIn: aParseTree 	^(self new)		executeTree: aParseTree;		read</body></methods><methods><class-id>Refactory.Browser.RBPatternParser</class-id> <category>private-classes</category><body package="Browser-Parser" selector="messageNodeClass">messageNodeClass	^RBPatternMessageNode</body><body package="Browser-Parser" selector="methodNodeClass">methodNodeClass	^RBPatternMethodNode</body><body package="Browser-Parser" selector="variableNodeClass">variableNodeClass	^RBPatternVariableNode</body></methods><methods><class-id>Refactory.Browser.RBPatternParser</class-id> <category>private-parsing</category><body package="Browser-Parser" selector="parseLiteralByteArrayObject">parseLiteralByteArrayObject	| node |	(currentToken isIdentifier and: [currentToken isPatternVariable]) 		ifTrue: 			[node := self variableNodeClass identifierToken: currentToken.			node isLiteralNode 				ifTrue: 					[self step.					^node]].	^super parseLiteralByteArrayObject</body><body package="Browser-Parser" selector="parsePatternBlock:">parsePatternBlock: aClass 	| position node |	position := currentToken start.	self step.	node := self parseBlockArgsInto: aClass new.	node left: position.	node body: (self parseStatements: false).	(currentToken isSpecial and: [currentToken value == $}]) 		ifFalse: [self parserError: (#CloseBraceExpected &lt;&lt; #browser &gt;&gt; '} expected')].	node right: currentToken start.	self step.	^node</body><body package="Browser-Parser" selector="parsePrimitiveLiteral">parsePrimitiveLiteral	| node |	(currentToken isIdentifier and: [currentToken isPatternVariable]) 		ifTrue: 			[node := self variableNodeClass identifierToken: currentToken.			node isLiteralNode 				ifTrue: 					[self step.					^node].			currentToken := RBLiteralToken 						value: currentToken value asSymbol						start: currentToken start						stop: currentToken stop].	^super parsePrimitiveLiteral</body><body package="Browser-Parser" selector="parsePrimitiveObject">parsePrimitiveObject	currentToken isPatternBlock 		ifTrue: [^self parsePatternBlock: RBPatternBlockNode].	^super parsePrimitiveObject</body><body package="Browser-Parser" selector="parseUnaryMessage">parseUnaryMessage	| node |	node := self parsePrimitiveObject.	self addCommentsTo: node.		[currentToken isLiteralToken ifTrue: [self patchLiteralMessage].	currentToken isPatternBlock 		ifTrue: 			[node := (self parsePatternBlock: RBPatternWrapperBlockNode)						wrappedNode: node;						yourself].	currentToken isIdentifier] 			whileTrue: [node := self parseUnaryMessageWith: node].	self addCommentsTo: node.	^node</body></methods><methods><class-id>Refactory.Browser.RBPatternParser</class-id> <category>accessing</category><body package="Browser-Parser" selector="scannerClass">scannerClass	^RBPatternScanner</body></methods><methods><class-id>Refactory.Browser.RBPatternParser</class-id> <category>private</category><body package="Browser-Parser" selector="patchLiteralArrayToken">patchLiteralArrayToken	(currentToken isIdentifier and: [currentToken isPatternVariable]) 		ifTrue: [^self].	super patchLiteralArrayToken</body></methods><methods><class-id>Refactory.Browser.RBPatternBlockNode</class-id> <category>visitor</category><body package="Browser-Parser" selector="acceptVisitor:">acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptPatternBlockNode: self</body></methods><methods><class-id>Refactory.Browser.RBPatternBlockNode</class-id> <category>matching</category><body package="Browser-Parser" selector="addArgumentWithNameBasedOn:to:">addArgumentWithNameBasedOn: aString to: aRBBlockNode 	| name index vars |	name := aString.	vars := aRBBlockNode allDefinedVariables.	index := 0.	[vars includes: name] whileTrue: 			[index := index + 1.			name := name , index printString].	aRBBlockNode 		arguments: (aRBBlockNode arguments copyWith: (RBVariableNode named: name))</body><body package="Browser-Parser" selector="constructLookupNodeFor:in:">constructLookupNodeFor: aString in: aRBBlockNode 	| argumentNode |	argumentNode := RBLiteralNode literalToken: (RBLiteralToken 						value: aString						start: nil						stop: nil).	^RBMessageNode 		receiver: (RBVariableNode named: 'self')		selector: #lookupMatchFor:in:		arguments: (Array with: argumentNode with: aRBBlockNode arguments last)</body><body package="Browser-Parser" selector="copyInContext:">copyInContext: aDictionary 	^self replacingBlock value: aDictionary</body><body package="Browser-Parser" selector="createBlockFor:">createBlockFor: aRBBlockNode 	| source |	self replacePatternNodesIn: aRBBlockNode.	source := aRBBlockNode formattedCode.	^Compiler 		evaluate: source		for: self		logged: false</body><body package="Browser-Parser" selector="createMatchingBlock">createMatchingBlock	| newBlock |	self arguments size &gt; 2 		ifTrue: 			[self 				error: (#GenKey7 &lt;&lt; #browser &gt;&gt; 'Search blocks can only contain arguments for the node and matching dictionary')].	newBlock := RBBlockNode arguments: arguments body: body.	newBlock arguments isEmpty 		ifTrue: [self addArgumentWithNameBasedOn: 'aNode' to: newBlock].	newBlock arguments size = 1 		ifTrue: [self addArgumentWithNameBasedOn: 'aDictionary' to: newBlock].	^self createBlockFor: newBlock</body><body package="Browser-Parser" selector="createReplacingBlock">createReplacingBlock	| newBlock |	self arguments size &gt; 1 		ifTrue: 			[self 				error: (#GenKey8 &lt;&lt; #browser &gt;&gt; 'Replace blocks can only contain an argument for the matching dictionary')].	newBlock := RBBlockNode arguments: arguments body: body.	self arguments isEmpty 		ifTrue: [self addArgumentWithNameBasedOn: 'aDictionary' to: newBlock].	^self createBlockFor: newBlock</body><body package="Browser-Parser" selector="lookupMatchFor:in:">lookupMatchFor: aString in: aDictionary 	^aDictionary at: aString		ifAbsent: 			[| variableNode |			variableNode := RBPatternVariableNode named: aString.			aDictionary at: variableNode ifAbsent: [nil]]</body><body package="Browser-Parser" selector="match:inContext:">match: aNode inContext: aDictionary 	^self matchingBlock value: aNode value: aDictionary</body><body package="Browser-Parser" selector="matchingBlock">matchingBlock	^valueBlock isNil 		ifTrue: [valueBlock := self createMatchingBlock]		ifFalse: [valueBlock]</body><body package="Browser-Parser" selector="replacePatternNodesIn:">replacePatternNodesIn: aRBBlockNode 	aRBBlockNode body nodesDo: 			[:each | 			(each isVariable and: [each isPatternNode]) 				ifTrue: 					[each 						replaceWith: (self constructLookupNodeFor: each name in: aRBBlockNode)]]</body><body package="Browser-Parser" selector="replacingBlock">replacingBlock	^valueBlock isNil 		ifTrue: [valueBlock := self createReplacingBlock]		ifFalse: [valueBlock]</body></methods><methods><class-id>Refactory.Browser.RBPatternBlockNode</class-id> <category>accessing</category><body package="Browser-Parser" selector="sentMessages">sentMessages	^OrderedCollection new</body></methods><methods><class-id>Refactory.Browser.RBPatternWrapperBlockNode</class-id> <category>visitor</category><body package="Browser-Parser" selector="acceptVisitor:">acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptPatternWrapperBlockNode: self</body></methods><methods><class-id>Refactory.Browser.RBPatternWrapperBlockNode</class-id> <category>matching</category><body package="Browser-Parser" selector="copyInContext:">copyInContext: aDictionary 	"I don't know what this would mean, so ignore it."	^wrappedNode copyInContext: aDictionary</body><body package="Browser-Parser" selector="match:inContext:">match: aNode inContext: aDictionary 	(wrappedNode match: aNode inContext: aDictionary) ifFalse: [^false].	^super match: aNode inContext: aDictionary</body></methods><methods><class-id>Refactory.Browser.RBPatternWrapperBlockNode</class-id> <category>accessing</category><body package="Browser-Parser" selector="precedence">precedence	^1</body><body package="Browser-Parser" selector="wrappedNode">wrappedNode	^wrappedNode</body><body package="Browser-Parser" selector="wrappedNode:">wrappedNode: aRBProgramNode 	wrappedNode := aRBProgramNode.	aRBProgramNode parent: self</body></methods><methods><class-id>Refactory.Browser.RBLiteralValueNode</class-id> <category>accessing</category><body package="Browser-Parser" selector="startWithoutParentheses">startWithoutParentheses	^token start</body><body package="Browser-Parser" selector="stopWithoutParentheses">stopWithoutParentheses	^token stop</body><body package="Browser-Parser" selector="token">token	^token</body><body package="Browser-Parser" selector="value">value	^token realValue</body></methods><methods><class-id>Refactory.Browser.RBLiteralValueNode</class-id> <category>visitor</category><body package="Browser-Parser" selector="acceptVisitor:">acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptLiteralNode: self</body></methods><methods><class-id>Refactory.Browser.RBLiteralValueNode</class-id> <category>initialize-release</category><body package="Browser-Parser" selector="literalToken:">literalToken: aLiteralToken 	token := aLiteralToken</body></methods><methods><class-id>Refactory.Browser.RBLiteralValueNode</class-id> <category>matching</category><body package="Browser-Parser" selector="copyInContext:">copyInContext: aDictionary	^self class literalToken: token removePositions</body></methods><methods><class-id>Refactory.Browser.RBLiteralValueNode</class-id> <category>comparing</category><body package="Browser-Parser" selector="=">= anObject 	^super = anObject and: 			[self value = anObject value 				and: [self value species == anObject value species]]</body></methods><methods><class-id>Refactory.Browser.RBLiteralValueNode class</class-id> <category>instance creation</category><body package="Browser-Parser" selector="literalToken:">literalToken: aLiteralToken 	^(self new)		literalToken: aLiteralToken;		yourself</body><body package="Browser-Parser" selector="value:">value: aValue 	^self literalToken: (RBLiteralToken value: aValue)</body></methods><methods><class-id>Core.Behavior</class-id> <category>RefactoringBrowser</category><body package="Browser-Parser" selector="parseTreeFor:">parseTreeFor: aSymbol 	^Refactory.Browser.RBParser parseMethod: (self sourceCodeAt: aSymbol)		onError: [:aString :pos | ^nil]</body></methods><initialize><class-id>Refactory.Browser.RBParser</class-id></initialize><initialize><class-id>Refactory.Browser.RBScanner</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Stream</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>KeyedCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class></st-source>