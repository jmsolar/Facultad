<?xml version="1.0"?><st-source><!-- Name: Debugger-Process MonitorComment: PDP Process Monitor for VW 7.DbIdentifier: bear73DbTrace: 53490DevelopmentPrerequisites: #(#(#any 'Debugger-UI' ''))PackageName: Debugger-Process MonitorParcel: #('Debugger-Process Monitor')PrerequisiteParcels: #(#('Debugger-UI' ''))PrintStringCache: (7.3.1 - 1.2,bobw)Version: 7.3.1Post-Load Block: 	[ :pkg |  Process allInstances do: [:p | p priority = 50 ifFalse: [p setIsSystemProcess]].]Date: 5:54:23 pm April 10, 2005 --><time-stamp>From VisualWorksÂ®, 7.3.1 of April 10, 2005 on April 10, 2005 at 5:54:23 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ProcessMonitorClient</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>service record intervalHolder samplerProcess isSampling processRecords displayFilter displayList numProcHolder memSizeHolder sortBlock tabs processListWidget </inst-vars><class-inst-vars>defaultFilter </class-inst-vars><imports></imports><category>CrafProcessMonitor</category><attributes><package>Debugger-Process Monitor</package></attributes></class><class><name>ProcessMonitorService</name><environment>Smalltalk</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>processes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CrafProcessMonitor</category><attributes><package>Debugger-Process Monitor</package></attributes></class><class><name>ProcessMonitorRecord</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>index state hash priority topContext type name underDebug windowLabel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CrafProcessMonitor</category><attributes><package>Debugger-Process Monitor</package></attributes></class><methods><class-id>ProcessMonitorClient</class-id> <category>actions</category><body package="Debugger-Process Monitor" selector="changeProcessPriority">changeProcessPriority	| answer |	self hasSelection		ifFalse: [^self].	answer := Dialog request: (#EnterNewPriority &lt;&lt; #pdp &gt;&gt; 'Enter new priority') initialAnswer: self selectedProcessRecord priority printString.	answer isEmpty		ifTrue: [^self].	answer := answer asNumber rounded.	(answer &lt; 1 or: [answer &gt; (Processor highestPriority - 1)])		ifTrue: [^self].	displayList selections do: [:rec | service changeProcess: rec processHash priorityTo: answer]</body><body package="Debugger-Process Monitor" selector="debugProcess">debugProcess	(displayList selections anySatisfy: [:rec | rec isSystemProcess])		ifTrue:			[(Dialog confirm: (#DebuggingSystemProcessMayHarm &lt;&lt; #pdp &gt;&gt; 'Debugging a system process may harm the system.	Continue debug?'))				ifFalse: [^self]].	displayList selections do: [:rec | service debugProcess: rec processHash]</body><body package="Debugger-Process Monitor" selector="dumpProcess">dumpProcess	| aString strm |	aString := Dialog requestFileName: (#EnterFileNameForDump &lt;&lt; #pdp &gt;&gt; 'Enter file name for dump')				default: 'procdmp.txt'.	(aString isNil or: [aString isEmpty]) ifTrue: [^self].	strm := aString asFilename writeStream.	[displayList selections do:		[:rec |		rec printOn: strm.		strm cr.		strm nextPutAll: (service stackStringOf: rec processHash).		strm cr.].	] 		ensure: [strm close]</body><body package="Debugger-Process Monitor" selector="inspectProcess">inspectProcess	displayList selections do: [:rec | service inspectProcess: rec processHash]</body><body package="Debugger-Process Monitor" selector="proceedAllAndExit">proceedAllAndExit	service proceedUserProcesses.	self exit</body><body package="Debugger-Process Monitor" selector="proceedAllProcesses">proceedAllProcesses	service proceedUserProcesses</body><body package="Debugger-Process Monitor" selector="proceedProcess">proceedProcess	displayList selections do: [:rec | service proceedProcess: rec processHash]</body><body package="Debugger-Process Monitor" selector="terminateProcess">terminateProcess	(Dialog confirm: (#AreYouSureYouWantToTerminateSelected &lt;&lt; #pdp &gt;&gt; 'Are you sure you want to terminate the selected processes?')) 		ifFalse: [^self].	displayList selections do: [:rec | service terminateProcess: rec processHash]</body><body package="Debugger-Process Monitor" selector="toggleSampling">toggleSampling	isSampling := isSampling not.	self spawnNextSampler.	(builder componentAt: #sampleCntrl) widget labelString: self sampleCntrlLabel</body><body package="Debugger-Process Monitor" selector="viewProcess">viewProcess	| holder |	displayList selections do:		[:rec |		holder := (rec printString , '' , (service stackStringOf: rec processHash)) asValue.		[ComposedTextView 			open: holder			label: ((#ProcessViewOf1s &lt;&lt; #pdp &gt;&gt; 'Process view of &lt;1s&gt;')			expandMacrosWith: rec name)] forkAt: Processor userSchedulingPriority]</body></methods><methods><class-id>ProcessMonitorClient</class-id> <category>actions - sorting</category><body package="Debugger-Process Monitor" selector="createSortBlockFor:">createSortBlockFor: field	| ascSortBlock dscSortBlock |	ascSortBlock := [:x :y | (x perform: field) &lt;= (y perform: field)].	dscSortBlock := [:x :y | (x perform: field) &gt;= (y perform: field)].	sortBlock := self processList sortAspect == field		ifTrue:			[self processList sortDirection == #asc				ifTrue:					[self processList sortDirection: #dsc.					ascSortBlock]				ifFalse:					[self processList sortDirection: #asc.					dscSortBlock]]		ifFalse:			[self processList sortAspect: field.			self processList sortDirection: #dsc.			ascSortBlock].</body><body package="Debugger-Process Monitor" selector="recordNameLabelPressed">recordNameLabelPressed	self sortField: #name</body><body package="Debugger-Process Monitor" selector="recordPriorityLabelPressed">recordPriorityLabelPressed	self sortField: #priority</body><body package="Debugger-Process Monitor" selector="recordProcessHashLabelPressed">recordProcessHashLabelPressed	self sortField: #processHash</body><body package="Debugger-Process Monitor" selector="recordStateLabelPressed">recordStateLabelPressed	self sortField: #state</body><body package="Debugger-Process Monitor" selector="recordTopContextLabelPressed">recordTopContextLabelPressed	self sortField: #topContext</body><body package="Debugger-Process Monitor" selector="recordTypeLabelPressed">recordTypeLabelPressed	self sortField: #type</body><body package="Debugger-Process Monitor" selector="recordWindowLabelLabelPressed">recordWindowLabelLabelPressed	self sortField: #windowLabel</body><body package="Debugger-Process Monitor" selector="sortField:">sortField: field 	self createSortBlockFor: field.	self displayProcessRecords.</body></methods><methods><class-id>ProcessMonitorClient</class-id> <category>updating</category><body package="Debugger-Process Monitor" selector="displayProcessRecords">displayProcessRecords	| selectedRecords nLines scrollPosition |	nLines := displayList list size.	scrollPosition := processListWidget scrollOffsetHolder value.	selectedRecords := displayList selections.	displayList list: (SortedCollection withAll: (self filter: processRecords) sortBlock: sortBlock) asList.	displayList selections: selectedRecords.	displayList list size &gt;= nLines		ifTrue: [processListWidget scrollTo: scrollPosition].</body><body package="Debugger-Process Monitor" selector="setProcessListPage">setProcessListPage	(self widgetAt: #tabControl) client: self		spec: (#(#processSpec #windowProcessSpec) at: tabs selectionIndex)</body><body package="Debugger-Process Monitor" selector="tabsChanged">tabsChanged	self createSortBlockFor: #name.	self updateList.	self setProcessListPage</body><body package="Debugger-Process Monitor" selector="updateList">updateList	processRecords := tabs selectionIndex = 1		ifTrue: [service processList]		ifFalse: [service windowProcessList].	self displayProcessRecords.	self updateStatusBar.	self spawnNextSampler.</body><body package="Debugger-Process Monitor" selector="updateStatusBar">updateStatusBar	numProcHolder value: ((#SystemC1sUserC2s &lt;&lt; #pdp &gt;&gt; 'System: &lt;1s&gt;  User: &lt;2s&gt;')			expandMacrosWith: self numOfSystemProcesses			with: self numOfUserProcesses).	memSizeHolder  value: ((#MemoryC1s &lt;&lt; #pdp &gt;&gt; 'Memory: &lt;1s&gt;')			expandMacrosWith: service dynamicallyAllocatedFootprint printString).</body></methods><methods><class-id>ProcessMonitorClient</class-id> <category>private</category><body package="Debugger-Process Monitor" selector="enableDebug">enableDebug	^self menuCommandEnablement and: [(displayList selections anySatisfy: [:rec | rec isUnderDebug]) not]</body><body package="Debugger-Process Monitor" selector="filter:">filter: aCollection	^aCollection select: displayFilter.</body><body package="Debugger-Process Monitor" selector="hasSelection">hasSelection	^displayList selectionIndexes notEmpty</body><body package="Debugger-Process Monitor" selector="menuCommandEnablement">menuCommandEnablement	^self hasSelection</body><body package="Debugger-Process Monitor" selector="numOfSystemProcesses">numOfSystemProcesses	^(processRecords inject: 0 into: [:s :p | s + (p isSystemProcess ifTrue: [1] ifFalse: [0])]) printString</body><body package="Debugger-Process Monitor" selector="numOfUserProcesses">numOfUserProcesses	^(processRecords inject: 0 into: [:s :p | s + (p isSystemProcess ifTrue: [0] ifFalse: [1])]) printString</body><body package="Debugger-Process Monitor" selector="selectedProcessRecord">selectedProcessRecord	^displayList selections first</body></methods><methods><class-id>ProcessMonitorClient</class-id> <category>accessing</category><body package="Debugger-Process Monitor" selector="enableProceed">enableProceed	^self hasSelection and: [(displayList selections anySatisfy: [:rec | rec state ~= '  paused']) not]</body><body package="Debugger-Process Monitor" selector="intervalHolder">intervalHolder	^intervalHolder</body><body package="Debugger-Process Monitor" selector="labelFor:">labelFor: aSymbol	^self perform: aSymbol</body><body package="Debugger-Process Monitor" selector="memSizeHolder">memSizeHolder	^memSizeHolder</body><body package="Debugger-Process Monitor" selector="numProcHolder">numProcHolder	^numProcHolder</body><body package="Debugger-Process Monitor" selector="processList">processList	^displayList</body><body package="Debugger-Process Monitor" selector="record">record	^record</body><body package="Debugger-Process Monitor" selector="sampleCntrlLabel">sampleCntrlLabel	^isSampling		ifTrue: [(#Stop &lt;&lt; #pdp &gt;&gt; 'Stop')]		ifFalse: [(#Start &lt;&lt; #pdp &gt;&gt; 'Start')]</body><body package="Debugger-Process Monitor" selector="tabs">tabs	^tabs</body></methods><methods><class-id>ProcessMonitorClient</class-id> <category>menus</category><body package="Debugger-Process Monitor" selector="exit">exit	self closeRequest</body><body package="Debugger-Process Monitor" selector="showAll">showAll	displayFilter := self class allProcessesFilter.	self displayProcessRecords.</body><body package="Debugger-Process Monitor" selector="showSystem">showSystem	displayFilter := self class systemProcessesFilter.	self displayProcessRecords.</body><body package="Debugger-Process Monitor" selector="showUser">showUser	displayFilter := self class userProcessesFilter.	self displayProcessRecords.</body></methods><methods><class-id>ProcessMonitorClient</class-id> <category>initialize-release</category><body package="Debugger-Process Monitor" selector="noticeOfWindowClose:">noticeOfWindowClose: aWindow	EventQueue allInstancesDo: [:each | each restoreReadSynchSignals].	service proceedUserProcesses.	self release.</body><body package="Debugger-Process Monitor" selector="on:">on: aProcMonServer 	service := aProcMonServer.	intervalHolder := 2000 asValue.	displayList := MultiSelectionInListSortAware new.	record := nil asValue.	displayFilter := self class defaultProcessFilter.	numProcHolder := '' asValue.	memSizeHolder := '' asValue.	self createSortBlockFor: #name.	tabs := SelectionInList new.	tabs 		list: 			(List 				with: (#Processes &lt;&lt; #pdp &gt;&gt; 'Processes')				with: (#Windows &lt;&lt; #pdp &gt;&gt; 'Windows'));		selectionIndex: 1.	isSampling := true.</body><body package="Debugger-Process Monitor" selector="release">release	self stopSampling.	super release.</body></methods><methods><class-id>ProcessMonitorClient</class-id> <category>interface opening</category><body package="Debugger-Process Monitor" selector="postBuildWith:">postBuildWith: aBuilder	super postBuildWith: aBuilder.	builder == aBuilder		ifTrue: [builder window damageRepairPolicy: DoubleBufferingWindowDisplayPolicy new]		ifFalse: [processListWidget := (aBuilder componentAt: #processList) widget].</body><body package="Debugger-Process Monitor" selector="postOpenWith:">postOpenWith: aBuilder	super postOpenWith: aBuilder.	self setProcessListPage.	self updateList.</body></methods><methods><class-id>ProcessMonitorClient</class-id> <category>controlling</category><body package="Debugger-Process Monitor" selector="spawnNextSampler">spawnNextSampler	samplerProcess notNil		ifTrue: [samplerProcess terminate].	isSampling		ifFalse: [^self].	samplerProcess := 	[	(Delay forMilliseconds: intervalHolder value) wait.	self mainWindow send: #updateList to: self.	] newProcess.	samplerProcess name: 'ProcessMonitorSampler'.	samplerProcess resume.</body><body package="Debugger-Process Monitor" selector="stopSampling">stopSampling	samplerProcess isNil		ifTrue: [^self].	samplerProcess terminate.	samplerProcess := nil</body></methods><methods><class-id>ProcessMonitorClient class</class-id> <category>filters</category><body package="Debugger-Process Monitor" selector="allProcessesFilter">allProcessesFilter	^[:p | true].</body><body package="Debugger-Process Monitor" selector="defaultProcessFilter">defaultProcessFilter	^defaultFilter</body><body package="Debugger-Process Monitor" selector="defaultToAllProcesses">defaultToAllProcesses	defaultFilter := self allProcessesFilter.</body><body package="Debugger-Process Monitor" selector="defaultToSystemProcesses">defaultToSystemProcesses	defaultFilter := self systemProcessesFilter.</body><body package="Debugger-Process Monitor" selector="defaultToUserProcesses">defaultToUserProcesses	defaultFilter := self userProcessesFilter.</body><body package="Debugger-Process Monitor" selector="systemProcessesFilter">systemProcessesFilter	^[:p | p isSystemProcess].</body><body package="Debugger-Process Monitor" selector="userProcessesFilter">userProcessesFilter	^[:p | p isSystemProcess not].</body></methods><methods><class-id>ProcessMonitorClient class</class-id> <category>class initialization</category><body package="Debugger-Process Monitor" selector="initialize">initialize	defaultFilter := self userProcessesFilter.</body></methods><methods><class-id>ProcessMonitorClient class</class-id> <category>instance creation</category><body package="Debugger-Process Monitor" selector="openOn:">openOn: aService	^(self new on: aService) open</body></methods><methods><class-id>ProcessMonitorService</class-id> <category>actions</category><body package="Debugger-Process Monitor" selector="changeProcess:priorityTo:">changeProcess: anInteger priorityTo: newPriority	^self do: [:p | p priority: newPriority] forProcess: anInteger</body><body package="Debugger-Process Monitor" selector="debugProcess:">debugProcess: anInteger	^self do: [:p | p debug] forProcess: anInteger</body><body package="Debugger-Process Monitor" selector="dumpProcess:into:">dumpProcess: anInteger into: aString	self do: [:pr | pr dumpStackToFileNamed: aString]		forProcess: anInteger</body><body package="Debugger-Process Monitor" selector="inspectProcess:">inspectProcess: anInteger	^self do: [:each | [each inspect] forkAt: Processor userSchedulingPriority] forProcess: anInteger</body><body package="Debugger-Process Monitor" selector="proceedProcess:">proceedProcess: anInteger	^self do: [:p | p proceed] forProcess: anInteger</body><body package="Debugger-Process Monitor" selector="proceedUserProcesses">proceedUserProcesses	Processor proceedUserProcesses</body><body package="Debugger-Process Monitor" selector="stackStringOf:">stackStringOf: anInteger	self do: [:p | ^p stackString] forProcess: anInteger.	^''</body><body package="Debugger-Process Monitor" selector="terminateProcess:">terminateProcess: anInteger	^self do: 			[:pr |			pr terminate.			pr terminate.	"needed twice if it was waiting on a semaphore"]		forProcess: anInteger</body><body package="Debugger-Process Monitor" selector="viewProcess:">viewProcess: anInteger	self do:		[:pr | | strm name meth |		strm := WriteStream on: (String new: 2000).		strm nextPutAll: (#Process &lt;&lt; #dialogs &gt;&gt; 'Process') asString; space.		meth := pr processCreationMethod.		meth notNil			ifTrue:				[meth printNameOn: strm inClass: nil.				name := strm contents.				strm nextPut: Character cr.				strm nextPut: Character cr.				self printProcessStack: pr on: strm]			ifFalse:				[strm nextPutAll: 'nil'.				name := 'nil'].		ComposedTextView open: strm contents asValue label: name.]		forProcess: anInteger</body></methods><methods><class-id>ProcessMonitorService</class-id> <category>private</category><body package="Debugger-Process Monitor" selector="do:forProcess:">do: aBlock forProcess: anInteger	^aBlock value: (processes detect: [:p | p ~= 0 and: [p identityHash = anInteger]] ifNone: [^nil])</body></methods><methods><class-id>ProcessMonitorService</class-id> <category>accessing</category><body package="Debugger-Process Monitor" selector="dynamicallyAllocatedFootprint">dynamicallyAllocatedFootprint	^ObjectMemory current dynamicallyAllocatedFootprint</body><body package="Debugger-Process Monitor" selector="processList">processList	| strm |	processes := Process allGeneralInstances reject: [:p | p isTerminated].	processes := WeakArray withAll: processes.	strm := WriteStream on: (Array new: processes size).	processes do:		[:p |		p ~= processes tombstone			ifTrue: [strm nextPut: (ProcessMonitorRecord on: p)]].	^strm contents</body><body package="Debugger-Process Monitor" selector="windowProcessList">windowProcessList	| strm |	strm := WriteStream on: (Array new: 100).	processes := OrderedCollection new.	Window allGeneralInstancesDo:		[:win | | p |		(win isOpen and: [win windowManager isKindOf: WindowManager])			ifTrue:				[p := win windowProcess.				(p notNil and: [p isTerminated not])					ifTrue:						[processes add: p.						strm nextPut: (ProcessMonitorRecord onWindow: win)]]].	processes := WeakArray withAll: processes.	^strm contents</body></methods><methods><class-id>ProcessMonitorService class</class-id> <category>instance creation</category><body package="Debugger-Process Monitor" selector="open">open	^ProcessMonitorClient openOn: self new</body></methods><methods><class-id>ProcessMonitorRecord</class-id> <category>comparing</category><body package="Debugger-Process Monitor" selector="=">= aRecord	^hash = aRecord processHash and: [name = aRecord name]</body><body package="Debugger-Process Monitor" selector="hash">hash	^hash</body></methods><methods><class-id>ProcessMonitorRecord</class-id> <category>initialize-release</category><body package="Debugger-Process Monitor" selector="basicOn:">basicOn: aProcess	self initializeNameForProcess: aProcess.	priority := aProcess priority.	state := (underDebug := aProcess isUnderDebug)		ifTrue: ['d ' ]		ifFalse: ['  '].	state := state , aProcess processState asString.	topContext := aProcess suspendedContext.	(topContext notNil and: [topContext method == (Semaphore compiledMethodAt: #wait)])		ifTrue: [topContext := topContext sender].	topContext := topContext printString.	type := aProcess isSystemProcess.	type isNil		ifTrue: [type := false].	hash := aProcess identityHash.</body><body package="Debugger-Process Monitor" selector="initializeNameForProcess:">initializeNameForProcess: aProcess	name := aProcess name.	name notNil		ifTrue: [^self].	name := aProcess processCreationMethod.	name := name notNil		ifTrue: [name nameString]		ifFalse: ['nil'].	aProcess name: name.</body><body package="Debugger-Process Monitor" selector="on:">on: aProcess	aProcess priority &gt; Processor activeProcess priority		ifTrue: [[self basicOn: aProcess] valueUnpreemptively]		ifFalse: [self basicOn: aProcess]</body><body package="Debugger-Process Monitor" selector="onWindow:">onWindow: aWindow	windowLabel := aWindow label.	windowLabel := windowLabel isNil		ifTrue: [aWindow printString]		ifFalse: [windowLabel asString].	self basicOn: aWindow windowProcess.</body></methods><methods><class-id>ProcessMonitorRecord</class-id> <category>accessing</category><body package="Debugger-Process Monitor" selector="index">index	^index</body><body package="Debugger-Process Monitor" selector="name">name	^name</body><body package="Debugger-Process Monitor" selector="printOn:">printOn: aStream	aStream nextPutAll: (#NameC &lt;&lt; #pdp &gt;&gt; 'Name: ') asString;		nextPutAll: name; space; space;		nextPutAll: (#PriorityC &lt;&lt; #pdp &gt;&gt; 'Priority: ') asString;		print: priority.</body><body package="Debugger-Process Monitor" selector="priority">priority	^priority</body><body package="Debugger-Process Monitor" selector="processHash">processHash	^hash</body><body package="Debugger-Process Monitor" selector="state">state	^state</body><body package="Debugger-Process Monitor" selector="topContext">topContext	^topContext</body><body package="Debugger-Process Monitor" selector="type">type	^type		ifTrue: [(#system &lt;&lt; #pdp &gt;&gt; 'system') asString]		ifFalse: [(#user &lt;&lt; #pdp &gt;&gt; 'user') asString]</body><body package="Debugger-Process Monitor" selector="windowLabel">windowLabel	^windowLabel</body></methods><methods><class-id>ProcessMonitorRecord</class-id> <category>testing</category><body package="Debugger-Process Monitor" selector="isSystemProcess">isSystemProcess	^type</body><body package="Debugger-Process Monitor" selector="isUnderDebug">isUnderDebug	^underDebug</body></methods><methods><class-id>ProcessMonitorRecord class</class-id> <category>instance creation</category><body package="Debugger-Process Monitor" selector="on:">on: aProcess	^self new on: aProcess</body><body package="Debugger-Process Monitor" selector="onWindow:">onWindow: aWindow	^self new onWindow: aWindow</body></methods><methods><class-id>Kernel.Process</class-id> <category>accessing</category><body package="Debugger-Process Monitor" selector="processCreationMethod">processCreationMethod	| ctx stack |	stack := OrderedCollection new.	ctx := Processor activeProcess == self		ifTrue: [thisContext]		ifFalse: [suspendedContext].	ctx isNil		ifTrue: [^nil].	stack add: ctx.	[(ctx := stack last sender) isNil		ifTrue: [^stack first method homeMethod].	stack size &gt;= 3		ifTrue: [stack removeFirst].	stack addLast: ctx] repeat</body><body package="Debugger-Process Monitor" selector="processState">processState	Processor activeProcess == self		ifTrue: [^#active].	suspendedContext isNil		ifTrue: [^#terminated].	myList isNil		ifTrue:			[^(Processor isPaused: self)				ifTrue: [#paused]	"paused is really suspended"				ifFalse: [#suspend]].	^(Processor isRunable: self)		ifTrue: [#runable]		ifFalse: [#blocked]</body></methods><methods><class-id>Kernel.Process</class-id> <category>printing</category><body package="Debugger-Process Monitor" selector="stackString">stackString	| strm |	strm := (String new: 1000) writeStream.	self printStackOn: strm.	^strm contents</body></methods><methods><class-id>Kernel.CompiledCode</class-id> <category>printing</category><body package="Debugger-Process Monitor" selector="nameString">nameString	| aStream |	aStream := (String new: 256) writeStream.	self printNameOn: aStream inClass: nil.	^aStream contents</body></methods><methods><class-id>ProcessMonitorClient class</class-id> <category>resources</category><body package="Debugger-Process Monitor" selector="menu">menu	"MenuEditor new openOnClass: self andSelector: #menu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #File #defaultString: 'File' #catalogID: #pdp) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ProceedAllPaused #defaultString: 'Proceed All Paused' #catalogID: #pdp) 							#value: #proceedAllProcesses ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ProceedAllAndExit #defaultString: 'Proceed All and Exit' #catalogID: #pdp) 							#value: #proceedAllAndExit ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Exit #defaultString: 'Exit' #catalogID: #pdp) 							#value: #exit ) ) #(3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #View #defaultString: 'View' #catalogID: #pdp) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ShowAll #defaultString: 'Show All' #catalogID: #pdp) 							#value: #showAll ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ShowUser #defaultString: 'Show User' #catalogID: #pdp) 							#value: #showUser ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ShowSystem #defaultString: 'Show System' #catalogID: #pdp) 							#value: #showSystem ) ) #(3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Process #defaultString: 'Process' #catalogID: #pdp) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Debug #defaultString: 'Debug' #catalogID: #pdp) 							#value: #debugProcess 							#enablementSelector: #enableDebug ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #View #defaultString: 'View' #catalogID: #pdp) 							#value: #viewProcess 							#enablementSelector: #menuCommandEnablement ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Terminate #defaultString: 'Terminate' #catalogID: #pdp) 							#value: #terminateProcess 							#enablementSelector: #menuCommandEnablement ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Dump #defaultString: 'Dump' #catalogID: #pdp) 							#value: #dumpProcess 							#enablementSelector: #menuCommandEnablement ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Inspect #defaultString: 'Inspect' #catalogID: #pdp) 							#value: #inspectProcess 							#enablementSelector: #menuCommandEnablement ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Proceed #defaultString: 'Proceed' #catalogID: #pdp) 							#value: #proceedProcess 							#enablementSelector: #enableProceed ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ChangePriority #defaultString: 'Change Priority' #catalogID: #pdp) 							#value: #changeProcessPriority 							#enablementSelector: #menuCommandEnablement ) ) #(7 ) nil ) ) ) #(3 ) nil ) decodeAsLiteralArray</body><body package="Debugger-Process Monitor" selector="processMenu">processMenu	"MenuEditor new openOnClass: self andSelector: #processMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Debug #defaultString: 'Debug' #catalogID: #pdp) 				#value: #debugProcess 				#enablementSelector: #enableDebug ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #View #defaultString: 'View' #catalogID: #pdp) 				#value: #viewProcess 				#enablementSelector: #menuCommandEnablement ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Terminate #defaultString: 'Terminate' #catalogID: #pdp) 				#value: #terminateProcess 				#enablementSelector: #menuCommandEnablement ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Dump #defaultString: 'Dump' #catalogID: #pdp) 				#value: #dumpProcess 				#enablementSelector: #menuCommandEnablement ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Inspect #defaultString: 'Inspect' #catalogID: #pdp) 				#value: #inspectProcess 				#enablementSelector: #menuCommandEnablement ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Proceed #defaultString: 'Proceed' #catalogID: #pdp) 				#value: #proceedProcess 				#enablementSelector: #enableProceed ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #ChangePriority #defaultString: 'Change Priority' #catalogID: #pdp) 				#value: #changeProcessPriority 				#enablementSelector: #menuCommandEnablement ) ) #(7 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>ProcessMonitorClient class</class-id> <category>interface specs</category><body package="Debugger-Process Monitor" selector="processSpec">processSpec	"Tools.UIPainter new openOnClass: self andSelector: #processSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #ProcessMonitor #defaultString: 'Process Monitor' #catalogID: #pdp) 			#bounds: #(#{Graphics.Rectangle} 640 512 1238 919 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.DataSetSpec} 					#properties: #(#{UI.PropertyListDictionary} #showVerticalLines false #allowColumnReordering true #rowSize 30 #allowColumnResizing true #allowSorting true #showHorizontalLines false ) 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #processList 					#model: #processList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #debugProcess ) 					#menu: #processMenu 					#columns: #(						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true ) 							#model: #'record name' 							#label: #(#{Kernel.UserMessage} #key: #NameOrCreator #defaultString: 'Name or Creator' #catalogID: #pdp) 							#labelIsImage: false 							#width: 240 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true ) 							#model: #'record priority' 							#label: #(#{Kernel.UserMessage} #key: #Priority #defaultString: 'Priority' #catalogID: #pdp) 							#labelIsImage: false 							#width: 60 							#rendererType: #Text 							#editorType: #None 							#type: #number 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true ) 							#model: #'record processHash' 							#label: #(#{Kernel.UserMessage} #key: #Hash #defaultString: 'Hash' #catalogID: #pdp) 							#labelIsImage: false 							#width: 50 							#rendererType: #Text 							#editorType: #None 							#type: #number 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true ) 							#model: #'record state' 							#label: #(#{Kernel.UserMessage} #key: #State #defaultString: 'State' #catalogID: #pdp) 							#labelIsImage: false 							#width: 65 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true ) 							#model: #'record type' 							#label: #(#{Kernel.UserMessage} #key: #Type #defaultString: 'Type' #catalogID: #pdp) 							#labelIsImage: false 							#width: 50 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true ) 							#model: #'record topContext' 							#label: #(#{Kernel.UserMessage} #key: #WaitingContext #defaultString: 'Waiting Context' #catalogID: #pdp) 							#labelIsImage: false 							#width: 300 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) ) 					#multipleSelections: true 					#labelsAsButtons: true ) ) ) )</body><body package="Debugger-Process Monitor" selector="windowProcessSpec">windowProcessSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowProcessSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #ProcessMonitor #defaultString: 'Process Monitor' #catalogID: #pdp) 			#bounds: #(#{Graphics.Rectangle} 640 512 1238 919 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.DataSetSpec} 					#properties: #(#{UI.PropertyListDictionary} #showVerticalLines false #allowColumnReordering true #rowSize 30 #allowColumnResizing true #allowSorting true #showHorizontalLines false ) 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #processList 					#model: #processList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #debugProcess ) 					#menu: #processMenu 					#columns: #(						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true #labelFromApplication false ) 							#model: #'record windowLabel' 							#label: #(#{Kernel.UserMessage} #key: #Window #defaultString: 'Window' #catalogID: #pdp) 							#labelIsImage: false 							#width: 140 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true #labelFromApplication false ) 							#model: #'record name' 							#label: #(#{Kernel.UserMessage} #key: #ProcessNameOrCreator #defaultString: 'Process name or creator' #catalogID: #pdp) 							#labelIsImage: false 							#width: 180 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true ) 							#model: #'record priority' 							#label: #(#{Kernel.UserMessage} #key: #Priority #defaultString: 'Priority' #catalogID: #pdp) 							#labelIsImage: false 							#width: 60 							#rendererType: #Text 							#editorType: #None 							#type: #number 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true ) 							#model: #'record processHash' 							#label: #(#{Kernel.UserMessage} #key: #Hash #defaultString: 'Hash' #catalogID: #pdp) 							#labelIsImage: false 							#width: 50 							#rendererType: #Text 							#editorType: #None 							#type: #number 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true ) 							#model: #'record state' 							#label: #(#{Kernel.UserMessage} #key: #State #defaultString: 'State' #catalogID: #pdp) 							#labelIsImage: false 							#width: 65 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true ) 							#model: #'record type' 							#label: #(#{Kernel.UserMessage} #key: #Type #defaultString: 'Type' #catalogID: #pdp) 							#labelIsImage: false 							#width: 50 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true ) 							#model: #'record topContext' 							#label: #(#{Kernel.UserMessage} #key: #WaitingContext #defaultString: 'Waiting Context' #catalogID: #pdp) 							#labelIsImage: false 							#width: 300 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) ) 					#multipleSelections: true 					#labelsAsButtons: true ) ) ) )</body><body package="Debugger-Process Monitor" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #ProcessMonitor 				#defaultString: 'Process Monitor' 				#catalogID: #pdp ) 			#bounds: #(#{Graphics.Rectangle} 426 361 1024 768 ) 			#flags: 4 			#menu: #menu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 90 0 20 0 -110 1 49 0 ) 					#name: #Slider1 					#model: #intervalHolder 					#helpText: 					#(#{Kernel.UserMessage} 						#key: #SetSamplingInterval 						#defaultString: 'Set sampling interval' 						#catalogID: #pdp ) 					#orientation: #horizontal 					#start: 250 					#stop: 5000 					#step: 50 ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} -100 1 19 0 -35 1 44 0 ) 					#name: #InputField1 					#model: #intervalHolder 					#helpText: 					#(#{Kernel.UserMessage} 						#key: #SetSamplingInterval 						#defaultString: 'Set sampling interval' 						#catalogID: #pdp ) 					#type: #number ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} -30 1 21 0 ) 					#name: #Label1 					#label: 					#(#{Kernel.UserMessage} 						#key: #ms 						#defaultString: 'ms' 						#catalogID: #pdp ) ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 0 0 -2 1 55 0 ) 					#name: #GroupBox1 					#label: 					#(#{Kernel.UserMessage} 						#key: #Sample 						#defaultString: 'Sample' 						#catalogID: #pdp ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 13 20 77 45 ) 					#name: #sampleCntrl 					#model: #toggleSampling 					#helpText: 					#(#{Kernel.UserMessage} 						#key: #ControlSamplingProcess 						#defaultString: 'Control sampling process' 						#catalogID: #pdp ) 					#label: #sampleCntrlLabel 					#defaultable: true ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -28 1 0 0.5 0 1 ) 					#name: #numProcsLbl 					#flags: 12 					#model: #numProcHolder 					#helpText: 					#(#{Kernel.UserMessage} 						#key: #NumberOfProcesses 						#defaultString: 'Number of processes' 						#catalogID: #pdp ) 					#isReadOnly: true 					#tabRequiresControl: true 					#isWrapped: false ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.5 -28 1 0 1 0 1 ) 					#name: #TextEditor1 					#flags: 12 					#model: #memSizeHolder 					#helpText: 					#(#{Kernel.UserMessage} 						#key: #AmountOfAllocatedMemory 						#defaultString: 'Amount of allocated memory' 						#catalogID: #pdp ) 					#isReadOnly: true 					#tabRequiresControl: true 					#isWrapped: false ) 				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 60 0 0 1 -30 1 ) 					#name: #tabControl 					#model: #tabs 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #tabsChanged ) 					#tabable: false 					#labels: #() ) ) ) )</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>actions</category><body package="Debugger-Process Monitor" selector="openProcessMonitor">openProcessMonitor	&lt;menuItem: #(#OpenProcess_Monitor #pdp 'Open Process &amp;Monitor')		icon: nil		nameKey: nil		menu: #(#menuBar #probes)		position: 100&gt;	ProcessMonitorService open</body></methods><initialize><class-id>ProcessMonitorClient</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>CompiledCode</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>bytes </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Process</name><environment>Kernel</environment><super>Core.Link</super><private>false</private><indexed-type>none</indexed-type><inst-vars>suspendedContext priority myList depth hostThreadKey interruptProtect environment isSystem name inDebug </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Processes</category><attributes><package>Kernel-Processes</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector toolDock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class></st-source>