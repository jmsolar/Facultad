<?xml version="1.0"?><st-source><!-- Name: Arbor HypertextNotice: Copyright © 2002 Cincom Systems, Inc.  All Rights Reserved.Comment: Provides generic support for hypertext in a standard text view.DbIdentifier: bear73DbTrace: 28909DevelopmentPrerequisites: #(#(#any 'Arbor Help System Widget Help Core' ''))PackageName: Arbor HypertextParcel: #('Arbor Hypertext')ParcelName: Arbor HypertextPrerequisiteParcels: #(#('Arbor Help System Widget Help Core' ''))PrintStringCache: (7 - 0.2,bobw)Version: 7.2Date: 1:27:11 pm October 20, 2003 --><time-stamp>From VisualWorks®, 7.2 of October 20, 2003 on October 20, 2003 at 1:27:11 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ArborHyperlink</name><environment>VWHelp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>linkObject </inst-vars><class-inst-vars>color emphasis </class-inst-vars><imports></imports><category>Help-Arbor Hypertext</category><attributes><package>Arbor Hypertext</package></attributes></class><comment><class-id>VWHelp.ArborHyperlink</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:linkObject	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>ArborReversibleColorValue</name><environment>VWHelp</environment><super>Graphics.ColorValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Arbor Widget Extensions</category><attributes><package>Arbor Hypertext</package></attributes></class><comment><class-id>VWHelp.ArborReversibleColorValue</class-id><body>Copyright 1998 AppNet Systems, Inc.ArborReversibleColorValueInstances of this class have an added property in that they are able to reverse its color when installing themselves on a GraphicsContext.  During the #installOn: process, the graphics context is checked to see if the last paint applied appeared to be SymbolicPaint selectionForeground.  If so, and the selectionForeground color is different from the foreground color, then an inverse of the defined color is placed on the graphics context rather than the actual color defined by its instance variables.  Why is this useful?  Glad you asked...When a Text object is displayed on the graphics context (via a subclass of ComposedTextView), the only object that is aware of whether the text is selected or not is the view itself.  If the default system color is used for the #foreground color, the system is able to adjust the color correctly to display an appropriate #selectionForeground when it is highlighted.  However, if the Text has a color applied to it as part of its emphasis, the system displays that specified color regardless of whether or not the text is selected (through a rather complex sequence of events, but it generally boils down to a SyntheticFont being created with the desired color, and this is what displays the text - obviously the knowledge of whether or not the text is selected is lost at this level).  However, the graphics context still 'knows' because it's devicePaint is still set to what the ComposedTextView set it to - "SymbolicPaint selectionForeground".  So if an instance of ArborReversibleColorValue is used to colorize text, when it is highlighted in a text editor it will display a reversed color instead, usually providing a good bit more contrast and thereby allowing the user to read the text even when highlighted.Got it?</body></comment><class><name>ArborHypertextSelectionTracker</name><environment>VWHelp</environment><super>UI.TextSelectionTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Arbor Hypertext</category><attributes><package>Arbor Hypertext</package></attributes></class><comment><class-id>VWHelp.ArborHypertextSelectionTracker</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:</body></comment><class><name>ArborHypertextEditorController</name><environment>VWHelp</environment><super>UI.TextEditorController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Arbor Hypertext</category><attributes><package>Arbor Hypertext</package></attributes></class><comment><class-id>VWHelp.ArborHypertextEditorController</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:Class Variables:FingerCursor	&lt;ClassOfVariable&gt;	description of variable''s function</body></comment><class><name>ArborHypertextController</name><environment>VWHelp</environment><super>VWHelp.ArborHypertextEditorController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Arbor Hypertext</category><attributes><package>Arbor Hypertext</package></attributes></class><comment><class-id>VWHelp.ArborHypertextController</class-id><body>ArborHypertextControllerIntended to be used with TextView instances (NOT TextEditorView instances!)</body></comment><class><name>ArborHyperlinkAssociation</name><environment>VWHelp</environment><super>Core.Association</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Arbor Hypertext</category><attributes><package>Arbor Hypertext</package></attributes></class><comment><class-id>VWHelp.ArborHyperlinkAssociation</class-id><body>ArborHyperlinkAssociationAn extension to Association providing necessary tweaks to normal Association behavior when used as part of a Text's emphasis.  In particular, #supersedesAsTextEmphasis now checks both the key and value before answering true, ensuring that different hyperlinks are not considered equivalent.</body></comment><class><name>ArborHypertext</name><environment>VWHelp</environment><super>Core.Text</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Arbor Hypertext</category><attributes><package>Arbor Hypertext</package></attributes></class><comment><class-id>VWHelp.ArborHypertext</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:</body></comment><shared-variable><name>FingerCursor</name><environment>VWHelp.ArborHypertextEditorController</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Arbor Hypertext</package></attributes></shared-variable><methods><class-id>VWHelp.ArborHyperlink</class-id> <category>comparing</category><body package="Arbor Hypertext">= anotherHyperLinkObject	"Base equality solely on the linkObject.  This is most useful when looking to remove links from a hypertext - when told to remove links of a given linkObject, all will be removed."	^self species == anotherHyperLinkObject species		and: [self linkObject = anotherHyperLinkObject linkObject]</body><body package="Arbor Hypertext">hash	^self linkObject hash</body></methods><methods><class-id>VWHelp.ArborHyperlink</class-id> <category>resources</category><body package="Arbor Hypertext">textEmphasis	^self class textEmphasis</body></methods><methods><class-id>VWHelp.ArborHyperlink</class-id> <category>converting</category><body package="Arbor Hypertext">asEmphasis	^ArborHyperlinkAssociation value: self</body></methods><methods><class-id>VWHelp.ArborHyperlink</class-id> <category>accessing</category><body package="Arbor Hypertext">linkObject	^linkObject</body><body package="Arbor Hypertext">linkObject: anObject	linkObject := anObject</body></methods><methods><class-id>VWHelp.ArborHyperlink</class-id> <category>engaging</category><body package="Arbor Hypertext">engageFor: anObject	"The hyperlink has been engaged within the context of anObject."	^self subclassResponsibility</body></methods><methods><class-id>VWHelp.ArborHyperlink</class-id> <category>copying</category><body package="Arbor Hypertext">postCopy	super postCopy.	linkObject := linkObject copy</body></methods><methods><class-id>VWHelp.ArborHyperlink</class-id> <category>testing</category><body package="Arbor Hypertext">supersedesAsTextEmphasis: aLinkObject	"Tests for superceding should only concern themselves with the link object.  This method is only here in case a decision is made at some point to override #= in a subclass, which otherwise could cause bad behavior when editing hyperText."	^self species = aLinkObject species		and: [self linkObject = aLinkObject linkObject]</body></methods><methods><class-id>VWHelp.ArborHyperlink class</class-id> <category>color &amp; emphasis</category><body package="Arbor Hypertext">color	^color  = #none		ifTrue: [nil]		ifFalse: [			(color isNil or: [color = #default])				ifTrue: [self defaultColor]				ifFalse: [color]]</body><body package="Arbor Hypertext">color: aValue	"Set the hyperlink color (may be a ColorValue, nil, #none, or #default)."	color := aValue.</body><body package="Arbor Hypertext">defaultColor	"Answer the default color for the hyperlink.  A nil value indicates no special coloring."	^nil</body><body package="Arbor Hypertext">defaultEmphasis	"Answer the default non-color emphasis for the hyperlink.  May be a single emphasis, a collection, or nil."	^nil</body><body package="Arbor Hypertext">emphasis	^emphasis  = #none		ifTrue: [nil]		ifFalse: [			(emphasis isNil or: [emphasis = #default])				ifTrue: [self defaultEmphasis]				ifFalse: [emphasis]]</body><body package="Arbor Hypertext">emphasis: aValue	"Set the hyperlink emphasis (may be a single emphasis, a collection, nil, #none, or #default)."	emphasis := aValue.</body><body package="Arbor Hypertext">textEmphasis	"Answer the emphasis to use when displaying this hyperlink, built from the #color and #emphasis attributes."	| result emph |	result := Array new writeStream.	((emph := self emphasis) isSequenceable and: [emph isSymbol not])		ifTrue: [result nextPutAll: emph]		ifFalse: [emph notNil ifTrue: [result nextPut: emph]].	self color notNil		ifTrue: [result nextPut: #color-&gt;self color].	emph := result contents.	^emph isEmpty		ifTrue: [nil]		ifFalse: [			emph size = 1				ifTrue: [emph first]				ifFalse: [emph]]</body></methods><methods><class-id>VWHelp.ArborHyperlink class</class-id> <category>defaulting</category><body package="Arbor Hypertext">defaultColorValueClass	"Use Arbor's reversible color value if possible (which reverses its color when highlighted), otherwise use ColorValue."	^#{ArborReversibleColorValue} valueOrDo: [ColorValue]</body></methods><methods><class-id>VWHelp.ArborHyperlink class</class-id> <category>instance creation</category><body package="Arbor Hypertext">newLink: anObject	"creates an instance of a hyper link"	^self new linkObject: anObject</body></methods><methods><class-id>VWHelp.ArborReversibleColorValue</class-id> <category>private</category><body package="Arbor Hypertext">reversedFor: aColorValue	"Given aColorValue, answer a ColorValue that should have a high degree of contrast."	"This simple implementation ignores aColorValue and simply inverts everything, then brightens the resulting color up if too dim.  Subclasses may override this method to make it sensitive to aColorValue."	| color |	color := ColorValue				scaledRed: MaxValue - red				scaledGreen: MaxValue - green				scaledBlue: MaxValue - blue.	^(color brightness &lt; 0.8)		ifTrue: [ColorValue hue: color hue saturation: color saturation brightness: 0.8]		ifFalse: [color]</body></methods><methods><class-id>VWHelp.ArborReversibleColorValue</class-id> <category>installing</category><body package="Arbor Hypertext">installOn: aGraphicsContext	"Install a device paint representing the receiver on aGraphicsContext."	| fore selectionFore |	fore := aGraphicsContext paintPreferencesMatchAt: SymbolicPaint foreground.	selectionFore := aGraphicsContext paintPreferencesMatchAt: SymbolicPaint selectionForeground.	(fore ~= selectionFore		and: [(selectionFore asDevicePaintOn: aGraphicsContext medium) = aGraphicsContext aisDevicePaint])			ifTrue: [				"The ideal thing here would be to get the color of #selectionBackground from the graphics device's palette and use that as the basis for a color inversion.  Unfortunately, those values are generally DevicePaints which are not easily mapped back into ColorValues.  So we must request a simple color inversion rather than an inversion based on a known selection color.  In general, the selection background color will be dark, so any reasonably light color should be acceptable."				aGraphicsContext setPaintToColor: (self reversedFor: ColorValue veryDarkGray)]			ifFalse: [super installOn: aGraphicsContext]</body></methods><methods><class-id>VWHelp.ArborReversibleColorValue class</class-id> <category>constants</category><body package="Arbor Hypertext">black	^self newFrom: super black</body><body package="Arbor Hypertext">blue	^self newFrom: super blue</body><body package="Arbor Hypertext">brown	^self newFrom: super brown</body><body package="Arbor Hypertext">chartreuse	^self newFrom: super chartreuse</body><body package="Arbor Hypertext">cyan	^self newFrom: super cyan</body><body package="Arbor Hypertext">darkCyan	^self newFrom: super darkCyan</body><body package="Arbor Hypertext">darkGray	^self newFrom: super darkGray</body><body package="Arbor Hypertext">darkGreen	^self newFrom: super darkGreen</body><body package="Arbor Hypertext">darkMagenta	^self newFrom: super darkMagenta</body><body package="Arbor Hypertext">darkRed	^self newFrom: super darkRed</body><body package="Arbor Hypertext">gray	^self newFrom: super gray</body><body package="Arbor Hypertext">green	^self newFrom: super green</body><body package="Arbor Hypertext">lightCyan	^self newFrom: super lightCyan</body><body package="Arbor Hypertext">lightGray	^self newFrom: super lightGray</body><body package="Arbor Hypertext">lightYellow	^self newFrom: super lightYellow</body><body package="Arbor Hypertext">magenta	^self newFrom: super magenta</body><body package="Arbor Hypertext">navy	^self newFrom: super navy</body><body package="Arbor Hypertext">olive	^self newFrom: super olive</body><body package="Arbor Hypertext">orange	^self newFrom: super orange</body><body package="Arbor Hypertext">orchid	^self newFrom: super orchid</body><body package="Arbor Hypertext">paleGreen	^self newFrom: super paleGreen</body><body package="Arbor Hypertext">pink	^self newFrom: super pink</body><body package="Arbor Hypertext">purple	^self newFrom: super purple</body><body package="Arbor Hypertext">red	^self newFrom: super red</body><body package="Arbor Hypertext">royalBlue	^self newFrom: super royalBlue</body><body package="Arbor Hypertext">salmon	^self newFrom: super salmon</body><body package="Arbor Hypertext">springGreen	^self newFrom: super springGreen</body><body package="Arbor Hypertext">veryDarkGray	^self newFrom: super veryDarkGray</body><body package="Arbor Hypertext">veryLightGray	^self newFrom: super veryLightGray</body><body package="Arbor Hypertext">white	^self newFrom: super white</body><body package="Arbor Hypertext">yellow	^self newFrom: super yellow</body></methods><methods><class-id>VWHelp.ArborReversibleColorValue class</class-id> <category>instance creation</category><body package="Arbor Hypertext">newFrom: aColorValue	"Answer a new instance of myself that is based on aColorValue."	^aColorValue copy changeClassToThatOf: self basicNew</body></methods><methods><class-id>VWHelp.ArborHypertextSelectionTracker</class-id> <category>events</category><body package="Arbor Hypertext">redButtonReleasedEvent: aMouseButtonEvent	"Our controller wants to know when the red button is released because it uses that to do hyperlinking."	| ctrlr |	ctrlr := self controller.	super redButtonReleasedEvent: aMouseButtonEvent.	ctrlr redButtonReleasedEvent: aMouseButtonEvent.</body></methods><methods><class-id>VWHelp.ArborHypertextEditorController</class-id> <category>private-hypermedia</category><body package="Arbor Hypertext">availableLink: aMouseEvent	"Answer the hyperlink at the location identified by aMouseEvent, or nil if there isn't a hyperlink there."	^(self cursorInViewFrom: aMouseEvent)		ifTrue: [| aHyperText |			aHyperText := self trackTextPosition: (self cursorPointInViewFrom: aMouseEvent).			aHyperText notNil				ifTrue: [aHyperText firstAvailableLink]]</body><body package="Arbor Hypertext">checkHyperlinks: aMouseEvent	"Tweak cursor if necessary, and if the red &lt;select&gt; button is pressed then engage hyperlink if necessary. Answer true if a hyperlink was engaged."	| link |	(link := self availableLink: aMouseEvent) notNil		ifTrue: [^self engageIfPossible: link withEvent: aMouseEvent].	Cursor normal show.	^false</body><body package="Arbor Hypertext">engageIfPossible: aLink withEvent: aMouseEventOrNil	"Try to engage the hyperlink.  If successfully engaged, answer true."	self canEngageHypermedia		ifTrue: [			self class hyperFinger show.			(self shouldEngageHypermedia: aMouseEventOrNil)				ifTrue: ["jump to the hyperlink"					Cursor normal show.					Object errorSignal						handle: [:ex |							"There is a handler for any exception raised during the control sequence in VisualPart&gt;&gt;objectWantingControl which will result in closing the active window (via the handler in ControlManager&gt;&gt;activeControllerLoop).  Since typos and whatnot fall into that category, this can make for frustrating debugging.  To work around this problem, any exception raised during a hyperlink action is trapped and re-raised as an information signal, which circumvents the standard handler and will result in a walkback opening."							Object informationSignal raiseErrorString: ex errorString]						do: [aLink engageFor: self performer].					^true]]		ifFalse: [Cursor normal show].	^false</body></methods><methods><class-id>VWHelp.ArborHypertextEditorController</class-id> <category>events</category><body package="Arbor Hypertext">mouseMovedEvent: event	self checkHyperlinks: event.	^super mouseMovedEvent: event</body><body package="Arbor Hypertext">redButtonPressedEvent: event	"Only allow red button presses through if we're not read only."	^self readOnly		ifTrue: [nil]		ifFalse: [super redButtonPressedEvent: event]</body><body package="Arbor Hypertext">redButtonReleasedEvent: event	((self checkHyperlinks: event) not and: [self readOnly not])		ifTrue: [^super redButtonReleasedEvent: event].	^nil</body></methods><methods><class-id>VWHelp.ArborHypertextEditorController</class-id> <category>event driven</category><body package="Arbor Hypertext">handlerForMouseEvent: aMouseEvent 	"We want redButtonPressed and mouseMoved events	in order to change the cursor and engage hyperlinks"	^((aMouseEvent isButtonReleasedEvent and: [aMouseEvent redButtonReleased])		or: [aMouseEvent isKindOf: MouseMovedEvent])			ifTrue: [(self viewHasCursorWithEvent: aMouseEvent) 						ifTrue: [self getEventHandler]						ifFalse: [nil]]			ifFalse: [super handlerForMouseEvent: aMouseEvent]</body><body package="Arbor Hypertext">selectionTracker	^ArborHypertextSelectionTracker on: self</body></methods><methods><class-id>VWHelp.ArborHypertextEditorController</class-id> <category>testing</category><body package="Arbor Hypertext">canEngageHypermedia	"Answer true if things are in a state where a hyperlink may be invoked."	^self readOnly or: [self sensor ctrlDown]</body><body package="Arbor Hypertext">shouldEngageHypermedia: aMouseEventOrNil	"Answer true if it appears that conditions allow for engaging a hyperlink.  nil is used for non-event driven environments.  Use the button-up state in event-driven environments to better mimic existing hypertext browsers."	^aMouseEventOrNil isNil		ifTrue: [self sensor redButtonPressed]		ifFalse: [			aMouseEventOrNil isButtonReleasedEvent				and: [aMouseEventOrNil redButtonReleased]]</body></methods><methods><class-id>VWHelp.ArborHypertextEditorController</class-id> <category>private</category><body package="Arbor Hypertext">characterIsValid: aCharacter 	"Ignore non valid characters like cr, lf, space, nil."	^(aCharacter isNil		or: [aCharacter = Character cr			or: [aCharacter = Character lf]]) not</body><body package="Arbor Hypertext">cursorInViewFrom: anEvent	"Answer true if the mouse cursor is within the bounds of the view.  Use anEvent if non-nil."	^anEvent isNil		ifTrue: [self viewHasCursor]		ifFalse: [self viewHasCursorWithEvent: anEvent]</body><body package="Arbor Hypertext">cursorPointInViewFrom: anEvent	"Answer the associated cursor/mouse point in local coordinates.  Use anEvent if non-nil."	^anEvent isNil		ifTrue: [self sensor cursorPoint]		ifFalse: [self sensor mousePointFor: anEvent]</body><body package="Arbor Hypertext">setEmphasisHere	"We don't want the default emphasis to include any hyperlinks!"	emphasisHere := self text asArborHypertext rawEmphasisAt: self selectionStartIndex</body><body package="Arbor Hypertext">trackTextPosition: aPoint	"checks if the pointer is over a text. If it is and the text is a hypertext then return 	the (hyper) character corresponding to the pointer location."	| characterIndex aCharacterBlock aCharacter |	aCharacterBlock := self view characterBlockAtPoint: aPoint.	aCharacter := aCharacterBlock character.	(self characterIsValid: aCharacter)		ifFalse: [characterIndex := nil]		ifTrue: [			characterIndex := aCharacterBlock stringIndex.			"Account for the characterBlock calculation being based on the character center rather than the edge."			aPoint x &lt; aCharacterBlock left				ifTrue: [characterIndex := characterIndex - 1]].	^characterIndex isNil		ifTrue: [nil]		ifFalse: [(self view displayContents text copyFrom: characterIndex to: characterIndex) asArborHypertext]</body></methods><methods><class-id>VWHelp.ArborHypertextEditorController</class-id> <category>basic control sequence</category><body package="Arbor Hypertext">controlTerminate	"Restore the cursor, but only if non-event driven."	super controlTerminate.	self sensor window isEventDriven		ifFalse: [Cursor normal show].</body></methods><methods><class-id>VWHelp.ArborHypertextEditorController</class-id> <category>control defaults</category><body package="Arbor Hypertext">isControlWanted	self checkHyperlinks: nil.	self viewHasCursor		ifFalse: [^false].	^super isControlWanted</body></methods><methods><class-id>VWHelp.ArborHypertextEditorController class</class-id> <category>class accessing</category><body package="Arbor Hypertext">hyperFinger	FingerCursor isNil		ifTrue: [self initializeCursors].	^FingerCursor</body></methods><methods><class-id>VWHelp.ArborHypertextEditorController class</class-id> <category>class initialization</category><body package="Arbor Hypertext">initializeCursors	"self initializeCursors"	FingerCursor := 		Cursor			imageArray: #(				2r0001100000000000				2r0010010000000000				2r0010010000000000				2r0001001110110000				2r0001001001001110				2r0001001001001001				2r0110101001001001				2r1001100000000001				2r1000100000000010				2r0100000000000010				2r0010000000000010				2r0001000000000100				2r0001000000000100				2r0000100000001000				2r0000010000001000				2r0000010000001000)			maskArray: #(				2r0001100000000000				2r0011110000000000				2r0011110000000000				2r0001111110110000				2r0001111111111110				2r0001111111111111				2r0111111111111111				2r1111111111111111				2r1111111111111110				2r0111111111111110				2r0011111111111110				2r0001111111111100				2r0001111111111100				2r0000111111111000				2r0000011111111000				2r0000011111111000)			hotSpot: 4@1			name: 'hyper finger'</body></methods><methods><class-id>VWHelp.ArborHypertextController</class-id> <category>private</category><body package="Arbor Hypertext">doAccept	"Send the accept message to the model.  Answer what the model answers."	| acceptMsg |	acceptMsg := view acceptMessage.	acceptMsg == nil ifTrue: [view flash. ^ false].	^ acceptMsg numArgs = 1		ifTrue:  "one arg selectors get text only"			[model perform: acceptMsg with: self text]		ifFalse:  "two arg selectors get text and controller as well"			[model perform: acceptMsg with: self text with: self]</body></methods><methods><class-id>VWHelp.ArborHypertextController</class-id> <category>menu messages</category><body package="Arbor Hypertext">accept	(self textHasChanged and: [model changeRequestFrom: view])		ifFalse: [^view flash].	self doAccept		ifTrue: [self textHasChanged: false]		ifFalse: [view flash]</body><body package="Arbor Hypertext">alwaysAccept	"Try to do an accept even if the text is the same."	(model changeRequestFrom: view)		ifFalse: [^view flash].	self doAccept		ifTrue: [self textHasChanged: false]		ifFalse: [view flash]</body><body package="Arbor Hypertext">alwaysAcceptKey: aCharEvent	"The carriage return was typed by the user.	This designates that the receiver should give up control.	Try to do an accept even if the text is the same."	self alwaysAccept</body></methods><methods><class-id>VWHelp.ArborHypertextController</class-id> <category>model access</category><body package="Arbor Hypertext">model: aModel	super model: aModel.	self performer: aModel</body></methods><methods><class-id>VWHelp.ArborHypertextController</class-id> <category>initialize-release</category><body package="Arbor Hypertext">initializeMenu	self menuHolder: ((PluggableAdaptor on: self)			getBlock: [:cont | | menuMsg |						menuMsg := cont view menuMessage.						menuMsg == nil							ifTrue: [nil]							ifFalse: [cont model perform: menuMsg]]			putBlock: [:cont :v | ]			updateBlock: [:cont :a :p | false])</body></methods><methods><class-id>VWHelp.ArborHyperlinkAssociation</class-id> <category>testing</category><body package="Arbor Hypertext">hasStandardLinkTag	^self key = self class hyperlinkTag</body><body package="Arbor Hypertext">isArborHyperlinkAssociation	^true</body><body package="Arbor Hypertext">supersedesAsTextEmphasis: aTextEmphasis 	"Pass the superseding test on to my value - this is important for AHSHelpHyperlinkObjects."	^(super supersedesAsTextEmphasis: aTextEmphasis)		and: [self value supersedesAsTextEmphasis: aTextEmphasis value]</body></methods><methods><class-id>VWHelp.ArborHyperlinkAssociation</class-id> <category>printing</category><body package="Arbor Hypertext">printOn: aStream 	"Append to the argument, aStream, the two elements of the 	Association separated by a right arrow."	aStream print: self key; nextPutAll: '~&gt;'; print: self value</body></methods><methods><class-id>VWHelp.ArborHyperlinkAssociation class</class-id> <category>instance creation</category><body package="Arbor Hypertext">value: value	"Answer a new instance of the receiver with the key defaulted to the hyperlink tag and the value being the argument."	^self key: self hyperlinkTag value: value</body></methods><methods><class-id>VWHelp.ArborHyperlinkAssociation class</class-id> <category>constants</category><body package="Arbor Hypertext">hyperlinkTag	"Answer the symbol used as the key for any hyperlink association embedded in an ArborHypertext."	^#aisHyperlink</body></methods><methods><class-id>VWHelp.ArborHypertext</class-id> <category>private</category><body package="Arbor Hypertext">linkBoundsAt: anInteger	"Private - Answer an Interval containing the starting and stopping position of the link located at anInteger."	^runs aisBoundsForAttributeAt: anInteger</body><body package="Arbor Hypertext">reduceEmphasis: emphasis 	"Flatten emphasis into a single-level array.  Keep the hyperlink emphasis present, but embed it in an Array."	emphasis isSymbol ifTrue: [^Array with: emphasis].	(self isHyperLink: emphasis)	ifTrue: [^(self reduceEmphasis: emphasis value textEmphasis), (Array with: emphasis)].	emphasis isSequenceable ifTrue: [| str |		str := (Array new: 10) writeStream.		emphasis do: [:emph | str nextPutAll: (self reduceEmphasis: emph)].		^str contents].	^Array with: emphasis</body></methods><methods><class-id>VWHelp.ArborHypertext</class-id> <category>accessing</category><body package="Arbor Hypertext">collectHypermediaAround: anIndex	"Collect all hypermedia immediately around (to the left 	and right) the character in the position anIndex."	| bounds |	bounds := self linkBoundsAt: anIndex.	^ self 		copyFrom: bounds first		to: bounds last</body><body package="Arbor Hypertext">firstAvailable: aBlock	"Returns the first available link using block test on this text, or nil. For efficiency, loops only through the runs values"	runs values do: [:emphasis | 		(emphasis isSymbol not and: [emphasis isSequenceable]) 			ifTrue: [emphasis do: [:item | (aBlock value: item) ifTrue:[^item value]]]			ifFalse: [(aBlock value: emphasis) ifTrue: [^emphasis value]]].	^nil</body><body package="Arbor Hypertext">firstAvailableLink	"returns the first available Hyper link found in the text or nil"	^self firstAvailable: [:item | self isHyperLink: item]</body><body package="Arbor Hypertext">replaceFrom: start to: stop with: aTextOrString	"If aTextOrString is a string or a text with no emphasis then leave the original emphasis alone when replacing the range."	^aTextOrString isString		ifTrue: [self replaceStringFrom: start to: stop with: aTextOrString]		ifFalse: [super replaceFrom: start to: stop with: aTextOrString asArborHypertext]</body><body package="Arbor Hypertext">replaceStringFrom: start to: stop with: aTextOrString	"Replace the my string value only from start to stop with the entire contents of aTextOrString, leaving the existing emphasis intact."	| selectedText |	selectedText := self copyFrom: start to: stop.		selectedText replaceStringWith: aTextOrString.	super replaceFrom:start 	to: stop with: selectedText.</body><body package="Arbor Hypertext">replaceStringWith: aString	"Does replace of String, using the text emphasis of the receiver.  For cases where the string being copied is longer than the receiver string, it extends the emphasis of the last character."	| difference |	string := string 				changeFrom: 1 				to: self size 				with: aString.	(difference := string size - runs size) &gt; 0		ifTrue: [			runs isEmpty ifTrue: [				runs addLast: nil.				difference := difference - 1].			runs runs 				at: (runs runs size) 				put: (runs runs last + difference)]		ifFalse: [difference &lt; 0 ifTrue: [runs := runs copyFrom: 1 to: aString size]].</body></methods><methods><class-id>VWHelp.ArborHypertext</class-id> <category>emphasis</category><body package="Arbor Hypertext">addHyperlink: aLinkEmphasis 	"Change the text attributes to indicate that a hyper link exists."	self		addEmphasis: (Array with: aLinkEmphasis)		removeEmphasis: #()		allowDuplicates: false.</body><body package="Arbor Hypertext">addHyperlink: aLinkEmphasis from: start to: stop	"Change the text attributes to indicate that a hyper link exists."	self		addEmphasis: (Array with: aLinkEmphasis)		removeEmphasis: #()		allowDuplicates: false		from: start		to: stop</body><body package="Arbor Hypertext">emphasisAt: characterIndex 	"Answer the actual emphasis, plus any implied emphasis computed from any hyperlinks."	| emphasis |	emphasis := self reduceEmphasis: (super emphasisAt: characterIndex).	^emphasis size = 1		ifTrue: [emphasis first]		ifFalse: [emphasis]</body><body package="Arbor Hypertext">rawEmphasisAt: characterIndex 	"Answer the actual, unmodified emphasis at characterIndex."	^super emphasisAt: characterIndex</body><body package="Arbor Hypertext">removeAllHyperLinks	"Removes all Hyperlinks from selected text"	self aisAddEmphasis: #() removeEmphasisTest: [:emph | self isHyperLink: emph].</body><body package="Arbor Hypertext">removeAllStyle	"Removes all Style (Bold, Italics, etc.) from selected text, but leave hyperlinks"	self aisAddEmphasis: #() removeEmphasisTest: [:emph | (self isHyperLink: emph) not].</body></methods><methods><class-id>VWHelp.ArborHypertext</class-id> <category>printing</category><body package="Arbor Hypertext">printOn: aStream 	"Append to the argument aStream a sequence of characters that identifies the receiver."	aStream		nextPutAll: self class name;		nextPutAll: ' for: ';		print: string.</body><body package="Arbor Hypertext">storeOn: aStream 	"Append to the argument aStream a sequence of characters that is an expression 	whose evaluation creates text similar to the receiver."	aStream 		nextPut: $(;		nextPutAll: self class name;		nextPutAll: ' string: ';		store: string;		nextPutAll: ' runs: ';		store: runs;		nextPut: $)</body></methods><methods><class-id>VWHelp.ArborHypertext</class-id> <category>testing</category><body package="Arbor Hypertext">isHyperLink: anEmphasis	"Returns true if anEmphasis is a hyperlink"	^anEmphasis notNil		and: [anEmphasis aisIsAssociation		and: [anEmphasis isArborHyperlinkAssociation		and: [anEmphasis hasStandardLinkTag]]]</body></methods><methods><class-id>VWHelp.ArborHypertext</class-id> <category>converting</category><body package="Arbor Hypertext">asArborHypertext	^self</body></methods><methods><class-id>Core.RunArray</class-id> <category>Arbor Hypertext adds</category><body package="Arbor Hypertext">aisAdd: newEmphasis removeTest: removeBlock	"Taking each value in the receiver, add components found in newEmphasis and remove any components where removeBlock evaluates to true.  Store the new value in another RunArray.  Duplication is suppressed."	| last cellSize newValues newRuns |	last := nil.	cellSize := 0.	newValues := (Array new: runs size) writeStream.	newRuns := (Array new: runs size) writeStream.	1 to: runs size do: [:runIndex || new |		new := self aisPrivateAdd: newEmphasis removeTest: removeBlock to: (values at: runIndex).		(new = last or: [cellSize = 0])			ifFalse:	[				newValues nextPut: last.				newRuns nextPut: cellSize.				cellSize := 0].		cellSize := cellSize + (runs at: runIndex).		last := new].	cellSize &gt; 0		ifTrue: [			newValues nextPut: last.			newRuns nextPut: cellSize].	^self class runs: newRuns contents values: newValues contents</body><body package="Arbor Hypertext">aisBoundsForAttributeAt: anInteger	"Answer an Interval containing the start and stop points for the attribute located at anInteger."	| result |	self		at: anInteger		setRunAndOffset: 			[:run :offset || start |			start := anInteger - offset.			result := Interval 						from: start						to: start + (runs at: run) - 1].	^ result</body><body package="Arbor Hypertext">aisPrivateAdd: addValues removeTest: removeBlock to: value 	"Begin with 'value', add components found in addValues, remove any	items that test true in the removeBlock, answer the result. "	| v existingValues |	value == nil		ifTrue: [existingValues := v := OrderedCollection new: addValues size + 5]		ifFalse: [value class == Array			ifTrue: [v := OrderedCollection new: addValues size + value size + 5.					existingValues := value.					1 to: value size do: [:i | v add: (value at: i)]]			ifFalse: [existingValues := v := OrderedCollection new: addValues size + 5.					v add: value]].	1 to: existingValues size do: [:i | | old |		old := existingValues at: i.		(removeBlock value: old) ifTrue: [v remove: old]].	v addAll: addValues.	^v isEmpty		ifTrue: [nil]		ifFalse: [v size = 1				ifTrue: [v at: 1]				ifFalse: [v asArray]]</body></methods><methods><class-id>Graphics.GraphicsContext</class-id> <category>Arbor Widgets adds</category><body package="Arbor Hypertext">aisDevicePaint	^devicePaint</body></methods><methods><class-id>Core.Text</class-id> <category>Arbor Hypertext adds</category><body package="Arbor Hypertext">aisAddEmphasis: newEmphasis removeEmphasisTest: removeBlock	"Add new emphases and remove and emphases where removeBlock evaluates to true."	runs := runs aisAdd: newEmphasis removeTest: removeBlock</body><body package="Arbor Hypertext">asArborHypertext	^#{VWHelp.ArborHypertext} value string: self string runs: self runs</body><body package="Arbor Hypertext">emphasesDo: aBlock	"Iterate through all emphases, evaluating aBlock for every atomic emphasis element.  aBlock is a two-parameter block - first is the emphasis, second is an interval describing the range it emphasizes."	| start |	start := 1.	runs runs with: runs values do: [:length :emph || range |		range := start to: (start := start + length) - 1.		self emphasis: emph do: [:e | aBlock value: e value: range]].</body><body package="Arbor Hypertext">emphasesLike: anEmphasis do: aBlock	"For each emphasis like anEmphasis, evaluate aBlock with the emphasis as a parameter."	self emphasesDo: [:emph :interval |		(anEmphasis supersedesAsTextEmphasis: emph)			ifTrue: [aBlock value: emph]].</body><body package="Arbor Hypertext">emphasis: anEmphasis do: aBlock	"Simple way to process an emphasis, which may be nil, a symbol, association, generic object, or array.  aBlock is a single-parameter block which is evaluated once for each atomic emphasis element."	(anEmphasis isSymbol not and: [anEmphasis isSequenceable])		ifTrue: [anEmphasis do: [:emph | self emphasis: emph do: aBlock]]		ifFalse: [aBlock value: anEmphasis].</body><body package="Arbor Hypertext">rawEmphasisAt: anIndex	"Polymorphism with ArborHypertext."	^self emphasisAt: anIndex</body></methods><methods><class-id>Core.Text</class-id> <category>Arbor Core adds</category><body package="Arbor Hypertext">replaceFrom: start to: stop with: aTextOrString startingAt: anInteger	"If not overridden, this method will answer a text with the emphases all stripped out.  This is undesireable for the most part, so it is added by Arbor."	^self		replaceFrom: start		to: stop		with: (aTextOrString copyFrom: anInteger to: (anInteger + stop - start))</body></methods><methods><class-id>Core.String</class-id> <category>Arbor Hypertext adds</category><body package="Arbor Hypertext">asArborHypertext	^#{VWHelp.ArborHypertext} value fromString: self</body></methods><methods><class-id>Core.LookupKey</class-id> <category>Arbor Hypertext adds</category><body package="Arbor Hypertext">isArborHyperlinkAssociation	^false</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>LookupKey</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>Association</name><environment>Core</environment><super>Core.LookupKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>Text</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string runs </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>ColorValue</name><environment>Graphics</environment><super>Graphics.SimplePaint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>red green blue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Support</category><attributes><package>Graphics-Support</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>TextSelectionTracker</name><environment>UI</environment><super>UI.ScrollingTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pivotBlock currentBlock nextBlock showingCaret gc prevStartBlock prevStopBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events-Trackers</category><attributes><package>Interface-Events-Trackers</package></attributes></class><class><name>GraphicsContext</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>medium clipOriginX clipOriginY clipWidth clipHeight lineWidth capStyle joinStyle deviceFont devicePaint offsetX offsetY phaseX phaseY scaleX scaleY font paint paintPolicy fontPolicy clientData paintPreferences </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Support</category><attributes><package>Graphics-Support</package></attributes></class><class><name>TextEditorController</name><environment>UI</environment><super>UI.ParagraphEditor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyboardProcessor keyboardHook readOnly accepted autoAccept continuousAccept tabMeansNextField tabRequiresControl dispatcher </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>UIBasics-Controllers</category><attributes><package>UIBasics-Controllers</package></attributes></class><class><name>RunArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>runs values cacheRun cacheRunStart </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class></st-source>