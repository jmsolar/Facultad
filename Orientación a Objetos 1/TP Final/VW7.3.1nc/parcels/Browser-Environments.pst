<?xml version="1.0"?><st-source><!-- Name: Browser-EnvironmentsNotice: Copyright © 2002-2005 Cincom Systems, Inc.  All Rights Reserved.Comment: This package contains the environments for the browser. A browser environment determines what a user of the browser can and cannot see within that browser. For example, an environment for implementers of X can only see the X methods.DbIdentifier: bear73DbTrace: 50535DevelopmentPrerequisites: #(#(#any 'Browser-Namespace' ''))PackageName: Browser-EnvironmentsParcel: #('Browser-Environments')PrerequisiteParcels: #(#('Browser-Namespace' ''))PrintStringCache: (7.3 - 1.4,bobw)Version: 7.3.1Date: 5:51:42 pm April 10, 2005 --><time-stamp>From VisualWorks®, 7.3.1 of April 10, 2005 on April 10, 2005 at 5:51:42 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>UnparceledParcel</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-Environments</package></attributes></class><comment><class-id>Refactory.Browser.UnparceledParcel</class-id><body>UnparceledParcel is a fake parcel that represents all unparceled items in the image.</body></comment><class><name>BrowserEnvironment</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label searchStrings </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><comment><class-id>Refactory.Browser.BrowserEnvironment</class-id><body>BrowserEnvironment represents the classes/methods that are to be browsed. Not only is this class the superclass of all environments, it also represents browsing everything.Instance Variables:	label	&lt;String&gt;	a description of what we're looking at	searchStrings	&lt;Collection of: String&gt;	strings to look for whenever we select a method</body></comment><class><name>BrowserEnvironmentWrapper</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserEnvironment</super><private>false</private><indexed-type>none</indexed-type><inst-vars>environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><comment><class-id>Refactory.Browser.BrowserEnvironmentWrapper</class-id><body>BrowserEnvironmentWrapper is a wrapper for BrowserEnvironments that limits what is shown. While it does not have any #subclassResponsibility methods, it is an abstract class since it doesn't provide any useful behavior by itselfInstance Variables:	environment	&lt;BrowserEnvironment&gt;	the environment we're wrapping</body></comment><class><name>VariableEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserEnvironmentWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instanceVariables instanceVariableReaders instanceVariableWriters selectorCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><comment><class-id>Refactory.Browser.VariableEnvironment</class-id><body>VariableEnvironment represents a set of classes and methods that refer to a set of instance variables.Instance Variables:	instanceVariables	&lt;Dictionary key: String value: (Set of: String)&gt;	Keys are the classes, values are the variables whose references are in this environment.	instanceVariableReaders	&lt;Dictionary key: String value: (Set of: String)&gt;	Keys are the classes, values are the selectors that read these instance variables.	instanceVariableWriters	&lt;Dictionary key: String value: (Set of: String)&gt;	Keys are the classes, values are the selectors that write to these instance variables.	selectorCache	&lt;Dictionary key: String value: (Set of: String)&gt;	Keys are the classes, values are the selectors that refer to these instance variables.</body></comment><class><name>ProtocolEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserEnvironmentWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>class protocols </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><comment><class-id>Refactory.Browser.ProtocolEnvironment</class-id><body>ProtocolEnvironment represents a collection of protocols in a class to be browsed.Instance Variables:	class	&lt;Behavior&gt;	the class that contains the protocols	protocols	&lt;Collection of: Symbol&gt;	the protocols to be browsed</body></comment><class><name>PundleEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserEnvironmentWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bundleNames packageNames </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><comment><class-id>Refactory.Browser.PundleEnvironment</class-id><body>PundleEnvironment represents all of the classes and methods in a set of bundles and packages.Instance Variables:	bundleNames	&lt;(SequenceableCollection of: String)&gt;	Bundles represented by this environment.	packageNames	&lt;(Collection of: String)&gt;	Packages represented by this environment.</body></comment><class><name>CategoryEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserEnvironmentWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>categories </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><comment><class-id>Refactory.Browser.CategoryEnvironment</class-id><body>CategoryEnvironment represents browsing some selected categories. All methods/classes not in the categories are not shown in the browser..Instance Variables:	categories	&lt;Collection of: Symbol&gt;	the category names to browse</body></comment><class><name>NotEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserEnvironmentWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><comment><class-id>Refactory.Browser.NotEnvironment</class-id><body>NotEnvironment represents the complement of its environment. It contains all of the methods and classes in the image that are NOT in its environment.</body></comment><class><name>SelectorEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserEnvironmentWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classSelectors metaClassSelectors initializers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><comment><class-id>Refactory.Browser.SelectorEnvironment</class-id><body>SelectorEnvironment represents a collection of methods to be browsed.Instance Variables:	classSelectors	&lt;Dictionary key: Symbol value: (Collection of: Symbol)&gt;	selectors for the class side	initializers	&lt;Collection&gt;	the binding references of all shared variable initializers in our environment	metaClassSelectors	&lt;Dictionary key: Symbol value: (Collection of: Symbol)&gt;	selectors for the metaclass side</body></comment><class><name>MethodDefinitionEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.SelectorEnvironment</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definitions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><comment><class-id>Refactory.Browser.MethodDefinitionEnvironment</class-id><body>MethodDefinitionEnvironment provided compatibility with the previous browsers so that the extra text of a method definition can be displayed.Instance Variables:	definitions	&lt;OrderedCollection of: GeneralMethodDefinition&gt;	all the method definitions</body></comment><class><name>AndEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserEnvironmentWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>andedEnvironment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><comment><class-id>Refactory.Browser.AndEnvironment</class-id><body>AndEnvironment represents an environment that contains all of the classes in methods that occur in its environment AND andedEnvironment.Instance Variables:	andedEnvironment	&lt;BrowserEnvironmentWrapper&gt;	The environment to AND with.</body></comment><class><name>ClassEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserEnvironmentWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classes metaClasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><comment><class-id>Refactory.Browser.ClassEnvironment</class-id><body>ClassEnvironment represents a collection of classes to be browsed.Instance Variables:	classes	&lt;Collection of: Symbol&gt;	the class names (not metaclasses)	metaClasses	&lt;Collection of: Symbol&gt;	the class names for the metaclasses that are selected</body></comment><class><name>ParcelEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserEnvironmentWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parcelNames </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><comment><class-id>Refactory.Browser.ParcelEnvironment</class-id><body>ParcelEnvironment contains all of the Classes and Methods within a set of parcels.Instance Variables:	parcelNames	&lt;(Collection of: String)&gt;	Parcels represented by this environment.</body></comment><methods><class-id>Refactory.Browser.UnparceledParcel</class-id> <category>comparing</category><body package="Browser-Environments" selector="=">= anObject 	^self class = anObject class</body><body package="Browser-Environments" selector="hash">hash	^self class hash</body></methods><methods><class-id>Refactory.Browser.UnparceledParcel</class-id> <category>no-op changes</category><body package="Browser-Environments" selector="addBinding:in:">addBinding: aBinding in: aNameSpace</body><body package="Browser-Environments" selector="addClass:">addClass: aClass</body><body package="Browser-Environments" selector="addEntiretyOfClass:">addEntiretyOfClass: aClass	"do nothing"</body><body package="Browser-Environments" selector="addName:in:">addName: aSymbol in: aNameSpace</body><body package="Browser-Environments" selector="addNameSpace:">addNameSpace: aNameSpace</body><body package="Browser-Environments" selector="addSelector:forClass:">addSelector: aSymbol forClass: aClass	"Do nothing since we aren't really a parcel"</body><body package="Browser-Environments" selector="addSelectors:forClass:">addSelectors: aCollection forClass: aClass</body><body package="Browser-Environments" selector="comment:">comment: aString</body><body package="Browser-Environments" selector="removeBinding:in:">removeBinding: aBinding in: aNameSpace</body><body package="Browser-Environments" selector="removeEntiretyOfClass:">removeEntiretyOfClass: aClass	"do nothing"</body><body package="Browser-Environments" selector="removeName:in:">removeName: aSymbol in: aNameSpace</body><body package="Browser-Environments" selector="removeNameSpace:">removeNameSpace: aNameSpace</body><body package="Browser-Environments" selector="removeSelectors:forClass:">removeSelectors: aCollection forClass: aClass</body></methods><methods><class-id>Refactory.Browser.UnparceledParcel</class-id> <category>querying</category><body package="Browser-Environments" selector="allClassesAndNameSpaces">allClassesAndNameSpaces	| unparceled |	unparceled := Set new.	BrowserEnvironment new classesDo: 			[:each | 			(self class isUnparceled: each) 				ifTrue: [unparceled add: each instanceBehavior]].	Root withAllNameSpacesDo: 			[:each | 			(self class isNameSpaceUnparceled: each) ifTrue: [unparceled add: each]].	^unparceled</body><body package="Browser-Environments" selector="allSharedReferencesDo:">allSharedReferencesDo: aBlock 	Root withAllNameSpacesDo: 			[:ns | 			ns bindingsDo: 					[:each | 					each isForGeneral 						ifTrue: [aBlock value: (ns fullyQualifiedReferenceOf: each key)]]]</body><body package="Browser-Environments" selector="definedBindingsFor:">definedBindingsFor: aClass 	| bindings |	bindings := OrderedCollection new.	aClass asNameSpace bindingsDo: 			[:each | 			| parcels |			parcels := Parcel parcelsForBinding: each.			(parcels isNil or: [parcels isEmpty]) ifTrue: [bindings add: each]].	^bindings</body><body package="Browser-Environments" selector="definedClasses">definedClasses	| unparceled |	unparceled := Set new.	BrowserEnvironment new classesDo: 			[:each | 			(Parcel isClassDefinedInParcel: each) 				ifFalse: [unparceled add: each instanceBehavior]].	^unparceled</body><body package="Browser-Environments" selector="definedNameSpaces">definedNameSpaces	^Root withAllNameSpaces 		select: [:each | (Parcel parcelsDefiningNameSpace: each) isEmpty]</body><body package="Browser-Environments" selector="definedSelectorsFor:">definedSelectorsFor: aClass 	^aClass selectors 		select: [:each | self definesSelector: each forClass: aClass]</body><body package="Browser-Environments" selector="definedStaticReferences">definedStaticReferences	| refs |	refs := Set new.	self allSharedReferencesDo: 			[:each | 			| parcels |			parcels := Parcel parcelsForBinding: each binding.			(parcels isNil or: [parcels isEmpty]) ifTrue: [refs add: each]].	^refs</body><body package="Browser-Environments" selector="definesClass:">definesClass: aClass 	^(Parcel parcelsDefiningClass: aClass) isEmpty</body><body package="Browser-Environments" selector="definesClassOrNameSpace:">definesClassOrNameSpace: aClassOrNameSpace 	^(aClassOrNameSpace isBehavior 		ifTrue: [Parcel parcelsDefiningClass: aClassOrNameSpace]		ifFalse: [Parcel parcelsDefiningNameSpace: aClassOrNameSpace]) isEmpty</body><body package="Browser-Environments" selector="definesName:in:">definesName: aSymbol in: aNameSpace 	| binding parcels |	binding := aNameSpace asNameSpace bindingFor: aSymbol.	binding isNil ifTrue: [^false].	parcels := Parcel parcelsForBinding: binding.	^parcels isNil or: [parcels isEmpty]</body><body package="Browser-Environments" selector="definesObject:">definesObject: aNameSpace 	| parcels |	parcels := Parcel parcelsForClassOrNameSpace: aNameSpace.	^parcels isNil or: [parcels isEmpty]</body><body package="Browser-Environments" selector="definesOrExtendsClass:">definesOrExtendsClass: aClass 	^self class isUnparceled: aClass</body><body package="Browser-Environments" selector="definesSelector:forClass:">definesSelector: aSelector forClass: aClass 	^(Parcel parcelsDefiningSelector: aSelector inClass: aClass) isEmpty</body><body package="Browser-Environments" selector="extendedClasses">extendedClasses	| unparceled |	unparceled := Set new.	BrowserEnvironment new classesAndSelectorsDo: 			[:class :sel | 			(Parcel isSelector: sel parceledInClass: class) 				ifFalse: [unparceled add: class instanceBehavior]].	^unparceled</body><body package="Browser-Environments" selector="isPackage">isPackage	^false</body><body package="Browser-Environments" selector="isParcel">isParcel	^true</body></methods><methods><class-id>Refactory.Browser.UnparceledParcel</class-id> <category>printing</category><body package="Browser-Environments" selector="displayString">displayString	^self name</body><body package="Browser-Environments" selector="printOn:">printOn: aStream 	aStream nextPutAll: self name</body></methods><methods><class-id>Refactory.Browser.UnparceledParcel</class-id> <category>accessing</category><body package="Browser-Environments" selector="comment">comment	^(#UnparceledParcelComment &lt;&lt; #browser &gt;&gt; 'This "parcel" holds all classes/methods/name spaces/shared variables that are not in a parcel. It is not a normal parcel, but is dynamically calculated.') asString</body><body package="Browser-Environments" selector="name">name	^self class unparceledParcelName</body><body package="Browser-Environments" selector="versionString">versionString	^''</body></methods><methods><class-id>Refactory.Browser.UnparceledParcel</class-id> <category>testing</category><body package="Browser-Environments" selector="isUnparceledParcel">isUnparceledParcel	^true</body></methods><methods><class-id>Refactory.Browser.UnparceledParcel class</class-id> <category>testing</category><body package="Browser-Environments" selector="isBindingUnparceled:">isBindingUnparceled: aBinding 	^(Parcel isBindingDefinedInParcel: aBinding) not</body><body package="Browser-Environments" selector="isNameSpaceUnparceled:">isNameSpaceUnparceled: aNameSpace 	| parcels |	parcels := Parcel parcelsForClassOrNameSpace: aNameSpace.	(parcels isNil or: [parcels isEmpty]) ifTrue: [^true].	aNameSpace bindingsDo: 			[:each | 			(each isForGeneral 				and: [(parcels := Parcel parcelsForBinding: each) isNil or: [parcels isEmpty]]) 					ifTrue: [^true]].	^false</body><body package="Browser-Environments" selector="isUnparceled:">isUnparceled: aClass 	^(Parcel isClassDefinedInParcel: aClass) not or: 			[(aClass selectors 				anySatisfy: [:each | (Parcel isSelector: each parceledInClass: aClass) not]) 					or: 						[aClass asNameSpace localBindings 							anySatisfy: [:each | (Parcel isBindingDefinedInParcel: each) not]]]</body></methods><methods><class-id>Refactory.Browser.UnparceledParcel class</class-id> <category>accessing</category><body package="Browser-Environments" selector="unparceledParcelName">unparceledParcelName	^'***Unparceled***'</body></methods><methods><class-id>Refactory.Browser.BrowserEnvironment</class-id> <category>environments</category><body package="Browser-Environments" selector="&amp;">&amp; anEnvironment 	"If we or anEnvironment includes everything, then just include the other environment (optimization)"	self isSystem ifTrue: [^anEnvironment].	anEnvironment isSystem ifTrue: [^self].	^AndEnvironment onEnvironment: self and: anEnvironment</body><body package="Browser-Environments" selector="forCategories:">forCategories: categoryList 	^CategoryEnvironment onEnvironment: self categories: categoryList</body><body package="Browser-Environments" selector="forClass:protocols:">forClass: aClass protocols: protocolCollection 	^ProtocolEnvironment 		onEnvironment: self		class: aClass		protocols: protocolCollection</body><body package="Browser-Environments" selector="forClass:selectors:">forClass: aClass selectors: selectorCollection 	^(SelectorEnvironment 		onMethods: selectorCollection		forClass: aClass		in: self)		label: aClass fullName , '&gt;&gt;' 					, (selectorCollection detect: [:each | true] ifNone: ['']);		yourself</body><body package="Browser-Environments" selector="forClasses:">forClasses: classCollection 	^ClassEnvironment onEnvironment: self classes: classCollection</body><body package="Browser-Environments" selector="forParcels:">forParcels: parcelList 	^ParcelEnvironment onEnvironment: self parcels: parcelList</body><body package="Browser-Environments" selector="forPundles:">forPundles: pundleList 	^PundleEnvironment onEnvironment: self pundles: pundleList</body><body package="Browser-Environments" selector="implementorsMatching:">implementorsMatching: aString 	^SelectorEnvironment implementorsMatching: aString in: self</body><body package="Browser-Environments" selector="implementorsOf:">implementorsOf: aSelector 	^SelectorEnvironment implementorsOf: aSelector in: self</body><body package="Browser-Environments" selector="instVarReadersTo:in:">instVarReadersTo: instVarName in: aClass 	^VariableEnvironment 		on: self		readersOfInstanceVariable: instVarName		in: aClass</body><body package="Browser-Environments" selector="instVarRefsTo:in:">instVarRefsTo: instVarName in: aClass 	^VariableEnvironment 		on: self		referencesToInstanceVariable: instVarName		in: aClass</body><body package="Browser-Environments" selector="instVarWritersTo:in:">instVarWritersTo: instVarName in: aClass 	^VariableEnvironment 		on: self		writersOfInstanceVariable: instVarName		in: aClass</body><body package="Browser-Environments" selector="matches:">matches: aString 	^SelectorEnvironment matches: aString in: self</body><body package="Browser-Environments" selector="not">not	self isSystem ifTrue: [^SelectorEnvironment new].	^NotEnvironment onEnvironment: self</body><body package="Browser-Environments" selector="referencesTo:">referencesTo: aLiteral 	^SelectorEnvironment referencesTo: aLiteral in: self</body><body package="Browser-Environments" selector="referencesTo:in:">referencesTo: aLiteral in: aClass 	| classes |	classes := aClass withAllSuperclasses asSet.	classes		addAll: aClass allSubclasses;		addAll: aClass class withAllSuperclasses;		addAll: aClass class allSubclasses.	^(self forClasses: classes) referencesTo: aLiteral</body><body package="Browser-Environments" selector="selectMethods:">selectMethods: aBlock 	| env |	env := SelectorEnvironment onEnvironment: self.	self classesAndSelectorsDo: 			[:each :sel | 			(aBlock value: (each compiledMethodAt: sel)) 				ifTrue: [env addClass: each selector: sel]].	^env</body><body package="Browser-Environments" selector="sourceCodeMatching:">sourceCodeMatching: aString 	^self selectMethods: 			[:each | 			| source |			source := each getSource.			source notNil and: [aString match: source]]</body><body package="Browser-Environments" selector="|">| anEnvironment 	"If we or anEnvironment includes everything, then return it instead of creating 	an or that will include everything."	self isSystem ifTrue: [^self].	anEnvironment isSystem ifTrue: [^anEnvironment].	^(self not &amp; anEnvironment not) not</body></methods><methods><class-id>Refactory.Browser.BrowserEnvironment</class-id> <category>accessing-classes</category><body package="Browser-Environments" selector="allClassesDo:">allClassesDo: aBlock 	Root allBehaviorsDo: aBlock</body><body package="Browser-Environments" selector="classes">classes	| classes |	classes := Set new.	self classesDo: [:each | classes add: each].	^classes</body><body package="Browser-Environments" selector="classesDo:">classesDo: aBlock 	self 		allClassesDo: [:each | (self includesClass: each) ifTrue: [aBlock value: each]]</body><body package="Browser-Environments" selector="classNames">classNames	| names |	names := Set new.	self classesDo: [:each | names add: each instanceBehavior fullRootName].	^names</body><body package="Browser-Environments" selector="nameSpaceObjectNames">nameSpaceObjectNames	| names |	names := Set new.	Root withAllNameSpacesDo: 			[:each | 			each bindingsDo: 					[:binding | 					(self includesBinding: binding in: each) 						ifTrue: 							[names add: (binding isForGeneral 										ifTrue: [each fullRootName]										ifFalse: [binding value fullRootName])]]].	^names</body><body package="Browser-Environments" selector="nameSpacesDo:">nameSpacesDo: aBlock 	Root withAllNameSpacesDo: 			[:each | 			(self includesNameSpace: each) ifTrue: [aBlock value: each]]</body></methods><methods><class-id>Refactory.Browser.BrowserEnvironment</class-id> <category>accessing</category><body package="Browser-Environments" selector="addSearchString:">addSearchString: aString 	searchStrings isNil 		ifTrue: 			[searchStrings := SortedCollection sortBlock: 							[:a :b | 							(a indexOf: $: ifAbsent: [a size]) &gt; (b indexOf: $: ifAbsent: [b size])]].	searchStrings add: aString</body><body package="Browser-Environments" selector="bindingReferencesDo:">bindingReferencesDo: aBlock 	Root withAllNameSpacesDo: 			[:ns | 			| ref |			ref := ns fullyQualifiedReference.			ns bindingsDo: 					[:each | 					(self includesBinding: each in: ns) 						ifTrue: [aBlock value: (ref append: each key)]]].	Root allBehaviorsDo: 			[:cls | 			cls isMeta 				ifFalse: 					[cls asNameSpace bindingsDo: 							[:each | 							(self includesBinding: each in: cls) 								ifTrue: 									[| ref |									ref := cls fullyQualifiedReference.									aBlock value: (ref append: each key)]]]]</body><body package="Browser-Environments" selector="bindingsFor:in:">bindingsFor: aCategoryName in: aNameSpace 	| bindings |	bindings := OrderedCollection new.	(aNameSpace organization listAtCategoryNamed: aCategoryName) do: 			[:each | 			| binding |			binding := aNameSpace bindingFor: each.			(binding notNil and: [self includesBinding: binding in: aNameSpace]) 				ifTrue: [bindings add: binding]].	^bindings</body><body package="Browser-Environments" selector="categories">categories	| categories |	categories := Set new.	Root 		withAllNameSpacesDo: [:each | categories addAll: each organization classCategories].	^categories select: [:each | self includesCategory: each]</body><body package="Browser-Environments" selector="classesAndSelectorsDo:">classesAndSelectorsDo: aBlock 	self classesDo: 			[:class | 			self selectorsForClass: class do: [:sel | aBlock value: class value: sel]]</body><body package="Browser-Environments" selector="instanceVariablesFor:">instanceVariablesFor: aClass 	^aClass instVarNames</body><body package="Browser-Environments" selector="methodDefinitions">methodDefinitions	| defs |	defs := OrderedCollection new.	self classesAndSelectorsDo: 			[:class :selector | 			defs add: (MethodDefinition class: class selector: selector)].	self sharedVariableReferencesDo: 			[:each | 			defs 				add: (InitializerDefinition nameSpace: each environment key: each name)].	^defs</body><body package="Browser-Environments" selector="methodsDo:">methodsDo: aBlock 	self 		classesAndSelectorsDo: [:class :selector | aBlock value: (class compiledMethodAt: selector)]</body><body package="Browser-Environments" selector="namesInCategories:">namesInCategories: aCategoryCollection 	| names |	names := Set new.	((aCategoryCollection includes: self rootCategory) 		and: [self includesNameSpace: Root]) 			ifTrue: [names add: Root fullRootName asString].	Root withAllNameSpacesDo: 			[:each | 			(each organization listAtCategoriesNamed: aCategoryCollection) do: 					[:name | 					| binding |					binding := each bindingFor: name.					binding isForClass 						ifTrue: 							[(self includesClass: binding value) 								ifTrue: [names add: binding value fullRootName asString]].					binding isForNameSpace 						ifTrue: 							[(self includesNameSpace: binding value) 								ifTrue: [names add: binding value fullRootName asString]]]].	^names</body><body package="Browser-Environments" selector="namesInCategory:">namesInCategory: aSymbol 	^self namesInCategories: (Array with: aSymbol)</body><body package="Browser-Environments" selector="numberClasses">numberClasses	^self classNames size</body><body package="Browser-Environments" selector="numberSelectors">numberSelectors	| total |	total := 0.	self 		allClassesDo: [:each | self selectorsForClass: each do: [:sel | total := total + 1]].	^total</body><body package="Browser-Environments" selector="protocolsFor:">protocolsFor: aClass 	^aClass organization categories 		select: [:each | self includesProtocol: each in: aClass]</body><body package="Browser-Environments" selector="rootCategory">rootCategory	^#'System-Name Spaces'</body><body package="Browser-Environments" selector="searchStrings">searchStrings	^searchStrings isNil ifTrue: [#()] ifFalse: [searchStrings]</body><body package="Browser-Environments" selector="searchStrings:">searchStrings: aCollection 	searchStrings := aCollection</body><body package="Browser-Environments" selector="selectorsFor:in:">selectorsFor: aProtocol in: aClass	^(aClass organization listAtCategoryNamed: aProtocol)		select: [:each | self includesSelector: each in: aClass]</body><body package="Browser-Environments" selector="selectorsForClass:">selectorsForClass: aClass 	| selectors |	selectors := Set new: 50.	self selectorsForClass: aClass do: [:each | selectors add: each].	^selectors</body><body package="Browser-Environments" selector="selectorsForClass:do:">selectorsForClass: aClass do: aBlock 	aClass selectorsAndMethodsDo: 			[:each :meth | 			(self includesSelector: each in: aClass) ifTrue: [aBlock value: each]]</body><body package="Browser-Environments" selector="sharedVariableProtocolsFor:">sharedVariableProtocolsFor: aClass 	^aClass asNameSpace organization sharedVariableCategories 		select: [:each | self includesDataProtocol: each in: aClass]</body><body package="Browser-Environments" selector="sharedVariableReferencesDo:">sharedVariableReferencesDo: aBlock 	self bindingReferencesDo: 			[:each | 			| binding |			binding := each bindingOrNil.			(binding notNil and: [binding isForGeneral]) ifTrue: [aBlock value: each]]</body><body package="Browser-Environments" selector="sharedVariablesFor:in:">sharedVariablesFor: aProtocol in: aClassOrNameSpace 	^(aClassOrNameSpace asNameSpace organization 		listAtCategoryNamed: aProtocol) select: 				[:each | 				| binding |				binding := aClassOrNameSpace bindingFor: each.				binding isForGeneral 					and: [self includesBinding: binding in: aClassOrNameSpace]]</body><body package="Browser-Environments" selector="sharedVariablesForClass:">sharedVariablesForClass: aClass 	| vars |	vars := Set new.	aClass asNameSpace bindingsDo: 			[:each | 			(each isForGeneral and: [self includesBinding: each in: aClass]) 				ifTrue: [vars add: each key]].	^vars</body><body package="Browser-Environments" selector="whichCategoryIncludes:">whichCategoryIncludes: aClassOrNameSpace 	| object |	aClassOrNameSpace isNil ifTrue: [^self rootCategory].	object := aClassOrNameSpace isBehavior 				ifTrue: [aClassOrNameSpace instanceBehavior]				ifFalse: [aClassOrNameSpace].	^self whichCategoryIncludes: object name in: object environment</body><body package="Browser-Environments" selector="whichCategoryIncludes:in:">whichCategoryIncludes: aClassName in: aNameSpace 	| name index |	aNameSpace isNil ifTrue: [^self rootCategory].	index := aClassName lastIndexOf: $. ifAbsent: [0].	name := index = 0 				ifTrue: [aClassName]				ifFalse: [aClassName copyFrom: index + 1 to: aClassName size].	^aNameSpace organization categoryOfElement: name asSymbol</body><body package="Browser-Environments" selector="whichProtocolIncludes:in:">whichProtocolIncludes: aSelector in: aClass	^aClass organization categoryOfElement: aSelector</body><body package="Browser-Environments" selector="whichProtocolIncludesVariable:in:">whichProtocolIncludesVariable: aSymbol in: aClass 	^aClass asNameSpace organization categoryOfElement: aSymbol</body></methods><methods><class-id>Refactory.Browser.BrowserEnvironment</class-id> <category>copying</category><body package="Browser-Environments" selector="copyEmpty">copyEmpty	^self class new</body></methods><methods><class-id>Refactory.Browser.BrowserEnvironment</class-id> <category>testing</category><body package="Browser-Environments" selector="definesClass:">definesClass: aClass	^true</body><body package="Browser-Environments" selector="includesBinding:in:">includesBinding: aBinding in: aNameSpace 	^true</body><body package="Browser-Environments" selector="includesCategory:">includesCategory: aCategory	^true</body><body package="Browser-Environments" selector="includesCategory:in:">includesCategory: aCategory in: aNameSpace	^true</body><body package="Browser-Environments" selector="includesClass:">includesClass: aClass	^true</body><body package="Browser-Environments" selector="includesDataProtocol:in:">includesDataProtocol: aProtocol in: aClass	^true</body><body package="Browser-Environments" selector="includesNameSpace:">includesNameSpace: aNameSpace 	^true</body><body package="Browser-Environments" selector="includesProtocol:in:">includesProtocol: aProtocol in: aClass	^true</body><body package="Browser-Environments" selector="includesSelector:in:">includesSelector: aSelector in: aClass	^true</body><body package="Browser-Environments" selector="isClassContainer">isClassContainer	^self isSystem</body><body package="Browser-Environments" selector="isClassEnvironment">isClassEnvironment	^false</body><body package="Browser-Environments" selector="isEmpty">isEmpty	^false</body><body package="Browser-Environments" selector="isSelector">isSelector	^false</body><body package="Browser-Environments" selector="isSystem">isSystem	^true</body><body package="Browser-Environments" selector="notEmpty">notEmpty	^self isEmpty not</body></methods><methods><class-id>Refactory.Browser.BrowserEnvironment</class-id> <category>initialize-release</category><body package="Browser-Environments" selector="initialize">initialize</body><body package="Browser-Environments" selector="label:">label: aString	label := aString</body></methods><methods><class-id>Refactory.Browser.BrowserEnvironment</class-id> <category>printing</category><body package="Browser-Environments" selector="printOn:">printOn: aStream	aStream nextPutAll: self label</body><body package="Browser-Environments" selector="storeOn:">storeOn: aStream 	aStream		nextPutAll: self class fullName;		nextPutAll: ' new'</body></methods><methods><class-id>Refactory.Browser.BrowserEnvironment</class-id> <category>private</category><body package="Browser-Environments" selector="defaultLabel">defaultLabel	^''</body><body package="Browser-Environments" selector="label">label	^label isNil ifTrue: [self defaultLabel] ifFalse: [label]</body></methods><methods><class-id>Refactory.Browser.BrowserEnvironment class</class-id> <category>instance creation</category><body package="Browser-Environments" selector="new">new	^(super new)		initialize;		yourself</body></methods><methods><class-id>Refactory.Browser.BrowserEnvironmentWrapper</class-id> <category>private</category><body package="Browser-Environments" selector="environment">environment	^environment</body></methods><methods><class-id>Refactory.Browser.BrowserEnvironmentWrapper</class-id> <category>testing</category><body package="Browser-Environments" selector="definesClass:">definesClass: aClass 	^environment definesClass: aClass</body><body package="Browser-Environments" selector="includesBinding:in:">includesBinding: aBinding in: aNameSpace 	^environment includesBinding: aBinding in: aNameSpace</body><body package="Browser-Environments" selector="includesCategory:">includesCategory: aCategory 	^(self namesInCategory: aCategory) notEmpty</body><body package="Browser-Environments" selector="includesCategory:in:">includesCategory: aCategory in: aNameSpace 	^(self bindingsFor: aCategory in: aNameSpace) notEmpty</body><body package="Browser-Environments" selector="includesClass:">includesClass: aClass	^environment includesClass: aClass</body><body package="Browser-Environments" selector="includesDataProtocol:in:">includesDataProtocol: aProtocol in: aClass 	^(aClass isBehavior not or: [self includesClass: aClass]) 		and: [environment includesDataProtocol: aProtocol in: aClass]</body><body package="Browser-Environments" selector="includesNameSpace:">includesNameSpace: aNameSpace 	^environment includesNameSpace: aNameSpace</body><body package="Browser-Environments" selector="includesProtocol:in:">includesProtocol: aProtocol in: aClass	^(self includesClass: aClass)		and: [environment includesProtocol: aProtocol in: aClass]</body><body package="Browser-Environments" selector="includesSelector:in:">includesSelector: aSelector in: aClass	^(self includesClass: aClass)		and: [environment includesSelector: aSelector in: aClass]</body><body package="Browser-Environments" selector="isEmpty">isEmpty	self classesDo: [:each | ^false].	^true</body><body package="Browser-Environments" selector="isSystem">isSystem	^false</body></methods><methods><class-id>Refactory.Browser.BrowserEnvironmentWrapper</class-id> <category>initialize-release</category><body package="Browser-Environments" selector="onEnvironment:">onEnvironment: anEnvironment	environment := anEnvironment</body></methods><methods><class-id>Refactory.Browser.BrowserEnvironmentWrapper</class-id> <category>printing</category><body package="Browser-Environments" selector="storeOn:">storeOn: aStream 	aStream		nextPutAll: '(';		nextPutAll: self class fullName;		nextPutAll: ' onEnvironment: '.	environment storeOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>Refactory.Browser.BrowserEnvironmentWrapper class</class-id> <category>instance creation</category><body package="Browser-Environments" selector="new">new	^self onEnvironment: BrowserEnvironment new</body><body package="Browser-Environments" selector="onEnvironment:">onEnvironment: anEnvironment 	^(self basicNew)		initialize;		onEnvironment: anEnvironment;		yourself</body></methods><methods><class-id>Refactory.Browser.VariableEnvironment</class-id> <category>private</category><body package="Browser-Environments" selector="accessorMethods">accessorMethods	^#(#instanceVariables #instanceVariableReaders #instanceVariableWriters)</body><body package="Browser-Environments" selector="allClassesDo:">allClassesDo: aBlock 	| classes instVarBlock |	classes := Set new.	instVarBlock := 			[:each | 			| class |			class := self classForName: each.			classes				addAll: class allSuperclasses;				addAll: class withAllSubclasses].	instanceVariables keysDo: instVarBlock.	instanceVariableReaders keysDo: instVarBlock.	instanceVariableWriters keysDo: instVarBlock.	classes do: aBlock</body><body package="Browser-Environments" selector="classForName:">classForName: aString 	| name isMeta class |	isMeta := aString includes: $ .	name := (isMeta 				ifTrue: [aString copyFrom: 1 to: (aString size - 6 max: 1)]				ifFalse: [aString]) asSymbol.	class := name asQualifiedReference valueOrDo: [nil].	^class notNil &amp; isMeta ifTrue: [class class] ifFalse: [class]</body><body package="Browser-Environments" selector="computeSelectorCacheFor:">computeSelectorCacheFor: aClass 	^self instanceVariableSelectorsFor: aClass</body><body package="Browser-Environments" selector="flushCachesFor:">flushCachesFor: aClass 	| nonMetaClass |	selectorCache isNil ifTrue: [^self].	nonMetaClass := aClass instanceBehavior.	nonMetaClass withAllSubclasses do: 			[:each | 			selectorCache				removeKey: each ifAbsent: [];				removeKey: each class ifAbsent: []]</body><body package="Browser-Environments" selector="instanceVariableReaders">instanceVariableReaders	^instanceVariableReaders</body><body package="Browser-Environments" selector="instanceVariableReaders:">instanceVariableReaders: anObject	instanceVariableReaders := anObject</body><body package="Browser-Environments" selector="instanceVariables">instanceVariables	^instanceVariables</body><body package="Browser-Environments" selector="instanceVariables:">instanceVariables: anObject	instanceVariables := anObject</body><body package="Browser-Environments" selector="instanceVariableSelectorsFor:">instanceVariableSelectorsFor: aClass 	| selectors |	selectors := Set new.	#(#instanceVariables #instanceVariableReaders #instanceVariableWriters) 		with: #(#whichSelectorsAccess: #whichSelectorsRead: #whichSelectorsAssign:)		do: 			[:var :sel | 			| instVars |			instVars := Set new.			(self perform: var) keysDo: 					[:each | 					| cls |					cls := self classForName: each.					(cls notNil 						and: [(aClass includesBehavior: cls) or: [cls includesBehavior: aClass]]) 							ifTrue: [instVars addAll: ((self perform: var) at: each)]].			instVars do: [:each | selectors addAll: (aClass perform: sel with: each)]].	^selectors</body><body package="Browser-Environments" selector="instanceVariableWriters">instanceVariableWriters	^instanceVariableWriters</body><body package="Browser-Environments" selector="instanceVariableWriters:">instanceVariableWriters: anObject	instanceVariableWriters := anObject</body><body package="Browser-Environments" selector="selectorCache">selectorCache	^selectorCache isNil 		ifTrue: [selectorCache := Dictionary new]		ifFalse: [selectorCache]</body><body package="Browser-Environments" selector="selectorCacheFor:">selectorCacheFor: aClass 	^self selectorCache at: aClass		ifAbsentPut: [self computeSelectorCacheFor: aClass]</body></methods><methods><class-id>Refactory.Browser.VariableEnvironment</class-id> <category>accessing</category><body package="Browser-Environments" selector="addClass:instanceVariable:">addClass: aClass instanceVariable: aString 	(instanceVariables at: aClass fullRootName ifAbsentPut: [Set new]) 		add: aString.	self flushCachesFor: aClass.	self addSearchString: aString</body><body package="Browser-Environments" selector="addClass:instanceVariableReader:">addClass: aClass instanceVariableReader: aString 	(instanceVariableReaders at: aClass fullRootName ifAbsentPut: [Set new]) 		add: aString.	self flushCachesFor: aClass.	self addSearchString: aString</body><body package="Browser-Environments" selector="addClass:instanceVariableWriter:">addClass: aClass instanceVariableWriter: aString 	(instanceVariableWriters at: aClass fullRootName ifAbsentPut: [Set new]) 		add: aString.	self flushCachesFor: aClass.	self addSearchString: aString</body><body package="Browser-Environments" selector="classNamesWithVariables">classNamesWithVariables	| classNames |	classNames := Set new.	classNames		addAll: instanceVariables keys;		addAll: instanceVariableReaders keys;		addAll: instanceVariableWriters keys.	^classNames</body><body package="Browser-Environments" selector="environmentForInstanceVariable:in:">environmentForInstanceVariable: aString in: aClass 	| selectorEnvironment isReader isWriter |	selectorEnvironment := SelectorEnvironment onEnvironment: self.	selectorEnvironment addSearchString: aString.	isReader := isWriter := false.	((instanceVariables at: aClass fullRootName ifAbsent: [#()]) includes: aString) 		ifTrue: 			[isReader := true.			isWriter := true].	((instanceVariableWriters at: aClass fullRootName ifAbsent: [#()]) 		includes: aString) ifTrue: [isWriter := true].	((instanceVariableReaders at: aClass fullRootName ifAbsent: [#()]) 		includes: aString) ifTrue: [isReader := true].	aClass allSuperclasses , aClass withAllSubclasses do: 			[:each | 			isWriter 				ifTrue: 					[(each whichSelectorsAssign: aString) 						do: [:sel | selectorEnvironment addClass: each selector: sel]].			isReader 				ifTrue: 					[(each whichSelectorsRead: aString) 						do: [:sel | selectorEnvironment addClass: each selector: sel]]].	^selectorEnvironment</body><body package="Browser-Environments" selector="instanceVariablesFor:">instanceVariablesFor: aClass 	| vars name |	vars := Set new.	name := aClass fullRootName.	vars		addAll: (instanceVariables at: name ifAbsent: [#()]);		addAll: (instanceVariableReaders at: name ifAbsent: [#()]);		addAll: (instanceVariableWriters at: name ifAbsent: [#()]).	^vars</body><body package="Browser-Environments" selector="numberVariables">numberVariables	^self accessorMethods inject: 0		into: [:sum :each | sum + ((self perform: each) inject: 0 into: [:s :e | s + e size])]</body><body package="Browser-Environments" selector="removeClass:instanceVariable:">removeClass: aClass instanceVariable: aString 	| vars |	vars := instanceVariables at: aClass fullRootName ifAbsent: [Set new].	vars remove: aString ifAbsent: [].	vars isEmpty 		ifTrue: [instanceVariables removeKey: aClass fullRootName ifAbsent: []].	self flushCachesFor: aClass</body><body package="Browser-Environments" selector="removeClass:instanceVariableReader:">removeClass: aClass instanceVariableReader: aString 	| vars |	vars := instanceVariableReaders at: aClass fullRootName ifAbsent: [Set new].	vars remove: aString ifAbsent: [].	vars isEmpty 		ifTrue: [instanceVariableReaders removeKey: aClass fullRootName ifAbsent: []].	self flushCachesFor: aClass</body><body package="Browser-Environments" selector="removeClass:instanceVariableWriter:">removeClass: aClass instanceVariableWriter: aString 	| vars |	vars := instanceVariableWriters at: aClass fullRootName ifAbsent: [Set new].	vars remove: aString ifAbsent: [].	vars isEmpty 		ifTrue: [instanceVariableWriters removeKey: aClass fullRootName ifAbsent: []].	self flushCachesFor: aClass</body></methods><methods><class-id>Refactory.Browser.VariableEnvironment</class-id> <category>copying</category><body package="Browser-Environments" selector="copyDictionary:">copyDictionary: aDictionary 	| copy |	copy := Dictionary new: aDictionary size.	aDictionary keysAndValuesDo: [:key :value | copy at: key put: value].	^copy</body><body package="Browser-Environments" selector="postCopy">postCopy	super postCopy.	instanceVariables := self copyDictionary: instanceVariables.	instanceVariableReaders := self copyDictionary: instanceVariableReaders.	instanceVariableWriters := self copyDictionary: instanceVariableWriters.	selectorCache := nil</body></methods><methods><class-id>Refactory.Browser.VariableEnvironment</class-id> <category>testing</category><body package="Browser-Environments" selector="includesBinding:in:">includesBinding: aBinding in: aNameSpace 	^(super includesBinding: aBinding in: aNameSpace) and: 			[aBinding isForClass and: 					[(self includesClass: aBinding value) 						or: [self includesClass: aBinding value class]]]</body><body package="Browser-Environments" selector="includesClass:">includesClass: aClass 	(super includesClass: aClass) ifFalse: [^false].	(instanceVariables includesKey: aClass name) ifTrue: [^true].	^(self selectorCacheFor: aClass) 		anySatisfy: [:each | self includesSelector: each in: aClass]</body><body package="Browser-Environments" selector="includesProtocol:in:">includesProtocol: aProtocol in: aClass 	^(self selectorsFor: aProtocol in: aClass) notEmpty</body><body package="Browser-Environments" selector="includesSelector:in:">includesSelector: aSymbol in: aClass 	^(environment includesSelector: aSymbol in: aClass) 		and: [(self selectorCacheFor: aClass) includes: aSymbol]</body><body package="Browser-Environments" selector="isEmpty">isEmpty	^self accessorMethods allSatisfy: [:each | (self perform: each) isEmpty]</body></methods><methods><class-id>Refactory.Browser.VariableEnvironment</class-id> <category>initialize-release</category><body package="Browser-Environments" selector="initialize">initialize	super initialize.	instanceVariables := Dictionary new.	instanceVariableReaders := Dictionary new.	instanceVariableWriters := Dictionary new</body></methods><methods><class-id>Refactory.Browser.VariableEnvironment</class-id> <category>printing</category><body package="Browser-Environments" selector="storeOn:">storeOn: aStream 	aStream		nextPut: $(;		nextPutAll: self class fullRootName;		nextPutAll: ' new '.	self accessorMethods do: 			[:each | 			aStream				nextPutAll: each;				nextPutAll: ': '.			(self perform: each) storeOn: aStream.			aStream nextPutAll: '; '].	aStream nextPutAll: ' yourself)'</body></methods><methods><class-id>Refactory.Browser.VariableEnvironment class</class-id> <category>instance creation</category><body package="Browser-Environments" selector="on:readersOfInstanceVariable:in:">on: anEnvironment readersOfInstanceVariable: aString in: aClass 	^(self onEnvironment: anEnvironment)		label: ((#ReadersOf1sIn2s &lt;&lt; #browser &gt;&gt; 'Readers of ''&lt;1s&gt;'' in &lt;2s&gt;')			expandMacrosWith: aString			with: aClass fullName);		addClass: aClass instanceVariableReader: aString;		yourself</body><body package="Browser-Environments" selector="on:referencesToInstanceVariable:in:">on: anEnvironment referencesToInstanceVariable: aString in: aClass 	^(self onEnvironment: anEnvironment)		label: ((#ReferencesTo1sIn2s &lt;&lt; #browser &gt;&gt; 'References to ''&lt;1s&gt;'' in &lt;2s&gt;')			expandMacrosWith: aString			with: aClass fullName);		addClass: aClass instanceVariable: aString;		yourself</body><body package="Browser-Environments" selector="on:writersOfInstanceVariable:in:">on: anEnvironment writersOfInstanceVariable: aString in: aClass 	^(self onEnvironment: anEnvironment)		label: ((#WritersOf1sIn2s &lt;&lt; #browser &gt;&gt; 'Writers of ''&lt;1s&gt;'' in &lt;2s&gt;')			expandMacrosWith: aString			with: aClass fullName);		addClass: aClass instanceVariableWriter: aString;		yourself</body><body package="Browser-Environments" selector="readersOfInstanceVariable:in:">readersOfInstanceVariable: aString in: aClass 	^self 		on: BrowserEnvironment new		readersOfInstanceVariable: aString		in: aClass</body><body package="Browser-Environments" selector="referencesToInstanceVariable:in:">referencesToInstanceVariable: aString in: aClass 	^self 		on: BrowserEnvironment new		referencesToInstanceVariable: aString		in: aClass</body><body package="Browser-Environments" selector="writersOfInstanceVariable:in:">writersOfInstanceVariable: aString in: aClass 	^self 		on: BrowserEnvironment new		writersOfInstanceVariable: aString		in: aClass</body></methods><methods><class-id>Refactory.Browser.ProtocolEnvironment</class-id> <category>initialize-release</category><body package="Browser-Environments" selector="class:protocols:">class: aClass protocols: aCollection	class := aClass.	protocols := aCollection</body></methods><methods><class-id>Refactory.Browser.ProtocolEnvironment</class-id> <category>private</category><body package="Browser-Environments" selector="defaultLabel">defaultLabel	| stream |	stream := String new writeStream.	stream		nextPutAll: class fullName;		nextPut: $&gt;.	protocols do: 			[:each | 			stream				nextPutAll: each;				nextPut: $ ].	^stream contents</body></methods><methods><class-id>Refactory.Browser.ProtocolEnvironment</class-id> <category>testing</category><body package="Browser-Environments" selector="includesBinding:in:">includesBinding: aBinding in: aNameSpace 	^(super includesBinding: aBinding in: aNameSpace) and: 			[(aBinding isForClass and: 					[(self includesClass: aBinding value) 						or: [self includesClass: aBinding value class]]) 				or: 					[aNameSpace = class 						and: [aBinding isForGeneral and: [protocols includes: aBinding category]]]]</body><body package="Browser-Environments" selector="includesClass:">includesClass: aClass	^aClass == class and: [super includesClass: aClass]</body><body package="Browser-Environments" selector="includesNameSpace:">includesNameSpace: aNameSpace 	^false</body><body package="Browser-Environments" selector="includesProtocol:in:">includesProtocol: aProtocol in: aClass 	^aClass == class and: 			[(super includesProtocol: aProtocol in: aClass) 				and: [protocols includes: aProtocol]]</body><body package="Browser-Environments" selector="includesSelector:in:">includesSelector: aSelector in: aClass 	^(super includesSelector: aSelector in: aClass) and: 			[protocols 				includes: (environment whichProtocolIncludes: aSelector in: aClass)]</body><body package="Browser-Environments" selector="isEmpty">isEmpty	^protocols isEmpty</body></methods><methods><class-id>Refactory.Browser.ProtocolEnvironment</class-id> <category>copying</category><body package="Browser-Environments" selector="postCopy">postCopy	protocols := protocols copy.	^super postCopy</body></methods><methods><class-id>Refactory.Browser.ProtocolEnvironment</class-id> <category>printing</category><body package="Browser-Environments" selector="storeOn:">storeOn: aStream 	aStream nextPut: $(.	super storeOn: aStream.	aStream		nextPutAll: ' class: ';		nextPutAll: class fullRootName;		nextPutAll: ' protocols: '.	protocols asArray storeOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>Refactory.Browser.ProtocolEnvironment class</class-id> <category>instance creation</category><body package="Browser-Environments" selector="onEnvironment:class:protocols:">onEnvironment: anEnvironment class: aClass protocols: aCollection 	^(self onEnvironment: anEnvironment)		class: aClass protocols: aCollection;		yourself</body></methods><methods><class-id>Refactory.Browser.PundleEnvironment</class-id> <category>accessing-classes</category><body package="Browser-Environments" selector="classesDo:">classesDo: aBlock 	| classes block |	classes := Set new: 100.	block := 			[:each | 			| class |			class := each actual.			class notNil 				ifTrue: 					[(classes includes: class) 						ifFalse: 							[classes add: class.							aBlock value: class]]].	self packages do: 			[:each | 			each classesDefinedInPackage do: block.			each classesExtendedInPackage do: block.			each metaclassesDefinedInPackage do: block.			each metaclassesExtendedInPackage do: block]</body></methods><methods><class-id>Refactory.Browser.PundleEnvironment</class-id> <category>copying</category><body package="Browser-Environments" selector="postCopy">postCopy	super postCopy.	bundleNames := bundleNames copy.	packageNames := packageNames copy</body></methods><methods><class-id>Refactory.Browser.PundleEnvironment</class-id> <category>initialize-release</category><body package="Browser-Environments" selector="bundleNames:packageNames:">bundleNames: bundleCollection packageNames: packageCollection 	bundleNames := bundleCollection.	packageNames := packageCollection</body><body package="Browser-Environments" selector="pundles:">pundles: aCollection 	bundleNames := OrderedCollection new.	packageNames := OrderedCollection new.	aCollection do: 			[:each | 			(each isPackage ifTrue: [packageNames] ifFalse: [bundleNames]) 				add: each name]</body></methods><methods><class-id>Refactory.Browser.PundleEnvironment</class-id> <category>printing</category><body package="Browser-Environments" selector="storeOn:">storeOn: aStream 	aStream nextPut: $(.	super storeOn: aStream.	aStream nextPutAll: ' bundleNames: '.	bundleNames asArray storeOn: aStream.	aStream nextPutAll: ' packageNames: '.	packageNames asArray storeOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>Refactory.Browser.PundleEnvironment</class-id> <category>testing</category><body package="Browser-Environments" selector="definesClass:">definesClass: aBehavior 	^self packages anySatisfy: [:each | each definesClass: aBehavior]</body><body package="Browser-Environments" selector="includesBinding:in:">includesBinding: aBinding in: aNameSpace 	(super includesBinding: aBinding in: aNameSpace) ifFalse: [^false].	aBinding isForClass 		ifTrue: 			[^(self includesClass: aBinding value) 				or: [self includesClass: aBinding value class]].	aBinding isForNameSpace ifTrue: [^self includesNameSpace: aBinding value].	^self packages anySatisfy: 			[:each | 			each definesName: aBinding key in: aNameSpace]</body><body package="Browser-Environments" selector="includesClass:">includesClass: aClass 	(super includesClass: aClass) ifFalse: [^false].	^self packages 		anySatisfy: [:each | (each definesClass: aClass) or: [each extendsClass: aClass]]</body><body package="Browser-Environments" selector="includesNameSpace:">includesNameSpace: aNameSpace 	^self packages 		anySatisfy: [:each | each definesClassOrNameSpace: aNameSpace]</body><body package="Browser-Environments" selector="includesProtocol:in:">includesProtocol: aProtocol in: aClass 	^(super includesProtocol: aProtocol in: aClass) and: 			[(environment selectorsFor: aProtocol in: aClass) 				anySatisfy: [:aSelector | self includesSelector: aSelector in: aClass]]</body><body package="Browser-Environments" selector="includesSelector:in:">includesSelector: aSelector in: aClass 	^(environment includesSelector: aSelector in: aClass) and: 			[self packages 				anySatisfy: [:each | each definesSelector: aSelector forClass: aClass]]</body><body package="Browser-Environments" selector="isClassContainer">isClassContainer	^true</body></methods><methods><class-id>Refactory.Browser.PundleEnvironment</class-id> <category>accessing</category><body package="Browser-Environments" selector="numberSelectors">numberSelectors	^self packages inject: 0 into: [:sum :each | sum + each methods size]</body><body package="Browser-Environments" selector="packages">packages	| packages todo each |	packages := OrderedCollection new.	todo := self pundles.	[todo isEmpty] whileFalse: 			[each := todo removeFirst.			each isBundle 				ifTrue: [todo addAll: each containedItems]				ifFalse: [packages add: each]].	^packages</body><body package="Browser-Environments" selector="pundles">pundles	| pundles |	pundles := OrderedCollection new: packageNames size + bundleNames size.	bundleNames do: 			[:each | 			| bundle |			bundle := Store.Registry bundleNamed: each.			bundle notNil ifTrue: [pundles add: bundle]].	packageNames do: 			[:each | 			| package |			package := Store.Registry packageNamed: each.			package notNil ifTrue: [pundles add: package]].	^pundles</body><body package="Browser-Environments" selector="selectorsForClass:do:">selectorsForClass: aClass do: aBlock 	self packages do: 			[:each | 			(each definedSelectorsFor: aClass) do: 					[:sel | 					((aClass includesSelector: sel) 						and: [environment includesSelector: sel in: aClass]) 							ifTrue: [aBlock value: sel]]]</body><body package="Browser-Environments" selector="sharedVariableReferencesDo:">sharedVariableReferencesDo: aBlock 	| refs |	refs := Set new.	self packages 		do: [:package | package data do: [:each | refs add: each fullName asQualifiedReference]].	refs do: [:each | each isDefined ifTrue: [aBlock value: each]]</body></methods><methods><class-id>Refactory.Browser.PundleEnvironment</class-id> <category>private</category><body package="Browser-Environments" selector="defaultLabel">defaultLabel	| stream |	stream := String new writeStream.	bundleNames , packageNames do: [:each | stream nextPutAll: each]		separatedBy: [stream nextPut: $ ].	^stream contents</body></methods><methods><class-id>Refactory.Browser.PundleEnvironment class</class-id> <category>instance creation</category><body package="Browser-Environments" selector="onEnvironment:bundleNames:packageNames:">onEnvironment: aBrowserEnvironment bundleNames: bundleCollection packageNames: packageCollection 	^(self onEnvironment: aBrowserEnvironment)		bundleNames: bundleCollection packageNames: packageCollection;		yourself</body><body package="Browser-Environments" selector="onEnvironment:pundles:">onEnvironment: aBrowserEnvironment pundles: aCollection 	^(self onEnvironment: aBrowserEnvironment)		pundles: aCollection;		yourself</body></methods><methods><class-id>Refactory.Browser.CategoryEnvironment</class-id> <category>accessing</category><body package="Browser-Environments" selector="categories">categories	^categories</body><body package="Browser-Environments" selector="numberSelectors">numberSelectors	| total |	total := 0.	self 		classesDo: [:each | self selectorsForClass: each do: [:sel | total := total + 1]].	^total</body></methods><methods><class-id>Refactory.Browser.CategoryEnvironment</class-id> <category>initialize-release</category><body package="Browser-Environments" selector="categories:">categories: aCollection	categories := aCollection</body><body package="Browser-Environments" selector="initialize">initialize	super initialize.	categories := Set new</body></methods><methods><class-id>Refactory.Browser.CategoryEnvironment</class-id> <category>testing</category><body package="Browser-Environments" selector="includesCategory:">includesCategory: aCategory 	^(categories includes: aCategory) and: [super includesCategory: aCategory]</body><body package="Browser-Environments" selector="includesCategory:in:">includesCategory: aCategory in: aNameSpace 	^(categories includes: aCategory)		and: [super includesCategory: aCategory in: aNameSpace]</body><body package="Browser-Environments" selector="includesClass:">includesClass: aClass 	^(super includesClass: aClass) and: 			[| nonMetaClass |			nonMetaClass := aClass instanceBehavior.			categories 				includes: (environment whichCategoryIncludes: nonMetaClass)]</body><body package="Browser-Environments" selector="isClassContainer">isClassContainer	^true</body><body package="Browser-Environments" selector="isEmpty">isEmpty	^categories isEmpty</body></methods><methods><class-id>Refactory.Browser.CategoryEnvironment</class-id> <category>copying</category><body package="Browser-Environments" selector="postCopy">postCopy	categories := categories copy.	^super postCopy</body></methods><methods><class-id>Refactory.Browser.CategoryEnvironment</class-id> <category>printing</category><body package="Browser-Environments" selector="storeOn:">storeOn: aStream 	aStream nextPut: $(.	super storeOn: aStream.	aStream nextPutAll: ' categories: '.	categories asArray storeOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>Refactory.Browser.CategoryEnvironment</class-id> <category>private</category><body package="Browser-Environments" selector="defaultLabel">defaultLabel	| stream |	stream := String new writeStream.	categories do: 			[:each | 			stream				nextPutAll: each;				nextPut: $ ].	^stream contents</body></methods><methods><class-id>Refactory.Browser.CategoryEnvironment class</class-id> <category>instance creation</category><body package="Browser-Environments" selector="onEnvironment:categories:">onEnvironment: anEnvironment categories: aCollection 	^(self onEnvironment: anEnvironment)		categories: aCollection;		yourself</body></methods><methods><class-id>Refactory.Browser.NotEnvironment</class-id> <category>testing</category><body package="Browser-Environments" selector="includesBinding:in:">includesBinding: aBinding in: aNameSpace 	^aBinding isForClass 		ifTrue: 			[(self includesClass: aBinding value) 				or: [self includesClass: aBinding value class]]		ifFalse: [(super includesBinding: aBinding in: aNameSpace) not]</body><body package="Browser-Environments" selector="includesClass:">includesClass: aClass 	(environment includesClass: aClass) ifFalse: [^true].	aClass selectorsAndMethodsDo: 			[:each :meth | 			(environment includesSelector: each in: aClass) ifFalse: [^true]].	^false</body><body package="Browser-Environments" selector="includesNameSpace:">includesNameSpace: aNameSpace 	^(environment includesNameSpace: aNameSpace) not</body><body package="Browser-Environments" selector="includesProtocol:in:">includesProtocol: aProtocol in: aClass 	^(self selectorsFor: aProtocol in: aClass) notEmpty</body><body package="Browser-Environments" selector="includesSelector:in:">includesSelector: aSelector in: aClass	^(environment includesSelector: aSelector in: aClass) not</body></methods><methods><class-id>Refactory.Browser.NotEnvironment</class-id> <category>environments</category><body package="Browser-Environments" selector="not">not	^environment</body></methods><methods><class-id>Refactory.Browser.NotEnvironment</class-id> <category>printing</category><body package="Browser-Environments" selector="storeOn:">storeOn: aStream	environment storeOn: aStream.	aStream nextPutAll: ' not'</body></methods><methods><class-id>Refactory.Browser.SelectorEnvironment</class-id> <category>initialize-release</category><body package="Browser-Environments" selector="classes:metaClasses:">classes: classArray metaClasses: metaArray 	"Used to recreate an environment from its storeString"	classSelectors := Dictionary new.	metaClassSelectors := Dictionary new.	classArray 		do: [:each | classSelectors at: each first put: each last asSet].	metaArray 		do: [:each | metaClassSelectors at: each first put: each last asSet]</body><body package="Browser-Environments" selector="classSelectors:metaClassSelectors:">classSelectors: classSelectorDictionary metaClassSelectors: metaClassSelectorDictionary 	classSelectors := classSelectorDictionary.	metaClassSelectors := metaClassSelectorDictionary</body><body package="Browser-Environments" selector="initialize">initialize	super initialize.	classSelectors := Dictionary new.	metaClassSelectors := Dictionary new.	initializers := Set new.</body><body package="Browser-Environments" selector="initializers:">initializers: initializerCollection 	initializers := initializerCollection</body><body package="Browser-Environments" selector="on:">on: aDict 	aDict keysAndValuesDo: 			[:class :selectors | 			class isMeta 				ifTrue: [metaClassSelectors at: class soleInstance fullRootName put: selectors]				ifFalse: 					[classSelectors at: class fullRootName						put: (selectors select: [:each | each isSymbol])]]</body></methods><methods><class-id>Refactory.Browser.SelectorEnvironment</class-id> <category>accessing-classes</category><body package="Browser-Environments" selector="classesDo:">classesDo: aBlock 	classSelectors keysDo: 			[:each | 			| class |			class := each asQualifiedReference valueOrDo: [nil].			class notNil 				ifTrue: [(self includesClass: class) ifTrue: [aBlock value: class]]].	metaClassSelectors keysDo: 			[:each | 			| class |			class := each asQualifiedReference valueOrDo: [nil].			class notNil 				ifTrue: 					[(self includesClass: class class) ifTrue: [aBlock value: class class]]]</body><body package="Browser-Environments" selector="classNames">classNames	| names |	names := Set new: classSelectors size + metaClassSelectors size.	names		addAll: classSelectors keys;		addAll: metaClassSelectors keys.	initializers do: 			[:each | 			| env |			env := each environment.			env isBehavior ifTrue: [names add: each environment fullRootName]].	^names asOrderedCollection</body><body package="Browser-Environments" selector="nameSpaceObjectNames">nameSpaceObjectNames	| names |	names := Set new.	self classesDo: [:each | names add: each instanceBehavior fullRootName].	initializers do: [:each | names add: each environment fullRootName].	^names</body></methods><methods><class-id>Refactory.Browser.SelectorEnvironment</class-id> <category>private</category><body package="Browser-Environments" selector="defaultLabel">defaultLabel	^''</body><body package="Browser-Environments" selector="privateIncludesSelector:inClass:">privateIncludesSelector: aSelector inClass: aClass 	^(self privateSelectorsForClass: aClass) includes: aSelector</body><body package="Browser-Environments" selector="privateSelectorsForClass:">privateSelectorsForClass: aClass 	^aClass isMeta 		ifTrue: [metaClassSelectors at: aClass soleInstance fullRootName ifAbsent: [#()]]		ifFalse: [classSelectors at: aClass fullRootName ifAbsent: [#()]]</body></methods><methods><class-id>Refactory.Browser.SelectorEnvironment</class-id> <category>testing</category><body package="Browser-Environments" selector="hasInitializerForClass:">hasInitializerForClass: aClass 	^initializers anySatisfy: [:each | each environment = aClass]</body><body package="Browser-Environments" selector="includesBinding:in:">includesBinding: aBinding in: aNameSpace 	(super includesBinding: aBinding in: aNameSpace) ifFalse: [^false].	aBinding isForClass 		ifTrue: 			[^(self includesClass: aBinding value) 				or: [self includesClass: aBinding value class]].	^initializers anySatisfy: [:ref | ref binding = aBinding]</body><body package="Browser-Environments" selector="includesClass:">includesClass: aClass 	^((self privateSelectorsForClass: aClass) notEmpty 		or: [self hasInitializerForClass: aClass]) 			and: [super includesClass: aClass]</body><body package="Browser-Environments" selector="includesNameSpace:">includesNameSpace: aNameSpace 	^initializers anySatisfy: [:each | each environment = aNameSpace]</body><body package="Browser-Environments" selector="includesProtocol:in:">includesProtocol: aProtocol in: aClass 	^(super includesProtocol: aProtocol in: aClass) and: 			[(environment selectorsFor: aProtocol in: aClass) 				anySatisfy: [:aSelector | self privateIncludesSelector: aSelector inClass: aClass]]</body><body package="Browser-Environments" selector="includesSelector:in:">includesSelector: aSelector in: aClass 	^(environment includesSelector: aSelector in: aClass)		and: [self privateIncludesSelector: aSelector inClass: aClass]</body><body package="Browser-Environments" selector="isEmpty">isEmpty	^classSelectors isEmpty 		and: [metaClassSelectors isEmpty and: [initializers isEmpty]]</body><body package="Browser-Environments" selector="isSelector">isSelector	^true</body></methods><methods><class-id>Refactory.Browser.SelectorEnvironment</class-id> <category>accessing</category><body package="Browser-Environments" selector="numberSelectors">numberSelectors	"This doesn't compute the correct result when a method that is included in our method list is not in the	environment we are wrapping. It is implemented this way for efficiency."	^(classSelectors inject: 0 into: [:sum :each | sum + each size]) 		+ (metaClassSelectors inject: 0 into: [:sum :each | sum + each size]) 			"+ initializers size"</body><body package="Browser-Environments" selector="selectorsForClass:do:">selectorsForClass: aClass do: aBlock 	^(self privateSelectorsForClass: aClass) 		do: [:each | (aClass includesSelector: each) ifTrue: [aBlock value: each]]</body><body package="Browser-Environments" selector="sharedVariableReferencesDo:">sharedVariableReferencesDo: aBlock 	initializers do: aBlock</body></methods><methods><class-id>Refactory.Browser.SelectorEnvironment</class-id> <category>copying</category><body package="Browser-Environments" selector="postCopy">postCopy	| newDict |	newDict := classSelectors copy.	newDict keysAndValuesDo: [:key :value | newDict at: key put: value copy].	classSelectors := newDict.	newDict := metaClassSelectors copy.	newDict keysAndValuesDo: [:key :value | newDict at: key put: value copy].	metaClassSelectors := newDict.	initializers := initializers copy.	^super postCopy</body></methods><methods><class-id>Refactory.Browser.SelectorEnvironment</class-id> <category>removing</category><body package="Browser-Environments" selector="removeClass:">removeClass: aClass 	aClass isMeta 		ifTrue: 			[metaClassSelectors removeKey: aClass soleInstance fullRootName ifAbsent: []]		ifFalse: [classSelectors removeKey: aClass fullRootName ifAbsent: []]</body><body package="Browser-Environments" selector="removeClass:selector:">removeClass: aClass selector: aSelector 	(aClass isMeta 		ifTrue: 			[metaClassSelectors at: aClass soleInstance fullRootName ifAbsent: [^self]]		ifFalse: [classSelectors at: aClass fullRootName ifAbsent: [^self]]) 			remove: aSelector			ifAbsent: []</body><body package="Browser-Environments" selector="removeInitializer:">removeInitializer: aQualifiedReference 	initializers remove: aQualifiedReference ifAbsent: []</body></methods><methods><class-id>Refactory.Browser.SelectorEnvironment</class-id> <category>adding</category><body package="Browser-Environments" selector="addClass:">addClass: aClass 	aClass isMeta 		ifTrue: 			[metaClassSelectors at: aClass soleInstance fullRootName put: aClass selectors]		ifFalse: [classSelectors at: aClass fullRootName put: aClass selectors]</body><body package="Browser-Environments" selector="addClass:selector:">addClass: aClass selector: aSymbol 	(aClass isMeta 		ifTrue: 			[metaClassSelectors at: aClass soleInstance fullRootName ifAbsentPut: [Set new]]		ifFalse: [classSelectors at: aClass fullRootName ifAbsentPut: [Set new]]) 			add: aSymbol</body><body package="Browser-Environments" selector="addDefinition:">addDefinition: aGeneralMethodDefinition 	aGeneralMethodDefinition isForSharedVariable 		ifTrue: 			[self 				addInitializer: aGeneralMethodDefinition fullName asQualifiedReference]		ifFalse: 			[self addClass: aGeneralMethodDefinition implementingClass				selector: aGeneralMethodDefinition selector]</body><body package="Browser-Environments" selector="addInitializer:">addInitializer: aQualifiedReference 	initializers add: aQualifiedReference</body></methods><methods><class-id>Refactory.Browser.SelectorEnvironment</class-id> <category>printing</category><body package="Browser-Environments" selector="storeOn:">storeOn: aStream 	| classBlock |	aStream		nextPutAll: '((';		nextPutAll: self class fullRootName;		nextPutAll: ' onEnvironment: '.	environment storeOn: aStream.	aStream		nextPut: $);		nextPutAll: ' classes: #('.	classBlock := 			[:key :value | 			aStream				nextPutAll: '#(';				store: key;				nextPutAll: ' #('.			value do: 					[:each | 					aStream						store: each;						nextPut: $ ].			aStream				nextPutAll: '))';				cr].	classSelectors keysAndValuesDo: classBlock.	aStream nextPutAll: ') metaClasses: #('.	metaClassSelectors keysAndValuesDo: classBlock.	aStream nextPutAll: '))'</body></methods><methods><class-id>Refactory.Browser.SelectorEnvironment class</class-id> <category>instance creation</category><body package="Browser-Environments" selector="implementorsMatching:in:">implementorsMatching: aString in: anEnvironment 	| classDict metaDict |	classDict := Dictionary new.	metaDict := Dictionary new.	anEnvironment classesDo: 			[:class | 			| selectors |			selectors := Set new.			anEnvironment selectorsForClass: class				do: [:each | (aString match: each) ifTrue: [selectors add: each]].			selectors notEmpty 				ifTrue: 					[class isMeta 						ifTrue: [metaDict at: class soleInstance fullRootName put: selectors]						ifFalse: [classDict at: class fullRootName put: selectors]]].	^(self onEnvironment: anEnvironment)		classSelectors: classDict metaClassSelectors: metaDict;		label: ((#ImplementorsOf1s &lt;&lt; #browser &gt;&gt; 'Implementors of &lt;1s&gt;')			expandMacrosWith: aString);		yourself</body><body package="Browser-Environments" selector="implementorsOf:in:">implementorsOf: aSelector in: anEnvironment 	| classDict metaDict selectors |	classDict := Dictionary new.	metaDict := Dictionary new.	selectors := Set with: aSelector.	anEnvironment classesDo: 			[:class | 			((class includesSelector: aSelector) 				and: [anEnvironment includesSelector: aSelector in: class]) 					ifTrue: 						[class isMeta 							ifTrue: [metaDict at: class soleInstance fullRootName put: selectors copy]							ifFalse: [classDict at: class fullRootName put: selectors copy]]].	^(self onEnvironment: anEnvironment)		classSelectors: classDict metaClassSelectors: metaDict;		label: ((#ImplementorsOf1s &lt;&lt; #browser &gt;&gt; 'Implementors of &lt;1s&gt;')			expandMacrosWith: aSelector);		yourself</body><body package="Browser-Environments" selector="matches:in:">matches: aString in: anEnvironment 	| newEnvironment |	newEnvironment := (self onEnvironment: anEnvironment)				label: ((#Matching1s &lt;&lt; #browser &gt;&gt; 'Matching: &lt;1s&gt;')			expandMacrosWith: aString);				searchStrings: (Array with: aString);				yourself.	anEnvironment classesAndSelectorsDo: 			[:each :sel | 			| method |			method := each compiledMethodAt: sel.			method allLiterals do: 					[:lit | 					(self checkLiteral: lit matches: aString) 						ifTrue: [newEnvironment addClass: each selector: sel]]].	^newEnvironment</body><body package="Browser-Environments" selector="onMethods:">onMethods: aMethodDefinitionCollection 	"We have to perserve the extra text in the original method definitions, so we defer to some specialized subclass."	^MethodDefinitionEnvironment onMethods: aMethodDefinitionCollection</body><body package="Browser-Environments" selector="onMethods:forClass:in:">onMethods: selectorCollection forClass: aClass in: anEnvironment 	| env |	env := self onEnvironment: anEnvironment.	selectorCollection do: [:each | env addClass: aClass selector: each].	^env</body><body package="Browser-Environments" selector="referencesTo:in:">referencesTo: aLiteral in: anEnvironment 	| classDict literalPrintString specialIndex variables |	literalPrintString := aLiteral isVariableBinding 				ifTrue: [aLiteral key asString]				ifFalse: 					[aLiteral isString ifTrue: [aLiteral] ifFalse: [aLiteral printString]].	specialIndex := CompiledCode specialSelectorIndexFor: aLiteral.	classDict := Dictionary new.	anEnvironment classesDo: 			[:class | 			| selectors |			selectors := (class whichSelectorsReferTo: aLiteral) 						select: [:aSelector | anEnvironment includesSelector: aSelector in: class].			selectors notEmpty ifTrue: [classDict at: class put: selectors]].	variables := OrderedCollection new.	anEnvironment sharedVariableReferencesDo: 			[:each | 			| binding init method |			binding := each bindingOrNil.			binding notNil 				ifTrue: 					[init := binding initializer.					init notNil 						ifTrue: 							[method := init method.							((method refersToLiteral: aLiteral) or: 									[(specialIndex &gt; 0 and: [method sendsSpecialSelector: specialIndex]) 										or: [method refersToSpecialLiteral: aLiteral]]) 								ifTrue: [variables add: each]]]].	^(self onEnvironment: anEnvironment)		on: classDict;		initializers: variables;		label: ((#ReferencesTo1s &lt;&lt; #browser &gt;&gt; 'References to: &lt;1s&gt;')			expandMacrosWith: literalPrintString);		searchStrings: (Array with: literalPrintString);		yourself</body></methods><methods><class-id>Refactory.Browser.SelectorEnvironment class</class-id> <category>private</category><body package="Browser-Environments" selector="checkLiteral:matches:">checkLiteral: aLiteral matches: aString 	aLiteral class = Array 		ifTrue: [^aLiteral anySatisfy: [:each | self checkLiteral: each matches: aString]].	^aLiteral isString and: [aString match: aLiteral]</body></methods><methods><class-id>Refactory.Browser.MethodDefinitionEnvironment</class-id> <category>accessing</category><body package="Browser-Environments" selector="methodDefinitions">methodDefinitions	definitions removeAllSuchThat: 			[:each | 			each isForSharedVariable 				ifTrue: [each binding isNil]				ifFalse: [each hasMethod not]].	^definitions</body></methods><methods><class-id>Refactory.Browser.MethodDefinitionEnvironment</class-id> <category>initialize-release</category><body package="Browser-Environments" selector="definitions:">definitions: aMethodDefinitionCollection 	definitions := aMethodDefinitionCollection asOrderedCollection</body><body package="Browser-Environments" selector="initialize">initialize	definitions := OrderedCollection new.	super initialize</body></methods><methods><class-id>Refactory.Browser.MethodDefinitionEnvironment</class-id> <category>removing</category><body package="Browser-Environments" selector="removeClass:">removeClass: aClass 	definitions removeAllSuchThat: [:each | each classOrNameSpace = aClass].	super removeClass: aClass</body><body package="Browser-Environments" selector="removeClass:selector:">removeClass: aClass selector: aSelector 	definitions removeAllSuchThat: 			[:each | 			each classOrNameSpace = aClass and: [each selector = aSelector]].	super removeClass: aClass selector: aSelector</body><body package="Browser-Environments" selector="removeInitializer:">removeInitializer: aQualifiedReference 	definitions removeAllSuchThat: 			[:each | 			each isForSharedVariable and: 					[each classOrNameSpace = aQualifiedReference environment 						and: [each variableName = aQualifiedReference simpleName]]].	super removeInitializer: aQualifiedReference</body></methods><methods><class-id>Refactory.Browser.MethodDefinitionEnvironment</class-id> <category>copying</category><body package="Browser-Environments" selector="postCopy">postCopy	definitions := definitions copy.	^super postCopy</body></methods><methods><class-id>Refactory.Browser.MethodDefinitionEnvironment</class-id> <category>adding</category><body package="Browser-Environments" selector="addClass:">addClass: aClass 	aClass selectors do: [:each | self addClass: aClass selector: each].	aClass asNameSpace bindingsDo: 			[:each | 			self addInitializer: (aClass asQualifiedReference append: each key)]</body><body package="Browser-Environments" selector="addClass:selector:">addClass: aClass selector: aSymbol 	definitions add: (MethodDefinition class: aClass selector: aSymbol).	super addClass: aClass selector: aSymbol</body><body package="Browser-Environments" selector="addDefinition:">addDefinition: aGeneralMethodDefinition 	aGeneralMethodDefinition isForSharedVariable 		ifTrue: 			[super 				addInitializer: aGeneralMethodDefinition fullName asQualifiedReference]		ifFalse: 			[super addClass: aGeneralMethodDefinition implementingClass				selector: aGeneralMethodDefinition selector].	definitions add: aGeneralMethodDefinition</body><body package="Browser-Environments" selector="addInitializer:">addInitializer: aQualifiedReference 	definitions 		add: (RBInitializerDefinition nameSpace: aQualifiedReference environment				key: aQualifiedReference simpleName).	super addInitializer: aQualifiedReference</body></methods><methods><class-id>Refactory.Browser.MethodDefinitionEnvironment class</class-id> <category>instance creation</category><body package="Browser-Environments" selector="onMethods:">onMethods: aMethodDefinitionCollection 	| env |	env := self new.	aMethodDefinitionCollection do: 			[:each | 			each isBindingReference 				ifTrue: [env addInitializer: each]				ifFalse: [env addDefinition: each]].	^env</body></methods><methods><class-id>Refactory.Browser.AndEnvironment</class-id> <category>private</category><body package="Browser-Environments" selector="andedEnvironment">andedEnvironment	^andedEnvironment</body></methods><methods><class-id>Refactory.Browser.AndEnvironment</class-id> <category>initialize-release</category><body package="Browser-Environments" selector="andedEnvironment:">andedEnvironment: aBrowserEnvironment 	andedEnvironment := aBrowserEnvironment</body></methods><methods><class-id>Refactory.Browser.AndEnvironment</class-id> <category>accessing</category><body package="Browser-Environments" selector="classesDo:">classesDo: aBlock 	environment 		classesDo: [:each | (self includesClass: each) ifTrue: [aBlock value: each]]</body><body package="Browser-Environments" selector="numberSelectors">numberSelectors	| total |	total := 0.	environment classesAndSelectorsDo: 			[:each :sel | 			(andedEnvironment includesSelector: sel in: each) 				ifTrue: [total := total + 1]].	^total</body><body package="Browser-Environments" selector="selectorsForClass:do:">selectorsForClass: aClass do: aBlock 	environment selectorsForClass: aClass		do: 			[:each | 			(andedEnvironment includesSelector: each in: aClass) 				ifTrue: [aBlock value: each]]</body></methods><methods><class-id>Refactory.Browser.AndEnvironment</class-id> <category>testing</category><body package="Browser-Environments" selector="includesBinding:in:">includesBinding: aBinding in: aNameSpace 	^aBinding isForClass 		ifTrue: 			[(self includesClass: aBinding value) 				or: [self includesClass: aBinding value class]]		ifFalse: 			[(super includesBinding: aBinding in: aNameSpace) 				and: [andedEnvironment includesBinding: aBinding in: aNameSpace]]</body><body package="Browser-Environments" selector="includesClass:">includesClass: aClass 	| doesntHaveSelectors |	(environment includesClass: aClass) ifFalse: [^false].	(andedEnvironment includesClass: aClass) ifFalse: [^false].	doesntHaveSelectors := true.	environment selectorsForClass: aClass		do: 			[:each | 			doesntHaveSelectors := false.			(andedEnvironment includesSelector: each in: aClass) ifTrue: [^true]].	^doesntHaveSelectors</body><body package="Browser-Environments" selector="includesNameSpace:">includesNameSpace: aNameSpace 	^(super includesNameSpace: aNameSpace) 		and: [andedEnvironment includesNameSpace: aNameSpace]</body><body package="Browser-Environments" selector="includesProtocol:in:">includesProtocol: aProtocol in: aClass 	^(self selectorsFor: aProtocol in: aClass) notEmpty</body><body package="Browser-Environments" selector="includesSelector:in:">includesSelector: aSelector in: aClass 	^(environment includesSelector: aSelector in: aClass) 		and: [andedEnvironment includesSelector: aSelector in: aClass]</body></methods><methods><class-id>Refactory.Browser.AndEnvironment</class-id> <category>printing</category><body package="Browser-Environments" selector="storeOn:">storeOn: aStream 	aStream nextPut: $(.	environment storeOn: aStream.	aStream nextPutAll: ' &amp; '.	andedEnvironment storeOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>Refactory.Browser.AndEnvironment class</class-id> <category>instance creation</category><body package="Browser-Environments" selector="onEnvironment:and:">onEnvironment: anEnvironment and: anotherEnvironment 	^(self onEnvironment: anEnvironment)		andedEnvironment: anotherEnvironment;		yourself</body></methods><methods><class-id>Refactory.Browser.ClassEnvironment</class-id> <category>initialize-release</category><body package="Browser-Environments" selector="classes:">classes: aCollection 	aCollection do: [:each | self addClass: each]</body><body package="Browser-Environments" selector="initialize">initialize	super initialize.	classes := Set new.	metaClasses := Set new</body></methods><methods><class-id>Refactory.Browser.ClassEnvironment</class-id> <category>testing</category><body package="Browser-Environments" selector="includesBinding:in:">includesBinding: aBinding in: aNameSpace 	^(super includesBinding: aBinding in: aNameSpace) and: 			[aBinding isForClass and: 					[(self includesClass: aBinding value) 						or: [self includesClass: aBinding value class]]]</body><body package="Browser-Environments" selector="includesClass:">includesClass: aClass 	^(aClass isMeta		ifTrue: [metaClasses includes: aClass soleInstance fullRootName]		ifFalse: [classes includes: aClass fullRootName])			and: [super includesClass: aClass]</body><body package="Browser-Environments" selector="includesNameSpace:">includesNameSpace: aNameSpace 	^false</body><body package="Browser-Environments" selector="isClassEnvironment">isClassEnvironment	^true</body><body package="Browser-Environments" selector="isEmpty">isEmpty	^classes isEmpty and: [metaClasses isEmpty]</body></methods><methods><class-id>Refactory.Browser.ClassEnvironment</class-id> <category>copying</category><body package="Browser-Environments" selector="postCopy">postCopy	classes := classes copy.	metaClasses := metaClasses copy.	^super postCopy</body></methods><methods><class-id>Refactory.Browser.ClassEnvironment</class-id> <category>private</category><body package="Browser-Environments" selector="defaultLabel">defaultLabel	| stream |	stream := String new writeStream.	classes do: 			[:each | 			stream				nextPutAll: each;				nextPut: $ ].	^stream contents</body></methods><methods><class-id>Refactory.Browser.ClassEnvironment</class-id> <category>accessing-classes</category><body package="Browser-Environments" selector="classesDo:">classesDo: aBlock 	classes do: 			[:each | 			| class |			class := each asQualifiedReference value.			(class notNil and: [environment includesClass: class]) 				ifTrue: [aBlock value: class]].	metaClasses do: 			[:each | 			| class |			class := each asQualifiedReference value.			(class notNil and: [environment includesClass: class class]) 				ifTrue: [aBlock value: class class]]</body><body package="Browser-Environments" selector="classNames">classNames	^(Set withAll: classes)		addAll: metaClasses;		yourself</body></methods><methods><class-id>Refactory.Browser.ClassEnvironment</class-id> <category>printing</category><body package="Browser-Environments" selector="storeOn:">storeOn: aStream 	aStream nextPut: $(.	super storeOn: aStream.	aStream nextPutAll: ' classes: (('.	classes asArray storeOn: aStream.	aStream 		nextPutAll: ' inject: OrderedCollection new into: [:sum :each | 				| class |				class := (BindingReference pathString: each) valueOrDo: [nil].				class notNil ifTrue: [sum add: class].				sum]) , ('.	metaClasses asArray storeOn: aStream.	aStream 		nextPutAll: ' inject: OrderedCollection new into: [:sum :each | 				| class |				class := (BindingReference pathString: each) valueOrDo: [nil].				class notNil ifTrue: [sum add: class class].				sum])))'</body></methods><methods><class-id>Refactory.Browser.ClassEnvironment</class-id> <category>adding</category><body package="Browser-Environments" selector="addClass:">addClass: aClass 	aClass isMeta		ifTrue: [metaClasses add: aClass soleInstance fullRootName]		ifFalse: [classes add: aClass fullRootName]</body></methods><methods><class-id>Refactory.Browser.ClassEnvironment</class-id> <category>removing</category><body package="Browser-Environments" selector="removeClass:">removeClass: aClass 	aClass isMeta		ifTrue: [metaClasses remove: aClass soleInstance fullRootName ifAbsent: []]		ifFalse: [classes remove: aClass fullRootName ifAbsent: []]</body></methods><methods><class-id>Refactory.Browser.ClassEnvironment class</class-id> <category>instance creation</category><body package="Browser-Environments" selector="onEnvironment:classes:">onEnvironment: anEnvironment classes: aCollection 	^(self onEnvironment: anEnvironment)		classes: aCollection;		yourself</body></methods><methods><class-id>Refactory.Browser.ParcelEnvironment</class-id> <category>private</category><body package="Browser-Environments" selector="defaultLabel">defaultLabel	| stream |	stream := String new writeStream.	parcelNames do: [:each | stream nextPutAll: each]		separatedBy: [stream nextPut: $ ].	^stream contents</body></methods><methods><class-id>Refactory.Browser.ParcelEnvironment</class-id> <category>testing</category><body package="Browser-Environments" selector="definesClass:">definesClass: aBehavior 	^self parcels anySatisfy: [:each | each definesClass: aBehavior]</body><body package="Browser-Environments" selector="includesBinding:in:">includesBinding: aBinding in: aNameSpace 	(super includesBinding: aBinding in: aNameSpace) ifFalse: [^false].	^aBinding isForClass 		ifTrue: 			[self parcels anySatisfy: 					[:each | 					(each definesOrExtendsClass: aBinding value) 						or: [each definesOrExtendsClass: aBinding value class]]]		ifFalse: 			[aBinding isForNameSpace 				ifTrue: 					[self parcels anySatisfy: [:each | each definesObject: aBinding value]]				ifFalse: 					[aNameSpace notNil and: 							[self parcels 								anySatisfy: [:each | each definesName: aBinding key in: aNameSpace]]]]</body><body package="Browser-Environments" selector="includesClass:">includesClass: aClass 	(super includesClass: aClass) ifFalse: [^false].	^self parcels anySatisfy: [:each | each definesOrExtendsClass: aClass]</body><body package="Browser-Environments" selector="includesNameSpace:">includesNameSpace: aNameSpace 	^self parcels 		anySatisfy: [:each | each definesClassOrNameSpace: aNameSpace]</body><body package="Browser-Environments" selector="includesProtocol:in:">includesProtocol: aProtocol in: aClass 	^(super includesProtocol: aProtocol in: aClass) and: 			[(environment selectorsFor: aProtocol in: aClass) 				anySatisfy: [:aSelector | self includesSelector: aSelector in: aClass]]</body><body package="Browser-Environments" selector="includesSelector:in:">includesSelector: aSelector in: aClass 	^(environment includesSelector: aSelector in: aClass) and: 			[self parcels 				anySatisfy: [:each | each definesSelector: aSelector forClass: aClass]]</body><body package="Browser-Environments" selector="isClassContainer">isClassContainer	^true</body></methods><methods><class-id>Refactory.Browser.ParcelEnvironment</class-id> <category>initialize-release</category><body package="Browser-Environments" selector="parcelNames:">parcelNames: aCollection 	parcelNames := aCollection</body><body package="Browser-Environments" selector="parcels:">parcels: aCollection 	parcelNames := aCollection collect: [:each | each name]</body></methods><methods><class-id>Refactory.Browser.ParcelEnvironment</class-id> <category>accessing</category><body package="Browser-Environments" selector="parcels">parcels	| parcels |	parcels := OrderedCollection new: parcelNames size.	parcelNames do: 			[:each | 			| parcel |			parcel := each = UnparceledParcel unparceledParcelName 						ifTrue: [UnparceledParcel new]						ifFalse: [Parcel parcelNamed: each].			parcel notNil ifTrue: [parcels add: parcel]].	^parcels</body></methods><methods><class-id>Refactory.Browser.ParcelEnvironment</class-id> <category>copying</category><body package="Browser-Environments" selector="postCopy">postCopy	super postCopy.	parcelNames := parcelNames copy</body></methods><methods><class-id>Refactory.Browser.ParcelEnvironment</class-id> <category>printing</category><body package="Browser-Environments" selector="storeOn:">storeOn: aStream 	aStream nextPut: $(.	super storeOn: aStream.	aStream nextPutAll: ' parcelNames: '.	parcelNames asArray storeOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>Refactory.Browser.ParcelEnvironment class</class-id> <category>instance creation</category><body package="Browser-Environments" selector="onEnvironment:parcelNames:">onEnvironment: anEnvironment parcelNames: aCollection 	^(self onEnvironment: anEnvironment)		parcelNames: aCollection;		yourself</body><body package="Browser-Environments" selector="onEnvironment:parcels:">onEnvironment: anEnvironment parcels: parcelCollection 	^(self onEnvironment: anEnvironment)		parcels: parcelCollection;		yourself</body></methods><methods><class-id>Kernel.NameSpaceOrganizer</class-id> <category>categories</category><body package="Browser-Environments" selector="classCategories">classCategories	| all |	all := Set withAll: emptyCategories.	self environment 		bindingsDo: [:i | i isForGeneral ifFalse: [all add: i category]].	^all</body><body package="Browser-Environments" selector="sharedVariableCategories">sharedVariableCategories	| all |	all := Set withAll: emptyCategories.	self environment 		bindingsDo: [:i | i isForGeneral ifTrue: [all add: i category]].	^all</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>RefactoringBrowser</category><body package="Browser-Environments" selector="fullRootName">fullRootName	| stream |	self environment isNil ifTrue: [^self name].	stream := WriteStream on: (String new: 64).	self fullRootNameInto: stream.	^stream contents</body><body package="Browser-Environments" selector="fullRootNameInto:">fullRootNameInto: aStream 	self environment notNil 		ifTrue: 			[self environment fullRootNameInto: aStream.			aStream nextPut: $.].	aStream nextPutAll: self name</body></methods><methods><class-id>Core.Behavior</class-id> <category>RefactoringBrowser</category><body package="Browser-Environments" selector="fullRootName">fullRootName	| stream |	stream := WriteStream on: (String new: 64).	self fullRootNameInto: stream.	^stream contents</body><body package="Browser-Environments" selector="fullRootNameInto:">fullRootNameInto: aStream 	self environment fullRootNameInto: aStream.	aStream nextPut: $..	aStream nextPutAll: self name</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>NameSpace</name><environment>Kernel</environment><super>Kernel.GeneralNameSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>NameSpaceOrganizer</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comment environment emptyCategories </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class></st-source>