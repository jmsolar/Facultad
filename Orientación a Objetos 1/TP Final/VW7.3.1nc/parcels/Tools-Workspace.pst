<?xml version="1.0"?><st-source><!-- Name: Tools-WorkspaceNotice: Copyright © 1999-2005 Cincom Systems, Inc.  All Rights Reserved.Comment: Tools-Workspaces provide a workspace that organizes several workspaces inside a single window. Such multiple-page workspaces, or "workbooks", are the default kind of workspace opened by the Launcher. If you prefer the traditional single-page workspaces, you can use the "Workspace" section of the Settings tool to change this default. You can also "tear off" a page from the workbook into a single-page workspace.An inspector of workspace local variables (Trippy in disguise) is  integrated into a workspace window and supports saving and loading objects in workspace variables as files using BOSS. Together with the ability to drag and drop objects between workspaces and inspectors open on any objects in the image, this allows copying objects between images.Workspaces protect against overwriting concurrent changes. When a workspace reads a file for editing, it remembers its modification timestamp. Before saving, a workspace makes sure that the timestamp of the file has not changed, warning you if it has.DbIdentifier: bear73DbTrace: 51841DevelopmentPrerequisites: #(#(#any 'Tools-Trippy' ''))PackageName: Tools-WorkspaceParcel: #('Tools-Workspace')ParcelName: Tools-WorkspacePrerequisiteParcels: #(#('Tools-Trippy' ''))PrintStringCache: (7.3.1 - 1.1,bobw)Version: 7.3.1Date: 5:52:32 pm April 10, 2005 --><time-stamp>From VisualWorks®, 7.3.1 of April 10, 2005 on April 10, 2005 at 5:52:32 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>NoWorkspace</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Workspace</category><attributes><package>Tools-Workspace</package></attributes></class><comment><class-id>Tools.NoWorkspace</class-id><body>Instances of this class stand in for "real" parent workspaces of WorkspacePages used in a standalone mode (as undecorated windows similar to the classic Smalltalk-80 workspaces).</body></comment><class><name>AbstractWorkspace</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>locals importAll specificImports importSummaryHolder pageExplanationHolder statusBarVisible encodingChannel menuBarHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Workspace</category><attributes><package>Tools-Workspace</package></attributes></class><comment><class-id>Tools.AbstractWorkspace</class-id><body>This is the abstract superclass of various kinds of workspaces.  Typically, a workspace manages some text and some local variables. This abstract superclass takes care of variable management and leaves text management as well as the actual GUI that takes care of switches between text(s) and variables up to the specific subclass.This class does, however, manage some GUI things--such as the window toolbar or value holders used by the status bar's page explanation and import summary boxes. It also assumes subclasses will implement the following methods:	currentPage	currentTextPage	isAtTextPageInstance Variables:	locals	&lt;WorkspaceVariablePool&gt;	The pool containing this workspace's local variables.	importAll	&lt;Boolean&gt;	True if this workspace should compile the code it evaluates in context of all namespaces currently in the system.	specificImports	&lt;Collection of: NameSpace&gt;	If 'importAll' if false, only namespaces included in this collection are imported when compiling the code in the workspace.	menuBar	&lt;ValueHolder with: Menu&gt;	A holder with the workspace window menu bar.	importSummaryHolder	&lt;ValueHolder with: String&gt;	The model of a status bar box showing the summary of currently imported namespaces.	pageExplanationHolder	&lt;ValueHolder with: String&gt; The model of a status bar box showing the explanation of the currenly displayed page.	encodingChannel	&lt;ValueHolder with: Symbol&gt; The encoding menu sets the value of this holder to be the currently selected encoding. Various component may register themselves as dependents to track preferred encoding changes.Class Variables		ShowStatusBar	&lt;Boolean&gt;	If true (the default value) all workspaces open with the status bar visible.	ShowToolBar	&lt;Boolean&gt;	If true (the default value) all workspaces open with the toolbar visible.	UseMultiPageWorkspaces	&lt;Boolean&gt;	If true (the default value) open the new-style workspace.</body></comment><class><name>Workbook</name><environment>Tools</environment><super>Tools.AbstractWorkspace</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pageHolder lastInstalledPage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Workspace</category><attributes><package>Tools-Workspace</package></attributes></class><comment><class-id>Tools.Workbook</class-id><body>This is the new-style (as of 5i.4) workspace.  It consists of a number of text pages selected using a tab control, as well as a separate page for workspace local variables.Instance Variables:	pageHolder	&lt;SelectionInList&gt;	Pages currently contained by this workspace. Pages are instances of either WorkspacePage (text pages) or WorkspaceInspectorPage (variable page). A workbook contains one or more text pages followed by one variable page.	lastInstalledPage	&lt;WorkspacePage | WorkspaceInspectorPage&gt;	The current page of the workspace. Preserved so the action triggered on a page change can refer to the previous page.</body></comment><class><name>WorkspaceImportsDialog</name><environment>Tools</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>namespaces importAllHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Workspace</category><attributes><package>Tools-Workspace</package></attributes></class><comment><class-id>Tools.WorkspaceImportsDialog</class-id><body>The "Imported Namespaces" dialog brought up by the "Smalltalk&gt;Namespaces..." menu item.Instance Variables:	namespaces	&lt;MultiSelectionInList&gt;  Model of the "some" namespace list.	importAllHolder	&lt;ValueHolder with: Boolean&gt; Holds a Boolean indicating whether the user wants to import all namespaces or only those selected in the "some" namespace list. </body></comment><class><name>WorkspaceCompilerErrorHandler</name><environment>Tools</environment><super>Kernel.InteractiveCompilerErrorHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>workspace </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Workspace</category><attributes><package>Tools-Workspace</package></attributes></class><comment><class-id>Tools.WorkspaceCompilerErrorHandler</class-id><body>A specialized error handler involved in workspace-local variables implementation. It is essentially an InteractiveErrorHandler. The only difference is the treatment of undefined variables. They are silently passed on to the workspace to be added to the pool of local variables, then compilation continues.Instance Variables:	workspace	&lt;Workspace&gt; The workspace that should receive all undeclared variables.Class Variables	SilentlyDeclareVariables	&lt;Boolean&gt;  If true (the default) then assume that an undeclared variable is a workspace local variable</body></comment><class><name>WorkspaceVariablePool</name><environment>Tools</environment><super>Kernel.NameSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars>workspace </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Workspace</category><attributes><package>Tools-Workspace</package></attributes></class><comment><class-id>Tools.WorkspaceVariablePool</class-id><body>A specialized NameSpace to be used as a pool of workspace local variables.  A regular namespace would work just as well, but this subclass slips in a different inspector class, so we have more control over what the user gets as the inspector.Instance Variables:	workspace	&lt;Workspace&gt;  The workspace this pool belongs to, to get import information.</body></comment><class><name>WorkspaceInspectorPage</name><environment>Tools</environment><super>Tools.Trippy.InspectorHolder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Workspace</category><attributes><package>Tools-Workspace</package></attributes></class><comment><class-id>Tools.WorkspaceInspectorPage</class-id><body>This is the inspector page displaying the workspace local variables. (Though technically it can contain any inspector on any object).  It is just an subclass of the regular InspectorHolder extended to understand the workspace page protocol.</body></comment><class><name>WorkspacePage</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>workspace label verboseLabel filename fileTimestamp textModel unacceptedText savedSelection savedFileTimestamp textModelOverride </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Workspace</category><attributes><package>Tools-Workspace</package></attributes></class><comment><class-id>Tools.WorkspacePage</class-id><body>This is the subapplication that takes care of text editing for various workspaces.Instance Variables:	workspace	&lt;No Workspace | AbstractWorkspace subclass&gt; The workspace that contains this page; supplies local variables and the receiver for doits.	label	&lt;String&gt;	The label of this page. Returned as the page's #displayString and may be used to differentiate between several pages in a UI. When a page is associated with a file by saving, the label is changed to become the file name sans path information.	verboseLabel &lt;String | nil&gt; The text that appears on the status bar when the page is selected.	filename	&lt;Filename | nil&gt;	If a page is associated with a file, the name of that file.	fileTimestamp &lt;Timestamp | nil&gt; The modification timestamp of a file at the time the file was read into the workspace. Before saving, it is compared to the timestamp of the file at that time to determine whether saving can overwrite changes made by other tools.	textModel	&lt;PluggableAdaptor&gt;	redirecting value requests to the page, so that the page can either read or write the file it displays or use its textModelOverride (see below).	unacceptedText	&lt;String | nil&gt;	When a page that has unsaved changes is uninstalled by the higher-level application, the unsaved text from the text editor controller is preserved here.  If this variable is nil, the page is either active or had no unsaved changes when deactivated.	savedSelection	&lt;Array | nil&gt;	When the unsaved text is preserved, the selection start and stop indices are saved here as an array of two elements.	savedFileTimestamp &lt;Timestamp | nil&gt; When unsaved text is preserved, the original timestamp of the file where the text came from is preserved as well.  When the interface is rebuilt later, the timestamp is restored to be the original one (by which time the original timestamp may have been overridden by the timestamp of the file at the time of rebuilding).	textModelOverride	&lt;ValueHolder | nil&gt; In some cases, such as when editing text in a value holder in the image, the page uses this as the holder for the text it shows. In such cases, 'accept' in the text view will save the text displayed into the holder. File&gt;Save, however, will request a file name as save the text into a file.  This holder is also used when opening a page on a non-existent file with some initial text, to store the initial text.</body></comment><class><name>Workspace</name><environment>Tools</environment><super>Tools.AbstractWorkspace</super><private>false</private><indexed-type>none</indexed-type><inst-vars>textPage inspectorPage currentPage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Workspace</category><attributes><package>Tools-Workspace</package></attributes></class><comment><class-id>Tools.Workspace</class-id><body>This is a more traditional workspace, with a single text area to edit text, however it can switch the view to an inboard inspector on the pool of locals.Instance Variables:	textPage	&lt;WorkspacePage&gt;	The page providing the text editing interface.	inspectorPage	&lt;WorkspaceInspectorPage&gt;	The page providing the inspector interface.	currentPage	&lt;WorkspacePage | WorkspaceInspectorPage&gt;	The currently displayed page, either the textPage or inspectorPage.</body></comment><shared-variable><name>PopularEncodings</name><environment>Tools.WorkspacePage</environment><private>false</private><constant>false</constant><category>encodings</category><initializer>OrderedCollection new</initializer><attributes><package>Tools-Workspace</package></attributes></shared-variable><shared-variable><name>ShowStatusBar</name><environment>Tools.AbstractWorkspace</environment><private>false</private><constant>false</constant><category>Settings</category><initializer>true</initializer><attributes><package>Tools-Workspace</package></attributes></shared-variable><shared-variable><name>UseMultiPageWorkspaces</name><environment>Tools.AbstractWorkspace</environment><private>false</private><constant>false</constant><category>Settings</category><initializer>true</initializer><attributes><package>Tools-Workspace</package></attributes></shared-variable><shared-variable><name>ShowToolBar</name><environment>Tools.AbstractWorkspace</environment><private>false</private><constant>false</constant><category>Settings</category><initializer>true</initializer><attributes><package>Tools-Workspace</package></attributes></shared-variable><shared-variable><name>SilentlyDeclareVariables</name><environment>Tools.WorkspaceCompilerErrorHandler</environment><private>false</private><constant>false</constant><category>Settings</category><initializer>true</initializer><attributes><package>Tools-Workspace</package></attributes></shared-variable><methods><class-id>Tools.NoWorkspace</class-id> <category>workspace fakery</category><body package="Tools-Workspace" selector="addAllToLocals:">addAllToLocals: ignored</body><body package="Tools-Workspace" selector="doItHandler">doItHandler	^InteractiveCompilerErrorHandler new</body><body package="Tools-Workspace" selector="doItReceiver">doItReceiver	^nil</body><body package="Tools-Workspace" selector="encodingChannel">encodingChannel	^#Source asValue</body><body package="Tools-Workspace" selector="updatePage">updatePage	"Nothing to do."</body></methods><methods><class-id>Tools.AbstractWorkspace</class-id> <category>accessing</category><body package="Tools-Workspace" selector="addLocal:">addLocal: aKey	locals at: aKey put: nil</body><body package="Tools-Workspace" selector="addLocal:value:">addLocal: aKey value: anObject	locals at: aKey put: anObject</body><body package="Tools-Workspace" selector="currentPage">currentPage	"Subclasses should implement this to answer the current page installed;	whatever is their notion of what pages are there and how they are managed."	self subclassResponsibility</body><body package="Tools-Workspace" selector="currentTextPage">currentTextPage	"Subclasses should implement this to answer the current text page installed	or fail if the current page is not one that contains text;	whatever is their notion of what pages are there and how they are managed."	self subclassResponsibility</body><body package="Tools-Workspace" selector="doItEnvironment">doItEnvironment	"Every time the environment is requested, re-update imports 	if 'all' are imported because namespaces might have been added to the	system in the meantime."	importAll ifTrue: [locals updateImports].	^locals</body><body package="Tools-Workspace" selector="doItHandler">doItHandler	^WorkspaceCompilerErrorHandler new		workspace: self</body><body package="Tools-Workspace" selector="doItReceiver">doItReceiver	^locals at: #self ifAbsent: [nil]</body><body package="Tools-Workspace" selector="encoding:">encoding: aSymbol	encodingChannel value: aSymbol</body><body package="Tools-Workspace" selector="encodingChannel">encodingChannel	^encodingChannel</body><body package="Tools-Workspace" selector="imports">imports	^importAll		ifTrue: [Root allNameSpaces copyWithout: Undeclared]		ifFalse: [specificImports]</body><body package="Tools-Workspace" selector="importSummaryHolder">importSummaryHolder	"This is a ValueHolder with a String containing the summary 	of what namespaces are imported. Subclasses may use it as	they wish in their UIs."	importSummaryHolder isNil		ifTrue: [importSummaryHolder := String new asValue].	^importSummaryHolder</body><body package="Tools-Workspace" selector="isAtTextPage">isAtTextPage	"Subclasses should implement this so the answer is true if the	current page is one that contains text and false otherwise."	self subclassResponsibility</body><body package="Tools-Workspace" selector="menuBarHolder">menuBarHolder	menuBarHolder isNil ifTrue: 		[menuBarHolder := self buildMenuBar asValue].	^menuBarHolder</body><body package="Tools-Workspace" selector="pageExplanationHolder">pageExplanationHolder	"This is a ValueHolder with a String containing an explanation of	what the current page displays.  For example, explanation of a 	text page with a text from a file is the full path name of the file. 	Subclasses may use it as they wish in their UIs."	^pageExplanationHolder isNil		ifTrue:			[pageExplanationHolder := String new asValue]		ifFalse:			[pageExplanationHolder]</body><body package="Tools-Workspace" selector="statusBarVisible">statusBarVisible	^statusBarVisible</body></methods><methods><class-id>Tools.AbstractWorkspace</class-id> <category>actions-delegated</category><body package="Tools-Workspace" selector="copySelection">copySelection	^self currentPage copySelection</body><body package="Tools-Workspace" selector="cut">cut	^self currentPage cut</body><body package="Tools-Workspace" selector="explain">explain	^self currentPage explain</body><body package="Tools-Workspace" selector="fileSave">fileSave	| result |	result := self currentTextPage saveIntoFile.	self updatePage.	^result</body><body package="Tools-Workspace" selector="fileSaveAs">fileSaveAs	| result |	result := self currentTextPage requestFileNameAndSave.	self updatePage.	^result</body><body package="Tools-Workspace" selector="find">find	^self currentPage find</body><body package="Tools-Workspace" selector="paste">paste	^self currentPage paste</body><body package="Tools-Workspace" selector="replace">replace	^self currentPage replace</body><body package="Tools-Workspace" selector="selectAll">selectAll	^self currentPage selectAll</body><body package="Tools-Workspace" selector="smalltalkDebugIt">smalltalkDebugIt	^self currentPage debugIt</body><body package="Tools-Workspace" selector="smalltalkDoIt">smalltalkDoIt	^self currentPage doIt</body><body package="Tools-Workspace" selector="smalltalkFileItIn">smalltalkFileItIn	^self currentPage fileItIn</body><body package="Tools-Workspace" selector="smalltalkInspectIt">smalltalkInspectIt	^self currentPage inspectIt</body><body package="Tools-Workspace" selector="smalltalkPrintIt">smalltalkPrintIt	^self currentPage printIt</body><body package="Tools-Workspace" selector="undo">undo	^self currentPage undo</body></methods><methods><class-id>Tools.AbstractWorkspace</class-id> <category>actions</category><body package="Tools-Workspace" selector="bossIn">bossIn		self currentPage canBOSSObjects		ifTrue: [self currentPage bossIn]</body><body package="Tools-Workspace" selector="bossOut">bossOut		self currentPage canBOSSObjects		ifTrue: [self currentPage bossOut]</body><body package="Tools-Workspace" selector="editImports">editImports	| dialog |	dialog := WorkspaceImportsDialog new.	dialog initializeImportAll: importAll specific: specificImports.	dialog open ifTrue:		[importAll := dialog importAll.		specificImports := dialog specificImports.		self updateImports]</body><body package="Tools-Workspace" selector="helpAbout">helpAbout	AboutVisualWorksDialog open</body><body package="Tools-Workspace" selector="helpWorkspace">helpWorkspace	SmalltalkWorkbench		openHelpBook: 'VisualWorks Tools' 		topic: 'Workspace'</body><body package="Tools-Workspace" selector="statusBarVisible:">statusBarVisible: aBoolean	statusBarVisible := aBoolean.	builder window refresh</body><body package="Tools-Workspace" selector="toggleStatusBar">toggleStatusBar	self statusBarVisible: statusBarVisible not</body><body package="Tools-Workspace" selector="toggleToolbar">toggleToolbar	| menuItem |	menuItem := self menuBar atNameKey: #toolbar.	self builder window toolbarVisible: menuItem isOn not.	menuItem indication: menuItem isOn not</body></methods><methods><class-id>Tools.AbstractWorkspace</class-id> <category>privileged</category><body package="Tools-Workspace" selector="addAllToLocals:">addAllToLocals: partCollection	partCollection size = 1		ifTrue: [self addOneToLocals: partCollection first]		ifFalse: [self addManyToLocals: partCollection]</body><body package="Tools-Workspace" selector="addAllToLocalsQuietly:">addAllToLocalsQuietly: keyValueCollection	| validated |	validated := Dictionary new.	keyValueCollection do:		[:keyValue | | name |		name := self makeVariableName: keyValue key uniqueIn: validated.		validated at: name put: keyValue value].	validated keysAndValuesDo:		[:key :value |		self addLocal: key value: value]</body><body package="Tools-Workspace" selector="addManyToLocals:">addManyToLocals: partCollection	| validated |	validated := Dictionary new.	partCollection do:		[:each | | name |		name := self makeVariableName: each asVariableName uniqueIn: validated.		validated at: name put: each].	(self confirmAdditionOf: validated) ifFalse: [^self].	validated keysAndValuesDo:		[:name :part |		self addLocal: name value: part value]</body><body package="Tools-Workspace" selector="addOneToLocals:">addOneToLocals: aPart	| name |	name := Dialog 		request: (#AssignDroppedObjectToWorkspaceLocalNamedColon &lt;&lt; #dialogs &gt;&gt; 'Assign the dropped object to a workspace local named:') 		initialAnswer: (self makeVariableName: aPart asVariableName).	name isEmpty ifTrue: [^self].	self addLocal: name value: aPart value</body><body package="Tools-Workspace" selector="clientAreaBottomOffset">clientAreaBottomOffset	^statusBarVisible ifTrue: [-24] ifFalse: [0]</body><body package="Tools-Workspace" selector="explainSpecial:for:">explainSpecial: aString for: anExplainer	"Answer with a string explaining the code view selection if it is 	displaying one of the special edit functions."	(locals includesKey: aString asSymbol) ifTrue:		[^Array with: 			(#explainer1SisAWorkspaceLocal &lt;&lt; #dialogs &gt;&gt; '''&lt;1s&gt;'' is a workspace local variable. Switch to the Variables tab to inspect its value.'				expandMacrosWith: aString)				-&gt; nil].	^nil</body></methods><methods><class-id>Tools.AbstractWorkspace</class-id> <category>private</category><body package="Tools-Workspace" selector="buildEncodingSubmenu">buildEncodingSubmenu	^WorkspacePage buildEncodingMenuFor: encodingChannel</body><body package="Tools-Workspace" selector="buildMenuBar">buildMenuBar	| menu |	menu := self class menuBar.	(menu atNameKey: #toggleStatusBar) indicationSelector: #statusBarVisible.	(menu atNameKey: #editEncoding) submenu: [self buildEncodingSubmenu].	menu 		augmentFrom: self class		to: AbstractWorkspace		menuName: #menuBar		for: self.	^menu</body><body package="Tools-Workspace" selector="canBOSSObjects">canBOSSObjects	^self currentPage canBOSSObjects</body><body package="Tools-Workspace" selector="capitalized:">capitalized: aString	^aString copy		at: 1 put: aString first asUppercase;		yourself</body><body package="Tools-Workspace" selector="confirmAdditionOf:">confirmAdditionOf: namePartDictionary	| message nameCount |	message := WriteStream on: (String new: 100).	nameCount := 1.	message nextPutAll: (#AssignDroppedObjectToWorkspaceLocalsColon &lt;&lt; #dialogs &gt;&gt; 'Assign the dropped objects to these workspace locals?') asString; cr.	namePartDictionary keys asSortedCollection		do: [:each | message nextPutAll: '"', each, '"']		separatedBy: 			[nameCount \\ 6 = 0 				ifTrue: [message nextPutAll: ','; cr]				ifFalse: [message nextPutAll: ', '].			nameCount := nameCount + 1].	^Dialog confirm: message contents</body><body package="Tools-Workspace" selector="hibernate">hibernate	"Prepare to become temporarily inactive and potentially have the widgets	rebuilt. Usually happens during UI rebuilds."	self subclassResponsibility</body><body package="Tools-Workspace" selector="importSummary">importSummary	^importAll		ifTrue: [(#All &lt;&lt; #labels &gt;&gt; 'All') asString]		ifFalse: [specificImports size printString]</body><body package="Tools-Workspace" selector="makeVariableName:">makeVariableName: aString	"Given an arbitrary string, produce a string that can be a valid variable name.	Do not allow pseudo-variable names except 'self'."	| noBlanks |	noBlanks := aString trimBlanks.	(SystemUtils validateName: noBlanks) isNil ifTrue:		[^((#object1s &lt;&lt; #dialogs &gt;&gt; 'object&lt;1s&gt;')			expandMacrosWith: (noBlanks select: [:some | some isLetter | some isDigit]))].	(#('true' 'false' 'super' 'nil' 'thisContext') includes: noBlanks) ifTrue:		[^(#x1sObject &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt;Object'			expandMacrosWith: noBlanks)].	^noBlanks</body><body package="Tools-Workspace" selector="makeVariableName:uniqueIn:">makeVariableName: aString uniqueIn: aDictionary	"Accept a string that can be anything and answer another string that can safely be used as a legal Smalltalk variable name. The answer can be the same as the argument if it was OK to begin with. Make sure there is no name clash with keys of aDictionary.  Append 2, 3, and so on to the original name until the clash if resolved. The dictionary keys may be strings or symbols."	| namesTaken baseName name suffix |	namesTaken := (aDictionary keys collect: [:each | each asString]) asSet.	baseName := self makeVariableName: aString.	name := baseName.	suffix := 2.	[namesTaken includes: name] whileTrue:		[name := baseName, suffix printString.		suffix := suffix + 1].	^name</body><body package="Tools-Workspace" selector="menuBar">menuBar	^self menuBarHolder value</body><body package="Tools-Workspace" selector="refreshMenuBar">refreshMenuBar	^self menuBarHolder value: self buildMenuBar</body><body package="Tools-Workspace" selector="reInstallInterface">reInstallInterface	"Install the receiver's user interface again. Keep the same 	window. This happens when restarting or changing look and feel."	| window spec |	self hibernate.	window := builder window.	window component release.		"Event dispatcher has to be reset so that it doesn't hold on to		old objects, such as keyboardProcessor, etc"	window controller reInstallEventDispatcher.	builder := UIBuilder new.	builder setWindow: window.	builder source: self.	spec := self class interfaceSpecFor: #windowSpec.	self preBuildWith: builder.	builder add: spec.	self postBuildWith: builder.	builder doFinalHookup.	builder window refresh. 		"Refresh needed to force proper layouts to the text widget, which		is otherwise not always able to properly restore its selection during		postOpen."	self postOpenWith: builder.	^builder</body><body package="Tools-Workspace" selector="updateImports">updateImports	locals updateImports.	self importSummaryHolder value: self importSummary</body><body package="Tools-Workspace" selector="updatePage">updatePage	"Page-related things such as labels may have changed for the current page."	self pageExplanationHolder value: self currentPage verboseLabel</body></methods><methods><class-id>Tools.AbstractWorkspace</class-id> <category>events</category><body package="Tools-Workspace" selector="windowEvent:from:">windowEvent: anEvent from: aWindow	super windowEvent: anEvent from: aWindow.	anEvent key = #newGraphicsDevice		ifTrue: [self reInstallInterface]</body></methods><methods><class-id>Tools.AbstractWorkspace</class-id> <category>initialize-release</category><body package="Tools-Workspace" selector="initialize">initialize	statusBarVisible := self class showStatusBar.	locals := WorkspaceVariablePool new initialize: self.	importAll := true.	specificImports := Array with: Smalltalk with: Core with: Kernel.	encodingChannel := #Source asValue.	self updateImports</body><body package="Tools-Workspace" selector="postBuildWith:">postBuildWith: aBuilder	builder window 		application: self;		sendWindowEvents: #(#newGraphicsDevice).</body><body package="Tools-Workspace" selector="postOpenWith:">postOpenWith: aBuilder	"Any new workspace comes up with the toolbar showing.	Toggle it if the user prefers it initially hidden."	self class showToolBar ifFalse: [self toggleToolbar]</body></methods><methods><class-id>Tools.AbstractWorkspace class</class-id> <category>window opening</category><body package="Tools-Workspace" selector="openFile:">openFile: aFilenameOrString	"Open a new workspace or a workbook with a single page on the file."	"Workspace openFile: 'visual.cha'"	"Workbook openFile: 'visual.cha'"	^(self withFile: aFilenameOrString) open</body><body package="Tools-Workspace" selector="openFile:ifAbsent:">openFile: aFilenameOrString ifAbsent: aBlock	"Open a new workspace or a workbook with a single page on the file.	If the file does not exist, create a workbook anyway with a	page associated with that non-existent file, and with the result	of evaluating aBlock (expected to be a String or a Text) as	the initial contents."	"Workspace openFile: 'bogus.zzz' ifAbsent: ['-new file-']"	"Workbook openFile: 'bogus.zzz' ifAbsent: ['-new file-']"	^(self withFile: aFilenameOrString ifAbsent: aBlock) open</body><body package="Tools-Workspace" selector="openOnHolder:">openOnHolder: aValueModel	"Open a new workspace or a workbook with a single page that has aString 	as the label and aValueModel as the content holder. Answer the builder."	"Workspace openOnHolder: 'Hello world' asValue"	"Workbook openOnHolder: 'Hello world' asValue"	^(self on: aValueModel) open</body><body package="Tools-Workspace" selector="openOnHolder:labeled:">openOnHolder: aValueModel labeled: aString	"Open a new workspace or a workbook with a single page that has aString 	as the label and aValueModel as the content holder. Answer the builder."	"Workspace openOnHolder: 'Hello world' asValue labeled: 'Greeting'"	"Workbook openOnHolder: 'Hello world' asValue labeled: 'Greeting'"	^(self on: aValueModel labeled: aString) open</body><body package="Tools-Workspace" selector="openWith:">openWith: aText	"Open a new workspace or a workbook with a single page that has aString 	as the label and aText as the contents."	"Workspace openWith: 'Hello world' "	"Workbook openWith: 'Hello world' "	^(self with: aText) open</body><body package="Tools-Workspace" selector="openWith:labeled:">openWith: aText labeled: aString	"Open a new workspace or a workbook with a single page that has aString 	as the label and aText as the contents."	"Workspace openWith: 'Hello world'  labeled: 'Greeting' "	"Workbook openWith: 'Hello world'  labeled: 'Greeting' "	^(self with: aText labeled: aString) open</body></methods><methods><class-id>Tools.AbstractWorkspace class</class-id> <category>instance creation</category><body package="Tools-Workspace" selector="on:">on: aValueModel	"Create a new instance using aValueModel as the contents holder."	self subclassResponsibility</body><body package="Tools-Workspace" selector="on:labeled:">on: aValueModel labeled: aString	"Create a new workbook with a single text page	that has aString as the label and aValueModel as the contents holder."	self subclassResponsibility</body><body package="Tools-Workspace" selector="with:">with: aText	"Create a new workbook with aText as the contents."	self subclassResponsibility</body><body package="Tools-Workspace" selector="with:labeled:">with: aText labeled: aString	"Create a new workbook with a single text page	that has aString as the label and aText as the contents."	self subclassResponsibility</body><body package="Tools-Workspace" selector="withFile:">withFile: aFilenameOrString	"Create a new workbook with text from the specified file, 	or empty if the file is missing."	^self withFile: aFilenameOrString ifAbsent: [String new]</body><body package="Tools-Workspace" selector="withFile:ifAbsent:">withFile: aFilenameOrString ifAbsent: aBlock	"Create a new workbook with text from the specified file.	If the file does not exist, create a workbook anyway with a	page associated with that non-existent file, and with the result	of evaluating aBlock (expected to be a String or a Text) as	the initial contents."	self subclassResponsibility</body></methods><methods><class-id>Tools.AbstractWorkspace class</class-id> <category>notifications</category><body package="Tools-Workspace" selector="instanceMethodsChanged">instanceMethodsChanged	ScheduledControllers scheduledControllers do:		[:each |		(each model isKindOf: self)			ifTrue: [each model refreshMenuBar]]</body></methods><methods><class-id>Tools.AbstractWorkspace class</class-id> <category>accessing</category><body package="Tools-Workspace" selector="showStatusBar">showStatusBar	^ShowStatusBar</body><body package="Tools-Workspace" selector="showStatusBar:">showStatusBar: aBoolean	ShowStatusBar := aBoolean</body><body package="Tools-Workspace" selector="showToolBar">showToolBar	^ShowToolBar</body><body package="Tools-Workspace" selector="showToolBar:">showToolBar: aBoolean	ShowToolBar := aBoolean</body><body package="Tools-Workspace" selector="useMultiPageWorkspaces">useMultiPageWorkspaces	^UseMultiPageWorkspaces</body><body package="Tools-Workspace" selector="useMultiPageWorkspaces:">useMultiPageWorkspaces: aBoolean	UseMultiPageWorkspaces := aBoolean</body></methods><methods><class-id>Tools.Workbook</class-id> <category>actions</category><body package="Tools-Workspace" selector="fileNew">fileNew	self addAndSelectPage: (WorkspacePage labeled: self pickUniquePageLabel)</body><body package="Tools-Workspace" selector="fileOpen">fileOpen	| nameString |	nameString := Dialog requestFileName: (#OpenFileNamedColon &lt;&lt; #dialogs &gt;&gt; 'Open file named: ') default: '*.ws'.	nameString isEmpty ifTrue: [^self].	self addAndSelectPage: (WorkspacePage filename: nameString asFilename)</body><body package="Tools-Workspace" selector="pageClose">pageClose	self canClosePage ifFalse: [self error: (#errCannotCloseThisPage &lt;&lt; #dialogs &gt;&gt; 'cannot close this page')].	self currentTextPage changeRequest ifFalse: [^self].	self removePage: self currentTextPage</body><body package="Tools-Workspace" selector="pageRename">pageRename	| newLabel current |	self canRenamePage ifFalse: [self error: (#errCannotRenameThisPage &lt;&lt; #dialogs &gt;&gt; 'cannot rename this page')].	current := self currentPage.	newLabel := Dialog 		request: (#RenameThisPageAsColon &lt;&lt; #dialogs &gt;&gt; 'Rename this page as:') 		initialAnswer: current label.	newLabel isEmpty ifTrue: [^self].	current label: newLabel.	self pages changed: #at: with: self pageHolder selectionIndex</body><body package="Tools-Workspace" selector="pageTearOff">pageTearOff	"Remove the current text page from the workbook and open it	as a separate workspace (not a workbook). If this was the last text	page, close the current workbook. The new window should have	reasonable size and position--that is same size as the original workbook	and either same or cascaded position, depending on whether the	workbook stays or goes. With the MPUI introduction, if the original window	is closed, it should be done *after* opening the new one."	| thisPage workspace bounds wasLastPage |	bounds := self builder window displayBox.	thisPage := self currentTextPage.	thisPage deactivate.	workspace := Workspace new textPage: thisPage.	locals keysAndValuesDo:		[:key :value | workspace addLocal: key value: value].	wasLastPage := self textPageCount &lt;= 1.	wasLastPage ifFalse:		[self removePage: thisPage.		bounds := Screen default makeRectangleVisible:			(bounds copy moveBy: 20@20)].	workspace 		allButOpenInterface: #windowSpec;		finallyOpenIn: bounds withType: #normal.	wasLastPage ifTrue:		[self builder window controller closeAndUnschedule]</body></methods><methods><class-id>Tools.Workbook</class-id> <category>private-pages</category><body package="Tools-Workspace" selector="currentPage">currentPage	^lastInstalledPage</body><body package="Tools-Workspace" selector="currentTextPage">currentTextPage	self isAtTextPage ifFalse: [self error: (#errNotAtTextPage &lt;&lt; #dialogs &gt;&gt; 'not at text page')].	^self currentPage</body><body package="Tools-Workspace" selector="installPage:">installPage: aWorkspacePage	lastInstalledPage := aWorkspacePage.	aWorkspacePage builder: nil.	self tabControl		client: aWorkspacePage		spec: #windowSpec		builder: builder newSubBuilder.	self updatePage.	aWorkspacePage refresh</body><body package="Tools-Workspace" selector="isAtTextPage">isAtTextPage	"Text pages are all pages except the last."	^self pageHolder selectionIndex &lt; self pageHolder list size</body><body package="Tools-Workspace" selector="textPageCount">textPageCount	"One of the pages is the Variables page; all others are text."	^self pages size - 1</body></methods><methods><class-id>Tools.Workbook</class-id> <category>private</category><body package="Tools-Workspace" selector="hibernate">hibernate	self pageHolder selectionIndex: 0</body><body package="Tools-Workspace" selector="pickUniquePageLabel">pickUniquePageLabel	| labels suffix label |	labels := self pages collect: [:each | each displayString].	suffix := 1.	[label := ((#Page1s &lt;&lt; #dialogs &gt;&gt; 'Page &lt;1s&gt;')			expandMacrosWith: suffix printString).	labels includes: label] 		whileTrue: [suffix := suffix + 1].	^label</body><body package="Tools-Workspace" selector="reInstallInterface">reInstallInterface	"It is suspicious that the selection is not preserved while	rebuilding, but for now let's just work around it."	| pageIndex |	pageIndex := self pageHolder selectionIndex.	super reInstallInterface.	self pageHolder selectionIndex: pageIndex</body><body package="Tools-Workspace" selector="suggestSaving:">suggestSaving: pageCollection	| messageStream wordsOnThisLine |	messageStream := (String new: 100) writeStream.	wordsOnThisLine := 1.	messageStream nextPutAll: (#SomePagesNeedSaved &lt;&lt; #dialogs &gt;&gt; 'The following pages have unsaved changes:') asString; cr.	pageCollection 		do: [:each | 			wordsOnThisLine &gt; 5 ifTrue:				[messageStream cr.				wordsOnThisLine := 0].			wordsOnThisLine := wordsOnThisLine + 1.			messageStream 				nextPut: $"; 				nextPutAll: each displayString;				nextPut: $"]		separatedBy: [messageStream nextPutAll: ', '].	messageStream nextPutAll: '.'; cr; nextPutAll: (#SaveChangesBeforeClosing &lt;&lt; #dialogs &gt;&gt; 'Save changes before closing the window?') asString.	^Dialog 		choose: messageStream contents		labels: (Array with: (#Yes &lt;&lt; #dialogs &gt;&gt; 'Yes') with: (#No &lt;&lt; #dialogs &gt;&gt; 'No') with: (#Cancel &lt;&lt; #dialogs &gt;&gt; 'Cancel'))		values: #(yes no cancel)		default: #yes</body><body package="Tools-Workspace" selector="tabControl">tabControl	^(builder componentAt: #pages) widget</body><body package="Tools-Workspace" selector="updatePage">updatePage	"Page-related things such as labels may have changed for the current page."	super updatePage.	self pages changed: #at: with: self pageHolder selectionIndex</body></methods><methods><class-id>Tools.Workbook</class-id> <category>initialize-release</category><body package="Tools-Workspace" selector="initialize">initialize	super initialize.	self pageHolder		list: (List 			with: ((WorkspacePage labeled: (#Page1 &lt;&lt; #dialogs &gt;&gt; 'Page 1')) workspace: self)			with: (WorkspaceInspectorPage withInspectorOn: locals))</body><body package="Tools-Workspace" selector="postBuildWith:">postBuildWith: aBuilder	super postBuildWith: aBuilder.	(builder componentAt: #pages) component layout		bottomOffset: [self clientAreaBottomOffset].	(builder componentAt: #pageExplanation) component layout		topOffset: [self clientAreaBottomOffset].	(builder componentAt: #importSummary) component layout		topOffset: [self clientAreaBottomOffset].	self pageHolder selectionIndexHolder		onChangeSend: #pageChanged to: self</body><body package="Tools-Workspace" selector="postOpenWith:">postOpenWith: aBuilder	super postOpenWith: aBuilder.	self pageHolder selection: self pageHolder list first</body></methods><methods><class-id>Tools.Workbook</class-id> <category>aspects</category><body package="Tools-Workspace" selector="pageHolder">pageHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^pageHolder isNil		ifTrue:			[pageHolder := SelectionInList new]		ifFalse:			[pageHolder]</body></methods><methods><class-id>Tools.Workbook</class-id> <category>accessing</category><body package="Tools-Workspace" selector="addAndSelectPage:">addAndSelectPage: aWorkspacePage	self addPage: aWorkspacePage.	self pageHolder selection: aWorkspacePage</body><body package="Tools-Workspace" selector="addPage:">addPage: aWorkspacePage	"The Variables page always remains the last, so any new page	always ends up being one before the last."	| inspectorPage |	inspectorPage := self pages last.	aWorkspacePage workspace: self.	self pages add: aWorkspacePage before: inspectorPage</body><body package="Tools-Workspace" selector="changeRequest">changeRequest	| unsaved choice |	unsaved := self pages reject: [:some | some isAccepted].	unsaved isEmpty ifTrue: [^true].	choice := self suggestSaving: unsaved.	choice = #no ifTrue: [^true].	choice = #cancel ifTrue: [^false].	"The choice is #yes, i.e. save all"	unsaved do: [:each | each saveIntoFile ifFalse: [^false]].	^true</body><body package="Tools-Workspace" selector="pageChanged">pageChanged	| selection |	selection := self pageHolder selection.	lastInstalledPage notNil ifTrue:		[lastInstalledPage deactivate.		lastInstalledPage := nil].	selection isNil ifTrue: [^self].	self installPage: selection</body><body package="Tools-Workspace" selector="pages">pages	^self pageHolder list</body><body package="Tools-Workspace" selector="removePage:">removePage: aWorkspacePage	self pages remove: aWorkspacePage</body><body package="Tools-Workspace" selector="replaceAllTextPagesWith:">replaceAllTextPagesWith: aPage	| inspectorPage removed |	inspectorPage := self pages last.	aPage workspace: self.	removed := self pages removeAllSuchThat: [:page | page ~~ inspectorPage].	removed do: [:each | each release].	self pages addFirst: aPage</body><body package="Tools-Workspace" selector="selectPageLabeled:">selectPageLabeled: userMessageOrString	self pageHolder selection: 		(self pages 			detect: [:aPage | aPage label asString = userMessageOrString asString]			ifNone: [^self])</body><body package="Tools-Workspace" selector="selectPageNumber:">selectPageNumber: index	self pageHolder selectionIndex: index</body></methods><methods><class-id>Tools.Workbook</class-id> <category>private-testing</category><body package="Tools-Workspace" selector="canClosePage">canClosePage	^self isAtTextPage and: [self textPageCount &gt; 1]</body><body package="Tools-Workspace" selector="canRenamePage">canRenamePage	^self isAtTextPage</body><body package="Tools-Workspace" selector="canUndo">canUndo	^self isAtTextPage or: [self currentPage canUndo]</body></methods><methods><class-id>Tools.Workbook class</class-id> <category>examples</category><body package="Tools-Workspace" selector="example1">example1	"Here is how to open a workbook with pages containing text."	"self example1"	| book |	book := Workbook new.	book 		replaceAllTextPagesWith: "also get rid of the default 'Page 1'"			(WorkspacePage 				labeled: 'example1' 				with: (self class compiledMethodAt: #example1) getSource);		addAndSelectPage: "now add more pages"			(WorkspacePage				labeled: 'example2'				with: (self class compiledMethodAt: #example2) getSource).	book open</body><body package="Tools-Workspace" selector="example2">example2	"Here is how to open a workbook with pages containing text from files."	"self example2"	| book |	book := Workbook new.	book replaceAllTextPagesWith:		(WorkspacePage filename: 'visual.cha' asFilename).	book open</body></methods><methods><class-id>Tools.Workbook class</class-id> <category>instance creation</category><body package="Tools-Workspace" selector="on:">on: aValueModel	"Create a new workbook with a single text page	that has aString as the label and aValueModel as the contents holder."	| book |	book := self new.	book replaceAllTextPagesWith: (WorkspacePage on: aValueModel).	^book</body><body package="Tools-Workspace" selector="on:labeled:">on: aValueModel labeled: aString	"Create a new workbook with a single text page	that has aString as the label and aValueModel as the contents holder."	| book |	book := self new.	book replaceAllTextPagesWith:		(WorkspacePage labeled: aString on: aValueModel).	^book</body><body package="Tools-Workspace" selector="with:">with: aText	"Create a new workbook with a single text page	that has aString as the label and aText as the contents."	| book |	book := self new.	book replaceAllTextPagesWith: (WorkspacePage with: aText).	^book</body><body package="Tools-Workspace" selector="with:labeled:">with: aText labeled: aString	"Create a new workbook with a single text page	that has aString as the label and aText as the contents."	| book |	book := self new.	book replaceAllTextPagesWith: 		(WorkspacePage labeled: aString with: aText).	^book</body><body package="Tools-Workspace" selector="withFile:ifAbsent:">withFile: aFilenameOrString ifAbsent: aBlock	"Create a new workbook with text from the specified file.	If the file does not exist, create a workbook anyway with a	page associated with that non-existent file, and with the result	of evaluating aBlock (expected to be a String or a Text) as	the initial contents."	| book page |	book := self new.	page := [WorkspacePage filename: aFilenameOrString]		on: OsError		do: [:ex | ex return:			(WorkspacePage 				filename: aFilenameOrString 				contents: aBlock value)].	book replaceAllTextPagesWith: page.	^book</body></methods><methods><class-id>Tools.Workbook class</class-id> <category>system workbooks</category><body package="Tools-Workspace" selector="openSystemWorkbook">openSystemWorkbook	^self systemWorkbook open</body><body package="Tools-Workspace" selector="systemWorkbook">systemWorkbook	^Workbook new		replaceAllTextPagesWith: WorkspacePage installationWorkspacePage;		addPage: WorkspacePage systemWorkspacePage;		yourself</body></methods><methods><class-id>Tools.WorkspaceImportsDialog</class-id> <category>private</category><body package="Tools-Workspace" selector="allNameSpaces">allNameSpaces	^Root withAllNameSpaces asSortedCollection:		[:a :b | a fullName &lt; b fullName]</body><body package="Tools-Workspace" selector="importTypeChanged">importTypeChanged	(builder componentAt: #namespaces) isEnabled: self importAllHolder value not</body></methods><methods><class-id>Tools.WorkspaceImportsDialog</class-id> <category>accessing</category><body package="Tools-Workspace" selector="importAll">importAll	^self importAllHolder value</body><body package="Tools-Workspace" selector="specificImports">specificImports	^self namespaces selections</body></methods><methods><class-id>Tools.WorkspaceImportsDialog</class-id> <category>aspects</category><body package="Tools-Workspace" selector="importAllHolder">importAllHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^importAllHolder isNil		ifTrue:			[importAllHolder := nil asValue]		ifFalse:			[importAllHolder]</body><body package="Tools-Workspace" selector="namespaces">namespaces	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^namespaces isNil		ifTrue:			[namespaces := MultiSelectionInList new]		ifFalse:			[namespaces]</body></methods><methods><class-id>Tools.WorkspaceImportsDialog</class-id> <category>initialize-release</category><body package="Tools-Workspace" selector="initializeImportAll:specific:">initializeImportAll: aBoolean specific: namespaceCollection	self namespaces list: self allNameSpaces.	self importAllHolder value: aBoolean.	self namespaces selections: namespaceCollection</body><body package="Tools-Workspace" selector="postBuildWith:">postBuildWith: aBuilder	self importAllHolder		onChangeSend: #importTypeChanged		to: self.	self importTypeChanged</body></methods><methods><class-id>Tools.WorkspaceCompilerErrorHandler</class-id> <category>initialize-release</category><body package="Tools-Workspace" selector="workspace:">workspace: aWorkspace	workspace := aWorkspace</body></methods><methods><class-id>Tools.WorkspaceCompilerErrorHandler</class-id> <category>private-undeclared variables</category><body package="Tools-Workspace" selector="declareGlobal:from:">declareGlobal: assoc from: codeStream	"Change the association's key from (possibly) a String to a Symbol,	then add that association to Smalltalk (as opposed to the superclass	adding it to the current environment)."	| name |	name := SystemUtils			validateStaticVariableName: assoc key			confirm: [:msg :vname | Dialog confirm: msg for: editor view]			warn: [:msg | Dialog warn: msg for: editor view].	name == nil ifTrue: [^self abort].	name asString = assoc key asString		ifFalse:			[self replaceEditSelectionWith: name].	assoc key: name.	Smalltalk		defineSharedVariable: assoc key		private: false		constant: false		category: #'Workspace Globals'		initializer: nil.	(Smalltalk bindingFor: assoc key) value: assoc value.	^true  "retry"</body><body package="Tools-Workspace" selector="declareWorkspaceVar:from:">declareWorkspaceVar: assoc from: codeStream	"Change the association's key from (possibly) a String to a Symbol,	then add that association to the pool of workspace variables."	assoc key: assoc key asSymbol.	workspace doItEnvironment simpleAddBinding: assoc.	(workspace doItEnvironment bindingFor: assoc key)		value: assoc value.	^true  "retry"</body><body package="Tools-Workspace" selector="undeclaredVariableTypes">undeclaredVariableTypes	^super undeclaredVariableTypes		addFirst: #Workspace &lt;&lt; #dialogs &gt;&gt; 'Workspace' -&gt; #declareWorkspaceVar:from:;		yourself</body></methods><methods><class-id>Tools.WorkspaceCompilerErrorHandler</class-id> <category>interaction</category><body package="Tools-Workspace" selector="undeclaredStore:in:from:">undeclaredStore: association in: assignNode from: codeStream	self class silentlyDeclareVariables		ifTrue: [^self declareWorkspaceVar: association from: codeStream].	^super undeclaredStore: association in: assignNode from: codeStream</body></methods><methods><class-id>Tools.WorkspaceCompilerErrorHandler class</class-id> <category>accessing</category><body package="Tools-Workspace" selector="silentlyDeclareVariables">silentlyDeclareVariables		^SilentlyDeclareVariables</body><body package="Tools-Workspace" selector="silentlyDeclareVariables:">silentlyDeclareVariables: aBoolean		SilentlyDeclareVariables := aBoolean</body></methods><methods><class-id>Tools.WorkspaceVariablePool</class-id> <category>initialize-release</category><body package="Tools-Workspace" selector="initialize:">initialize: aWorkspace	workspace := aWorkspace</body></methods><methods><class-id>Tools.WorkspaceVariablePool</class-id> <category>accessing</category><body package="Tools-Workspace" selector="updateImports">updateImports	self importsObjects: 		(workspace imports collect: 			[:each | 	GeneralNameSpaceImport pathString: each fullName])</body><body package="Tools-Workspace" selector="workspace">workspace	^workspace</body></methods><methods><class-id>Tools.WorkspaceVariablePool</class-id> <category>collection accessing</category><body package="Tools-Workspace" selector="removeKey:ifAbsent:">removeKey: key ifAbsent: aBlock	| bind |	bind := bindings lookup: key.	^bind == nil		ifTrue: [aBlock value]		ifFalse: [self simpleRemoveKey: key]</body></methods><methods><class-id>Tools.WorkspaceInspectorPage</class-id> <category>private</category><body package="Tools-Workspace" selector="exportSelections">exportSelections	| parts |	parts := inspector selections.	^parts collect: [:each | each key -&gt; each value]</body><body package="Tools-Workspace" selector="workspace">workspace	^self builder window application</body></methods><methods><class-id>Tools.WorkspaceInspectorPage</class-id> <category>testing</category><body package="Tools-Workspace" selector="canBOSSObjects">canBOSSObjects	^#{BinaryObjectStorage} isDefined</body><body package="Tools-Workspace" selector="canUndo">canUndo	^inspector canUndo</body><body package="Tools-Workspace" selector="isAccepted">isAccepted	^true</body></methods><methods><class-id>Tools.WorkspaceInspectorPage</class-id> <category>actions</category><body package="Tools-Workspace" selector="bossIn">bossIn	"This message can only be sent when BOSS is loaded so it is OK	to assume it is.  Still, we avoid a hard reference to it, in case it isn't loaded."	| nameString boss stream objects |	nameString := Dialog 		requestFileNameWithMessage: (#BOSSInFromC &lt;&lt; #dialogs &gt;&gt; 'BOSS In From:') 		default: '*.bos'		version: #mustBeOld		ifFail: ['']		for: nil.	nameString isEmpty ifTrue: [^self].	stream := nameString asFilename readStream.	[boss := #{BinaryObjectStorage} value onOldNoScan: stream.	objects := boss next] 		ensure: [stream close].	((objects isKindOf: SequenceableCollection) not			or: [objects contains: [:some | (some isKindOf: Association) not]])		ifTrue: [self error: (#FileDoesNotContainVariables &lt;&lt; #dialogs &gt;&gt; 'The object does not look like a saved variable collection')]		ifFalse: [self workspace addAllToLocalsQuietly: objects].	inspector refresh; selectAll</body><body package="Tools-Workspace" selector="bossOut">bossOut	"This message can only be sent when BOSS is loaded so it is OK	to assume it is.  Still, we avoid a hard reference to it, in case it isn't loaded."	| nameString boss stream objects |	inspector hasSelection ifFalse: [inspector selectAll].	nameString := Dialog 		requestFileNameWithMessage: (#BOSSOutToC &lt;&lt; #dialogs &gt;&gt; 'BOSS Out To:') 		default: 'objects.bos'		version: #new		ifFail: ['']		for: nil.	nameString isEmpty ifTrue: [^self].	objects := self exportSelections.	stream := nameString asFilename writeStream.	[boss := #{BinaryObjectStorage} value onNew: stream.	boss nextPut: objects] 		ensure: [stream close]</body><body package="Tools-Workspace" selector="copySelection">copySelection	^inspector copySelection</body><body package="Tools-Workspace" selector="cut">cut	"There is no real cut in the inspector."	^inspector 		copySelection; 		removeSelected</body><body package="Tools-Workspace" selector="debugIt">debugIt	self textEditor debugIt</body><body package="Tools-Workspace" selector="doIt">doIt	self textEditor doIt</body><body package="Tools-Workspace" selector="fileItIn">fileItIn	self textEditor fileItIn</body><body package="Tools-Workspace" selector="find">find	self textEditor find</body><body package="Tools-Workspace" selector="inspectIt">inspectIt	self textEditor inspectIt</body><body package="Tools-Workspace" selector="paste">paste	^inspector paste</body><body package="Tools-Workspace" selector="printIt">printIt	self textEditor printIt</body><body package="Tools-Workspace" selector="refresh">refresh	inspector refresh; selectAll</body><body package="Tools-Workspace" selector="replace">replace	self textEditor replace</body><body package="Tools-Workspace" selector="selectAll">selectAll	^inspector selectAll</body><body package="Tools-Workspace" selector="textEditor">textEditor	^(inspector builder componentAt: #text) widget controller</body><body package="Tools-Workspace" selector="undo">undo	^inspector undo</body></methods><methods><class-id>Tools.WorkspaceInspectorPage</class-id> <category>accessing</category><body package="Tools-Workspace" selector="changeRequest">changeRequest	"An inspector is unlikely to contain anything worthwhile, so closing	is always OK."	^true</body><body package="Tools-Workspace" selector="displayString">displayString	^self label</body><body package="Tools-Workspace" selector="label">label	^(#Variables &lt;&lt; #labels &gt;&gt; 'Variables') asString</body><body package="Tools-Workspace" selector="verboseLabel">verboseLabel	^(#WorkspaceLocalVariables &lt;&lt; #labels &gt;&gt; 'Workspace local variables') asString</body></methods><methods><class-id>Tools.WorkspaceInspectorPage</class-id> <category>privileged</category><body package="Tools-Workspace" selector="deactivate">deactivate	"About to switch from this page to another one. Unselect	everything so everything gets re-selected when we come back.	Flush the history so that we don't quietly hang onto large things.	This is important in workspaces, since they are more permanent	than inspectors."	inspector 		flushUndoHistory;		select: nil</body></methods><methods><class-id>Tools.WorkspacePage</class-id> <category>actions</category><body package="Tools-Workspace" selector="dragEntry:">dragEntry: aDragContext	^(#(inspectorObject inspectorObjects) includes: aDragContext data key)		ifTrue: [#dropEffectCopy]		ifFalse: [#dropEffectNone]</body><body package="Tools-Workspace" selector="dragOver:">dragOver: aDragContext	^(#(inspectorObject inspectorObjects) includes: aDragContext data key)		ifTrue: [#dropEffectCopy]		ifFalse: [#dropEffectNone]</body><body package="Tools-Workspace" selector="drop:">drop: aDragContext	#inspectorObject == aDragContext data key ifTrue:		[self workspace addAllToLocals: aDragContext data clientData.		^#dropEffectCopy].	^#dropEffectNone</body><body package="Tools-Workspace" selector="fileItIn">fileItIn	self textEditor fileItIn</body><body package="Tools-Workspace" selector="maybeSaveIfCancel:">maybeSaveIfCancel: aBlock	"If the page has unsaved changes, suggest the user to save them	using the usual Yes-No-Cancel dialog.  Answer a Boolean indicating 	whether it is OK to close the window."	| reply |	self textEditor accepted ifFalse:		[reply := Dialog choose: (#SaveChanges &lt;&lt; #dialogs &gt;&gt; 'Save changes?')					labels: (Array with: (#Yes &lt;&lt; #dialogs &gt;&gt; 'Yes') with: (#No &lt;&lt; #dialogs &gt;&gt; 'No') with: (#Cancel &lt;&lt; #dialogs &gt;&gt; 'Cancel')) 					values: #(yes no cancel)					default: #yes.		#cancel == reply ifTrue: [^aBlock value].		#yes == reply ifTrue: [^self saveIntoFile]].	^true</body><body package="Tools-Workspace" selector="requestFileNameAndSave">requestFileNameAndSave	| newName |	newName := Dialog 		requestNewFileName: (#SaveWorkspaceToFileColon &lt;&lt; #dialogs &gt;&gt; 'Save the workspace to file:') 		default: self suggestFileName.	newName isEmpty ifTrue: [^false].	self filename: newName asLogicalFileSpecification.	^self acceptText</body><body package="Tools-Workspace" selector="saveIntoFile">saveIntoFile	"Save the contents into a file.  Prompt for a filename if needed.	Answer true if saved successfully, false otherwise."	^filename isNil 		ifTrue: [self requestFileNameAndSave]		ifFalse: [self acceptText]</body></methods><methods><class-id>Tools.WorkspacePage</class-id> <category>privileged</category><body package="Tools-Workspace" selector="changeRequest">changeRequest	"If a page's builder is nil, it has no editor yet. But it also means	it hasn't been open yet and has no changes to lose."	^self builder isNil		or: [self textEditor accepted		or: [self maybeSaveIfCancel: [^false]]]</body><body package="Tools-Workspace" selector="deactivate">deactivate	"Sent by the container application just before switching from this page	to another one. Controller text is preserved to be reinstalled as unaccepted 	when the page is rebuilt later."	| editor |	editor := self textEditor.	editor accepted ifFalse:		[unacceptedText := editor text.		savedFileTimestamp := fileTimestamp.		savedSelection := Array 			with: editor selectionStartIndex 			with: editor selectionStopIndex]</body><body package="Tools-Workspace" selector="encodingChanged">encodingChanged	(self hasUnsavedChanges and: [self okToRereadFile not]) 		ifTrue: [^self].	builder ifNotNil: [self textEditor cancel]</body><body package="Tools-Workspace" selector="giveFocusToEditor">giveFocusToEditor	(self builder componentAt: #text) takeKeyboardFocus</body><body package="Tools-Workspace" selector="refresh">refresh	"Refresh is sent as soon as the page becomes current again."	unacceptedText notNil ifTrue:		[self restoreUnacceptedText.		unacceptedText := nil].	builder window isOpen ifTrue:		[(builder componentAt: #text) takeKeyboardFocus]</body><body package="Tools-Workspace" selector="testFileLoading">testFileLoading	self readText</body></methods><methods><class-id>Tools.WorkspacePage</class-id> <category>accessing</category><body package="Tools-Workspace" selector="displayString">displayString	^self label asString</body><body package="Tools-Workspace" selector="doItEnvironment">doItEnvironment	^self workspace doItEnvironment</body><body package="Tools-Workspace" selector="doItHandler">doItHandler	^self workspace doItHandler</body><body package="Tools-Workspace" selector="doItReceiver">doItReceiver	^self workspace doItReceiver</body><body package="Tools-Workspace" selector="label">label	^label</body><body package="Tools-Workspace" selector="label:">label: aString	label := aString</body><body package="Tools-Workspace" selector="verboseLabel">verboseLabel	^verboseLabel notNil		ifTrue: [verboseLabel]		ifFalse: [filename isNil			ifTrue: [(#TextOrSmalltalkCode &lt;&lt; #labels &gt;&gt; 'Text or Smalltalk code') asString]			ifFalse: [filename asString]]</body><body package="Tools-Workspace" selector="verboseLabel:">verboseLabel: aStringOrNil	verboseLabel := aStringOrNil.	workspace updatePage</body><body package="Tools-Workspace" selector="workspace">workspace	^workspace</body><body package="Tools-Workspace" selector="workspace:">workspace: aWorkspace	workspace encodingChannel retractInterestsFor: self.	workspace := aWorkspace.	workspace encodingChannel onChangeSend: #encodingChanged to: self</body></methods><methods><class-id>Tools.WorkspacePage</class-id> <category>private</category><body package="Tools-Workspace" selector="acceptText">acceptText	self textEditor accept.	^true</body><body package="Tools-Workspace" selector="compareTextWithFile">compareTextWithFile	"Open a Differator on the text currently on the page (on the left) and the text from the file on the right."	| text fileText |	text := self textEditor text copy.	fileText := [self filenameWithEncoding contentsOfEntireFile]		on: OsError do: [:ex | ex return: String new].	(Differator newOn: text and: fileText) open</body><body package="Tools-Workspace" selector="encoding">encoding	^workspace encodingChannel value</body><body package="Tools-Workspace" selector="fileChangedOnDisk">fileChangedOnDisk	"Make sure that the timestamp of the file on the disk has not changed behind our back. If it has, it means the file has been saved into in the meantime (possibly even by us in an unsaved image session). Answer true if it is OK to save the file, false if saving may overwrite existing changes."	^fileTimestamp ~= self fileOnDiskTimestamp</body><body package="Tools-Workspace" selector="filenameWithEncoding">filenameWithEncoding	^filename asFilename withEncoding: self encoding</body><body package="Tools-Workspace" selector="fileOnDiskTimestamp">fileOnDiskTimestamp	filename isNil ifTrue: [^nil].	^[filename modificationTimestamp]		on: OsError		do: [:ex | ex return: nil]</body><body package="Tools-Workspace" selector="hasUnsavedChanges">hasUnsavedChanges	builder isNil ifTrue: [^false].	^self textEditor accepted not</body><body package="Tools-Workspace" selector="okToRereadFile">okToRereadFile	^Dialog 		confirm: (#okToRereadFile &lt;&lt; #labels &gt;&gt; 			'Reread the file using the new encoding?&lt;n&gt;(Unsaved changes will be lost).')				expandMacros		initialAnswer: false</body><body package="Tools-Workspace" selector="rememberFileTimestamp">rememberFileTimestamp	fileTimestamp := self fileOnDiskTimestamp</body><body package="Tools-Workspace" selector="restoreUnacceptedText">restoreUnacceptedText	self textEditor view editText: unacceptedText.	self textEditor		selectionStartIndex: savedSelection first		stopIndex: savedSelection last.	fileTimestamp := savedFileTimestamp.	self textEditor notAccepted</body><body package="Tools-Workspace" selector="suggestFileName">suggestFileName	| labelString |	labelString := label asString.	^(labelString includes: $.)		ifTrue: [labelString]		ifFalse: [labelString, '.ws']</body><body package="Tools-Workspace" selector="textEditor">textEditor	^(builder componentAt: #text) widget controller</body></methods><methods><class-id>Tools.WorkspacePage</class-id> <category>testing</category><body package="Tools-Workspace" selector="canBOSSObjects">canBOSSObjects	^false</body><body package="Tools-Workspace" selector="hasEmphasis">hasEmphasis	| text |	text := self textEditor text.	^(text emphasisAt: 1) notNil or: [text hasChangeOfEmphasis]</body><body package="Tools-Workspace" selector="isAccepted">isAccepted	"If a page's builder is nil, it has no editor yet. But it also means	it hasn't been open yet and has no changes to lose."	^builder isNil or: [self textEditor accepted and: [unacceptedText isNil]]</body></methods><methods><class-id>Tools.WorkspacePage</class-id> <category>initialize-release</category><body package="Tools-Workspace" selector="contents:">contents: aTextOrString	textModelOverride := aTextOrString asValue</body><body package="Tools-Workspace" selector="filename:">filename: aFilename	filename := aFilename.	self rememberFileTimestamp.	aFilename notNil ifTrue: [label := aFilename tail]</body><body package="Tools-Workspace" selector="initialize">initialize	workspace := NoWorkspace new.	label := (#Workspace &lt;&lt; #labels &gt;&gt; 'Workspace').	textModel := (PluggableAdaptor on: self)		getSelector: #text		putSelector: #text:</body><body package="Tools-Workspace" selector="postBuildWith:">postBuildWith: aBuilder	self textEditor		initializeMenuForCodeWithFileItIn;		doNotHandleLocally: #explain;		autoAccept: false</body><body package="Tools-Workspace" selector="postOpenWith:">postOpenWith: aBuilder	(aBuilder componentAt: #text) takeKeyboardFocus</body><body package="Tools-Workspace" selector="preBuildWith:">preBuildWith: aBuilder	super preBuildWith: aBuilder.	aBuilder labelAt: #label put: label</body><body package="Tools-Workspace" selector="release">release	workspace encodingChannel retractInterestsFor: self.	super release</body><body package="Tools-Workspace" selector="textHolder:">textHolder: aValueModel	textModelOverride := aValueModel</body></methods><methods><class-id>Tools.WorkspacePage</class-id> <category>actions-text</category><body package="Tools-Workspace" selector="copySelection">copySelection	self textEditor copySelection</body><body package="Tools-Workspace" selector="cut">cut	self textEditor cut</body><body package="Tools-Workspace" selector="debugIt">debugIt	self textEditor debugIt</body><body package="Tools-Workspace" selector="doIt">doIt	"This method processes menu shortcuts, and Ctrl+D is dispatched here for	both shifted and unshifted keystrokes, which are handled differently by the editor.	We match that here for consistency."	InputState default shiftDown		ifTrue: [self textEditor displayDate]		ifFalse: [self textEditor doIt]</body><body package="Tools-Workspace" selector="explain">explain	self textEditor explainFor: workspace</body><body package="Tools-Workspace" selector="find">find	self textEditor find</body><body package="Tools-Workspace" selector="inspectIt">inspectIt	self textEditor inspectIt</body><body package="Tools-Workspace" selector="paste">paste	self textEditor paste</body><body package="Tools-Workspace" selector="printIt">printIt	self textEditor printIt</body><body package="Tools-Workspace" selector="replace">replace	self textEditor replace</body><body package="Tools-Workspace" selector="selectAll">selectAll	| controller |	controller := self textEditor.	controller selectFrom: 1 to: controller text size</body><body package="Tools-Workspace" selector="undo">undo	self textEditor undo</body></methods><methods><class-id>Tools.WorkspacePage</class-id> <category>private-file access</category><body package="Tools-Workspace" selector="okToSaveTextFrom:">okToSaveTextFrom: aContoller	| choice |	self fileChangedOnDisk ifFalse: [^true].	choice := Dialog 		choose: (#fileChangedByOtherProgram &lt;&lt; #dialogs &gt;&gt; 'The file has been changed on the disk independently from this workspace.Saving may override other changes.  Save anyway?')		labels: (Array with: (#Yes &lt;&lt; #dialogs &gt;&gt; 'Yes') with: (#No &lt;&lt; #dialogs &gt;&gt; 'No') with: (#Compare &lt;&lt; #dialogs &gt;&gt; 'Compare'))		values: #(yes no compare)		default: #no.	choice = #compare ifTrue: [self compareTextWithFile].	^choice = #yes</body><body package="Tools-Workspace" selector="readText">readText	| text |	text := [self filenameWithEncoding contentsOfEntireFile]		on: OsError		do: [:ex | 			ex isNested				ifTrue: [ex pass]				ifFalse: [	^(#cannotReadTheFile &lt;&lt; #dialogs &gt;&gt; '&lt;cannot read the file&gt;') asText emphasizeAllWith: #italic]].	self rememberFileTimestamp.	^text</body><body package="Tools-Workspace" selector="text">text	^textModelOverride notNil 		ifTrue: [textModelOverride value]		ifFalse: [filename notNil			ifTrue: [self readText]			ifFalse: [String new]]</body><body package="Tools-Workspace" selector="text:">text: aText	^filename notNil		ifTrue: [self writeText: aText]		ifFalse: 			[self textHolder value: aText. 			true]</body><body package="Tools-Workspace" selector="writeText:">writeText: aText	| stream |	stream := self filenameWithEncoding writeStream.	[stream nextPutAll: aText] ensure: [stream close].	self rememberFileTimestamp.	textModelOverride := nil</body></methods><methods><class-id>Tools.WorkspacePage</class-id> <category>aspects</category><body package="Tools-Workspace" selector="textHolder">textHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^textModelOverride isNil		ifTrue:			[textModelOverride := String new asValue]		ifFalse:			[textModelOverride]</body><body package="Tools-Workspace" selector="textModel">textModel	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^textModel isNil		ifTrue:			[textModel := String new asValue]		ifFalse:			[textModel]</body></methods><methods><class-id>Tools.WorkspacePage class</class-id> <category>accessing</category><body package="Tools-Workspace" selector="readFrom:">readFrom: aStream	^aStream contents</body></methods><methods><class-id>Tools.WorkspacePage class</class-id> <category>instance creation</category><body package="Tools-Workspace" selector="filename:">filename: aFilenameOrString	"Create a page containing text from the file of the given filename.	The client should be prepared to catch possible OsErrors."	^self new 		filename: aFilenameOrString asLogicalFileSpecification;		testFileLoading;		yourself</body><body package="Tools-Workspace" selector="filename:contents:">filename: aFilename contents: aTextOrString	"Create a page with the given filename (a label is derived from	that filename) and the contents, presumably coming from that file."	^self new		filename: aFilename asLogicalFileSpecification;		contents: aTextOrString;		yourself</body><body package="Tools-Workspace" selector="labeled:">labeled: aString	"Create a new empty page unassociated with any file, with	aString as the label."	^self new label: aString</body><body package="Tools-Workspace" selector="labeled:on:">labeled: aString on: aValueModel	"Create a new page unassociated with any file, using aValueModel	to hold the text being edited."	^self new 		label: aString;		textHolder: aValueModel;		yourself</body><body package="Tools-Workspace" selector="labeled:with:">labeled: aString with: aText	"Create a new page unassociated with any file, with aString	as the label and aText as the initial contents."	^self new 		label: aString;		contents: aText;		yourself</body><body package="Tools-Workspace" selector="on:">on: aValueModel	"Create a new page unassociated with any file, using aValueModel	to hold the text being edited."	^self new 		textHolder: aValueModel;		yourself</body><body package="Tools-Workspace" selector="on:labeled:">on: aValueModel labeled: aString	^self labeled: aString on: aValueModel</body><body package="Tools-Workspace" selector="with:">with: aText	"Create a new page unassociated with any file, with aString	as the label and aText as the initial contents."	^self new 		contents: aText;		yourself</body><body package="Tools-Workspace" selector="with:labeled:">with: aText labeled: aString	^self labeled: aString with: aText</body></methods><methods><class-id>Tools.WorkspacePage class</class-id> <category>window opening</category><body package="Tools-Workspace" selector="open">open	^self new open</body><body package="Tools-Workspace" selector="openOnHolder:">openOnHolder: aValueModel	"Open a new workspace with a text holder as the content holder."	"self openOnHolder: 'Hello world' asValue"	^(self on: aValueModel) open</body><body package="Tools-Workspace" selector="openOnHolder:labeled:">openOnHolder: aValueModel labeled: aString	"Open a new workspace with a text holder as the content holder."	"self openOnHolder: 'Hello world' asValue labeled: 'Example' "	^(self labeled: aString on: aValueModel) open</body><body package="Tools-Workspace" selector="openWith:">openWith: aString	"Open a new workspace with aString as the initial contents."	"self openWith: 'Hello world'"	^(self with: aString) open</body><body package="Tools-Workspace" selector="openWith:labeled:">openWith: aString labeled: labelString	"Open a new workspace with aString as the initial contents."	"self openWith: 'Hello world' labeled: 'Example' "	^(self labeled: labelString with: aString) open</body></methods><methods><class-id>Tools.WorkspacePage class</class-id> <category>system workpages</category><body package="Tools-Workspace" selector="cautiousAdaptorOn:">cautiousAdaptorOn: aValueModel	| confirmMessage |	confirmMessage := #confirmChangeSystemWorkspaceContent &lt;&lt; #dialogs &gt;&gt;		'About to change the workspace content saved in this image. Are you sure?'.	^(PluggableAdaptor on: aValueModel)		getBlock: [:m | m value]		putBlock: [:m :v | 			(Dialog confirm: confirmMessage) 				ifTrue: [m value: v]]		updateBlock: [:m :a :p | true]</body><body package="Tools-Workspace" selector="installationWorkspacePage">installationWorkspacePage	^WorkspacePage 		labeled: (#installationWorkspace &lt;&lt; #labels &gt;&gt; 'Installation Workspace')		on: (self cautiousAdaptorOn: ComposedTextView.InstallationWorkspace)</body><body package="Tools-Workspace" selector="systemWorkspacePage">systemWorkspacePage	^WorkspacePage		labeled: (#systemWorkspace &lt;&lt; #labels &gt;&gt; 'System Workspace')		on: (self cautiousAdaptorOn: ComposedTextView.SystemWorkspace)</body></methods><methods><class-id>Tools.WorkspacePage class</class-id> <category>encodings menu</category><body package="Tools-Workspace" selector="addDefaultAndSourceEncodingsTo:for:">addDefaultAndSourceEncodingsTo: aMenu for: aValueModel	| encodingKey |	encodingKey := (StreamEncoder lookupEncoderDirectory: #default) streamEncodingType asString.	aMenu addItem:		(self 			buildEncodingItem: ((#defaultEncoding &lt;&lt; #menus &gt;&gt; 'Default (&lt;1s&gt;)') expandMacrosWith: encodingKey)			key: #default			for: aValueModel).	encodingKey := (StreamEncoder lookupEncoderDirectory: #Source) streamEncodingType asString.	aMenu addItem:		(self 			buildEncodingItem: ((#sourceEncoding &lt;&lt; #menus &gt;&gt; 'Source (&lt;1s&gt;)') expandMacrosWith: encodingKey)			key: #Source			for: aValueModel)</body><body package="Tools-Workspace" selector="addLineTo:">addLineTo: aMenu	aMenu addLine</body><body package="Tools-Workspace" selector="addOtherItemTo:for:">addOtherItemTo: aMenu for: aValueModel	| item |	item := MenuItem labeled: (#otherEllipsis &lt;&lt; #menus &gt;&gt; 'Other...') asString.	item value: [self chooseEncodingFor: aValueModel].	aMenu addItem: item</body><body package="Tools-Workspace" selector="addPopularEncodingsTo:for:">addPopularEncodingsTo: aMenu for: aValueModel	| encodings |	encodings := self sortedPopularEncodings.	(encodings includes: aValueModel value)		ifFalse: [encodings add: aValueModel value].	encodings do:		[:key |		(#(default Source) includes: key) ifFalse:			[aMenu addItem: (self buildEncodingItem: key asString key: key for: aValueModel)]].</body><body package="Tools-Workspace" selector="buildEncodingItem:key:for:">buildEncodingItem: labelString key: aSymbol for: aValueModel	^(MenuItem labeled: labelString)		indication: [aValueModel value = aSymbol];		value: [aValueModel value: aSymbol];		yourself</body><body package="Tools-Workspace" selector="buildEncodingMenuFor:">buildEncodingMenuFor: aValueModel	| menu |	menu := Menu new.	self 		addDefaultAndSourceEncodingsTo: menu for: aValueModel;		addLineTo: menu;		addPopularEncodingsTo: menu for: aValueModel;		addLineTo: menu;		addOtherItemTo: menu for: aValueModel.	^menu</body><body package="Tools-Workspace" selector="chooseEncodingFor:">chooseEncodingFor: aValueModel	| encodings choice |	encodings := StreamEncoder availableEncodings asSet.	encodings 		remove: #Source ifAbsent: [];		remove: #default ifAbsent: [].	encodings := encodings asSortedStrings.	choice := Dialog 		choose: (#selectEncoding &lt;&lt; #dialogs &gt;&gt; 'Select Encoding')		fromList: encodings values: encodings lines: 20 cancel: [nil].	choice notNil ifTrue:		[aValueModel value: choice.		self rememberPopularEncoding: choice]</body><body package="Tools-Workspace" selector="forgetPopularEncodings">forgetPopularEncodings	"self forgetPopularEncodings"	PopularEncodings := OrderedCollection new</body><body package="Tools-Workspace" selector="maximumEncodingsToRemember">maximumEncodingsToRemember	^8</body><body package="Tools-Workspace" selector="rememberPopularEncoding:">rememberPopularEncoding: aSymbol	(#(default Source) includes: aSymbol) ifFalse:		[PopularEncodings remove: aSymbol ifAbsent: [].		PopularEncodings addFirst: aSymbol.		[PopularEncodings size &gt; self maximumEncodingsToRemember]			whileTrue: [PopularEncodings removeLast]]</body><body package="Tools-Workspace" selector="sortedPopularEncodings">sortedPopularEncodings	^PopularEncodings asSortedStrings</body></methods><methods><class-id>Tools.WorkspacePage class</class-id> <category>examples</category><body package="Tools-Workspace" selector="example1">example1	"A standalone workspace page can be used as a replacement of	SimpleWorkspace. Thanks to Terry Raymond for the idea."	"self example1"	(WorkspacePage new		textHolder: (#initialText &lt;&lt; #examples &gt;&gt; 'initial text') asString asValue;		label: (#PrimitiveWorkspaceExample &lt;&lt; #examples &gt;&gt; 'Primitive workspace example');		yourself) open</body></methods><methods><class-id>Tools.Workspace</class-id> <category>actions</category><body package="Tools-Workspace" selector="fileNew">fileNew	self showTextPage.	self currentPage maybeSaveIfCancel: [^self].	textPage := WorkspacePage new.	self installPage: textPage</body><body package="Tools-Workspace" selector="fileOpen">fileOpen	| nameString |	self showTextPage.	self currentPage maybeSaveIfCancel: [^self].	nameString := Dialog requestFileName: (#OpenFileNamedColon &lt;&lt; #dialogs &gt;&gt; 'Open file named: ') default: '*.ws'.	nameString isEmpty ifTrue: [^self].	textPage := WorkspacePage filename: nameString asFilename.	self installPage: textPage</body><body package="Tools-Workspace" selector="mutateToWorkbook">mutateToWorkbook	"Replace this workspace window with a workbook with a single text page.	The workbook should occupy the same position on the screen as the original	window."	| book bounds |	book := Workbook new.	textPage deactivate.	book replaceAllTextPagesWith: textPage.	locals keysAndValuesDo:		[:key :value | book addLocal: key value: value].	bounds := self builder window displayBox.	"Opening the new window and THEN closing the old eliminates screen flicker."	book 		allButOpenInterface: #windowSpec;		finallyOpenIn: bounds withType: #normal.	self builder window controller closeAndUnschedule. "bypass changeRequest"</body><body package="Tools-Workspace" selector="showInspectorPage">showInspectorPage	self isAtTextPage ifTrue: 		[self currentPage deactivate.		self installPage: inspectorPage]</body><body package="Tools-Workspace" selector="showTextPage">showTextPage	self isAtInspectorPage ifTrue: 		[self currentPage deactivate.		self installPage: textPage]</body><body package="Tools-Workspace" selector="toggleView">toggleView	self isAtTextPage		ifTrue: [self showInspectorPage]		ifFalse: [self showTextPage]</body></methods><methods><class-id>Tools.Workspace</class-id> <category>private</category><body package="Tools-Workspace" selector="buildMenuBar">buildMenuBar	| menu |	menu := super buildMenuBar.	(menu atNameKey: #pageText) indicationSelector: #isAtTextPage.	(menu atNameKey: #pageVariables) indicationSelector: #isAtInspectorPage.	^menu</body><body package="Tools-Workspace" selector="hibernate">hibernate	self currentPage deactivate</body><body package="Tools-Workspace" selector="installPage:">installPage: aWorkspacePage	currentPage := aWorkspacePage.	aWorkspacePage builder: nil.	self pageSubcanvas		client: aWorkspacePage		spec: #windowSpec		builder: builder newSubBuilder.	self updatePage.	aWorkspacePage refresh</body><body package="Tools-Workspace" selector="pageSubcanvas">pageSubcanvas	^(self builder componentAt: #page) widget</body></methods><methods><class-id>Tools.Workspace</class-id> <category>initialize-release</category><body package="Tools-Workspace" selector="initialize">initialize	super initialize.	self textPage: (WorkspacePage new workspace: self).	inspectorPage := WorkspaceInspectorPage withInspectorOn: locals</body><body package="Tools-Workspace" selector="postBuildWith:">postBuildWith: aBuilder	super postBuildWith: aBuilder.	(builder componentAt: #page) component layout		bottomOffset: [self clientAreaBottomOffset].	(builder componentAt: #pageExplanation) component layout		topOffset: [self clientAreaBottomOffset].	(builder componentAt: #importSummary) component layout		topOffset: [self clientAreaBottomOffset]</body><body package="Tools-Workspace" selector="postOpenWith:">postOpenWith: aBuilder	super postOpenWith: aBuilder.	self installPage: textPage</body><body package="Tools-Workspace" selector="preBuildWith:">preBuildWith: aBuilder	super preBuildWith: aBuilder.	aBuilder labelAt: #label put: self currentPage label</body><body package="Tools-Workspace" selector="setContents:">setContents: aString	self setContents: aString from: nil</body><body package="Tools-Workspace" selector="setContents:from:">setContents: aString from: aFilenameOrNil	self currentPage		contents: aString;		filename: aFilenameOrNil</body><body package="Tools-Workspace" selector="textPage:">textPage: aWorkspacePage	"This message should not be sent after the UI is built."	textPage notNil ifTrue: [textPage release].	textPage := aWorkspacePage.	textPage workspace: self.	currentPage := textPage</body></methods><methods><class-id>Tools.Workspace</class-id> <category>testing</category><body package="Tools-Workspace" selector="canUndo">canUndo	^self isAtTextPage or: [self currentPage canUndo]</body></methods><methods><class-id>Tools.Workspace</class-id> <category>accessing</category><body package="Tools-Workspace" selector="changeRequest">changeRequest	^self currentPage changeRequest</body><body package="Tools-Workspace" selector="currentPage">currentPage	^currentPage</body><body package="Tools-Workspace" selector="currentTextPage">currentTextPage	currentPage == textPage		ifFalse: [self error: (#errNotAtTextPage &lt;&lt; #dialogs &gt;&gt; 'not at text page')].	^self currentPage</body><body package="Tools-Workspace" selector="isAtInspectorPage">isAtInspectorPage	^self isAtTextPage not</body><body package="Tools-Workspace" selector="isAtTextPage">isAtTextPage	^currentPage == textPage</body></methods><methods><class-id>Tools.Workspace class</class-id> <category>instance creation</category><body package="Tools-Workspace" selector="on:">on: aValueModel	"Create a new workspace with aString as the initial contents."	| instance |	instance := self new.	instance currentPage textHolder: aValueModel.	^instance</body><body package="Tools-Workspace" selector="on:labeled:">on: aValueModel labeled: aString	"Create a new workspace with aValueModel as the content holder	and aString as its label."	| instance |	instance := self new.	instance currentPage		label: aString;		textHolder: aValueModel.	^instance</body><body package="Tools-Workspace" selector="with:">with: aString	"Create a new workspace with aString as the initial contents."	^self new 		setContents: aString;		yourself</body><body package="Tools-Workspace" selector="with:labeled:">with: aString labeled: labelString	"Create a new workspace with aString as the initial contents."	| instance |	instance := self new.	instance currentPage		label: labelString;		contents: aString.	^instance</body><body package="Tools-Workspace" selector="withFile:ifAbsent:">withFile: aFilenameOrString ifAbsent: aBlock	"Create a new workspace with the contents of the file as the initial contents.	If the file is missing, execute the block. If the block returns, create a workspace	on a new file with the name specified by the filename and the value returned	by the block as the initial content."	| page |	page := [WorkspacePage filename: aFilenameOrString]		on: OsError		do: [:ex | 			ex return: (WorkspacePage 				filename: aFilenameOrString				contents: aBlock value)].	^self new 		textPage: page;		yourself</body></methods><methods><class-id>Tools.Workbook class</class-id> <category>interface specs</category><body package="Tools-Workspace" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #Workspace 				#defaultString: 'Workspace' 				#catalogID: #labels ) 			#min: #(#{Core.Point} 250 100 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 474 368 1024 768 ) 			#flags: 4 			#menu: #menuBarHolder 			#toolBar: #toolBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 -25 1 ) 					#name: #pages 					#model: #pageHolder 					#tabable: true 					#labels: #() ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -24 1 -41 1 0 1 ) 					#name: #pageExplanation 					#model: #pageExplanationHolder 					#tabable: false 					#helpText: #(#{Kernel.UserMessage} #key: #ExplainCurrentPage #defaultString: 'Explanation of the current page' #catalogID: #labels) 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} -40 1 -24 1 0 1 0 1 ) 					#name: #importSummary 					#model: #importSummaryHolder 					#tabable: false 					#helpText: #(#{Kernel.UserMessage} #key: #NamespacesImportedHere #defaultString: 'Namespaces imported by this workspace' #catalogID: #labels) 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>Tools.Workbook class</class-id> <category>resources</category><body package="Tools-Workspace" selector="menuBar">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Page 					#defaultString: '&amp;Page' 					#catalogID: #menus ) 				#nameKey: #pageMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_New 								#defaultString: '&amp;New' 								#catalogID: #menus ) 							#nameKey: #fileNew 							#value: #fileNew 							#shortcutKeyCharacter: $N 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileNew ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_OpenDot 								#defaultString: '&amp;Open...' 								#catalogID: #menus ) 							#nameKey: #fileOpen 							#value: #fileOpen 							#shortcutKeyCharacter: $O 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileOpen ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Save 								#defaultString: '&amp;Save' 								#catalogID: #menus ) 							#nameKey: #fileSave 							#value: #fileSave 							#enablementSelector: #isAtTextPage 							#shortcutKeyCharacter: $S 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileSave ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Save_AsDot 								#defaultString: 'Save &amp;As...' 								#catalogID: #menus ) 							#nameKey: #fileSaveAs 							#value: #fileSaveAs 							#enablementSelector: #isAtTextPage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_RenameDot 								#defaultString: '&amp;Rename...' 								#catalogID: #menus ) 							#nameKey: #pageRename 							#value: #pageRename 							#enablementSelector: #canRenamePage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_TearOff 								#defaultString: '&amp;Tear Off' 								#catalogID: #menus ) 							#nameKey: #pageTearOff 							#value: #pageTearOff 							#enablementSelector: #isAtTextPage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Re_move 								#defaultString: 'Re&amp;move' 								#catalogID: #menus ) 							#nameKey: #pageClose 							#value: #pageClose 							#enablementSelector: #canClosePage ) ) #(1 3 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Edit 					#defaultString: '&amp;Edit' 					#catalogID: #menus ) 				#nameKey: #editMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Undo 								#defaultString: '&amp;Undo' 								#catalogID: #menus ) 							#nameKey: #editUndo 							#value: #undo 							#enablementSelector: #canUndo 							#shortcutKeyCharacter: $Z 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Cu_t 								#defaultString: 'Cu&amp;t' 								#catalogID: #menus ) 							#nameKey: #editCut 							#value: #cut 							#enablementSelector: #isAtTextPage 							#shortcutKeyCharacter: $X 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #cut ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Copy 								#defaultString: '&amp;Copy' 								#catalogID: #menus ) 							#nameKey: #editCopy 							#value: #copySelection 							#shortcutKeyCharacter: $C 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #copy ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Paste 								#defaultString: '&amp;Paste' 								#catalogID: #menus ) 							#nameKey: #editPaste 							#value: #paste 							#shortcutKeyCharacter: $V 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #paste ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_FindDots 								#defaultString: '&amp;Find...' 								#catalogID: #menus ) 							#nameKey: #editFind 							#value: #find 							#shortcutKeyCharacter: $L 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ReplaceDots 								#defaultString: '&amp;Replace...' 								#catalogID: #menus ) 							#nameKey: #editReplace 							#value: #replace 							#shortcutKeyCharacter: $R 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Select_All 								#defaultString: 'Select &amp;All' 								#catalogID: #menus ) 							#nameKey: #editSelectAll 							#value: #selectAll 							#shortcutKeyCharacter: $A 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Encoding 								#defaultString: '&amp;Encoding' 								#catalogID: #menus ) 							#nameKey: #editEncoding ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Boss_InDot 								#defaultString: 'Boss &amp;In...' 								#catalogID: #menus ) 							#value: #bossIn 							#enablementSelector: #canBOSSObjects ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Boss_OutDot 								#defaultString: 'Boss &amp;Out...' 								#catalogID: #menus ) 							#value: #bossOut 							#enablementSelector: #canBOSSObjects ) ) #(1 3 2 1 1 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Smalltalk 					#defaultString: '&amp;Smalltalk' 					#catalogID: #menus ) 				#nameKey: #smalltalkSubmenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_DoIt 								#defaultString: '&amp;Do it' 								#catalogID: #menus ) 							#value: #smalltalkDoIt 							#shortcutKeyCharacter: $D 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #doIt ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_PrintIt 								#defaultString: '&amp;Print it' 								#catalogID: #menus ) 							#value: #smalltalkPrintIt 							#shortcutKeyCharacter: $P 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #printIt ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_InspectIt 								#defaultString: '&amp;Inspect it' 								#catalogID: #menus ) 							#value: #smalltalkInspectIt 							#shortcutKeyCharacter: $Q 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #inspectIt ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #De_bugIt 								#defaultString: 'De&amp;bug it' 								#catalogID: #menus ) 							#value: #smalltalkDebugIt 							#shortcutKeyCharacter: $B 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #debugIt ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_FileItIn 								#defaultString: '&amp;File it In' 								#catalogID: #menus ) 							#value: #smalltalkFileItIn ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_NamespacesDot 								#defaultString: '&amp;Namespaces...' 								#catalogID: #menus ) 							#value: #editImports 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #namespaces ) ) ) #(4 1 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Options 					#defaultString: '&amp;Options' 					#catalogID: #menus ) 				#nameKey: #optionsMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Toolbar 								#defaultString: '&amp;Toolbar' 								#catalogID: #menus ) 							#nameKey: #toolbar 							#value: #toggleToolbar 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_StatusBar 								#defaultString: '&amp;Status Bar' 								#catalogID: #menus ) 							#nameKey: #toggleStatusBar 							#value: #toggleStatusBar ) ) #(2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Help 					#defaultString: '&amp;Help' 					#catalogID: #menus ) 				#nameKey: #help 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Workspace 								#defaultString: '&amp;Workspace' 								#catalogID: #menus ) 							#value: #helpWorkspace 							#shortcutKeyCharacter: #F1 							#shortcutModifiers: 0 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #help ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_AboutVisualWorksDot 								#defaultString: '&amp;About VisualWorks...' 								#catalogID: #menus ) 							#value: #helpAbout ) ) #(1 1 ) nil ) ) ) #(5 ) nil ) decodeAsLiteralArray</body><body package="Tools-Workspace" selector="toolBar">toolBar	"MenuEditor new openOnClass: self andSelector: #toolBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #New #defaultString: 'New' #catalogID: #menus) 				#value: #fileNew 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileNew ) 				#helpText: #(#{Kernel.UserMessage} #key: #New #defaultString: 'New' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Open #defaultString: 'Open' #catalogID: #menus) 				#value: #fileOpen 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileOpen ) 				#helpText: #(#{Kernel.UserMessage} #key: #Open #defaultString: 'Open' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Save #defaultString: 'Save' #catalogID: #menus) 				#nameKey: #fileSave 				#value: #fileSave 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileSave ) 				#helpText: #(#{Kernel.UserMessage} #key: #Save #defaultString: 'Save' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Cut #defaultString: 'Cut' #catalogID: #menus) 				#nameKey: #cut 				#value: #cut 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #cut ) 				#helpText: #(#{Kernel.UserMessage} #key: #Cut #defaultString: 'Cut' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Copy #defaultString: 'Copy' #catalogID: #menus) 				#nameKey: #copy 				#value: #copySelection 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #copy ) 				#helpText: #(#{Kernel.UserMessage} #key: #Copy #defaultString: 'Copy' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Paste #defaultString: 'Paste' #catalogID: #menus) 				#nameKey: #paste 				#value: #paste 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #paste ) 				#helpText: #(#{Kernel.UserMessage} #key: #Paste #defaultString: 'Paste' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #DoIt #defaultString: 'Do it' #catalogID: #menus) 				#value: #smalltalkDoIt 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #doIt ) 				#helpText: #(#{Kernel.UserMessage} #key: #DoIt #defaultString: 'Do it' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #PrintIt #defaultString: 'Print it' #catalogID: #menus) 				#value: #smalltalkPrintIt 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #printIt ) 				#helpText: #(#{Kernel.UserMessage} #key: #PrintIt #defaultString: 'Print it' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #InspectIt #defaultString: 'Inspect it' #catalogID: #menus) 				#value: #smalltalkInspectIt 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #inspectIt ) 				#helpText: #(#{Kernel.UserMessage} #key: #InspectIt #defaultString: 'Inspect it' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #DebugIt #defaultString: 'Debug it' #catalogID: #menus) 				#value: #smalltalkDebugIt 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #debugIt ) 				#helpText: #(#{Kernel.UserMessage} #key: #DebugIt #defaultString: 'Debug it' #catalogID: #menus) ) ) #(3 3 4 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.WorkspaceImportsDialog class</class-id> <category>interface specs</category><body package="Tools-Workspace" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #ImportedNamespaces #defaultString: 'Imported Namespaces' #catalogID: #labels) 			#bounds: #(#{Graphics.Rectangle} 238 268 442 539 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 10 10 ) 					#model: #importAllHolder 					#label: #(#{Kernel.UserMessage} #key: #All #defaultString: 'All' #catalogID: #labels) 					#select: true ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 10 30 ) 					#model: #importAllHolder 					#label: #(#{Kernel.UserMessage} #key: #SomeColon #defaultString: 'Some:' #catalogID: #labels) 					#select: false ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 60 0 -10 1 -50 1 ) 					#name: #namespaces 					#model: #namespaces 					#multipleSelections: true 					#selectionType: #checkMark ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 -35 1 -10 0.5 -10 1 ) 					#model: #accept 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #labels) 					#isDefault: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0.5 -35 1 -10 1 -10 1 ) 					#model: #cancel 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #labels) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Tools.WorkspacePage class</class-id> <category>interface specs</category><body package="Tools-Workspace" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #label 			#bounds: #(#{Graphics.Rectangle} 512 384 960 649 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dropSelector 						#drop: #dragEnterSelector 						#dragEntry: #dragOverSelector 						#dragOver: ) 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #text 					#model: #textModel 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: 						#okToSaveTextFrom: ) 					#tabRequiresControl: true ) ) ) )</body></methods><methods><class-id>Tools.Workspace class</class-id> <category>interface specs</category><body package="Tools-Workspace" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 			#label: #label 			#min: #(#{Core.Point} 250 100 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 474 368 1024 768 ) 			#flags: 4 			#menu: #menuBarHolder 			#toolBar: #toolBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 -24 1 ) 					#name: #page 					#flags: 0 ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -24 1 -41 1 0 1 ) 					#name: #pageExplanation 					#model: #pageExplanationHolder 					#tabable: false 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} -40 1 -24 1 0 1 0 1 ) 					#name: #importSummary 					#model: #importSummaryHolder 					#tabable: false 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>Tools.Workspace class</class-id> <category>resources</category><body package="Tools-Workspace" selector="menuBar">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_File 					#defaultString: '&amp;File' 					#catalogID: #menus ) 				#nameKey: #fileMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_New 								#defaultString: '&amp;New' 								#catalogID: #menus ) 							#nameKey: #fileNew 							#value: #fileNew 							#shortcutKeyCharacter: $N 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileNew ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_OpenDot 								#defaultString: '&amp;Open...' 								#catalogID: #menus ) 							#nameKey: #fileOpen 							#value: #fileOpen 							#shortcutKeyCharacter: $O 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileOpen ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Save 								#defaultString: '&amp;Save' 								#catalogID: #menus ) 							#nameKey: #fileSave 							#value: #fileSave 							#enablementSelector: #isAtTextPage 							#shortcutKeyCharacter: $S 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileSave ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Save_AsDot 								#defaultString: 'Save &amp;As...' 								#catalogID: #menus ) 							#nameKey: #fileSaveAs 							#value: #fileSaveAs 							#enablementSelector: #isAtTextPage ) ) #(1 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Edit 					#defaultString: '&amp;Edit' 					#catalogID: #menus ) 				#nameKey: #editMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Undo 								#defaultString: '&amp;Undo' 								#catalogID: #menus ) 							#nameKey: #editUndo 							#value: #undo 							#enablementSelector: #canUndo 							#shortcutKeyCharacter: $Z 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Cu_t 								#defaultString: 'Cu&amp;t' 								#catalogID: #menus ) 							#nameKey: #editCut 							#value: #cut 							#enablementSelector: #isAtTextPage 							#shortcutKeyCharacter: $X 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #cut ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Copy 								#defaultString: '&amp;Copy' 								#catalogID: #menus ) 							#nameKey: #editCopy 							#value: #copySelection 							#shortcutKeyCharacter: $C 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #copy ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Paste 								#defaultString: '&amp;Paste' 								#catalogID: #menus ) 							#nameKey: #editPaste 							#value: #paste 							#shortcutKeyCharacter: $V 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #paste ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_FindDots 								#defaultString: '&amp;Find...' 								#catalogID: #menus ) 							#nameKey: #editFind 							#value: #find 							#shortcutKeyCharacter: $L 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ReplaceDots 								#defaultString: '&amp;Replace...' 								#catalogID: #menus ) 							#nameKey: #editReplace 							#value: #replace 							#shortcutKeyCharacter: $R 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Select_All 								#defaultString: 'Select &amp;All' 								#catalogID: #menus ) 							#nameKey: #editSelectAll 							#value: #selectAll ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Encoding 								#defaultString: '&amp;Encoding' 								#catalogID: #menus ) 							#nameKey: #editEncoding ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Boss_InDot 								#defaultString: 'Boss &amp;In...' 								#catalogID: #menus ) 							#value: #bossIn 							#enablementSelector: #canBOSSObjects ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Boss_OutDot 								#defaultString: 'Boss &amp;Out...' 								#catalogID: #menus ) 							#value: #bossOut 							#enablementSelector: #canBOSSObjects ) ) #(1 3 2 1 1 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Smalltalk 					#defaultString: '&amp;Smalltalk' 					#catalogID: #menus ) 				#nameKey: #smalltalkSubmenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_DoIt 								#defaultString: '&amp;Do it' 								#catalogID: #menus ) 							#value: #smalltalkDoIt 							#shortcutKeyCharacter: $D 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #doIt ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_PrintIt 								#defaultString: '&amp;Print it' 								#catalogID: #menus ) 							#value: #smalltalkPrintIt 							#shortcutKeyCharacter: $P 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #printIt ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_InspectIt 								#defaultString: '&amp;Inspect it' 								#catalogID: #menus ) 							#value: #smalltalkInspectIt 							#shortcutKeyCharacter: $Q 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #inspectIt ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #De_bugIt 								#defaultString: 'De&amp;bug it' 								#catalogID: #menus ) 							#value: #smalltalkDebugIt 							#shortcutKeyCharacter: $B 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #debugIt ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_NamespacesDot 								#defaultString: '&amp;Namespaces...' 								#catalogID: #menus ) 							#value: #editImports 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #namespaces ) ) ) #(4 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_View 					#defaultString: '&amp;View' 					#catalogID: #menus ) 				#nameKey: #viewSubmenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Text 								#defaultString: '&amp;Text' 								#catalogID: #menus ) 							#nameKey: #pageText 							#value: #showTextPage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Variables 								#defaultString: '&amp;Variables' 								#catalogID: #menus ) 							#nameKey: #pageVariables 							#value: #showInspectorPage ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_BecomeMultiPage 								#defaultString: '&amp;Become Multi-Page' 								#catalogID: #menus ) 							#value: #mutateToWorkbook ) ) #(2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Options 					#defaultString: '&amp;Options' 					#catalogID: #menus ) 				#nameKey: #optionsMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Toolbar 								#defaultString: '&amp;Toolbar' 								#catalogID: #menus ) 							#nameKey: #toolbar 							#value: #toggleToolbar 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_StatusBar 								#defaultString: '&amp;Status Bar' 								#catalogID: #menus ) 							#nameKey: #toggleStatusBar 							#value: #toggleStatusBar ) ) #(2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Help 					#defaultString: '&amp;Help' 					#catalogID: #menus ) 				#nameKey: #help 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Workspace 								#defaultString: '&amp;Workspace' 								#catalogID: #menus ) 							#value: #helpWorkspace 							#shortcutKeyCharacter: #F1 							#shortcutModifiers: 0 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #help ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_AboutVisualWorksDot 								#defaultString: '&amp;About VisualWorks...' 								#catalogID: #menus ) 							#value: #helpAbout ) ) #(1 1 ) nil ) ) ) #(6 ) nil ) decodeAsLiteralArray</body><body package="Tools-Workspace" selector="toolBar">toolBar	"MenuEditor new openOnClass: self andSelector: #toolBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #New #defaultString: 'New' #catalogID: #menus) 				#value: #fileNew 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileNew ) 				#helpText: #(#{Kernel.UserMessage} #key: #New #defaultString: 'New' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Open #defaultString: 'Open' #catalogID: #menus) 				#value: #fileOpen 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileOpen ) 				#helpText: #(#{Kernel.UserMessage} #key: #Open #defaultString: 'Open' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Save #defaultString: 'Save' #catalogID: #menus) 				#value: #fileSave 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileSave ) 				#helpText: #(#{Kernel.UserMessage} #key: #Save #defaultString: 'Save' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Cut #defaultString: 'Cut' #catalogID: #menus) 				#value: #cut 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #cut ) 				#helpText: #(#{Kernel.UserMessage} #key: #Cut #defaultString: 'Cut' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Copy #defaultString: 'Copy' #catalogID: #menus) 				#value: #copySelection 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #copy ) 				#helpText: #(#{Kernel.UserMessage} #key: #Copy #defaultString: 'Copy' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Paste #defaultString: 'Paste' #catalogID: #menus) 				#value: #paste 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #paste ) 				#helpText: #(#{Kernel.UserMessage} #key: #Paste #defaultString: 'Paste' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #DoIt #defaultString: 'Do it' #catalogID: #menus) 				#value: #smalltalkDoIt 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #doIt ) 				#helpText: #(#{Kernel.UserMessage} #key: #DoIt #defaultString: 'Do it' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #PrintIt #defaultString: 'Print it' #catalogID: #menus) 				#value: #smalltalkPrintIt 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #printIt ) 				#helpText: #(#{Kernel.UserMessage} #key: #PrintIt #defaultString: 'Print it' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #InspectIt #defaultString: 'Inspect it' #catalogID: #menus) 				#value: #smalltalkInspectIt 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #inspectIt ) 				#helpText: #(#{Kernel.UserMessage} #key: #InspectIt #defaultString: 'Inspect it' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #DebugIt #defaultString: 'Debug it' #catalogID: #menus) 				#value: #smalltalkDebugIt 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #debugIt ) 				#helpText: #(#{Kernel.UserMessage} #key: #DebugIt #defaultString: 'Debug it' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #toggleView #defaultString: 'toggleView' #catalogID: #menus) 				#value: #toggleView 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #inspectLocals ) 				#helpText: #(#{Kernel.UserMessage} #key: #ToggleTextvariablesView #defaultString: 'Toggle text/variables view' #catalogID: #menus) ) ) #(3 3 4 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>actions</category><body package="Tools-Workspace" selector="fileOpen">fileOpen	&lt;menuItem: #(#OpenFileItemLabel #menus '&amp;Open File...')		icon: nil		nameKey: #fileOpen		menu: #(#menuBar file)		position: 9.02&gt;	| name ws |	name := (Dialog requestFileName: (#OpenFile &lt;&lt; #dialogs &gt;&gt; 'Open File') default: '*.ws') trimBlanks.	name isEmpty ifFalse:		[ws := Workspace withFile: name.		 ws encodingChannel value: #default.		 ws open]</body><body package="Tools-Workspace" selector="helpInstallationWorkspace">helpInstallationWorkspace	&lt;menuItem: #(#installWorkspace #menus 'Installation Workspace')		nameKey: nil		menu: #(#menuBar #help)		position: 5.02&gt;	Workbook systemWorkbook		open;		selectPageLabeled: 			(#installationWorkspace &lt;&lt; #labels &gt;&gt; 'Installation Workspace')</body><body package="Tools-Workspace" selector="helpSystemWorkspace">helpSystemWorkspace	&lt;menuItem: #(#systemWorkspaceMenu #menus 'System Workspace')		nameKey: nil		menu: #(#menuBar #help)		position: 5.03&gt;	Workbook systemWorkbook		open;		selectPageLabeled: 				(#systemWorkspace &lt;&lt; #labels &gt;&gt; 'System Workspace')</body><body package="Tools-Workspace" selector="toolsNewWorkspace">toolsNewWorkspace	"Open a new workspace."	&lt;menuItem: #(#Workspace #labels 'Workspace')		icon: #workspaceIcon		nameKey: nil		menu: #(#launcherToolBar)		position: 30.5		helpText: #(#OpenANewWorkspace #labels 'Open a new workspace')&gt;	&lt;menuItem: #(#_Workspace #menus '&amp;Workspace')		icon: #workspaceIcon		nameKey: nil		shortcutKeyCharacter: #F6		shortcutModifiers: 0		menu: #(#menuBar tools)		position: 9.00&gt;	self openApplicationForClassNamed:		(AbstractWorkspace useMultiPageWorkspaces			ifTrue: [#Workbook]			ifFalse: [#Workspace])</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>NameSpace</name><environment>Kernel</environment><super>Kernel.GeneralNameSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class><class><name>InspectorHolder</name><environment>Tools.Trippy</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inspector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector toolDock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>InteractiveCompilerErrorHandler</name><environment>Kernel</environment><super>Kernel.CompilerErrorHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>editor lengthChange selectRange alreadyHandled </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Support</category><attributes><package>System-Compiler-Support</package></attributes></class></st-source>