<?xml version="1.0"?><st-source><!-- Name: DatabaseNotice: Copyright © 1999-2005 Cincom Systems, Inc.  All Rights Reserved.Comment: VisualWorks Database support is provided in several packages. This package (Database) provides the External database interface framework (EXDI) that other packages (OracleEXDI, CTLibEXDI, etc) need to interact with relational databases.Further information on the EXDI framework can be found in the 'Database Application Developer's Guide' (located in the /doc subdirectory of the VisualWorks installation).DbIdentifier: bear73DbTrace: 53504DevelopmentPrerequisites: #(#(#any 'Database-Namespace' ''))HideSource: falsePackageName: DatabasePackageName:: DatabaseParcel: #('Database')ParcelName: DatabasePrerequisiteParcels: #(#('Database-Namespace' ''))PrintStringCache: (7.3.1 - 1.4,bobw)SaveSource: trueSource: Database.pstVersion: 7.3.1Date: 5:51:16 pm April 10, 2005 --><time-stamp>From VisualWorks®, 7.3.1 of April 10, 2005 on April 10, 2005 at 5:51:16 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ConnectionDialog</name><environment>Database</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connectionProfileListHolder connectionProfileHolder databaseListHolder databaseHolder environmentListHolder environmentHolder userNameListHolder userNameHolder passwordHolder currentProfileHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Connection Dialog</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ConnectionDialog</class-id><body>This is the dialog used to set parameters of a database connection. The dialog also allows to save often used sets of parameters as profiles that can be selected with a single click.The primary access point is the messages under the 'utilities' protocol on the class side:	chooseProfilewhich former opens the dialog and answers an instance of ConnectionProfile with the settings selected by the user. If the dialog has been cancelled, the answer is nil. The client code is then responsible for connecting to the database and handling possible errors, however the dialog class can help with that if all that is required is to attempt a connection and display a message box in case of an error.  See the class-side method	connect:This very simple pattern of using the dialog is illustrated by two methods under the 'examples' protocol on the class side.Instance Variables:	connectionProfileListHolder	&lt;ValueHolder with: &lt;List of: String&gt;&gt; 	This and most of the following variables hold various aspects of the dialog interface.	connectionProfileHolder	&lt;ValueHolder with: String&gt;	databaseListHolder	&lt;ValueHolder with: &lt;List of: Symbol&gt;&gt;	databaseHolder	&lt;AspectAdaptor&gt;		environmentListHolder	&lt;ValueHolder with: &lt;List of: String&gt;&gt;	environmentHolder	&lt;AspectAdaptor&gt;	userNameListHolder	&lt;ValueHolder with: &lt;List of: String&gt;&gt;	userNameHolder	&lt;AspectAdaptor&gt;	passwordHolder	&lt;AspectAdaptor&gt;	currentProfileHolder	&lt;ValueHolder with: ConnectionProfile&gt;	A value holder with the "working copy" of a ConnectionProfile. It is a subject channel of some of the aspects above, which are aspects adaptors.Shared Variables:	LastUsedProfile	&lt;ConnectionProfile&gt;	The connection profile most recently accepted by the user.	Profiles	&lt;Collection of: ConnectionProfile&gt;	All the named profiles that have been saved by the user.</body></comment><class><name>ExternalDatabaseError</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dbmsErrorCode dbmsErrorString osErrorCode osErrorString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ExternalDatabaseError</class-id><body>An ExternalDatabaseError is returned as the parameter for exceptions raised by the External Database Interface to describe conditions reported by the dbms api in use.  Other exceptionswill have nil for the parameter value.The instance variables may all be nil to indicate that (in the current situation) there is no available/appropriate value for that field.Individual drivers may subclass if they have additional information to provide when errors occur.Instance Variables:	dbmsErrorCode		&lt;SmallInteger | nil&gt;		The code provided by the dbms api.	dbmsErrorString		&lt;String | nil&gt;		The string associated with the dbmsErrorCode.	osErrorCode			&lt;SmallInteger | nil&gt;		The error code provided by the dbms api which is attributed to the underlying		operating system.  This is usually just detail information about the dbmsErrorCode.	osErrorString 		&lt;String | nil&gt;		The string associated with the osErrorCode.</body></comment><class><name>ByteFieldDescriptor</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>template max isLongType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Support</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ByteFieldDescriptor</class-id><body>Instances of ByteFieldDescriptor describe variable-length data fields.  Used by protocol private to the ObjectLens.Instance Variables:	template &lt;Object&gt;		a template object describing the class of values in the field	max &lt;SmallInteger&gt;		the maximum size of objects in the field</body></comment><class><name>AdHocQueryTool</name><environment>Database</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection session answerStream queryModel tableModel whichDriverModel connectedStatusHolder executeStatusHolder moreAnswersStatusHolder usernameModel passwordModel environmentModel blockFactorModel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Tools</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.AdHocQueryTool</class-id><body>AdHocQueryTool is a simple application that supports ad hoc database queries,and demonstrates the use of the External Database Interface.Instance variables:	connection &lt;ExternalDatabaseConnection&gt;		The current database connection.	queryModel &lt;ValueHolder&gt;		Holds the latest query.	tableModel &lt;TableInterface&gt;		The table used to display results.	whichDriverModel &lt;ValueHolder&gt;		Holds the name of the Database Connect to use.	usernameModel &lt;ValueHolder&gt;		Holds the username to use to make the connection.	passwordModel &lt;ValueHolder&gt;		Holds the password to use to make the connection.	environmentModel &lt;ValueHolder&gt;		Holds the environment (connect) string to make the connection.	blockFactorModel &lt;ValueHolder&gt;		Holds the block factor to use when executing the query.</body></comment><class><name>ExternalDatabaseColumnDescription</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name index type length precision scale nullable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ExternalDatabaseColumnDescription</class-id><body>Class ExternalDatabaseColumnDescription defines the common protocol for accessing meta-data about columns.  The information available is limited by the database api library.  If any of the properties of a column are unknown, a nil value is reported.Instance variables:	name	&lt;String | nil&gt;		The name of the column. If the column is derived (in an answer set),		the name may not be defined (nil) or an empty string.	index	&lt;SmallInteger | nil&gt;		The ordinal position of the column in the answer set or in the table.	type		&lt;Magnitude class | nil&gt;		The Smalltalk class which is used to hold data from the column.	length	&lt;SmallInteger | nil&gt;		The number of bytes to represent the column.  In some database api libraries, this		is the maximum storage length.  In others, it is the display length.  If both are available,		it is the maximum of the two.	precision	&lt;SmallInteger | nil&gt;		The total number of digits in a decimal number.	scale	&lt;SmallInteger | nil&gt;		The number of digits to the right of the decimal point.	nullable 	&lt;Boolean | nil&gt;		True implies that this column may hold null values.</body></comment><class><name>ExternalDatabaseBuffer</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>databaseType encoding elementSize count bufferPointer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ExternalDatabaseBuffer</class-id><body>ExternalDatabaseBuffer is a private, abstract class used by ExternalDatabaseSessionto represent and manage an external database buffer, and to translate between alimited set of Smalltalk objects and their external database specific representationin the buffer.Subclasses extend ExternalDatabaseBuffer to deal with particular databases.Instance variables:	databaseType &lt;Object&gt;		The type of data that the buffer will contain.  The interpretation of this		is subclass dependent.	encoding &lt;Symbol&gt;		The encoding that Strings will be subjected to.	elementSize	&lt;SmallInteger&gt;		The maximum length of a single data item.	count	&lt;SmallInteger&gt;		The cardinality of (number of item slots in) the buffer.  A count of zero		indicates that the buffer will hold a scalar value.	bufferPointer	&lt;nil | CPointer&gt;		When allocated, the CPointer that "holds" the buffer.Subclasses must implement the following messages	instance protocol		accessing			at:			at:put:</body></comment><class><name>ExternalDatabaseFramework</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stateHolder traceStream traceLevel participants participantsSemaphore </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ExternalDatabaseFramework</class-id><body>Class ExternalDatabaseFramework is an abstract class defining common services for the implementation of the external database interface.  Applications never use this class directly.The external database interface defines application-visible services and is composed of abstract classes.  To access a database, a driver is used.  Each driver is a set of concrete classes which implement the external database interface services by making calls to a specific database interface library.  A driver may also extend the services available to the application in order to provide features which are unique to that database library.The interface divides overall services into connections, sessions, answer streams, and column descriptions.  Each of these concepts is represented by a class.  ExternalDatabaseConnection defines transaction and connection management services. ExternalDatabaseSession defines services for preparing and executing SQL statements. ExternalDatabaseAnswerStream defines services for processing the answer set of a SELECT statement. ExternalDatabaseColumnDescription defines information which describes a column of a table or answer set.  ExternalDatabaseTransaction is used by the connection to handle  transaction services, but is not directly utilized by application programmers using the external database interface.  As a naming convention, the driver-specific subclasses of the above abstract classes will have the driver name as a prefix in the class name in place of "ExternalDatabase".ExternalDatabaseFramework services:	1) registration for active instances of a subclass (used when holding external handles)	2) a framework for finalization	3) a signal dictionary for all signals	4) a framework for trace output collection and generation	5) a framework for activation control (pause and resume)	6) a collection of participants (see below for definition of participation)	7) a framework for preparing trace entriesRegistry:	The basic design of the external database interface requires every driver class that holds external resources have a registry.  It is assumed that: 1) the holder of external resources is registered whenever it holds that external resource or is paused (see the ExternalDatabaseConnection class for the definition of pause and resume); and 2) that the executors hold strong references only to handles, the state of the object, and parent objects.Participation:	An application uses instances of several external database interface classes which have specific relationships according to their role. The relationships comprise a hierarchy where one or more instances of a class *lower* in the hierarchy are said to *participate* in the context defined by an instance of the class *above* them.  For instance, a session is said to participate in a connection.  Participation is recorded in a weak array that is the size of the number of participants.  The array is weak to facilitate the automatic release of external resources when instances of the external database interface classes are no longer used.Instance variables:	stateHolder &lt;ValueHolder on: Symbol&gt;		Holds the current state.  Legal states are defined by the subclasses.	traceStream	&lt;WriteStream on: String&gt;		A private stream used for preparing complex trace entries.	traceLevel  &lt;SmallInteger&gt;		The trace level, copied from the class side on instance creation.  If zero, tracing		is disabled.	participants	&lt;WeakArray&gt;		Holds references to participating (subordinate) external database objects.		Used to propogate operations downward when multiple objects must cooperate		to provide a function.	participantsSemaphore	&lt;RecursionLock&gt;		Used for mutual exclusion protection on uses of the participants array.Class variables:	TraceLevel			&lt;SmallInteger&gt;		The current tracing level for the class.	TraceCollector		&lt;nil | TextCollector | Stream&gt;		nil =&gt; do not output the trace.	TraceSequencer		&lt;RecursionLock&gt;		Use for mutual exclusion to ensure that trace entries are not interleaved.Subclasses must implement the following messages	instance protocol		private-finalization			key		private-library calls			acquireExternal			dismissExternal			class protocol		accessing			connectionClass		private-registry			registry:Notation:	Assume:			a pre-condition for a method.	Enforce:			a pre-condition that is enforced by raising an exception.	Enforce-quietly:	a pre-condition that is enforced and the method is a no-op.	Assert:			a condition that must be met in the middle of a method.	Assure:			a post-condition which is guaranteed on method completion.</body></comment><class><name>ExternalDatabaseSession</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection query queryFragments bindInput bindTemplate bindOutput useNamedOutputBinding bindValues resultTemplate allocateForEachRow blockFactor numColumns columnDescriptions rowAdaptors rowBuffersHolder bufferIndex answerStream currentRow </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ExternalDatabaseSession</class-id><body>ExternalDatabaseSession is the abstract class defining the application interface to executing prepared SQL statements or stored procedures, describing the results of the execution, and acquiring streams of results.Inherited instance variables:	stateHolder &lt;ValueHolder on: (#new | #connected | #prepared | #executing | #ready | #validResults | #fetchingData | #paused)&gt;			The state variable is used to track the legal operations on sessions.	traceStream &lt;WriteStream on: String&gt;		A private stream used for preparing complex trace entries.	traceLevel  &lt;SmallInteger&gt;		The trace level, copied from the class side on instance creation.  If zero, tracing		is disabled.	participants &lt;WeakArray of: ExternalDatabaseAnswerStream&gt;		The answer stream instance that participates in this session.  There will never be		more than one.	participantsSemaphore &lt;RecursionLock&gt;		Used for mutual exclusion protection of uses of the participants array.Instance variables:	connection &lt;ExternalDatabaseConnection&gt;		The connection context in which this session executes		SQL statements or stored procedures.	query &lt;String&gt;		The SQL query provided by the client.	queryFragments &lt;Collection of: (String | SmallInteger | Symbol)&gt;		The query, canonized for parameter binding.	bindInput &lt;Object | nil&gt;		The object to obtain bind values from, if any are required.	bindOutput &lt;Object | nil&gt;		The bind object to use for output rows.  If nil, output rows are instances of Array.	bindValues &lt;IdentityDictionary&gt;		A private dictionary, keyed by bind position, of values bound to parameters.		Used to avoid unneccessary rebinds.	useNamedOutputBinding &lt;Boolean&gt;		Determines if the output bind object should be populated by sending it mutators		fashined from the column names.  The default is populate the bind object		by directly indexing its instance variables.	allocateForEachRow	&lt;Boolean&gt;		When true (the default), the answer stream will create a copy of the output bind		object for each row.  When false, the answer stream will use the same bind object		repeatedly.	blockFactor	&lt;SmallInteger&gt;		The number of rows to fetch in a block from the dbms server.	currentRow &lt;Object | nil&gt;		The session's bindOutput object or an appropriate Array (i.e. with the right number		of cells to match the number of columns).  The adaptors used to insert values		into the appropriate repository for each column are given a copy of this or use it		directly if allocateForEachRow is false.	numColumns &lt;SmallInteger&gt;		The number of columns in the answer set.	columnDescriptions &lt;(Array of: ExternalDatabaseColumnDescription) | nil&gt;		Array containing a description of each column in the answer set.	rowAdaptors &lt;Array of: BlockClosure&gt;		A block for each column of the output.  Each block takes two arguments		(subject and value) and is responsible for inserting the value into the instance		or indexed variable of the subject.	rowBuffersHolder &lt;ValueHolder on: (Array of: (ExternalDatabaseBuffer | Array))&gt;		Each driver will need space to store the data as it is returned from the		dbms api.  For systems which do not fetch rows directly into predeclared		buffer, it is still important to allocate these buffers once to avoid the overhead		of constantly allocating and deallocating space.	answerStream &lt;ExternalDatabaseAnswerStream | nil&gt;		A reference to the active answer stream.	bindTemplate &lt;Object&gt;		Private variable for Object Lens use.	resultTemplate &lt;Object&gt;		Private variable for Object Lens use.	bufferIndex &lt;SmallInteger&gt;		Private variable for Object Lens use.Subclasses must implement the following messages	instance protocol		data processing			rowCount		private-answer set			advanceExternal			allocateRowBufferExternal:			getColumnDescriptionExternal:			hasAnswerSetExternal			getFieldExternal:			cancelAnswerSetExternal		private-execution			executeExternal			readyExternal			resultsExternal			moreResultsExternal			cancelExternal		private-binding			prepareExternal			bindValue:at:		schema access			listTablesLike:			describeColumns:		private-ObjectLens			bindInput:template:to:			flattenResultTemplate:onto:			nextViaTemplate:</body></comment><class><name>ExternalDatabaseConnection</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transaction username password environment transactionCoordinator cachedSession isolationLevel </inst-vars><class-inst-vars>environmentMap xif xifMap </class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ExternalDatabaseConnection</class-id><body>ExternalDatabaseConnection is the abstract class defining database connection services.The maximum number of active connections is controlled by the driver.All drivers are required to support coordinated transactions.  If full atomic behavior is not available, it is simulated with a serial broadcast commit on each participating connection.  A two-phase commit protocol would ensure true coordination for commits and rollbacks.Implementation Details:Participation relationships:	An instance of the connection subclasses will participate in an instance of the	transaction subclass.  An instance of the session subclass will participate	in an instance of the connection subclass.Inherited instance variables:	stateHolder			&lt;ValueHolder on: (#new | #xactNo | #xactYes | #paused)&gt;		The state variable is used to track the legal operations on connections.	traceStream		&lt;WriteStream on: String&gt;		A private stream used for preparing complex trace entries.	traceLevel  &lt;SmallInteger&gt;		The trace level, copied from the class side on instance creation.  If zero, tracing		is disabled.	participants			&lt;WeakArray of: ExternalDatabaseSession&gt;		The session instances that participate in the connection.	participantsSemaphore	&lt;RecursionLock&gt;		Used for mutual exclusion protection of uses of the participants array.Instance variables:	transaction			&lt;ExternalDatabaseTransaction | nil&gt;		Transaction that this connection is a part of.	username			&lt;String | nil&gt;			Name of current user; driver will signal if required and == nil.	password			&lt;String | nil&gt;		Password of current user; driver will signal if required and == nil.	environment			&lt;String | nil&gt;			Logical or physical name for environment; driver will signal if required and == nil.	transactionCoordinator &lt;ValueHolder on: Boolean&gt;		Holds true if this connection is a transaction coordinator for other connections.	cachedSession &lt;nil | ExternalDatabaseSession&gt;		Holds onto a session for reuse by getSession.	isolationLevel &lt; Symbol | nil&gt;		Holds the isolationLevel for this connection.Class variables:	DefaultConnection			&lt;Symbol | nil&gt;		Contains name of subclass to use when creating a new connection.	DefaultEnvironment	&lt;String | nil&gt;		Contains logical environment to use as a default for connecting.	StandardSignals		&lt;IdentityDictionary of: Signal&gt;		Maps signal names to signals.	PlatformType &lt;nil | Symbol&gt;		Platform/OS type that we're running on.  Used to select an platform-specific		ExternalInterface subclass.Class instance variables:	environmentMap		&lt;Dictionary | nil&gt;		Each driver maintains a map of logical to physical environments.Subclasses must implement the following messages:	instance protocol		private-library calls			acquireExternal:	class protocol		accessing			sessionClass			transactionClass			kind		activation			pause			resume		private-accessing			call		private-activation			install</body></comment><class><name>ExternalDatabaseException</name><environment>Database</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ExternalDatabaseException</class-id><body>ExternalDatabaseException is raised in case of the external database common errors.</body></comment><class><name>UnableToBind</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnableToBind</class-id><body>UnableToBind is used to indicate that the input or output bind was unsuccessful.</body></comment><class><name>UnableToPrepare</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnableToPrepare</class-id><body>UnableToPrepare is used to indicate that it is unable to prepare an SQL statement.</body></comment><class><name>UnableToQueryHandleInformation</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnableToQueryHandleInformation</class-id><body>UnableToQueryHandleInformation is used to indicate that the handle information could not be queried.</body></comment><class><name>ExternalDatabaseTransactionError</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ExternalDatabaseTransactionError</class-id><body>ExternalDatabaseTransactionError is used to indicate an attempt to commit/rollback a database transaction failed.</body></comment><class><name>TooManyActiveConnections</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.TooManyActiveConnections</class-id><body>TooManyActiveConnections is used to indicate that the driver for this connection already has the maximum number of active connections.</body></comment><class><name>TransactionPhase2Fatal</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.TransactionPhase2Fatal</class-id><body>TransactionPhase2Fatal is used to indicate a fatal error in the second phase of a two-phase commit or rollback.  This usually means that manual recovery will be required to complete the transaction.</body></comment><class><name>InvalidTransactionState</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.InvalidTransactionState</class-id><body>InvalidTransactionState is used to indicate that the application cannot use a function at a given time.</body></comment><class><name>UnsupportedIsolationLevel</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnsupportedIsolationLevel</class-id><body>UnsupportedIsolationLevel is used to indicate that an attempt was made to set an unsupported isolation level.</body></comment><class><name>InvalidTableName</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.InvalidTableName</class-id><body>InvalidTableName is used to indicate that the query specified an invalid table name</body></comment><class><name>DynamicSQLError</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.DynamicSQLError</class-id><body>DynamicSQLError is used to indicate problems in the ANSI-2 exception class named dynamic SQL error.</body></comment><class><name>InvalidParameterMarker</name><environment>Database</environment><super>Database.DynamicSQLError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.InvalidParameterMarker</class-id><body>InvalidParameterMarker is used to indicate that the parameter marker is incorrect.</body></comment><class><name>InvalidSessionState</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.InvalidSessionState</class-id><body>InvalidSessionState is as not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.</body></comment><class><name>UnableToQueryDriverInformation</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnableToQueryDriverInformation</class-id><body>UnableToQueryDriverInformation is used to indicate that driver information could not be queried.</body></comment><class><name>InvalidDescriptorCount</name><environment>Database</environment><super>Database.DynamicSQLError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.InvalidDescriptorCount</class-id><body>InvalidDescriptorCount is used to indicate that there are more input variables in an SQL statement than are found in the bind object.</body></comment><class><name>UnableToAllocateHandle</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnableToAllocateHandle</class-id><body>UnableToAllocateHandle is used to indicate that a handle could not be allocated.</body></comment><class><name>TooManyActiveTransactions</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.TooManyActiveTransactions</class-id><body>TooManyActiveTransactions is used to indicate that the driver for this connection already has the maximum number of active transactions.</body></comment><class><name>TooManyActiveSessions</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.TooManyActiveSessions</class-id><body>TooManyActiveSessions is used to indicate that the connection already has the maximum number of active sessions.</body></comment><class><name>UnableToFetchData</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnableToFetchData</class-id><body>UnableToFetchData is used to indicate that the row or rows could not be fetched.</body></comment><class><name>MissingBindVariable</name><environment>Database</environment><super>Database.UnableToBind</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.MissingBindVariable</class-id><body>MissingBindVariable is used to indicate that a bind variable is missing.</body></comment><class><name>UnableToDescribe</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnableToDescribe</class-id><body>UnableToDescribe is used to indicate that description of a input variable or an output column could not be acquired.</body></comment><class><name>ExternalDatabaseLibraryInaccessible</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ExternalDatabaseLibraryInaccessible</class-id><body>ExternalDatabaseLibraryInaccessible is used to indicate that a driver is not able to access the database library.  Either the OE does not contain the database library or it cannot be found in the search	path for dynamic link libraries.</body></comment><class><name>UnableToExecuteSQL</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnableToExecuteSQL</class-id><body>UnableToExecuteSQL is used to indicate that the prepared SQL text could not be executed.</body></comment><class><name>IndexConflict</name><environment>Database</environment><super>Database.UnableToExecuteSQL</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.IndexConflict</class-id><body>IndexConflict is used to indicate attempt to insert or update an object that has the same index value as another object.</body></comment><class><name>DuplicateIndexesError</name><environment>Database</environment><super>Database.UnableToExecuteSQL</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.DuplicateIndexesError</class-id><body>DuplicateIndexesError is used to indicate attempting to add an index having the same columns as an existing index.</body></comment><class><name>SQLSyntaxError</name><environment>Database</environment><super>Database.UnableToExecuteSQL</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.SQLSyntaxError</class-id><body>SQLSyntaxError is used to indicate that the SQL text could not be prepared.</body></comment><class><name>UnsupportedDriverFunctionality</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnsupportedDriverFunctionality</class-id><body>UnsupportedDriverFunctionality is used to indicate that an attempt was made to use functionality which is not available from the underlying API due to the current execution circumstances.</body></comment><class><name>UnableToOpenCursor</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnableToOpenCursor</class-id><body>UnableToOpenCursor is used to indicate that a cursor could not be opened.</body></comment><class><name>TransactionException</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.TransactionException</class-id><body>TransactionException is used to indicate an error in transaction processing.</body></comment><class><name>UnableToCancelCursor</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnableToCancelCursor</class-id><body>UnableToCancelCursor is used to indicate that an Oracle cursor could not be canceled.  This signal is not proceedable.</body></comment><class><name>ExternalDatabaseResumableException</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ExternalDatabaseResumableException</class-id><body>ExternalDatabaseResumableException is a super class of the external database resumable exceptions.</body></comment><class><name>UnableToFreeResource</name><environment>Database</environment><super>Database.ExternalDatabaseResumableException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnableToFreeResource</class-id><body>UnableToFreeResource is used to indicate that an external resource could not be released/dropped/free'd.</body></comment><class><name>RequiredPassword</name><environment>Database</environment><super>Database.ExternalDatabaseResumableException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.RequiredPassword</class-id><body>RequiredPassword is used to indicate that a password is required in order to connect. This signal is proceedable and expects a password string as the proceedWith: value.</body></comment><class><name>RequiredUsername</name><environment>Database</environment><super>Database.ExternalDatabaseResumableException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.RequiredUsername</class-id><body>RequiredUsername is used to indicate that a username is required in order to connect. This signal is proceedable and expects a username string as the proceedWith: value.</body></comment><class><name>UnableToCloseCursor</name><environment>Database</environment><super>Database.ExternalDatabaseResumableException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnableToCloseCursor</class-id><body>UnableToCloseCursor is used to indicate that the Oracle cursor could not be closed.  This signal is proceedable.</body></comment><class><name>NoDefaultConnection</name><environment>Database</environment><super>Database.ExternalDatabaseResumableException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.NoDefaultConnection</class-id><body>NoDefaultConnection is used to report that ExternalDatabaseConnection doesn't know	which Connection to use for a new connection.</body></comment><class><name>InvalidConnectionState</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.InvalidConnectionState</class-id><body>InvalidConnectionState is used to indicate that the application cannot use a function at a given time.</body></comment><class><name>RowIsReferencedError</name><environment>Database</environment><super>Database.UnableToExecuteSQL</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.RowIsReferencedError</class-id><body>RowIsReferencedError is used to indicate that a row may not be deleted nor the primary key changed because it is still referenced.</body></comment><class><name>RequiredEnvironment</name><environment>Database</environment><super>Database.ExternalDatabaseResumableException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.RequiredEnvironment</class-id><body>RequiredEnvironment is used to report that the environment is a required parameter by this driver and no default was specified.</body></comment><class><name>ConnectionException</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ConnectionException</class-id><body>ConnectionException is raised to indicate problems in the ANSI-2 	exception class named connection exception.</body></comment><class><name>CouldNotResolveServiceName</name><environment>Database</environment><super>Database.ConnectionException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.CouldNotResolveServiceName</class-id><body>CouldNotResolveServiceName is raised to indicate that the service (or TNS alias) specified when trying to connect does not exist.</body></comment><class><name>ConnectionProfile</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name driverClassName environment userName password originalName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Connection Dialog</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ConnectionProfile</class-id><body>An instances of ConnectionProfile is a set of database connection parameters. In other words, a profile represents future database connection(s). The difference between a profile and a connection is that a profile can be incomplete--for example have no connection type (driverClassName) set. It also has a human-readable name.ConnectionProfiles are mostly created and manipulated by ConnectionDialogs.Instance Variables:	name	&lt;String | nil&gt;	A human-readable string of arbitrary format used by the UI to identify profiles.	driverClassName	&lt;Symbol | nil&gt;	The name of the ExternalDatabaseConnection subclass to instantiate to create the connection.	environment	&lt;String | nil&gt;	The connection environment string.	userName	&lt;String | nil&gt;	The database user name.	password	&lt;String | nil&gt;	The database user's password	originalName	&lt;String | nil&gt;	A duplicate of the original value of &lt;name&gt;. The name may be reset to nil by a connection dialog while a profile is being modified, yet this saved value allows to remember the original name to save the profile afterwards.</body></comment><class><name>UnableToConnectToSQLserver</name><environment>Database</environment><super>Database.ConnectionException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnableToConnectToSQLserver</class-id><body>UnableToConnectToSQLserver is used to indicate that the connection cannot be made to the database server.  This signal is used when it is the server that is the cause of the failure.  If it is possible to segregate the errors, an	unableToConnectToSQLEnvironmentSignal should be used.</body></comment><class><name>AuthenticationFailure</name><environment>Database</environment><super>Database.ConnectionException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.AuthenticationFailure</class-id><body>AuthenticationFailure is raised when the server failed to authenticate the username and/or password</body></comment><class><name>UnableToConnectToSQLenvironment</name><environment>Database</environment><super>Database.UnableToConnectToSQLserver</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnableToConnectToSQLenvironment</class-id><body>UnableToConnectToSQLenvironmentS is used to indicate that the connection cannot be made to the database environment for some reason other than the server itself.  This signal is used when it is possible to segregate the error causes, otherwise	unableToConnectToSQLserverSignal should be used.</body></comment><class><name>UnableToDisconnect</name><environment>Database</environment><super>Database.ExternalDatabaseResumableException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnableToDisconnect</class-id><body>UnableToDisconnect is used to indicate that an error occurred when trying to end the connection.   This signal is proceedable.</body></comment><class><name>ObjectLocked</name><environment>Database</environment><super>Database.UnableToExecuteSQL</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ObjectLocked</class-id><body>ObjectLocked is used to indicate that an object is locked when attempting to change it in the database</body></comment><class><name>ConnectionNotOpen</name><environment>Database</environment><super>Database.ConnectionException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ConnectionNotOpen</class-id><body>ConnectionNotOpen is raised to indicate that the connection does not have a connection to the SQL-environment.</body></comment><class><name>ExternalDatabaseAnswerStream</name><environment>Database</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session nextRow </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ExternalDatabaseAnswerStream</class-id><body>ExternalDatabaseAnswerStream is the class for receiving rows returned from an SQL select statement or stored procedure.Implementation Details:	ExternalDatabaseAnswerStream is a subclass of Stream since it is not	practical to transparently support the skip functionality of PeekableStream	and it does not have a collection as is assumed by PositionableStream.Instance Variables:	session			&lt;ExternalDatabaseSession | nil&gt;		Holds the reference to the parent of the answer stream, or nil if the		answer stream is no longer connected (as will happen at end-of-stream).	nextRow			&lt;Object | nil&gt;		Caches the next object to be returned.  The object will be an instance		of the bindOutput object, if one was provided, otherwise it will be an		instance of Array.</body></comment><class><name>ExternalDatabaseTransaction</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>memberCountHolder remainingCountHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ExternalDatabaseTransaction</class-id><body>Class ExternalDatabaseTransaction is a private abstract class used by the external database interface to manage transaction services on behalf of one or more connections. ExternalDatabaseTransaction reduces the differences between independent and coordinated (sometimes called distributed) database transaction styles.  Independent transactions limit the unit of work to a single connection with a database.  Coordinated transactions allow multiple concurrent connections to comprise the unit of work.  For either independent or coordinated transactions, commiting or aborting all changes made during the unit of work should be atomic.ExternalDatabaseTransaction unifies these two transaction styles by allowing multiple connections (of the same driver) to be coordinated whether or not there is direct support from the underlying database system.  A *two-phase commit* protocol is required to assure atomicity for the unit of work. When a two-phase commit protocol is not available, a less rigorous serial broadcast strategy is used.  In this approach, each connection is asked to commit or rollback in turn.  If there is a system or network failure before all have completed the work, it is possible that not all will perform the same action to complete the transaction.  The application is responsible for recovery in the event that not all commits are completed.Implementation Considerations:Participation relationships:	An instance of the connection subclasses will participate in an instance of the	transaction subclass.Inherited instance variables:	stateHolder			&lt;ValueHolder on: (#xactNo | #xactYes | #committing | #aborting | #paused)&gt;		The state variable is used to track the legal operations on transactions.	traceStream		&lt;WriteStream on: String&gt;		A private stream used for preparing complex trace entries.	traceLevel  &lt;SmallInteger&gt;		The trace level, copied from the class side on instance creation.  If zero, tracing		is disabled.	participants		&lt;WeakArray of: ExternalDatabaseConnection&gt;		The connection instances that are coordinated via the transaction instance.	participantsSemaphore	&lt;RecursionLock&gt;		Used for mutual exclusion protection on uses of the participants array. Instance variables:	memberCountHolder	&lt;ValueHolder on: SmallInteger&gt;		A count of the number of connections that are members of the current transaction.	remainingCountHolder	&lt;ValueHolder on: SmallInteger&gt;		A count of the number of connections that remain members of the current transaction.		If this number is less than the number held in memberCount, we are in the		#committed or #aborting states.  This will persist until the last executor is heard from.Subclasses must implement the following messages	instance protocol		private-library calls			beginExternal			commitExternal			rollbackExternal </body></comment><shared-variable><name>TraceLevel</name><environment>Database.ExternalDatabaseFramework</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Database</package></attributes></shared-variable><shared-variable><name>TraceSequencer</name><environment>Database.ExternalDatabaseFramework</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Database</package></attributes></shared-variable><shared-variable><name>TraceCollector</name><environment>Database.ExternalDatabaseFramework</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Database</package></attributes></shared-variable><shared-variable><name>PlatformType</name><environment>Database.ExternalDatabaseConnection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Database</package></attributes></shared-variable><shared-variable><name>DefaultConnection</name><environment>Database.ExternalDatabaseConnection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Database</package></attributes></shared-variable><shared-variable><name>StandardSignals</name><environment>Database.ExternalDatabaseConnection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Database</package></attributes></shared-variable><shared-variable><name>DefaultEnvironment</name><environment>Database.ExternalDatabaseConnection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Database</package></attributes></shared-variable><shared-variable><name>LastUsedProfile</name><environment>Database.ConnectionDialog</environment><private>false</private><constant>false</constant><category>profiles</category><initializer>nil</initializer><attributes><package>Database</package></attributes></shared-variable><shared-variable><name>Profiles</name><environment>Database.ConnectionDialog</environment><private>false</private><constant>false</constant><category>profiles</category><initializer>OrderedCollection new</initializer><attributes><package>Database</package></attributes></shared-variable><methods><class-id>Database.ConnectionDialog</class-id> <category>aspects</category><body package="Database" selector="connectionProfileHolder">connectionProfileHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^connectionProfileHolder isNil		ifTrue:			[connectionProfileHolder := String new asValue]		ifFalse:			[connectionProfileHolder]</body><body package="Database" selector="connectionProfileListHolder">connectionProfileListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^connectionProfileListHolder isNil		ifTrue:			[connectionProfileListHolder := List new asValue]		ifFalse:			[connectionProfileListHolder]</body><body package="Database" selector="databaseHolder">databaseHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^databaseHolder isNil		ifTrue:			[databaseHolder := String new asValue]		ifFalse:			[databaseHolder]</body><body package="Database" selector="databaseListHolder">databaseListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^databaseListHolder isNil		ifTrue:			[databaseListHolder := List new asValue]		ifFalse:			[databaseListHolder]</body><body package="Database" selector="environmentHolder">environmentHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^environmentHolder isNil		ifTrue:			[environmentHolder := String new asValue]		ifFalse:			[environmentHolder]</body><body package="Database" selector="environmentListHolder">environmentListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^environmentListHolder isNil		ifTrue:			[environmentListHolder := List new asValue]		ifFalse:			[environmentListHolder]</body><body package="Database" selector="passwordHolder">passwordHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^passwordHolder isNil		ifTrue:			[passwordHolder := String new asValue]		ifFalse:			[passwordHolder]</body><body package="Database" selector="userNameHolder">userNameHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^userNameHolder isNil		ifTrue:			[userNameHolder := String new asValue]		ifFalse:			[userNameHolder]</body><body package="Database" selector="userNameListHolder">userNameListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^userNameListHolder isNil		ifTrue:			[userNameListHolder := List new asValue]		ifFalse:			[userNameListHolder]</body></methods><methods><class-id>Database.ConnectionDialog</class-id> <category>private-profile list</category><body package="Database" selector="addOrReplaceProfile:">addOrReplaceProfile: aProfile	"If there is a profile with the same name as that of the argument,	replace it with the argument."	(self class profiles includes: aProfile) ifTrue: [self class profiles remove: aProfile].	self class profiles add: aProfile.</body><body package="Database" selector="allProfiles">allProfiles	^self class profiles copyWith: self lastUsedProfile</body><body package="Database" selector="currentProfile">currentProfile	^currentProfileHolder value</body><body package="Database" selector="currentProfile:">currentProfile: aProfile	currentProfileHolder value: aProfile.	self connectionProfileHolder value:		((self class profiles anySatisfy: [:some | some name = aProfile name])			ifTrue: [aProfile name]			ifFalse: [nil])</body><body package="Database" selector="deleteProfileNamed:">deleteProfileNamed: aString	| profile |	profile := self class profiles detect: [:some | some name = aString].	self class profiles remove: profile</body><body package="Database" selector="lastUsedProfile">lastUsedProfile	LastUsedProfile isNil ifTrue:		[LastUsedProfile := self createNewProfile].	^LastUsedProfile</body><body package="Database" selector="updateProfileList">updateProfileList	self connectionProfileListHolder value: self knownProfileNames</body></methods><methods><class-id>Database.ConnectionDialog</class-id> <category>private</category><body package="Database" selector="createNewProfile">createNewProfile	| profile databaseNames |	profile := ConnectionProfile new.	databaseNames := self knownDatabases.	databaseNames isEmpty ifFalse:		[profile driverClassName: databaseNames first].	^profile</body><body package="Database" selector="knownDatabases">knownDatabases	^((ExternalDatabaseConnection allSubclasses select: [:cl | cl kind notNil])		asSortedCollection: [:a :b | a kind &lt;= b kind])			collect: [:each | each name]</body><body package="Database" selector="knownEnvironmentStrings">knownEnvironmentStrings	^(self allProfiles collect: [:each | each environment]) asSet</body><body package="Database" selector="knownProfileNames">knownProfileNames	^(self class profiles collect: [:each | each name]) asSortedCollection</body><body package="Database" selector="knownUserNames">knownUserNames	"Collect user names used in the existing connection profiles."	^(self allProfiles collect: [:each | each userName]) asSet</body><body package="Database" selector="resetProfileName">resetProfileName	self currentProfile resetName.	self connectionProfileHolder value: nil.	self profileChanged</body></methods><methods><class-id>Database.ConnectionDialog</class-id> <category>actions</category><body package="Database" selector="connect">connect	LastUsedProfile := self currentProfile.	self accept value: true</body><body package="Database" selector="deleteProfile">deleteProfile	| nameToDelete |	nameToDelete := self connectionProfileHolder value.	nameToDelete isNil ifTrue: [^self].	(Dialog confirm: (#GenKeyDeleteProfile &lt;&lt; #database &gt;&gt; 'Are you sure you want to delete this connection profile?')) ifFalse: [^self].	self 		deleteProfileNamed: nameToDelete;		currentProfile: self createNewProfile;		updateProfileList</body><body package="Database" selector="saveProfile">saveProfile	| name savedProfile |	name := Dialog request: (#ProfileName &lt;&lt; #database &gt;&gt; 'Profile name:') initialAnswer: self currentProfile originalName.	name isEmpty ifTrue: [^self].	self currentProfile name: name.	savedProfile := self currentProfile copy.	self 		addOrReplaceProfile: savedProfile;		currentProfile: self currentProfile;		updateProfileList</body></methods><methods><class-id>Database.ConnectionDialog</class-id> <category>notifications</category><body package="Database" selector="databaseChanged">databaseChanged	self resetProfileName</body><body package="Database" selector="environmentChanged">environmentChanged	self resetProfileName</body><body package="Database" selector="passwordChanged">passwordChanged	self resetProfileName</body><body package="Database" selector="profileChanged">profileChanged	| hasName |	hasName := self currentProfile name notNil.	self builder window notNil ifTrue:		[(self builder componentAt: #saveProfile) isEnabled: hasName not.		(self builder componentAt: #deleteProfile) isEnabled: hasName.		(self builder componentAt: #connect) isEnabled: self currentProfile isValid]</body><body package="Database" selector="profileSelected">profileSelected	| name profile |	name := self connectionProfileHolder value.	name isNil ifTrue: [^self].	profile := self class profiles detect: [:some | some name = name].	currentProfileHolder value: profile copy</body><body package="Database" selector="userNameChanged">userNameChanged	self resetProfileName</body></methods><methods><class-id>Database.ConnectionDialog</class-id> <category>initialize-release</category><body package="Database" selector="initialize">initialize	super initialize.	self initializeAspects.	self 		updateProfileList;		currentProfile: self lastUsedProfile copy.	self databaseListHolder value: self knownDatabases.	self environmentListHolder value: 		self knownEnvironmentStrings asSortedCollection.	self userNameListHolder value:		self knownUserNames asSortedCollection.	self connectionProfileHolder onChangeSend: #profileSelected to: self.	currentProfileHolder onChangeSend: #profileChanged to: self</body><body package="Database" selector="initializeAspects">initializeAspects	currentProfileHolder := ValueHolder new.	databaseHolder := self profileAspect: #driverClassName.	environmentHolder := self profileAspect: #environment.	userNameHolder := self profileAspect: #userName.	passwordHolder := self profileAspect: #password</body><body package="Database" selector="postBuildWith:">postBuildWith: aBuilder	#(databaseCombo environmentCombo userNameCombo passwordField) do:		[:widgetName |		(builder componentAt: widgetName) 			widget controller continuousAccept: true].	self profileChanged "cause update"</body><body package="Database" selector="profileAspect:">profileAspect: aSymbol	^(AspectAdaptor forAspect: aSymbol)		subjectChannel: currentProfileHolder;		yourself</body></methods><methods><class-id>Database.ConnectionDialog class</class-id> <category>utilities</category><body package="Database" selector="connect:">connect: aProfile	"Connect a ConnectionProfile (presumably selected using the dialog)	and answer the resulting connection or nil if connection fails. In case	of failure, show a dialog box. See also #unsafeConnect:."	^Cursor database showWhile: 		[[self unsafeConnect: aProfile]			on: ExternalDatabaseConnection externalDatabaseErrorSignal			do: [:ex |				Dialog warn: (self messageFor: ex from: aProfile).				ex return: nil]]</body><body package="Database" selector="messageFor:from:">messageFor: exception from: aProfile	"Answer a suitable message to display to the user (a String)	to explain the exception."	| parameter message |	(exception  isMemberOf: (aProfile driverClass authenticationFailureSignal))		ifTrue: [^exception errorString].	((parameter := exception parameter) notNil 		and: [parameter isEmpty not 		and: [(message := (parameter at: 1) dbmsErrorString) notNil "ugh"		and: [message isEmpty not]]])			ifTrue: [^message]			ifFalse: [^exception errorString]</body><body package="Database" selector="unsafeConnect:">unsafeConnect: aProfile	"Similar to #connect: but without the error handling.	Connection exceptions are not intercepted and are available	for the client code to take care of."	| connection |	connection := aProfile asConnection.	connection connect: aProfile password.	^connection</body></methods><methods><class-id>Database.ConnectionDialog class</class-id> <category>accessing</category><body package="Database" selector="chooseProfile">chooseProfile	"Open the connection dialog. After it is closed answer either the	connection profile with parameters selected by the user if it was accepted	or nil if the dialog was cancelled."	| instance |	instance := self new.	^instance open		ifTrue: [instance currentProfile]		ifFalse: [nil]</body><body package="Database" selector="chooseProfileInitially:">chooseProfileInitially: aProfileOrNil	"Open the connection dialog. After it is closed answer either the	connection profile with parameters selected by the user if it was accepted	or nil if the dialog was cancelled."	| instance |	instance := self new.	aProfileOrNil notNil ifTrue: [instance currentProfile: aProfileOrNil].	^instance open		ifTrue: [instance currentProfile]		ifFalse: [nil]</body><body package="Database" selector="lastUsedProfile">lastUsedProfile	^LastUsedProfile</body><body package="Database" selector="profiles">profiles	^Profiles</body></methods><methods><class-id>Database.ConnectionDialog class</class-id> <category>convenience</category><body package="Database" selector="openConnection">openConnection	"Open the dialog and then open the database connection that was selected.	Answer the opened connection or nil if either the dialog was cancelled or	the connection failed."	| profile |	profile := self chooseProfile.	^profile isNil		ifTrue: [nil]		ifFalse: [self connect: profile]</body><body package="Database" selector="openConnectionIfCancelled:">openConnectionIfCancelled: aBlock	"Open the dialog and then open the database connection that was selected.	Answer the opened connection or nil if the connection failed.	Evaluate aBlock if the dialog was cancelled."	| profile |	profile := self chooseProfile.	^profile isNil		ifTrue: [aBlock value]		ifFalse: [self connect: profile]</body></methods><methods><class-id>Database.ExternalDatabaseError</class-id> <category>accessing</category><body package="Database" selector="dbmsErrorCode">dbmsErrorCode	"Answer the error code used by the dbms api which lead to this error report."	^dbmsErrorCode</body><body package="Database" selector="dbmsErrorString">dbmsErrorString	"Answer the text associated with the code value returned from the dbms api. 	Not all dbms api make this information available."	^dbmsErrorString</body><body package="Database" selector="osErrorCode">osErrorCode	"Answer the error code provided by the dbms api which is attributed to the underlying	operating system.  This is usually just detail information about the dbmsErrorCode."	^osErrorCode</body><body package="Database" selector="osErrorString">osErrorString	"Answer the text associated with the osErrorCode returned from the dbms api. 	Not all systems make this information available."	^osErrorString</body></methods><methods><class-id>Database.ExternalDatabaseError</class-id> <category>private-accessing</category><body package="Database" selector="dbmsErrorCode:">dbmsErrorCode: aSmallInteger	dbmsErrorCode := aSmallInteger</body><body package="Database" selector="dbmsErrorString:">dbmsErrorString: aString	dbmsErrorString := aString</body><body package="Database" selector="osErrorCode:">osErrorCode: aSmallInteger	osErrorCode := aSmallInteger</body><body package="Database" selector="osErrorString:">osErrorString: aString	osErrorString := aString</body></methods><methods><class-id>Database.ByteFieldDescriptor</class-id> <category>initialize-release</category><body package="Database" selector="template:max:">template: aTemplate max: anInteger	template := aTemplate.	max := anInteger</body></methods><methods><class-id>Database.ByteFieldDescriptor</class-id> <category>accessing</category><body package="Database" selector="MaxColumnConstraint">MaxColumnConstraint	^max</body><body package="Database" selector="Template">Template	^template</body><body package="Database" selector="Type">Type	^template class maxColumnConstraint: max</body><body package="Database" selector="yourself">yourself	^template</body></methods><methods><class-id>Database.ByteFieldDescriptor</class-id> <category>testing</category><body package="Database" selector="includes:">includes: string	^false</body><body package="Database" selector="isKindOf:">isKindOf: aClass	"Answer a Boolean as to whether the class, aClass, is a superclass or class of	the receiver."	template class == aClass		ifTrue: [^true]		ifFalse: [^template class inheritsFrom: aClass]</body></methods><methods><class-id>Database.ByteFieldDescriptor</class-id> <category>printing</category><body package="Database" selector="do:">do: block	'&lt;byte field&gt;' do: [:c | block value: c]</body><body package="Database" selector="printOn:">printOn: stream	super printOn: stream.	max notNil		ifTrue:			[stream nextPutAll: (#Max &lt;&lt; #database &gt;&gt; ' (max=') asString.			max printOn: stream.			stream nextPut: $)]</body></methods><methods><class-id>Database.AdHocQueryTool</class-id> <category>initialize-release</category><body package="Database" selector="initialize">initialize	| conn |	self queryModel onChangeSend: #changedQuery to: self.	self tableModel columnLabelsArray: #().	(conn := ExternalDatabaseConnection defaultConnection) notNil		ifTrue: [ self whichDriver: conn ].	self blockFactor: 1.	self usernameModel value: (UISettings preferenceFor: #dbDevUsername).	self passwordModel value: (UISettings preferenceFor: #dbDevPassword).	self environmentModel value: (UISettings preferenceFor: #dbDevEnvironment).	self connectedStatusHolder onChangeSend: #connectedStatusChanged to: self.	self executeStatusHolder onChangeSend: #executeStatusChanged to: self.	self moreAnswersStatusHolder onChangeSend: #moreAnswersStatusChanged to: self.</body></methods><methods><class-id>Database.AdHocQueryTool</class-id> <category>accessing</category><body package="Database" selector="blockFactor">blockFactor	^self blockFactorModel value</body><body package="Database" selector="blockFactor:">blockFactor: anInteger	self blockFactorModel value: (anInteger &gt; 1 ifTrue: [anInteger] ifFalse: [ 1 ])</body><body package="Database" selector="environment">environment	^self environmentModel value</body><body package="Database" selector="password">password	^self passwordModel value</body><body package="Database" selector="query">query	^self queryModel value</body><body package="Database" selector="username">username	^self usernameModel value</body><body package="Database" selector="whichDriver">whichDriver	^self whichDriverModel value</body><body package="Database" selector="whichDriver:">whichDriver: aSymbol	self whichDriverModel value: aSymbol</body></methods><methods><class-id>Database.AdHocQueryTool</class-id> <category>actions</category><body package="Database" selector="changedQuery">changedQuery	connection notNil ifTrue:		[ self executeStatusHolder value: self query isEmpty not ]</body><body package="Database" selector="connect">connect	| spec dialog |	spec := self class interfaceSpecFor: #connectSpec.	dialog := SimpleDialog new.	dialog builder source: self.	dialog parentView: builder window.	dialog allButOpenFrom: spec.	dialog builder openDialog.	dialog accept value ifFalse: [^nil].	self whichDriver isNil 		ifTrue: 			[Dialog warn: #selectDatabase &lt;&lt; #database 						&gt;&gt; 'You must select a database to connect to.'				for: builder window.			^nil].	connection := self whichDriver asQualifiedReference value new.	connection username: self username.	connection environment: self environment.	Cursor database showWhile: 			[[connection connect: self password] 				on: connection class externalDatabaseErrorSignal				do: 					[:exception | 					self reportError: (self messageFor: exception).					connection := nil.					exception return]].	self connectedStatusHolder value: connection notNil</body><body package="Database" selector="disconnect">disconnect	Cursor database showWhile: [connection disconnect].	session := nil.	connection := nil.	self connectedStatusHolder value: false</body><body package="Database" selector="execute">execute	| discardSession |	discardSession := false.	Cursor database showWhile: 			[			[session isNil ifTrue: [session := connection getSession connect].			session prepare: self query asString.			session blockFactor: self blockFactor.			session execute.			answerStream := session answer.			self nextAnswer] 					on: connection class externalDatabaseErrorSignal					do: 						[:exception | 						self reportError: (self messageFor: exception).						discardSession := true.						exception return]].	discardSession ifTrue: [session notNil ifTrue: [session disconnect]]</body><body package="Database" selector="fetchBuffers">fetchBuffers	| saveBlockFactor spec dialog |	saveBlockFactor := self blockFactor.	"Raise dialog."	spec := self class interfaceSpecFor: #buffersSpec.	dialog := SimpleDialog new.	dialog builder source: self.	dialog parentView: builder window.	dialog allButOpenFrom: spec.	dialog builder openDialog.	"Restore original value?"	(dialog accept value) ifFalse:		[ self blockFactor: saveBlockFactor ]</body><body package="Database" selector="nextAnswer">nextAnswer	| cols list |	cols := Array new: 0.	list := Array new: 0.	answerStream == #noMoreAnswers ifFalse:		[ answerStream == #noAnswerStream ifFalse:			[ cols := answerStream columnDescriptions.			list := answerStream upToEnd ].		self updateTable: list column: cols.		(answerStream := session answer) == #noMoreAnswers			ifTrue:				[ self moreAnswersStatusHolder value: false.				session disconnect.				session := nil ]			ifFalse:				[ self moreAnswersStatusHolder value: true ] ].</body></methods><methods><class-id>Database.AdHocQueryTool</class-id> <category>aspects</category><body package="Database" selector="blockFactorModel">blockFactorModel	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^blockFactorModel isNil ifTrue: [blockFactorModel := 0 asValue] ifFalse: [blockFactorModel]</body><body package="Database" selector="connectedStatusHolder">connectedStatusHolder	^connectedStatusHolder isNil ifTrue: [connectedStatusHolder := false asValue] ifFalse: [connectedStatusHolder]</body><body package="Database" selector="environmentModel">environmentModel	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^environmentModel isNil ifTrue: [environmentModel := String new asValue] ifFalse: [environmentModel]</body><body package="Database" selector="executeStatusHolder">executeStatusHolder	^executeStatusHolder isNil ifTrue: [executeStatusHolder := false asValue] ifFalse: [executeStatusHolder]</body><body package="Database" selector="moreAnswersStatusHolder">moreAnswersStatusHolder	^moreAnswersStatusHolder isNil ifTrue: [moreAnswersStatusHolder := false asValue] ifFalse: [moreAnswersStatusHolder]</body><body package="Database" selector="passwordModel">passwordModel	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^passwordModel isNil ifTrue: [passwordModel := String new asValue] ifFalse: [passwordModel]</body><body package="Database" selector="queryModel">queryModel	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^queryModel isNil ifTrue: [queryModel := String new asValue] ifFalse: [queryModel]</body><body package="Database" selector="tableModel">tableModel	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^tableModel isNil ifTrue: [tableModel := TableInterface new selectionInTable: SelectionInTable new] ifFalse: [tableModel]</body><body package="Database" selector="usernameModel">usernameModel	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^usernameModel isNil ifTrue: [usernameModel := String new asValue] ifFalse: [usernameModel]</body><body package="Database" selector="whichDriverModel">whichDriverModel	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^whichDriverModel isNil ifTrue: [whichDriverModel := nil asValue] ifFalse: [whichDriverModel]</body></methods><methods><class-id>Database.AdHocQueryTool</class-id> <category>interface opening</category><body package="Database" selector="postOpenWith:">postOpenWith: aBuilder 	"This message is sent by the builder after it has opened a completed 	window."	"The disconnect, execute, and next answer buttons are enabled under program control."	| menuBar |	"We want to notice any character typed into the query so that an accept isn't required."	(aBuilder componentAt: #query) widget controller continuousAccept: true.	"Arrange for the menu items to be enabled correctly."	menuBar := aBuilder menuAt: #menuBar.	(menuBar atNameKey: #connect) enabled: [self connectedStatusHolder value not].	(menuBar atNameKey: #disconnect) enabled: self connectedStatusHolder.	(menuBar atNameKey: #execute) enabled: self executeStatusHolder.	(menuBar atNameKey: #nextAnswer) enabled: self moreAnswersStatusHolder</body></methods><methods><class-id>Database.AdHocQueryTool</class-id> <category>private</category><body package="Database" selector="connectedStatusChanged">connectedStatusChanged	| connected |	connected := self connectedStatusHolder value.	(builder componentAt: #connect) isEnabled: connected not.	(builder componentAt: #disconnect) isEnabled: connected.	connected		ifTrue:			[ self query isEmpty ifFalse:				[ self executeStatusHolder value: true ] ]		ifFalse:			[ self executeStatusHolder value: false.			self moreAnswersStatusHolder value: false ]</body><body package="Database" selector="executeStatusChanged">executeStatusChanged	(builder componentAt: #execute) isEnabled: self executeStatusHolder value</body><body package="Database" selector="installedDBConnectsMenu">installedDBConnectsMenu	| rawList menu |	rawList := (ExternalDatabaseConnection allSubclasses 				select: [:cl | cl kind notNil]) 					asSortedCollection: [:a :b | a kind &lt;= b kind].	menu := Menu new.	rawList do: 		[:each |		menu 			addItemLabel: each kind			value: each fullName].	^menu asValue</body><body package="Database" selector="messageFor:">messageFor: exception	| errs msg |	exception == connection class authenticationFailureSignal ifTrue:		[ ^exception errorString ].	( (errs := exception parameter) notNil	and: [ errs isEmpty not	and: [ (msg := (exception parameter at: 1) dbmsErrorString) notNil	and: [ msg isEmpty not ] ] ] )		ifTrue: [ ^msg ]		ifFalse: [ ^exception errorString ]</body><body package="Database" selector="moreAnswersStatusChanged">moreAnswersStatusChanged	(builder componentAt: #nextAnswer) isEnabled: self moreAnswersStatusHolder value</body><body package="Database" selector="reportError:">reportError: errorText	| spec dialog |	"Raise dialog."	spec := self class interfaceSpecFor: #reportErrorSpec.	dialog := SimpleDialog new.	dialog builder source: self.	dialog builder aspectAt: #errorText put: errorText asValue.	dialog parentView: builder window.	dialog allButOpenFrom: spec.	dialog builder window label: (#errDatabaseError &lt;&lt; #database &gt;&gt; 'Database Error').	(dialog builder componentAt: #errorText) widget controller		keyboardHook: [:ev :ctrlr | nil ].	"Deny type-in, but allow menu for copy"	dialog builder openDialog</body><body package="Database" selector="updateTable:column:">updateTable: list column: descrs	| table colAdaptors tableAdaptor colNames colWidths col mwidth width |	table := self tableModel.	colAdaptors := RowAdaptor adaptForIndexes: (1 to: descrs size).	tableAdaptor := TableAdaptor on: list adaptors: colAdaptors.	colNames := List new.	colWidths := List new.	mwidth := 'm' asComposedText width.	"I.e. width of representative character"	1 to: descrs size		do: [ :index |			col := descrs at: index.			colNames add: col name.			width := 36 max: (col name asComposedText width + 1).			width := width max: ((mwidth * col maxColumnConstraint asInteger) min: (3 * 72)).			colWidths add: width ].	descrs size &gt; 0		ifTrue:	[ table columnWidths: colWidths.				table columnLabelsArray: colNames ].	table columnLabelsFormats: #left.	table selectionInTable table: tableAdaptor</body></methods><methods><class-id>Database.AdHocQueryTool</class-id> <category>events</category><body package="Database" selector="noticeOfWindowClose:">noticeOfWindowClose: aWindow 	"The ApplicationWindow aWindow is in the process of closing. 	Disconnect from the database if needed."	connection notNil ifTrue:		[ self disconnect ]</body></methods><methods><class-id>Database.AdHocQueryTool class</class-id> <category>class initialization</category><body package="Database" selector="initialize">initialize	"AdHocQueryTool initialize"		self initializeSettings</body><body package="Database" selector="initializeSettings">initializeSettings	"AdHocQueryTool initializeSettings"		UISettings addPreferenceSection: #addDatabaseSectionTo:development:runtime:</body></methods><methods><class-id>Database.AdHocQueryTool class</class-id> <category>private</category><body package="Database" selector="obsolete">obsolete	"Remove the associated settigns and slices from the UISettings."	super obsolete.	UISettings removePreferenceSection: #addDatabaseSectionTo:development:runtime:</body></methods><methods><class-id>Database.ExternalDatabaseColumnDescription</class-id> <category>accessing</category><body package="Database" selector="index">index	"Answer the ordinal number of the column, or nil if unknown."	^index</body><body package="Database" selector="maxColumnConstraint">maxColumnConstraint	"Answer the size of the buffer required to hold data for the column, or nil if unknown."	^length</body><body package="Database" selector="name">name	"Answer the name of the column, or nil if unknown."	^name</body><body package="Database" selector="nullable">nullable	"Answer true or false to indicate whether the column admits NULL, or nil if unknown."	^nullable</body><body package="Database" selector="precision">precision	"Answer the decimal precision of the column, or nil if unknown."	^precision</body><body package="Database" selector="scale">scale	"Answer the decimal scale of the column, or nil if unknown."	^scale</body><body package="Database" selector="type">type	"Answer the Smalltalk class which will be used to hold data	from the column, or nil if unknown."	^type</body></methods><methods><class-id>Database.ExternalDatabaseColumnDescription</class-id> <category>printing</category><body package="Database" selector="printOn:">printOn: aStream 	"Append to the argument aStream a sequence of characters that identifies the 	receiver."	| colName colType |	super printOn: aStream.	aStream nextPut: $(.	(colName := self name) notNil ifTrue:		[ aStream			nextPutAll: (#Name &lt;&lt; #database &gt;&gt; ' name=') asString;			nextPutAll: colName].	(colType := self type) notNil ifTrue:		[ aStream nextPutAll: (#Type &lt;&lt; #database &gt;&gt; ' type=') asString.		colType printOn: aStream ].	aStream nextPutAll: ' )'</body></methods><methods><class-id>Database.ExternalDatabaseColumnDescription</class-id> <category>private-accessing</category><body package="Database" selector="index:">index: aNumber	index := aNumber</body><body package="Database" selector="maxColumnConstraint:">maxColumnConstraint: anInteger	length := anInteger</body><body package="Database" selector="name:">name: aString	name := aString</body><body package="Database" selector="nullable:">nullable: aBoolean	nullable := aBoolean</body><body package="Database" selector="precision:">precision: anInteger	precision := anInteger</body><body package="Database" selector="scale:">scale: anInteger	scale := anInteger</body><body package="Database" selector="type:">type: aString	type := aString</body></methods><methods><class-id>Database.ExternalDatabaseBuffer</class-id> <category>initialize-release</category><body package="Database" selector="elementSize:count:databaseType:">elementSize: anElementSize count: aCount databaseType: aDatabaseType	elementSize := anElementSize.	count := aCount.	databaseType := aDatabaseType</body><body package="Database" selector="initialize">initialize	"Initialize an instance of the receiver."	encoding := #default</body></methods><methods><class-id>Database.ExternalDatabaseBuffer</class-id> <category>allocation</category><body package="Database" selector="free">free	"Free the receiver."	bufferPointer notNil ifTrue:		[ bufferPointer freePointer.		bufferPointer := nil ]</body><body package="Database" selector="mallocUsingSelector:">mallocUsingSelector: mallocSelector	"Assert: mallocSelector is either #malloc: or #malloc16:"	bufferPointer := self pointerType perform: mallocSelector with: (count max: 1)</body></methods><methods><class-id>Database.ExternalDatabaseBuffer</class-id> <category>accessing</category><body package="Database" selector="at:">at: anIndex	"Answer the object in the buffer at anIndex."	^self subclassResponsibility</body><body package="Database" selector="at:put:">at: anIndex put: anObject	"Store anObject into the buffer at anIndex."	^self subclassResponsibility</body><body package="Database" selector="count">count	"Answer the receiver's cardinality"	^count</body><body package="Database" selector="databaseType">databaseType	"Answer the receiver's database type."	^databaseType</body><body package="Database" selector="elementSize">elementSize	"Answer the receiver's length"	^elementSize</body><body package="Database" selector="encoding">encoding	"Answer the encoding"	^encoding</body><body package="Database" selector="encoding:">encoding: aSymbol	"Set the encoding type"	encoding := aSymbol</body><body package="Database" selector="pointer">pointer	"Answer the receiver's buffer pointer."	^bufferPointer</body><body package="Database" selector="size">size	"Answer the receiver's size"	^(count max: 1) * elementSize</body><body package="Database" selector="value">value	"Answer the value (or values) held in the buffer"	| array |	count == 0		ifTrue: [ ^self at: 1 ].	array := Array new: count.	1 to: count do:		[ :index | array at: index put: (self at: index) ].	^array</body><body package="Database" selector="value:">value: aValueOrArray	"Store aValueOrArray into the receiver."	| size |	count == 0 ifTrue: [ ^self at: 1 put: aValueOrArray ].	size := aValueOrArray size.	size &gt; count ifTrue: [ ^self error: (#errTooBigForBuffer &lt;&lt; #database &gt;&gt; 'too big for buffer') ].	1 to: size do: [ :index |		self at: index put: (aValueOrArray at: index) ].	size &lt; count		ifTrue: [ (size + 1) to: count do: [ :index |					self at: index put: nil ] ]</body></methods><methods><class-id>Database.ExternalDatabaseBuffer</class-id> <category>private</category><body package="Database" selector="pointerType">pointerType	"Answer the pointer type to use for buffer allocation."	^CArrayType defaultPointer			referentType: CIntegerType char;			numElements: self elementSize.</body></methods><methods><class-id>Database.ExternalDatabaseBuffer class</class-id> <category>instance creation</category><body package="Database" selector="new">new	"Answer an initialized instance of the receiver"	^super new initialize</body></methods><methods><class-id>Database.ExternalDatabaseFramework</class-id> <category>initialize-release</category><body package="Database" selector="initialize">initialize	"Establish initial value for instance variables."	"Subclasses which override must include super initialize."	traceLevel := TraceLevel.	self stateHolder: nil asValue.	self initializeParticipants</body><body package="Database" selector="install">install	"Perform all processing relevant for just returning from a snapshot."	"Assume: reciever is registered."	self installExternal.	self participantsDo: [ :each | each installExternal ]</body></methods><methods><class-id>Database.ExternalDatabaseFramework</class-id> <category>printing</category><body package="Database" selector="printOn:">printOn: aStream 	"Append to the argument aStream a sequence of characters that identifies the 	receiver."	super printOn: aStream.	self isExecutor ifTrue: [ aStream nextPut: $' ]</body></methods><methods><class-id>Database.ExternalDatabaseFramework</class-id> <category>private-accessing</category><body package="Database" selector="state">state	"Answer with the current state of the External Database object."	^stateHolder value</body><body package="Database" selector="state:">state: aSymbol	"Set the current state of the External Database object."	stateHolder setValue: aSymbol</body><body package="Database" selector="stateHolder:">stateHolder: aValueHolder	"Initialize the holder of state information."	stateHolder := aValueHolder</body><body package="Database" selector="traceLevel:">traceLevel: anInteger	traceLevel := anInteger</body></methods><methods><class-id>Database.ExternalDatabaseFramework</class-id> <category>private-activation</category><body package="Database" selector="activate">activate	"Time to revive all connections to external resources."	"Assume: receiver is registered."	"Enforce-quietly: receiver is paused."	self state == #paused ifFalse: [ ^self ].	self acquireExternal notNil		ifTrue:	[ self class register: self ]		ifFalse:	[ self class unregister: self ].	self participantsDo:	[ :each | each activate ]</body><body package="Database" selector="dismiss">dismiss	"Time to release any external resources."	"Assume: receiver is registered."	self class unregister: self.	"Avoid duplication of resource release."	self state == #paused		ifFalse:	[ self dismissExternal ]</body><body package="Database" selector="quiesce">quiesce	"Time to quiesce all connections to external resources."	"Assume: receiver is registered."	"Enforce-quietly: receiver is not paused."	self state == #paused ifTrue: [ ^self ].	[ self participantsDo: [ :each | each quiesce ].	self dismissExternal ]		ensure:			[ self state: #paused ]</body></methods><methods><class-id>Database.ExternalDatabaseFramework</class-id> <category>private-finalization</category><body package="Database" selector="executor">executor	"Answer with the executor."	"Subclassess which want to override to add information to the executor	should use super executor to create the executor initially."	| ex |	"Make a new instance, but all the initialization will happen as part of the executor methods."	ex := self class basicNew.	"The state machine must be exposed to the executor."	ex stateHolder: stateHolder.	"The executor retains the ability to trace"	ex traceLevel: traceLevel.	^ex</body><body package="Database" selector="finalize">finalize	"Release all external resource."	"Enforce-quietly: receiver is not paused."	self state == #paused ifTrue: [^self].	self initializeParticipants.	"It's not necessary to report errors at this time."	[self finalizeExternal] 		on: self class connectionClass externalDatabaseErrorSignal		do: [:ex | ex return]</body><body package="Database" selector="finalizeExternal">finalizeExternal	"Release all external resources."	( traceLevel &gt;= 1 ) ifTrue:		[ self class trace: nil ].	self dismissExternal</body><body package="Database" selector="key">key	"Key value to use when inserting receiver into a handle registry. This value 	needs to be unique within the registry."	^self subclassResponsibility</body></methods><methods><class-id>Database.ExternalDatabaseFramework</class-id> <category>private-library calls</category><body package="Database" selector="acquireExternal">acquireExternal	"Acquire the external resources. If the external resources	cannot be acquired, an exception is raised."	^self subclassResponsibility</body><body package="Database" selector="dismissExternal">dismissExternal	"Release the external resources."	"All activity within this method must function with only the instance	variables defined in the executor object."	^self subclassResponsibility</body><body package="Database" selector="installExternal">installExternal	"Perform return from snapshot processing."	"Subclasses that override should invoke super installExternal."	self state: #paused	"Assure: no dangling CPointers remain."</body></methods><methods><class-id>Database.ExternalDatabaseFramework</class-id> <category>private-participation</category><body package="Database" selector="addParticipant:">addParticipant: aParticipant	"Add aParticipant to the collection of participants in receiver's scope.  A	new participant is added to the collection if it is not already present."	| p new |	participantsSemaphore critical:		[ "Check for and return immediately if already a particpant."		((p := self participants) includes: aParticipant)			ifTrue:	[ ^self ].		new := p class withAll: (p copyWith: aParticipant).		p become: new ]"This method of growing the participants gives the exact same kind of collection.  This is necessary because WeakArray&gt;&gt;copyWith: does not answer another WeakArray."</body><body package="Database" selector="initializeParticipants">initializeParticipants	"Initialize the instance variables which define the participation mechanism."	participants := WeakArray new: 0.	participantsSemaphore := RecursionLock new.	participants addDependent: self</body><body package="Database" selector="participants">participants	"Answer with the collection of participants.  The participants collection	should always be accessed in a critical section controlled with the	participantsSemaphore."	^participants</body><body package="Database" selector="participantsDetect:ifNone:">participantsDetect: aBlock ifNone: exceptionBlock	"Evaluate aBlock with each of the receiver's elements as the argument.	Answer the first element for which aBlock evaluates to true."	"Since the participants are a WeakArray, we also need to skip	over 0 values (the death of a participant will leave a 0)."	^participantsSemaphore critical:		[ (self participants copy)			detect:				[ :each |				(each == 0 or: [ each isExecutor ])					ifTrue: [ false ]					ifFalse: [ aBlock value: each ] ]			ifNone: exceptionBlock ]</body><body package="Database" selector="participantsDo:">participantsDo: aBlock	"Invoke aBlock for each participant."	"Since the participants are a WeakArray, we also need to skip	over 0 values (the death of a participant will leave a 0)."	participantsSemaphore critical:		[ (self participants copy) do:			[ :each |			(each == 0 or: [ each isExecutor ]) ifFalse:				[ aBlock value: each ] ] ]</body><body package="Database" selector="participantsSize">participantsSize	"Answer the size of the participants array."	"Since the participants are a WeakArray, we also need to skip	over 0 values (the death of a participant will leave a 0)."	| total |	participantsSemaphore critical:		[ total := self participants				inject: 0				into: [:subTotal :next |					next == 0 ifTrue: [ subTotal ] ifFalse: [ subTotal + 1] ] ].	^total</body><body package="Database" selector="removeParticipant:">removeParticipant: aParticipant	"Remove aParticipant from the collection of participants in receiver's scope."	| p |	participantsSemaphore critical:		[ ((p := self participants) includes: aParticipant)			ifFalse:	[ ^self ].		p become: (p class withAll: (p copyWithout: aParticipant)) ]"This method of shrinking the participants gives the exact same kind of collection.  This is necessary because WeakArray&gt;&gt;copyWithout: does not answer another WeakArray."</body></methods><methods><class-id>Database.ExternalDatabaseFramework</class-id> <category>private-testing</category><body package="Database" selector="isExecutor">isExecutor	"Answer true if the receiver is really an executor, not the primary object."	^self participants isNil</body></methods><methods><class-id>Database.ExternalDatabaseFramework</class-id> <category>private-tracing</category><body package="Database" selector="emitTrace">emitTrace	"Answer the receiver's trace buffer contents.  Reset the trace stream to be empty."	| trace |	trace := traceStream contents.	traceStream reset.	^trace</body><body package="Database" selector="traceStream">traceStream	"Answer the receiver's trace stream.  Create the stream if necessary."	^traceStream isNil ifTrue: [ traceStream := (String new: 64) writeStream ] ifFalse: [ traceStream ]</body></methods><methods><class-id>Database.ExternalDatabaseFramework</class-id> <category>private-updating</category><body package="Database" selector="update:with:from:">update: anAspectSymbol with: aParameter from: aSender 	"Receive a change notice from an object, denoted by aSender, of whom the receiver is a 	dependent. The argument anAspectSymbol is typically a Symbol that indicates what 	change has occurred and aParameter is additional information."	| p |	(anAspectSymbol == #ElementExpired and: [aSender == self participants]) ifTrue:		[ participantsSemaphore critical:			[ (p := self participants) become: (p class withAll: (p copyWithout: 0)) ] ]</body></methods><methods><class-id>Database.ExternalDatabaseFramework class</class-id> <category>class initialization</category><body package="Database" selector="initialize">initialize	"Establish class variables."	"ExternalDatabaseFramework initialize"	TraceLevel := 0.	TraceSequencer := RecursionLock new.</body></methods><methods><class-id>Database.ExternalDatabaseFramework class</class-id> <category>accessing</category><body package="Database" selector="connectionClass">connectionClass	"Answer the class to use for connection objects associated with receiver."	^self subclassResponsibility</body></methods><methods><class-id>Database.ExternalDatabaseFramework class</class-id> <category>tracing</category><body package="Database" selector="shouldTrace:">shouldTrace: level	"Answer true if tracing is enabled through level."	^self traceLevel &gt;= level</body><body package="Database" selector="trace:">trace: aStringOrNil	"Emit the standard trace header followed by aString (if not nil) into the trace log."	| header when sender depth |	TraceCollector == nil ifTrue: [ ^self ].	header := WriteStream on: (String new: 64).	when := Time dateAndTimeNow.	sender := thisContext sender.	depth := TraceLevel &gt; 4 ifTrue: [ TraceLevel - 4 ] ifFalse: [ 1 ].	"Emit a timestamp"	header		nextPutAll: '{';		"print: (when at: 1);"  nextPutAll: ((when at: 1) printFormat: #(1 2 3 $ 2 2));		nextPutAll: ' ';		print: (when at: 2);		nextPutAll: '} 	'.		"curly-brace, space and a tab"	"Emit a stack trace"	[ depth &gt; 0 ] whileTrue:		[ header			nextPutAll: sender mclass printString;			nextPutAll: '&gt;&gt;';			nextPutAll: sender selector asString.		sender := sender sender.		(depth := depth - 1) &gt; 0 ifTrue:			[ header cr; tab: 6 ] ].	TraceSequencer critical:		[ TraceCollector nextPutAll: header contents; cr.		( aStringOrNil size &gt; 0 ) ifTrue:			[ TraceCollector tab; nextPutAll: aStringOrNil; cr ].		TraceCollector flush ]</body><body package="Database" selector="traceLevel">traceLevel	"Answer the level of tracing that is enabled for this class."	TraceLevel isNil ifTrue:		[ TraceLevel := 0 ].	^TraceLevel</body></methods><methods><class-id>Database.ExternalDatabaseFramework class</class-id> <category>private-activation</category><body package="Database" selector="activate">activate	"Resume operation on suspended database connections."	"Each of the driver classes whose instances hold external resources must	maintain a registry of active and inactive instances so that all such resources	may be released at appropriate times. As each member of the collection is	activated it should reregister."	| registry |	(registry := self registry) isNil		ifTrue:	[ ^self shouldNotImplement ].	registry do:		[ :each | each state == #paused ifTrue: [ each activate ] ]</body><body package="Database" selector="quiesce">quiesce	"Suspend operation on active database connections."	"Each of the driver classes whose instances hold external resources must	maintain a registry of active and inactive instances so that all such resources	may be released at appropriate times. As each member of the collection is	activated it should reregister."	| registry |	(registry := self registry) isNil		ifTrue:	[ ^self shouldNotImplement ].	registry do:		[ :each | each state == #paused ifFalse: [ each quiesce ] ]</body><body package="Database" selector="returnFromSnapshot">returnFromSnapshot	"No external resources can be held at this point.  Reset all appropriate control information	as if operation had been paused."	| registry |	( TraceLevel &gt;= 1 )		ifTrue:	[ self trace: nil ].	(registry := self registry) isNil		ifTrue:	[ ^self shouldNotImplement ].	registry do:		[ :each | each install ]</body></methods><methods><class-id>Database.ExternalDatabaseFramework class</class-id> <category>private-registry</category><body package="Database" selector="initRegistry">initRegistry	"Initialize the registry to the proper form of collection."	self registry: HandleRegistry new.</body><body package="Database" selector="register:">register: sender	"Register the sender."	| registry |	^(registry := self registry) notNil		ifTrue: [ registry register: sender ]</body><body package="Database" selector="registry">registry	"Answer with the registry."	"Subclasses must override if they have registries."	^nil</body><body package="Database" selector="registry:">registry: aCollection 	"Record aCollection as the registry."	^self subclassResponsibility</body><body package="Database" selector="unregister:">unregister: uh 	"Remove the argument from the active registry."	| registry |	(registry := self registry) isNil		ifFalse: [registry unregister: uh]</body></methods><methods><class-id>Database.ExternalDatabaseSession</class-id> <category>initialize-release</category><body package="Database" selector="initialize">initialize	super initialize.	traceLevel := self class traceLevel.	self state: #new.	connection := nil.	self releaseBindings.	allocateForEachRow := true.	useNamedOutputBinding := false.	blockFactor := 1.	rowBuffersHolder := nil asValue</body></methods><methods><class-id>Database.ExternalDatabaseSession</class-id> <category>accessing</category><body package="Database" selector="allocateForEachRow">allocateForEachRow	"Answer whether the answer stream should create a copy of the output	bind object to hold each row."	^allocateForEachRow</body><body package="Database" selector="allocateForEachRow:">allocateForEachRow: aBoolean	"Specify whether the answer stream should create a copy of the output	bind object to hold each row."	allocateForEachRow := aBoolean</body><body package="Database" selector="bindInput">bindInput	"Answer the object from which input values will be 	obtained for host variable references in the SQL text."	^bindInput</body><body package="Database" selector="bindInput:">bindInput: aBindObject 	"Supply aBindObject as the object from which input values should be 	obtained for host variable references in the SQL text.  Host variables	may be specified using either a positional or a named notation.  The	driver may limit to only one form.	When using the positional form (a ?), all host variable references (including	the named ones) are implicitly ordered by their position in the SQL-text.	The n-th variable of aBindObject is used for the n-th host variable reference.	If aBindObject has both instance variables and indexed variables, only the	indexed variables will be used. 	When using the named form, the leading colon is removed and the name is	expected to be an accessing method on aBindObject (i.e. aBindObject is sent	perform: with the name converted to a symbol as the argument)."	bindInput := aBindObject</body><body package="Database" selector="bindOutput">bindOutput	"Answer the bind object used for returned rows."	^bindOutput</body><body package="Database" selector="bindOutput:">bindOutput: aBindObject 	"Specify the bind object used for returned rows."	self bindOutputIndexed: aBindObject</body><body package="Database" selector="bindOutputIndexed:">bindOutputIndexed: aBindObject	"Specify the bind object used for returned rows.  aBindObject may have either	instance variables or indexed variables; if both are present, the indexed variables	are used.	Rows are mapped into aBindObject using positional correspondence between the	row's columns and aBindObject's variables (i.e., column 1 goes into variable 1, etc.).	Variables in aBindObject may be skipped in the positional mapping if they contain	an instance of Object.  This is useful when only a few columns of a table are needed."	bindOutput := aBindObject.	useNamedOutputBinding := false.	self rowAdaptors: nil.</body><body package="Database" selector="bindOutputNamed:">bindOutputNamed: aBindObject	"Specify the bind object used for returned rows.	Rows are mapped into aBindObject using the column names, postfixed with a colon,	as mutator messages.  Thus, each column must have a name that is suitable for	conversion to a symbol, and aBindObject must respond to such a message."	bindOutput := aBindObject.	useNamedOutputBinding := true.	self rowAdaptors: nil.</body><body package="Database" selector="blockFactor">blockFactor	"Answer the blocking factor for using buffers to accelerate fetching of row data."	^blockFactor</body><body package="Database" selector="blockFactor:">blockFactor: aSmallInteger	"Specify the blocking factor to use when fetching of row data.  This may improve application	performance at the expense of memory. The blocking factor is optional and will be ignored if	the driver does not support fetching multiple rows at a time.	The application still uses next to obtain a single row at a time.  However, the use of	WHERE CURRENT OF may not be allowed as the database system cannot be sure	of which row the application is referring to."	blockFactor := aSmallInteger</body><body package="Database" selector="query">query	"Answer SQL text for this session."	^query</body></methods><methods><class-id>Database.ExternalDatabaseSession</class-id> <category>data processing</category><body package="Database" selector="answer">answer	"Wait for the currently executing SQL statement to complete processing. Exceptions are	raised for any errors.  The value answered will be an answer stream,  #noAnswerStream or	#noMoreAnswers.  #noAnswerStream is used to indicate successful processing, but no answer	stream was generated.  In order to maintain application portability with database libraries	that allow multiple SQL statements in one prepare:, this message should be sent until it	returns #noMoreAnswers"	( self state == #executing )		ifTrue:	[ self delayUntilReady ].	^self answerOfClass: self class answerStreamClass</body><body package="Database" selector="cancel">cancel	"Interrupt the processing of the prepared SQL text or stored procedure."	self isExecuting ifFalse:		[ self class connectionClass invalidSessionStateSignal raise ].	answerStream notNil ifTrue:		[ answerStream dismiss ].	( self state == #fetchingData ) ifTrue:		[ self cancelAnswerSetExternal ].	self cancelExternal.	self state: #prepared</body><body package="Database" selector="connect">connect	"Optional: gives direct control over when external resources are acquired. Will be done 	automatically when prepare: is invoked."	( self state == #new ) ifFalse:		[ self class connectionClass invalidSessionStateSignal raise ].	( connection isNil or: [ connection isConnected not ] ) ifTrue:		[ self class connectionClass connectionNotOpenSignal raise ].	self acquire.	self state: #connected</body><body package="Database" selector="disconnect">disconnect	"Optional: gives direct control over when external resources are dismissed."	( self state == #new ) ifTrue: [ ^self ].	self dismiss.	self state: #new</body><body package="Database" selector="execute">execute	"Execute the prepared SQL statement."	"Should we clean up after any previous work?"	self isExecuting ifTrue:		[ self cancel ].	( self state == #prepared ) ifFalse:		[ self class connectionClass invalidSessionStateSignal raise ].	[ "Begin unwind protection."	self bindExternal.	self state: #executing.	self executeExternal.	"End unwind protection." ]		ifCurtailed:			[ self state: #prepared ]</body><body package="Database" selector="prepare:">prepare: aString	"Prepare aString for processing."	self startPrepare.	"Save the query, and prepare it for parameter binding."	self setupQuery: aString.	"We're finally ready to prepare the SQL.	If there is a problem, make sure the state is appropriate."	[ "Begin unwind protection."	self state: #prepared.	self prepareExternal.	"End unwind protection." ]		ifCurtailed:			[ self state: #connected ]</body><body package="Database" selector="rowCount">rowCount	"Answer an Integer representing the number of rows affected by the previous query.	Valid only after the query has been answered."	^self subclassResponsibility</body></methods><methods><class-id>Database.ExternalDatabaseSession</class-id> <category>testing</category><body package="Database" selector="isReady">isReady	"Answer a boolean for whether processing has completed and an answer is ready."	| stateTemp |	(stateTemp := self state) == #executing		ifTrue:			[ (self readyExternal) ifTrue:				[ self state: #ready.				^true ] ]		ifFalse:			[ (stateTemp == #ready			or: [ stateTemp == #validResults 			or: [ stateTemp == #fetchingData ] ] ) ifFalse:				[ self class connectionClass invalidSessionStateSignal raise ].			^true ].	^false</body><body package="Database" selector="useNamedOutputBinding">useNamedOutputBinding	"Answer true if the session is using named output binding"	^useNamedOutputBinding</body></methods><methods><class-id>Database.ExternalDatabaseSession</class-id> <category>private-accessing</category><body package="Database" selector="answerStream:">answerStream: anAnswerStreamOrNil	"Set the session's answer stream."	answerStream := anAnswerStreamOrNil</body><body package="Database" selector="columnDescriptions">columnDescriptions	"Answer the column descriptions array"	^columnDescriptions</body><body package="Database" selector="columnDescriptions:">columnDescriptions: anArray	"Set the column descriptions array"	columnDescriptions := anArray</body><body package="Database" selector="connection">connection	"Answer the connection in which receiver executes."	^connection</body><body package="Database" selector="connection:">connection: aConnection	"Set the connection in which receiver should execute."	connection := aConnection</body><body package="Database" selector="numColumns">numColumns	"Answer the number of columns"	^numColumns</body><body package="Database" selector="numColumns:">numColumns: anInteger	"Save the number of columns"	numColumns := anInteger</body><body package="Database" selector="rowAdaptors:">rowAdaptors: aSequenceableCollection	rowAdaptors := aSequenceableCollection</body><body package="Database" selector="rowBuffers">rowBuffers	^rowBuffersHolder value</body><body package="Database" selector="rowBuffers:">rowBuffers: aSequenceableCollection	rowBuffersHolder value: aSequenceableCollection</body><body package="Database" selector="rowBuffersHolder">rowBuffersHolder	^rowBuffersHolder</body><body package="Database" selector="rowBuffersHolder:">rowBuffersHolder: aValueHolder	rowBuffersHolder := aValueHolder</body></methods><methods><class-id>Database.ExternalDatabaseSession</class-id> <category>private-activation</category><body package="Database" selector="acquire">acquire	"Acquire resources necessary to execute SQL, and register as a participant of our connect."	connection addParticipant: self.	[ self acquireExternal notNil ifTrue:		[ "Assert: external resource held."		self class register: self ]	] ifCurtailed: [ connection removeParticipant: self ]</body><body package="Database" selector="activate">activate	"Don't bother reconnecting now."	connection removeParticipant: self.	self class unregister: self.	self state: #new</body><body package="Database" selector="dismiss">dismiss	self isExecuting ifTrue:		[ self cancel ].	self releaseBuffersAndAdaptors.	self releaseBindings.	super dismiss.	connection removeParticipant: self</body><body package="Database" selector="quiesce">quiesce	"Quiesce all connections to external resources."	self state == #paused ifTrue: [ ^self ].	answerStream notNil ifTrue:		[ answerStream dismiss ].	[ self dismissExternal ]		ensure:			[ self state: #paused ]</body></methods><methods><class-id>Database.ExternalDatabaseSession</class-id> <category>private-answer set</category><body package="Database" selector="aboutToAnswer">aboutToAnswer	"Do any final work before fetching results from an answer set."	^self</body><body package="Database" selector="acquireBuffers">acquireBuffers	"Acquire buffers for fetching the answer set from the server."	| buffers |	"Buffers will only exist here if they're OK to reuse."	self rowBuffers notNil ifTrue: [ ^self ].	buffers := Array new: numColumns.	[ "Begin unwind protection."	1 to: numColumns do:		[ :column |		buffers at: column put: (self allocateRowBufferExternal: column) ].	"End unwind protection." ]		ifCurtailed:			[ "give back any pointers we might have acquired as none will be used."			1 to: numColumns do:				[ :col | | buf |				(buf := buffers at: col) notNil ifTrue:					[ buf free ] ] ].	self rowBuffers: buffers</body><body package="Database" selector="advanceExternal">advanceExternal	"Advance the current row. If blockFactor is supported, this may entail fetching 	many rows but doing it infrequently. If there are no more rows, answer nil. 	Otherwise, answering self is sufficient."	^self subclassResponsibility</body><body package="Database" selector="allocateRowBufferExternal:">allocateRowBufferExternal: aColumn 	"Answer an object describing space allocated for holding one column's	worth of information as returned by the dbms api. The driver is responsible	for defining the structure of the object returned."	^self subclassResponsibility</body><body package="Database" selector="answerOfClass:">answerOfClass: anAnswerStreamClass	"Answer an instance of the given subclass of ExternalDatabaseAnswerStream"	"Assert: anAnswerStreamClass isKindOf: ExternalDatabaseAnswerStream"	| initialAnswer |	initialAnswer := ( self state == #ready ).	self state: #validResults.	initialAnswer		ifTrue:	[ "Verify that the query executed without error."				self resultsExternal ]		ifFalse:	[ "If we're still holding on to a prior answer stream, dismiss it."				answerStream notNil					ifTrue:	[ answerStream close ].				"Assert: self state == #validResults"				self moreResultsExternal					ifFalse:	[ self state: #prepared.							^#noMoreAnswers ] ].	self hasAnswerSetExternal		ifTrue:	[ | answer |				initialAnswer ifFalse:					[ "Previous descriptions/buffers are no longer valid"					self releaseBuffers.					self releaseAdaptors.					self columnDescriptions: nil ].				self getColumnDescriptions.				self acquireBuffers.				self setupAdaptors.				self aboutToAnswer.				answer := anAnswerStreamClass newForSession: self.				self answerStream: answer.				self state: #fetchingData.				^answer ].	^#noAnswerStream.</body><body package="Database" selector="answerStreamDismissed">answerStreamDismissed	"Note that the answer stream has dismissed itself."	self answerStream: nil</body><body package="Database" selector="cancelAnswerSet">cancelAnswerSet	"Cancel an answer set.  Used to release server resources."	self cancelAnswerSetExternal.	self state: #validResults.</body><body package="Database" selector="cancelAnswerSetExternal">cancelAnswerSetExternal	"Cancel any resources associated with the current answer set"	self subclassResponsibility</body><body package="Database" selector="describeAnswerColumns">describeAnswerColumns	"Fill in the columnDescriptions array."	| descrs index temp |	descrs := Array new writeStream.	index := 0.	[ ( temp := self getColumnDescriptionExternal: (index := index + 1) ) notNil ]		whileTrue: [ descrs nextPut: temp ].	self columnDescriptions: (index &gt; 1 ifTrue: [ descrs contents ] ifFalse: [ nil ]).	self numColumns: (index - 1).</body><body package="Database" selector="getColumnDescriptionExternal:">getColumnDescriptionExternal: aColumn	^self subclassResponsibility</body><body package="Database" selector="getColumnDescriptions">getColumnDescriptions	"Get descriptions for the columns in the answer set"	"If column descriptions exist, they're safe to re-use."	( columnDescriptions == nil ) ifFalse: [ ^self ].	( resultTemplate == nil )		ifTrue: [ self describeAnswerColumns ]		ifFalse: [ self answerColumnsFromTemplate ]</body><body package="Database" selector="getFieldExternal:">getFieldExternal: aColumn	^self subclassResponsibility</body><body package="Database" selector="hasAnswerSetExternal">hasAnswerSetExternal	"Answer true if the SQL-statement (batch) being processed returns an answer set."	^self subclassResponsibility</body><body package="Database" selector="nextRowExternal">nextRowExternal	"Answer with the next row of data.  Answer nil at end"	| currentRowCopy |	( self advanceExternal == nil ) ifTrue:		[ "We've exhausted the answer set.  No DBMS cancel is necessary."		self state: #validResults.		^nil ].	"If we have a resultTemplate, use it to provide the answer."	( resultTemplate == nil ) ifFalse:		[ bufferIndex := 1.		^self nextViaTemplate: resultTemplate ].	currentRowCopy := allocateForEachRow		ifTrue:			[ currentRow copy ]		ifFalse:			[ currentRow ].	1 to: numColumns		do: [ :index |			(rowAdaptors at: index)				value: currentRowCopy				value: (self getFieldExternal: index) ].	^currentRowCopy</body><body package="Database" selector="releaseAdaptors">releaseAdaptors	"Release existing adaptors."	"Subclasses may release subclass-specific resources before invoking this method."	self rowAdaptors: nil</body><body package="Database" selector="releaseBuffers">releaseBuffers	"Release buffers and their associated resources."	"Subclasses may release subclass-specific resources before invoking this method."	self rowBuffers: nil</body><body package="Database" selector="releaseBuffersAndAdaptors">releaseBuffersAndAdaptors	"Release buffers, adaptors, and their associated resources."	"Subclasses may release subclass-specific resources before invoking this method."	"Discard previous buffers, descriptors, and adaptors."	self releaseBuffers.	self releaseAdaptors.	self columnDescriptions: nil.	self numColumns: nil.</body><body package="Database" selector="setupAdaptors">setupAdaptors	"Setup adaptors for populating the bindOutput object"	| adaptors bind directInstVarAccess bindSize adaptorIndex currentValue |	"Adaptors may already be set up."	rowAdaptors notNil ifTrue: [ ^self ].	adaptors := Array new: numColumns.	"If no template was specified we'll reify fetched rows as Arrays"	( bind := self bindOutput ) isNil ifTrue:		[ bind := Array new: numColumns ].	currentRow := bind.	"Determine which type of adaptor to build"	directInstVarAccess := false.	( bind class isVariable )		ifTrue:			[ bindSize := bind size ]		ifFalse:			[ bindSize := bind class instSize.			directInstVarAccess := true ].	useNamedOutputBinding ifTrue:		[ bindSize := numColumns ].	"Make a block to insert new values for each slot in the bind object.  This exploits the concept of copying-blocks.  It is assumed that the local variables referenced in the blocks used below as the putAdaptor will be copied on the block and thus be frozen at the time the execution path passes thru the creation of the block."	adaptorIndex := 0.	1 to: bindSize do:		[ :bindIndex | | putAdaptor |		useNamedOutputBinding			ifTrue:				[ | colName putSelector |				( colName := (columnDescriptions at: bindIndex) name ) isNil					ifTrue:	[ self class connectionClass invalidDescriptorCountSignal raise ].				currentValue := bind perform: colName asSymbol.				putSelector := (colName , ':') asSymbol.				putAdaptor := [ :subj :value | subj perform: putSelector with: value ] ]			ifFalse:				[ directInstVarAccess					ifTrue:						[ currentValue := bind instVarAt: bindIndex.						putAdaptor := [ :subj :value | subj instVarAt: bindIndex put: value ] ]					ifFalse:						[ currentValue := bind at: bindIndex.						putAdaptor := [ :subj :value | subj at: bindIndex put: value ] ] ].		"Skip slots in the bind object that contain instances of Object."		( currentValue class == Object ) ifFalse:			[ adaptorIndex := adaptorIndex + 1.			( adaptorIndex &gt; numColumns ) ifTrue:				[ self class connectionClass invalidDescriptorCountSignal raise ].			adaptors at: adaptorIndex put: putAdaptor ]		].	"We must bind exactly as many columns as there are non-skipped	slots in the bind object."	useNamedOutputBinding ifFalse:		[ ( adaptorIndex == numColumns  ) ifFalse:			[ self class connectionClass invalidDescriptorCountSignal raise ] ].	self rowAdaptors: adaptors.</body></methods><methods><class-id>Database.ExternalDatabaseSession</class-id> <category>private-binding</category><body package="Database" selector="bindExternal">bindExternal	"Bind values to parameters in the query, avoiding unnecessary rebinding	where possible."	"Subclasses that do not support binding must override this method	to provide a substitute."	"For each bind marker in the query fragments, get the corresponding	value from the bindInput object.  If the value isn't already bound,	bind and remember it."	2 to: queryFragments size by: 2 do:		[ :index | | bindMarker value |		bindMarker := queryFragments at: index.		value := self inBindInputAt: bindMarker.		( self boundValueAt: bindMarker is: value )			ifFalse: [ self bindValue: value at: bindMarker.					self bindValues at: bindMarker put: value. ] ].</body><body package="Database" selector="bindValue:at:">bindValue: aValue at: aPosition	"Bind aValue at aPosition."	^self subclassResponsibility</body><body package="Database" selector="bindValues">bindValues	"Answer with the receiver's bind value dictionary."	^bindValues notNil		ifTrue:	[ bindValues ]		ifFalse:	[ bindValues := IdentityDictionary new ]</body><body package="Database" selector="boundValueAt:is:">boundValueAt: aPosition is: aValue	"Answer true if there is a parameter bound at aPosition, and if	its value is the same as aValue.  Otherwise, answer false."	| boundValue |	boundValue := self bindValues at: aPosition ifAbsent: [ ^false ].	boundValue = aValue ifTrue: [ ^true ].	self bindValues removeKey: aPosition.	^false</body><body package="Database" selector="inBindInputAt:">inBindInputAt: bindMarker	"Answer the value in bindInput that corresponds to the bindMarker.	If the bindMarker is an integer, the value will be in an instance variable	or indexed variable index.  If the bindMarker is a symbol, bindInput is	assumed to respond to the bindMarker as a message with the value."	^bindMarker isInteger		ifTrue:	[ bindInput class isVariable					ifTrue:						[ bindMarker &gt; bindInput size ifTrue:							[ self class connectionClass invalidDescriptorCountSignal raise ].						bindInput at: bindMarker ]					ifFalse:						[ bindMarker &gt; bindInput class instSize ifTrue:							[ self class connectionClass invalidDescriptorCountSignal raise ].						bindInput instVarAt: bindMarker ] ]		ifFalse:	[ bindInput perform: bindMarker ]</body><body package="Database" selector="prepareExternal">prepareExternal	"Send the query text to the external DBMS to be prepared."	^self subclassResponsibility</body><body package="Database" selector="releaseBindings">releaseBindings	"Release bind values."	bindValues := nil.</body><body package="Database" selector="scanMarkerFrom:">scanMarkerFrom: aStream	"Scan a parameter marker from aStream."	^self		scanNumberOrTokenFrom: aStream		doing:			[:number :tokenStream | 			number == nil				ifTrue:					[| token |					tokenStream isNil						ifTrue: [nil]						ifFalse:							[token := tokenStream contents.							token isEmpty								ifTrue: [self class invalidParameterMarkerSignal raise].							token asSymbol]]				ifFalse: [number]].</body><body package="Database" selector="scanNumberOrTokenFrom:doing:">scanNumberOrTokenFrom: aStream doing: aBlock	"Scan a parameter marker from aStream."	| ch rule number tokenStream |	aStream atEnd ifTrue: [^aBlock value: nil value: #() readStream].	( ch := aStream next ) isDigit		ifTrue:			[ rule := [ :c | c isDigit ].			number := 0 ]		ifFalse:			[ rule := [ :c | c isAlphaNumeric or: [ c == $_ ] ].			tokenStream := WriteStream on: (String new: 16).			number := nil ].	[ ch notNil and: [ rule value: ch ] ] whileTrue:		[ number == nil			ifTrue:	[ tokenStream nextPut: ch ]			ifFalse:	[ number := (number * 10) + ch digitValue ].		ch := aStream atEnd ifTrue: [nil] ifFalse: [aStream next] ].	ch notNil ifTrue:		[ aStream skip: -1 ].	^aBlock value: number value: tokenStream.</body><body package="Database" selector="setupQuery:">setupQuery: aString	"Save the query. Break the query into an Array of fragments, 	isolating each parameter marker. Save the fragmented form."	"The size of the fragment array will always be odd, with parameter 	markers at even positions. Markers of the form '?' and ':number' 	are converted to index-into-bindInput-object form. Markers of 	the form ':name' are converted to #name."	| stream fragmentStream collection markerCount ch prevCh marker cr tab space |	query := aString.	stream := query readStream.	fragmentStream := WriteStream on: (aString class new: query size).	collection := OrderedCollection new: 13.	markerCount := 0.	ch := $?.	cr := Character cr.	tab := Character tab.	space := Character space.	[ stream atEnd ] whileFalse:		[ prevCh := ch.		ch := stream next.		( ch == $' or: [ ch == $" ] )			ifTrue:				[ fragmentStream					nextPut: ch;					nextPutAll: (stream through: ch) ]			ifFalse:				[ ( ch == $?				or: [ (ch == $:) and: [ prevCh isAlphaNumeric not and: [ stream atEnd not and: [stream peek isAlphaNumeric ]] ] ] )					ifTrue:						[ markerCount := markerCount + 1.						collection add: fragmentStream contents.						fragmentStream reset.						( ch == $? )							ifTrue:								[ collection add: markerCount ]							ifFalse:								[ marker := self scanMarkerFrom: stream.								"ch does not reflect that last character, but that's O.K."								collection add: marker ] ]					ifFalse:						[ (ch == cr or: [ ch == tab]) ifTrue:							[ ch := space ].						fragmentStream nextPut: ch ] ] ].	collection add: fragmentStream contents.	queryFragments := collection.</body><body package="Database" selector="startPrepare">startPrepare	"Get the receiver into a reasonable state to prepare a new SQL statement."	| stateTemp |	"Should we clean up after any previous work?"	self isExecuting ifTrue:		[ self cancel ].	"If not already held, acquire the right to execute SQL statements."	( self state == #new ) ifTrue:		[ self connect ] .	"Enforce: we're in a legal state to prepare new SQL text."	( (stateTemp := self state) == #connected	or: [ stateTemp == #prepared ] ) ifFalse:		[ self class connectionClass invalidSessionStateSignal raise ].	"Release any previously held buffers and adaptors."	self releaseBuffersAndAdaptors.	"Previous bind parameters are now invalid."	self releaseBindings.	"Drop the old query texts."	query := nil.	queryFragments := nil.	"Default to a connected state"	self state: #connected</body></methods><methods><class-id>Database.ExternalDatabaseSession</class-id> <category>private-execution</category><body package="Database" selector="cancelExternal">cancelExternal	^self subclassResponsibility</body><body package="Database" selector="delayUntilReady">delayUntilReady	"Delay until the server is ready."	"Assert: self state == #executing"	| ticks |	ticks := 1.	[ self isReady ]		whileFalse:			[ (Delay forMilliseconds: ticks) wait.			ticks &lt; 1000 ifTrue: [ ticks := ticks + ticks ] ].	"Assert: self state == #ready"</body><body package="Database" selector="executeExternal">executeExternal	"Execute the prepared query."	"Subclasses that don't support query preparation will need to assemble the	query in the overriding method."	^self subclassResponsibility</body><body package="Database" selector="moreResultsExternal">moreResultsExternal	"Answer true if there are more results available, otherwise answer false.	Raise an exception if there are errors."	^self subclassResponsibility</body><body package="Database" selector="readyExternal">readyExternal	"Answer whether or not the dbms has processed the SQL statement (batch)."	^self subclassResponsibility</body><body package="Database" selector="resultsExternal">resultsExternal	"Examine the outcome of executing an SQL statement and raise exceptions	for any errors.  Answer a boolean indicating the presense of an answer."	^self subclassResponsibility</body></methods><methods><class-id>Database.ExternalDatabaseSession</class-id> <category>private-finalization</category><body package="Database" selector="executor">executor	"Answer with an executor for this session."	"Subclassess will want to override to add information to the executor. 	The subclass method should use super executor to create the executor 	initially."	| ex |	ex := super executor.	ex connection: connection.	ex rowBuffersHolder: self rowBuffersHolder.	^ex</body><body package="Database" selector="finalizeExternal">finalizeExternal	"Release all external resource."	( traceLevel &gt;= 1 ) ifTrue: [ self class trace: nil ].	self isExecuting ifTrue: [ self cancelExternal ].	super finalizeExternal</body></methods><methods><class-id>Database.ExternalDatabaseSession</class-id> <category>private-testing</category><body package="Database" selector="isExecuting">isExecuting	"Answer true if receiver is in an executing state."	| state |	^(state := self state) == #executing	or: [state == #ready	or: [state == #validResults	or: [state == #fetchingData]]]</body></methods><methods><class-id>Database.ExternalDatabaseSession class</class-id> <category>instance creation</category><body package="Database" selector="new">new	^self error: (#errNewExternalDatabaseSession &lt;&lt; #database &gt;&gt; 'An ExternalDatabaseSession is obtained from an instance of ExternalDatabaseConnection.')</body></methods><methods><class-id>Database.ExternalDatabaseSession class</class-id> <category>accessing</category><body package="Database" selector="answerStreamClass">answerStreamClass	^ExternalDatabaseAnswerStream</body><body package="Database" selector="xif">xif	"Answer the ExternalInterface subclass instance in use."	^self connectionClass xif</body></methods><methods><class-id>Database.ExternalDatabaseSession class</class-id> <category>private-instance creation</category><body package="Database" selector="newForConnection:">newForConnection: aConnection	"Answer a new ExternalDatabaseSession associated with aConnection."	| req |	(req := self basicNew) initialize.	req connection: aConnection.	^req</body></methods><methods><class-id>Database.ExternalDatabaseConnection</class-id> <category>initialize-release</category><body package="Database" selector="initialize">initialize	"Establish initial value for instance variables."	"Subclasses which override must include super initialize."	super initialize.	self state: #new.	transaction := nil.	self transactionCoordinator: false asValue.</body></methods><methods><class-id>Database.ExternalDatabaseConnection</class-id> <category>accessing</category><body package="Database" selector="environment">environment	"Answer the environment to use when connecting to the SQL-environment."	^environment</body><body package="Database" selector="environment:">environment: aString 	"Set the environment to use when connecting to the SQL-environment.	An empty string should be used to specify the 'default' environment.  If the	environment is nil, the driver will raise a proceedable exception	(requiredEnvironmentSignal on a connection class) when connecting."	environment := aString</body><body package="Database" selector="password">password	"Answer the password to use when connecting to the SQL-environment."	^password</body><body package="Database" selector="password:">password: aString 	"Set the password to use when connecting to the SQL-environment. 	Passwords are not required by all database systems (or on all platforms). 	An empty string should be used for the no-password case.  If the password	is nil, the driver will raise a proceedable exception (requiredPasswordSignal	on a connection class) when connecting."	password := aString</body><body package="Database" selector="username">username	"Answer the username to use when connecting to the SQL-environment."	^username</body><body package="Database" selector="username:">username: aString	"Set the username to use when connecting to the SQL-environment.	An empty string should be used  to connect as the default user unless the driver	requires something else.  If the username is nil, the driver will raise a proceedable	exception (requiredUsernameSignal on a connection class) when connecting."	username := aString</body></methods><methods><class-id>Database.ExternalDatabaseConnection</class-id> <category>connections</category><body package="Database" selector="connect">connect	"Establish connection with SQL-environment ."	self connect: self password.</body><body package="Database" selector="connect:">connect: aPassword 	"Establish connection with SQL-environment using the supplied password."	"Enforce: external resources not held."	self isConnected ifTrue:		[ ^self class invalidConnectionStateSignal raise ].	( traceLevel &gt;= 1 ) ifTrue:		[ (self traceStream)			nextPutAll: (#Version &lt;&lt; #database &gt;&gt; 'Version: ') asString;			nextPutAll: self class version.		self class trace: self emitTrace ].	self acquireTransaction.	self acquire: aPassword.	self state: #xactNo</body><body package="Database" selector="disconnect">disconnect	"Terminate connection with SQL-environment. An outstanding transaction	(if any) is aborted."	( self state == #new ) ifTrue: [ ^self ].	cachedSession := nil.	self inTransactionMode ifTrue: [ self rollback ].	self participantsDo: [ :each | each disconnect ].	self dismiss.	self dismissTransaction.	self state: #new</body><body package="Database" selector="getSession">getSession	"Answer an instance of the driver's subclass of ExternalDatabaseSession."	self isConnected ifFalse:		[ self class connectionNotOpenSignal raise ].	^cachedSession notNil		ifTrue:	[ | session |				session := cachedSession.				cachedSession := nil.				session ]		ifFalse:	[ self class sessionClass newForConnection: self ]</body><body package="Database" selector="prepare:">prepare: aString 	"Answer an instance of the driver's subclass of ExternalDatabaseSession	and prepare the SQL text in aString for processing. The number of active	sessions is driver-dependent."	^self getSession prepare: aString</body></methods><methods><class-id>Database.ExternalDatabaseConnection</class-id> <category>testing</category><body package="Database" selector="inTransactionMode">inTransactionMode	"Answer true if a multi-statement transaction has been started."	| xact |	^(xact := self transaction) isNil		ifTrue:	[ false ]		ifFalse:	[ xact inTransactionMode ]</body><body package="Database" selector="isConnected">isConnected	"Answer whether receiver is connected to database."	| stateTemp |	^((stateTemp := self state) == #new or: [ stateTemp == #paused ]) not</body><body package="Database" selector="isTransactionCoordinator">isTransactionCoordinator	"Answer true if this connection has been designated as the	coordinator for a multiple connection transaction."	^self transactionCoordinator value</body></methods><methods><class-id>Database.ExternalDatabaseConnection</class-id> <category>transactions</category><body package="Database" selector="begin">begin	"Mark the beginning of a multi-statement transaction.  This is necessary if	the transaction needs to include more than one statement in the transaction."	self inTransactionMode		ifTrue:	[ ^self class invalidTransactionStateSignal raise ].	self transaction begin</body><body package="Database" selector="beTransactionCoordinator">beTransactionCoordinator	"Designate this connection as the commit coordinator for a collection of connections.	Connections must be desginated as commit coordinators before they connect."	self state == #new		ifFalse:	[ self class invalidTransactionStateSignal raise ].	self transactionCoordinator value: true.	self acquireTransaction</body><body package="Database" selector="commit">commit	"Commit all database changes made during the current multi-statement transaction."	self inTransactionMode		ifTrue:	[ self transaction commit ]</body><body package="Database" selector="rollback">rollback	"Rollback all database changes made during the current multi-statement transaction."	self inTransactionMode		ifTrue:	[ self transaction rollback ]</body><body package="Database" selector="transactionCoordinatorFor:">transactionCoordinatorFor: aConnection	"Designate this connection as the commit coordinator for aConnection.  If the	receiver is not currently a transaction coordinator and is not connected, it will	be designated as such.  aConnection must not be connected."	"Become a transaction coordinator if not already."	self state == #new		ifTrue:			[ self isTransactionCoordinator				ifFalse: [ self beTransactionCoordinator ] ]		ifFalse:			[ self isTransactionCoordinator				ifFalse: [ self class invalidTransactionStateSignal raise ] ].	"Enforce: aConnection isn't a transaction coordinator and is not connected."	(aConnection isConnected or: [aConnection isTransactionCoordinator])		ifTrue:	[ self class invalidTransactionStateSignal raise ].		"aConnection assumes receiver's transaction."	aConnection useTransaction: self transaction</body></methods><methods><class-id>Database.ExternalDatabaseConnection</class-id> <category>private-accessing</category><body package="Database" selector="encoding">encoding	^#default</body><body package="Database" selector="isolationLevel">isolationLevel	"Answer the current isolation level."	^isolationLevel</body><body package="Database" selector="isolationLevel:">isolationLevel: anIsolationLevel	"Set the current isolation level."	self subclassResponsibility.</body><body package="Database" selector="platformType">platformType	"Answer the current platform type"	^self class platformType</body><body package="Database" selector="transaction">transaction	"Answer the transaction for commit/rollback coordination."	^transaction</body><body package="Database" selector="transaction:">transaction: aTransaction	"Set the transaction for commit/rollback coordination."	transaction := aTransaction</body><body package="Database" selector="transactionCoordinator">transactionCoordinator	^transactionCoordinator</body><body package="Database" selector="transactionCoordinator:">transactionCoordinator: anExternalDatabaseValueHolder	transactionCoordinator := anExternalDatabaseValueHolder</body></methods><methods><class-id>Database.ExternalDatabaseConnection</class-id> <category>private-activation</category><body package="Database" selector="acquire:">acquire: aPassword	"Time to acquire any external resources."	(self acquireExternal: aPassword) notNil		ifTrue:	[ self class register: self ]</body><body package="Database" selector="acquireTransaction">acquireTransaction	"If we don't have a transaction object, arrange for one."	self transaction isNil ifTrue:		[ self useTransaction: self class transactionClass new ]</body><body package="Database" selector="activate">activate	super activate.	self state: #xactNo</body><body package="Database" selector="dismissTransaction">dismissTransaction	"We don't need our transaction object any more."	self transaction dismiss.	self transaction removeParticipant: self.	self transaction: nil</body><body package="Database" selector="quiesce">quiesce	"Time to quiesce all connections to external resources."	"Enforce-quietly: receiver is connected."	self isConnected ifFalse: [ ^self ].	"If we're in a transaction, roll it back now to assure a consistent state."	self inTransactionMode ifTrue:		 [ self rollback ].	super quiesce</body><body package="Database" selector="useTransaction:">useTransaction: aTransaction	"Use aTransaction as our transaction."	self transaction: aTransaction.	self transaction addParticipant: self.	self transaction acquire</body></methods><methods><class-id>Database.ExternalDatabaseConnection</class-id> <category>private-finalization</category><body package="Database" selector="executor">executor	"Answer with the executor."	"Subclassess will want to override to add information to the executor. 	The subclass method should use super executor to create the executor 	initially."	| ex |	ex := super executor.	ex transaction: self transaction.	ex transactionCoordinator: self transactionCoordinator.	^ex</body><body package="Database" selector="finalizeExternal">finalizeExternal	"Release all external resource."	( traceLevel &gt;= 1 )		ifTrue:	[ self class trace: nil ].	self transaction addParticipant: self.	self inTransactionMode ifTrue:		[ "Assert: the connection cannot be in the paused state."		self transaction executorFinishingTransaction ].	self transaction dismiss.	super finalizeExternal</body></methods><methods><class-id>Database.ExternalDatabaseConnection</class-id> <category>private-library calls</category><body package="Database" selector="acquireExternal">acquireExternal	"Dispatch to proper method for connection classes."	self acquireExternal: self password</body><body package="Database" selector="acquireExternal:">acquireExternal: aPassword	"Acquire the external resources involved with a connection to the 	SQL-environment."	"The username, password, and environment variables may be nil to indicate that	the proper value is unknown or an empty string to indicate that the DBMS is expected	to take the default. If the value for one of these variables is required, raise the proceedable	signal requiredUsernameSignal, requiredPasswordSignal, or requiredEnvironmentSignal and	use the proceed value.  Do not record this value in the instance variable."	self subclassResponsibility	"Note: implementations of this method are expected to use		self class mapLogical: self environment	in order to determine the proper environment string to use."</body><body package="Database" selector="beginExternal">beginExternal	"Mark the beginning of receiver's portion of a transaction. Most 	dbms define this as a side-effect of using a transaction-initiating 	statement. This is provided as a convenience for drivers that 	require knowledge of the event to control their state machines."	self isConnected ifFalse:		[ ^self class connectionNotOpenSignal raise  ].	self state == #xactNo		ifTrue:	[ self state: #xactYes ]	"Drivers with a transaction concept that spans multiple connections	may never invoke this method. Thus, those drivers should overide	this with ^self shouldNotImplement."</body><body package="Database" selector="commitExternal">commitExternal	"Commit all changes made by receiver's connection."	| wasInTrans |	(wasInTrans := (self state == #xactYes))		ifTrue:	[ self state: #xactNo ].	^wasInTrans	"Drivers with a transaction concept that spans multiple connections	may never invoke this method. Thus, those drivers should overide	this with ^self shouldNotImplement."</body><body package="Database" selector="rollbackExternal">rollbackExternal	"Rollback all changes made by receiver's connection."	| wasInTrans |	(wasInTrans := (self state == #xactYes))		ifTrue:	[ self state: #xactNo ].	^wasInTrans	"Drivers with a transaction concept that spans multiple connections	may never invoke  this method. Thus, those drivers should overide	this with ^self shouldNotImplement."</body></methods><methods><class-id>Database.ExternalDatabaseConnection class</class-id> <category>class initialization</category><body package="Database" selector="initialize">initialize	"Establish class variables."	"ExternalDatabaseConnection initialize"	| theLens |	(ObjectMemory dependents includes: self) ifFalse:		[ ObjectMemory addDependent: self ].	(theLens := #{LensSession} valueOrDo: [nil]) notNil ifTrue:		[ theLens initializeAllSignals ].	self initializeExceptionClasses.</body><body package="Database" selector="initializeExceptionClasses">initializeExceptionClasses	"Initialize related exception classes."	AuthenticationFailure		notifierString: (#errUsernamePassword &lt;&lt; #database &gt;&gt; 'Invalid username/password');		nameClass: self message: #authenticationFailureSignal.	ConnectionException		notifierString: (#errConnectionException &lt;&lt; #database &gt;&gt; 'Connection Exception');		nameClass: self message: #connectionExceptionSignal.	ConnectionNotOpen		notifierString: (#connectionNotOpen &lt;&lt; #database &gt;&gt; 'Connection Exception--connection not open');		nameClass: self message: #connectionNotOpenSignal.	CouldNotResolveServiceName		notifierString: (#couldNotResolveServiceName &lt;&lt; #database &gt;&gt; 'Connection Exception--Could not resolve service name.');		nameClass: self message: #couldNotResolveServiceNameSignal.	DuplicateIndexesError		notifierString: (#duplicateIndex &lt;&lt; #database &gt;&gt; 'Attempting to create a duplicate index');		nameClass: self message: #duplicateIndexesErrorSignal.	DynamicSQLError		notifierString: (#errDynamicSQL &lt;&lt; #database &gt;&gt; 'Dynamic SQL Error');		nameClass: self message: #dynamicSQLErrorSignal.	ExternalDatabaseException			notifierString: (#errExternalDatabase &lt;&lt; #database &gt;&gt; 'External Database Error');		nameClass: self message: #externalDatabaseErrorSignal.	ExternalDatabaseResumableException			notifierString: (#errInformation &lt;&lt; #database &gt;&gt; 'External Database Information');		nameClass: self message: #externalDatabaseInformationSignal.	ExternalDatabaseLibraryInaccessible			notifierString: (#databaseClientInacessilbe &lt;&lt; #database &gt;&gt; 'Database client libraries are inaccessible. Either the Object Engine has not been linked with the required libraries, or the DLLs for those libraries are not in your search path.  For more information, consult the release notes for this Connect product.' );		nameClass: self message: #externalDatabaseLibraryInaccessibleSignal.	ExternalDatabaseTransactionError		notifierString: (#errCommitRollbackFailed &lt;&lt; #database  &gt;&gt; 'An attempt to commit/rollback a database transaction failed.');		nameClass: self message: #externalDatabaseTransactionErrorSignal.	IndexConflict			notifierString: (#errUpdatePrimaryKey &lt;&lt; #database &gt;&gt; 'You cannot update the primary key of an existing row or insert a new row if this would result in more than one row with the same primary key.');		nameClass: self message: #indexConflictSignal.	InvalidConnectionState			notifierString: (#errConnectionState &lt;&lt; #database &gt;&gt; 'Invalid Connection State');		nameClass: self message: #invalidConnectionStateSignal.	InvalidDescriptorCount			notifierString: (#errDescriptorCount &lt;&lt; #database &gt;&gt; 'Dynamic SQL Error--invalid descriptor count');		nameClass: self message: #invalidDescriptorCountSignal.	InvalidParameterMarker			notifierString: (#errParameterMarker &lt;&lt; #database &gt;&gt; 'Dynamic SQL Error--invalid parameter marker');		nameClass: self message: #invalidParameterMarkerSignal.	InvalidSessionState			notifierString: (#errSessionState &lt;&lt; #database &gt;&gt; 'Invalid Session State');		nameClass: self message: #invalidSessionStateSignal.	InvalidTableName			notifierString: (#errTableName &lt;&lt; #database &gt;&gt; 'Invalid table name in query');		nameClass: self message: #invalidTableNameSignal.	InvalidTransactionState			notifierString: (#errTransactionState &lt;&lt; #database &gt;&gt; 'Invalid Transaction State');		nameClass: self message: #invalidTransactionStateSignal.	MissingBindVariable		notifierString: (#missingBindVariable &lt;&lt; #database &gt;&gt; 'Missing bind variable.');		nameClass: self message: #missingBindVariableSignal.	NoDefaultConnection			notifierString: (#errDefaultConnection1 &lt;&lt; #database &gt;&gt; 'There is no default Connection to provide a connection');		nameClass: self message: #noDefaultConnectionSignal.	ObjectLocked			notifierString: (#alreadyLockedObject &lt;&lt; #database &gt;&gt; 'Attempting to lock a locked object');		nameClass: self message: #objectLockedSignal.	RequiredEnvironment			notifierString: (#errEnvironment &lt;&lt; #database &gt;&gt; 'No environment was specified and there is no default defined');		nameClass: self message: #requiredEnvironmentSignal.	RequiredPassword			notifierString: (#passwordRequired &lt;&lt; #database &gt;&gt; 'A password is required');		nameClass: self message: #requiredPasswordSignal.	RequiredUsername			notifierString: (#userNameRequired &lt;&lt; #database &gt;&gt; 'A user name is required');		nameClass: self message: #requiredUsernameSignal.	RowIsReferencedError			notifierString:  (#errPrimaryKey &lt;&lt; #database &gt;&gt; 'You cannot change the primary key of&lt;n&gt;or delete a row which is 			referenced in another table.') expandMacros;		nameClass: self message: #rowIsReferencedErrorSignal.	SQLSyntaxError			notifierString: (#errSQLSyntax &lt;&lt; #database &gt;&gt; 'Syntax error or access rule violation in SQL dynamic statement');		nameClass: self message: #syntaxErrorSignal.	TooManyActiveConnections			notifierString: (#errConnectionMaxDriver &lt;&lt; #database &gt;&gt; 'The maximum number of connections are already active for this driver');		nameClass: self message: #tooManyActiveConnectionsSignal.	TooManyActiveSessions			notifierString: (#errMaxSessionsPerConnection &lt;&lt; #database &gt;&gt; 'The maximum number of sessions are already active in this connection');		nameClass: self message: #tooManyActiveSessionsSignal.	TooManyActiveTransactions			notifierString: (#errMaxTransactionsDriver &lt;&lt; #database &gt;&gt; 'The maximum number of transactions are already active for this driver');		nameClass: self message: #tooManyActiveTransactionsSignal.	TransactionException			notifierString: (#errTransactionException &lt;&lt; #database &gt;&gt; 'Transaction Exception');		nameClass: self message: #transactionExceptionSignal.	TransactionPhase2Fatal			notifierString: (#err2phaseCommit &lt;&lt; #database &gt;&gt; 'Failure to complete 2-phase commit second phase.&lt;n&gt;Inform your Database Administrator.') expandMacros;		nameClass: self message: #transactionPhase2FatalSignal.	UnableToAllocateHandle			notifierString: (#errHandleAllocation &lt;&lt; #database &gt;&gt; 'Unable to allocate a handle.');		nameClass: self message: #unableToAllocateHandleSignal.	UnableToBind			notifierString: (#errVariableBufferAssocation &lt;&lt; #database &gt;&gt; 'Unable to associate buffer with bind variable');		nameClass: self message: #unableToBindSignal.	UnableToCancelCursor			notifierString: (#errCursorCancel &lt;&lt; #database &gt;&gt; 'The database cursor could not be canceled.');		nameClass: self message: #unableToCancelCursorSignal.	UnableToCloseCursor			notifierString: (#errCursorClosed &lt;&lt; #database &gt;&gt; 'The database cursor could not be closed.');		nameClass: self message: #unableToCloseCursorSignal.	UnableToConnectToSQLenvironment			notifierString: (#errDatabaseEvironment &lt;&lt; #database &gt;&gt; 'Connection Exception--unable to connect to database environment');		nameClass: self message: #unableToConnectToSQLenvironmentSignal.	UnableToConnectToSQLserver			notifierString: (#errDatabaseSeverConnection &lt;&lt; #database &gt;&gt; 'Connection Exception--unable to connect to database server');		nameClass: self message: #unableToConnectToSQLserverSignal.	UnableToDescribe			notifierString: (#errObtainDescription &lt;&lt; #database &gt;&gt; 'Unable to obtain description');		nameClass: self message: #unableToDescribeSignal.	UnableToDisconnect			notifierString: (#errServerDisconnect &lt;&lt; #database &gt;&gt; 'Unable to disconnect from SQL-server');		nameClass: self message: #unableToDisconnectSignal.	UnableToExecuteSQL			notifierString: (#errExecuteSQL &lt;&lt; #database &gt;&gt; 'Unable to execute the prepared SQL text');		nameClass: self message: #unableToExecuteSQLSignal.	UnableToFetchData			notifierString: (#errUnableToFetch &lt;&lt; #database &gt;&gt; 'Unable to fetch one or more rows of data');		nameClass: self message: #unableToFetchDataSignal.	UnableToFreeResource			notifierString: (#errFreeResource &lt;&lt; #database &gt;&gt; 'Unable to free an external resource.');		nameClass: self message: #unableToFreeResourceSignal.	UnableToOpenCursor			notifierString: (#errCursorOpened &lt;&lt; #database &gt;&gt; 'The database cursor could not be opened.');		nameClass: self message: #unableToOpenCursorSignal.	UnableToPrepare			notifierString: (#errPrepareSQL &lt;&lt; #database &gt;&gt; 'Unable to prepare SQL statement.');		nameClass: self message: #unableToPrepareSignal.	UnableToQueryDriverInformation			notifierString: (#errQueryDriver &lt;&lt; #database &gt;&gt; 'Unable to query driver information.');		nameClass: self message: #unableToQueryDriverInformationSignal.	UnableToQueryHandleInformation			notifierString: (#errQueryHandle &lt;&lt; #database &gt;&gt; 'Unable to query handle information.');		nameClass: self message: #unableToQueryHandleInformationSignal.	UnsupportedDriverFunctionality			notifierString:  (#externalDBError &lt;&lt; #database &gt;&gt; 'An attempt was made to use a feature which the API is not available in the current configuration.');		nameClass: self message: #unsupportedDriverFunctionalitySignal.	UnsupportedIsolationLevel			notifierString: (#unsupportedIsolation &lt;&lt; #database &gt;&gt; 'An attempt was made to set an unsupported isolation level.');		nameClass: self message: #unsupportedIsolationLevelSignal.</body><body package="Database" selector="obsolete">obsolete	"This class is being removed from the system."	(ObjectMemory dependents includes: self)		ifTrue:	[ ObjectMemory removeDependent: self ].	super obsolete</body></methods><methods><class-id>Database.ExternalDatabaseConnection class</class-id> <category>instance creation</category><body package="Database" selector="new">new	"Create a valid, but empty, connection object."	| defaultName defaultClass |	self == ExternalDatabaseConnection		ifTrue:			[ ((defaultName := self defaultConnection) isNil			or: [ (defaultClass := self environment at: defaultName ifAbsent: []) isNil ]) ifTrue:				[ defaultClass := self noDefaultConnectionSignal raiseRequest ].				^defaultClass new ]		ifFalse:	[ ^self basicNew initialize ].</body></methods><methods><class-id>Database.ExternalDatabaseConnection class</class-id> <category>accessing</category><body package="Database" selector="defaultConnection">defaultConnection	"Answer the class name for the default Connection to use when creating connections."	^DefaultConnection</body><body package="Database" selector="defaultConnection:">defaultConnection: aClassName	"Set the class name for the default Connection to use when creating connections."	DefaultConnection := aClassName</body><body package="Database" selector="defaultEnvironment">defaultEnvironment	"Answer the default logical environment to use when creating connections."	^DefaultEnvironment</body><body package="Database" selector="defaultEnvironment:">defaultEnvironment: aString 	"Set the default logical environment to use when creating connections."	DefaultEnvironment := aString</body><body package="Database" selector="kind">kind	"Answer a symbol representing the type of DMBS the receiver provides services for."	^self subclassResponsibility</body><body package="Database" selector="version">version	^(#EXDIversion &lt;&lt; #database &gt;&gt; 'External Database Interface - Release 7.0') asString</body></methods><methods><class-id>Database.ExternalDatabaseConnection class</class-id> <category>activation</category><body package="Database" selector="pause">pause	"Direct this driver (or all drivers if receiver is ExternalDatabaseConnection) to	indefinitely suspend operations."	"Subclasses must override to provide driver-specific behavior."	self == ExternalDatabaseConnection		ifTrue:	[ self subclasses do: [ :each | each pause ]. ]		ifFalse:	[ self subclassResponsibility ].</body><body package="Database" selector="resume">resume	"Direct this driver (or all drivers if receiver is ExternalDatabaseConnection) to	resume suspended operations."	"Subclasses must override to provide driver-specific behavior."	self == ExternalDatabaseConnection		ifTrue:	[ self subclasses do: [ :each | each resume ]. ]		ifFalse:	[ self subclassResponsibility ].</body></methods><methods><class-id>Database.ExternalDatabaseConnection class</class-id> <category>environment mapping</category><body package="Database" selector="addLogical:environment:">addLogical: aLogicalEnvironmentString environment: anEnvironmentSpecificationString 	"Add a new entry in the logical environment map which associates aLogicalEnvironmentString	as the logical name for the environment and anEnvironmentSpecificationString as  	the value to use when connecting."	| theClass |	self == ExternalDatabaseConnection		ifTrue: 			[DefaultConnection isNil				ifTrue: 					[self error: #errDefaultConnection &lt;&lt; #database &gt;&gt; 'Establish a defaultConnection: first'.					^self].			theClass := self environment at: DefaultConnection]		ifFalse: [theClass := self].	theClass environments at: aLogicalEnvironmentString put: anEnvironmentSpecificationString</body><body package="Database" selector="environments">environments	"Answer dictionary containing all logical name -&gt; SQL-environment string mappings."	"Lazy initialization"	environmentMap isNil		ifTrue:	[ environmentMap := Dictionary new ].	"Answer the dictionary."	^environmentMap</body><body package="Database" selector="mapLogical:">mapLogical: aLogicalEnvironmentString 	"Answer the string to use for the environment in making a connection.	Answer  aLogicalEnvironmentString if it does not appearin the map."	"This is only sent from subclasses, so their distinct class-side instance	environments variable will be used."	^self environments at: aLogicalEnvironmentString ifAbsent: [ aLogicalEnvironmentString ]</body><body package="Database" selector="removeLogical:">removeLogical: aLogicalEnvironmentString 	"Remove an entry from the logical environment map."	| theClass |	self == ExternalDatabaseConnection		ifTrue: 			[DefaultConnection isNil ifTrue: [^self].			theClass := self environment at: DefaultConnection]		ifFalse: [theClass := self].	theClass environments removeKey: aLogicalEnvironmentString ifAbsent: []</body></methods><methods><class-id>Database.ExternalDatabaseConnection class</class-id> <category>signal constants</category><body package="Database" selector="authenticationFailureSignal">authenticationFailureSignal	"Answer the signal used to indicate that the server failed to authenticate the	username and/or password."	^AuthenticationFailure</body><body package="Database" selector="connectionExceptionSignal">connectionExceptionSignal	"Answer the parent for signals used to indicate problems in the ANSI-2 	exception class named connection exception."	^ConnectionException</body><body package="Database" selector="connectionNotOpenSignal">connectionNotOpenSignal	"Answer the signal used to indicate that the connection does not have a	connection to the SQL-environment."	^ConnectionNotOpen</body><body package="Database" selector="couldNotResolveServiceNameSignal">couldNotResolveServiceNameSignal	"Answer the signal used to indicate that the service name could not be resolved."	^CouldNotResolveServiceName</body><body package="Database" selector="duplicateIndexesErrorSignal">duplicateIndexesErrorSignal	"Answer the signal used to indicate attempting to add an index having the same	columns as an existing index."	^DuplicateIndexesError</body><body package="Database" selector="dynamicSQLErrorSignal">dynamicSQLErrorSignal	"Answer the parent for signals used to indicate problems in the ANSI-2 	exception class named dynamic SQL error."	^DynamicSQLError</body><body package="Database" selector="externalDatabaseErrorSignal">externalDatabaseErrorSignal	"Answer the most general external database error signal. This signal and its	descendents are not proceedable.  External database error signals may have	parameters defined.  Read the method which returns each signal for a definition."	^ExternalDatabaseException</body><body package="Database" selector="externalDatabaseInformationSignal">externalDatabaseInformationSignal	"Answer the most general external database information signal. This signal and its	descendents are proceedable as they are usually used to collect missing information	or report conditions that the handler should be able to correct.  External database	information signals may have parameters defined.  Read the method which returns	each signal for a definition."	^ExternalDatabaseResumableException</body><body package="Database" selector="externalDatabaseLibraryInaccessibleSignal">externalDatabaseLibraryInaccessibleSignal	"Answer the signal used to indicate that a driver is not able to access the database library.	Either the OE does not contain the database library or it cannot be found in the search	path for dynamic link libraries."	^ExternalDatabaseLibraryInaccessible</body><body package="Database" selector="externalDatabaseTransactionErrorSignal">externalDatabaseTransactionErrorSignal 	"An attempt to commit/rollback a database transaction failed."	^ExternalDatabaseTransactionError</body><body package="Database" selector="indexConflictSignal">indexConflictSignal	"Answer the signal indicating attempt to insert or update an object so that it has the same 	index value as another object."	^IndexConflict</body><body package="Database" selector="invalidConnectionStateSignal">invalidConnectionStateSignal	"Answer the signal used to indicate that the application cannot use a function at a given time."	^InvalidConnectionState</body><body package="Database" selector="invalidDescriptorCountSignal">invalidDescriptorCountSignal	"Answer the signal used to indicate that there are more input variables in an 	SQL statement than are found in the bind object."	^InvalidDescriptorCount</body><body package="Database" selector="invalidParameterMarkerSignal">invalidParameterMarkerSignal 	"Answer the signal used to indicate that the parameter marker is incorrect."	^InvalidParameterMarker</body><body package="Database" selector="invalidSessionStateSignal">invalidSessionStateSignal	"Answer the signal used to indicate that the application cannot use a function at a given time."	^InvalidSessionState</body><body package="Database" selector="invalidTableNameSignal">invalidTableNameSignal	"The query specified an invalid table name"	^InvalidTableName</body><body package="Database" selector="invalidTransactionStateSignal">invalidTransactionStateSignal	"Answer the signal used to indicate that the application cannot use a function at a given time."	^InvalidTransactionState</body><body package="Database" selector="missingBindVariableSignal">missingBindVariableSignal	"Answer the signal used to indicate that a bind variable is missing."	^MissingBindVariable</body><body package="Database" selector="noDefaultConnectionSignal">noDefaultConnectionSignal	"Answer the signal to report that ExternalDatabaseConnection doesn't know	which Connection to use for a new connection."	^NoDefaultConnection</body><body package="Database" selector="objectLockedSignal">objectLockedSignal	"Answer the signal indicating that an object is locked when attempting to change it in the database."	^ObjectLocked</body><body package="Database" selector="requiredEnvironmentSignal">requiredEnvironmentSignal	"Answer the signal to report that the environment is a required parameter	by this driver and no default was specified."	^RequiredEnvironment</body><body package="Database" selector="requiredPasswordSignal">requiredPasswordSignal	"Answer the signal used to indicate that a password is required in order to 	connect. This signal is proceedable and expects a password string as the 	proceedWith: value."	^RequiredPassword</body><body package="Database" selector="requiredUsernameSignal">requiredUsernameSignal	"Answer the signal used to indicate that a username is required in order to 	connect. This signal is proceedable and expects a username string as the 	proceedWith: value."	^RequiredUsername</body><body package="Database" selector="rowIsReferencedErrorSignal">rowIsReferencedErrorSignal	"Answer the signal indicating that a row may not be deleted nor the primary key changed because it is still referenced."	^RowIsReferencedError</body><body package="Database" selector="syntaxErrorSignal">syntaxErrorSignal	"Answer the signal used to indicate that the SQL text could not be prepared."	^SQLSyntaxError</body><body package="Database" selector="tooManyActiveConnectionsSignal">tooManyActiveConnectionsSignal	"Answer the signal used to indicate that the driver for this connection already	has the maximum number of active connections."	^TooManyActiveConnections</body><body package="Database" selector="tooManyActiveSessionsSignal">tooManyActiveSessionsSignal	"Answer the signal used to indicate that the connection already	has the maximum number of active sessions."	^TooManyActiveSessions</body><body package="Database" selector="tooManyActiveTransactionsSignal">tooManyActiveTransactionsSignal	"Answer the signal used to indicate that the driver for this connection already	has the maximum number of active transactions."	^TooManyActiveTransactions</body><body package="Database" selector="transactionExceptionSignal">transactionExceptionSignal	"Answer the signal used to indicate an error in transaction processing."	^TransactionException</body><body package="Database" selector="transactionPhase2FatalSignal">transactionPhase2FatalSignal 	"Answer the signal used to indicate a fatal error in the second phase of	a two-phase commit or rollback.  This usually means that manual recovery	will be required to complete the transaction."	^TransactionPhase2Fatal</body><body package="Database" selector="unableToAllocateHandleSignal">unableToAllocateHandleSignal	"A handle could not be allocated."	^UnableToAllocateHandle</body><body package="Database" selector="unableToBindSignal">unableToBindSignal	"Answer the signal used to indicate that the input or output bind was unsuccessful."	^UnableToBind</body><body package="Database" selector="unableToCancelCursorSignal">unableToCancelCursorSignal	"The database cursor (statement) could not be canceled.  This signal is not proceedable."	^UnableToCancelCursor</body><body package="Database" selector="unableToCloseCursorSignal">unableToCloseCursorSignal	"The database cursor could not be closed.  This signal is proceedable."	^UnableToCloseCursor</body><body package="Database" selector="unableToConnectToSQLenvironmentSignal">unableToConnectToSQLenvironmentSignal	"Answer the signal used to indicate that the connection cannot be	made to the database environment for some reason other than the server itself.	This signal is used when it is possible to segregate the error causes, otherwise	unableToConnectToSQLserverSignal should be used."	^UnableToConnectToSQLenvironment</body><body package="Database" selector="unableToConnectToSQLserverSignal">unableToConnectToSQLserverSignal	"Answer the signal used to indicate that the connection cannot be	made to the database server.  This signal is used when it is the server that	is the cause of the failure.  If it is possible to segregate the errors, an	unableToConnectToSQLEnvironmentSignal should be used."	^UnableToConnectToSQLserver</body><body package="Database" selector="unableToDescribeSignal">unableToDescribeSignal	"Answer the signal used to indicate that description of a input variable	or an output column could not be acquired."	^UnableToDescribe</body><body package="Database" selector="unableToDisconnectSignal">unableToDisconnectSignal	"Answer the signal used to indicate that an error occurred when trying to	end the connection.   This signal is proceedable."	^UnableToDisconnect</body><body package="Database" selector="unableToExecuteSQLSignal">unableToExecuteSQLSignal	"Answer the signal used to indicate that the prepared SQL text could not be executed."	^UnableToExecuteSQL</body><body package="Database" selector="unableToFetchDataSignal">unableToFetchDataSignal	"Answer the signal used to indicate that the row or rows could not be fetched."	^UnableToFetchData</body><body package="Database" selector="unableToFreeResourceSignal">unableToFreeResourceSignal	"An external resource could not be released/dropped/free'd."	^UnableToFreeResource</body><body package="Database" selector="unableToOpenCursorSignal">unableToOpenCursorSignal	"The database cursor could not be opened."	^UnableToOpenCursor</body><body package="Database" selector="unableToPrepareSignal">unableToPrepareSignal	"Unable to prepare an SQL statement."	^UnableToPrepare</body><body package="Database" selector="unableToQueryDriverInformationSignal">unableToQueryDriverInformationSignal	"Driver information could not be queried."	^UnableToQueryDriverInformation</body><body package="Database" selector="unableToQueryHandleInformationSignal">unableToQueryHandleInformationSignal	"Driver information could not be queried."	^UnableToQueryHandleInformation</body><body package="Database" selector="unsupportedDriverFunctionalitySignal">unsupportedDriverFunctionalitySignal	"Answer the signal indicating an attempt was made to use functionality which is not available from the underlying API due to the current execution circumstances."	^UnsupportedDriverFunctionality</body><body package="Database" selector="unsupportedIsolationLevelSignal">unsupportedIsolationLevelSignal	"Answer the signal indicating an attempt was made to set an unsupported isolation level."	^UnsupportedIsolationLevel</body></methods><methods><class-id>Database.ExternalDatabaseConnection class</class-id> <category>tracing</category><body package="Database" selector="toggleTracing">toggleTracing	"Enable/disable a coarse level of tracing"	"ExternalDatabaseConnection toggleTracing"	Transcript cr; show: (#databaseTracing &lt;&lt; #database &gt;&gt; 'Database tracing ').	( TraceLevel isNil or: [ TraceLevel == 0 ] )		ifTrue:	[ self traceCollector: Transcript.				self traceLevel: 1.				Transcript show: (#enabled &lt;&lt; #database &gt;&gt; 'enabled') asString ]		ifFalse:	[ self traceLevel: 0.				Transcript show: (#disabled &lt;&lt; #database &gt;&gt; 'disabled') asString ].	Transcript flush.</body><body package="Database" selector="traceCollector">traceCollector	"Answer the stream currently receiving any trace output."	^TraceCollector</body><body package="Database" selector="traceCollector:">traceCollector: aWriteStream	"Setup a stream to receive any trace output."	TraceCollector := aWriteStream</body><body package="Database" selector="traceLevel:">traceLevel: anInteger	"Set the level of tracing that is enabled for this class to anInteger."	TraceLevel := anInteger</body></methods><methods><class-id>Database.ExternalDatabaseConnection class</class-id> <category>private-accessing</category><body package="Database" selector="columnDescriptionClass">columnDescriptionClass	"Answer the class to use for column description objects associated with receiver."	^ExternalDatabaseColumnDescription</body><body package="Database" selector="connectionClass">connectionClass	^self</body><body package="Database" selector="platformType">platformType	"Answer the current platform type."	PlatformType isNil		ifTrue: [ PlatformType := self determinePlatformType ].	^PlatformType</body><body package="Database" selector="sessionClass">sessionClass	"Answer the class to use for session objects associated with receiver."	^self subclassResponsibility</body><body package="Database" selector="transactionClass">transactionClass	"Answer the class to use for transaction objects associated with receiver."	^self subclassResponsibility</body><body package="Database" selector="xif">xif	"Answer the ExternalInterface subclass instance to use." 	^self subclassResponsibility</body><body package="Database" selector="xif:">xif: anExternalInterface	"Set the ExternalInterface subclass instance to use." 	xif := anExternalInterface</body></methods><methods><class-id>Database.ExternalDatabaseConnection class</class-id> <category>private-activation</category><body package="Database" selector="determineMacPlatformFrom:">determineMacPlatformFrom: osNameString	"Answer a symbol representing the current platform type."	"ExternalInterface must complete its #returnFromSnapshot processing before	this method can be safely invoked."	"Power Mac  ^#powermac	Mac 68K ^#mac"	| tokens |	tokens := osNameString tokensBasedOn: Character space.	(tokens includes: 'Power') ifTrue: [^#powermac].	^#mac.</body><body package="Database" selector="determinePlatformType">determinePlatformType	"Answer a symbol representing the current platform type."	"ExternalInterface must complete its #returnFromSnapshot processing before	this method can be safely invoked."	| platformArray platformSymbol osNameString |	platformArray := ExternalInterface currentPlatform.	platformSymbol := platformArray at: 1.	osNameString := platformArray at: 2.	#unix == platformSymbol		ifTrue: [^self determineUnixPlatformFrom: osNameString].	#os2 == platformSymbol		ifTrue: [ ^#os2 ].	#win32 == platformSymbol		ifTrue: [^self determineWinTelPlatformFrom: osNameString].	#mac == platformSymbol		ifTrue: [^self determineMacPlatformFrom: osNameString].	^#unknown.</body><body package="Database" selector="determineUnixPlatformFrom:">determineUnixPlatformFrom: unixOSNameString	"Answer a symbol representing the current platform type."	"ExternalInterface must complete its #returnFromSnapshot processing before	this method can be safely invoked."	"Digital Unix ^#alpha_unix	HP Unix ^#hp_unix	IBM Aix ^#aix_unix			Sun Solaris ^#sun5_unix	Sun SunOS ^#sun4_unix"	| tokens |	tokens := unixOSNameString tokensBasedOn: Character space.	(tokens includes: 'osf1') ifTrue: [^#alpha_unix].	(tokens includes: 'hp-ux') ifTrue: [^#hp_unix].	(tokens includes: 'aix') ifTrue: [^#aix_unix].	(tokens includes: 'solaris') ifTrue: [^#sun5_unix].	((tokens includes: 'bsd') and: [tokens includes: 'sun']) ifTrue: [^#sun4_unix].	((tokens includes: 'I386') and: [tokens includes: 'linux']) ifTrue:[^#linux_i386_unix].	((tokens includes: 'Power') and: [tokens includes: 'MacOSX']) ifTrue: [^#Power_MacOSX].	^#unknown</body><body package="Database" selector="determineWinTelPlatformFrom:">determineWinTelPlatformFrom: osNameString	"Answer a symbol representing the current platform type."	"ExternalInterface must complete its #returnFromSnapshot processing before	this method can be safely invoked."	"WinNT  ^#nt				Win95 ^#win95	Win3.1 ^#win32s"	| tokens |	tokens := osNameString tokensBasedOn: Character space.	(tokens includes: 'nt') ifTrue: [^#nt].	(tokens includes: '95') ifTrue: [^#win95].	^#win32s</body><body package="Database" selector="install">install	"Direct this driver (or all drivers if receiver is ExternalDatabaseConnection) to	take the necessary steps for returning from a snapshot.  Notify dependents	when fully installed so that appropriate action may be taken."	"ExternalDatabaseConnection install"	PlatformType := nil.	self == ExternalDatabaseConnection		ifTrue:	[ self subclasses do: [ :each | each install ] ]		ifFalse:	[ self subclassResponsibility ].	"Driver implementations should arrange for each class with a registry to perform	returnFromSnapshot (and anything else important, of course)."</body></methods><methods><class-id>Database.ExternalDatabaseConnection class</class-id> <category>private-updating</category><body package="Database" selector="update:with:from:">update: anAspectSymbol with: aParameter from: aSender 	"In order to aid in sequencing of activities, clients may become dependents of ExternalDatabaseConnection rather than ObjectMemory.  All notifications from ObjectMemory are passed on as if they came from the receiver."	aSender == ObjectMemory ifTrue:		[ "Sometimes the notice should be sent out first so dependents can act before we do."		anAspectSymbol == #aboutToQuit ifTrue:			[ self changed: anAspectSymbol with: aParameter.			^self pause ].		"In other cases, we need to act before notifying the dependents.  Note: fall through to the notification."		anAspectSymbol == #returnFromSnapshot ifTrue:			[ self install ].		"And sometimes we're just sending it on."		self changed: anAspectSymbol with: aParameter ]</body></methods><methods><class-id>Database.ExternalDatabaseResumableException class</class-id> <category>testing</category><body package="Database" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Database.ConnectionProfile</class-id> <category>accessing</category><body package="Database" selector="asConnection">asConnection	^self driverClass new		environment: self environment;		username: self userName;		yourself</body><body package="Database" selector="displayString">displayString	^name isNil		ifTrue: [String new]		ifFalse: [name]</body><body package="Database" selector="driverClass">driverClass	^self driverClassName asQualifiedReference value</body><body package="Database" selector="driverClassName">driverClassName	^driverClassName</body><body package="Database" selector="driverClassName:">driverClassName: aString	driverClassName := aString</body><body package="Database" selector="environment">environment	^environment</body><body package="Database" selector="environment:">environment: aString	environment := aString</body><body package="Database" selector="name">name	^name</body><body package="Database" selector="name:">name: aString	name := aString.	originalName := aString</body><body package="Database" selector="originalName">originalName	^originalName isNil		ifTrue: [String new]		ifFalse: [originalName]</body><body package="Database" selector="password">password	^password</body><body package="Database" selector="password:">password: aString	password := aString</body><body package="Database" selector="resetName">resetName	name := nil</body><body package="Database" selector="userName">userName	^userName</body><body package="Database" selector="userName:">userName: aString	userName := aString</body></methods><methods><class-id>Database.ConnectionProfile</class-id> <category>comparing</category><body package="Database" selector="=">= anObject	^(anObject isKindOf: ConnectionProfile) and:		[self name = anObject name]</body><body package="Database" selector="hash">hash	^name hash</body></methods><methods><class-id>Database.ConnectionProfile</class-id> <category>private</category><body package="Database" selector="isSpecified:">isSpecified: anObject	^anObject notNil and: [anObject isEmpty not]</body></methods><methods><class-id>Database.ConnectionProfile</class-id> <category>initialize-release</category><body package="Database" selector="initialize">initialize	environment := String new.	password := String new</body></methods><methods><class-id>Database.ConnectionProfile</class-id> <category>testing</category><body package="Database" selector="isConnectable">isConnectable	"Answer if the receiver can be used to open a connection right now."	^self isValid and: [self driverClassName asQualifiedReference isDefined]</body><body package="Database" selector="isValid">isValid	"A valid profile is one with enough data to open a connection in principle,	assuming the necessary driver class is present in the image."	^(self isSpecified: driverClassName) and:		[self isSpecified: userName]</body></methods><methods><class-id>Database.ConnectionProfile class</class-id> <category>instance creation</category><body package="Database" selector="new">new	^super new initialize</body></methods><methods><class-id>Database.ExternalDatabaseAnswerStream</class-id> <category>initialize-release</category><body package="Database" selector="initialize">initialize	^self</body></methods><methods><class-id>Database.ExternalDatabaseAnswerStream</class-id> <category>accessing</category><body package="Database" selector="columnDescriptions">columnDescriptions	"Describe the column structure of the answer set for the (current) SQL 	statement or stored procedure.  Answers an instance of	ExternalDatabaseColumnDescription for each column of the answer set."	^self session columnDescriptions</body><body package="Database" selector="columns">columns	"Answer the number of columns in the answer set."	^self session numColumns</body><body package="Database" selector="contents">contents	"The contents are not accessible as a complete unit since they are	not stored in the image. Use upToEnd to return all (remaining) rows."	^self shouldNotImplement</body><body package="Database" selector="flush">flush	^self shouldNotImplement</body><body package="Database" selector="next">next	"Answer the next row from the answer stream."	| row |	( nextRow == nil )		ifTrue: [ self getNextRow ].	( session == nil )		ifTrue: [ ^self class endOfStreamSignal raise ].	row := nextRow.	nextRow := nil.	^row</body><body package="Database" selector="next:into:startingAt:">next: anInteger into: aSequenceableCollection startingAt: startIndex 	"Store the next anInteger elements of the receiver into aSequenceableCollection 	starting at startIndex in aSequenceableCollection. Answer aSequenceableCollection.	Since there must be a unique object for every entry of the set, the allocateForEachRow	control in the session is ignored and  a copy of the bindOutput object is always made."	| index stopIndex |	index := startIndex.	stopIndex := index + anInteger.	[ | getRow |			session allocateForEachRow				ifTrue:	[ getRow :=  [ self next ]		"next made the copy" ]				ifFalse:	[ getRow := [ self next copy ] 	"next didn't make the copy" ].			[ index &lt; stopIndex ]				whileTrue:					[ "Collect the next row by executing the getRow block from					above and then insert into the collection."					aSequenceableCollection at: index put: getRow value.					index := index + 1 ] ]		on: Stream endOfStreamSignal		do: [:ex | 			ex isResumable 				ifTrue: [ex resume]				ifFalse: [ex restartDo:					[(Stream incompleteNextCountSignal newExceptionFrom: self)						parameter: index - startIndex;						raiseRequest]]].	^aSequenceableCollection</body><body package="Database" selector="nextPut:">nextPut: anObject 	self shouldNotImplement</body><body package="Database" selector="peek">peek	"Answer the next row from the answer stream without consuming the row.	If the end of the answer stream has been reached, answer nil.	Applications should be aware that this method may cause the current	row to advance in order to detect the existence of an additional row.	If the application is dependent on a consistent view of the current	row (perhaps for WHERE CURRENT OF operations), peek should not	be used after a next until completing all processing of the current row."	nextRow isNil		ifTrue: [ self getNextRow ].	^session isNil ifTrue: [ nil ] ifFalse: [ nextRow ]</body><body package="Database" selector="upToEnd">upToEnd	"Answer the current contents of the receiver's input stream. All rows of the answer	set are fetched. Since there must be a unique object for every entry of the set, the	allocateForEachRow control in the session is ignored and  a copy of the bindOutput	object is always made."	| cont getRow |	cont := WriteStream on: (self contentsSpecies new: 512).	session allocateForEachRow		ifTrue:	[ getRow :=  [ self next ]		"next made the copy" ]		ifFalse:	[ getRow := [ self next copy ] 	"next didn't make the copy" ].	[ self atEnd ]		whileFalse: [ cont nextPut: getRow value ].	^cont contents</body></methods><methods><class-id>Database.ExternalDatabaseAnswerStream</class-id> <category>status</category><body package="Database" selector="close">close	"Sets the status of the stream to be closed."	session notNil ifTrue:		[ session cancelAnswerSet.		self dismiss ].</body></methods><methods><class-id>Database.ExternalDatabaseAnswerStream</class-id> <category>testing</category><body package="Database" selector="atEnd">atEnd	"Answer whether there are any more rows to be processed.	Applications should be aware that this method may cause the current	row to advance in order to detect the existence of additional rows.	If the application is dependent on a consistent view of the current	row (perhaps for WHERE CURRENT OF operations), atEnd should not	be used after a next until completing all processing of the row returned."	( nextRow == nil )		ifTrue: [ self getNextRow ].	^session == nil</body></methods><methods><class-id>Database.ExternalDatabaseAnswerStream</class-id> <category>private-accessing</category><body package="Database" selector="getNextRow">getNextRow	"Get the next row of data into nextRow.  If no more rows, dismiss the receiver."	| row |	( session == nil ) ifTrue: [ ^self ].	row := session nextRowExternal.	( row == nil )		ifTrue: [ self dismiss ]		ifFalse: [ nextRow := row ]</body><body package="Database" selector="session">session	^session</body><body package="Database" selector="session:">session: aSession	session := aSession</body></methods><methods><class-id>Database.ExternalDatabaseAnswerStream</class-id> <category>private-activation</category><body package="Database" selector="activate">activate	"Should never be sent because answer streams do not remain a participant 	when quiesced so no parent will retain a reference and send activate."	^self shouldNotImplement</body><body package="Database" selector="dismiss">dismiss	session answerStreamDismissed.	self session: nil</body><body package="Database" selector="quiesce">quiesce	"Answer streams cannot be reactivated so quiesce is the same as dismiss."	self dismiss</body></methods><methods><class-id>Database.ExternalDatabaseAnswerStream</class-id> <category>private-testing</category><body package="Database" selector="isExecutor">isExecutor	"Answer true if the receiver is really an executor, not the primary object."	"AnswerStreams never hold external resources themselves and so will never have executors."	^false</body></methods><methods><class-id>Database.ExternalDatabaseAnswerStream class</class-id> <category>instance creation</category><body package="Database" selector="new">new	^self error: (#errNewAnswerStream &lt;&lt; #database &gt;&gt; 'An ExternalDatabaseAnswerStream is obtained from an instance of ExternalDatabaseSession')</body></methods><methods><class-id>Database.ExternalDatabaseAnswerStream class</class-id> <category>private-instance creation</category><body package="Database" selector="newForSession:">newForSession: aSession 	"Create a new ExternalDatabaseAnswerStream instance 	associated with the session aSession."	| ans |	(ans := self basicNew)		initialize;		session: aSession.	^ans</body></methods><methods><class-id>Database.ExternalDatabaseTransaction</class-id> <category>initialize-release</category><body package="Database" selector="initialize">initialize	"Establish instance variables that require special handling."	super initialize.	self state: #xactNo.	self memberCountHolder: 0 asValue.	self remainingCountHolder: 0 asValue</body></methods><methods><class-id>Database.ExternalDatabaseTransaction</class-id> <category>testing</category><body package="Database" selector="inTransactionMode">inTransactionMode	"Answer true if a transaction has been started."	| s |	^((s := self state) == #xactYes or: [ s == #committing ]) or: [ s == #aborting ]</body></methods><methods><class-id>Database.ExternalDatabaseTransaction</class-id> <category>transactions</category><body package="Database" selector="begin">begin	"Mark the beginning of a transaction.  If an error occurs, prevent any further	activity on any of the participanting connections.  This is achieved by	disconnecting without further transaction actions and letting the database	manager take whatever action as the disconnects occur."	self state == #xactNo ifFalse:		[ self class connectionClass invalidTransactionStateSignal raise ].	"If we can't begin successfully, the only response is to refuse to do any work."	[ self state: #xactYes.	self remainingCount: self memberCount.	self beginExternal.	self participantsDo: [ :each | each beginExternal ] ]		ifCurtailed:			[ self state: #xactNo.	"Will prevent connections from trying to do xact termination."			self participantsDo: [ :each | each disconnect ] ]</body><body package="Database" selector="commit">commit	"Coordinate the commit for all related connections.	If an individual connection can't do its part, go on to the others	and reraise an exception when all have tried.  The parameter to the	exception will be all the exception's parameters aggregated."	^self finishTransaction: #committing method: #commitExternal</body><body package="Database" selector="rollback">rollback	"Coordinate the rollback for all related connections.	If an individual connection can't do its part, go on to the others	and reraise an exception when all have tried.  The parameter to the	exception will be all the exception's parameters aggregated."	^self finishTransaction: #aborting method: #rollbackExternal</body></methods><methods><class-id>Database.ExternalDatabaseTransaction</class-id> <category>private-accessing</category><body package="Database" selector="acquireTrigger">acquireTrigger	"Answer number of participants required to trigger acquire/dismiss."	^nil		"never acquire"</body><body package="Database" selector="memberCount">memberCount	"Answer the number of members in a coordinated transaction."	^self memberCountHolder value</body><body package="Database" selector="memberCount:">memberCount: aSmallInteger	"Set the number of members in a coordinated transaction."	self memberCountHolder value: aSmallInteger</body><body package="Database" selector="memberCountHolder">memberCountHolder	"Answer the holder for the number of members in a coordinated transaction."	^memberCountHolder</body><body package="Database" selector="memberCountHolder:">memberCountHolder: anExternalDatabaseValueHolder	"Set the holder for the number of members in a coordinated transaction."	memberCountHolder := anExternalDatabaseValueHolder</body><body package="Database" selector="remainingCount">remainingCount	"Answer the number of members remaining in a coordinated transaction."	^self remainingCountHolder value</body><body package="Database" selector="remainingCount:">remainingCount: aSmallInteger	"Set the number of members remaining in a coordinated transaction."	self remainingCountHolder value: aSmallInteger</body><body package="Database" selector="remainingCountHolder">remainingCountHolder	"Answer the holder for the number of members remaining in a coordinated transaction."	^remainingCountHolder</body><body package="Database" selector="remainingCountHolder:">remainingCountHolder: anExternalDatabaseValueHolder	"Set the holder for the number of members remaining in a coordinated transaction."	remainingCountHolder := anExternalDatabaseValueHolder</body></methods><methods><class-id>Database.ExternalDatabaseTransaction</class-id> <category>private-activation</category><body package="Database" selector="acquire">acquire	"Record existence of active member of this coordinated transaction."	self memberCount: self memberCount + 1</body><body package="Database" selector="activate">activate	super activate.	self state: #xactNo</body><body package="Database" selector="dismiss">dismiss	"Record departure of active member of this coordinated transaction."	self memberCount: self memberCount - 1</body></methods><methods><class-id>Database.ExternalDatabaseTransaction</class-id> <category>private-finalization</category><body package="Database" selector="executor">executor	"Answer with the executor."	"Subclassess which want to override to add information to the executor	should use super executor to create the executor initially."	| ex |	ex := super executor.	ex memberCountHolder: self memberCountHolder.	ex remainingCountHolder: self remainingCountHolder.	^ex</body></methods><methods><class-id>Database.ExternalDatabaseTransaction</class-id> <category>private-library calls</category><body package="Database" selector="beginExternal">beginExternal	"Perform driver-specific work at the beginning of a transaction."	^self subclassResponsibility</body><body package="Database" selector="commitExternal">commitExternal	"Perform driver-specific work at the completion of a transaction."	^self subclassResponsibility</body><body package="Database" selector="rollbackExternal">rollbackExternal	"Perform driver-specific work at the completion of a transaction."	^self subclassResponsibility</body></methods><methods><class-id>Database.ExternalDatabaseTransaction</class-id> <category>private-transactions</category><body package="Database" selector="executorFinishingTransaction">executorFinishingTransaction		| action s |	( traceLevel &gt;= 1 ) ifTrue:		[ (self traceStream)			nextPutAll: (#state &lt;&lt; #database &gt;&gt; 'state: ') asString; print: self state.		self class trace: self emitTrace ].	"If nobody else has tried to finish up the transaction, we need to roll it back."	(s := self state) == #xactYes		ifTrue:	[ ^self rollback ].	"We're finishing up the transaction, but due to garbage collection, the executor which sent	this message didn't hear about it.  Carry on with what we're doing."	s == #committing		ifTrue:	[ action := #commitExternal ].	s == #aborting		ifTrue:	[ action := #rollbackExternal ].	self participantsDo:		[ :each |		each state == #xactYes ifTrue:			[ each perform: action.			self remainingCount: (self remainingCount - 1) ] ].	self remainingCount == 0		ifTrue:	[ self state: #xactNo ]</body><body package="Database" selector="finishTransaction:method:">finishTransaction: finishingState method: selector 	"Coordinate the completion of the transaction for all related connections.	The finishingState is used until all of the transaction members have done	their part of finishing the transaction.  The selector is the method to use to	invoke the driver-specific action.  If an individual connection can't do its part,	go on to the others and reraise an exception when all have tried. The parameter	to the exception will be all the exception's parameters aggregated.	Errors while finishing a transaction lead to all participating connections being	prevented from any further work (they are disconnected)."	| exParams |	self state == #xactYes 		ifFalse: [^self class connectionClass invalidTransactionStateSignal raise].	exParams := nil.	"The finishingState will remain until all participants (including	any being finalized) check in and complete their part."	self state: finishingState.	"Phase 1 is performed by the driver's transaction implementation of	commitExternal or rollbackExternal.  If an error occurs here, the unwind	block will render each of the participants unable to do further processing."	[self perform: selector] ifCurtailed: 			[self state: #xactNo.			self participantsDo: [:each | each disconnect]].	"Phase 2 is performed by each participant's implementation of	commitExternal or rollbackExternal.  In systems that do not support	a 2-phase commit, this provides the serial broadcast form of commit	or rollback.  Capture any errors that occur here, but attempt to finish	the remaining transactions.  In any event, manual intervention will be	required to complete the transaction."	self participantsDo: 			[:each | 			[each perform: selector] 				on: self class connectionClass externalDatabaseErrorSignal				do: 					[:ex | 					exParams isNil ifTrue: [exParams := OrderedCollection new].					ex parameter notNil ifTrue: [exParams addAll: ex parameter].					ex return].			"Accumulate the exception parameters"			self remainingCount: self remainingCount - 1].	self remainingCount == 0 ifTrue: [self state: #xactNo].	exParams notNil 		ifTrue: 			[self state: #xactNo.			self participantsDo: [:each | each disconnect].			exParams isEmpty 			ifTrue: [ self class connectionClass transactionPhase2FatalSignal raiseSignal: nil ] 			ifFalse: [ self class connectionClass transactionPhase2FatalSignal raiseWith: exParams errorString: exParams first dbmsErrorString ]]</body></methods><methods><class-id>Database.ExternalDatabaseTransaction class</class-id> <category>instance creation</category><body package="Database" selector="new">new	"Applications never use transaction objects directly."	^super new initialize.</body></methods><methods><class-id>UI.UISettings class</class-id> <category>user preferences</category><body package="Database" selector="addDatabaseSectionTo:development:runtime:">addDatabaseSectionTo: aDictionary development: devSpecs runtime: runtimeSpecs	"Add the Lens set of preferences and settings slices to the arguments."	aDictionary		at: #databaseAccept put: [self databaseAccept];		at: #databaseReset put: [self databaseReset].	self ensure: aDictionary		hasModelFor: #dbDevUsername		editing: #dbDevUsernameEditing		default: ''.	self ensure: aDictionary		hasModelFor: #dbDevPassword		editing: #dbDevPasswordEditing		default: ''.	self ensure: aDictionary		hasModelFor: #dbDevEnvironment		editing: #dbDevEnvironmentEditing		default: ''.	self ensure: aDictionary		hasModelFor: #dbUserUsername		editing: #dbUserUsernameEditing		default: ''.	self ensure: aDictionary		hasModelFor: #dbUserPassword		editing: #dbUserPasswordEditing		default: ''.	devSpecs		addLast: (#Database &lt;&lt; #database &gt;&gt; 'Database')-&gt;#(#databaseSpec #databaseHelp)</body></methods><methods><class-id>UI.UISettings class</class-id> <category>accessing preferences</category><body package="Database" selector="databaseAccept">databaseAccept	(self preferenceModelFor: #dbDevUsername)		value: (self preferenceFor: #dbDevUsernameEditing).	(self preferenceModelFor: #dbDevPassword)		value: (self preferenceFor: #dbDevPasswordEditing).	(self preferenceModelFor: #dbDevEnvironment)		value: (self preferenceFor: #dbDevEnvironmentEditing).	(self preferenceModelFor: #dbUserUsername)		value: (self preferenceFor: #dbUserUsernameEditing).	(self preferenceModelFor: #dbUserPassword)		value: (self preferenceFor: #dbUserPasswordEditing).</body><body package="Database" selector="databaseReset">databaseReset	(self preferenceModelFor: #dbDevUsernameEditing)		value: (self preferenceFor: #dbDevUsername).	(self preferenceModelFor: #dbDevPasswordEditing)		value: (self preferenceFor: #dbDevPassword).	(self preferenceModelFor: #dbDevEnvironmentEditing)		value: (self preferenceFor: #dbDevEnvironment).	(self preferenceModelFor: #dbUserUsernameEditing)		value: (self preferenceFor: #dbUserUsername).	(self preferenceModelFor: #dbUserPasswordEditing)		value: (self preferenceFor: #dbUserPassword).</body></methods><methods><class-id>UI.UISettings</class-id> <category>help</category><body package="Database" selector="databaseHelp">databaseHelp	^(#GenKeyDatabaseHelp &lt;&lt; #database &gt;&gt; 'Database DefaultsDatabase Development Tools such as the Data Model Editor and Query Editor require access to database tables. The entries under Development Tools Defaults are used as default parameters when using these tools.The entries under User Application Defaults are used when actually running database applications.')</body></methods><methods><class-id>UI.TableAdaptor</class-id> <category>accessing</category><body package="Database" selector="elementSize">elementSize	^baseCollection size</body></methods><methods><class-id>Database.ConnectionDialog class</class-id> <category>interface specs</category><body package="Database" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #ConnectToDatabase #defaultString: 'Connect to Database' #catalogID: #database) 			#min: #(#{Core.Point} 426 216 ) 			#max: #(#{Core.Point} 426 216 ) 			#bounds: #(#{Graphics.Rectangle} 512 384 938 600 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.Rectangle} 140 14 320 38 ) 					#name: #connectionProfile 					#model: #connectionProfileHolder 					#type: #string 					#comboList: #connectionProfileListHolder ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.Rectangle} 140 56 310 79 ) 					#name: #databaseCombo 					#model: #databaseHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #databaseChanged ) 					#type: #string 					#comboList: #databaseListHolder ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.Rectangle} 140 85 310 109 ) 					#name: #environmentCombo 					#model: #environmentHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #environmentChanged ) 					#isReadOnly: false 					#comboList: #environmentListHolder ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.Rectangle} 140 114 310 138 ) 					#name: #userNameCombo 					#model: #userNameHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #userNameChanged ) 					#isReadOnly: false 					#comboList: #userNameListHolder ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 140 143 310 167 ) 					#name: #passwordField 					#model: #passwordHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #passwordChanged ) 					#type: #password ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 140 175 220 198 ) 					#name: #saveProfile 					#model: #saveProfile 					#label: #(#{Kernel.UserMessage} #key: #Save #defaultString: 'Save...' #catalogID: #database) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 230 175 310 198 ) 					#name: #deleteProfile 					#model: #deleteProfile 					#label: #(#{Kernel.UserMessage} #key: #Delete #defaultString: 'Delete' #catalogID: #database) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 14 0 -10 1 39 0 ) 					#name: #connect 					#model: #connect 					#label: 					#(#{Kernel.UserMessage} 						#key: #Connect 						#defaultString: 'Connect' 						#catalogID: #database ) 					#isDefault: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 46 0 -10 1 71 0 ) 					#name: #cancel 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #database ) 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 80 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #interface						#defaultString: 'Interface:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 138 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #userName 						#defaultString: 'User Name:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 167 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #password 						#defaultString: 'Password:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 109 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #environment 						#defaultString: 'Environment:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 9 0 38 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #profile 						#defaultString: 'Connection Profile:' 						#catalogID: #database ) ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 10 46 320 210 ) ) ) ) )</body></methods><methods><class-id>Database.AdHocQueryTool class</class-id> <category>interface specs</category><body package="Database" selector="buffersSpec">buffersSpec	"UIPainter new openOnClass: self andSelector: #buffersSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: '' 			#min: #(#Point 317 76 ) 			#max: #(#Point 317 76 ) 			#bounds: #(#Rectangle 326 467 643 543 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#InputFieldSpec 					#layout: #(#LayoutFrame -64 1 8 0 -24 1 32 0 ) 					#model: #blockFactorModel 					#alignment: #right 					#type: #number ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -82 0.5 -35 1 -8 0.5 -4 1 ) 					#model: #accept 					#label: #(#{UserMessage} #key: #OK #catalogID: #database #defaultString: 'OK' )					#isDefault: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 16 0.5 -35 1 89 0.5 -4 1 ) 					#model: #cancel 					#label: #(#{UserMessage} #key: #Cancel #catalogID: #database #defaultString: 'Cancel' )					#defaultable: true ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin -66 1 32 0 1 1 ) 					#label: #(#{UserMessage} #key: #bufferRows #catalogID: #database #defaultString: 'Number of rows to buffer internally:') ) ) ) )</body><body package="Database" selector="connectSpec">connectSpec	"UIPainter new openOnClass: self andSelector: #connectSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: '' 			#min: #(#Point 302 162 ) 			#max: #(#Point 302 162 ) 			#bounds: #(#Rectangle 559 265 861 427 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#InputFieldSpec 					#layout: #(#LayoutFrame 152 0 35 0 -11 1 59 0 ) 					#model: #usernameModel ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 152 0 65 0 -11 1 89 0 ) 					#model: #passwordModel 					#type: #password ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 152 0 95 0 -11 1 119 0 ) 					#model: #environmentModel ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -82 0.5 -35 1 -8 0.5 -4 1 ) 					#model: #accept 					#label: #(#{UserMessage} #key: #OK #catalogID: #database #defaultString: 'OK' ) 					#isDefault: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 16 0.5 -36 1 89 0.5 -5 1 ) 					#model: #cancel 					#label: #(#{UserMessage} #key: #Cancel #catalogID: #database #defaultString: 'Cancel' ) 					#defaultable: true ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 120 0 0 1 ) 					#label: #(#{UserMessage} #key: #environment #catalogID: #database #defaultString: 'Environment:') ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 60 0 0 1 ) 					#label: #(#{UserMessage} #key: #userName #catalogID: #database #defaultString: 'User Name:') ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 90 0 0 1 ) 					#label: #(#{UserMessage} #key: #password #catalogID: #database #defaultString: 'Password:') ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 30 0 0 1 ) 					#label: #(#{UserMessage} #key: #databaseConnect #catalogID: #database #defaultString: 'Database Connect:') ) 				#(#MenuButtonSpec 					#layout: #(#LayoutFrame 152 0 5 0 -11 1 29 0 ) 					#model: #whichDriverModel 					#menu: #installedDBConnectsMenu ) ) ) )</body><body package="Database" selector="reportErrorSpec">reportErrorSpec	"UIPainter new openOnClass: self andSelector: #reportErrorSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: '' 			#min: #(#Point 313 200 ) 			#max: #(#Point 313 200 ) 			#bounds: #(#Rectangle 267 274 580 474 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#TextEditorSpec 					#layout: #(#LayoutFrame 0 0 0 0 0 1 -40 1 ) 					#name: #errorText 					#model: #errorText 					#tabable: true 					#menu: #errorTextMenu 					#isReadOnly: false ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -25 0.5 -35 1 25 0.5 -5 1 ) 					#model: #accept 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #database) 					#isDefault: true 					#defaultable: true ) ) ) )</body><body package="Database" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{UserMessage} #key: #adHocSQL #catalogID: #database #defaultString: 'Ad Hoc SQL' )			#min: #(#Point 458 317 ) 			#max: #(#Point 1152 900 ) 			#bounds: #(#Rectangle 86 132 544 449 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#ActionButtonSpec 					#layout: #(#Rectangle 10 5 90 35 ) 					#name: #connect 					#model: #connect 					#label: #(#{UserMessage} #key: #Connect #catalogID: #database #defaultString: 'Connect' )					#isDefault: false ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 100 5 200 35 ) 					#name: #disconnect 					#flags: 40 					#model: #disconnect 					#label: #(#{UserMessage} #key: #disconnect1 #catalogID: #database #defaultString: 'Disconnect') ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 210 5 300 35 ) 					#name: #execute 					#flags: 40 					#model: #execute 					#label: #(#{UserMessage} #key: #execute #catalogID: #database #defaultString: 'Execute') ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 310 5 420 35 ) 					#name: #nextAnswer 					#flags: 40 					#model: #nextAnswer 					#label: #(#{UserMessage} #key: #nextAnswer1 #catalogID: #database #defaultString: 'Next Answer') ) 				#(#TextEditorSpec 					#layout: #(#LayoutFrame 0 0 40 0 0 1 -3 0.33 ) 					#name: #query 					#model: #queryModel ) 				#(#TableViewSpec 					#layout: #(#LayoutFrame 0 0 0 0.33 0 1 0 1 ) 					#model: #tableModel 					#showHGrid: true 					#showVGrid: true 					#selectionStyle: #row ) ) ) )</body></methods><methods><class-id>Database.AdHocQueryTool class</class-id> <category>resources</category><body package="Database" selector="errorTextMenu">errorTextMenu	"MenuEditor new openOnClass: self andSelector: #errorTextMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#rawLabel: #(#{UserMessage} #key: #copy #catalogID: #database #defaultString: 'copy' )				#value: #copySelection ) ) #(1 ) nil ) decodeAsLiteralArray</body><body package="Database" selector="menuBar">menuBar	"MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#rawLabel: #(#{UserMessage} #key: #connection #catalogID: #database #defaultString: '&amp;Connection' )				#submenu: #(#Menu #(						#(#MenuItem 							#rawLabel: #(#{UserMessage} #key: #connect #catalogID: #database #defaultString: '&amp;Connect...' )							#nameKey: #connect 							#value: #connect ) 						#(#MenuItem 							#rawLabel: #(#{UserMessage} #key: #disconnect #catalogID: #database #defaultString: '&amp;Disconnect' )							#enabled: false 							#nameKey: #disconnect 							#value: #disconnect ) 						#(#MenuItem 							#rawLabel: #(#{UserMessage} #key: #Exit #catalogID: #database #defaultString: 'E&amp;xit' )							#value: #closeRequest ) ) #(3 ) nil ) ) 			#(#MenuItem 				#rawLabel: #(#{UserMessage} #key: #Execution #catalogID: #database #defaultString: '&amp;Execution' )				#submenu: #(#Menu #(						#(#MenuItem 							#rawLabel: #(#{UserMessage} #key: #Execute #catalogID: #database #defaultString: '&amp;Execute' )							#enabled: false 							#nameKey: #execute 							#value: #execute ) 						#(#MenuItem 							#rawLabel: #(#{UserMessage} #key: #nextAnswer #catalogID: #database #defaultString: '&amp;Next Answer' )							#enabled: false 							#nameKey: #nextAnswer 							#value: #nextAnswer ) 						#(#MenuItem 							#rawLabel: #(#{UserMessage} #key: #buffers #catalogID: #database #defaultString: '&amp;Buffers...' )							#nameKey: #fetchBuffers 							#value: #fetchBuffers ) ) #(3 ) nil ) ) ) #(2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-database</category><body package="Database" selector="database1DevelopmentUserName">database1DevelopmentUserName	&lt;setting: #(database developmentUserName)&gt;	^(StringSetting onUISetting: #dbDevUsername)		label: #DeveloperName &lt;&lt; #labels &gt;&gt; 'Developer name';		helpText: #DeveloperNameHelpText &lt;&lt; #dialogs &gt;&gt; 'User name used by database development tools in the image.'</body><body package="Database" selector="database2DevelopmentPassword">database2DevelopmentPassword	&lt;setting: #(database developmentPassword)&gt;	^(StringSetting forPassword onUISetting: #dbDevPassword)		label: #DeveloperPassword &lt;&lt; #labels &gt;&gt; 'Developer password';		helpText: #DeveloperPasswordHelpText &lt;&lt; #dialogs &gt;&gt; 'Database password used by the developer tools in the image.'</body><body package="Database" selector="database3DevelopmentEnvironment">database3DevelopmentEnvironment	&lt;setting: #(database developmentEnvironment)&gt;	^(StringSetting onUISetting: #dbDevEnvironment)		label: #DeveloperEnvironment &lt;&lt; #labels &gt;&gt; 'Developer environment';		helpText: #DeveloperEnvironmentHelpText &lt;&lt; #dialogs &gt;&gt; 'Database environment string used by the developer tools in the image.'</body><body package="Database" selector="database4UserUserName">database4UserUserName	&lt;setting: #(database userUserName)&gt;	^(StringSetting onUISetting: #dbUserUsername)		label: #DbUserName &lt;&lt; #labels &gt;&gt; 'User name';		helpText: #DbUserNameHelpText &lt;&lt; #dialogs &gt;&gt; 'Database user name used when running database applications.'</body><body package="Database" selector="database5UserPassword">database5UserPassword	&lt;setting: #(database userPassword)&gt;	^(StringSetting forPassword onUISetting: #dbUserPassword)		label: #DbPassword &lt;&lt; #labels &gt;&gt; 'Password';		helpText: #DbPasswordHelpText &lt;&lt; #dialogs &gt;&gt; 'Database password used when running database applications.'</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="Database" selector="databasePage">databasePage	&lt;settingsPage: #(tools database)&gt;	^ModularSettingsPage new		label: #Database &lt;&lt; #labels &gt;&gt; 'Database';		icon: (ListIconLibrary visualFor: #database);		settings: (self settingsWithPrefix: #(database))</body></methods><initialize><class-id>Database.AdHocQueryTool</class-id></initialize><initialize><class-id>Database.ExternalDatabaseFramework</class-id></initialize><initialize><class-id>Database.ExternalDatabaseConnection</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>TableAdaptor</name><environment>UI</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents baseCollection adaptors columnSize transposed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Collections</category><attributes><package>UIBasics-Collections</package></attributes></class><class><name>Stream</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class><class><name>UISettings</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>list disturbed subBuilder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Support</category><attributes><package>Interface-Support</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>