<?xml version="1.0"?><st-source><!-- Name: Debugger-ProbesComment: PDP Probes for VW 7DbIdentifier: bear73DbTrace: 53303DevelopmentPrerequisites: #(#(#any 'Debugger-Compiler-Modifications' ''))PackageName: Debugger-ProbesParcel: #('Debugger-Probes')PrerequisiteParcels: #(#('Debugger-Compiler-Modifications' ''))PrintStringCache: (7.3.1 - 1.1,bobw)Version: 7.3.1Post-Load Block: 	[:package | |imp|CraftedSmalltalk.CodeProbe initializeMethods.CraftedSmalltalk.DisplayActionProbe initializeMethods.CraftedSmalltalk.ProbeTestExpressionEditor initializeLibrary.CraftedSmalltalk.ProbeActionExpressionEditor initializeLibrary.imp := GeneralNameSpaceImport path: #(#CraftedSmalltalk).Smalltalk addImport: imp]Post-Unload Block: 	[''Remove the import that we added''|imp|imp := GeneralNameSpaceImport path: #(#CraftedSmalltalk).Smalltalk removeImport: imp]Date: 5:54:08 pm April 10, 2005 --><time-stamp>From VisualWorksÂ®, 7.3.1 of April 10, 2005 on April 10, 2005 at 5:54:08 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>CraftedSmalltalk</name><environment>Smalltalk</environment><private>true</private><imports>			private Smalltalk.*			</imports><category>CraftedSt</category><attributes><package>Debugger-Probes</package></attributes></name-space><class><name>SilentProbeExprCompilerErrorHandler</name><environment>CraftedSmalltalk</environment><super>Kernel.CompilerErrorHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Compiler</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.SilentProbeExprCompilerErrorHandler</class-id><body>SilentProbeExprCompilerErrorHandler	Version 1.1Copyright 1997,1998 Crafted SmalltalkAll Rights ReservedThis class is used to handle errors that may generated by the automatic compilation ofprobe expressions.</body></comment><class><name>RemovedProbedMethodsBrowser</name><environment>CraftedSmalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methods methodList hiddenMethods selectedMethods showHidden textHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Tools</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.RemovedProbedMethodsBrowser</class-id><body>RemovedProbedMethodsBrowser	Version 1.0Copyright 1997 Crafted SmalltalkAll Rights ReservedThe RemovedProbedMethodsBrowser is used to browse and manage ProbedCompiledMethodsthat were removed as a result of recompiling a class.  With a RemovedProbedMethodsBrowser theuser can browse and select methods so that their probes may be reinserted.Instance Variables:	methods			&lt;SortedCollection of: ProbedCompiledMethod&gt;					The list of methods to be used for browsing or probe reinsertion.	methodList			&lt;MultiSelectionInList of: ProbedCompiledMethod&gt;	The list of methods being displayed.	hiddenMethods		&lt;SortedCollection of: ProbedCompiledMethod&gt;					A list of methods that were removed from "methods".	selectedMethods	&lt;Array of: ProbedCompiledMethod&gt;	The list of methods selected by the user.	showHidden			&lt;Boolean&gt;		If true, "hiddenMethods" is displayed instead of "methods"	textHolder			&lt;ValueHolder on: Text&gt;	Holds the selected method's source text.</body></comment><class><name>ProbeExprCompiler</name><environment>CraftedSmalltalk</environment><super>Kernel.Compiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>compileForProbes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Compiler</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.ProbeExprCompiler</class-id><body>ProbeExprCompiler	Version 1.1Copyright 1995,1998 Crafted SmalltalkAll Rights ReservedSpecializes the compiler to work with probed methods and probe expressions.Instance Variables:	compileForProbes		&lt;Boolean&gt;  Instructs the compiler to force all blocks to be full blocks.</body></comment><class><name>MethodActionRecord</name><environment>CraftedSmalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>action class selector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Tools support</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.MethodActionRecord</class-id><body>MethodActionRecord	Version 1.0Copyright 1995 Crafted SmalltalkAll Rights ReservedInstances of MethodActionRecord are used by Browser's class probe panels to conveyinformation to the methods inserting the probes into the selected methods.Instance Variables:	action		&lt;Integer&gt;		class		&lt;Class&gt;	selector		&lt;Symbol&gt;</body></comment><class><name>PDPWeakDictionary</name><environment>CraftedSmalltalk</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyArray valueArray tally accessLock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Dbgr support</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.PDPWeakDictionary</class-id><body>PDPWeakDictionary	Version 1.1Copyright 1995,1997 Crafted SmalltalkAll Rights ReservedPDPWeakDictionary is a partial implementation of an identity dictionary.  It was done so that either thekeys or the values could be weak references.Instance Variables:	accessLock		&lt;RecursionLock&gt;  Protects elements from conflicting access					during use and element expiration.	keyArray		&lt;Array | WeakArray&gt;	The keys.	valueArray		&lt;Array | WeakArray&gt;	The values.	tally			&lt;Integer&gt;	The number of items in the dictionary.Class Variables:		"Copied from Set"	ImproperCreationSizeSignal		&lt;Signal&gt;				Used to indicate an attempt to create an instance with an inappropriate size.	PrimeMap						&lt;ByteArray&gt;				Used to map the first some integers to primes, used in calculating instance				sizes -- prime numbers make good hash divisors.  Each byte contains				the distance from the index'th odd number to the nearest higher prime.	MaxMapped						&lt;Integer&gt;	Last integer that is mapped by PrimeMap.</body></comment><class><name>ProbeCreationSpec</name><environment>CraftedSmalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>probeClass conditional permanent selectWindowParams isAutoProbe </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Tools support</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.ProbeCreationSpec</class-id><body>ProbeCreationSpec	Version 1.0Copyright 1995 Crafted SmalltalkAll Rights ReservedInstances of ProbeCreationSpec specify the type of probe to be created.,Instance Variables:	probeClass					&lt;Class&gt;	The class of the probe to create.	conditional					&lt;Boolean&gt;	If true the probe will have a conditional expression.	permanent					&lt;Boolean&gt;	If true the probe will be a permanent probe.	selectWindowParams		&lt;Boolean&gt;	If true the select windows panel will be opened.</body></comment><class><name>WatchWindowHolder</name><environment>CraftedSmalltalk</environment><super>UI.TextCollector</super><private>false</private><indexed-type>none</indexed-type><inst-vars>window label doLogging displayBox labelView </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Probes</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.WatchWindowHolder</class-id><body>WatchWindowHolder	Version 1.0Copyright 1995 Crafted SmalltalkAll Rights ReservedWatchWindowHolder is a specialized text collector for watch windows.  Italso holds additional information about the window that is reused aftera window is closed then reopenedInstance Variables:	window			&lt;ScheduledWindow | nil&gt;	The watch window.	label			&lt;String&gt;	The watch window label.	doLogging		&lt;Boolean&gt;		Specifies whether logging or replacement is done.	displayBox		&lt;Rectangle&gt;	The watch window display box.	labelView		&lt;BorderedWrapper | nil&gt;	The watch window label view.</body></comment><class><name>ProbedCompiledBlock</name><environment>CraftedSmalltalk</environment><super>Kernel.CompiledBlock</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>probeStart auxInfo </inst-vars><class-inst-vars></class-inst-vars><imports>			OpcodePool.*			</imports><category>CraftedSt-VM</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.ProbedCompiledBlock</class-id><body>ProbedCompiledBlock	Version 1.0Copyright 1995,1996 Crafted SmalltalkAll Rights ReservedInstances of ProbedCompiledBlock replace CompiledBlocks in a ProbedCompiledMethod.Instance Variables:	probeStart			&lt;Integer&gt;	The starting index of the probes.	auxInfo				&lt;AuxCodeInfoExtractor&gt;	The extractor used for this block method.</body></comment><class><name>AbstractCodeProbe</name><environment>CraftedSmalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>probeRecord parent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Probes</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.AbstractCodeProbe</class-id><body>AbstractCodeProbe	Version 1.0Copyright 1995,1996 Crafted SmalltalkAll Rights ReservedAbstractCodeProbe is the abstract class of all the software probes.  Itprimarily provides the methods for accessing the information withinthe probe record.Instance Variables:	probeRecord		&lt;ProbeInsertionRecord&gt;	The probe record.	parent				&lt;CodeProbe&gt;	The probe from which the receiver was copied.Class Variables:	DoClone	&lt;Boolean&gt;	This specifies what type of copying will be done when							a probe is copied.</body></comment><class><name>TopOfStackVariable</name><environment>CraftedSmalltalk</environment><super>Kernel.VariableDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Compiler</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.TopOfStackVariable</class-id><body>TopOfStackVariableThe TopOfStackVariable supports the TopOFStack pseudo variable inprobe expressions.  It provides the expression with access to the objecton the top of the debugged context stack.</body></comment><class><name>CodeProbe</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.AbstractCodeProbe</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testMethod testSource variables labelString permanent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Probes</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.CodeProbe</class-id><body>CodeProbe	Version 1.1Copyright 1995,1998 Crafted SmalltalkAll Rights ReservedAn instance of CodeProbe is used as a breakpoint probe.  It provides mostof a probe's functionallity.Instance Variables:	testMethod		&lt;CompiledMethod&gt;	The method that is executed to determine if the probe should be activated.	testSource		&lt;String&gt;	Souce for the test method.	variables		&lt;Dictionary&gt;	Dictionary of the probe's local debug variables.	labelString		&lt;ValueHolder of: (nil | String)&gt;	Window label	permanent		&lt;Boolean&gt;		Permanent or temp probeClass Variables:	DebugActiveMethod		&lt;CompiledMethod&gt;	Used to initialize an unconditional test method.												The result returned is the value of the #DebugActive global debug variable.												This is set the by visual launcher probe menu command "enable debugging".	DefaultTestMethod		&lt;CompiledMethod&gt;	The defauld method used to initialize an unconditional test method	DefaultTestSource		&lt;String&gt;			The source string of the default test method.	TrueTestMethod			&lt;CompiledMethod&gt;	Used to initialize an unconditional test method	FalseTestMethod		&lt;CompiledMethod&gt;	Used to initialize a conditional test method</body></comment><class><name>PDPTransientWarning</name><environment>CraftedSmalltalk</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>labelText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Tools support</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.PDPTransientWarning</class-id><body>PDPTransientWarningPDPTransientWarning opens a window that presentsa short message and then closes automatically in 1.5 seconds.Instance Variables:	labelText	&lt;Text&gt;	The message.</body></comment><class><name>AuxCodeInfoExtractor</name><environment>CraftedSmalltalk</environment><super>Kernel.InstructionStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>jumps depth oldPC jumpStack maxDepth visited </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-VM</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.AuxCodeInfoExtractor</class-id><body>AuxCodeInfoExtractor	Version 1.0Copyright 1995 Crafted SmalltalkAll Rights ReservedAn instance of a AuxCodeInfoExtractor is used to extract stack depth and jumpdestinations from a compiled method.Instance Variables:	depth			&lt;Integer&gt;  Current stack depth	jumps			&lt;OrderedCollection of: JumpRecord&gt;  Collection of all the jumps in the method.	jumpStack		&lt;OrderedCollection of: Association&gt;				The key is the pc of a jump instruction and the value is the stack depth.	maxDepth		&lt;Integer&gt;	Maximum stack depth used in the method	oldPC			&lt;Integer&gt;	Pc of the first byte code of the current instruction	visited			&lt;Array of: Boolean&gt;				A visitation record of every instruction in the method.  It is used to make sure				that every instruction in every branch is visited.</body></comment><class><name>PDPInstrumenter</name><environment>CraftedSmalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classUnderTest templateProbe instrumentationRecords labelStream probeClass probedMethod leadString methodString probeRecord probe iVarName iVarIndex startingScope probeCompletionSelector useConditionalProbe selectWindowParams instrumentationRequest </inst-vars><class-inst-vars>reportStrings </class-inst-vars><imports></imports><category>CraftedSt-Tools</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.PDPInstrumenter</class-id><body>PDPInstrumenter	Version 1.0Copyright 1997 Crafted SmalltalkAll Rights ReservedThe PDPInstrumenter is an abstract instrumentation class.  Subclassesprovide the functionality to instrument a set of methods.Instance Variables:	classUnderTest				&lt;Metaclass&gt;	Class being instrumented	templateProbe				&lt;CodeProbe&gt;	A probe that serves as a template for creating additional probes.	instrumentationRecords		&lt;OrderedCollection of: MethodActionRecord&gt;		These record what methods																				should be instrumented.	labelStream					&lt;WriteStream&gt;	Used to create the probe label.	probeClass					&lt;CodeProbe class&gt;	probedMethod				&lt;ProbedCompiledMethod&gt;	The actual method being probed.	leadString					&lt;String&gt;	methodString				&lt;String&gt;	probeRecord				&lt;ProbeInsertionRecord&gt;	This specifies were in the method a probe is														to be inserted.	probe						&lt;CodeProbe&gt;	The probe being inserted.	iVarName					&lt;String&gt;	The name of the instance variable being monitored.	iVarIndex					&lt;Integer&gt;	The index of the instance variabe being monitored.	startingScope				&lt;NameScope&gt;	This is the scope used in compiling the probe expressions.	probeCompletionSelector	&lt;Symbol&gt;	The method used to complete each probe.	useConditionalProbe			&lt;Boolean&gt;	Specifies whether a code editor is opened to allow the test											expression to be edited.	selectWindowParams		&lt;Boolean&gt;	Specified whether the dialog is opened to permit the watch											window parameters to be changed.	instrumentationRequest		&lt;Symbol&gt;	The request being processed.  It the selector of the method that											initiates the instrumentation process.</body></comment><class><name>DisplayProbe</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.CodeProbe</super><private>false</private><indexed-type>none</indexed-type><inst-vars>windowID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Probes</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.DisplayProbe</class-id><body>DisplayProbe	Version 1.0Copyright 1995 Crafted SmalltalkAll Rights ReservedThe super class of all the watchpoint probes.Instance Variables:	windowID		&lt;Symbol&gt;	ID of the watch window</body></comment><class><name>ProcessTerminatedDuringSimulation</name><environment>CraftedSmalltalk</environment><super>Core.GenericException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Dbgr support</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.ProcessTerminatedDuringSimulation</class-id><body>ProcessTerminatedDuringSimulation The ProcessTerminatedDuringSimulation exception is raised ifthe process is terminated during byte code simulation.</body></comment><class><name>CodeProbeEditor</name><environment>CraftedSmalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>originalProbe workingCopyProbe closeAction probedMethod probedClass testEditor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Tools</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.CodeProbeEditor</class-id><body>An instance of CodeProbeEditor is the model for a code probe editor panel.  It servestwo purposes; to build the panel, and to perform the appropriate action when thepanel is closed.Instance Variables:	originalProbe			&lt;CodeProbe&gt;	The probe for which the editor was opened.	workingCopyProbe		&lt;CodeProbe&gt;					A copy of the object ivar.  This is the actual probe that is operated on.					This is used so a cancel actually works.	closeAction			&lt;BlockClosure&gt;						This block is performed when the panel is closed via the Done button.	probedMethod		&lt;ProbedCompiledMethod&gt;	The probed method.	probedClass		&lt;Metaclass&gt;	The class containing the probed method.	testEditor			&lt;ProbeExpressionEditor&gt;	The editor for the test expression.</body></comment><class><name>RawRemoteVariable</name><environment>CraftedSmalltalk</environment><super>Kernel.RemoteVariable</super><private>false</private><indexed-type>none</indexed-type><inst-vars>slot </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Compiler</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.RawRemoteVariable</class-id><body>RawRemoteVariable	Version 1.1Copyright 1995,1997 Crafted SmalltalkAll Rights ReservedInstances of RawRemoteVariable provide for accessing temporary variables ofan outer context without forcing Context to create a local scope and checkingvariable names.  The index of the variable is assumed to includecompiler generated temps.  This class was provided to improveaccessing speed of the temps.</body></comment><class><name>DisplayProbeEditor</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.CodeProbeEditor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Tools</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.DisplayProbeEditor</class-id><body>DisplayProbeEditor	Version 1.0Copyright 1995,1996 Crafted SmalltalkAll Rights ReservedAn instance of DisplayProbeEditor is the model for a display probe editor panel.  It servestwo purposes; to build the panel, and to perform the appropriate action when thepanel is closed.</body></comment><class><name>WatchWindowView</name><environment>CraftedSmalltalk</environment><super>UI.TextCollectorView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Probes</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.WatchWindowView</class-id><body>WatchWindowHolder	Version 1.0Copyright 1995 Crafted SmalltalkAll Rights ReservedWatchWindowView is a specialized TextCollectorView that handles being updatedin a replace rather than log mode of operation.</body></comment><class><name>DisplayVariableProbe</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.DisplayProbe</super><private>false</private><indexed-type>none</indexed-type><inst-vars>index name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Probes</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.DisplayVariableProbe</class-id><body>DisplayVariableProbe	Version 1.0Copyright 1995 Crafted SmalltalkAll Rights ReservedThe super class of the probes that display the contents of a defined variable.Instance Variables:	index		&lt;Integer&gt;	The variable index.	name		&lt;String&gt;	The variable name.</body></comment><class><name>DisplayMethodVarProbe</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.DisplayVariableProbe</super><private>false</private><indexed-type>none</indexed-type><inst-vars>slot </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Probes</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.DisplayMethodVarProbe</class-id><body>DisplayMethodVarProbe	Version 1.0Copyright 1995 Crafted SmalltalkAll Rights ReservedWhen activated an instance of a DisplayMethodVarProbe displays thecontents of a method temporary variable.</body></comment><class><name>PDPWeakCollection</name><environment>CraftedSmalltalk</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessLock elements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Tools support</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.PDPWeakCollection</class-id><body>PDPWeakCollection	Version 1.1Copyright 1995,1996,1997 Crafted SmalltalkAll Rights ReservedPDPWeakCollection is a collection that uses a WeakArray to containthe elements.  Complete collection protocol has not been implemented.Instance Variables:	elements	&lt;WeakArray&gt;	The collection of objects.	accessLock		&lt;RecursionLock&gt;  Protects elements from conflicting access					during use and element expiration.</body></comment><class><name>ProbeCharacterStyle</name><environment>CraftedSmalltalk</environment><super>Core.Association</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Tools support</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.ProbeCharacterStyle</class-id><body>ProbeCharacterStyle	Version 1.0Copyright 1995 Crafted SmalltalkAll Rights ReservedThe purpose of this class is to prevent the caching of character styles,actually associations, when used to retain probe information.  Thecaching of styles began in VW 2.0 so this class is not needed forOW 4.1 and VW 1.0 but its use simplifies the overall code.</body></comment><class><name>CRC32Function</name><environment>CraftedSmalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-VM</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.CRC32Function</class-id><body>The CRC32Function provides a function to calculate 32 bit CRCs ofa ByteArray.Shared Variables:	CRC32Table	&lt;Array&gt;		Precalculated CRC table</body></comment><class><name>ProbeClone</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.AbstractCodeProbe</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Probes</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.ProbeClone</class-id><body>ProbeClone	Version 1.0Copyright 1995,1996 Crafted SmalltalkAll Rights ReservedA ProbeClone is a copy of a probe and is used only in temporary methods.It exists so when a user modifies a probe in the debugger that the actualprobe contained in the probed method in the method dictionary is modifiedand not simply the probe in the temporary method.</body></comment><class><name>PDPInstrumenterGUIModel</name><environment>CraftedSmalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classUnderTest basicTypeModel subclassModel conditionalModel panelList methods winParamButtonW winParam reportModel instrumenter ivarMenu ivarMenuModel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Tools</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.PDPInstrumenterGUIModel</class-id><body>PDPInstrumenterGUIModel	Version 1.0Copyright 1997 Crafted SmalltalkAll Rights ReservedThe PDPInstrumenterGUIModel is the abstract instrumentation GUI model class.  It andits Subclasses control the instrumentation panel GUIs.  The actual instrumentation ofmethods is done by an instance of a PDPInstrumenter subclass.</body></comment><class><name>PDPIVarRefInstrumenterGUIModel</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.PDPInstrumenterGUIModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>readModel writeModel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Tools</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.PDPIVarRefInstrumenterGUIModel</class-id><body>PDPIvarRefInstrumenterGUIModel	Version 1.0Copyright 1997 Crafted SmalltalkAll Rights Reserved</body></comment><class><name>PDPIVarReferenceInstrumenter</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.PDPInstrumenter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>actionString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Tools</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.PDPIVarReferenceInstrumenter</class-id><body>PDPIVarReferenceInstrumenter	Version 1.0Copyright 1997 Crafted SmalltalkAll Rights ReservedThe PDPIVarReferenceInstrumenter is the instrumentation class used to instrumentthe monitoring of instance variable references.Instance Variables:	actionString		&lt;String&gt;	This string indicates what the variable reference is doing,								reading or writing.</body></comment><class><name>BranchLimit</name><environment>CraftedSmalltalk</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-VM</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.BranchLimit</class-id><body>BranchLimitThis exception is raised if inserting a probe into a methodwould cause a jump instruction to try to jump farther thanthe bytecode set permits.</body></comment><class><name>ProbedCompiledMethod</name><environment>CraftedSmalltalk</environment><super>Kernel.CompiledMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>original methodHolder probeStart auxInfo </inst-vars><class-inst-vars>removedProbedMethodsHolder </class-inst-vars><imports>			OpcodePool.*			</imports><category>CraftedSt-VM</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id><body>ProbedCompiledMethod	Version 1.0Copyright 1995 Crafted SmalltalkAll Rights ReservedAn instance of ProbedCompiledMethod replaces a CompiledMethod when a probe isinserted.Instance Variables:	original				&lt;CompiledMethod&gt;	The compiled method being replaced by the receiver.	methodHolder		&lt;MethodNodeHolder&gt;					The MethodNodeHolder used to create the receiver.  It is cached					because the likelyhood of being needed again is high.	probeStart			&lt;Integer&gt;	The starting index of the probes.	auxInfo				&lt;AuxCodeInfoExtractor&gt;					The extractor used to adjust jumps and stack depth.</body></comment><class><name>BreakInterrupt</name><environment>CraftedSmalltalk</environment><super>Core.ControlInterrupt</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Dbgr support</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.BreakInterrupt</class-id><body>BreakInterruptBreakInterrupt is the exception that is raised to causea breakpoint action.</body></comment><class><name>PDPMsgRcvdInstrumenterGUIModel</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.PDPInstrumenterGUIModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ivarMenuButton </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Tools</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.PDPMsgRcvdInstrumenterGUIModel</class-id><body>PDPMsgRcvdInstrumenterGUIModel	Version 1.0Copyright 1997 Crafted SmalltalkAll Rights Reserved</body></comment><class><name>PDPMthdListMsgRcvdInstrumenterGUIModel</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.PDPMsgRcvdInstrumenterGUIModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>origMethods </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Tools</category><attributes><package>Debugger-Probes</package></attributes></class><class><name>DisplayInstanceVarProbe</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.DisplayVariableProbe</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Probes</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.DisplayInstanceVarProbe</class-id><body>DisplayInstanceVarProbe	Version 1.0Copyright 1995 Crafted SmalltalkAll Rights ReservedWhen activated an instance of a DisplayInstanceVarProbe displays thecontents of an instance variable.</body></comment><class><name>ProbeInsertionRecord</name><environment>CraftedSmalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pc blockIndex characterIndex mclass selector mapEntry atEnd </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Probes</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.ProbeInsertionRecord</class-id><body>ProbeInsertionRecord	Version 1.0Copyright 1995 Crafted SmalltalkAll Rights ReservedInstances of ProbeInsertionRecord record where a probe is inserted.Instance Variables:	pc					&lt;Integer&gt;	The probe insertion pc.	blockIndex			&lt;Integer&gt;	The block index of the probe.	characterIndex		&lt;Integer&gt;	The character index of the probe.	mclass				&lt;Class&gt;	The class in which the ProbedCompiledMethod was compiled.	selector				&lt;Symbol&gt;	The selector of the ProbedCompiledMethod.	mapEntry			&lt;VisibleMapEntry&gt;	The map entry for the node in which the probe is inserted.	atEnd				&lt;Boolean&gt;	True if the probe is inserted at the end of node</body></comment><class><name>PDPManager</name><environment>CraftedSmalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>watchWindows lastID methodDependents debugVariables defaultToPermanentProbe </class-inst-vars><imports></imports><category>CraftedSt-Tools</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.PDPManager</class-id><body>PDPManager	Version 2.0Copyright 1997, 2002 Crafted SmalltalkAll Rights ReservedThe PDPManager manages global functions related to the debug package.</body></comment><class><name>DisplayTOSProbe</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.DisplayProbe</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Probes</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.DisplayTOSProbe</class-id><body>DisplayTOSProbe	Version 1.0Copyright 1995 Crafted SmalltalkAll Rights ReservedAn instance of DisplayTOSProbe displays the top of the context stackwhen the probe is activated.</body></comment><class><name>JumpRecord</name><environment>CraftedSmalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>location delta type newDelta </inst-vars><class-inst-vars></class-inst-vars><imports>			OpcodePool.*			</imports><category>CraftedSt-VM</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.JumpRecord</class-id><body>JumpRecord	Version 1.0Copyright 1995 Crafted SmalltalkAll Rights ReservedJumpRecords are used to keep track of the jumps in a CompiledMethod.Instance Variables:	location			&lt;Integer&gt;	The location of the first byte in the jump instruction.	delta			&lt;Integer&gt;	The relative jump to the target location.	type			&lt;Integer&gt;	Indicates the type of jump instruction	newDelta		&lt;Integer&gt;	Used to iteratively adjust jumps in a compiled method. </body></comment><class><name>PrintTimeoutError</name><environment>CraftedSmalltalk</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Dbgr support</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.PrintTimeoutError</class-id><body>PrintTimeoutErrorThis exception is raised (in some inspectors) when printing an objecttakes so long that it becomes highly probable that the printingsuffers from infinite recursion.</body></comment><class><name>PDPParser</name><environment>CraftedSmalltalk</environment><super>Kernel.Parser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Compiler</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.PDPParser</class-id><body>PDPParser	Version 1.0Copyright 1997 Crafted SmalltalkAll Rights ReservedThe PDPParser is used to create probe expressions.  The expressions are compiledas special forms of doit expressions.</body></comment><class><name>ProbedAnnotatedMethod</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.ProbedCompiledMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>attributes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-VM</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.ProbedAnnotatedMethod</class-id><body>ProbedAnnotatedMethod	Version 1.0Copyright 1995,1996 Crafted SmalltalkAll Rights ReservedThis class combines the functionality of the ProbedCompiledMethod classand the AnnotatedMethod class.  Here is one place where multiple inheritancewould be nice.</body></comment><class><name>ActionProbeEditor</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.DisplayProbeEditor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>actionEditor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Tools</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.ActionProbeEditor</class-id><body>ActionProbeEditor	Version 1.1Copyright 1995,1996,1997 Crafted SmalltalkAll Rights ReservedAn instance of ActionProbeEditor is the model for a display action probe editor panel.  It servestwo purposes; to build the panel, and to perform the appropriate action when thepanel is closed.Instance Variables:	actionEditor		&lt;ProbeExpressionEditor&gt;	The editor for the watch expression.</body></comment><class><name>DebugStepIntoBlockClosure</name><environment>CraftedSmalltalk</environment><super>Kernel.BlockClosure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Tools</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.DebugStepIntoBlockClosure</class-id><body>DebugStepIntoBlockClosure The DebugStepIntoBlockClosure is used by the debugger to stepinto a block closure.  It is substituted for the block closuresin the message send.</body></comment><class><name>PDPMsgRcvdInstrumenter</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.PDPInstrumenter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Tools</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.PDPMsgRcvdInstrumenter</class-id><body>PDPMsgRcvdInstrumenter	Version 1.0Copyright 1997 Crafted SmalltalkAll Rights ReservedThe PDPMsgRcvdInstrumenter is the instrumentation class used to instrumentthe reception of messages.</body></comment><class><name>ProbeExpressionEditor</name><environment>CraftedSmalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>probedMethod probedClass probe textMenu </inst-vars><class-inst-vars>expressionLibrary </class-inst-vars><imports></imports><category>CraftedSt-Tools</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.ProbeExpressionEditor</class-id><body>ProbeExpressionEditor is the abstract super class for the probe expression editors.  It is responsible for most of the probe expression editing activity.  It provides the menu commands for accessing and defining variables.  It also provides proper variable scope so the expressions will be able to refer to variables within an instance of probedClass.ProbeExpressionEditor allows a client to store and retrieve expressions in its class instance variable, expressionLibrary, a dictionary.  This Dictionary can is accessed by methods in the class side method protocol: #'expression library'.  Expressions are stored as strings and are accessed by the name a client decides is appropriate (the current implementation converts any expression names into symbols).Instance Variables:	probedMethod		&lt;ProbedCompiledMethod | nil&gt;	The method being probed.	probedClass		&lt;Class&gt;	The class of the method being probed	probe				&lt;Probe&gt;	The probe being operated on.	textMenu			&lt;Menu&gt;		The text menu.  A new text menu is supplied					because additional commands are provided.Class Instance Variables:	expressionLibrary	&lt;Dictionary of: Symbol-&gt;String&gt; The current collection of stored expressions </body></comment><class><name>ProbeActionExpressionEditor</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.ProbeExpressionEditor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Tools</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.ProbeActionExpressionEditor</class-id><body>The ProbeActionExpressionEditor tailors the ProbeExpressionEditor for action expressions.  Most of the specialization is for accessing the action expression and method.</body></comment><class><name>ProbeTestExpressionEditor</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.ProbeExpressionEditor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Tools</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.ProbeTestExpressionEditor</class-id><body>The ProbeTestExpressionEditor tailors the ProbeExpressionEditor for test expressions.  Most of the specialization is for accessing the test expression and method.</body></comment><class><name>DisplayActionProbe</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.DisplayProbe</super><private>false</private><indexed-type>none</indexed-type><inst-vars>actionMethod actionSource </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Probes</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.DisplayActionProbe</class-id><body>DisplayActionProbe	Version 1.0Copyright 1995 Crafted SmalltalkAll Rights ReservedInstances of DisplayActionProbe are used to display the result of a Smalltalk expression.Instance Variables:	actionMethod			&lt;CompiledMethod&gt;					The method that is evaluated to obtain a string to display.	actionSource		&lt;String&gt;	Source code of the action method.Class Variables:	ActionMethod		&lt;CompiledMethod&gt; Used to initialize the action method.</body></comment><shared-variable><name>PDPVersionNumber</name><environment>CraftedSmalltalk</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Debugger-Probes</package></attributes></shared-variable><shared-variable><name>CRC32Table</name><environment>CraftedSmalltalk.CRC32Function</environment><private>false</private><constant>false</constant><category>table</category><attributes><package>Debugger-Probes</package></attributes></shared-variable><shared-variable><name>DebugActiveMethod</name><environment>CraftedSmalltalk.CodeProbe</environment><private>false</private><constant>false</constant><category>defaults</category><attributes><package>Debugger-Probes</package></attributes></shared-variable><shared-variable><name>DefaultTestMethod</name><environment>CraftedSmalltalk.CodeProbe</environment><private>false</private><constant>false</constant><category>defaults</category><attributes><package>Debugger-Probes</package></attributes></shared-variable><shared-variable><name>FalseTestMethod</name><environment>CraftedSmalltalk.CodeProbe</environment><private>false</private><constant>false</constant><category>defaults</category><attributes><package>Debugger-Probes</package></attributes></shared-variable><shared-variable><name>DefaultTestSource</name><environment>CraftedSmalltalk.CodeProbe</environment><private>false</private><constant>false</constant><category>defaults</category><attributes><package>Debugger-Probes</package></attributes></shared-variable><shared-variable><name>TrueTestMethod</name><environment>CraftedSmalltalk.CodeProbe</environment><private>false</private><constant>false</constant><category>defaults</category><attributes><package>Debugger-Probes</package></attributes></shared-variable><shared-variable><name>MaxMapped</name><environment>CraftedSmalltalk.PDPWeakDictionary</environment><private>false</private><constant>false</constant><category>vars</category><attributes><package>Debugger-Probes</package></attributes></shared-variable><shared-variable><name>PrimeMap</name><environment>CraftedSmalltalk.PDPWeakDictionary</environment><private>false</private><constant>false</constant><category>vars</category><attributes><package>Debugger-Probes</package></attributes></shared-variable><shared-variable><name>ActionMethod</name><environment>CraftedSmalltalk.DisplayActionProbe</environment><private>false</private><constant>false</constant><category>defaults</category><attributes><package>Debugger-Probes</package></attributes></shared-variable><shared-variable><name>DoClone</name><environment>CraftedSmalltalk.AbstractCodeProbe</environment><private>false</private><constant>false</constant><category>defaults</category><attributes><package>Debugger-Probes</package></attributes></shared-variable><methods><class-id>CraftedSmalltalk.SilentProbeExprCompilerErrorHandler</class-id> <category>error handling</category><body package="Debugger-Probes" selector="error:with:at:">error: type with: message at: sourcePosition	Transcript cr;		nextPutAll: ((#ErrorIn1sDash2sAt3p &lt;&lt; #pdp &gt;&gt; 'Error in &lt;1s&gt; - &lt;2s&gt; at: &lt;3p&gt;')			expandMacrosWith: self methodString;			with: message;			with: sourcePosition);		endEntry.	^self abort</body><body package="Debugger-Probes" selector="error:with:in:from:">error: type with: message in: node from: codeStream	| msg |	msg := message isVariableBinding		ifTrue: [message key]		ifFalse: [message isString			ifTrue: [message]			ifFalse: ['?']].	Transcript cr;		nextPutAll: ((#ErrorDash1s2sIn3s &lt;&lt; #pdp &gt;&gt; 'Error - &lt;1s&gt; "&lt;2s&gt;" in &lt;3s&gt;')			expandMacrosWith: type			with: msg			with: self methodString);		endEntry.	^self abort</body></methods><methods><class-id>CraftedSmalltalk.SilentProbeExprCompilerErrorHandler</class-id> <category>private</category><body package="Debugger-Probes" selector="methodString">methodString	selector isNil		ifTrue: [^(#UnboundMethod &lt;&lt; #pdp &gt;&gt; 'Unbound method') asString].	^class shortName , '&gt;&gt;' , selector string</body></methods><methods><class-id>CraftedSmalltalk.RemovedProbedMethodsBrowser</class-id> <category>private</category><body package="Debugger-Probes" selector="changedMethodList">changedMethodList	methodList list: (showHidden		ifTrue: [hiddenMethods]		ifFalse: [methods]).</body><body package="Debugger-Probes" selector="changedSelection">changedSelection	textHolder value: (selectedMethods size ~= 1		ifTrue: [Text new]		ifFalse: [selectedMethods first sourceText])</body><body package="Debugger-Probes" selector="clearMethods">clearMethods	methods := self newMethodCollection.</body><body package="Debugger-Probes" selector="menu">menu	^selectedMethods isEmpty		ifTrue:			[showHidden				ifTrue:					[Menu						labelArray: (Array with: #ShowNormal &lt;&lt; #pdp &gt;&gt; 'Show Normal')						values: #(showNormal)]				ifFalse:					[Menu						labelArray: (Array with: (#ReinsertProbes &lt;&lt; #pdp &gt;&gt; 'Reinsert Probes') with: (#ShowHidden &lt;&lt; #pdp &gt;&gt; 'Show Hidden'))						values: #(reinsertProbes showHidden)]]		ifFalse:			[showHidden				ifTrue:					[Menu						labelArray: (Array with: (#ShowNormal &lt;&lt; #pdp &gt;&gt; 'Show Normal') with: (#Unhide &lt;&lt; #pdp &gt;&gt; 'Unhide'))						values: #(showNormal unhide)]				ifFalse:					[Menu						labelArray: (Array with: (#ReinsertProbes &lt;&lt; #pdp &gt;&gt; 'Reinsert Probes') with: (#ShowHidden &lt;&lt; #pdp &gt;&gt; 'Show Hidden') with: (#Hide &lt;&lt; #pdp &gt;&gt; 'Hide'))						values: #(reinsertProbes showHidden hide)]]</body><body package="Debugger-Probes" selector="newMethodCollection">newMethodCollection	^SortedCollection sortBlock:		[:a :b |			a mclass name &lt; b mclass name or:				[a mclass name = b mclass name and:					[a selector &lt; b selector]]]</body></methods><methods><class-id>CraftedSmalltalk.RemovedProbedMethodsBrowser</class-id> <category>menu commands</category><body package="Debugger-Probes" selector="hide">hide	hiddenMethods addAll: selectedMethods.	methods removeAll: selectedMethods.	selectedMethods := #().	self changedMethodList</body><body package="Debugger-Probes" selector="reinsertProbes">reinsertProbes	ProbedCompiledMethod recompileAndInsertProbesFrom: methods.	hiddenMethods isEmpty		ifTrue: [^builder window topComponent controller close].	self clearMethods.	self changedMethodList.</body><body package="Debugger-Probes" selector="showHidden">showHidden	showHidden := true.	self changedMethodList</body><body package="Debugger-Probes" selector="showNormal">showNormal	showHidden := false.	self changedMethodList</body><body package="Debugger-Probes" selector="unhide">unhide	methods addAll: selectedMethods.	hiddenMethods removeAll: selectedMethods.	selectedMethods := #().	self changedMethodList</body></methods><methods><class-id>CraftedSmalltalk.RemovedProbedMethodsBrowser</class-id> <category>initialize - release</category><body package="Debugger-Probes" selector="initialize">initialize	self clearMethods.	showHidden := false.	selectedMethods := #().	hiddenMethods := self newMethodCollection.	textHolder := '' asText asValue.	methodList := MultiSelectionInList new.	methodList selectionIndexHolder onChangeSend: #newSelection to: self.	methodList selectionIndexHolder value: selectedMethods.</body><body package="Debugger-Probes" selector="on:">on: aCollection	methods addAll: aCollection.</body></methods><methods><class-id>CraftedSmalltalk.RemovedProbedMethodsBrowser</class-id> <category>accessing</category><body package="Debugger-Probes" selector="menuHolder">menuHolder	^[self menu]</body><body package="Debugger-Probes" selector="methodList">methodList	methodList list: (showHidden		ifTrue: [hiddenMethods]		ifFalse: [methods]).	^methodList</body><body package="Debugger-Probes" selector="textHolder">textHolder	^textHolder</body></methods><methods><class-id>CraftedSmalltalk.RemovedProbedMethodsBrowser</class-id> <category>selecting</category><body package="Debugger-Probes" selector="newSelection">newSelection	selectedMethods := methodList selections.	self changedSelection</body></methods><methods><class-id>CraftedSmalltalk.RemovedProbedMethodsBrowser class</class-id> <category>interface opening</category><body package="Debugger-Probes" selector="onMethods:">onMethods: aCollection	self openOn: (self new on: aCollection)"Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.ProbeExprCompiler</class-id> <category>public access</category><body package="Debugger-Probes" selector="compileProbeExpression:forProbe:inClass:beginScope:notifying:ifFail:">compileProbeExpression: textOrStream forProbe: aProbe inClass: aClass beginScope: scope notifying: aRequestor ifFail: failBlock 	"Compiles the sourceStream into a parse tree, then generates code 	into a method.  If receiver is not nil, then the text can refer to	instance variables of that receiver (the Inspector uses this).  If 	aContext is not nil, the text can refer to temporaries in that context	(the Debugger uses this).  If aRequestor is not nil, then it will	receive a notify:at: message if an error is deteted. 		Finally, the compiled method is returned"	| lastLocalScope method scope1 handler methodNode staticScope |	class := aClass.	lastLocalScope := scope.	[lastLocalScope outerScope class == StaticScope]		whileFalse: [lastLocalScope := lastLocalScope outerScope].	staticScope := lastLocalScope outerScope.	scope1 := StaticScope variables: PDPManager debugVariables.	scope1 outerScope: staticScope.	aProbe variables isEmpty		ifFalse: [scope1 := (StaticScope variables: aProbe variables) outerScope: scope1].	lastLocalScope outerScope: scope1.	self from: textOrStream		class: class		context: (self scopeForProbeExpressionsOuterScope: scope)		notifying: aRequestor.	handler := requestor isNil		ifTrue: [SilentProbeExprCompilerErrorHandler new]		ifFalse: [self interactiveCompilerErrorHandlerClass new].	[methodNode := handler		forClass: targetClass		on: sourceStream		for: requestor		onFailDo: [^failBlock value]		do: [:src |			self				translate: src				ifFail: [^failBlock value]				handler: handler]]		valueNowOrOnUnwindDo: [lastLocalScope outerScope: staticScope].	method := methodNode generate.	method allLiteralsDo: [:obj | (obj isVariableBinding and: [obj isDeferred]) ifTrue: [obj resolveBinding]].	^method</body><body package="Debugger-Probes" selector="evaluate:in:allowReceiver:receiver:environment:notifying:ifFail:">evaluate: textOrStream in: aContext allowReceiver: allowSelf	receiver: receiver environment: env	notifying: aRequestor ifFail: failBlock	"This method should be sent to this compiler class only by	a TextController that is part of a probe expression editor."	| value method editor |	Cursor execute show.	editor := aRequestor performer.	[method := self		compileProbeExpression: textOrStream		forProbe: editor probe		inClass: editor probedClass		beginScope: editor nameScope		notifying: aRequestor		ifFail: 			[Cursor normal show.			^failBlock value].	value := method mclass basicNew performMethod: method with: nil with: nil]		ensure: [Cursor normal show].	^value</body><body package="Debugger-Probes" selector="evaluate:in:receiver:notifying:ifFail:">evaluate: textOrStream in: aContext receiver: receiver notifying: aRequestor ifFail: failBlock	"This method should be sent to this compiler class only by	a TextController that is part of a probe expression editor."	| value method editor |	Cursor execute show.	editor := aRequestor performer.	[method := self		compileProbeExpression: textOrStream		forProbe: editor probe		inClass: editor probedClass		beginScope: editor nameScope		notifying: aRequestor		ifFail: 			[Cursor normal show.			^failBlock value].	value := method mclass basicNew performMethod: method with: nil with: nil]		ensure: [Cursor normal show].	^value</body></methods><methods><class-id>CraftedSmalltalk.ProbeExprCompiler</class-id> <category>private</category><body package="Debugger-Probes" selector="newCodeStream">newCodeStream	"Return an appropriate code stream"	| stream |	stream := super newCodeStream.	compileForProbes == true		ifTrue: [stream makeFullBlock: true].	^stream</body><body package="Debugger-Probes" selector="scopeForClass">scopeForClass	^(context isKindOf: NameScope)		ifTrue: [context]		ifFalse: [super scopeForClass]</body><body package="Debugger-Probes" selector="scopeForProbeExpressionsOuterScope:">scopeForProbeExpressionsOuterScope: aScope	| localScope temps |	localScope := LocalScope new.	localScope addVariable: TopOfStackVariable new named: 'TopOFStack'.	temps := aScope temps reject: [:var | var key first = $.].	temps do:		[:var |		localScope			addVariable: (RawRemoteVariable new slot: var)			named: var key].	localScope outerScope: aScope.	^localScope</body><body package="Debugger-Probes" selector="translate:ifFail:handler:">translate: aStream ifFail: failBlock handler: handler	"This method is used only to compile or evaluate probe expressions."	| methodNode holder codeStream method |	"Make special provisions for compiling methods	in classes that still use the old parser."	methodNode :=		PDPParser new			parse: aStream			class: class			environment: self environment			noPattern: false			context: context			notifying: handler			builder: ProgramNodeBuilder new			saveComments: false			ifFail: [^failBlock value].	(BlockAnalyzer new analyze: methodNode inClass: class context: context)		storeHintsForStandardSmalltalk.	handler selector: methodNode selector.  "save selector in case of error"	codeStream := self newCodeStream.	codeStream		class: targetClass outerScope: self scopeForClass;		requestor: handler.	methodNode emitValue: codeStream inContext: nil.	method := codeStream makeMethod: methodNode.	method := method withAdditionalPropertiesFrom: methodNode.	holder := self newMethodHolder.	holder node: methodNode.	holder method: method.	^holder</body></methods><methods><class-id>CraftedSmalltalk.ProbeExprCompiler</class-id> <category>accessing</category><body package="Debugger-Probes" selector="setCompileForProbes">setCompileForProbes	compileForProbes := true</body></methods><methods><class-id>CraftedSmalltalk.ProbeExprCompiler class</class-id> <category>accessing</category><body package="Debugger-Probes" selector="doitContextVarName">doitContextVarName	^'DOITCONTEXT'"Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.MethodActionRecord</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="action:class:selector:">action: anInteger class: aClass selector: aSymbol	action := anInteger.		class := aClass.	selector := aSymbol</body></methods><methods><class-id>CraftedSmalltalk.MethodActionRecord</class-id> <category>accessing</category><body package="Debugger-Probes" selector="compiledMethod">compiledMethod	^class compiledMethodAt: selector</body><body package="Debugger-Probes" selector="methodClass">methodClass	^class</body><body package="Debugger-Probes" selector="methodClass:">methodClass: aClass	class := aClass</body><body package="Debugger-Probes" selector="nameString">nameString	^class shortName , '&gt;&gt;' , selector</body><body package="Debugger-Probes" selector="printString">printString	action == nil		ifTrue: [^self nameString].	^(#('r' 'rw' 'w') at: action) , ' ' , class shortName , '&gt;&gt;' , selector</body><body package="Debugger-Probes" selector="replaceMethod:">replaceMethod: aCompiledMethod	class addSelector: selector withMethod: aCompiledMethod</body><body package="Debugger-Probes" selector="setRead">setRead	action := #r</body><body package="Debugger-Probes" selector="setReadWrite">setReadWrite	action := #rw</body><body package="Debugger-Probes" selector="setWrite">setWrite	action := #w</body></methods><methods><class-id>CraftedSmalltalk.MethodActionRecord</class-id> <category>testing</category><body package="Debugger-Probes" selector="isRead">isRead	^action &lt; 3</body><body package="Debugger-Probes" selector="isWrite">isWrite	^action &gt; 1</body></methods><methods><class-id>CraftedSmalltalk.MethodActionRecord class</class-id> <category>instance creation</category><body package="Debugger-Probes" selector="action:class:selector:">action: anInteger class: aClass selector: aSymbol	^self new action: anInteger class: aClass selector: aSymbol"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakDictionary</class-id> <category>adding</category><body package="Debugger-Probes" selector="add:">add: anAssociation 	"Include newObject as one of the receiver's elements.  Answer newObject."	self at: anAssociation key put: anAssociation value.	^anAssociation</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakDictionary</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="allWeak:">allWeak: size	accessLock := RecursionLock new.	valueArray := WeakArray new: size.	valueArray addDependent: self.	keyArray := WeakArray new: size.	keyArray addDependent: self.	tally := 0</body><body package="Debugger-Probes" selector="normal:">normal: size	accessLock := RecursionLock new.	valueArray := Array new: size.	keyArray := Array new: size.	tally := 0</body><body package="Debugger-Probes" selector="weakKeys:">weakKeys: size	accessLock := RecursionLock new.	valueArray := Array new: size.	keyArray := WeakArray new: size.	keyArray addDependent: self.	tally := 0</body><body package="Debugger-Probes" selector="weakValues:">weakValues: size	accessLock := RecursionLock new.	valueArray := WeakArray new: size.	valueArray addDependent: self.	keyArray := Array new: size.	tally := 0</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakDictionary</class-id> <category>accessing</category><body package="Debugger-Probes" selector="associationAt:ifAbsent:">associationAt: key ifAbsent: aBlock 	"Answer an Association consisting of key and the value of	the receiver at that key.  If key is not found, evaluate aBlock."	^accessLock critical: [self unprotAssociationAt: key ifAbsent: aBlock]</body><body package="Debugger-Probes" selector="at:">at: key 	"Answer the value at key.  If key is not found, raise a signal."	^self at: key ifAbsent: [self keyNotFoundError: key]</body><body package="Debugger-Probes" selector="at:ifAbsent:">at: key ifAbsent: aBlock 	"Answer the value at key.  If key is not found, answer the	result of evaluating aBlock."	^accessLock critical: [self unprotAt: key ifAbsent: aBlock]</body><body package="Debugger-Probes" selector="at:put:">at: key put: anObject 	"Set the value at key to be anObject.  If key is not found, create a new	entry for key and set is value to anObject. Answer anObject."	^accessLock critical: [self unprotAt: key put: anObject]</body><body package="Debugger-Probes" selector="capacity">capacity	"Answer how much space the receiver has to contain elements."	^self collectionSize</body><body package="Debugger-Probes" selector="keyAtValue:ifAbsent:">keyAtValue: value ifAbsent: exceptionBlock	"Answer the key whose value equals the argument, value.  If there is none, 	answer the result of evaluating exceptionBlock."	^accessLock critical: [self unprotKeyAtValue: value ifAbsent: exceptionBlock]</body><body package="Debugger-Probes" selector="size">size	"Answer how many elements the receiver contains."	^tally</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakDictionary</class-id> <category>dictionary enumerating</category><body package="Debugger-Probes" selector="associationsDo:">associationsDo: aBlock 	"Evaluate aBlock for associations consisting of the receiver's keys and 	their values."	accessLock critical: [self unprotAssociationsDo: aBlock]</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakDictionary</class-id> <category>private - unprotected</category><body package="Debugger-Probes" selector="changeCapacityTo:">changeCapacityTo: newCapacity	"Change the size of the receiver to newCapacity.	-Note that #rehash uses this -- don't optimize the case where	the receiver doesn't change in size."	| newKeys newValues |	newKeys := keyArray class new: newCapacity.	newValues := valueArray class new: newCapacity.	"Copy named instance variables."	1 to: newKeys class instSize do:		[ :i |  newKeys instVarAt: i put: (keyArray instVarAt: i)].	1 to: newValues class instSize do:		[ :i |  newValues instVarAt: i put: (valueArray instVarAt: i)].	"Copy indexed variables"	1 to: keyArray size do:		[:index | |key nuIndex probe|		((key := keyArray at: index) == nil or: [key = WeakArray tombstone])	"Keys cannot be nil or 0"			ifFalse:				[nuIndex  := self initialIndexFor: key hash boundedBy: newCapacity.				[(probe := newKeys at: nuIndex) == nil or: [probe == key]]					whileFalse:						[(nuIndex := nuIndex + 1) &gt; newCapacity							ifTrue: [nuIndex := 1]].				newKeys at: nuIndex put: key.				newValues at: nuIndex put: (valueArray at: index)]].	valueArray := newValues.	keyArray := newKeys.</body><body package="Debugger-Probes" selector="finalize:">finalize: array	| deadIndex deadIndices|	deadIndex := array size.	deadIndices := OrderedCollection new.	[deadIndex &gt;= 1]		whileTrue: 			[deadIndex := array						indexOf: array tombstone						replaceWith: nil						startingAt: deadIndex						stoppingAt: 1.			deadIndex == 0				ifFalse: 					[deadIndices add: deadIndex.					deadIndex := deadIndex - 1]].	self removeAndCleanUpIndices: deadIndices.</body><body package="Debugger-Probes" selector="findKeyOrNil:">findKeyOrNil: key 	"Look for the key in the receiver.  If it is found, answer	the index of the association containting the key, otherwise	answer the index of the first unused slot."	| index length probe pass |	length := keyArray size.	pass := 1.	index := self initialIndexFor: key identityHash boundedBy: length.	[(probe := keyArray at: index) == nil or: [probe == key]] whileFalse: 			[(index := index + 1) &gt; length 				ifTrue: 					[index := 1.					pass := pass + 1.					pass &gt; 2 ifTrue: [^self grow findKeyOrNil: key]]].	^index</body><body package="Debugger-Probes" selector="rehash">rehash	"Rebuild the receiver to insure that it is hashed correctly."	"Note that this routine depends on implementors of #changeCapacityTo:	not 'optimizing' the case where the receiver doesn't need to change."	self changeCapacityTo: self capacity</body><body package="Debugger-Probes" selector="removeAndCleanUpIndices:">removeAndCleanUpIndices: indices 	"Remove the keys in indices and rehash"	indices do: 			[:index | 			keyArray at: index put: nil.			valueArray at: index put: nil.			tally := tally - 1].	self rehash</body><body package="Debugger-Probes" selector="unprotAssociationAt:ifAbsent:">unprotAssociationAt: key ifAbsent: aBlock 	"Answer an Association consisting of key and the value of	the receiver at that key.  If key is not found, evaluate aBlock."	| index storedKey |	index := self findKeyOrNil: key.	^(storedKey := keyArray at: index) == nil		ifTrue: [aBlock value]		ifFalse:			[Association 				key: storedKey				value: (valueArray at: index)]</body><body package="Debugger-Probes" selector="unprotAssociationsDo:">unprotAssociationsDo: aBlock 	"Evaluate aBlock for associations consisting of the receiver's keys and 	their values."	1 to: keyArray size do: 		[:index | 		(keyArray at: index) == nil 			ifFalse: [aBlock value: (Association 										key: (keyArray at: index)										value: (valueArray at: index))]]</body><body package="Debugger-Probes" selector="unprotAt:ifAbsent:">unprotAt: key ifAbsent: aBlock 	"Answer the value at key.  If key is not found, answer the	result of evaluating aBlock."	| index |	index := self findKeyOrNil: key.	^(keyArray at: index) == nil		 ifTrue: [aBlock value]		ifFalse: [valueArray at: index]</body><body package="Debugger-Probes" selector="unprotAt:put:">unprotAt: key put: anObject 	"Set the value at key to be anObject.  If key is not found, create a new	entry for key and set is value to anObject. Answer anObject."	| index |	key == nil ifTrue: [^self subscriptBoundsError: key].	index := self findKeyOrNil: key.	(keyArray at: index)  == nil		ifTrue:			[tally := tally + 1.			keyArray at: index put: key].	valueArray at: index put: anObject.	self fullCheck.	^anObject</body><body package="Debugger-Probes" selector="unprotDo:">unprotDo: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument."	1 to: keyArray size do: 		[:index | 		(keyArray at: index) == nil ifFalse: [aBlock value: (valueArray at: index)]]</body><body package="Debugger-Probes" selector="unprotIncludesKey:">unprotIncludesKey: key 	"Answer whether the receiver has a key equal to the argument, key."	| index |	index := self findKeyOrNil: key.	^(keyArray at: index) notNil</body><body package="Debugger-Probes" selector="unprotKeyAtValue:ifAbsent:">unprotKeyAtValue: value ifAbsent: exceptionBlock	"Answer the key whose value equals the argument, value.  If there is none, 	answer the result of evaluating exceptionBlock."	| theKey |	1 to: keyArray size do:		[:index |		value == (valueArray at: index)			ifTrue:				[(theKey := keyArray at: index) == nil					ifFalse: [^theKey]]].	^exceptionBlock value</body><body package="Debugger-Probes" selector="unprotKeysAndValuesDo:">unprotKeysAndValuesDo: aBlock 	"Evaluate aBlock with each of the receiver's key/value pairs as the 	arguments."	1 to: keyArray size do: 		[:index |		| key |		(key := keyArray at: index) == nil			ifFalse: [aBlock value: key value: (valueArray at: index)]]</body><body package="Debugger-Probes" selector="unprotRemoveKey:ifAbsent:">unprotRemoveKey: key ifAbsent: aBlock	"Remove key from the receiver.  If key is not in the receiver, 	answer the result of evaluating aBlock.  Otherwise, answer the value 	associated with key."	| index value |	index := self findKeyOrNil: key.	(keyArray at: index) == nil ifTrue: [^aBlock value].	value := valueArray at: index.	self removeAndCleanUpIndices: (Array with: index).	^value</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakDictionary</class-id> <category>private</category><body package="Debugger-Probes" selector="collectionSize">collectionSize	^keyArray basicSize</body><body package="Debugger-Probes" selector="fullCheck">fullCheck	"If there is insufficient capacity in the receiver to do efficient lookups,	then grow."	"Require 25% free slots."	keyArray size - self size &lt;= (keyArray size // 4)		ifTrue: [self grow]</body><body package="Debugger-Probes" selector="grow">grow	"The receiver becomes roomier."	self changeCapacityTo: self capacity + self growSize</body><body package="Debugger-Probes" selector="initialIndexFor:boundedBy:">initialIndexFor: aHashValue boundedBy: length	"Find the place where we should start the search.	Optimize for relatively small dictionaries."	length &gt; 1023  "maxHash will definitely be larger than this"		ifTrue:			[" For very large dictionaries, spread out the hash. "			| maxHash |			maxHash := ObjectMemory maximumIdentityHashValue.			length &gt; maxHash				ifTrue: [^aHashValue * (length // maxHash + 1) \\ length + 1]].	^aHashValue \\ length + 1</body><body package="Debugger-Probes" selector="keyNotFoundError:">keyNotFoundError: key	"Raise a signal indicating that the key was	not found."	^Dictionary keyNotFoundSignal raiseWith: key</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakDictionary</class-id> <category>enumerating</category><body package="Debugger-Probes" selector="do:">do: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument."	accessLock critical: [self unprotDo: aBlock]</body><body package="Debugger-Probes" selector="keysAndValuesDo:">keysAndValuesDo: aBlock 	"Evaluate aBlock with each of the receiver's key/value pairs as the 	arguments."	accessLock critical: [self unprotKeysAndValuesDo: aBlock]</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakDictionary</class-id> <category>dictionary testing</category><body package="Debugger-Probes" selector="includesKey:">includesKey: key 	"Answer whether the receiver has a key equal to the argument, key."	^accessLock critical: [self unprotIncludesKey: key]</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakDictionary</class-id> <category>dictionary removing</category><body package="Debugger-Probes" selector="remove:ifAbsent:">remove: anObject ifAbsent: exceptionBlock 	"Provide an error notification that Dictionaries can not respond to	remove: messages."	self shouldNotImplement</body><body package="Debugger-Probes" selector="removeKey:ifAbsent:">removeKey: key ifAbsent: aBlock	"Remove key from the receiver.  If key is not in the receiver, 	answer the result of evaluating aBlock.  Otherwise, answer the value 	associated with key."	^accessLock critical: [self unprotRemoveKey: key ifAbsent: aBlock]</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakDictionary</class-id> <category>updating</category><body package="Debugger-Probes" selector="update:with:from:">update: anAspectSymbol with: aParameter from: aSender 	anAspectSymbol == #ElementExpired		ifFalse: [^self].	aSender == keyArray | (aSender == valueArray)		ifFalse: [^self].	accessLock critical: [self finalize: aSender]</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakDictionary class</class-id> <category>instance creation</category><body package="Debugger-Probes" selector="allWeak">allWeak	^self allWeak: self createSize"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="allWeak:">allWeak: anInteger 	"Create an instance of a Set."	anInteger &gt;= 0 ifFalse: [self improperCreationSizeSignal raiseWith: anInteger].	^super new allWeak: (self goodSizeFrom: anInteger)"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="new:">new: anInteger 	"Create an instance of a Set."	anInteger &gt;= 0 ifFalse: [self improperCreationSizeSignal raiseWith: anInteger].	^super new normal: (self goodSizeFrom: anInteger)"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="weakKeys">weakKeys	^self weakKeys: self createSize"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="weakKeys:">weakKeys: anInteger 	"Create an instance of a Set."	anInteger &gt;= 0 ifFalse: [self improperCreationSizeSignal raiseWith: anInteger].	^super new weakKeys: (self goodSizeFrom: anInteger)"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="weakValues">weakValues	^self weakValues: self createSize"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="weakValues:">weakValues: anInteger 	"Create an instance of a Set."	anInteger &gt;= 0 ifFalse: [self improperCreationSizeSignal raiseWith: anInteger].	^super new weakValues: (self goodSizeFrom: anInteger)"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakDictionary class</class-id> <category>private</category><body package="Debugger-Probes" selector="createSize">createSize	^4"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="goodSizeFrom:">goodSizeFrom: requestedSize 	"Given a size request, round it up to a size which will give best 	hash clustering (such as next prime)."	"Just ensure oddness if out-of-range."	^(requestedSize &lt;= 7 or: [requestedSize &gt; ((PrimeMap size bitShift: 1) + 1)])		ifTrue: [requestedSize bitOr: 1]		ifFalse: [(PrimeMap at: (requestedSize bitShift: -1)) + (requestedSize bitOr: 1)]"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakDictionary class</class-id> <category>class initialization</category><body package="Debugger-Probes" selector="improperCreationSizeSignal">improperCreationSizeSignal	^Set improperCreationSizeSignal"Smalltalk Professional Debug Package Version 2.5 (c) 1995,1999 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="initialize">initialize	"Initialize signal and size table."	"PDPWeakDictionary initialize"	" the improperCreationSize signal has been delegated to	'Set improperCreationSizeSignal'."	self makeSizeTable"Smalltalk Professional Debug Package Version 2.5 (c) 1995 - 1999 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="makeSizeTable">makeSizeTable	"Construct a prefered size table mapping the first 1024 odd integers	to the next prime."	| primes pos sz |	MaxMapped := 2049.	primes := OrderedCollection with: 3.	3 to: MaxMapped + 100 "Slop to insure we get next prime over MaxMapped" by: 2 do: 			[:cand |			primes detect: [:p | cand \\ p = 0] ifNone: [primes add: cand]].	primes := primes asArray.	sz := MaxMapped // 2.	PrimeMap := ByteArray new: sz.	pos := 1.	1 to: sz do: [:i |		| n p |		n := i * 2 + 1.		[(p := primes at: pos) &gt;= n] whileFalse: [pos := pos + 1].		PrimeMap at: i put: p - n]"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.ProbeCreationSpec</class-id> <category>accessing</category><body package="Debugger-Probes" selector="conditional:">conditional: aBoolean	conditional := aBoolean</body><body package="Debugger-Probes" selector="permanent:">permanent: aBoolean	permanent := aBoolean</body><body package="Debugger-Probes" selector="probeClass">probeClass	^probeClass</body><body package="Debugger-Probes" selector="probeClass:">probeClass: aClass	probeClass := aClass</body><body package="Debugger-Probes" selector="selectWindowParams">selectWindowParams	^selectWindowParams</body><body package="Debugger-Probes" selector="selectWindowParams:">selectWindowParams: aBoolean	selectWindowParams := aBoolean</body><body package="Debugger-Probes" selector="setConditional">setConditional	conditional := true</body><body package="Debugger-Probes" selector="setIsAutoProbe">setIsAutoProbe	isAutoProbe := true.</body><body package="Debugger-Probes" selector="setPermanent">setPermanent	permanent := true</body><body package="Debugger-Probes" selector="setTemporary">setTemporary	permanent := false</body><body package="Debugger-Probes" selector="setUnconditional">setUnconditional	conditional := false</body></methods><methods><class-id>CraftedSmalltalk.ProbeCreationSpec</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="initialize">initialize	isAutoProbe := false.</body><body package="Debugger-Probes" selector="type:conditional:permanent:">type: type conditional: cond permanent: perm	permanent := perm.	probeClass := type.	conditional := cond.</body></methods><methods><class-id>CraftedSmalltalk.ProbeCreationSpec</class-id> <category>testing</category><body package="Debugger-Probes" selector="isAutoProbe">isAutoProbe	^isAutoProbe</body><body package="Debugger-Probes" selector="isConditional">isConditional	^conditional</body><body package="Debugger-Probes" selector="isPermanent">isPermanent	^permanent</body></methods><methods><class-id>CraftedSmalltalk.ProbeCreationSpec class</class-id> <category>instance creation</category><body package="Debugger-Probes" selector="new">new	^super new initialize</body><body package="Debugger-Probes" selector="type:conditional:permanent:">type: type conditional: cond permanent: perm	^self new type: type conditional: cond permanent: perm"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.WatchWindowHolder</class-id> <category>private</category><body package="Debugger-Probes" selector="createWindow">createWindow	| aView subViews visual labelBottom |	window := ScheduledWindow				model: self				label: (#WatchWindow &lt;&lt; #pdp &gt;&gt; 'Watch window')				minimumSize: 200@100.	window icon: (Icon constantNamed: #watchWindow).	aView := WatchWindowView model: self.	aView controller performer: self.	aView controller menuHolder:		(ValueHolder with: (Menu 			labelList: #((again undo) (copy cut paste) ('do it' 'print it' 'inspect') 						(cancel) (hardcopy) ('log on' 'log off'))			values: #(again undo copySelection cut paste doIt printIt						inspectIt cancel hardcopy doLog dontLog))).	subViews := CompositePart new.	visual := label asText allBold asParagraph.	labelBottom := visual preferredBounds height + 4.	labelView := BorderedWrapper			on: visual			in: (LayoutFrame					leftFraction: 0 offset: 0					rightFraction: 1 offset: 0					topFraction: 0 offset: 0					bottomFraction: 0 offset: labelBottom)			border: LookPreferences defaultBorder.	subViews add: labelView.	subViews		add: (LookPreferences edgeDecorator on: aView)		in: (LayoutFrame					leftFraction: 0 offset: 0					rightFraction: 1 offset: 0					topFraction: 0 offset: labelBottom					bottomFraction: 1 offset: 0).	window component: subViews.	^window</body><body package="Debugger-Probes" selector="reopen">reopen	window notNil		ifTrue: [^self].	self createWindow.	displayBox isNil		ifTrue: [window open]		ifFalse: [window openIn: displayBox]</body></methods><methods><class-id>CraftedSmalltalk.WatchWindowHolder</class-id> <category>accessing</category><body package="Debugger-Probes" selector="doLog">doLog	doLogging := true.	self endEntry.</body><body package="Debugger-Probes" selector="dontLog">dontLog	self endEntry.	doLogging := false.</body><body package="Debugger-Probes" selector="label">label	window isNil		ifTrue: [^label].	^window label</body><body package="Debugger-Probes" selector="label:">label: aString	window isNil		ifFalse: [labelView component: aString asText allBold asParagraph].	label := aString</body><body package="Debugger-Probes" selector="showString:">showString: aString	self reopen.	doLogging		ifTrue: [self show: aString; cr]		ifFalse:			[value := aString asText.			self changed: #update.]</body></methods><methods><class-id>CraftedSmalltalk.WatchWindowHolder</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="initialize">initialize	super initialize.	doLogging := true.</body></methods><methods><class-id>CraftedSmalltalk.WatchWindowHolder</class-id> <category>managing</category><body package="Debugger-Probes" selector="removeDependent:">removeDependent: anObject	window == anObject		ifTrue:			[displayBox := window displayBox.			labelView := window := nil].	super removeDependent: anObject</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledBlock</class-id> <category>private - probes</category><body package="Debugger-Probes" selector="addProbeToLiterals:">addProbeToLiterals: aProbe	| probeIndex |	probeIndex := self size.	[probeIndex &gt;= probeStart and: [(self basicAt: probeIndex) == nil]]		whileTrue: [probeIndex := probeIndex -1].	probeIndex = self size		ifTrue: [self grow].	probeIndex := probeIndex + 1.	self basicAt: probeIndex put: aProbe.	^probeIndex</body><body package="Debugger-Probes" selector="adjustJumps:in:at:by:atTop:probeRecord:ignore:">adjustJumps: aJumpTable in: newBytes at: pc by: delta atTop: topFlag probeRecord: probeRecord ignore: activeRecord	| amount map insertBefore changes charInsertPt |	changes := OrderedCollection with: (Array with: pc with: delta with: topFlag).	map := self sourceMap.	insertBefore := probeRecord atEnd | activeRecord notNil.	topFlag		ifTrue:			[charInsertPt := probeRecord characterIndex.			map do: [:ac | ac forPC: pc andCharacterIdx: charInsertPt adjust: delta].			self probesDo:				[:aProbe | | pr |				pr := aProbe probeRecord.				pr == probeRecord					ifFalse: [pr fixPCFor: pc amount: delta]]]		ifFalse:			[map do: [:ac | ac for: pc adjust: delta].			self probesDo: [:aProbe | aProbe probeRecord fixPCFor: pc amount: delta]].	aJumpTable do:		[:jumpRcd |		activeRecord == jumpRcd			ifFalse:				[jumpRcd location &lt; pc					ifTrue:						[(jumpRcd target &gt; pc or:							[insertBefore and:								[jumpRcd target = pc and:									[(map at: probeRecord mapIndex) pcRangeExcludes: jumpRcd location]]])							ifTrue: [jumpRcd newDelta: jumpRcd newDelta + delta]]					ifFalse:						[pc &gt; jumpRcd target							ifTrue: [jumpRcd newDelta: jumpRcd newDelta - delta].						jumpRcd moveBy: delta.]]].	aJumpTable do:		[:jumpRcd |		jumpRcd shouldMakeLong			ifTrue:				[amount := jumpRcd fixJumpIn: newBytes.				self					adjustJumps: aJumpTable					in: newBytes					at: jumpRcd location + 1					by: amount					atTop: false					probeRecord: probeRecord					ignore: jumpRcd]].		"If we are not the top send in this recursive chain, then exit."	topFlag		ifFalse: [^changes].	"At this point any necessary op code changes have been made and	new deltas caluculated.  Now change the actual byte code jump offsets."	aJumpTable do:		[:jumpRcd |		jumpRcd isChanged			ifTrue: [jumpRcd adjustDeltaIn: newBytes]].	^changes</body><body package="Debugger-Probes" selector="basicAddProbe:">basicAddProbe: aProbe	"Add aProbe to the receiver."	| probeIndex |	probeIndex := self addProbeToLiterals: aProbe.	(self insertProbeBytecodesFor: probeIndex)		ifTrue: [^self].	"A method branch limit was exceeded."	BranchLimit raiseSignal.</body><body package="Debugger-Probes" selector="basicIncludesProbe:">basicIncludesProbe: targetProbe	| probeIndex aProbe |	probeIndex := probeStart.	[aProbe := self basicAt: probeIndex.	targetProbe = aProbe or: [aProbe == nil or: [probeIndex = self size]]]		whileFalse: [probeIndex := probeIndex + 1].	^aProbe ~~ nil</body><body package="Debugger-Probes" selector="basicRemoveProbe:">basicRemoveProbe: aProbe	"Add aProbe to the receiver."	| probeIndex someProbe nextIndex oldByteArray probeRecord pc newBytes jumpTable |	oldByteArray := self bytes.	probeIndex := probeStart.	[someProbe := self basicAt: probeIndex.	aProbe = someProbe]		whileFalse: [probeIndex := probeIndex + 1].	probeRecord := (self basicAt: probeIndex) probeRecord.	[nextIndex := probeIndex + 1.	self size &gt;= nextIndex and:		[someProbe := self basicAt: nextIndex.		someProbe ~~ nil]]		whileTrue:			["Change code reference to probe."			oldByteArray at: someProbe insertionPC + 1 put: probeIndex - 1.			"Move probe down one position."			self basicAt: probeIndex put: someProbe.			probeIndex := nextIndex].	self basicAt: probeIndex put: nil.  "Make position empty."	pc := probeRecord insertionPC.	newBytes := ByteArray new: oldByteArray size - 7.	newBytes replaceFrom: 1 to: pc - 1 with: oldByteArray startingAt: 1.	newBytes replaceFrom: pc to: newBytes size with: oldByteArray startingAt: pc + 7.	jumpTable := self jumpTable.	self		adjustJumps: jumpTable		in: newBytes		at: pc		by: -7		atTop: true		probeRecord: probeRecord		ignore: nil.	bytes := (ByteArray new: newBytes size + 4) replaceFrom: 1 to: 4 with: bytes startingAt: 1.	bytes replaceFrom: 5 to: bytes size with: newBytes startingAt: 1.</body><body package="Debugger-Probes" selector="insertProbeBytecodesFor:">insertProbeBytecodesFor: probeIndex	| newBytes jumpTable probeRecord pc changes map |	probeRecord := (self basicAt: probeIndex) probeRecord.	pc := probeRecord insertionPCFor: self.	newBytes := OrderedCollection withAll: self bytes.	newBytes add: OpXLoadLiteral beforeIndex: pc;		add: probeIndex - 1 beforeIndex: pc + 1;		"index of aProbe"		add: OpLoadThisContext beforeIndex: pc + 2;		add: OpXXSend beforeIndex: pc + 3;		add: 1 beforeIndex: pc + 4;		add: probeStart - 2 beforeIndex: pc + 5;		add: OpPop beforeIndex: pc + 6.	"remove object returned from probe"	jumpTable := self jumpTable.	changes := self		adjustJumps: jumpTable		in: newBytes		at: pc		by: 7		atTop: true		probeRecord: probeRecord		ignore: nil.	(jumpTable detect: [:rcd | rcd isLongJumpTooLong] ifNone: [nil]) == nil		ifTrue: 			[bytes := (ByteArray new: newBytes size + 4) replaceFrom: 1 to: 4 with: bytes startingAt: 1.			bytes replaceFrom: 5 to: bytes size with: newBytes startingAt: 1.			^true].	"An excessively long branch was detected.  Must back out changes to method."	self basicAt: probeIndex put: nil.	map := self sourceMap.	changes reverseDo:		[:changeArray | | cpc delta atTop |		cpc := changeArray at: 1.		delta := changeArray at: 2.		atTop := changeArray at: 2.		map do: [:ac | ac for: cpc adjust: delta].		self probesDo: [:aProbe | aProbe probeRecord fixPCFor: cpc amount: delta doEqualPC: atTop]].	auxInfo := nil.	^false</body><body package="Debugger-Probes" selector="probesDo:">probesDo: aBlock 	probeStart to: self size do: 		[:i | 		| aProbe |		aProbe := self basicAt: i.		aProbe == nil			ifTrue: [^self].		aBlock value: aProbe]</body><body package="Debugger-Probes" selector="probeSize">probeSize	| count |	count := 0.	probeStart to: self basicSize do: 		[:i | 		(self basicAt: i) isNil			ifTrue: [^count].		count := count + 1].	^count</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledBlock</class-id> <category>private - info</category><body package="Debugger-Probes" selector="auxInfo">auxInfo	auxInfo isNil		ifTrue: [auxInfo := (AuxCodeInfoExtractor new method: self) run].	^auxInfo</body><body package="Debugger-Probes" selector="jumpTable">jumpTable	^self auxInfo jumpTable</body><body package="Debugger-Probes" selector="maxDepth">maxDepth	^self auxInfo maxDepth</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledBlock</class-id> <category>testing</category><body package="Debugger-Probes" selector="basicHasAnyProbes">basicHasAnyProbes	^(self basicAt: probeStart) notNil</body><body package="Debugger-Probes" selector="isProbed">isProbed	^true</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledBlock</class-id> <category>copying</category><body package="Debugger-Probes" selector="basicMethodDcopy">basicMethodDcopy	^self basicDcopy</body><body package="Debugger-Probes" selector="postDcopy">postDcopy	outerMethod := outerMethod basicDcopy.	auxInfo := nil.	1 to: self basicSize do: [ :i | self basicAt: i put: (self basicAt: i) basicMethodDcopy]</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledBlock</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="copyFrom:">copyFrom: oldSelf	"Copy all the instance variable from oldSelf to the receiver.	This is used to grow a new method."	1 to: oldSelf basicSize do:		[ :i | self basicAt: i put: (oldSelf basicAt: i)].	1 to: self class instSize do:		[ :i | self instVarAt: i put: (oldSelf instVarAt: i)].</body><body package="Debugger-Probes" selector="from:">from: aCompiledBlock	"Recursively create a new ProbedCompiledBlock from aCompliedBlock."	| flags maxDepth |	probeStart := aCompiledBlock numLiterals + 2.	self at: probeStart - 1 put: #actOn:.	1 to: aCompiledBlock numLiterals do: 		[:i | | lit cl bm |		lit := aCompiledBlock literalAt: i.		cl := lit class.		cl == CompiledBlock			ifTrue: 				[self literalAt: i put: (lit := ProbedCompiledBlock from: lit).				lit outerMethod: self]			ifFalse:				[cl == BlockClosure					ifTrue: 						[self literalAt: i put: (lit := lit copy).						bm := ProbedCompiledBlock from: lit method.						lit method: bm.						bm outerMethod: self]					ifFalse: [self literalAt: i put: lit]]].	flags := 16rE0 + (aCompiledBlock usesContextInstVars ifTrue: [16] ifFalse: [0]).	bytes := (ByteArray				with: flags				with: aCompiledBlock numArgs				with: aCompiledBlock numTempsOnly				with: aCompiledBlock frameSize) , aCompiledBlock bytes.	maxDepth := self maxDepth + 2.	maxDepth &gt; self frameSize		ifTrue: [bytes at: 4 put: maxDepth].	^self</body><body package="Debugger-Probes" selector="grow">grow	| newSelf |	newSelf := self class new: self basicSize + 7.	newSelf copyFrom: self.	newSelf become: self</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledBlock</class-id> <category>accessing</category><body package="Debugger-Probes" selector="sourceMap">sourceMap	^self homeMethod methodHolder sourceMap at: self blockMethodIndex</body><body package="Debugger-Probes" selector="variableMap">variableMap	^self homeMethod methodHolder variableMap at: self blockMethodIndex</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledBlock class</class-id> <category>instance creation</category><body package="Debugger-Probes" selector="from:">from: aCompiledBlockMethod	^(self new: aCompiledBlockMethod basicSize + 7) from: aCompiledBlockMethod"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.AbstractCodeProbe</class-id> <category>comparing</category><body package="Debugger-Probes" selector="=">= aProbe	^[self baseParent == aProbe baseParent]		on: MessageNotUnderstood		do: [:ex | false]</body><body package="Debugger-Probes" selector="basicHash">basicHash	^super hash</body><body package="Debugger-Probes" selector="hash">hash	^self baseParent basicHash</body></methods><methods><class-id>CraftedSmalltalk.AbstractCodeProbe</class-id> <category>accessing</category><body package="Debugger-Probes" selector="baseParent">baseParent	parent == nil		ifTrue: [^self].	^parent baseParent</body><body package="Debugger-Probes" selector="blockMethodIndex">blockMethodIndex	^probeRecord blockMethodIndex</body><body package="Debugger-Probes" selector="characterIndex">characterIndex	^probeRecord characterIndex</body><body package="Debugger-Probes" selector="insertionPC">insertionPC	^probeRecord insertionPC</body><body package="Debugger-Probes" selector="mclass">mclass	^probeRecord mclass</body><body package="Debugger-Probes" selector="methodString">methodString	^probeRecord methodString</body><body package="Debugger-Probes" selector="parent:">parent: aProbe	parent := aProbe</body><body package="Debugger-Probes" selector="probeRecord">probeRecord	^probeRecord</body><body package="Debugger-Probes" selector="reinsertAfterLoadInto:">reinsertAfterLoadInto: aMethod	probeRecord := aMethod probeRecordFor: probeRecord insertionRange.	^(self postLoadIntoMethod: aMethod) and:		[aMethod addProbe: self.		self recompileExpressionsUsingProbedMethod: aMethod].</body><body package="Debugger-Probes" selector="reinsertInto:">reinsertInto: aMethod	probeRecord := aMethod probeRecordFor: probeRecord insertionRange.	aMethod addProbe: self.</body><body package="Debugger-Probes" selector="selector">selector	^probeRecord selector</body></methods><methods><class-id>CraftedSmalltalk.AbstractCodeProbe</class-id> <category>copying</category><body package="Debugger-Probes" selector="basicMethodDcopy">basicMethodDcopy		^DoClone		ifTrue: [ProbeClone parent: self]		ifFalse: [self basicDcopy parent: self]</body><body package="Debugger-Probes" selector="postDcopy">postDcopy	probeRecord := probeRecord shallowCopy</body></methods><methods><class-id>CraftedSmalltalk.AbstractCodeProbe</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="forClass:">forClass: aClass	probeRecord isNil		ifTrue: [probeRecord := ProbeInsertionRecord new mclass: aClass]</body><body package="Debugger-Probes" selector="record:">record: aProbeRecord	probeRecord := aProbeRecord</body></methods><methods><class-id>CraftedSmalltalk.AbstractCodeProbe</class-id> <category>saving-loading</category><body package="Debugger-Probes" selector="loadFrom:">loadFrom: aStream	probeRecord := ProbeInsertionRecord createFrom: aStream.</body><body package="Debugger-Probes" selector="postLoadIntoMethod:">postLoadIntoMethod: probedMethod	"Ignore, return true"	^true</body><body package="Debugger-Probes" selector="saveOn:">saveOn: aStream	aStream nextPutAll: 'ProbeType: '; nextPutAll: self class shortName;cr.	probeRecord saveOn: aStream.</body><body package="Debugger-Probes" selector="storeOn:">storeOn: aStream	"You really cannot restore a probe using #readFrom: so #storeOn:	does not make sense, but the decompiler uses #storeOn: so we	use this representation for the decompiler."	aStream		nextPutAll: '(';		store: self class.	aStream nextPutAll: ') '</body><body package="Debugger-Probes" selector="unknowLoadField:on:expected:">unknowLoadField: someString on: aStream expected: fieldName	self class unknowLoadField: someString on: aStream expected: fieldName</body></methods><methods><class-id>CraftedSmalltalk.AbstractCodeProbe</class-id> <category>expression compiling</category><body package="Debugger-Probes" selector="recompileExpressionsUsingProbedMethod:">recompileExpressionsUsingProbedMethod: aMethod	self subclassResponsibility</body></methods><methods><class-id>CraftedSmalltalk.AbstractCodeProbe class</class-id> <category>compiler</category><body package="Debugger-Probes" selector="evaluatorClass">evaluatorClass	^ProbeExprCompiler"Smalltalk Professional Debug Package Version 1.6 (c) 1995,1998 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.AbstractCodeProbe class</class-id> <category>class initialization</category><body package="Debugger-Probes" selector="initialize">initialize	DoClone := false."Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.AbstractCodeProbe class</class-id> <category>copy setup</category><body package="Debugger-Probes" selector="setClone">setClone	DoClone := true"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="setCopy">setCopy	DoClone := false</body></methods><methods><class-id>CraftedSmalltalk.AbstractCodeProbe class</class-id> <category>saving-loading</category><body package="Debugger-Probes" selector="unknowLoadField:on:expected:">unknowLoadField: someString on: aStream expected: fieldName	Object errorSignal raiseErrorString:		((#UnknownField1sAtPosition2p3sExpected &lt;&lt; #pdp &gt;&gt; 'Unknown field "&lt;1s&gt;" at position &lt;2p&gt;. "&lt;3s&gt;" was expected. Please correct the probe file.')			expandMacrosWith: someString			with: aStream position - someString size			with: fieldName)</body></methods><methods><class-id>CraftedSmalltalk.TopOfStackVariable</class-id> <category>accessing</category><body package="Debugger-Probes" selector="debuggerIndex">debuggerIndex	^0</body></methods><methods><class-id>CraftedSmalltalk.TopOfStackVariable</class-id> <category>code generation</category><body package="Debugger-Probes" selector="emitLoad:from:">emitLoad: codeStream from: var	| builder node |	builder := ProgramNodeBuilder new.	node := builder		newMessageReceiver: self newDoitContextNode		selector: #top.	node sourcePosition: var sourcePosition.	node emitValue: codeStream</body><body package="Debugger-Probes" selector="emitStore:value:from:">emitStore: codeStream value: value from: assignment	(self storeNode: value from: assignment) emitValue: codeStream</body><body package="Debugger-Probes" selector="emitStorePop:value:from:">emitStorePop: codeStream value: value from: assignment	(self storeNode: value from: assignment) emitEffect: codeStream</body></methods><methods><class-id>CraftedSmalltalk.TopOfStackVariable</class-id> <category>code generation-private</category><body package="Debugger-Probes" selector="emitStore:from:">emitStore: codeStream from: var	"TopOfStackVariable implements the public message emitStore:value:from:,	not the private message. "	self shouldNotImplement</body><body package="Debugger-Probes" selector="emitStorePop:from:">emitStorePop: codeStream from: var	"TopOfStackVariable implements the public message emitStorePop:value:from:,	not the private message. "	self shouldNotImplement</body></methods><methods><class-id>CraftedSmalltalk.TopOfStackVariable</class-id> <category>private</category><body package="Debugger-Probes" selector="newDoitContextNode">newDoitContextNode	^VariableNode new name: ProbeExprCompiler doitContextVarName</body><body package="Debugger-Probes" selector="storeNode:from:">storeNode: valueNode from: assignment	| builder node |	builder := ProgramNodeBuilder new.	node := builder		newMessageReceiver: self newDoitContextNode		selector: #storeTop:		arguments: (Array with: valueNode).	node sourcePosition: assignment sourcePosition.	^node</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe</class-id> <category>responses</category><body package="Debugger-Probes" selector="actOn:">actOn: aContext	(self test: aContext)		ifTrue: [^self breakOn: aContext label: self labelString].</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe</class-id> <category>accessing</category><body package="Debugger-Probes" selector="addVariable:">addVariable: aSymbol	variables isNil		ifTrue: [variables := Dictionary new].	^variables at: aSymbol put: nil.</body><body package="Debugger-Probes" selector="editorLabelString">editorLabelString	^(#EditBreakpoint &lt;&lt; #pdp &gt;&gt; 'Edit Breakpoint') asString</body><body package="Debugger-Probes" selector="inspectString">inspectString	^self labelString</body><body package="Debugger-Probes" selector="labelString">labelString	labelString value isNil		ifTrue: [self createLabelString].	^labelString value</body><body package="Debugger-Probes" selector="labelString:">labelString: aString	labelString value: aString</body><body package="Debugger-Probes" selector="reportString">reportString	^testMethod == FalseTestMethod		ifTrue: [(#TestExprFailedRecompile &lt;&lt; #pdp &gt;&gt; 'Test expression failed recompile (probe disabled)') asString]		ifFalse: ['']</body><body package="Debugger-Probes" selector="setTemporary">setTemporary	permanent := false</body><body package="Debugger-Probes" selector="testMethodAndSource">testMethodAndSource	^testMethod -&gt; testSource</body><body package="Debugger-Probes" selector="testMethodAndSource:">testMethodAndSource: anAssoc	testMethod := anAssoc key.	testSource := anAssoc value string.</body><body package="Debugger-Probes" selector="testSource">testSource	testSource notNil		ifTrue: [^testSource].	testMethod isNil		ifTrue: [^String new].	^testMethod getSource string</body><body package="Debugger-Probes" selector="variableNames">variableNames	variables isNil		ifTrue: [^#()].	^variables keys asArray</body><body package="Debugger-Probes" selector="variables">variables	variables isNil ifTrue: [^Dictionary new].	^variables</body><body package="Debugger-Probes" selector="workingCopy">workingCopy	^self shallowCopy postWorkingCopy</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe</class-id> <category>accessing - emphasis</category><body package="Debugger-Probes" selector="basicEmphasis">basicEmphasis	^ProbeCharacterStyle key: #probe value: self</body><body package="Debugger-Probes" selector="emphasis">emphasis	^permanent		ifTrue: [self basicEmphasis]		ifFalse: [self tempEmphasis]</body><body package="Debugger-Probes" selector="emphasize:">emphasize: aText	^aText		emphasizeFrom: self characterIndex		to: self characterIndex		with: self emphasis</body><body package="Debugger-Probes" selector="tempEmphasis">tempEmphasis	^ProbeCharacterStyle key: #tempProbe value: self</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe</class-id> <category>private</category><body package="Debugger-Probes" selector="basicLabelString">basicLabelString	^labelString value</body><body package="Debugger-Probes" selector="basicTestMethod">basicTestMethod	^testMethod</body><body package="Debugger-Probes" selector="basicTestSource">basicTestSource	^testSource</body><body package="Debugger-Probes" selector="test:">test: aContext	^(self isPermanent or: [Processor activeProcess isUnderDebug]) and:		[(testMethod isNil) or:			[testMethod				valueWithReceiver: aContext homeReceiver				arguments: (Array with: aContext with: self)]]</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="clearLabelString">clearLabelString	labelString value: nil.</body><body package="Debugger-Probes" selector="createLabelString">createLabelString	labelString value: ((#BreakIn1sAt2s &lt;&lt; #pdp &gt;&gt; 'Break in &lt;1s&gt; at &lt;2s&gt;')			expandMacrosWith: self methodString			with: self characterIndex printString).</body><body package="Debugger-Probes" selector="finishSetup">finishSetup	(self mclass includesBehavior: Object)		ifTrue: [^self].	self recompileIfKnownMethods.</body><body package="Debugger-Probes" selector="ifNecessaryCopy:andRebindFrom:">ifNecessaryCopy: aMethod andRebindFrom: oldVariables	"This method returns a new method with rebound variables if	rebinding is needed.  Otherwise, the original method is returned."	| nuMethod keepCopy vars |	variables == nil		ifTrue: [^aMethod].	nuMethod := aMethod copy.	keepCopy := false.	vars := OrderedCollection new.	oldVariables associationsDo: [:ac | vars add: ac].	nuMethod withAllBlockMethodsDo:		[:meth |		1 to: meth numLiterals do:			[:i | | lit |			lit := meth at: i.			(vars contains: [:obj | obj == lit])				ifTrue:					[keepCopy := true.					meth at: i put: (variables bindingFor: lit key)]]].	keepCopy		ifFalse: [^aMethod].	^nuMethod</body><body package="Debugger-Probes" selector="initialize">initialize	permanent := true.	labelString := ValueHolder new.</body><body package="Debugger-Probes" selector="postWorkingCopy">postWorkingCopy	variables := variables shallowCopy.	labelString := labelString shallowCopy</body><body package="Debugger-Probes" selector="recompileIfKnownMethods">recompileIfKnownMethods	self isKnownMethod		ifFalse: [^self].	testMethod := CodeProbe compileProbeMethod: testSource inClass: self mclass.</body><body package="Debugger-Probes" selector="setAction">setAction	testMethod := DefaultTestMethod.	testSource := DefaultTestSource.</body><body package="Debugger-Probes" selector="setAlwaysAction">setAlwaysAction	testMethod := TrueTestMethod.	testSource := self class trueString.</body><body package="Debugger-Probes" selector="setNoAction">setNoAction	testMethod := FalseTestMethod.	testSource := self class falseString.</body><body package="Debugger-Probes" selector="updateExpressionsFromTemplate:">updateExpressionsFromTemplate: aProbe	| origMethod |	testSource := aProbe basicTestSource.	origMethod := aProbe basicTestMethod.	testMethod := aProbe isKnownMethod		ifTrue: [origMethod]		ifFalse: [self ifNecessaryCopy: origMethod andRebindFrom: aProbe variables].</body><body package="Debugger-Probes" selector="updateExpressionsFromWorkingCopy:">updateExpressionsFromWorkingCopy: aProbe	self testMethodAndSource: aProbe testMethodAndSource.</body><body package="Debugger-Probes" selector="updateFromTemplate:">updateFromTemplate: aProbe	self updateMiscFromTemplate: aProbe.	self updateExpressionsFromTemplate: aProbe.</body><body package="Debugger-Probes" selector="updateFromWorkingCopy:">updateFromWorkingCopy: aProbe	self updateMiscFromWorkingCopy: aProbe.	self updateExpressionsFromWorkingCopy: aProbe.</body><body package="Debugger-Probes" selector="updateInstanceVarIndexForMethod:">updateInstanceVarIndexForMethod: probedMethod	"Ignore, return true"	^true</body><body package="Debugger-Probes" selector="updateMiscFromProbe:">updateMiscFromProbe: aProbe	probeRecord := aProbe probeRecord.	self labelString: aProbe basicLabelString.</body><body package="Debugger-Probes" selector="updateMiscFromTemplate:">updateMiscFromTemplate: aProbe	| nuVars |	self updateMiscFromProbe: aProbe.	variables == nil		ifTrue: [^self]. 	nuVars := Dictionary new.	variables keysAndValuesDo: [:aKey :aValue | nuVars at: aKey put: aValue].	variables := nuVars.</body><body package="Debugger-Probes" selector="updateMiscFromWorkingCopy:">updateMiscFromWorkingCopy: aProbe	self updateMiscFromProbe: aProbe.	variables := aProbe variables.	variables == nil		ifTrue: [^self]. 	variables isEmpty		ifTrue: [variables := nil].</body><body package="Debugger-Probes" selector="updateTempVarForMethod:">updateTempVarForMethod: probedMethod	"Ignore, return true"	^true</body><body package="Debugger-Probes" selector="updateTempVarIndexForMethod:">updateTempVarIndexForMethod: probedMethod	"Ignore, return true"	^true</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe</class-id> <category>editor creation</category><body package="Debugger-Probes" selector="createEditorOn:">createEditorOn: probedMethod	^self createEditorOn: probedMethod class: probedMethod mclass</body><body package="Debugger-Probes" selector="createEditorOn:class:">createEditorOn: probedMethod class: probedClass 	self forClass: probedClass.	^self createTestEditorOn: probedMethod class: probedClass</body><body package="Debugger-Probes" selector="createTestEditorOn:class:">createTestEditorOn: probedMethod class: probedClass 	^(CodeProbeEditor on: self in: probedMethod class: probedClass) createTestEditor</body><body package="Debugger-Probes" selector="makeConditional:replacing:with:">makeConditional: probeSpec replacing: unprobedMethod with: probedMethod	probeSpec isConditional		ifTrue:			[self setNoAction.			self finishSetup.]		ifFalse:			[self setAction.			self finishSetup.			unprobedMethod mclass addSelector: probedMethod selector withMethod: probedMethod.			PDPManager				changedMethodFrom: unprobedMethod				to: probedMethod				by: nil.			^self].	self openEditorOn: probedMethod andReplace: unprobedMethod</body><body package="Debugger-Probes" selector="modifyIn:">modifyIn: aProbedMethod	| topView |	topView := self createEditorOn: aProbedMethod.	topView model closeAction: [].	topView open</body><body package="Debugger-Probes" selector="openEditorOn:andReplace:">openEditorOn: probedMethod andReplace: unprobedMethod	| topView |	topView := self createEditorOn: probedMethod.	topView model closeAction:		[unprobedMethod mclass addSelector: probedMethod selector withMethod: probedMethod.		PDPManager			changedMethodFrom: unprobedMethod			to: probedMethod			by: nil].	topView open</body><body package="Debugger-Probes" selector="unconditionallyInsertInto:replacing:">unconditionallyInsertInto: probedMethod replacing: unprobedMethod	self setAction.	self finishSetup.	unprobedMethod mclass addSelector: probedMethod selector withMethod: probedMethod.	PDPManager		changedMethodFrom: unprobedMethod		to: probedMethod		by: nil.</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe</class-id> <category>testing</category><body package="Debugger-Probes" selector="isKnownMethod">isKnownMethod	^testMethod == TrueTestMethod or: [testMethod == DebugActiveMethod or: [testSource = CodeProbe falseString]]</body><body package="Debugger-Probes" selector="isPermanent">isPermanent	^permanent</body><body package="Debugger-Probes" selector="isTemporary">isTemporary	^permanent not</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe</class-id> <category>saving-loading</category><body package="Debugger-Probes" selector="loadFrom:">loadFrom: aStream	super loadFrom: aStream.	self loadLabelStringFrom: aStream.	self loadVariablesFrom: aStream.	self loadTestExpressionFrom: aStream.</body><body package="Debugger-Probes" selector="loadLabelStringFrom:">loadLabelStringFrom:  aStream	| fieldName |	fieldName := aStream upTo: Character space.	fieldName = 'LabelString:'		ifFalse:			[^self unknowLoadField: fieldName on: aStream expected: 'LabelString:'].	labelString := (String readFrom: aStream) asValue.	aStream next.	"swallow cr"</body><body package="Debugger-Probes" selector="loadTestExpressionFrom:">loadTestExpressionFrom:  aStream	| fieldName |	fieldName := aStream upTo: Character space.	fieldName = 'TestExpr:'		ifFalse:			[^self unknowLoadField: fieldName on: aStream expected: 'TestExpr:'].	testSource := String readFrom: aStream.	aStream next.	"swallow cr"</body><body package="Debugger-Probes" selector="loadVariablesFrom:">loadVariablesFrom: aStream	| fieldName numVars varName defaultVal |	fieldName := aStream upTo: Character space.	fieldName = 'Variables:'		ifFalse:			[^self unknowLoadField: fieldName on: aStream expected: 'Variables:'].	numVars := Number readFrom: aStream.	aStream next.	"swallow cr"	[numVars = 0]		whileFalse:			[varName := (aStream upTo: Character tab) asSymbol.			self addVariable: varName.			defaultVal := aStream nextChunk.			aStream next.	"swallow cr"			defaultVal isEmpty				ifFalse:					[defaultVal := Compiler evaluate: defaultVal.					self variableAt: varName put: defaultVal].			numVars := numVars - 1].</body><body package="Debugger-Probes" selector="saveLabelStringOn:">saveLabelStringOn:  aStream	aStream nextPutAll: 'LabelString: '.	self labelString printOn: aStream.	aStream cr.</body><body package="Debugger-Probes" selector="saveOn:">saveOn:  aStream	super saveOn: aStream.	self saveLabelStringOn: aStream.	self saveVariablesOn: aStream.	self saveTestExpressionOn: aStream.</body><body package="Debugger-Probes" selector="saveTestExpressionOn:">saveTestExpressionOn:  aStream	aStream nextPutAll: 'TestExpr: '.	self testSource printOn: aStream.	aStream cr.</body><body package="Debugger-Probes" selector="saveVariablesOn:">saveVariablesOn: aStream	| varNames |	aStream nextPutAll: 'Variables: '.	varNames := self variableNames.	varNames size printOn: aStream.	aStream cr.	varNames do: [:str | aStream nextPutAll: str; tab; nextPut: $!; cr.]</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe</class-id> <category>expression compiling</category><body package="Debugger-Probes" selector="makeSafeTestMethod">makeSafeTestMethod	testMethod := FalseTestMethod</body><body package="Debugger-Probes" selector="recompileExpressionsUsingProbedMethod:">recompileExpressionsUsingProbedMethod: aMethod	^self recompileTestExpressionUsingProbedMethod: aMethod</body><body package="Debugger-Probes" selector="recompileTestExpressionUsingProbedMethod:">recompileTestExpressionUsingProbedMethod: aMethod	| src meth |	self isKnownMethod		ifTrue: [^true].	src := self testSource.	self makeSafeTestMethod.		"Reset the method to a sane value in case of failure."	meth := ProbeExprCompiler new		compileProbeExpression: src		forProbe: self		inClass: aMethod mclass		beginScope: (aMethod scopeForProbe: self)		notifying: nil		ifFail: [^false].	self testMethodAndSource: meth-&gt;src.	^true</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe</class-id> <category>public</category><body package="Debugger-Probes" selector="variableAt:">variableAt: aSymbol	^variables at: aSymbol</body><body package="Debugger-Probes" selector="variableAt:put:">variableAt: aSymbol put: anObject	^variables at: aSymbol put: anObject</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe class</class-id> <category>class initialization</category><body package="Debugger-Probes" selector="compileProbeMethod:inClass:">compileProbeMethod: aString inClass: aClass	| newMethod |	newMethod := ProbeExprCompiler new		compileProbeExpression: aString asString		forProbe: self new		inClass: aClass		beginScope: (NameScope forClass: aClass)		notifying: nil		ifFail: [^nil].	newMethod isNil		ifTrue: [^nil].	^newMethod"Smalltalk Professional Debug Package Version 1.6 (c) 1995,1997,1998 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="debugActiveString">debugActiveString	^'^DebugActive'"Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="falseString">falseString	^'false'"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="initializeMethods">initializeMethods	DefaultTestMethod := DebugActiveMethod := self compileProbeMethod: self debugActiveString inClass: Object.	DefaultTestSource := self debugActiveString.	FalseTestMethod := self compileProbeMethod: self falseString inClass: Object.	TrueTestMethod := self compileProbeMethod: self trueString inClass: Object."Smalltalk Professional Debug Package Version 1.5 (c) 1995,1997 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="trueString">trueString	^'true'"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe class</class-id> <category>instance creation</category><body package="Debugger-Probes" selector="createFrom:">createFrom: aStream	| fieldName className |	fieldName := aStream upTo: Character space.	fieldName = 'ProbeType:'		ifFalse:			[^self unknowLoadField: fieldName on: aStream expected: 'ProbeType:'].	className := (aStream upTo: Character cr) asSymbol.	^className asQualifiedReference value new loadFrom: aStream."Smalltalk Professional Debug Package Version 2.51 (c) 2000 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="new">new	^super new initialize"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe class</class-id> <category>defaults</category><body package="Debugger-Probes" selector="defaultConditionalProbe">defaultConditionalProbe	^false"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="defaultProbeType">defaultProbeType	^#Breakpoint"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="defaultSelectWinParams">defaultSelectWinParams	^false"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="defaultTempProbe">defaultTempProbe	^PDPManager isPermanentProbeDefault not"Smalltalk Professional Debug Package Version 3.0 (c) 2001 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe class</class-id> <category>testing</category><body package="Debugger-Probes" selector="needsSafeRebinding">needsSafeRebinding	^true</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe class</class-id> <category>user interaction</category><body package="Debugger-Probes" selector="newDefaultMethodFrom:inClass:">newDefaultMethodFrom: aString inClass: aClass	| dm |	dm := self compileProbeMethod: aString inClass: aClass.	dm isNil		ifTrue: [^Dialog warn: (#MethodDidNotCompileDiscarded &lt;&lt; #pdp &gt;&gt; 'Method did not compile,&lt;n&gt;change discarded.') expandMacros].	DefaultTestMethod := dm.	DefaultTestSource := aString."Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="selectBrowserProbeType">selectBrowserProbeType	^self selectProbeType: false asTemp: false"Smalltalk Professional Debug Package Version 2.6 (c) 2001 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="selectDebuggerProbeTypeAsTemp:">selectDebuggerProbeTypeAsTemp: forceTemp	^self selectProbeType: true asTemp: forceTemp"Smalltalk Professional Debug Package Version 2.6 (c) 2001 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="selectProbeType:asTemp:">selectProbeType: fromDebugger asTemp: forceTempProbe	| panel buttonSpacing bottom aModel em col1Width col2Width col2Start totalWidth col1End basicTypeModel conditionalModel permanenceModel result winParam testBlock builder buttonSpec breakButtonW varWatchButtonW expWatchButtonW winParamButtonW condButtonW tempButtonW indent col2End extent yPosition acceptButtonW cancelButtonW tempProbe buttonWidth |	conditionalModel := ValueHolder with: self defaultConditionalProbe.   "get default setting"	winParam := ValueHolder with: self defaultSelectWinParams.   "get default setting"	basicTypeModel := ValueHolder with: self defaultProbeType.  "get default setting"	tempProbe := forceTempProbe or: [self defaultTempProbe].	permanenceModel := ValueHolder with: tempProbe.	panel := SimpleDialog new.	builder := panel builder.	builder add: (WindowSpec label: (#InsertProbe &lt;&lt; #pdp &gt;&gt; 'Insert Probe')).	em := 'm' asComposedText preferredBounds extent.	buttonSpacing := (em y / 2) truncated.	buttonSpec :=		RadioButtonSpec			model: basicTypeModel			label: (#Breakpoint &lt;&lt; #pdp &gt;&gt; 'Breakpoint')			select: #Breakpoint			layout: (0@0 extent: 1@1).	builder add: buttonSpec.	breakButtonW := builder wrapper.	buttonSpec :=		RadioButtonSpec			model: basicTypeModel			label: (#VariableWatch &lt;&lt; #pdp &gt;&gt; 'Variable Watch')			select: #Variable			layout: (0@0 extent: 1@1).	builder add: buttonSpec.	varWatchButtonW := builder wrapper.	buttonSpec :=		RadioButtonSpec			model: basicTypeModel			label: (#ExpressionWatch &lt;&lt; #pdp &gt;&gt; 'Expression Watch')			select: #Expression			layout: (0@0 extent: 1@1).	builder add: buttonSpec.	expWatchButtonW := builder wrapper.	col1Width := expWatchButtonW preferredBounds width.	buttonSpec :=		CheckBoxSpec			model: winParam			label: (#WindowParameters &lt;&lt; #pdp &gt;&gt; 'Window Parameters')			layout: (0@0 extent: 1@1).	builder add: buttonSpec.	winParamButtonW := builder wrapper.	winParamButtonW isEnabled: winParam value.	col1Width := col1Width max: winParamButtonW preferredBounds width.	buttonSpec :=		CheckBoxSpec			model: conditionalModel			label: (#Conditional &lt;&lt; #pdp &gt;&gt; 'Conditional')			layout: (0@0 extent: 1@1).	builder add: buttonSpec.	condButtonW := builder wrapper.	col2Width := condButtonW preferredBounds width.	fromDebugger		ifTrue:			[buttonSpec :=				CheckBoxSpec					model: permanenceModel					label: (#Temporary &lt;&lt; #pdp &gt;&gt; 'Temporary')					layout: (0@0 extent: 1@1).			builder add: buttonSpec.			tempButtonW := builder wrapper.			tempButtonW isEnabled: forceTempProbe not.			col2Width := col2Width max: tempButtonW preferredBounds width].	indent := em x * 2.	col1End := col1Width + indent.	col2Start := col1End + em x.	col2End := col2Start + col2Width.	totalWidth := col2End + indent.	yPosition := em y.	extent := breakButtonW preferredBounds extent.	bottom := yPosition + extent y.	breakButtonW newLayout: (LayoutFrame				leftFraction: 0 offset: indent				rightFraction: 0  offset: col1End				topFraction: 0 offset: yPosition				bottomFraction: 0 offset: bottom).	extent := condButtonW preferredBounds extent.	condButtonW newLayout: (LayoutFrame				leftFraction: 0 offset: col2Start				rightFraction: 0  offset: col2End				topFraction: 0 offset: yPosition				bottomFraction: 0 offset: yPosition + extent y).	yPosition := bottom  + buttonSpacing.	extent := varWatchButtonW preferredBounds extent.	bottom := yPosition + extent y.	varWatchButtonW newLayout: (LayoutFrame				leftFraction: 0 offset: indent				rightFraction: 0  offset: col1End				topFraction: 0 offset: yPosition				bottomFraction: 0 offset: bottom).	yPosition := bottom  + buttonSpacing.	extent := expWatchButtonW preferredBounds extent.	bottom := yPosition + extent y.	expWatchButtonW newLayout: (LayoutFrame				leftFraction: 0 offset: indent				rightFraction: 0  offset: col1End				topFraction: 0 offset: yPosition				bottomFraction: 0 offset: bottom).	fromDebugger		ifTrue:			[extent := tempButtonW preferredBounds extent.			tempButtonW newLayout: (LayoutFrame						leftFraction: 0 offset: col2Start						rightFraction: 0  offset: col2End						topFraction: 0 offset: yPosition						bottomFraction: 0 offset: yPosition + extent y)].	yPosition := bottom  + buttonSpacing.	extent := winParamButtonW preferredBounds extent.	bottom := yPosition + extent y.	winParamButtonW newLayout: (LayoutFrame				leftFraction: 0 offset: indent				rightFraction: 0  offset: col1End				topFraction: 0 offset: yPosition				bottomFraction: 0 offset: bottom).	aModel := PluggableAdaptor on: (ValueHolder newBoolean).	basicTypeModel addDependent: aModel.	conditionalModel addDependent: aModel.	testBlock := [basicTypeModel value == #Variable and: [conditionalModel value not]].	aModel 		getBlock: [:m | testBlock value]		putBlock: [:m :v |]		updateBlock: [:m :a :p | winParamButtonW isEnabled: testBlock value. true].	yPosition := bottom  + (3 * buttonSpacing).	"add okButton"	buttonSpec :=		ActionButtonSpec			model: #accept			label: (#InsertDots &lt;&lt; #pdp &gt;&gt; 'Insert...')			layout: (0@0 extent: 1@1).	builder add: buttonSpec.	acceptButtonW := builder wrapper.	"add cancel button"	buttonSpec :=		ActionButtonSpec			model: #cancel			label: (#Cancel &lt;&lt; #pdp &gt;&gt; 'Cancel')			layout: (0@0 extent: 1@1).	builder add: buttonSpec.	cancelButtonW := builder wrapper.	extent := cancelButtonW preferredBounds extent max: acceptButtonW preferredBounds extent.	buttonWidth := extent x + (em x * 2).	bottom := yPosition + extent y.	cancelButtonW newLayout: (LayoutFrame				leftFraction: 1 offset: indent negated - buttonWidth				rightFraction: 1  offset: indent negated				topFraction: 0 offset: yPosition				bottomFraction: 0 offset: bottom).	acceptButtonW newLayout: (LayoutFrame				leftFraction: 1 offset: (indent negated - buttonWidth) * 2				rightFraction: 1  offset: indent negated * 2 - buttonWidth				topFraction: 0 offset: yPosition				bottomFraction: 0 offset: bottom).	yPosition := buttonSpacing + bottom.	builder window model: panel.	panel accept onChangeSend: #close to: panel.	panel cancel onChangeSend: #close to: panel.	builder openDialogWithExtent: totalWidth @ yPosition.	panel cancel value		ifTrue: [^nil].	result := ProbeCreationSpec new probeClass: (basicTypeModel value);				conditional: conditionalModel value.	result selectWindowParams: winParam value &amp; testBlock value.	^fromDebugger		ifTrue: [result permanent: permanenceModel value not]		ifFalse:[result]"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="setDefaultMethodToDebugActive">setDefaultMethodToDebugActive	DefaultTestMethod := DebugActiveMethod.	DefaultTestSource := self debugActiveString."Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="setDefaultMethodToFalse">setDefaultMethodToFalse	DefaultTestMethod := FalseTestMethod.	DefaultTestSource := self falseString."Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="setDefaultMethodToTrue">setDefaultMethodToTrue	DefaultTestMethod := TrueTestMethod.	DefaultTestSource := self trueString."Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.PDPTransientWarning</class-id> <category>interface opening</category><body package="Debugger-Probes" selector="on:">on: aString	labelText := aString.	self openInterface: #windowSpec.</body><body package="Debugger-Probes" selector="postBuildWith:">postBuildWith: aBuilder	(aBuilder componentAt: #warning) labelString: labelText.	aBuilder window displayBox: (0 @ 0 extent: aBuilder component preferredBounds extent + (50 @ 40)).</body><body package="Debugger-Probes" selector="postOpenWith:">postOpenWith: aBuilder	[(Delay forMilliseconds: 1500) wait.	aBuilder window topComponent model close] forkAt: Processor activeProcess priority + 1.</body></methods><methods><class-id>CraftedSmalltalk.PDPTransientWarning class</class-id> <category>instance creation</category><body package="Debugger-Probes" selector="on:">on: aString	self new on: aString"Smalltalk Professional Debug Package Version 2.5 (c) 1999 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.AuxCodeInfoExtractor</class-id> <category>decoding</category><body package="Debugger-Probes" selector="depthAt:">depthAt: aPC		[pc = aPC]		whileFalse:			[oldPC := pc.			visited at: pc put: true.			self interpretNextInstructionFor: self.			(visited at: pc)				ifTrue: [self endBranch]].	^depth</body><body package="Debugger-Probes" selector="run">run		[self atEnd]		whileFalse:			[oldPC := pc.			visited at: pc put: true.			self interpretNextInstructionFor: self.			(visited at: pc)				ifTrue: [self endBranch]]</body></methods><methods><class-id>CraftedSmalltalk.AuxCodeInfoExtractor</class-id> <category>opcodes-data movement</category><body package="Debugger-Probes" selector="dupFirst">dupFirst	self push</body><body package="Debugger-Probes" selector="dupLast">dupLast	self pop</body><body package="Debugger-Probes" selector="dupNext">dupNext	"no action"</body><body package="Debugger-Probes" selector="pop">pop	self pop: 1</body><body package="Debugger-Probes" selector="push">push	self push: 1</body><body package="Debugger-Probes" selector="pushConstant:">pushConstant: value	self push</body><body package="Debugger-Probes" selector="pushContext">pushContext	self push</body><body package="Debugger-Probes" selector="pushCopiedValues:">pushCopiedValues: count	self push: count</body><body package="Debugger-Probes" selector="pushInst:">pushInst: index	self push</body><body package="Debugger-Probes" selector="pushLocal:">pushLocal: index	self push</body><body package="Debugger-Probes" selector="pushLocalIndirect:index:">pushLocalIndirect: majorIndex index: minorIndex	self push.</body><body package="Debugger-Probes" selector="pushNewArray:">pushNewArray: size	self push</body><body package="Debugger-Probes" selector="pushReceiver">pushReceiver	self push</body><body package="Debugger-Probes" selector="pushStatic:">pushStatic: assoc	self push</body><body package="Debugger-Probes" selector="storeInst:">storeInst: index	"no action"</body><body package="Debugger-Probes" selector="storeLocal:">storeLocal: index	"no action"</body><body package="Debugger-Probes" selector="storePopInst:">storePopInst: index	self pop</body><body package="Debugger-Probes" selector="storePopLocal:">storePopLocal: index	self pop</body><body package="Debugger-Probes" selector="storePopLocalIndirect:index:">storePopLocalIndirect: majorIndex index: minorIndex	self pop.</body></methods><methods><class-id>CraftedSmalltalk.AuxCodeInfoExtractor</class-id> <category>private-jumps</category><body package="Debugger-Probes" selector="endBranch">endBranch	| state |	(jumpStack isEmpty)		ifTrue: [^pc := method bytesSize + 1].	state := jumpStack removeLast.	pc := state key.	depth := state value.</body></methods><methods><class-id>CraftedSmalltalk.AuxCodeInfoExtractor</class-id> <category>opcodes-control</category><body package="Debugger-Probes" selector="jump:">jump: delta	jumps add: (JumpRecord pc: oldPC delta: delta opr: (method byteAt: oldPC)).	delta &lt; 0		ifFalse: [pc := pc + delta]</body><body package="Debugger-Probes" selector="jump:if:">jump: delta if: condition		self pop.	jumps add: (JumpRecord pc: oldPC delta: delta opr: (method byteAt: oldPC)).	jumpStack add: pc-&gt;depth.	pc := pc + delta.</body><body package="Debugger-Probes" selector="loopHead">loopHead</body><body package="Debugger-Probes" selector="makeCopyingBlock:count:">makeCopyingBlock: meth count: count	self pop: count - 1</body><body package="Debugger-Probes" selector="makeFullBlock:">makeFullBlock: meth	self push</body><body package="Debugger-Probes" selector="makeFullCopyingBlock:count:">makeFullCopyingBlock: meth count: count	self pop: count - 1</body><body package="Debugger-Probes" selector="methodPrimitive:">methodPrimitive: index	self push</body><body package="Debugger-Probes" selector="methodReturnTop:">methodReturnTop: levels	self endBranch</body><body package="Debugger-Probes" selector="primitiveReturn">primitiveReturn</body><body package="Debugger-Probes" selector="returnTop">returnTop	self endBranch</body><body package="Debugger-Probes" selector="send:numArgs:">send: selector numArgs: na	self pop: na</body><body package="Debugger-Probes" selector="sendNoCheck:numArgs:">sendNoCheck: selector numArgs: na	self pop: na</body><body package="Debugger-Probes" selector="sendNonImmediate:numArgs:">sendNonImmediate: selector numArgs: na	self pop: na</body><body package="Debugger-Probes" selector="sendSuper:numArgs:">sendSuper: selector numArgs: na	self pop: na + 1</body></methods><methods><class-id>CraftedSmalltalk.AuxCodeInfoExtractor</class-id> <category>accessing</category><body package="Debugger-Probes" selector="jumpTable">jumpTable	^jumps</body><body package="Debugger-Probes" selector="maxDepth">maxDepth	^maxDepth</body></methods><methods><class-id>CraftedSmalltalk.AuxCodeInfoExtractor</class-id> <category>private</category><body package="Debugger-Probes" selector="method:">method: aMethod	super method: aMethod.	oldPC := pc.	visited := Array new: method bytesSize + 1 withAll: false.	jumps := OrderedCollection new.	jumpStack := OrderedCollection new.	depth := method numTemps.	maxDepth := depth.</body></methods><methods><class-id>CraftedSmalltalk.AuxCodeInfoExtractor</class-id> <category>private-stack</category><body package="Debugger-Probes" selector="pop:">pop: count	depth := depth - count</body><body package="Debugger-Probes" selector="push:">push: count	depth := depth + count.	maxDepth &gt; depth		ifFalse: [maxDepth := depth].</body></methods><methods><class-id>CraftedSmalltalk.PDPInstrumenter</class-id> <category>accessing</category><body package="Debugger-Probes" selector="class:">class: aClass	classUnderTest := aClass.</body><body package="Debugger-Probes" selector="instrumentationRecords:">instrumentationRecords: aCollection	instrumentationRecords := aCollection</body><body package="Debugger-Probes" selector="instrumentationRequest:">instrumentationRequest: aSymbol	instrumentationRequest := aSymbol.</body><body package="Debugger-Probes" selector="iVarIndex">iVarIndex	^iVarIndex</body><body package="Debugger-Probes" selector="iVarIndex:">iVarIndex: anInteger	iVarIndex := anInteger</body><body package="Debugger-Probes" selector="iVarName">iVarName	^iVarName</body><body package="Debugger-Probes" selector="iVarName:">iVarName: aString	iVarName := aString</body><body package="Debugger-Probes" selector="iVarSelection">iVarSelection	^iVarName -&gt; iVarIndex</body><body package="Debugger-Probes" selector="performInstrumentation">performInstrumentation	self perform: instrumentationRequest.</body><body package="Debugger-Probes" selector="selectWindowParams:">selectWindowParams: aBoolean	selectWindowParams := aBoolean</body><body package="Debugger-Probes" selector="useConditionalProbe:">useConditionalProbe: aBoolean	useConditionalProbe := aBoolean</body></methods><methods><class-id>CraftedSmalltalk.PDPInstrumenter</class-id> <category>private</category><body package="Debugger-Probes" selector="createAndAddProbesFor:">createAndAddProbesFor: aRec	self subclassResponsibility</body><body package="Debugger-Probes" selector="createExpression">createExpression	self subclassResponsibility</body><body package="Debugger-Probes" selector="createIvarLeadString">createIvarLeadString	leadString := ((#Ivar1s &lt;&lt; #pdp &gt;&gt; 'Ivar %&lt;&lt;1s&gt;%&gt; ')			expandMacrosWith: iVarName).</body><body package="Debugger-Probes" selector="createNewProbe">createNewProbe	probe := probeClass new.	probe updateFromTemplate: templateProbe.	probe record: probeRecord.	probedMethod addProbe: probe.</body><body package="Debugger-Probes" selector="createTemplateProbe">createTemplateProbe	templateProbe := probeClass new.	self initializeTemplateTestMethod.</body><body package="Debugger-Probes" selector="doNothing">doNothing</body><body package="Debugger-Probes" selector="finishBlock">finishBlock	^[| oldMethods newMethods |	newMethods := ReadWriteStream on: (Array new: instrumentationRecords size).	oldMethods := ReadWriteStream on: (Array new: instrumentationRecords size).	instrumentationRecords do:		[:aRec | | originalMethod |		originalMethod := aRec compiledMethod.		probedMethod := originalMethod newFullProbedMethod.		probedMethod notNil			ifTrue:				[self createAndAddProbesFor: aRec.				aRec replaceMethod: probedMethod.				newMethods nextPut: probedMethod.				oldMethods nextPut: originalMethod]].	oldMethods reset.	newMethods reset.	[newMethods atEnd]		whileFalse:			[PDPManager				changedMethodFrom: oldMethods next				to: newMethods next				by: nil]]</body><body package="Debugger-Probes" selector="initializeLabelStream">initializeLabelStream	labelStream := WriteStream on: (String new: 200).</body><body package="Debugger-Probes" selector="initializeLabelstring">initializeLabelstring	self subclassResponsibility</body><body package="Debugger-Probes" selector="initializeLabelstringToIvar">initializeLabelstringToIvar	templateProbe labelString: ((#x1sinClass2s &lt;&lt; #pdp &gt;&gt; '&lt;1s&gt;in class &lt;2s&gt;')			expandMacrosWith: leadString			with: classUnderTest shortName).</body><body package="Debugger-Probes" selector="initializeStartingScope">initializeStartingScope	startingScope := NameScope forClass: classUnderTest</body><body package="Debugger-Probes" selector="initializeTemplateTestMethod">initializeTemplateTestMethod	useConditionalProbe		ifTrue: [templateProbe setNoAction]		ifFalse: [templateProbe setAction].</body><body package="Debugger-Probes" selector="openEditor">openEditor	| topView |	topView := templateProbe createEditorOn: nil class: classUnderTest.	topView model closeAction: self finishBlock.	topView open.</body><body package="Debugger-Probes" selector="openEditor1">openEditor1	useConditionalProbe		ifTrue: [self openEditor]		ifFalse: [self finishBlock value].</body><body package="Debugger-Probes" selector="openEditor2">openEditor2	| topView |	useConditionalProbe		ifTrue:			[topView := templateProbe createDisplayEditorOn: nil class: classUnderTest.			topView model closeAction: self finishBlock.			topView open]		ifFalse:			[selectWindowParams				ifTrue: [templateProbe openWindowParamSelector].			templateProbe forClass: classUnderTest.			templateProbe finishSetup.			self finishBlock value].</body><body package="Debugger-Probes" selector="reportStringFor:">reportStringFor: aType	^self class reportStringFor: aType</body></methods><methods><class-id>CraftedSmalltalk.PDPInstrumenter</class-id> <category>expression watch</category><body package="Debugger-Probes" selector="createExpWatchLeadString">createExpWatchLeadString	self subclassResponsibility</body><body package="Debugger-Probes" selector="initializeExpressionWatchProbeClass">initializeExpressionWatchProbeClass	probeClass := DisplayActionProbe.</body><body package="Debugger-Probes" selector="initializeExpWatchFinishSelector">initializeExpWatchFinishSelector	probeCompletionSelector := #doNothing</body><body package="Debugger-Probes" selector="instrumentExpressionWatch">instrumentExpressionWatch	self initializeExpressionWatchProbeClass.	self initializeExpWatchFinishSelector.	self createExpWatchLeadString.	self createTemplateProbe.	self initializeLabelstring.	self createExpression.	self openEditor.</body></methods><methods><class-id>CraftedSmalltalk.PDPInstrumenter</class-id> <category>simple watch</category><body package="Debugger-Probes" selector="createSimpleWatchTemplateProbe">createSimpleWatchTemplateProbe	self subclassResponsibility</body><body package="Debugger-Probes" selector="initializeSimpleWatchFinishSelector">initializeSimpleWatchFinishSelector	probeCompletionSelector := #doNothing</body><body package="Debugger-Probes" selector="initializeSimpleWatchProbeClass">initializeSimpleWatchProbeClass	probeClass := DisplayTOSProbe.</body><body package="Debugger-Probes" selector="instrumentSimpleWatch">instrumentSimpleWatch	self initializeSimpleWatchProbeClass.	self initializeSimpleWatchFinishSelector.	self createIvarLeadString.	self createSimpleWatchTemplateProbe.	self initializeLabelstringToIvar.	self openEditor2</body></methods><methods><class-id>CraftedSmalltalk.PDPInstrumenter</class-id> <category>smart watch</category><body package="Debugger-Probes" selector="createSmartWatchLeadString">createSmartWatchLeadString	self subclassResponsibility</body><body package="Debugger-Probes" selector="initializeSmartWatchFinishSelector">initializeSmartWatchFinishSelector	probeCompletionSelector := #createIndiviualProbeSmartExpression</body><body package="Debugger-Probes" selector="initializeSmartWatchProbeClass">initializeSmartWatchProbeClass	probeClass := DisplayActionProbe.</body><body package="Debugger-Probes" selector="instrumentSmartWatch">instrumentSmartWatch	self initializeSmartWatchProbeClass.	self initializeSmartWatchFinishSelector.	self createSmartWatchLeadString.	self createTemplateProbe.	self initializeLabelstring.	self openEditor2</body></methods><methods><class-id>CraftedSmalltalk.PDPInstrumenter</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="initialize">initialize	self initializeIvar.</body><body package="Debugger-Probes" selector="initializeIvar">initializeIvar	iVarName := (#SelectVariable &lt;&lt; #pdp &gt;&gt; 'Select Variable') asString.	iVarIndex := 0.</body></methods><methods><class-id>CraftedSmalltalk.PDPInstrumenter</class-id> <category>breakpoints</category><body package="Debugger-Probes" selector="initializeBreakpointFinishSelector">initializeBreakpointFinishSelector	probeCompletionSelector := #createIndividualProbeLabel</body><body package="Debugger-Probes" selector="initializeBreakpointLeadString">initializeBreakpointLeadString	self subclassResponsibility</body><body package="Debugger-Probes" selector="initializeBreakpointProbeClass">initializeBreakpointProbeClass	probeClass := CodeProbe.</body><body package="Debugger-Probes" selector="instrumentBreakpoint">instrumentBreakpoint	self initializeBreakpointProbeClass.	self initializeBreakpointFinishSelector.	self initializeBreakpointLeadString.	self createTemplateProbe.	self openEditor1</body></methods><methods><class-id>CraftedSmalltalk.PDPInstrumenter</class-id> <category>N simple watches</category><body package="Debugger-Probes" selector="initializeNSimpleWatchesFinishSelector">initializeNSimpleWatchesFinishSelector	probeCompletionSelector := #createIndividualProbeLabel</body><body package="Debugger-Probes" selector="initializeNSimpleWatchesProbeClass">initializeNSimpleWatchesProbeClass	probeClass := DisplayTOSProbe.</body><body package="Debugger-Probes" selector="instrumentNSimpleWatches">instrumentNSimpleWatches	self initializeNSimpleWatchesProbeClass.	self initializeNSimpleWatchesFinishSelector.	self createIvarLeadString.	self createTemplateProbe.	self openEditor1</body></methods><methods><class-id>CraftedSmalltalk.PDPInstrumenter class</class-id> <category>instance creation</category><body package="Debugger-Probes" selector="new">new	^super new initialize"Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.PDPInstrumenter class</class-id> <category>reporting</category><body package="Debugger-Probes" selector="reportStringFor:">reportStringFor: aType	^reportStrings at: aType"Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.DisplayProbe</class-id> <category>editor creation</category><body package="Debugger-Probes" selector="createDisplayEditorOn:class:">createDisplayEditorOn: probedMethod class: probedClass		^(DisplayProbeEditor on: self in: probedMethod class: probedClass) createEditor</body><body package="Debugger-Probes" selector="createEditorOn:class:">createEditorOn: probedMethod class: probedClass	self forClass: probedClass.	^self createDisplayEditorOn: probedMethod class: probedClass</body><body package="Debugger-Probes" selector="makeConditional:replacing:with:">makeConditional: probeSpec replacing: unprobedMethod with: probedMethod	probeSpec isConditional		ifTrue:			[self setNoAction.			self finishSetup.]		ifFalse:			[self setAction.			probeSpec selectWindowParams				ifTrue: [self openWindowParamSelector].			self finishSetup.			unprobedMethod mclass addSelector: probedMethod selector withMethod: probedMethod.			^PDPManager				changedMethodFrom: unprobedMethod				to: probedMethod				by: nil].	self openEditorOn: probedMethod andReplace: unprobedMethod</body><body package="Debugger-Probes" selector="openWindowParamSelector">openWindowParamSelector	^(DisplayProbeEditor on: self in: nil class: nil) openWindowParamSelector</body></methods><methods><class-id>CraftedSmalltalk.DisplayProbe</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="finishSetup">finishSetup	super finishSetup.	self setLabel</body><body package="Debugger-Probes" selector="initialize">initialize	super initialize.	windowID := ''.</body><body package="Debugger-Probes" selector="setLabel">setLabel	(PDPManager getWatchWindow: windowID for: self ) label: self labelString</body><body package="Debugger-Probes" selector="updateMiscFromProbe:">updateMiscFromProbe: aProbe	super updateMiscFromProbe: aProbe.	windowID := aProbe windowID.</body></methods><methods><class-id>CraftedSmalltalk.DisplayProbe</class-id> <category>saving-loading</category><body package="Debugger-Probes" selector="loadFrom:">loadFrom: aStream	super loadFrom: aStream.	self loadWindowIDFrom: aStream.</body><body package="Debugger-Probes" selector="loadWindowIDFrom:">loadWindowIDFrom: aStream	| fieldName |	fieldName := aStream upTo: Character space.	fieldName = 'WindowID:'		ifFalse:			[^self unknowLoadField: fieldName on: aStream expected: 'WindowID:'].	windowID := Object evaluatorClass evaluate: (aStream upTo: Character cr).</body><body package="Debugger-Probes" selector="saveOn:">saveOn: aStream	super saveOn: aStream.	self saveWindowIDOn: aStream.</body><body package="Debugger-Probes" selector="saveWindowIDOn:">saveWindowIDOn: aStream	aStream nextPutAll: 'WindowID: '.	windowID printOn: aStream.	aStream cr.</body></methods><methods><class-id>CraftedSmalltalk.DisplayProbe</class-id> <category>accessing</category><body package="Debugger-Probes" selector="windowID">windowID	^windowID</body><body package="Debugger-Probes" selector="windowID:">windowID: anObject	windowID := anObject.</body></methods><methods><class-id>CraftedSmalltalk.CodeProbeEditor</class-id> <category>actions</category><body package="Debugger-Probes" selector="accept">accept	self install.	self closeRequest</body><body package="Debugger-Probes" selector="cancel">cancel	self closeRequest.</body></methods><methods><class-id>CraftedSmalltalk.CodeProbeEditor</class-id> <category>accessing</category><body package="Debugger-Probes" selector="closeAction:">closeAction: aBlock	closeAction := aBlock</body><body package="Debugger-Probes" selector="object:">object: aProbe	originalProbe := aProbe.	^workingCopyProbe := aProbe workingCopy.</body><body package="Debugger-Probes" selector="testEditor">testEditor	testEditor == nil		ifFalse: [^testEditor].	testEditor := ProbeTestExpressionEditor new				probe: workingCopyProbe				on: probedMethod				class: probedClass.	^testEditor</body></methods><methods><class-id>CraftedSmalltalk.CodeProbeEditor</class-id> <category>interface opening</category><body package="Debugger-Probes" selector="createEditor">createEditor	^self createEditorOn: #testEditorSpec</body><body package="Debugger-Probes" selector="createEditorOn:">createEditorOn: aSpec	^(self allButOpenInterface: aSpec) window</body><body package="Debugger-Probes" selector="createTestEditor">createTestEditor	^(self allButOpenInterface: #testEditorSpec) window</body><body package="Debugger-Probes" selector="postBuildWith:">postBuildWith: aBuilder	aBuilder window label: workingCopyProbe editorLabelString</body></methods><methods><class-id>CraftedSmalltalk.CodeProbeEditor</class-id> <category>private</category><body package="Debugger-Probes" selector="install">install	originalProbe updateFromWorkingCopy: workingCopyProbe.	originalProbe finishSetup.	closeAction value</body></methods><methods><class-id>CraftedSmalltalk.CodeProbeEditor</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="on:in:class:">on: aProbe in: aMethod class: aClass	self object: aProbe.	probedMethod := aMethod.	probedClass := aClass</body></methods><methods><class-id>CraftedSmalltalk.CodeProbeEditor class</class-id> <category>instance creation</category><body package="Debugger-Probes" selector="on:in:class:">on: aProbe in: aMethod class: aClass	^self new on: aProbe in: aMethod class: aClass"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.RawRemoteVariable</class-id> <category>accessing</category><body package="Debugger-Probes" selector="debuggerIndex">debuggerIndex	^slot value debuggerIndex</body><body package="Debugger-Probes" selector="nesting">nesting	^slot value nesting</body></methods><methods><class-id>CraftedSmalltalk.RawRemoteVariable</class-id> <category>private</category><body package="Debugger-Probes" selector="doItContextVar">doItContextVar	^VariableNode new name: 'DOITCONTEXT'</body></methods><methods><class-id>CraftedSmalltalk.RawRemoteVariable</class-id> <category>code generation</category><body package="Debugger-Probes" selector="emitLoad:from:">emitLoad: codeStream from: var	| builder node |	builder := ProgramNodeBuilder new.	node := builder		newMessageReceiver: self doItContextVar		selector: #getTempVar:		arguments: (Array with: (builder newLiteralValue: slot value)).	node sourcePosition: var sourcePosition.	node emitValue: codeStream</body><body package="Debugger-Probes" selector="emitStore:value:from:">emitStore: codeStream value: value from: assignment 	| builder node |	builder := ProgramNodeBuilder new.	node := builder				newMessageReceiver: self doItContextVar				selector: #put:intoTempVar:				arguments: (Array						with: value						with: (builder newLiteralValue: slot value)).	node sourcePosition: assignment sourcePosition.	^node emitValue: codeStream</body><body package="Debugger-Probes" selector="emitStorePop:value:from:">emitStorePop: codeStream value: value from: assignment	| builder node |	builder := ProgramNodeBuilder new.	node := builder				newMessageReceiver: self doItContextVar				selector: #put:intoTempVar:				arguments: (Array						with: value						with: (builder newLiteralValue: slot value)).	node sourcePosition: assignment sourcePosition.	^node emitEffect: codeStream</body></methods><methods><class-id>CraftedSmalltalk.RawRemoteVariable</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="slot:">slot: aSlot	slot := aSlot.</body></methods><methods><class-id>CraftedSmalltalk.DisplayProbeEditor</class-id> <category>interface opening</category><body package="Debugger-Probes" selector="createEditor">createEditor	^self createEditorOn: #displayEditorSpec</body><body package="Debugger-Probes" selector="hookUpWindowParameters">hookUpWindowParameters	self hookUpWindowParametersTo: builder</body><body package="Debugger-Probes" selector="hookUpWindowParametersTo:">hookUpWindowParametersTo: aBuilder	| idHolder |	idHolder := ValueHolder with: workingCopyProbe windowID.	aBuilder aspectAt: #windowID put: idHolder.	aBuilder		aspectAt: #openWatchWindow		put: [(aBuilder componentAt: #idEntry) widget controller accept.			idHolder value isEmpty				ifTrue: [Dialog warn: (#ValidWindowIDRequired &lt;&lt; #pdp &gt;&gt; 'A valid window ID must be first entered.')]				ifFalse:					[workingCopyProbe setLabel.					PDPManager openWatchWindow: workingCopyProbe windowID for: workingCopyProbe]].	idHolder		onChangeSend: #value		to: [workingCopyProbe windowID: idHolder value string asSymbol].	aBuilder		aspectAt: #selectID		put: [|result|			(result := self selectWindowID) isNil				ifFalse: [idHolder value: result]].	aBuilder		aspectAt: #changeLabel		put: [self openLabelEditor].</body><body package="Debugger-Probes" selector="invokePostOpen">invokePostOpen</body><body package="Debugger-Probes" selector="openWindowParamSelector">openWindowParamSelector	| dialog oldGuess |	dialog := SimpleDialog new.	dialog builder source: self.	self hookUpWindowParametersTo: dialog builder.	oldGuess := SimpleDialog classPool at: #GuessParentWindow.	SimpleDialog guessParentWindow: false.	dialog allButOpenFrom: (UISpecification from: self class windowParmOpenSpec).	SimpleDialog guessParentWindow: oldGuess.	dialog builder openDialog.	dialog accept value		ifTrue: [originalProbe updateFromWorkingCopy: workingCopyProbe]</body><body package="Debugger-Probes" selector="preBuildWith:">preBuildWith: aBuilder 	"This message is sent by the builder prior to beginning construction 	of either a SubCanvas or a complete window."	self hookUpWindowParameters</body></methods><methods><class-id>CraftedSmalltalk.DisplayProbeEditor</class-id> <category>actions</category><body package="Debugger-Probes" selector="openLabelEditor">openLabelEditor	| label |	label := Dialog request: (#EnterNewWindowLabel &lt;&lt; #pdp &gt;&gt; 'Enter new window label') initialAnswer: workingCopyProbe labelString.	label isEmpty		ifFalse: [workingCopyProbe labelString: label].</body><body package="Debugger-Probes" selector="selectWindowID">selectWindowID	| entries list |	entries := OrderedCollection new.	list := OrderedCollection new.	PDPManager windowHolders associationsDo:		[:ac|		entries add: ac key.		list add: '&lt;' , ac key printString , '&gt; ' , ac value label asString].	list isEmpty		ifTrue:			[Dialog warn: (#ThereAreNoWindowsAvailable &lt;&lt; #pdp &gt;&gt; 'There are no windows available.').			^nil].	^Dialog 		choose: (#SelectWindowIDWindow &lt;&lt; #pdp &gt;&gt; 'Select Window&lt;ID&gt;		Window') 		fromList: list		values: entries 		lines: 20		cancel: []</body></methods><methods><class-id>CraftedSmalltalk.WatchWindowView</class-id> <category>private</category><body package="Debugger-Probes" selector="changeText:">changeText: aText 	"The paragraph to be edited is changed to aText."	self repairDamage. "Since we are not using invalidation we need to be safe."	self deselect.	self editText: aText.	self selectionIndex: self text size + 1.	self selectAndScroll.	self clearInside.	self displayOn: self graphicsContext</body></methods><methods><class-id>CraftedSmalltalk.WatchWindowView</class-id> <category>updating</category><body package="Debugger-Probes" selector="updateRequest">updateRequest	"Answer regarding whether the receiver may change."	^true</body></methods><methods><class-id>CraftedSmalltalk.DisplayVariableProbe</class-id> <category>saving-loading</category><body package="Debugger-Probes" selector="loadFrom:">loadFrom: aStream	super loadFrom: aStream.	self loadVarNameFrom: aStream.</body><body package="Debugger-Probes" selector="loadVarNameFrom:">loadVarNameFrom: aStream	| fieldName |	fieldName := aStream upTo: Character space.	fieldName = 'VariableName:'		ifFalse:			[^self unknowLoadField: fieldName on: aStream expected: 'VariableName:'].	name := Object evaluatorClass evaluate: (aStream upTo: Character cr).</body><body package="Debugger-Probes" selector="saveOn:">saveOn: aStream	super saveOn: aStream.	self saveVarNameOn: aStream.</body><body package="Debugger-Probes" selector="saveVarNameOn:">saveVarNameOn: aStream	aStream nextPutAll: 'VariableName: '.	name printOn: aStream.	aStream cr.</body></methods><methods><class-id>CraftedSmalltalk.DisplayVariableProbe</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="name:index:">name: aString index: anIndex	name := aString.	index := anIndex.</body></methods><methods><class-id>CraftedSmalltalk.DisplayVariableProbe</class-id> <category>accessing</category><body package="Debugger-Probes" selector="reportString">reportString	^index = 0		ifTrue: [(#InvalidVarRefProbeRemoved &lt;&lt; #pdp &gt;&gt; 'Invalid variable reference (probe removed)') asString]		ifFalse: [super reportString]</body><body package="Debugger-Probes" selector="variableIndex">variableIndex	^index</body><body package="Debugger-Probes" selector="variableName">variableName	^name</body></methods><methods><class-id>CraftedSmalltalk.DisplayVariableProbe class</class-id> <category>instance creation</category><body package="Debugger-Probes" selector="name:index:">name: aString index: anIndex	^self new name: aString index: anIndex"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.DisplayMethodVarProbe</class-id> <category>responses</category><body package="Debugger-Probes" selector="actOn:">actOn: aContext 	(self test: aContext)		ifTrue:			[PDPManager				display: (aContext getTempVar: slot) debugString				on: windowID				for: self]</body></methods><methods><class-id>CraftedSmalltalk.DisplayMethodVarProbe</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="createLabelString">createLabelString	labelString value:		((#MethodTemp1sIn2sAt3p &lt;&lt; #pdp &gt;&gt; 'Method temp %&lt;&lt;1s&gt;%&gt; in &lt;2s&gt; at &lt;3p&gt;')			expandMacrosWith: self variableName			with: self methodString			with: self characterIndex)</body><body package="Debugger-Probes" selector="updateMiscFromProbe:">updateMiscFromProbe: aProbe	super updateMiscFromProbe: aProbe.	slot := aProbe slot.	name := aProbe variableName.</body><body package="Debugger-Probes" selector="updateTempVarForMethod:">updateTempVarForMethod: probedMethod	"Update the receiver's slot for the named temporary variable.	Return true if the tVar still exists, otherwise return false."	slot := (probedMethod scopeForProbe: self) variableAt: name from: nil.	^slot notNil</body></methods><methods><class-id>CraftedSmalltalk.DisplayMethodVarProbe</class-id> <category>accessing</category><body package="Debugger-Probes" selector="editorLabelString">editorLabelString	^((#EditTempVarWatchOn1s &lt;&lt; #pdp &gt;&gt; 'Edit Temporary Variable Watch on: %&lt;&lt;1s&gt;%&gt;')			expandMacrosWith: name)</body><body package="Debugger-Probes" selector="slot">slot	^slot</body><body package="Debugger-Probes" selector="slot:">slot: aSlot	slot := aSlot value.	name :=  aSlot key.</body></methods><methods><class-id>CraftedSmalltalk.DisplayMethodVarProbe</class-id> <category>saving-loading</category><body package="Debugger-Probes" selector="postLoadIntoMethod:">postLoadIntoMethod: probedMethod	^self updateTempVarForMethod: probedMethod</body></methods><methods><class-id>CraftedSmalltalk.DisplayMethodVarProbe class</class-id> <category>instance creation</category><body package="Debugger-Probes" selector="slot:">slot: aSlot	^self new slot: aSlot"Smalltalk Professional Debug Package Version 2.5 (c) 1999 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakCollection</class-id> <category>accessing</category><body package="Debugger-Probes" selector="add:">add: anObject	"Add anObject to the collection."	accessLock		critical:			[| index |			index := elements				indexOf: nil				replaceWith: anObject 				startingAt: 1 				stoppingAt: elements size.			index == 0				ifTrue:					[index := elements size + 1.					self basicGrow.					elements at: index put: anObject]].	^anObject</body><body package="Debugger-Probes" selector="remove:ifAbsent:">remove: anElement ifAbsent: aBlock	"Remove anElement as one of the receiver's elements.  If several of the	elements are equal to anElement, only one is removed. If no element is equal to	anElement, answer the result of evaluating anExceptionBlock.  Otherwise,	answer the argument, anElement."	accessLock		critical:			[| index |			index := elements				indexOf: anElement				replaceWith: nil				startingAt: 1 				stoppingAt: elements size.			index == 0				ifTrue: aBlock].	^anElement</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakCollection</class-id> <category>private - unprotected</category><body package="Debugger-Probes" selector="basicDo:">basicDo: aBlock	1 to: elements size do:		[:i | | d |		((d := elements at: i) == nil or: [d == elements tombstone])			ifFalse: 				[aBlock value: d]].</body><body package="Debugger-Probes" selector="basicGrow">basicGrow	self resizeElements: elements size + self growSize</body><body package="Debugger-Probes" selector="elementExpired">elementExpired	"An element has expired.  Shrink the element array if necessary."	| size |	elements nilAllCorpsesAndDo: [:a |].	size := elements size.	"Don't shrink collection below minimum size."	size &gt; self minSize		ifFalse: [^self].	"If the empty space is more than 80% of the available space then	we should consider shrinking."	self size &gt; (size * 0.2)		ifTrue: [^self].	self resizeElements: (self minSize max: (size / 2) truncated).</body><body package="Debugger-Probes" selector="resizeElements:">resizeElements: aSize	"We compress by replacing the current elements WeakArray	with a new compressed copy."	| wa i |	wa := WeakArray new: aSize.	i := 0.	self basicDo:		[:ele |		i := i + 1.		wa at: i put: ele].	elements removeDependent: self.	elements := wa.	elements addDependent: self.</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakCollection</class-id> <category>enumerating</category><body package="Debugger-Probes" selector="do:">do: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument."	accessLock critical: [self basicDo: aBlock]</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakCollection</class-id> <category>private</category><body package="Debugger-Probes" selector="growSize">growSize	"Return the size to increase the collection by when it becomes too small."	^10</body><body package="Debugger-Probes" selector="minSize">minSize	"Return the minimum collection size."	^6</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakCollection</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="initialize">initialize 	"Initialize the receiver."	self initialize: self minSize.</body><body package="Debugger-Probes" selector="initialize:">initialize: aNumber	"Initialize the receiver to provide aNumber of initially empty elements."	accessLock := RecursionLock new.	elements := WeakArray new: aNumber.	elements addDependent: self.</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakCollection</class-id> <category>updating</category><body package="Debugger-Probes" selector="update:with:from:">update: aSymbol with: aParameter from: anObject	"Handle expiration notification."	aSymbol == #ElementExpired &amp; (anObject == elements)		ifTrue: [^accessLock critical: [self elementExpired]].</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakCollection class</class-id> <category>instance creation</category><body package="Debugger-Probes" selector="new">new	"Return an instance of this class with no empty	space."	^super new initialize: 6"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="new:">new: aNumber	"Return an instance of this class with aNumber	of empty slots."	^super new initialize: aNumber"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.ProbeCharacterStyle</class-id> <category>testing</category><body package="Debugger-Probes" selector="isCharStyleCacheable">isCharStyleCacheable	^false</body></methods><methods><class-id>CraftedSmalltalk.CRC32Function class</class-id> <category>converting</category><body package="Debugger-Probes" selector="crc32Of:">crc32Of: aByteArray	^self crc32Of: aByteArray initial: 0"Smalltalk Professional Debug Package Version 2.5 (c) 1999 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="crc32Of:initial:">crc32Of: aByteArray initial: initialCRC	| crc |	crc := initialCRC.	1 to: aByteArray size do:		[:i |		crc := (CRC32Table at: ((aByteArray at: i) bitXor: (crc quo: 16r1000000)) + 1) bitXor: ((crc bitAnd: 16rffffff) * 256)].	^crc"Smalltalk Professional Debug Package Version 2.5 (c) 1999 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.CRC32Function class</class-id> <category>class initialization</category><body package="Debugger-Probes" selector="initialize">initialize	self initializeCRC32Table</body><body package="Debugger-Probes" selector="initializeCRC32Table">initializeCRC32Table	| ans |	CRC32Table := Array new: 256.	0 to: 255 do:		[:i |		ans := i * 16r1000000.		1 to: 8 do:			[:j |			ans := ans * 2.			ans &lt; 16r100000000				ifFalse: [ans := ans bitXor: 16r4c11db7.].			ans := ans bitAnd: 16rffffffff].		CRC32Table at: i + 1 put: ans]."Smalltalk Professional Debug Package Version 2.5 (c) 1999 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.ProbeClone</class-id> <category>responses</category><body package="Debugger-Probes" selector="actOn:">actOn: aContext	^parent actOn: aContext</body></methods><methods><class-id>CraftedSmalltalk.ProbeClone</class-id> <category>editor creation</category><body package="Debugger-Probes" selector="createEditorOn:">createEditorOn: probedMethod	^parent createEditorOn: probedMethod</body><body package="Debugger-Probes" selector="createEditorOn:class:">createEditorOn: probedMethod class: probedClass 	^parent createEditorOn: probedMethod class: probedClass</body><body package="Debugger-Probes" selector="modifyIn:">modifyIn: aProbedMethod	^parent modifyIn: aProbedMethod</body></methods><methods><class-id>CraftedSmalltalk.ProbeClone</class-id> <category>accessing</category><body package="Debugger-Probes" selector="emphasis">emphasis	^parent emphasis value: self</body><body package="Debugger-Probes" selector="emphasize:">emphasize: aText	^aText		emphasizeFrom: parent characterIndex		to: parent characterIndex		with: self emphasis</body></methods><methods><class-id>CraftedSmalltalk.ProbeClone</class-id> <category>testing</category><body package="Debugger-Probes" selector="isPermanent">isPermanent	^parent isPermanent</body><body package="Debugger-Probes" selector="isTemporary">isTemporary	^parent isTemporary</body></methods><methods><class-id>CraftedSmalltalk.ProbeClone</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="parent:">parent: aProbe	parent := aProbe.	probeRecord := parent probeRecord copy.</body></methods><methods><class-id>CraftedSmalltalk.ProbeClone</class-id> <category>private</category><body package="Debugger-Probes" selector="test:">test: aContext	^parent test: aContext</body></methods><methods><class-id>CraftedSmalltalk.ProbeClone class</class-id> <category>instance creation</category><body package="Debugger-Probes" selector="parent:">parent: aProbe	"Return a new instance of the receiver with aProbe as	its parent."	^self new parent: aProbe"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.PDPInstrumenterGUIModel</class-id> <category>accessing</category><body package="Debugger-Probes" selector="basicTypeModel">basicTypeModel	^basicTypeModel</body><body package="Debugger-Probes" selector="conditionalModel">conditionalModel	^conditionalModel</body><body package="Debugger-Probes" selector="ivarMenu">ivarMenu	^ivarMenu</body><body package="Debugger-Probes" selector="ivarMenuModel">ivarMenuModel	^ivarMenuModel</body><body package="Debugger-Probes" selector="listModel">listModel	^panelList</body><body package="Debugger-Probes" selector="reportModel">reportModel	^reportModel</body><body package="Debugger-Probes" selector="selectedRecords">selectedRecords	^panelList selectionIndexes collect: [:i | methods at: i].</body><body package="Debugger-Probes" selector="subclassModel">subclassModel	^subclassModel</body><body package="Debugger-Probes" selector="winParamModel">winParamModel	^winParam</body></methods><methods><class-id>CraftedSmalltalk.PDPInstrumenterGUIModel</class-id> <category>private</category><body package="Debugger-Probes" selector="buildVariableMenu">buildVariableMenu	| index menu ivarSelection |	(classUnderTest allInstVarNames includes: instrumenter iVarName)		ifFalse:			[instrumenter initializeIvar.			ivarMenuModel changed: #value].	ivarSelection := instrumenter iVarSelection.	menu := Menu		labelArray: (Array with: ivarSelection key)		lines: #(1)		values: (Array with: ivarSelection).	index := 0.	classUnderTest withAllSuperclasses reverse do:		[:cls | | clsIvarMenu ivars clsMenuItem |		ivars := cls instVarNames.		ivars isEmpty			ifFalse:				[clsIvarMenu := Menu 					labelArray: ivars					values: (ivars collect: [:var | index := index + 1. var -&gt; index]).				clsMenuItem := MenuItem labeled: cls shortName.				clsMenuItem labelText: cls shortName asText allItalic.				clsMenuItem submenu: clsIvarMenu.				menu addItem: clsMenuItem]].	ivarMenu value: menu</body></methods><methods><class-id>CraftedSmalltalk.PDPInstrumenterGUIModel</class-id> <category>operation</category><body package="Debugger-Probes" selector="checkWinParamEnablement">checkWinParamEnablement	winParamButtonW isEnabled: self isWinParamButtonValid</body><body package="Debugger-Probes" selector="finishUp">finishUp	| records |	records := self selectedRecords.	records isEmpty		ifTrue: [^self closeRequest].	instrumenter class: classUnderTest.	instrumenter useConditionalProbe: conditionalModel value;		selectWindowParams: winParam value &amp; self isWinParamButtonValid;		instrumentationRecords: records.	instrumenter instrumentationRequest: basicTypeModel value.	self closeRequest.	instrumenter initializeStartingScope.	instrumenter initializeLabelStream.	reportModel value		ifTrue: [instrumenter report: basicTypeModel value].	instrumenter performInstrumentation.</body><body package="Debugger-Probes" selector="isWinParamButtonValid">isWinParamButtonValid	^conditionalModel value not and:		[(basicTypeModel value == #instrumentSmartWatch or:			[basicTypeModel value == #instrumentSimpleWatch])]</body></methods><methods><class-id>CraftedSmalltalk.PDPInstrumenterGUIModel</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="on:">on: aClass	classUnderTest := aClass.	self openInterface.</body><body package="Debugger-Probes" selector="postBuildWith:">postBuildWith: aBuilder	| mv |	mv := (aBuilder componentAt: #ivarMenu) widget.	mv vcBlock: 		[:obj :aMenu |		mv makeTextLabelFor: obj asString asText allBold].	mv setLabel: instrumenter iVarName.	winParamButtonW := aBuilder componentAt: #winParam.	winParamButtonW isEnabled: winParam value.</body><body package="Debugger-Probes" selector="preBuildWith:">preBuildWith: aBuilder	subclassModel := ValueHolder with: true.	conditionalModel := ValueHolder with: CodeProbe defaultConditionalProbe.   "get default setting"	winParam := ValueHolder with:  CodeProbe defaultSelectWinParams.   "get default setting"	basicTypeModel := ValueHolder with: #instrumentBreakpoint.  "get default setting"	panelList := MultiSelectionInList new.	reportModel := ValueHolder with: true.	basicTypeModel onChangeSend: #checkWinParamEnablement to: self.	conditionalModel onChangeSend: #checkWinParamEnablement to: self.	subclassModel onChangeSend: #updateList to: self.	ivarMenuModel := PluggableAdaptor on: '' asValue.	ivarMenuModel		getBlock: [:m | instrumenter iVarName]		putBlock: [:m :v | 			instrumenter iVarName: v key.			instrumenter iVarIndex: v value]		updateBlock: [:m :p :a | false].	ivarMenu := nil asValue.	self buildVariableMenu.</body></methods><methods><class-id>CraftedSmalltalk.PDPInstrumenterGUIModel class</class-id> <category>instance creation</category><body package="Debugger-Probes" selector="instrumentIvarsIn:">instrumentIvarsIn: aClass	PDPIVarRefInstrumenterGUIModel on: aClass"Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="instrumentMsgRcvdIn:">instrumentMsgRcvdIn: aClass	PDPMsgRcvdInstrumenterGUIModel on: aClass"Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="instrumentMsgRcvdOnList:">instrumentMsgRcvdOnList: aColl	PDPMthdListMsgRcvdInstrumenterGUIModel on: aColl"Smalltalk Professional Debug Package Version 1.6 (c) 1998 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="on:">on: aClass	self new on: aClass"Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.PDPIVarRefInstrumenterGUIModel</class-id> <category>operation</category><body package="Debugger-Probes" selector="help">help	| msg |	msg := Text			string: (#ProbeOnIvarRefHelpText &lt;&lt; #pdp &gt;&gt; 'The "Probe on instance variable reference" panel enables a user to insert a probe where an instance variable is referenced in each selected method.  Some of the probes send the "debugString" to the object on the Top of Stack.  This object is either; the object just read from the variable, or the object to be written to the variable.  The action performed by the probe is determined by the the type selection radio buttons.  They are;	Breakpoint		Causes a breakpoint to occur at the variable reference point.	Smart watch		Records the following in the watch window; receiver''s class, method selector, character position of probe, the result of the "debugString" message being sent to the object on the Top of Stack in the watch window.  One watch window is shared by all the probes.	Simple watch		Records the result of the "debugString message being sent to the object on the Top of Stack in the watch window.  One watch window is shared by all the probes.	N Simple watches		Same as the Simple watch, except that each probe has its own watch window.	Expression watch		Records the result of a user defined expression in the watch window.  This expression is initialized to "^TopOFStack debugString".---------------------- Other controls -------------------Conditional	This check box is selected, a probe editor will open after the Done button has been pressed.  This allows the user to define an expression that will conditionally activate the probe.  Likewise, the   One should be aware that all the probes created by this panel will initially use this conditional expression.  Later, if the conditional expression of a probe is modified, only that probe will receive the change.Window parameters	This check box is used to request that a panel be opened to specify watch window parameters.Generate report	This check box will cause a workspace to be opened containing a report of what instrumentation action was requested.') asString		runs: (RunArray				runs: #(437 10 66 11 264 12 164 16 79 16 193 11 65 4 347 17 96 15 118)				values: #(nil #bold nil #bold nil #bold nil #bold nil #bold nil #bold nil #bold nil #bold nil #bold nil)).	ComposedTextView		open: msg asValue		label: (#ProbeOnIvarRefHelp &lt;&lt; #pdp &gt;&gt; 'Probe on Instance Variable Reference Help')		icon: (Icon constantNamed: #workspace)		extent: (500 @ 300).</body><body package="Debugger-Probes" selector="updateList">updateList	| classes iVarIndex |	iVarIndex := instrumenter iVarIndex.	classes := subclassModel value		ifTrue: [classUnderTest withAllSubclasses]		ifFalse: [Array with: classUnderTest].	methods := SortedCollection sortBlock: [:aa :b | aa nameString &lt; b nameString].	classes do:		[:cl |		cl methodDictionary keysAndValuesDo:			[:sel :meth | | activity |			activity := 0.			(readModel value and: [meth readsField: iVarIndex])				ifTrue: [activity := 1].			(writeModel value and: [meth writesField: iVarIndex])				ifTrue: [activity := 3 - activity].			meth isProbeable				ifFalse: [activity := 0].			activity ~= 0				ifTrue: [methods add: (MethodActionRecord											action: activity											class: cl											selector: sel)]]].	panelList list: (methods collect: [:aRecord |aRecord printString]).</body></methods><methods><class-id>CraftedSmalltalk.PDPIVarRefInstrumenterGUIModel</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="preBuildWith:">preBuildWith: aBuilder	instrumenter := PDPIVarReferenceInstrumenter new.	readModel := ValueHolder with: true.	writeModel := ValueHolder with: true.	readModel onChangeSend: #updateList to: self.	writeModel onChangeSend: #updateList to: self.	super preBuildWith: aBuilder.	ivarMenuModel onChangeSend: #updateList to: self.</body></methods><methods><class-id>CraftedSmalltalk.PDPIVarRefInstrumenterGUIModel</class-id> <category>accessing</category><body package="Debugger-Probes" selector="readModel">readModel	^readModel</body><body package="Debugger-Probes" selector="writeModel">writeModel		^writeModel</body></methods><methods><class-id>CraftedSmalltalk.PDPIVarReferenceInstrumenter</class-id> <category>private</category><body package="Debugger-Probes" selector="createAndAddProbesFor:">createAndAddProbesFor: aRec	| refs |	methodString := ((#x1sAt &lt;&lt; #pdp &gt;&gt; '&lt;1s&gt; at ')			expandMacrosWith: aRec nameString).	refs := probedMethod collectReferencesTo: iVarName.	refs do:		[:node |		node isRead			ifTrue:				[aRec isRead					ifTrue:						[probeRecord := node probeRecordAtEnd.						actionString := (#readIn &lt;&lt; #pdp &gt;&gt; 'read in ') asString]]			ifFalse:				[aRec isWrite					ifTrue:						[probeRecord := node probeRecordAtStart.						actionString := (#writeIn &lt;&lt; #pdp &gt;&gt; 'write in ') asString]].		probeRecord isNil			ifFalse:				[self createNewProbe.				self perform: probeCompletionSelector.				probeRecord := nil.]]</body><body package="Debugger-Probes" selector="createExpression">createExpression	self createTopOfStackExpression.</body><body package="Debugger-Probes" selector="createTopOfStackExpression">createTopOfStackExpression	templateProbe		compileExpression: '	^TopOFStack debugString'		inClass: classUnderTest		scope: startingScope.</body><body package="Debugger-Probes" selector="initializeLabelstring">initializeLabelstring	self initializeLabelstringToIvar.</body></methods><methods><class-id>CraftedSmalltalk.PDPIVarReferenceInstrumenter</class-id> <category>expression watch</category><body package="Debugger-Probes" selector="createExpWatchLeadString">createExpWatchLeadString	self createIvarLeadString.</body></methods><methods><class-id>CraftedSmalltalk.PDPIVarReferenceInstrumenter</class-id> <category>probe finish</category><body package="Debugger-Probes" selector="createIndividualProbeLabel">createIndividualProbeLabel	labelStream reset.	labelStream nextPutAll: leadString;		nextPutAll: actionString;		nextPutAll: methodString.	probeRecord characterIndex printOn: labelStream.	probe labelString: labelStream contents.	probe finishSetup.</body><body package="Debugger-Probes" selector="createIndiviualProbeSmartExpression">createIndiviualProbeSmartExpression" We use label Stream, because it already exists, it should be called expressionStream."	labelStream reset.	labelStream nextPutAll: '	| stream |	stream  := WriteStream on: (String new: 100).	stream nextPutAll: ''';		nextPutAll: leadString;		nextPutAll: actionString;		nextPutAll: methodString;		nextPutAll: '''.	ThisProbe characterIndex printOn: stream.	stream cr;		nextPutAll: TopOFStack debugString.	^stream contents'.	probe		compileExpression: labelStream contents		inClass: classUnderTest		scope: startingScope.</body></methods><methods><class-id>CraftedSmalltalk.PDPIVarReferenceInstrumenter</class-id> <category>simple watch</category><body package="Debugger-Probes" selector="createSimpleWatchTemplateProbe">createSimpleWatchTemplateProbe	self createTemplateProbe.</body></methods><methods><class-id>CraftedSmalltalk.PDPIVarReferenceInstrumenter</class-id> <category>smart watch</category><body package="Debugger-Probes" selector="createSmartWatchLeadString">createSmartWatchLeadString	self createIvarLeadString</body></methods><methods><class-id>CraftedSmalltalk.PDPIVarReferenceInstrumenter</class-id> <category>breakpoints</category><body package="Debugger-Probes" selector="initializeBreakpointLeadString">initializeBreakpointLeadString	leadString := ((#BreakOn1s &lt;&lt; #pdp &gt;&gt; 'Break on - %&lt;&lt;1s&gt;%&gt; ')			expandMacrosWith: iVarName).</body></methods><methods><class-id>CraftedSmalltalk.PDPIVarReferenceInstrumenter</class-id> <category>reporting</category><body package="Debugger-Probes" selector="report:">report: basicType	| reportStream |	reportStream := WriteStream on: (String new: 200).	reportStream nextPutAll: (self reportStringFor: basicType);		nextPutAll: (#OnInstanceVariable &lt;&lt; #pdp &gt;&gt; ' on instance variable &lt;')  asString;		nextPutAll: iVarName;		nextPutAll: (#ReferencesForC &lt;&lt; #pdp &gt;&gt; '&gt; references for:')  asString; cr.	instrumentationRecords do: [:rec | reportStream cr; nextPutAll: rec printString].	ComposedTextView		open: reportStream contents asText asValue		label: (#ProbeOnIVarRefsReport &lt;&lt; #pdp &gt;&gt; 'Probe on Instance Variable References Report')		icon: (Icon constantNamed: #workspace)		extent: (500 @ 300).</body></methods><methods><class-id>CraftedSmalltalk.PDPIVarReferenceInstrumenter class</class-id> <category>class initialization</category><body package="Debugger-Probes" selector="initialize">initialize	reportStrings := Dictionary new.	reportStrings at: #instrumentBreakpoint put: (#Breakpoint &lt;&lt; #pdp &gt;&gt; 'Breakpoint') asString.	reportStrings at: #instrumentSmartWatch put: (#SmartWatchpoint &lt;&lt; #pdp &gt;&gt; 'Smart watchpoint') asString.	reportStrings at: #instrumentSimpleWatch put: (#SimpleWatchpoint &lt;&lt; #pdp &gt;&gt; 'Simple watchpoint') asString.	reportStrings at: #instrumentNSimpleWatches put: (#NSimpleWatchpoints &lt;&lt; #pdp &gt;&gt; 'N Simple watchpoints') asString.	reportStrings at: #instrumentExpressionWatch put: (#ExpressionWatchpoint &lt;&lt; #pdp &gt;&gt; 'Expression watchpoint') asString."Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>probe management</category><body package="Debugger-Probes" selector="addProbe:">addProbe: aProbe	"Add aProbe to the receiver."	(self blockAt: aProbe blockMethodIndex) basicAddProbe: aProbe</body><body package="Debugger-Probes" selector="loadProbesFrom:">loadProbesFrom: aStream	| fieldName numVars aProbe probesInError |	fieldName := aStream upTo: Character space.	fieldName = 'Probes:'		ifFalse:			[^AbstractCodeProbe unknowLoadField: fieldName on: aStream expected: 'Probes:'].	probesInError := OrderedCollection new.	numVars := Number readFrom: aStream.	aStream next.	"swallow cr"	[numVars = 0]		whileFalse:			[aProbe := CodeProbe createFrom: aStream.			(aProbe reinsertAfterLoadInto: self)				ifFalse: [probesInError add: aProbe].			numVars := numVars - 1].	^probesInError</body><body package="Debugger-Probes" selector="recompileProbes">recompileProbes	| probesInError |	probesInError := OrderedCollection new.	self probesDo:		[:aProbe |		(aProbe recompileExpressionsUsingProbedMethod: self)			ifFalse: [probesInError add: aProbe]].	^probesInError</body><body package="Debugger-Probes" selector="reinsertProbe:">reinsertProbe: aProbe	"This method is for reinserting probes into a method after loading from a file.	  DO NOT use when changing the method source code!	Returns false if there is a problem with the probe, true otherwise."	^(aProbe updateInstanceVarIndexForMethod: self) and:		[aProbe reinsertInto: self.		aProbe recompileExpressionsUsingProbedMethod: self]</body><body package="Debugger-Probes" selector="reinsertProbesFrom:">reinsertProbesFrom: origProbedMethod	"This method is for reinserting probes into a method that has been recompiled	because of a change in class definition.  DO NOT use when changing the method	source code!"	| probesInError |	probesInError := OrderedCollection new.	origProbedMethod probesDo:		[:aProbe |		(self reinsertProbe: aProbe)			ifFalse: [probesInError add: aProbe]].	^probesInError</body><body package="Debugger-Probes" selector="removeProbe:">removeProbe: targetProbe	"Remove aProbe from the receiver."	(self blockAt: targetProbe blockMethodIndex) basicRemoveProbe: targetProbe.</body><body package="Debugger-Probes" selector="saveOn:">saveOn: aStream	| permProbes |	permProbes := OrderedCollection new.	self allProbesDo: [:aProbe | aProbe isPermanent ifTrue: [permProbes add: aProbe]].	permProbes isEmpty		ifTrue: [^self].	self printNameOn: aStream inClass: mclass.	aStream cr;		nextPutAll: 'CRC: '.	(CRC32Function crc32Of: (self getSource string asByteArray)) printOn: aStream.	aStream cr.	aStream nextPutAll: 'Probes: '.	permProbes size printOn: aStream.	aStream cr.	permProbes do: [:aProbe | aProbe saveOn: aStream].</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>private - probes</category><body package="Debugger-Probes" selector="addProbeToLiterals:">addProbeToLiterals: aProbe	| probeIndex |	probeIndex := self size.	[probeIndex &gt;= probeStart and: [(self basicAt: probeIndex) == nil]]		whileTrue: [probeIndex := probeIndex -1].	probeIndex = self size		ifTrue: [self grow].	probeIndex := probeIndex + 1.	self basicAt: probeIndex put: aProbe.	^probeIndex</body><body package="Debugger-Probes" selector="adjustJumps:in:at:by:atTop:probeRecord:ignore:">adjustJumps: aJumpTable in: newBytes at: pc by: delta atTop: topFlag probeRecord: probeRecord ignore: activeRecord	| amount map insertBefore changes charInsertPt |	changes := OrderedCollection with: (Array with: pc with: delta with: topFlag).	map := self sourceMap.	insertBefore := probeRecord atEnd | activeRecord notNil.	topFlag		ifTrue:			[charInsertPt := probeRecord characterIndex.			map do: [:ac | ac forPC: pc andCharacterIdx: charInsertPt adjust: delta].			self probesDo:				[:aProbe | | pr |				pr := aProbe probeRecord.				pr == probeRecord					ifFalse: [pr fixPCFor: pc amount: delta]]]		ifFalse:			[map do: [:ac | ac for: pc adjust: delta].			self probesDo: [:aProbe | aProbe probeRecord fixPCFor: pc amount: delta]].	aJumpTable do:		[:jumpRcd |		activeRecord == jumpRcd			ifFalse:				[jumpRcd location &lt; pc					ifTrue:						[(jumpRcd target &gt; pc or:							[insertBefore and:								[jumpRcd target = pc and:									[(map at: probeRecord mapIndex) pcRangeExcludes: jumpRcd location]]])							ifTrue: [jumpRcd newDelta: jumpRcd newDelta + delta]]					ifFalse:						[pc &gt; jumpRcd target							ifTrue: [jumpRcd newDelta: jumpRcd newDelta - delta].						jumpRcd moveBy: delta.]]].	aJumpTable do:		[:jumpRcd |		jumpRcd shouldMakeLong			ifTrue:				[amount := jumpRcd fixJumpIn: newBytes.				changes addAll: (self					adjustJumps: aJumpTable					in: newBytes					at: jumpRcd location + 1					by: amount					atTop: false					probeRecord: probeRecord					ignore: jumpRcd)]].		"If we are not the top send in this recursive chain, then exit."	topFlag		ifFalse: [^changes].	"At this point any necessary op code changes have been made and	new deltas caluculated.  Now change the actual byte code jump offsets."	aJumpTable do:		[:jumpRcd |		jumpRcd isChanged			ifTrue: [jumpRcd adjustDeltaIn: newBytes]].	^changes</body><body package="Debugger-Probes" selector="basicAddProbe:">basicAddProbe: aProbe	"Add aProbe to the receiver."	| probeIndex |	probeIndex := self addProbeToLiterals: aProbe.	(self insertProbeBytecodesFor: probeIndex)		ifTrue: [^self].	"A method branch limit was exceeded."	BranchLimit raiseSignal.</body><body package="Debugger-Probes" selector="basicHasAnyProbes">basicHasAnyProbes	^(self basicAt: probeStart) notNil</body><body package="Debugger-Probes" selector="basicIncludesProbe:">basicIncludesProbe: targetProbe	| probeIndex aProbe |	probeIndex := probeStart.	[aProbe := self basicAt: probeIndex.	targetProbe = aProbe or: [aProbe == nil or: [probeIndex = self size]]]		whileFalse: [probeIndex := probeIndex + 1].	^aProbe ~~ nil</body><body package="Debugger-Probes" selector="basicRemoveProbe:">basicRemoveProbe: aProbe	"Remove aProbe from the receiver."	| probeIndex someProbe nextIndex oldByteArray probeRecord pc newBytes jumpTable |	oldByteArray := self bytes.	probeIndex := probeStart.	[someProbe := self basicAt: probeIndex.	aProbe = someProbe]		whileFalse: [probeIndex := probeIndex + 1].	probeRecord := (self basicAt: probeIndex) probeRecord.	[nextIndex := probeIndex + 1.	self size &gt;= nextIndex and:		[someProbe := self basicAt: nextIndex.		someProbe ~~ nil]]		whileTrue:			["Change code reference to probe."			oldByteArray at: someProbe insertionPC + 1 put: probeIndex - 1.			"Move probe down one position."			self basicAt: probeIndex put: someProbe.			probeIndex := nextIndex].	self basicAt: probeIndex put: nil.  "Make position empty."	pc := probeRecord insertionPC.	newBytes := ByteArray new: oldByteArray size - 7.	newBytes replaceFrom: 1 to: pc - 1 with: oldByteArray startingAt: 1.	newBytes replaceFrom: pc to: newBytes size with: oldByteArray startingAt: pc + 7.	jumpTable := self jumpTable.	self		adjustJumps: jumpTable		in: newBytes		at: pc		by: -7		atTop: true		probeRecord: probeRecord		ignore: nil.	bytes := (ByteArray new: newBytes size + 4) replaceFrom: 1 to: 4 with: bytes startingAt: 1.	bytes replaceFrom: 5 to: bytes size with: newBytes startingAt: 1.</body><body package="Debugger-Probes" selector="insertProbeBytecodesFor:">insertProbeBytecodesFor: probeIndex	| newBytes jumpTable probeRecord pc changes map |	probeRecord := (self basicAt: probeIndex) probeRecord.	pc := probeRecord insertionPCFor: self.	newBytes := OrderedCollection withAll: self bytes.	newBytes add: OpXLoadLiteral beforeIndex: pc;		add: probeIndex - 1 beforeIndex: pc + 1;		"index of aProbe"		add: OpLoadThisContext beforeIndex: pc + 2;		add: OpXXSend beforeIndex: pc + 3;		add: 1 beforeIndex: pc + 4;		add: probeStart - 2 beforeIndex: pc + 5;		add: OpPop beforeIndex: pc + 6.	"remove object returned from probe"	jumpTable := self jumpTable.	changes := self		adjustJumps: jumpTable		in: newBytes		at: pc		by: 7		atTop: true		probeRecord: probeRecord		ignore: nil.	(jumpTable detect: [:rcd | rcd isLongJumpTooLong] ifNone: [nil]) == nil		ifTrue: 			[bytes := (ByteArray new: newBytes size + 4) replaceFrom: 1 to: 4 with: bytes startingAt: 1.			bytes replaceFrom: 5 to: bytes size with: newBytes startingAt: 1.			^true].	"An excessively long branch was detected.  Must back out changes to method."	self basicAt: probeIndex put: nil.	map := self sourceMap.	changes reverseDo:		[:changeArray | | cpc delta atTop |		cpc := changeArray at: 1.		delta := (changeArray at: 2) negated.		atTop := changeArray at: 2.		map do: [:ac | ac for: cpc adjust: delta].		self probesDo: [:aProbe | aProbe probeRecord fixPCFor: cpc amount: delta doEqualPC: atTop]].	auxInfo := nil.	^false</body><body package="Debugger-Probes" selector="probeSize">probeSize	| count |	count := 0.	probeStart to: self basicSize do: 		[:i | 		(self basicAt: i) isNil			ifTrue: [^count].		count := count + 1].	^count</body><body package="Debugger-Probes" selector="totalProbes">totalProbes	| total |	total := 0.	self withAllProbedBlockMethodsDo: [:aBlock | total := aBlock probeSize + total].	^total</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>accessing - probes</category><body package="Debugger-Probes" selector="allProbesDo:">allProbesDo: aBlock	self withAllProbedBlockMethodsDo: [:pBlock | pBlock probesDo: aBlock]</body><body package="Debugger-Probes" selector="includesProbe:">includesProbe: targetProbe	"Return true if the receiver contains targetProbe."	^(self blockAt: targetProbe blockMethodIndex) basicIncludesProbe: targetProbe.</body><body package="Debugger-Probes" selector="jumpRecordFor:blkIndex:">jumpRecordFor: selectionRange blkIndex: blkIndex	"Get the probe record corresponding to selectionRange."	^methodHolder node jumpRecordFor: selectionRange blkIndex: blkIndex</body><body package="Debugger-Probes" selector="probeRecordFor:">probeRecordFor: selectionRange	"Get the probe record corresponding to selectionRange."	^methodHolder node probeRecordFor: selectionRange</body><body package="Debugger-Probes" selector="probesDo:">probesDo: aBlock 	probeStart to: self size do: 		[:i | 		| aProbe |		aProbe := self basicAt: i.		aProbe == nil			ifTrue: [^self].		aBlock value: aProbe]</body><body package="Debugger-Probes" selector="scopeForProbe:">scopeForProbe: aProbe	^self variableMapAt: aProbe blockMethodIndex</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>private - info</category><body package="Debugger-Probes" selector="auxInfo">auxInfo	auxInfo isNil		ifTrue: [auxInfo := (AuxCodeInfoExtractor new method: self) run].	^auxInfo</body><body package="Debugger-Probes" selector="jumpTable">jumpTable	^self auxInfo jumpTable</body><body package="Debugger-Probes" selector="maxDepth">maxDepth	^self auxInfo maxDepth</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>accessing</category><body package="Debugger-Probes" selector="collectReferencesTo:">collectReferencesTo: variable	^methodHolder node collectReferencesTo: variable</body><body package="Debugger-Probes" selector="installedMethod">installedMethod	^mclass compiledMethodAt: self selector ifAbsent: [nil].</body><body package="Debugger-Probes" selector="methodHolder">methodHolder	^methodHolder</body><body package="Debugger-Probes" selector="newFullProbedMethod">newFullProbedMethod	^self dcopy</body><body package="Debugger-Probes" selector="newNormalProbedMethod">newNormalProbedMethod	^self dcopy</body><body package="Debugger-Probes" selector="newTempFullProbedMethod">newTempFullProbedMethod	^self newTempProbedMethod</body><body package="Debugger-Probes" selector="newTempProbedMethod">newTempProbedMethod	| nuMethod |	AbstractCodeProbe setClone.	nuMethod := self dcopy.	nuMethod originalMethod: self.	AbstractCodeProbe setCopy.	^nuMethod</body><body package="Debugger-Probes" selector="originalMethod">originalMethod	^original originalMethod</body><body package="Debugger-Probes" selector="originalMethod:">originalMethod: aMethod	original := aMethod</body><body package="Debugger-Probes" selector="permanentMethod">permanentMethod	^original</body><body package="Debugger-Probes" selector="selector">selector	^methodHolder selector</body><body package="Debugger-Probes" selector="sourceInfoIfCached">sourceInfoIfCached	^methodHolder</body><body package="Debugger-Probes" selector="sourceMap">sourceMap	^methodHolder sourceMap at: 1</body><body package="Debugger-Probes" selector="sourceMapAt:">sourceMapAt: index	^methodHolder sourceMap at: index</body><body package="Debugger-Probes" selector="variableMap">variableMap	^methodHolder variableMap at: 1</body><body package="Debugger-Probes" selector="variableMapAt:">variableMapAt: index	^methodHolder variableMap at: index</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>copying</category><body package="Debugger-Probes" selector="copy">copy	^self class registerMethod: super copy.</body><body package="Debugger-Probes" selector="dcopy">dcopy	^self class registerMethod: super dcopy.</body><body package="Debugger-Probes" selector="postDcopy">postDcopy	methodHolder := methodHolder basicDcopy.	auxInfo := nil.	1 to: self basicSize do: [ :i | self basicAt: i put: (self basicAt: i) basicMethodDcopy]</body><body package="Debugger-Probes" selector="shallowCopy">shallowCopy	^self class registerMethod: super shallowCopy.</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="copyFrom:">copyFrom: oldSelf	1 to: oldSelf basicSize do:		[ :i | self basicAt: i put: (oldSelf basicAt: i)].	1 to: self class instSize do:		[ :i | self instVarAt: i put: (oldSelf instVarAt: i)].</body><body package="Debugger-Probes" selector="from:full:">from: aCompiledMethod full: fullFlag	| adjustedMethod compiler |	original := aCompiledMethod.	mclass := aCompiledMethod mclass.	sourceCode := aCompiledMethod sourcePointer.	(mclass compilerClass == Compiler		or: [(mclass compilerClass respondsTo: #treatsAsSimpleSmalltalk:)			and: [mclass compilerClass treatsAsSimpleSmalltalk: self getSource]])		ifFalse: [^self error: (#CannotInsertIncompatibleCompiler &lt;&lt; #pdp &gt;&gt; 'Cannot insert probe, selected class uses incompatible compiler.')].	compiler := ProbeExprCompiler new.	fullFlag		ifTrue: [compiler setCompileForProbes].	methodHolder := compiler			parse: aCompiledMethod getSource			in: mclass			environment: aCompiledMethod environment			allowReceiver: true			noPattern: false			notifying: nil.	adjustedMethod := methodHolder generate.	probeStart := adjustedMethod numLiterals + 2.	self at: probeStart - 1 put: #actOn:.	1 to: adjustedMethod numLiterals do: 		[:i | | lit cl bm |		lit := adjustedMethod literalAt: i.		cl := lit class.		cl == CompiledBlock			ifTrue: 				[self literalAt: i put: (lit := ProbedCompiledBlock from: lit).				lit outerMethod: self]			ifFalse:				[cl == BlockClosure					ifTrue: 						[self literalAt: i put: (lit := lit copy).						bm := ProbedCompiledBlock from: lit method.						lit method: bm.						bm outerMethod: self]					ifFalse: [self literalAt: i put: lit]]].	self initializeBytes.	^self</body><body package="Debugger-Probes" selector="grow">grow	| newSelf |	newSelf := self class new: self basicSize + 7.	newSelf copyFrom: self.	newSelf become: self</body><body package="Debugger-Probes" selector="install">install	self noNotifyInstall.	PDPManager		changedMethodFrom: original		to: self		by: nil.</body><body package="Debugger-Probes" selector="noNotifyInstall">noNotifyInstall	mclass addSelector: self selector withMethod: self.</body><body package="Debugger-Probes" selector="revert">revert	"Restore the original method. Returns true if successful, otherwise false."	self installedMethod == self		ifFalse: [^false].	mclass		addSelector: self selector		withMethod: original.	PDPManager		changedMethodFrom: original		to: self		by: nil.	^true</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>testing</category><body package="Debugger-Probes" selector="hasAnyProbes">hasAnyProbes	self withAllProbedBlockMethodsDo: [:aBlock | aBlock basicHasAnyProbes ifTrue: [^true]].	^false</body><body package="Debugger-Probes" selector="isInSystem">isInSystem	^mclass notNil and: [self installedMethod == self]</body><body package="Debugger-Probes" selector="isPartiallyBound">isPartiallyBound	^self installedMethod originalMethod == self originalMethod</body><body package="Debugger-Probes" selector="isProbed">isProbed	^true</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>source code management</category><body package="Debugger-Probes" selector="highlightProbesIn:">highlightProbesIn: sourceText	"Return sourceText with probe locations emphasized."	self allProbesDo: [:aProbe | aProbe emphasize: sourceText].	^sourceText</body><body package="Debugger-Probes" selector="sourceText">sourceText	^self highlightProbesIn: (self getSource asText makeSelectorBoldIn: mclass)</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>private - bytes</category><body package="Debugger-Probes" selector="initializeBytes">initializeBytes	| maxDepth adjustedMethod flags |	adjustedMethod := methodHolder generate.	flags := 16rC0 + (adjustedMethod usesContextInstVars ifTrue: [16] ifFalse: [0]).	bytes := (ByteArray				with: flags 				with: original numArgs				with: adjustedMethod numTempsOnly				with: adjustedMethod frameSize) , adjustedMethod bytes.	"Insure acceptable frame size."	maxDepth := self maxDepth.	maxDepth + 2 &gt; self frameSize		ifTrue: [bytes at: 4 put: maxDepth + 2].</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>printing</category><body package="Debugger-Probes" selector="printNameOn:inClass:">printNameOn: aStream inClass: aClass	| selector class |	aClass isNil		ifTrue:			[| who |			mclass isNil				ifTrue:					[aStream nextPutAll: (#ParenUnboundMethodParen &lt;&lt; #pdp &gt;&gt; '(Unbound method)') asString.					^self].			who := self who.			who isNil				ifTrue:					[class := mclass.					selector := class defaultSelectorForMethod: self]				ifFalse:					[class := who first.					selector := who at: 2]]		ifFalse:			[class := aClass.			selector := self selector].	aStream nextPutAll: class shortName.	mclass == class 		ifFalse: 			[aStream nextPut: $(.			aStream nextPutAll: mclass shortName.			aStream nextPut: $)].	aStream nextPutAll: '&gt;&gt;'.	aStream nextPutAll: selector</body><body package="Debugger-Probes" selector="who">who 	"Answer an Array of the class in which the receiver is defined and	the selector to which it corresponds.  If the receiver is not defined	in any class, answer nil."	mclass isNil		ifTrue: [^nil].	^Array with: mclass with: self selector</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>fileIn/Out</category><body package="Debugger-Probes" selector="representBinaryOn:">representBinaryOn: bosWriter	" The stored representation of	CompiledMethods is special.  Overriding this method	helps prevent bossing out of probed methods. "	^bosWriter representCompiledMethod: original</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>tracing</category><body package="Debugger-Probes" selector="traceFrom:">traceFrom: aTracer	self error: (#ParcellingOutAProbedMethodErrorMessage &lt;&lt; #pdp &gt;&gt; 'An attempt was made to parcel out a ProbedCompiledMethod.  You must remove the probes from the target methods before parceling them out.')</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod class</class-id> <category>utilities</category><body package="Debugger-Probes" selector="allInstalledProbedMethods">allInstalledProbedMethods	^(self allProbedMethods select: [:meth | meth isInSystem]) asArray</body><body package="Debugger-Probes" selector="allProbedMethods">allProbedMethods	^self allInstances asOrderedCollection addAll: (ProbedAnnotatedMethod allInstances);yourself</body><body package="Debugger-Probes" selector="readProbesFromFile">readProbesFromFile	| fileName libStream |	fileName := Dialog requestFileName: (#NameOfProbeLibrary &lt;&lt; #pdp &gt;&gt; 'Name of probe library') default: '*.prb' version: #mustBeOld.	fileName isEmpty		ifTrue: [^self].	libStream := fileName asFilename readStream.	[self probeMethodsFrom: libStream]		ensure: [libStream close]"Smalltalk Professional Debug Package Version 2.5 (c) 1999 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="registerMethod:">registerMethod: aMethod	^aMethod</body><body package="Debugger-Probes" selector="revertAllProbedMethodsInSystem">revertAllProbedMethodsInSystem	self allInstalledProbedMethods do: [:each | each revert]</body><body package="Debugger-Probes" selector="saveProbesToFile">saveProbesToFile	| fileName libStream |	fileName := Dialog requestNewFileName: (#NameOfProbeLibrary &lt;&lt; #pdp &gt;&gt; 'Name of probe library') default: '*.prb'.	fileName isEmpty		ifTrue: [^self].	libStream := fileName asFilename writeStream.	[self allInstalledProbedMethods do: [:pMeth | pMeth saveOn: libStream]]		ensure: [libStream close]"Smalltalk Professional Debug Package Version 2.5 (c) 1999 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod class</class-id> <category>recompiling</category><body package="Debugger-Probes" selector="dontKeepRemovedMethods">dontKeepRemovedMethods	removedProbedMethodsHolder := PluggableAdaptor on: ValueHolder new.	removedProbedMethodsHolder		getBlock: [:m | Array new]		putBlock: [:m :v | v]		updateBlock: [:m :a :p | false]"Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="keepRemovedMethods">keepRemovedMethods	removedProbedMethodsHolder := PluggableAdaptor on: (ValueHolder with: OrderedCollection new).	removedProbedMethodsHolder		getBlock: [:m | m value]		putBlock: [:m :v | m value addAll: v]		updateBlock: [:m :a :p | false]"Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="recompileAndInsertProbesFrom:">recompileAndInsertProbesFrom: probedMethods	| probesInError |	probesInError := OrderedCollection new.	probedMethods do:		[:meth | | newProbedMethod |		newProbedMethod := meth installedMethod newFullProbedMethod.		probesInError addAll: (newProbedMethod reinsertProbesFrom: meth).		newProbedMethod hasAnyProbes			ifTrue: [newProbedMethod install]].	self reportOnFailedProbes: probesInError."Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="removedMethods">removedMethods	^removedProbedMethodsHolder value"Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="removedMethods:">removedMethods: methods	^removedProbedMethodsHolder value: methods"Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="reportOnFailedProbes:">reportOnFailedProbes: probesInError	| writeStream |	probesInError isEmpty		ifTrue: [^self].	writeStream := WriteStream on: (String new: 200).	writeStream nextPutAll: (#TheFollowingProbesFailedToRecompile &lt;&lt; #pdp &gt;&gt; 'The following probes failed to recompile correctly.') asString.	probesInError do: [:aProbe |		writeStream nextPutAll: aProbe methodString;			nextPutAll: ((#SpProbeAt1pDash2s &lt;&lt; #pdp &gt;&gt; ' probe at &lt;1p&gt; - &lt;2s&gt;&lt;n&gt;') 				expandMacrosWith: aProbe characterIndex printString				with: aProbe reportString)].	[ComposedTextView		open: writeStream contents asText asValue		label: (#FailedProbeRecompileReport &lt;&lt; #pdp &gt;&gt; 'Failed probe recompile report')] fork"Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod class</class-id> <category>instance creation</category><body package="Debugger-Probes" selector="from:full:">from: aCompiledMethod full: fullFlag	^(self new: aCompiledMethod basicSize + 7) from: aCompiledMethod full: fullFlag"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="probeMethodsFrom:">probeMethodsFrom: aStream	| aClassName selector meth cls |	[aStream atEnd]		whileFalse:			[aClassName := aStream upTo: $&gt;.			aStream next == $&gt;				ifFalse: [^Dialog warn: (#CannotUnderstandClassselector &lt;&lt; #pdp &gt;&gt; 'Cannot understand class&gt;&gt;selector')].			selector := aStream upTo: Character cr.			cls := Compiler evaluate: aClassName.			cls isNil				ifTrue: [^Dialog warn: ((#BadClassNameC1s &lt;&lt; #pdp &gt;&gt; 'Bad class name: &lt;1s&gt;')			expandMacrosWith: aClassName)].			meth := cls compiledMethodAt: selector asSymbol ifAbsent: [^Dialog warn: ((#x1sDoesNotHaveMethod2s &lt;&lt; #pdp &gt;&gt; '&lt;1s&gt; does not have method #&lt;2s&gt;')			expandMacrosWith: aClassName			with: selector)].			(self readMethodCRCFrom: aStream) = (CRC32Function crc32Of: (meth getSource string asByteArray))				ifFalse: [^Object errorSignal raiseErrorString: (#CannotInsertProbesMethodChanged &lt;&lt; #pdp &gt;&gt; 'Cannot insert probes, method has changed.')].			meth isProbed				ifFalse:					[meth := meth newFullProbedMethod.					meth loadProbesFrom: aStream.					meth install]]"Smalltalk Professional Debug Package Version 2.5 (c) 1999 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod class</class-id> <category>class initialization</category><body package="Debugger-Probes" selector="initialize">initialize	self dontKeepRemovedMethods."Smalltalk Professional Debug Package Version 3.1 (c) 2002 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod class</class-id> <category>private</category><body package="Debugger-Probes" selector="readMethodCRCFrom:">readMethodCRCFrom:  aStream	| fieldName result |	fieldName := aStream upTo: Character space.	fieldName = 'CRC:'		ifFalse:			[^AbstractCodeProbe unknowLoadField: fieldName on: aStream expected: 'CRC:'].	result := Number readFrom: aStream.	aStream next.	"swallow cr"	^result"Smalltalk Professional Debug Package Version 2.5 (c) 1999 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.BreakInterrupt class</class-id> <category>class initialization</category><body package="Debugger-Probes" selector="initialize">initialize	notifierString := (#BreakDash &lt;&lt; #pdp &gt;&gt; 'Break-').</body></methods><methods><class-id>CraftedSmalltalk.PDPMsgRcvdInstrumenterGUIModel</class-id> <category>operation</category><body package="Debugger-Probes" selector="checkIvarMenuButtonEnablement">checkIvarMenuButtonEnablement	ivarMenuButton isEnabled: basicTypeModel value == #instrumentSimpleWatch.</body><body package="Debugger-Probes" selector="help">help	| msg |	msg := Text			string: (#ProbeOnMessageReceivedHelpText &lt;&lt; #pdp &gt;&gt; 'The "Probe on message received" panel enables a user to insert a probe at the beginning of each method selected in the method list.  The action performed by the probe is determined by the the type selection radio buttons.  They are;	Breakpoint		Causes a breakpoint to occur when the message is received.	Simple msg watch		Records the receiver''s class and method selector in the watch window when the message is received.	Ivar watch		Causes a representation of the object in the instance variable to be recorded in the watch window.  The representation is obtained by sending the object a "debugString" message.  In Object, this method is defined as ^self printString.	Expression watch		Records the result of a user defined expression in the watch window.---------------------- Other controls -------------------Conditional	This check box is selected, a probe editor will open after the Done button has been pressed.  This allows the user to define an expression that will conditionally activate the probe.  Likewise, the   One should be aware that all the probes created by this panel will initially use this conditional expression.  Later, if the conditional expression of a probe is modified, only that probe will receive the change.Window parameters	This check box is used to request that a panel be opened to specify watch window parameters.Generate report	This check box will cause a workspace to be opened containing a report of what instrumentation action was requested.') asString		runs: (RunArray				runs: #(234 10 63 16 103 10 239 16 131 11 65 4 347 17 96 15 118)				values: #(nil #bold nil #bold nil #bold nil #bold nil #bold nil #bold nil #bold nil #bold nil)).	ComposedTextView		open: msg asValue		label: (#ProbeOnMessageReceivedHelp &lt;&lt; #pdp &gt;&gt; 'Probe on Message Received Help')		icon: (Icon constantNamed: #workspace)		extent: (500 @ 300).</body><body package="Debugger-Probes" selector="updateList">updateList	| classes |	classes := subclassModel value		ifTrue: [classUnderTest withAllSubclasses]		ifFalse: [Array with: classUnderTest].	methods := SortedCollection sortBlock: [:aa :b | aa nameString &lt; b nameString].	classes do: [:cl |		cl methodDictionary keysAndValuesDo: [:sel :meth |			meth isProbeable				ifTrue:					[methods add: (MethodActionRecord										action: nil										class: cl										selector: sel)]]].	panelList list: (methods collect: [:ac | ac nameString]).</body></methods><methods><class-id>CraftedSmalltalk.PDPMsgRcvdInstrumenterGUIModel</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="postBuildWith:">postBuildWith: aBuilder	super postBuildWith: aBuilder.	ivarMenuButton := aBuilder componentAt: #ivarMenu.	self updateList.</body><body package="Debugger-Probes" selector="preBuildWith:">preBuildWith: aBuilder	instrumenter := PDPMsgRcvdInstrumenter new.	super preBuildWith: aBuilder.	basicTypeModel onChangeSend: #checkIvarMenuButtonEnablement to: self.</body></methods><methods><class-id>CraftedSmalltalk.PDPMthdListMsgRcvdInstrumenterGUIModel</class-id> <category>private</category><body package="Debugger-Probes" selector="commonParentIn:">commonParentIn: clsCollection	| parent clsStream cls |	clsCollection do: [:cl | (cl includesBehavior: Object) ifFalse: [^nil]].	parent := clsCollection first.	clsStream := ReadStream on: clsCollection.	[clsStream atEnd]		whileFalse:			[((cls := clsStream next) includesBehavior: parent)				ifFalse:					[parent := parent commonSuperclass: cls.					clsStream reset]].	^parent</body><body package="Debugger-Probes" selector="determineBaseClass">determineBaseClass	| clsList records |	records := self selectedRecords asOrderedCollection.	clsList := records isEmpty		ifTrue: [origMethods collect: [:ac | ac key]]		ifFalse: [records collect: [:rec | rec methodClass]].	classUnderTest := self commonParentIn: clsList.</body></methods><methods><class-id>CraftedSmalltalk.PDPMthdListMsgRcvdInstrumenterGUIModel</class-id> <category>operation</category><body package="Debugger-Probes" selector="newSelection">newSelection	self determineBaseClass.	self buildVariableMenu.</body><body package="Debugger-Probes" selector="updateList">updateList	methods := SortedCollection sortBlock: [:aa :b | aa nameString &lt; b nameString].	origMethods do:		[:ac |		(ac key compiledMethodAt: ac value) isProbeable			ifTrue:				[methods add: (MethodActionRecord									action: nil									class: ac key									selector: ac value)]].	panelList list: (methods collect: [:ac | ac nameString]).</body></methods><methods><class-id>CraftedSmalltalk.PDPMthdListMsgRcvdInstrumenterGUIModel</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="on:">on: aColl	classUnderTest := Object.	origMethods := aColl.	self openInterface.</body><body package="Debugger-Probes" selector="postBuildWith:">postBuildWith: aBuilder	super postBuildWith: aBuilder.	panelList selectionIndexHolder onChangeSend: #newSelection to: self.</body></methods><methods><class-id>CraftedSmalltalk.DisplayInstanceVarProbe</class-id> <category>responses</category><body package="Debugger-Probes" selector="actOn:">actOn: aContext 	(self test: aContext)		ifTrue:			[PDPManager				display: (aContext homeReceiver instVarAt: index) debugString				on: windowID				for: self]</body></methods><methods><class-id>CraftedSmalltalk.DisplayInstanceVarProbe</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="createLabelString">createLabelString	labelString value:		((#Ivar1sIn2sAt3p &lt;&lt; #pdp &gt;&gt; 'Ivar %&lt;&lt;1s&gt;%&gt; in &lt;2s&gt; at &lt;3p&gt;')			expandMacrosWith: self variableName			with: self methodString			with: self characterIndex)</body><body package="Debugger-Probes" selector="updateInstanceVarIndexForMethod:">updateInstanceVarIndexForMethod: probedMethod	"Update the receiver's index for the named instance variable.	Return true if the iVar still exists, otherwise return false."	index := probedMethod mclass allInstVarNames indexOf: name.	^index ~~ 0</body><body package="Debugger-Probes" selector="updateMiscFromProbe:">updateMiscFromProbe: aProbe	super updateMiscFromProbe: aProbe.	index := aProbe variableIndex.	name := aProbe variableName.</body></methods><methods><class-id>CraftedSmalltalk.DisplayInstanceVarProbe</class-id> <category>accessing</category><body package="Debugger-Probes" selector="editorLabelString">editorLabelString	^((#EditIVarWatchProbeOn1s &lt;&lt; #pdp &gt;&gt; 'Edit Instance Variable Watch on: %&lt;&lt;1s&gt;%&gt;')			expandMacrosWith: name)</body></methods><methods><class-id>CraftedSmalltalk.DisplayInstanceVarProbe</class-id> <category>saving-loading</category><body package="Debugger-Probes" selector="postLoadIntoMethod:">postLoadIntoMethod: probedMethod	^self updateInstanceVarIndexForMethod: probedMethod</body></methods><methods><class-id>CraftedSmalltalk.ProbeInsertionRecord</class-id> <category>comparing</category><body package="Debugger-Probes" selector="=">= aRecord	^(aRecord characterIndex = characterIndex) &amp; (aRecord insertionPC = pc) &amp; (aRecord blockMethodIndex = blockIndex)</body><body package="Debugger-Probes" selector="hash">hash	^(blockIndex - 1 * 100 + characterIndex) * 100 + pc</body></methods><methods><class-id>CraftedSmalltalk.ProbeInsertionRecord</class-id> <category>accessing</category><body package="Debugger-Probes" selector="atEnd">atEnd	^atEnd</body><body package="Debugger-Probes" selector="blockMethodIndex">blockMethodIndex	^blockIndex</body><body package="Debugger-Probes" selector="characterIndex">characterIndex	^characterIndex</body><body package="Debugger-Probes" selector="fixPCFor:amount:">fixPCFor: aPC amount: delta	aPC &gt; pc		ifTrue: [^self].	pc := pc + delta</body><body package="Debugger-Probes" selector="fixPCFor:amount:doEqualPC:">fixPCFor: aPC amount: delta doEqualPC: doEqualNot	aPC &gt; pc		ifTrue: [^self].	aPC = pc &amp; doEqualNot		ifTrue: [^self].	pc := pc + delta</body><body package="Debugger-Probes" selector="getLastEntryFrom:">getLastEntryFrom: aProbedCompiledMethod	| map i nuEntry end anEntry |	atEnd		ifTrue: [^self].	map := aProbedCompiledMethod sourceMapAt: blockIndex.	i := mapEntry index + 1.	end := map size.	nuEntry := mapEntry.	[i &lt; end and: [(anEntry := map at: i) key == pc]]		whileTrue:			[anEntry end notNil				ifTrue: [nuEntry := anEntry].			i := i + 1].	nuEntry == mapEntry		ifTrue: [^self].	mapEntry := nuEntry.	pc := mapEntry key.	characterIndex := mapEntry value first min: mapEntry value last.</body><body package="Debugger-Probes" selector="insertionPC">insertionPC	^pc</body><body package="Debugger-Probes" selector="insertionPCFor:">insertionPCFor: aMethod	mclass := aMethod homeMethod mclass.	selector := aMethod homeMethod selector.	mapEntry := aMethod sourceMap at: self mapIndex.	pc := atEnd		ifTrue: [mapEntry end]		ifFalse: [mapEntry key].	^pc</body><body package="Debugger-Probes" selector="insertionRange">insertionRange	^characterIndex to: characterIndex</body><body package="Debugger-Probes" selector="mapIndex">mapIndex	^mapEntry index</body><body package="Debugger-Probes" selector="mclass">mclass	^mclass</body><body package="Debugger-Probes" selector="mclass:">mclass: aClass	mclass := aClass.</body><body package="Debugger-Probes" selector="methodString">methodString	^mclass name , '&gt;&gt;' , selector asString</body><body package="Debugger-Probes" selector="selector">selector	^selector</body><body package="Debugger-Probes" selector="updateMethod:">updateMethod: aProbedMethod	mclass := aProbedMethod homeMethod mclass.	selector := aProbedMethod homeMethod selector.</body></methods><methods><class-id>CraftedSmalltalk.ProbeInsertionRecord</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="characterIndex:blockIndex:mapEntry:atEnd:">characterIndex: ci blockIndex: bli mapEntry: me atEnd: endFlag	characterIndex := ci.	blockIndex := bli.	mapEntry := me.	atEnd := endFlag.	mapEntry == nil		ifTrue: [^self].	pc := atEnd		ifTrue: [mapEntry end]		ifFalse: [mapEntry key]</body></methods><methods><class-id>CraftedSmalltalk.ProbeInsertionRecord</class-id> <category>saving-loading</category><body package="Debugger-Probes" selector="loadFrom:">loadFrom: aStream	| fieldName |	fieldName := aStream upTo: Character space.	fieldName = 'CharacterPosition:'		ifFalse:			[^AbstractCodeProbe unknowLoadField: fieldName on: aStream expected: 'CharacterPosition:'].	characterIndex := Number readFrom: aStream.	aStream next.	"swallow cr"</body><body package="Debugger-Probes" selector="saveOn:">saveOn: aStream	aStream nextPutAll: 'CharacterPosition: '.	characterIndex printOn: aStream.	aStream cr.</body></methods><methods><class-id>CraftedSmalltalk.ProbeInsertionRecord</class-id> <category>testing</category><body package="Debugger-Probes" selector="pcRangeExcludes:">pcRangeExcludes: aLocation	^mapEntry pcRangeExcludes: aLocation</body></methods><methods><class-id>CraftedSmalltalk.ProbeInsertionRecord class</class-id> <category>instance creation</category><body package="Debugger-Probes" selector="characterIndex:blockIndex:mapEntry:atEnd:">characterIndex: ci blockIndex: bli mapEntry: me atEnd: endFlag	^self new characterIndex: ci blockIndex: bli mapEntry: me atEnd: endFlag"Smalltalk Professional Debug Package Version 1.5 (c) 1995,1997 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="createFrom:">createFrom: aStream	^self new loadFrom: aStream</body></methods><methods><class-id>CraftedSmalltalk.PDPManager class</class-id> <category>utilities</category><body package="Debugger-Probes" selector="about">about	| dialog builder |	dialog := SimpleDialog new.	builder := dialog builder.	builder labelAt: #versionLabel put: ((#Version1s &lt;&lt; #pdp &gt;&gt; 'Version &lt;1s&gt;')			expandMacrosWith: self versionString).	builder aspectAt: #ok put: [dialog close].	dialog allButOpenFrom: (UISpecification from: self aboutSpec).	dialog builder openDialog"Smalltalk Professional Debug Package Version 2.5 (c) 1999 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="browseAllProbedMethods">browseAllProbedMethods	"Create and schedule a MessageListBrowser for all probed methods."	^MethodCollector new		openListBrowserOn: self allProbedMethodDefinitions		label: (#ProbedMethods &lt;&lt; #pdp &gt;&gt; 'Probed Methods')		initialSelection: nil"Smalltalk Professional Debug Package Version 2.5 (c) 1999 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="findSelectedProbeEmphasisIn:">findSelectedProbeEmphasisIn: aText	| evalBlock |	evalBlock :=		[:emp |		(emp class == ProbeCharacterStyle and:			[emp key == #probe or: [emp key == #tempProbe]])				ifTrue: [^emp]].	aText runs values do:		[:aValue  |		(aValue isKindOf: Array)			ifTrue: [aValue do: [:obj | evalBlock value: obj]]			ifFalse: [evalBlock value: aValue]].	^nil	"Smalltalk Professional Debug Package Version 3.1 (c) 2003 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="purgeUnusedDebugVariables">purgeUnusedDebugVariables	"PDPManager purgeUnusedDebugVariables"	 | warray index da |	da := debugVariables bindingFor: #DebugActive.  "Hold onto binding so it will not be removed."	warray := WeakArray new: debugVariables size.	index := 1.	debugVariables associationsDo:		[:ac |		warray at: index put: ac.		index := index + 1].	debugVariables := Dictionary new.	ObjectMemory garbageCollect.	warray do: [:ac | ac == warray tombstone ifFalse: [debugVariables add: ac]]</body><body package="Debugger-Probes" selector="purgeUnusedWatchWindows">purgeUnusedWatchWindows	"PDPManager purgeUnusedWatchWindows"	| ids newWatches ac |	ObjectMemory garbageCollect.	ids := Set new.	DisplayProbe withAllSubclasses do:			[:probeClass |			probeClass allInstances do: [:aProbe | ids add: aProbe windowID]].	newWatches := Dictionary new.	ids do:		[:anID |		ac := watchWindows associationAt: anID ifAbsent: [nil].		ac isNil			ifFalse: [newWatches add: ac]].	watchWindows := newWatches."Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="toggleDebugging">toggleDebugging	self debugActive: self debugActive not."Smalltalk Professional Debug Package Version 3.1 (c) 2002 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="togglePermTempProbeType">togglePermTempProbeType	defaultToPermanentProbe := defaultToPermanentProbe not."Smalltalk Professional Debug Package Version 3.0 (c) 2001 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.PDPManager class</class-id> <category>accessing</category><body package="Debugger-Probes" selector="addDebugVariable:">addDebugVariable: aSymbol	self addDebugVariable: aSymbol value: nil"Smalltalk Professional Debug Package Version 3.1 (c) 1995-2002 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="addDebugVariable:value:">addDebugVariable: aSymbol value: anObject	debugVariables at: aSymbol put: anObject"Smalltalk Professional Debug Package Version 3.1 (c) 2002 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="debugActive">debugActive	^debugVariables at: #DebugActive"Smalltalk Professional Debug Package Version 1.51 (c) 1997 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="debugActive:">debugActive: aBoolean	debugVariables at: #DebugActive put: aBoolean"Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="debugVariableNames">debugVariableNames	^debugVariables keys asArray"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="debugVariables">debugVariables	^debugVariables"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="isPermanentProbeDefault">isPermanentProbeDefault	^defaultToPermanentProbe</body><body package="Debugger-Probes" selector="permanentProbeIsDefault">permanentProbeIsDefault	^defaultToPermanentProbe</body><body package="Debugger-Probes" selector="permanentProbeIsDefault:">permanentProbeIsDefault: aBoolean	defaultToPermanentProbe := aBoolean</body><body package="Debugger-Probes" selector="versionString">versionString	^'3.1'</body></methods><methods><class-id>CraftedSmalltalk.PDPManager class</class-id> <category>private</category><body package="Debugger-Probes" selector="allProbedMethodDefinitions">allProbedMethodDefinitions	ObjectMemory garbageCollect.	^ProbedCompiledMethod allInstalledProbedMethods collect: [:meth | MethodDefinition class: meth mclass selector: meth selector]."Smalltalk Professional Debug Package Version 3.1 (c) 2002 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="newWatchWindow">newWatchWindow	^WatchWindowHolder new"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="nextWindowID">nextWindowID	| id |	lastID := lastID + 1.	id := lastID printString asSymbol.	watchWindows at: id put: self newWatchWindow.	^id"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.PDPManager class</class-id> <category>probes - recompiling</category><body package="Debugger-Probes" selector="basicReinsertProbesAndIndices:into:">basicReinsertProbesAndIndices: probesAndIndices into: probedMethod	| probesInError |	probesInError := OrderedCollection new.	probesAndIndices do:		[:ac | | probe index newRecord |		probe := ac key baseParent copy.		index := ac value.		newRecord := probedMethod probeRecordFor: (index to: index).		probe record: newRecord.		(probe updateTempVarForMethod: probedMethod)			ifTrue: [probedMethod addProbe: probe]			ifFalse:				[newRecord updateMethod: probedMethod.		"update mclass and selector for reporting"				probesInError add: probe]].	probesInError addAll: probedMethod recompileProbes.	ProbedCompiledMethod reportOnFailedProbes: probesInError."Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="getProbesAndIndicesFrom:">getProbesAndIndicesFrom: aText	| runs values result emphasis position |	result := OrderedCollection new.	runs := aText runs runs.	values := aText runs values.	position := 1.	1 to: runs size do:		[:i |		emphasis := values at: i.		(emphasis isKindOf: Array)			ifTrue:				[emphasis do:	"There should be only one probe in the emphasis if any."					[:emp | 					emp class == ProbeCharacterStyle						ifTrue: [result add: emp value -&gt; position]]]			ifFalse:				[emphasis class == ProbeCharacterStyle					ifTrue: [result add: emphasis value -&gt; position]].		position := position + (runs at: i)].	^result"Smalltalk Professional Debug Package Version 3.1 (c) 2003 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="reinsertProbesAfterMethod:recompileFor:">reinsertProbesAfterMethod: newMethod recompileFor: aText	| oldProbes |	newMethod isNil		ifTrue: [^self].	newMethod isProbeable		ifFalse: [^newMethod].	oldProbes := self getProbesAndIndicesFrom: aText.	oldProbes isEmpty		ifTrue: [^newMethod].	(Dialog		choose: (#RemoveOrKeepOldProbes &lt;&lt; #pdp &gt;&gt; 'Remove or keep old probes?')		labels: (Array with: (#Remove &lt;&lt; #pdp &gt;&gt; 'Remove') with: (#Keep &lt;&lt; #pdp &gt;&gt; 'Keep'))		values: #(false true)		default: true)		ifFalse: [^newMethod].	^self reinsertProbesAndIndices: oldProbes into: newMethod."Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="reinsertProbesAndIndices:into:">reinsertProbesAndIndices: probesAndIndices into: newMethod	| probedMethod |	probedMethod := newMethod newFullProbedMethod.	self basicReinsertProbesAndIndices: probesAndIndices into: probedMethod.	probedMethod hasAnyProbes		ifFalse: [^newMethod].	probedMethod noNotifyInstall.	^probedMethod"Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="spawnRemovedProbedMethodsBrowser">spawnRemovedProbedMethodsBrowser	| removedMethods answer |	removedMethods := ProbedCompiledMethod removedMethods.	removedMethods isEmpty		ifTrue: [^self].	answer := Dialog 				choose: (#ProbesRemovedWhatToDo &lt;&lt; #pdp &gt;&gt; 'Probes were removed due to class recompliation.		What do you want to do with them?')				labels: (Array with: (#ReinstallAll &lt;&lt; #pdp &gt;&gt; 'Reinstall All') with: (#SelectivelyReinstall &lt;&lt; #pdp &gt;&gt; 'Selectively Reinstall') with: (#Discard &lt;&lt; #pdp &gt;&gt; 'Discard'))				values: #(0 1 2)				default: 0.	answer = 2		ifTrue: [^self].	answer = 0		ifTrue:			[[ProbedCompiledMethod recompileAndInsertProbesFrom: removedMethods] fork.			^self].	[RemovedProbedMethodsBrowser onMethods: removedMethods] fork."Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.PDPManager class</class-id> <category>synchronizing tools</category><body package="Debugger-Probes" selector="cancelMethodChangeNotificationFor:">cancelMethodChangeNotificationFor: aTool	methodDependents remove: aTool ifAbsent: []</body><body package="Debugger-Probes" selector="changedMethodFrom:to:by:">changedMethodFrom: oldMethod to: newMethod by: aBrowser 	| coll |	coll := OrderedCollection new.	methodDependents do: [:ab | coll add: ab].	coll do:		[:activeTool |		activeTool			changedMethodFrom: oldMethod			to: newMethod			by: aBrowser]"Smalltalk Professional Debug Package Version 3.0 (c) 2002 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="notifyOnMethodChanged:">notifyOnMethodChanged: aTool	methodDependents add: aTool</body><body package="Debugger-Probes" selector="revokeMethodChangeNotificationFor:">revokeMethodChangeNotificationFor: aTool	methodDependents remove: aTool ifAbsent: []</body></methods><methods><class-id>CraftedSmalltalk.PDPManager class</class-id> <category>watch windows</category><body package="Debugger-Probes" selector="display:on:for:">display: aString on: windowID for: aProbe		(self getWatchWindow: windowID for: aProbe) showString: aString."Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="getWatchWindow:for:">getWatchWindow: windowID for: aProbe 	| windowKey |	windowKey := windowID.	(windowKey isNil or: [windowKey isEmpty])		ifTrue: [aProbe windowID: (windowKey := self nextWindowID)].	(watchWindows includesKey: windowKey)		ifFalse: [watchWindows at: windowKey put: ((self newWatchWindow) label: aProbe labelString; yourself)].	^watchWindows at: windowKey"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="openWatchWindow:for:">openWatchWindow: windowID for: aProbe	| window |	window := self getWatchWindow: windowID for: aProbe.	window reopen."Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="windowHolders">windowHolders	^watchWindows"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.PDPManager class</class-id> <category>launcher menu</category><body package="Debugger-Probes" selector="getEnableProbeDebuggingLabel">getEnableProbeDebuggingLabel	^self debugActive		ifTrue: [(#Disable_Probes &lt;&lt; #pdp &gt;&gt; 'Disable &amp;Probes')]		ifFalse: [(#Enable_Probes &lt;&lt; #pdp &gt;&gt; 'Enable &amp;Probes')]."Smalltalk Professional Debug Package Version 1.51 (c) 1995,1997 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="getPermTempProbeLabel">getPermTempProbeLabel	^defaultToPermanentProbe		ifTrue: [(#DefaultTo_TempProbes &lt;&lt; #pdp &gt;&gt; 'Default to &amp;Temp Probes')]		ifFalse: [(#DefaultTo_PermProbes &lt;&lt; #pdp &gt;&gt; 'Default to &amp;Perm Probes')]."Smalltalk Professional Debug Package Version 3.0 (c) 2001 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.PDPManager class</class-id> <category>class initialization</category><body package="Debugger-Probes" selector="initialize">initialize	"PDPManager initialize."	debugVariables := Dictionary new.	self addDebugVariable: #DebugActive value: true.	watchWindows isNil		ifTrue:			[watchWindows := Dictionary new.			lastID := 0].	methodDependents := PDPWeakCollection new: 5.	defaultToPermanentProbe := false."Smalltalk Professional Debug Package Version 3.1 (c) 1997 - 2002 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.DisplayTOSProbe</class-id> <category>responses</category><body package="Debugger-Probes" selector="actOn:">actOn: aContext 	(self test: aContext)		ifTrue:			[PDPManager				display: aContext top debugString				on: windowID				for: self]</body></methods><methods><class-id>CraftedSmalltalk.DisplayTOSProbe</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="createLabelString">createLabelString	labelString value: 		((#TopOfStackAt1pIn2s &lt;&lt; #pdp &gt;&gt; 'Top of Stack at &lt;1p&gt; in &lt;2s&gt;')			expandMacrosWith: self characterIndex			with: self methodString)</body></methods><methods><class-id>CraftedSmalltalk.DisplayTOSProbe</class-id> <category>accessing</category><body package="Debugger-Probes" selector="editorLabelString">editorLabelString	^(#EditTopOfStackWatchProbe &lt;&lt; #pdp &gt;&gt; 'Edit Top of Stack Watch') asString</body></methods><methods><class-id>CraftedSmalltalk.JumpRecord</class-id> <category>comparing</category><body package="Debugger-Probes" selector="&lt;">&lt; aJumpRecord 	"Answer whether the receiver is less than the argument."	^location &lt; aJumpRecord location</body><body package="Debugger-Probes" selector="=">= aJumpRecord 	"Answer whether the receiver is equal to the argument."	^location = aJumpRecord location</body><body package="Debugger-Probes" selector="hash">hash	"Answer a SmallInteger unique to the receiver."	^location hash</body></methods><methods><class-id>CraftedSmalltalk.JumpRecord</class-id> <category>code corrections</category><body package="Debugger-Probes" selector="adjustDeltaIn:">adjustDeltaIn: aCollection	"This method changes the jump offset in aCollection to	newDelta.  It assumes that newDelta is a valid offset for	the current jump type."	| adjustment byte temp |	adjustment := newDelta - delta.	byte := aCollection at: location.	delta := newDelta.	type &lt; 2		ifTrue: [^aCollection at: location put: byte + adjustment].	delta abs &gt; 1023		ifTrue: [^self].	temp := (byte bitShift: 8) + (aCollection at: location + 1) + adjustment.	aCollection at: location put: (temp bitShift: -8).	aCollection at: location + 1 put: (temp bitAnd: 255).</body><body package="Debugger-Probes" selector="fixJumpIn:">fixJumpIn: aCollection	type = 0		ifTrue:			[newDelta &lt; 0 ifTrue: [newDelta := newDelta - 1].			aCollection at: location put: OpLongJump + 4 + ((newDelta bitShift: -8) bitAnd: 255).			aCollection add: (newDelta bitAnd: 255) beforeIndex: location + 1].	type = 1		ifTrue:			[aCollection at: location put: OpLongBranchFalse.			aCollection add: newDelta beforeIndex: location + 1].	delta := newDelta.	type := type + 2.	^1</body></methods><methods><class-id>CraftedSmalltalk.JumpRecord</class-id> <category>testing</category><body package="Debugger-Probes" selector="isChanged">isChanged	^newDelta ~= delta</body><body package="Debugger-Probes" selector="isLongJumpTooLong">isLongJumpTooLong	^newDelta abs &gt; 1023</body><body package="Debugger-Probes" selector="shouldMakeLong">shouldMakeLong	"Returns true if the jump should be converted to a long jump."	type = 0		ifTrue: [^newDelta &gt; MaxShortJump].	type = 1		ifTrue: [^newDelta &gt; MaxShortBranchFalse].	^false</body></methods><methods><class-id>CraftedSmalltalk.JumpRecord</class-id> <category>accessing</category><body package="Debugger-Probes" selector="location">location	^location</body><body package="Debugger-Probes" selector="moveBy:">moveBy: aDelta	location := location + aDelta</body><body package="Debugger-Probes" selector="newDelta">newDelta	^newDelta</body><body package="Debugger-Probes" selector="newDelta:">newDelta: anInteger	newDelta := anInteger</body><body package="Debugger-Probes" selector="pc:delta:opr:">pc: aPC delta: amount opr: byte	location := aPC.	newDelta := delta := amount.	(byte &lt;= (OpShortJump + MaxShortJump))		ifTrue: [^type := 0].	(byte &lt;= (OpShortBranchFalse + MaxShortBranchFalse))		ifTrue: [^type := 1].	(byte &lt;= (OpLongJump + 7))		ifTrue: [^type := 2].	(byte &lt;= (OpLongBranchFalse + 3))		ifTrue: [^type := 3].	(byte &lt;= (OpLongBranchTrue + 3))		ifTrue: [^type := 4].</body><body package="Debugger-Probes" selector="target">target	^(type &gt; 1		ifTrue: [2]		ifFalse: [1]) + location + newDelta</body></methods><methods><class-id>CraftedSmalltalk.JumpRecord class</class-id> <category>instance creation</category><body package="Debugger-Probes" selector="pc:delta:opr:">pc: aPC delta: amount opr: aByte	^(self new) pc: aPC delta: amount opr: aByte; yourself"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.PDPParser</class-id> <category>expression types-^value/error</category><body package="Debugger-Probes" selector="method:context:">method: fromDoIt context: ctxt 	"pattern [ | temporaries ] block =&gt; MethodNode"	| start pat messageComment methodNode tempNodes |	start := mark.	pat := Array 			with: #DOIT:PROBE:			with: (Array					with: (builder newParameterVariable: (builder newVariableName: 'DOITCONTEXT'))					with: (builder newParameterVariable: (builder newVariableName: 'ThisProbe'))).	"pat={selector, arguments}"	messageComment := currentComment.	currentComment := nil.	methodNode := builder newMethodSelector: (pat at: 1).	tempNodes := tokenType == #verticalBar		ifTrue: [self temporaries]		ifFalse:			[newLanguage				ifTrue: [nil]				ifFalse: [#()]].	self statementsArgs: (pat at: 2) temps: tempNodes.	tokenType == #doIt		ifFalse: [^self expected: (#NothingMore &lt;&lt; #pdp &gt;&gt; 'Nothing more')].	methodNode block: parseNode.	methodNode addComment: messageComment.	methodNode sourcePosition: (start to: self endOfLastToken).	^methodNode</body></methods><methods><class-id>CraftedSmalltalk.ProbedAnnotatedMethod</class-id> <category>comparing</category><body package="Debugger-Probes" selector="=">= aMethod	"Compare the receiver to another object.  Answer true if the	 other object is an exactly equivalent method.  Override to	 ensure we compare attributes."	| list |	super = aMethod ifFalse: [^false].	list := aMethod attributeMessages.	list size = self attributeMessages size ifFalse:		[^false].	list := OrderedCollection withAll: list.	self attributeMessages do:		[:msg | list remove: msg ifAbsent: [^false]].	^true</body></methods><methods><class-id>CraftedSmalltalk.ProbedAnnotatedMethod</class-id> <category>accessing-literals</category><body package="Debugger-Probes" selector="allLiteralsDo:">allLiteralsDo: aBlock	super allLiteralsDo: aBlock.	self attributeMessages do:		[:msg |		aBlock value: msg selector.		self traverse: msg arguments with: aBlock].</body><body package="Debugger-Probes" selector="allSymbolLiteralsDo:">allSymbolLiteralsDo: aBlock	super allSymbolLiteralsDo: aBlock.	self attributeMessages do:		[:msg |		aBlock value: msg selector.		self traverse: msg arguments with:			[:sublit|			sublit isSymbol ifTrue: [aBlock value: sublit]]].</body></methods><methods><class-id>CraftedSmalltalk.ProbedAnnotatedMethod</class-id> <category>accessing</category><body package="Debugger-Probes" selector="attributeAt:ifAbsent:">attributeAt: key ifAbsent: exceptionBlock	attributes == nil ifTrue: [^exceptionBlock value].	^self attributes at: key ifAbsent: exceptionBlock</body><body package="Debugger-Probes" selector="attributeMessages">attributeMessages	attributes class == IdentityDictionary		ifTrue: [self attributes: attributes].	^attributes</body><body package="Debugger-Probes" selector="attributeMessages:">attributeMessages: anArray	attributes := anArray == nil ifFalse: [anArray asArray]</body><body package="Debugger-Probes" selector="attributes">attributes	"Answer the receiver's attribute dictionary. If no attributes are defined, answer nil."	^attributes class == Array		ifTrue: [self messagesToDict: attributes]		ifFalse: [attributes]</body><body package="Debugger-Probes" selector="attributes:">attributes: aDictionary	| list |	list := Array new.	aDictionary keysAndValuesDo: [:key :value |		(key includes: $_) ifTrue: [self error: (#BadOldstyleKey &lt;&lt; #pdp &gt;&gt; 'Bad old-style key')].		list := list copyWith: (Message				selector: (key copyWith: $:) asSymbol				argument: value)].	self attributeMessages: list</body><body package="Debugger-Probes" selector="environment">environment	"Answer the NameSpace in which this compiled code	was compiled.  If not known, answer nil."	^self attributeAt: #__environment ifAbsent: [super environment]</body><body package="Debugger-Probes" selector="resourceType">resourceType	self attributeMessages do:		[:msg |		msg selector == #resource: ifTrue: [^msg arguments first]].	^nil</body></methods><methods><class-id>CraftedSmalltalk.ProbedAnnotatedMethod</class-id> <category>private</category><body package="Debugger-Probes" selector="copyStateFromOldVersion:">copyStateFromOldVersion: oldMethod	"This message is sent by CodeRegenerator to a newly	generated method, to allow the method to copy over	the source pointer and any other information that the	CodeRegenerator would not know how to preserve."	super copyStateFromOldVersion: oldMethod.	self attributeMessages: oldMethod attributeMessages</body><body package="Debugger-Probes" selector="messagesToDict:">messagesToDict: list	| d |	d := IdentityDictionary new.	list do:		[:msg |		d at: (self class transformSelectorToKey: msg selector)			put: (msg arguments size = 0 ifTrue: [nil] ifFalse: [msg arguments first])].	^d</body></methods><methods><class-id>CraftedSmalltalk.ProbedAnnotatedMethod</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="from:full:">from: aCompiledMethod full: fullFlag	self attributeMessages: aCompiledMethod attributeMessages.	^super from: aCompiledMethod full: fullFlag</body></methods><methods><class-id>CraftedSmalltalk.ProbedAnnotatedMethod</class-id> <category>binary storage</category><body package="Debugger-Probes" selector="isCodeReaderEquivalentTo:">isCodeReaderEquivalentTo: aNewlyLoadedMethod	"Override to ensure we compare attributes."	| theirAttributes |	(super isCodeReaderEquivalentTo: aNewlyLoadedMethod) ifFalse: [^false].	theirAttributes := aNewlyLoadedMethod attributeMessages.	theirAttributes size = self attributeMessages size ifFalse: [^false].	self attributeMessages		with: theirAttributes		do:			[:ourMsg :theirMsg |			(ourMsg isCodeReaderEquivalentTo: theirMsg) ifFalse: [^false]].	^true</body></methods><methods><class-id>CraftedSmalltalk.ProbedAnnotatedMethod</class-id> <category>testing</category><body package="Debugger-Probes" selector="refersToLiteral:">refersToLiteral: aLiteral	"Answer true if this method (or any submethod)	refers to the given literal, directly or indirectly as an element of an array. 	We do not include special selector references.	We duplicate the code of literalsDo: for speed."	^(super refersToLiteral: aLiteral) or:		[self attributeMessages contains:			[:msg |			(msg selector refersToLiteral: aLiteral) or:				[msg arguments refersToLiteral: aLiteral]]]</body></methods><methods><class-id>CraftedSmalltalk.ProbedAnnotatedMethod class</class-id> <category>utilities</category><body package="Debugger-Probes" selector="transformKeyToSelector:">transformKeyToSelector: key	| new |	new := key copyWith: $:.	new replaceAll: $_ with: $:.	^new asSymbol</body><body package="Debugger-Probes" selector="transformSelectorToKey:">transformSelectorToKey: selector	| new |	new := selector asString.	new replaceAll: $: with: $_.	new last = $_ ifTrue: [new := new copyFrom: 1 to: new size-1].	^new asSymbol</body></methods><methods><class-id>CraftedSmalltalk.ActionProbeEditor</class-id> <category>accessing</category><body package="Debugger-Probes" selector="actionEditor">actionEditor	actionEditor == nil		ifFalse: [^actionEditor].	actionEditor := ProbeActionExpressionEditor new				probe: workingCopyProbe				on: probedMethod				class: probedClass.	^actionEditor</body></methods><methods><class-id>CraftedSmalltalk.ActionProbeEditor</class-id> <category>interface opening</category><body package="Debugger-Probes" selector="createEditor">createEditor	^self createEditorOn: #actionEditorSpec</body></methods><methods><class-id>CraftedSmalltalk.DebugStepIntoBlockClosure</class-id> <category>evaluating</category><body package="Debugger-Probes" selector="value">value	^self valueWithArguments: #()</body><body package="Debugger-Probes" selector="value:">value: arg	^self valueWithArguments: (Array with: arg)</body><body package="Debugger-Probes" selector="value:value:">value: arg1 value: arg2	^self valueWithArguments: (Array with: arg1 with: arg2)</body><body package="Debugger-Probes" selector="value:value:value:">value: arg1 value: arg2 value: arg3	^self valueWithArguments: (Array with: arg1 with: arg2 with: arg3)</body><body package="Debugger-Probes" selector="valueWithArguments:">valueWithArguments: anArray	"Override evaluation to raise a signal if the receiver is being evaluated	 in the context of the debugger's current debug process."	(Processor activeProcess environment at: #_dbg_step_into_block ifAbsent: false) ifTrue:		[BlockClosure adoptInstance: self.		 StepIntoBlockNotification raiseRequestWith: (thisContext blockContextFrom: self args: anArray)].	^super valueWithArguments: anArray</body></methods><methods><class-id>CraftedSmalltalk.DebugStepIntoBlockClosure class</class-id> <category>instance creation</category><body package="Debugger-Probes" selector="new">new	"This class exists only for the use of the debugger."	^self shouldNotImplement</body></methods><methods><class-id>CraftedSmalltalk.PDPMsgRcvdInstrumenter</class-id> <category>private</category><body package="Debugger-Probes" selector="createAndAddProbesFor:">createAndAddProbesFor: aRec	methodString := aRec nameString.	probeRecord := probedMethod methodHolder node probeRecordAtStart.	probeRecord getLastEntryFrom: probedMethod.	self createNewProbe.	self perform: probeCompletionSelector.</body><body package="Debugger-Probes" selector="createContextExpression">createContextExpression	templateProbe		compileExpression: '	^DOITCONTEXT printString'		inClass: classUnderTest		scope: startingScope.</body><body package="Debugger-Probes" selector="createExpression">createExpression	self createContextExpression.</body><body package="Debugger-Probes" selector="initializeLabelstring">initializeLabelstring	templateProbe labelString: ((#MessagesReceivedInClass1s &lt;&lt; #pdp &gt;&gt; 'Messages received in class &lt;1s&gt;')			expandMacrosWith: classUnderTest shortName).</body></methods><methods><class-id>CraftedSmalltalk.PDPMsgRcvdInstrumenter</class-id> <category>expression watch</category><body package="Debugger-Probes" selector="createExpWatchLeadString">createExpWatchLeadString	"ignore, don't need a lead string"</body></methods><methods><class-id>CraftedSmalltalk.PDPMsgRcvdInstrumenter</class-id> <category>probe finish</category><body package="Debugger-Probes" selector="createIndividualProbeLabel">createIndividualProbeLabel	labelStream reset.	labelStream nextPutAll: leadString;		nextPutAll: methodString.	probe labelString: labelStream contents.</body><body package="Debugger-Probes" selector="createIndiviualProbeSmartExpression">createIndiviualProbeSmartExpression	probe		compileExpression: '	^''' , methodString , ''''		inClass: classUnderTest		scope: startingScope.</body></methods><methods><class-id>CraftedSmalltalk.PDPMsgRcvdInstrumenter</class-id> <category>simple watch</category><body package="Debugger-Probes" selector="createSimpleWatchTemplateProbe">createSimpleWatchTemplateProbe	templateProbe := DisplayInstanceVarProbe name: iVarName index: iVarIndex.	self initializeTemplateTestMethod.</body><body package="Debugger-Probes" selector="initializeSimpleWatchProbeClass">initializeSimpleWatchProbeClass	probeClass := DisplayInstanceVarProbe.</body></methods><methods><class-id>CraftedSmalltalk.PDPMsgRcvdInstrumenter</class-id> <category>smart watch</category><body package="Debugger-Probes" selector="createSmartWatchLeadString">createSmartWatchLeadString	"ignore, don't need a lead string"</body></methods><methods><class-id>CraftedSmalltalk.PDPMsgRcvdInstrumenter</class-id> <category>breakpoints</category><body package="Debugger-Probes" selector="initializeBreakpointLeadString">initializeBreakpointLeadString	leadString := (#BreakOnDash &lt;&lt; #pdp &gt;&gt; 'Break on - ') asString.</body></methods><methods><class-id>CraftedSmalltalk.PDPMsgRcvdInstrumenter</class-id> <category>reporting</category><body package="Debugger-Probes" selector="report:">report: basicType	| reportStream |	reportStream := WriteStream on: (String new: 200).	reportStream nextPutAll: (self reportStringFor: basicType).	instrumentationRequest == #instrumentSimpleWatch		ifTrue:			[reportStream nextPutAll: ' &lt;';					nextPutAll: iVarName;					nextPut: $&gt;].	reportStream nextPutAll: (#OnMessageReceivedForC &lt;&lt; #pdp &gt;&gt; ' on message received for:') asString; cr.	instrumentationRecords do: [:rec | reportStream cr; nextPutAll: rec printString].	ComposedTextView		open: reportStream contents asText asValue		label: (#ProbeOnMessageReceivedReport &lt;&lt; #pdp &gt;&gt; 'Probe on Message Received Report')		icon: (Icon constantNamed: #workspace)		extent: (500 @ 300).</body></methods><methods><class-id>CraftedSmalltalk.PDPMsgRcvdInstrumenter class</class-id> <category>class initialization</category><body package="Debugger-Probes" selector="initialize">initialize	reportStrings := Dictionary new.	reportStrings at: #instrumentBreakpoint put: (#Breakpoint &lt;&lt; #pdp &gt;&gt; 'Breakpoint') asString.	reportStrings at: #instrumentSmartWatch put: (#SimpleMessageTrace &lt;&lt; #pdp &gt;&gt; 'Simple message trace') asString.	reportStrings at: #instrumentSimpleWatch put: (#InstanceVariableWatchpoint &lt;&lt; #pdp &gt;&gt; 'Instance variable watchpoint') asString.	reportStrings at: #instrumentExpressionWatch put: (#ExpressionWatchpoint &lt;&lt; #pdp &gt;&gt; 'Expression watchpoint') asString."Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.ProbeExpressionEditor</class-id> <category>text</category><body package="Debugger-Probes" selector="accept:from:">accept: aText from: aController	^self acceptText: aText from: aController.</body><body package="Debugger-Probes" selector="text">text	^self subclassResponsibility</body><body package="Debugger-Probes" selector="textAccepted:">textAccepted: aController	^self acceptText: aController text from: aController</body><body package="Debugger-Probes" selector="value">value	^self text</body><body package="Debugger-Probes" selector="value:">value: aText	^self acceptText: aText from: self textController.</body></methods><methods><class-id>CraftedSmalltalk.ProbeExpressionEditor</class-id> <category>private</category><body package="Debugger-Probes" selector="acceptText:from:">acceptText: aText from: aController	| newMethod |	newMethod := ProbeExprCompiler new		compileProbeExpression: aText		forProbe: probe		inClass: probedClass		beginScope: self scope		notifying: aController		ifFail: [^false].	newMethod == nil		ifTrue: [^false].	self newMethodAndSource: newMethod-&gt;aText asString.	self changed: #value.	^true</body><body package="Debugger-Probes" selector="newMethodAndSource:">newMethodAndSource: anAssociation	^self subclassResponsibility</body><body package="Debugger-Probes" selector="scope">scope	^probedMethod isNil		ifTrue: [NameScope forClass: probedClass]		ifFalse: [probedMethod variableMapAt: probe blockMethodIndex]</body></methods><methods><class-id>CraftedSmalltalk.ProbeExpressionEditor</class-id> <category>menu messages</category><body package="Debugger-Probes" selector="addGlobalVariable">addGlobalVariable	| name |	name := (Dialog request: (#EnterTheVariableNameC &lt;&lt; #pdp &gt;&gt; 'Enter the variable name:')) asSymbol.	(PDPManager debugVariables includesKey: name)		ifTrue: [^Dialog warn: (#ThatVariableAreadyExists &lt;&lt; #pdp &gt;&gt; 'That variable aready exists.')].	PDPManager addDebugVariable: name.</body><body package="Debugger-Probes" selector="addLocalVariable">addLocalVariable	| name |	name := (Dialog request: (#EnterTheVariableNameC &lt;&lt; #pdp &gt;&gt; 'Enter the variable name:')) asSymbol.	(probe variables includes: name)		ifTrue: [^Dialog warn: (#ThatVariableAreadyExists &lt;&lt; #pdp &gt;&gt; 'That variable aready exists.')].	probe addVariable: name.</body><body package="Debugger-Probes" selector="insertExpression:from:">insertExpression: existingText from: aController	| expressionNames newName expressionText |	expressionNames := self class expressionNames asArray.	expressionNames isEmpty		ifTrue: [^Dialog warn: (#TheExpressionLibraryIsEmpty &lt;&lt; #pdp &gt;&gt; 'The expression library is empty')].	newName := Dialog 		choose: (#SelectTheExpressionToInsertC &lt;&lt; #pdp &gt;&gt; 'Select the expression to insert:') 		fromList: expressionNames 		values: expressionNames 		lines: 12 		cancel: [^self].	expressionText := (self class atExpName: newName asSymbol) asText.	aController replaceSelectionWith: expressionText</body><body package="Debugger-Probes" selector="insertVariable:from:">insertVariable: a from: aController	| result |	result := self variableMenu startUp.	result = 0		ifTrue: [^self].	aController replaceSelectionWith: result asText.</body><body package="Debugger-Probes" selector="inspectGlobalVariables">inspectGlobalVariables	PDPManager debugVariables isEmpty		ifTrue: [^Dialog warn: (#NoVariablesToInspect &lt;&lt; #pdp &gt;&gt; 'No variables to inspect')].	PDPManager debugVariables inspect</body><body package="Debugger-Probes" selector="inspectLocalVariables">inspectLocalVariables	probe variables isEmpty		ifTrue: [^Dialog warn: (#NoVariablesToInspect &lt;&lt; #pdp &gt;&gt; 'No variables to inspect')].	probe variables inspect</body><body package="Debugger-Probes" selector="saveExpression:from:">saveExpression: existingText from: aController	| name textOrSelection |	name := Dialog		request: #EnterTheExpressionNameC &lt;&lt; #pdp &gt;&gt; 'Enter the expression name:'.	name isEmpty ifTrue: [^self].	(self class includesExpressionName: name) ifTrue:		[(Dialog			confirm:				(#ExprExistsRedefineQ &lt;&lt; #pdp					&gt;&gt; 'That expression aready exists.&lt;n&gt;Do you wish to redefine it?')					expandMacros			initialAnswer: false)				ifFalse: [^self]].	textOrSelection := aController hasRangeSelection		ifTrue: [aController selection]		ifFalse: [aController text].	self class		atExpName: name		put: textOrSelection asString</body></methods><methods><class-id>CraftedSmalltalk.ProbeExpressionEditor</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="buildTextMenu">buildTextMenu	"Build the receiver's text menu."	textMenu := Menu		labelList: ParagraphEditor editGroupLabels,				(OrderedCollection new add: (Array with: (#DoIt &lt;&lt; #pdp &gt;&gt; 'Do it') with: (#PrintIt &lt;&lt; #pdp &gt;&gt; 'Print it') with: (#InspectIt &lt;&lt; #pdp &gt;&gt; 'Inspect it')); add: (Array with: (#Accept &lt;&lt; #pdp &gt;&gt; 'Accept') with: (#Cancel &lt;&lt; #pdp &gt;&gt; 'Cancel')); add: (Array with: (#InsertVar &lt;&lt; #pdp &gt;&gt; 'Insert Var') with: (#DefineDebugVar &lt;&lt; #pdp &gt;&gt; 'Define Debug Var') with: (#InspectDebugVars &lt;&lt; #pdp &gt;&gt; 'Inspect Debug Vars') with: (#ResetMethod &lt;&lt; #pdp &gt;&gt; 'Reset Method')); add: (Array with: (#InsertExpression &lt;&lt; #pdp &gt;&gt; 'Insert Expression') with: (#SaveExpression &lt;&lt; #pdp &gt;&gt; 'Save Expression')); add: (Array with: (#Hardcopy &lt;&lt; #pdp &gt;&gt; 'Hardcopy')); asArray)		values: ParagraphEditor editGroupSelectors ,				#(#doIt #printIt #inspectIt #accept:from: #cancel insertVariable:from:) ,				(Array					with: (Menu							labelArray: (Array with: (#Local &lt;&lt; #pdp &gt;&gt; 'Local') with: (#Global &lt;&lt; #pdp &gt;&gt; 'Global'))							values: (Array										with: [self addLocalVariable]										with: [self addGlobalVariable]))) ,				(Array					with: (Menu							labelArray: (Array with: (#Local &lt;&lt; #pdp &gt;&gt; 'Local') with: (#Global &lt;&lt; #pdp &gt;&gt; 'Global'))							values: (Array										with: [self inspectLocalVariables]										with: [self inspectGlobalVariables]))					with: self resetMethodMenu) ,				#(insertExpression:from: #saveExpression:from: #hardcopy).</body><body package="Debugger-Probes" selector="initialize">initialize	super initialize.	self buildTextMenu.</body><body package="Debugger-Probes" selector="probe:on:class:">probe: aProbe on: aMethod class: aClass	probedMethod := aMethod.	probedClass := aClass.	probe := aProbe.</body><body package="Debugger-Probes" selector="resetMethodMenu">resetMethodMenu	self subclassResponsibility</body></methods><methods><class-id>CraftedSmalltalk.ProbeExpressionEditor</class-id> <category>evaluation</category><body package="Debugger-Probes" selector="doItReceiver">doItReceiver	^probe</body></methods><methods><class-id>CraftedSmalltalk.ProbeExpressionEditor</class-id> <category>accessing</category><body package="Debugger-Probes" selector="editor">editor	^self</body><body package="Debugger-Probes" selector="nameScope">nameScope	^NameScope forClass: probedClass</body><body package="Debugger-Probes" selector="probe">probe	^probe</body><body package="Debugger-Probes" selector="probedClass">probedClass	^probedClass</body><body package="Debugger-Probes" selector="textController">textController	^(builder componentAt: #textEditor) widget controller</body><body package="Debugger-Probes" selector="turnOffAutoAccept">turnOffAutoAccept	self textController autoAccept: false.</body></methods><methods><class-id>CraftedSmalltalk.ProbeExpressionEditor</class-id> <category>menus</category><body package="Debugger-Probes" selector="textMenu">textMenu	"Answer a Menu of operations on the source code that 	is to be displayed when the operate menu button is 	pressed."	^textMenu</body><body package="Debugger-Probes" selector="variableMenu">variableMenu	"Return a menu of all available variable references."	| tnames inames dnames labels values |	tnames := probedMethod isNil		ifTrue: [#()]		ifFalse: 	[(probedMethod variableMapAt: probe blockMethodIndex) tempNames reject: [:name | name first = $.]].	tnames := tnames asSet asSortedCollection.	tnames := tnames , #('TopOFStack').	inames := self scope allInstVarNames.	dnames := probe variableNames , PDPManager debugVariableNames.	labels := #('Method Temp').	values := Array with: (Menu labelArray: tnames values: tnames).	inames isEmpty		ifFalse:			[labels := labels , #('Instance').			values := values , (Array with: (Menu labelArray: inames values: inames))].	dnames isEmpty		ifFalse:			[labels := labels , #('Debug').			values := values , (Array with: (Menu labelArray: dnames values: dnames))].	^Menu 		labelArray: labels		values: values</body></methods><methods><class-id>CraftedSmalltalk.ProbeExpressionEditor class</class-id> <category>expression library</category><body package="Debugger-Probes" selector="atExpName:">atExpName: aString	^expressionLibrary at: aString asSymbol</body><body package="Debugger-Probes" selector="atExpName:put:">atExpName: aString put: anExpression	^expressionLibrary at: aString asSymbol put: anExpression</body><body package="Debugger-Probes" selector="clearLibrary">clearLibrary	(Dialog 		confirm: (#ThisWillRemoveAllExprsContinueQ &lt;&lt; #pdp &gt;&gt; 'This will remove all expressions from the library.					Continue?'))		ifFalse: [^self].	self initializeLibrary</body><body package="Debugger-Probes" selector="expressionNames">expressionNames	^expressionLibrary keys</body><body package="Debugger-Probes" selector="includesExpressionName:">includesExpressionName: aString	^expressionLibrary includesKey: aString asSymbol"Smalltalk Professional Debug Package Version 1.51 (c) 1997 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="initializeLibrary">initializeLibrary	expressionLibrary := Dictionary new</body><body package="Debugger-Probes" selector="inspectLibrary">inspectLibrary	expressionLibrary inspect</body><body package="Debugger-Probes" selector="libraryFileComment">libraryFileComment	self subclassResponsibility</body><body package="Debugger-Probes" selector="readLibrary">readLibrary	| string |	string := Dialog				requestFileName: (#EnterTheNameOfTheExpressionFile &lt;&lt; #pdp &gt;&gt; 'Enter the name of the expression file')				default: ''				version: #mustBeOld.	string isEmpty		ifTrue: [^self].	self readLibraryFromFile: string asFilename</body><body package="Debugger-Probes" selector="readLibraryFromFile:">readLibraryFromFile: aFilename	| strm |	strm := aFilename readStream.	[(Object readFrom: strm) associationsDo: [:ac | self atExpName: ac key put: ac value]]		ensure: [strm close]</body><body package="Debugger-Probes" selector="saveLibrary">saveLibrary	| string |	string := Dialog				requestFileName: (#EnterTheNameOfTheExpressionFile &lt;&lt; #pdp &gt;&gt; 'Enter the name of the expression file')				default: ''				version: #new.	string isEmpty		ifTrue: [^self].	self saveLibraryToFile: string asFilename</body><body package="Debugger-Probes" selector="saveLibraryToFile:">saveLibraryToFile: aFilename	| strm |	strm := aFilename writeStream.	[strm nextPutAll: self libraryFileComment.	strm cr; cr.	expressionLibrary storeOn: strm]		ensure: [strm close]</body></methods><methods><class-id>CraftedSmalltalk.ProbeActionExpressionEditor</class-id> <category>private</category><body package="Debugger-Probes" selector="newMethodAndSource:">newMethodAndSource: anAssociation	probe actionMethodAndSource: anAssociation.</body></methods><methods><class-id>CraftedSmalltalk.ProbeActionExpressionEditor</class-id> <category>menu messages</category><body package="Debugger-Probes" selector="resetMethod">resetMethod	probe resetActionMethod.	self changed: #value.</body></methods><methods><class-id>CraftedSmalltalk.ProbeActionExpressionEditor</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="resetMethodMenu">resetMethodMenu	^#resetMethod</body></methods><methods><class-id>CraftedSmalltalk.ProbeActionExpressionEditor</class-id> <category>text</category><body package="Debugger-Probes" selector="text">text	^probe actionSource asText</body></methods><methods><class-id>CraftedSmalltalk.ProbeActionExpressionEditor class</class-id> <category>expression library</category><body package="Debugger-Probes" selector="libraryFileComment">libraryFileComment	^(#WatchExpressionLibraryFile &lt;&lt; #pdp &gt;&gt; '"Watch expression library file."') asString</body></methods><methods><class-id>CraftedSmalltalk.ProbeTestExpressionEditor</class-id> <category>private</category><body package="Debugger-Probes" selector="newMethodAndSource:">newMethodAndSource: anAssociation	probe testMethodAndSource: anAssociation.</body></methods><methods><class-id>CraftedSmalltalk.ProbeTestExpressionEditor</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="resetMethodMenu">resetMethodMenu	^Menu		labelList: (Array with: (Array with: (#default &lt;&lt; #pdp &gt;&gt; 'default') with: (#true &lt;&lt; #pdp &gt;&gt; 'true') with: (#false &lt;&lt; #pdp &gt;&gt; 'false')))		values: #(setTestMethodToDefault setTestMethodToTrue setTestMethodToFalse)</body></methods><methods><class-id>CraftedSmalltalk.ProbeTestExpressionEditor</class-id> <category>menu messages</category><body package="Debugger-Probes" selector="setTestMethodToDefault">setTestMethodToDefault	probe setAction.	self changed: #value.</body><body package="Debugger-Probes" selector="setTestMethodToFalse">setTestMethodToFalse	probe setNoAction.	self changed: #value.</body><body package="Debugger-Probes" selector="setTestMethodToTrue">setTestMethodToTrue	probe setAlwaysAction.	self changed: #value.</body></methods><methods><class-id>CraftedSmalltalk.ProbeTestExpressionEditor</class-id> <category>text</category><body package="Debugger-Probes" selector="text">text	^probe testSource asText</body></methods><methods><class-id>CraftedSmalltalk.ProbeTestExpressionEditor class</class-id> <category>expression library</category><body package="Debugger-Probes" selector="libraryFileComment">libraryFileComment	^(#TestExpressionLibraryFile &lt;&lt; #pdp &gt;&gt; '"Test expression library file."') asString</body></methods><methods><class-id>CraftedSmalltalk.DisplayActionProbe</class-id> <category>accessing</category><body package="Debugger-Probes" selector="actionMethod">actionMethod	^actionMethod</body><body package="Debugger-Probes" selector="actionMethodAndSource">actionMethodAndSource	^actionMethod -&gt; actionSource</body><body package="Debugger-Probes" selector="actionMethodAndSource:">actionMethodAndSource: anAssoc	actionMethod := anAssoc key.	actionSource := anAssoc value string.</body><body package="Debugger-Probes" selector="actionSource">actionSource	actionSource notNil		ifTrue: [^actionSource].	actionMethod isNil		ifTrue: [^String new].	^actionMethod getSource string</body><body package="Debugger-Probes" selector="basicActionMethod">basicActionMethod	^actionMethod</body><body package="Debugger-Probes" selector="basicActionSource">basicActionSource	^actionSource</body><body package="Debugger-Probes" selector="compileExpression:inClass:scope:">compileExpression: aString inClass: aClass scope: aScope	| aMethod |	aMethod := ProbeExprCompiler new				compileProbeExpression: aString				forProbe: self				inClass: aClass				beginScope: aScope				notifying: nil				ifFail: [nil].	self actionMethodAndSource: aMethod -&gt; aString</body><body package="Debugger-Probes" selector="editorLabelString">editorLabelString	^(#EditExpressionWatch &lt;&lt; #pdp &gt;&gt; 'Edit Expression Watch') asString</body><body package="Debugger-Probes" selector="reportString">reportString	| str |	^(str := super reportString) isEmpty		ifTrue: [(#ActionExprFailedRecompileDisabled &lt;&lt; #pdp &gt;&gt; 'Action expression failed recompile (probe disabled)') asString]		ifFalse:			[actionMethod == ActionMethod				ifTrue: [(#TestOrActionExprFailedRecompileDisabled &lt;&lt; #pdp &gt;&gt; 'Test expression or action expression failed recompile (probed disabled)') asString]				ifFalse: [str]]</body></methods><methods><class-id>CraftedSmalltalk.DisplayActionProbe</class-id> <category>responses</category><body package="Debugger-Probes" selector="actOn:">actOn: aContext 	(self test: aContext)		ifTrue:			[PDPManager				display: (actionMethod							valueWithReceiver: aContext homeReceiver							arguments: (Array with: aContext with: self))				on: windowID				for: self]</body></methods><methods><class-id>CraftedSmalltalk.DisplayActionProbe</class-id> <category>editor creation</category><body package="Debugger-Probes" selector="createEditorOn:class:">createEditorOn: probedMethod class: probedClass	self forClass: probedClass.	^(ActionProbeEditor on: self in: probedMethod class: probedClass) createEditor</body><body package="Debugger-Probes" selector="makeConditional:replacing:with:">makeConditional: probeSpec replacing: unprobedMethod with: probedMethod	probeSpec isConditional		ifTrue: [self setNoAction]		ifFalse: [self setAction].	self finishSetup.	self openEditorOn: probedMethod andReplace: unprobedMethod</body></methods><methods><class-id>CraftedSmalltalk.DisplayActionProbe</class-id> <category>initialize-release</category><body package="Debugger-Probes" selector="createLabelString">createLabelString	labelString value:		((#ExpressionAt1pIn2s &lt;&lt; #pdp &gt;&gt; 'Expression at &lt;1p&gt; in &lt;2s&gt;')			expandMacrosWith: self characterIndex			with: self methodString)</body><body package="Debugger-Probes" selector="initialize">initialize	super initialize.	actionMethod := ActionMethod.	actionSource := self class initialSource.</body><body package="Debugger-Probes" selector="recompileIfKnownMethods">recompileIfKnownMethods	super recompileIfKnownMethods.	self isDefautActionMethod		ifFalse: [^self].	actionMethod := CodeProbe compileProbeMethod: actionSource inClass: self mclass.</body><body package="Debugger-Probes" selector="resetActionMethod">resetActionMethod	actionMethod := ActionMethod.	actionSource := self class initialSource.</body><body package="Debugger-Probes" selector="updateExpressionsFromTemplate:">updateExpressionsFromTemplate: aProbe	super updateExpressionsFromTemplate: aProbe.	actionSource := aProbe basicActionSource.	actionMethod := self ifNecessaryCopy: aProbe basicActionMethod andRebindFrom: aProbe variables</body><body package="Debugger-Probes" selector="updateExpressionsFromWorkingCopy:">updateExpressionsFromWorkingCopy: aProbe	super updateExpressionsFromWorkingCopy: aProbe.	self actionMethodAndSource: aProbe actionMethodAndSource.</body></methods><methods><class-id>CraftedSmalltalk.DisplayActionProbe</class-id> <category>testing</category><body package="Debugger-Probes" selector="isDefautActionMethod">isDefautActionMethod	^actionMethod == ActionMethod</body></methods><methods><class-id>CraftedSmalltalk.DisplayActionProbe</class-id> <category>saving-loading</category><body package="Debugger-Probes" selector="loadActionExpressionFrom:">loadActionExpressionFrom:  aStream	| fieldName |	fieldName := aStream upTo: Character space.	fieldName = 'ActionExpr:'		ifFalse:			[^self unknowLoadField: fieldName on: aStream expected: 'ActionExpr:'].	actionSource := String readFrom: aStream.	aStream next.	"swallow cr"	actionMethod := nil.</body><body package="Debugger-Probes" selector="loadFrom:">loadFrom: aStream	super loadFrom: aStream.	self loadActionExpressionFrom:  aStream.</body><body package="Debugger-Probes" selector="saveActionExpressionOn:">saveActionExpressionOn:  aStream	aStream nextPutAll: 'ActionExpr: '.	self actionSource printOn: aStream.	aStream cr.</body><body package="Debugger-Probes" selector="saveOn:">saveOn: aStream	super saveOn: aStream.	self saveActionExpressionOn:  aStream.</body></methods><methods><class-id>CraftedSmalltalk.DisplayActionProbe</class-id> <category>expression compiling</category><body package="Debugger-Probes" selector="recompileActionExpressionUsingProbedMethod:">recompileActionExpressionUsingProbedMethod: aMethod	| src meth |	self isDefautActionMethod		ifTrue: [^true].	src := self actionSource.	actionMethod := ActionMethod.		"Reset the method to a sane value in case of failure."	meth := ProbeExprCompiler new		compileProbeExpression: src		forProbe: self		inClass: aMethod mclass		beginScope: (aMethod scopeForProbe: self)		notifying: nil		ifFail: [^false].	self actionMethodAndSource: meth-&gt;src.	^true</body><body package="Debugger-Probes" selector="recompileExpressionsUsingProbedMethod:">recompileExpressionsUsingProbedMethod: aMethod	^(super recompileExpressionsUsingProbedMethod: aMethod) and: 		[self recompileActionExpressionUsingProbedMethod: aMethod]</body></methods><methods><class-id>CraftedSmalltalk.DisplayActionProbe class</class-id> <category>initialization</category><body package="Debugger-Probes" selector="initializeMethods">initializeMethods	ActionMethod := self compileProbeMethod: self initialSource inClass: Object."Smalltalk Professional Debug Package Version 1.5 (c) 1995,1997 Crafted Smalltalk"</body><body package="Debugger-Probes" selector="initialSource">initialSource	^'^'''''"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.DisplayActionProbe class</class-id> <category>testing</category><body package="Debugger-Probes" selector="needsSafeRebinding">needsSafeRebinding	^true</body></methods><methods><class-id>Kernel.MethodInfoRecord</class-id> <category>copying</category><body package="Debugger-Probes" selector="postDcopy">postDcopy	"Complete the deep copy operation.  We don't copy bindings."	completeMap := completeMap basicDcopy.	topNode := topNode basicDcopy.</body></methods><methods><class-id>CraftedSmalltalk.RemovedProbedMethodsBrowser class</class-id> <category>interface specs</category><body package="Debugger-Probes" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #RemovedProbedMethods #defaultString: 'Removed Probed Methods' #catalogID: #pdp) 			#bounds: #(#Rectangle 422 622 958 1068 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#SequenceViewSpec 					#layout: #(#LayoutFrame 0 0 0 0 0 1 0 0.3 ) 					#model: #methodList 					#menu: #menuHolder 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#TextEditorSpec 					#layout: #(#LayoutFrame 0 0 0 0.3 0 1 0 1 ) 					#model: #textHolder ) ) ) )</body></methods><methods><class-id>CraftedSmalltalk.PDPTransientWarning class</class-id> <category>interface specs</category><body package="Debugger-Probes" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #Warning #defaultString: 'Warning' #catalogID: #pdp) 			#bounds: #(#Rectangle 469 621 773 725 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 0 0.5 0.5 0.5 ) 					#name: #warning 					#label: #(#{Kernel.UserMessage} #key: #warning #defaultString: 'warning' #catalogID: #pdp) ) ) ) )</body></methods><methods><class-id>CraftedSmalltalk.CodeProbeEditor class</class-id> <category>interface specs</category><body package="Debugger-Probes" selector="testEditorSpec">testEditorSpec	"Tools.UIPainter new openOnClass: self andSelector: #testEditorSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #ProbeEditor 				#defaultString: 'Probe Editor' 				#catalogID: #pdp ) 			#min: #(#{Core.Point} 462 301 ) 			#bounds: #(#{Graphics.Rectangle} 730 422 1326 849 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -220 1 -35 1 -120 1 -10 1 ) 					#model: #accept 					#label: 					#(#{Kernel.UserMessage} 						#key: #OK 						#defaultString: 'OK' 						#catalogID: #pdp ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -110 1 -35 1 -10 1 -10 1 ) 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #pdp ) 					#defaultable: true ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 0 0 -10 1 -45 1 ) 					#flags: 0 					#majorKey: #{CraftedSmalltalk.ProbeTestExpressionEditor} 					#minorKey: #testEditorSpec 					#clientKey: #testEditor ) ) ) )</body></methods><methods><class-id>CraftedSmalltalk.DisplayProbeEditor class</class-id> <category>interface specs</category><body package="Debugger-Probes" selector="displayEditorSpec">displayEditorSpec	"Tools.UIPainter new openOnClass: self andSelector: #displayEditorSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #ProbeEditor 				#defaultString: 'Probe Editor' 				#catalogID: #pdp ) 			#min: #(#{Core.Point} 522 374 ) 			#bounds: #(#{Graphics.Rectangle} 720 450 1242 824 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 0 0 -180 1 -65 1 ) 					#flags: 0 					#majorKey: #{CraftedSmalltalk.ProbeTestExpressionEditor} 					#minorKey: #testEditorSpec 					#clientKey: #testEditor ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} -160 1 10 0 0 1 241 0 ) 					#flags: 0 					#majorKey: #{CraftedSmalltalk.DisplayProbeEditor} 					#minorKey: #windowParamSpec ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -220 1 -45 1 -120 1 -15 1 ) 					#model: #accept 					#label: 					#(#{Kernel.UserMessage} 						#key: #OK 						#defaultString: 'OK' 						#catalogID: #pdp ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -110 1 -45 1 -10 1 -15 1 ) 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #pdp ) 					#defaultable: true ) ) ) )</body><body package="Debugger-Probes" selector="windowParamSpec">windowParamSpec	"UIPainter new openOnClass: self andSelector: #windowParamSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: '' 			#bounds: #(#Rectangle 578 310 725 471 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#CompositeSpecCollection 					#collection: #(						#(#LabelSpec 							#layout: #(#AlignmentOrigin 0 0.506944 0 0 0.5 0 ) 							#label: #(#{Kernel.UserMessage} #key: #WindowID #defaultString: 'Window ID' #catalogID: #pdp) ) 						#(#InputFieldSpec 							#layout: #(#Rectangle 0 24 144 54 ) 							#name: #idEntry 							#model: #windowID ) 						#(#ActionButtonSpec 							#layout: #(#Rectangle 0 60 144 90 ) 							#model: #selectID 							#label: #(#{Kernel.UserMessage} #key: #SelectIDDots #defaultString: 'Select ID...' #catalogID: #pdp) 							#defaultable: true ) 						#(#ActionButtonSpec 							#layout: #(#Rectangle 0 96 144 126 ) 							#model: #openWatchWindow 							#label: #(#{Kernel.UserMessage} #key: #OpenWindow #defaultString: 'Open Window' #catalogID: #pdp) 							#defaultable: true ) 						#(#ActionButtonSpec 							#layout: #(#Rectangle 0 132 144 162 ) 							#model: #changeLabel 							#label: #(#{Kernel.UserMessage} #key: #ChangeLabel #defaultString: 'Change label' #catalogID: #pdp) 							#defaultable: true ) ) 					#compositeSpec: 					#(#CompositeSpec 						#layout: #(#Rectangle 1 -5 145 157 ) ) ) ) ) )</body><body package="Debugger-Probes" selector="windowParmOpenSpec">windowParmOpenSpec	"UIPainter new openOnClass: self andSelector: #windowParmOpenSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #WindowParameters #defaultString: 'Window Parameters' #catalogID: #pdp) 			#bounds: #(#Rectangle 975 471 1236 761 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -40 0.3 -45 1 40 0.3 -15 1 ) 					#model: #accept 					#label: #(#{Kernel.UserMessage} #key: #Done #defaultString: 'Done' #catalogID: #pdp) 					#defaultable: true ) 				#(#SubCanvasSpec 					#layout: #(#LayoutFrame -75 0.5 48 0 75 0.5 217 0 ) 					#flags: 0 					#majorKey: #DisplayProbeEditor 					#minorKey: #windowParamSpec ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -40 0.7 -45 1 40 0.7 -15 1 ) 					#model: #cancel 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #pdp) 					#defaultable: true ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 11 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #SelectWindowParameters #defaultString: 'Select Window Parameters' #catalogID: #pdp) ) ) ) )</body></methods><methods><class-id>CraftedSmalltalk.PDPIVarRefInstrumenterGUIModel class</class-id> <category>interface specs</category><body package="Debugger-Probes" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #ProbeOnInstanceVariableReference #defaultString: 'Probe on instance variable reference' #catalogID: #pdp) 			#min: #(#Point 611 504 ) 			#bounds: #(#Rectangle 449 338 1060 873 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 6 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #ProbeOnInstanceVariableReference #defaultString: 'Probe on instance variable reference' #catalogID: #pdp) ) 				#(#SequenceViewSpec 					#layout: #(#LayoutFrame 20 0 33 0 -220 1 -55 1 ) 					#model: #listModel 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#CompositeSpecCollection 					#collection: #(						#(#ActionButtonSpec 							#layout: #(#Rectangle 0 0 80 25 ) 							#model: #finishUp 							#isDefault: true 							#label: #(#{Kernel.UserMessage} #key: #Done #defaultString: 'Done' #catalogID: #pdp) 							#defaultable: true ) 						#(#ActionButtonSpec 							#layout: #(#Rectangle 154 0 234 25 ) 							#model: #closeRequest 							#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #pdp) 							#defaultable: true ) ) 					#compositeSpec: 					#(#CompositeSpec 						#layout: #(#AlignmentOrigin 0 0.5 -40 1 0.5 0 ) ) ) 				#(#CompositeSpecCollection 					#collection: #(						#(#LabelSpec 							#layout: #(#Point 0 0 ) 							#label: #(#{Kernel.UserMessage} #key: #SelectedInstanceVariable #defaultString: 'Selected Instance Variable' #catalogID: #pdp) ) 						#(#MenuButtonSpec 							#layout: #(#Rectangle 0 22 177 47 ) 							#name: #ivarMenu 							#model: #ivarMenuModel 							#label: #(#{Kernel.UserMessage} #key: #Select #defaultString: 'Select' #catalogID: #pdp) 							#menu: #ivarMenu ) 						#(#CheckBoxSpec 							#layout: #(#Point 0 56 ) 							#model: #readModel 							#label: #(#{Kernel.UserMessage} #key: #OnRead #defaultString: 'On Read' #catalogID: #pdp) ) 						#(#CheckBoxSpec 							#layout: #(#Point 0 81 ) 							#model: #writeModel 							#label: #(#{Kernel.UserMessage} #key: #OnWrite #defaultString: 'On Write' #catalogID: #pdp) ) 						#(#CheckBoxSpec 							#layout: #(#Point 0 106 ) 							#model: #subclassModel 							#label: #(#{Kernel.UserMessage} #key: #IncludeSubclasses #defaultString: 'Include Subclasses' #catalogID: #pdp) ) 						#(#LabelSpec 							#layout: #(#Point 0 139 ) 							#label: #(#{Kernel.UserMessage} #key: #TypeOfAction #defaultString: 'Type of Action' #catalogID: #pdp) ) 						#(#RadioButtonSpec 							#layout: #(#Point 0 164 ) 							#model: #basicTypeModel 							#label: #(#{Kernel.UserMessage} #key: #Breakpoint #defaultString: 'Breakpoint' #catalogID: #pdp) 							#select: #instrumentBreakpoint ) 						#(#RadioButtonSpec 							#layout: #(#Point 0 189 ) 							#model: #basicTypeModel 							#label: #(#{Kernel.UserMessage} #key: #SmartWatch #defaultString: 'Smart Watch' #catalogID: #pdp) 							#select: #instrumentSmartWatch ) 						#(#RadioButtonSpec 							#layout: #(#Point 0 214 ) 							#model: #basicTypeModel 							#label: #(#{Kernel.UserMessage} #key: #SimpleWatch #defaultString: 'Simple Watch' #catalogID: #pdp) 							#select: #instrumentSimpleWatch ) 						#(#RadioButtonSpec 							#layout: #(#Point 0 239 ) 							#model: #basicTypeModel 							#label: #(#{Kernel.UserMessage} #key: #NSimpleWatches #defaultString: 'N Simple Watches' #catalogID: #pdp) 							#select: #instrumentNSimpleWatches ) 						#(#RadioButtonSpec 							#layout: #(#Point 0 264 ) 							#model: #basicTypeModel 							#label: #(#{Kernel.UserMessage} #key: #ExpressionWatch #defaultString: 'Expression Watch' #catalogID: #pdp) 							#select: #instrumentExpressionWatch ) 						#(#CheckBoxSpec 							#layout: #(#Point 0 289 ) 							#model: #conditionalModel 							#label: #(#{Kernel.UserMessage} #key: #Conditional #defaultString: 'Conditional' #catalogID: #pdp) ) 						#(#CheckBoxSpec 							#layout: #(#Point 0 328 ) 							#name: #winParam 							#model: #winParamModel 							#label: #(#{Kernel.UserMessage} #key: #WindowParameters #defaultString: 'Window Parameters' #catalogID: #pdp) ) 						#(#CheckBoxSpec 							#layout: #(#Point 0 353 ) 							#model: #reportModel 							#label: #(#{Kernel.UserMessage} #key: #GenerateReport #defaultString: 'Generate report' #catalogID: #pdp) ) 						#(#ActionButtonSpec 							#layout: #(#Rectangle 0 391 108 415 ) 							#model: #help 							#label: #(#{Kernel.UserMessage} #key: #Help #defaultString: 'Help' #catalogID: #pdp) 							#defaultable: true ) ) 					#compositeSpec: 					#(#CompositeSpec 						#layout: #(#LayoutFrame -197 1 33 0 -20 1 448 0 ) ) ) ) ) )</body></methods><methods><class-id>CraftedSmalltalk.PDPMsgRcvdInstrumenterGUIModel class</class-id> <category>interface specs</category><body package="Debugger-Probes" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #ProbeOnMessageReceived #defaultString: 'Probe on message received' #catalogID: #pdp) 			#min: #(#Point 611 505 ) 			#bounds: #(#Rectangle 466 505 1077 1040 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 6 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #ProbeOnMessageReceived #defaultString: 'Probe on message received' #catalogID: #pdp) ) 				#(#SequenceViewSpec 					#layout: #(#LayoutFrame 20 0 32 0 -217 1 -56 1 ) 					#model: #listModel 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#CompositeSpecCollection 					#collection: #(						#(#ActionButtonSpec 							#layout: #(#Rectangle 0 0 80 25 ) 							#model: #finishUp 							#label: #(#{Kernel.UserMessage} #key: #Done #defaultString: 'Done' #catalogID: #pdp) 							#isDefault: true 							#defaultable: true ) 						#(#ActionButtonSpec 							#layout: #(#Rectangle 154 0 234 25 ) 							#model: #closeRequest 							#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #pdp) 							#defaultable: true ) ) 					#compositeSpec: 					#(#CompositeSpec 						#layout: #(#AlignmentOrigin 0 0.5 -40 1 0.5 0 ) ) ) 				#(#CompositeSpecCollection 					#collection: #(						#(#MenuButtonSpec 							#layout: #(#Rectangle 0 131 177 156 ) 							#name: #ivarMenu 							#model: #ivarMenuModel 							#label: #(#{Kernel.UserMessage} #key: #Select #defaultString: 'Select' #catalogID: #pdp) 							#menu: #ivarMenu 							#flags: 40) 						#(#CheckBoxSpec 							#layout: #(#Point 0 0 ) 							#model: #subclassModel 							#label: #(#{Kernel.UserMessage} #key: #IncludeSubclasses #defaultString: 'Include Subclasses' #catalogID: #pdp) ) 						#(#LabelSpec 							#layout: #(#Point 0 28 ) 							#label: #(#{Kernel.UserMessage} #key: #TypeOfAction #defaultString: 'Type of Action' #catalogID: #pdp) ) 						#(#RadioButtonSpec 							#layout: #(#Point 0 53 ) 							#model: #basicTypeModel 							#label: #(#{Kernel.UserMessage} #key: #Breakpoint #defaultString: 'Breakpoint' #catalogID: #pdp) 							#select: #instrumentBreakpoint ) 						#(#RadioButtonSpec 							#layout: #(#Point 0 78 ) 							#model: #basicTypeModel 							#label: #(#{Kernel.UserMessage} #key: #SimpleMsgTrace #defaultString: 'Simple Msg Trace' #catalogID: #pdp) 							#select: #instrumentSmartWatch ) 						#(#RadioButtonSpec 							#layout: #(#Point 0 103 ) 							#model: #basicTypeModel 							#label: #(#{Kernel.UserMessage} #key: #IvarWatch #defaultString: 'Ivar Watch' #catalogID: #pdp) 							#select: #instrumentSimpleWatch ) 						#(#RadioButtonSpec 							#layout: #(#Point 0 168 ) 							#model: #basicTypeModel 							#label: #(#{Kernel.UserMessage} #key: #ExpressionWatch #defaultString: 'Expression Watch' #catalogID: #pdp) 							#select: #instrumentExpressionWatch ) 						#(#CheckBoxSpec 							#layout: #(#Point 0 215 ) 							#model: #conditionalModel 							#label: #(#{Kernel.UserMessage} #key: #Conditional #defaultString: 'Conditional' #catalogID: #pdp) ) 						#(#CheckBoxSpec 							#layout: #(#Point 0 254 ) 							#name: #winParam 							#model: #winParamModel 							#label: #(#{Kernel.UserMessage} #key: #WindowParameters #defaultString: 'Window Parameters' #catalogID: #pdp) ) 						#(#CheckBoxSpec 							#layout: #(#Point 0 279 ) 							#model: #reportModel 							#label: #(#{Kernel.UserMessage} #key: #GenerateReport #defaultString: 'Generate report' #catalogID: #pdp) ) 						#(#ActionButtonSpec 							#layout: #(#Rectangle 0 317 108 341 ) 							#model: #help 							#label: #(#{Kernel.UserMessage} #key: #Help #defaultString: 'Help' #catalogID: #pdp) 							#defaultable: true ) ) 					#compositeSpec: 					#(#CompositeSpec 						#layout: #(#LayoutFrame -197 1 32 0 -20 1 373 0 ) ) ) ) ) )</body></methods><methods><class-id>CraftedSmalltalk.PDPMthdListMsgRcvdInstrumenterGUIModel class</class-id> <category>interface specs</category><body package="Debugger-Probes" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #ProbeOnMessageReceived #defaultString: 'Probe on message received' #catalogID: #pdp) 			#min: #(#Point 611 505 ) 			#bounds: #(#Rectangle 466 505 1077 1040 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 6 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #ProbeOnMessageReceived #defaultString: 'Probe on message received' #catalogID: #pdp) ) 				#(#SequenceViewSpec 					#layout: #(#LayoutFrame 20 0 32 0 -217 1 -56 1 ) 					#model: #listModel 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#CompositeSpecCollection 					#collection: #(						#(#ActionButtonSpec 							#layout: #(#Rectangle 0 0 80 25 ) 							#model: #finishUp 							#label: #(#{Kernel.UserMessage} #key: #Done #defaultString: 'Done' #catalogID: #pdp) 							#isDefault: true 							#defaultable: true ) 						#(#ActionButtonSpec 							#layout: #(#Rectangle 154 0 234 25 ) 							#model: #closeRequest 							#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #pdp) 							#defaultable: true ) ) 					#compositeSpec: 					#(#CompositeSpec 						#layout: #(#AlignmentOrigin 0 0.5 -40 1 0.5 0 ) ) ) 				#(#CompositeSpecCollection 					#collection: #(						#(#MenuButtonSpec 							#layout: #(#Rectangle 0 131 177 156 ) 							#name: #ivarMenu 							#model: #ivarMenuModel 							#label: #(#{Kernel.UserMessage} #key: #Select #defaultString: 'Select' #catalogID: #pdp) 							#menu: #ivarMenu 							#flags: 40) 						#(#LabelSpec 							#layout: #(#Point 0 28 ) 							#label: #(#{Kernel.UserMessage} #key: #TypeOfAction #defaultString: 'Type of Action' #catalogID: #pdp) ) 						#(#RadioButtonSpec 							#layout: #(#Point 0 53 ) 							#model: #basicTypeModel 							#label: #(#{Kernel.UserMessage} #key: #Breakpoint #defaultString: 'Breakpoint' #catalogID: #pdp) 							#select: #instrumentBreakpoint ) 						#(#RadioButtonSpec 							#layout: #(#Point 0 78 ) 							#model: #basicTypeModel 							#label: #(#{Kernel.UserMessage} #key: #SimpleMsgTrace #defaultString: 'Simple Msg Trace' #catalogID: #pdp) 							#select: #instrumentSmartWatch ) 						#(#RadioButtonSpec 							#layout: #(#Point 0 103 ) 							#model: #basicTypeModel 							#label: #(#{Kernel.UserMessage} #key: #IvarWatch #defaultString: 'Ivar Watch' #catalogID: #pdp) 							#select: #instrumentSimpleWatch ) 						#(#RadioButtonSpec 							#layout: #(#Point 0 168 ) 							#model: #basicTypeModel 							#label: #(#{Kernel.UserMessage} #key: #ExpressionWatch #defaultString: 'Expression Watch' #catalogID: #pdp) 							#select: #instrumentExpressionWatch ) 						#(#CheckBoxSpec 							#layout: #(#Point 0 215 ) 							#model: #conditionalModel 							#label: #(#{Kernel.UserMessage} #key: #Conditional #defaultString: 'Conditional' #catalogID: #pdp) ) 						#(#CheckBoxSpec 							#layout: #(#Point 0 254 ) 							#name: #winParam 							#model: #winParamModel 							#label: #(#{Kernel.UserMessage} #key: #WindowParameters #defaultString: 'Window Parameters' #catalogID: #pdp) ) 						#(#CheckBoxSpec 							#layout: #(#Point 0 279 ) 							#model: #reportModel 							#label: #(#{Kernel.UserMessage} #key: #GenerateReport #defaultString: 'Generate report' #catalogID: #pdp) ) 						#(#ActionButtonSpec 							#layout: #(#Rectangle 0 317 108 341 ) 							#model: #help 							#label: #(#{Kernel.UserMessage} #key: #Help #defaultString: 'Help' #catalogID: #pdp) 							#defaultable: true ) ) 					#compositeSpec: 					#(#CompositeSpec 						#layout: #(#LayoutFrame -197 1 32 0 -20 1 373 0 ) ) ) ) ) )</body></methods><methods><class-id>CraftedSmalltalk.PDPManager class</class-id> <category>interface specs</category><body package="Debugger-Probes" selector="aboutSpec">aboutSpec	"UIPainter new openOnClass: self andSelector: #aboutSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #sizeType #specifiedSize #positionType #screenCenter #openType #advanced ) 			#label: #(#{Kernel.UserMessage} #key: #AboutSPDP #defaultString: 'About SPDP' #catalogID: #pdp) 			#min: #(#{Core.Point} 319 180 ) 			#max: #(#{Core.Point} 319 180 ) 			#bounds: #(#{Graphics.Rectangle} 644 506 963 686 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 5 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #SmalltalkProfessionalDebugPackage #defaultString: 'Smalltalk Professional Debug Package' #catalogID: #pdp) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 30 0 0.5 0 ) 					#label: #versionLabel ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 140 0 0.5 0 ) 					#model: #ok 					#label: #(#{Kernel.UserMessage} #key: #Ok #defaultString: 'Ok' #catalogID: #pdp) 					#isDefault: true 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 58 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #Copyright2002CraftedSmalltalk #defaultString: 'Copyright 2002, Crafted Smalltalk ' #catalogID: #pdp) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 64 90 ) 					#label: #(#{Kernel.UserMessage} #key: #EmailCTraymondcraftedsmalltalkcom #defaultString: 'Email:   traymond@craftedsmalltalk.com' #catalogID: #pdp) ) ) ) )</body></methods><methods><class-id>CraftedSmalltalk.ActionProbeEditor class</class-id> <category>interface specs</category><body package="Debugger-Probes" selector="actionEditorSpec">actionEditorSpec	"Tools.UIPainter new openOnClass: self andSelector: #actionEditorSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #ProbeEditor 				#defaultString: 'Probe Editor' 				#catalogID: #pdp ) 			#min: #(#{Core.Point} 494 500 ) 			#bounds: #(#{Graphics.Rectangle} 737 348 1231 848 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 0 0 -180 1 -10 0.5 ) 					#flags: 0 					#majorKey: #{CraftedSmalltalk.ProbeTestExpressionEditor} 					#minorKey: #testEditorSpec 					#clientKey: #testEditor ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 -10 0.5 -180 1 -60 1 ) 					#flags: 0 					#majorKey: #{CraftedSmalltalk.ProbeActionExpressionEditor} 					#minorKey: #watchExpressionEditorSpec 					#clientKey: #actionEditor ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} -170 1 10 0 0 1 255 0 ) 					#flags: 0 					#majorKey: #{CraftedSmalltalk.DisplayProbeEditor} 					#minorKey: #windowParamSpec ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -220 1 -45 1 -120 1 -15 1 ) 					#model: #accept 					#label: 					#(#{Kernel.UserMessage} 						#key: #OK 						#defaultString: 'OK' 						#catalogID: #pdp ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -110 1 -45 1 -10 1 -15 1 ) 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #pdp ) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>CraftedSmalltalk.ProbeActionExpressionEditor class</class-id> <category>interface specs</category><body package="Debugger-Probes" selector="watchExpressionEditorSpec">watchExpressionEditorSpec	"Tools.UIPainter new openOnClass: self andSelector: #watchExpressionEditorSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #UnlabeledCanvas 				#defaultString: 'Unlabeled Canvas' 				#catalogID: #pdp ) 			#bounds: #(#{Graphics.Rectangle} 732 439 1328 866 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 30 0 0 1 0 1 ) 					#name: #textEditor 					#model: #editor 					#menu: #textMenu 					#performer: #editor 					#tabRequiresControl: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0 30 0 0 1 ) 					#name: #actionEditor 					#label: 					#(#{Kernel.UserMessage} 						#key: #WatchExpressionC 						#defaultString: 'Watch Expression:' 						#catalogID: #pdp ) ) ) ) )</body></methods><methods><class-id>CraftedSmalltalk.ProbeTestExpressionEditor class</class-id> <category>interface specs</category><body package="Debugger-Probes" selector="testEditorSpec">testEditorSpec	"Tools.UIPainter new openOnClass: self andSelector: #testEditorSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #UnlabeledCanvas 				#defaultString: 'Unlabeled Canvas' 				#catalogID: #pdp ) 			#bounds: #(#{Graphics.Rectangle} 720 450 1316 877 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 30 0 0 1 0 1 ) 					#name: #textEditor 					#model: #editor 					#menu: #textMenu 					#performer: #editor 					#tabRequiresControl: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0 30 0 0 1 ) 					#name: #testEditor 					#label: 					#(#{Kernel.UserMessage} 						#key: #TriggerConditionC 						#defaultString: 'Trigger Condition:' 						#catalogID: #pdp ) ) ) ) )</body></methods><initialize><class-id>CraftedSmalltalk.PDPWeakDictionary</class-id></initialize><initialize><class-id>CraftedSmalltalk.AbstractCodeProbe</class-id></initialize><initialize><class-id>CraftedSmalltalk.CRC32Function</class-id></initialize><initialize><class-id>CraftedSmalltalk.PDPIVarReferenceInstrumenter</class-id></initialize><initialize><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id></initialize><initialize><class-id>CraftedSmalltalk.BreakInterrupt</class-id></initialize><initialize><class-id>CraftedSmalltalk.PDPManager</class-id></initialize><initialize><class-id>CraftedSmalltalk.PDPMsgRcvdInstrumenter</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Association</name><environment>Core</environment><super>Core.LookupKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>Compiler</name><environment>Kernel</environment><super>Kernel.SmalltalkCompiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Public Access</category><attributes><package>System-Compiler-Public Access</package></attributes></class><class><name>InstructionStream</name><environment>Kernel</environment><super>Kernel.InstructionClient</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method pc </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>MethodInfoRecord</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bindings completeMap topNode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Support</category><attributes><package>System-Compiler-Support</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>CompilerErrorHandler</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>failBlock retryBlock class selector errorHandlers environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Support</category><attributes><package>System-Compiler-Support</package></attributes></class><class><name>GenericException</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>messageText originator initialContext firstUnwindContext handlerContext parameter proceedBlock isResumable signal searchContext </inst-vars><class-inst-vars>notifierString </class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>ControlInterrupt</name><environment>Core</environment><super>Core.GenericException</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isInterrupt </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>CompiledBlock</name><environment>Kernel</environment><super>Kernel.CompiledCode</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>outerMethod </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>TextCollector</name><environment>UI</environment><super>UI.ValueHolder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>entryStream characterLimit writeSequencer nextEntry autoFlush </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Support</category><attributes><package>Interface-Support</package></attributes></class><class><name>TextCollectorView</name><environment>UI</environment><super>UI.ComposedTextView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>appendEntryMutex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>VariableDefinition</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Names and Scopes</category><attributes><package>System-Compiler-Names and Scopes</package></attributes></class><class><name>CompiledMethod</name><environment>Kernel</environment><super>Kernel.CompiledMainBlock</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>mclass sourceCode </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>RemoteVariable</name><environment>Kernel</environment><super>Kernel.VariableDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contextNode index </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Names and Scopes</category><attributes><package>System-Compiler-Names and Scopes</package></attributes></class><class><name>Parser</name><environment>Kernel</environment><super>Kernel.Scanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder requestor oldLanguage newLanguage extendedLanguage parseNode failBlock endTemps targetClass environment topEnvironment bindingRefs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Public Access</category><attributes><package>System-Compiler-Public Access</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class></st-source>