<?xml version="1.0"?><st-source><!-- Name: Debugger-UIComment: PDP Debugger for VW 7.DbIdentifier: bear73DbTrace: 53338DevelopmentPrerequisites: #(#(#any 'Debugger-StackInspector' '') #(#any 'Debugger-Exception-Modifications' ''))PackageName: Debugger-UIParcel: #('Debugger-UI')PrerequisiteParcels: #(#('Debugger-StackInspector' '') #('Debugger-Exception-Modifications' ''))PrintStringCache: (7.3.1 - 1.3,bobw)Version: 7.3.1Post-Load Block: 	[ :pkg |  Notifier beDevelopment.]Post-Unload Block: 	[        Notifier beDevelopment]Date: 5:54:20 pm April 10, 2005 --><time-stamp>From VisualWorksÂ®, 7.3.1 of April 10, 2005 on April 10, 2005 at 5:54:20 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ContextListPolicy</name><environment>CraftedSmalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>debugger stackLimit stack filteredStack displayAllLimit patterns conversionSymbol matchSymbol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>Debugger-UI</package></attributes></class><class><name>RestartSignal</name><environment>CraftedSmalltalk</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Dbgr support</category><attributes><package>Debugger-UI</package></attributes></class><class><name>DebugProbeInserter</name><environment>CraftedSmalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>probedMethod contextHomeMethod origPermMethod probeSpec homeContext probeRecord probe tempMethod tempProbe debugger exitBlock addToTempMethods </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Dbgr support</category><attributes><package>Debugger-UI</package></attributes></class><comment><class-id>CraftedSmalltalk.DebugProbeInserter</class-id><body>DebugProbeInserter	Version 1.0Copyright 1998 Crafted SmalltalkAll Rights ReservedThis class is used by the debugger to insert a probe into a method.  It used to be a single methodin Debugger but allowing the insertion operation to be restarted would have made the method too messy.This occurs if the inserter determines that the method needs to be converted to a full block methodand the context has not been stepped, i.e. it is at the beginning of the method.Because we can insert temporary probes using the debugger, we must provide a temporary method (unbound)so temp probes will not be inserted in the permanent method.  Furthermore, permanent probesmust appear to be the same in the temporary method and permanent method so when the usermodifies the probe, the change is reflected in both places.  However, the probe cannot be identicalbe cause it may not occupy the same pc position in each method.  To accomplish this, eachpermanent probe in a temporary method is a ProbeClone of the probe in the permanent method.Instance Variables:	addToTempMethods		&lt;Boolean&gt;	This variable indicates that the temp method must be added to								the debugger's temp methods, i.e. it is a new temp method. 	debugger				&lt;Debugger&gt;		The debugger.	exitBlock 				&lt;BlockClosure&gt;	This block is used to provide a non-local return so an immediate								exit from the probe insertion operation can be done from any method.	homeContext			&lt;MethodContext&gt;	The home context of the selected method.	origPermMethod			&lt;CompiledMethod | ProbedCompiledMethod&gt;	This is the method in the method dictionary								before the probe is inserted.	probe					&lt;CodeProbe&gt;	The probe inserted into the probedMethod.	probedMethod			&lt;ProbedCompiledMethod&gt;	This method will have a probe inserted, and then it will be put								into the method dictionary if the probe is a permanent probe.	probeSpec				&lt;ProbeSpec&gt;	probeRecord			&lt;ProbeRecord&gt;	tempMethod			&lt;ProbedCompiledMethod&gt;	This method will have a probe inserted, but it will exist only until								the home context exits.	tempProbe				&lt;CodeProbe&gt;	The probe inserted into the tempMethod.Class Variables:	RestartSignal			&lt;Signal&gt;	Raising this signal causes the insertion operation to be restarted.								This happens if the selected method was changed to a full block method.</body></comment><class><name>DebuggerClient</name><environment>CraftedSmalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>service tags contextIndex busy text parsedSource parseTree stackList stackEmphases enableStackFiltering shortClassNames closeAction terminated </inst-vars><class-inst-vars>menuHolder </class-inst-vars><imports>			Refactory.Browser.BrowserEnvironment			Refactory.Browser.RefactoringBrowser			Refactory.Browser.RBParser			</imports><category>Tools-Programming</category><attributes><package>Debugger-UI</package></attributes></class><class><name>StepIntoBlockNotification</name><environment>CraftedSmalltalk</environment><super>Core.UserInterrupt</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Dbgr support</category><attributes><package>Debugger-UI</package></attributes></class><class><name>ServerContextPatternSpec</name><environment>CraftedSmalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pattern name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>Debugger-UI</package></attributes></class><class><name>DebugTempProbeInserter</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.DebugProbeInserter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Dbgr support</category><attributes><package>Debugger-UI</package></attributes></class><class><name>ContextListPolicyEditor</name><environment>CraftedSmalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>patternList matchSelector conversionSelector selection colorHolder displayAllLimit buffer undoBuffer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>Debugger-UI</package></attributes></class><class><name>ContextDumpPolicy</name><environment>CraftedSmalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stack stream numberToDump errorMessage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>Debugger-UI</package></attributes></class><class><name>ClientContextPatternSpec</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.ServerContextPatternSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>color </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>Debugger-UI</package></attributes></class><shared-variable><name>PlaceToolbarBelowContexts</name><environment>CraftedSmalltalk.DebuggerClient</environment><private>false</private><constant>false</constant><category>settings</category><initializer>false</initializer><attributes><package>Debugger-UI</package></attributes></shared-variable><shared-variable><name>DisplayAllLimit</name><environment>CraftedSmalltalk.ContextListPolicyEditor</environment><private>false</private><constant>false</constant><category>variables</category><initializer>5</initializer><attributes><package>Debugger-UI</package></attributes></shared-variable><shared-variable><name>ConversionSelector</name><environment>CraftedSmalltalk.ContextListPolicyEditor</environment><private>false</private><constant>false</constant><category>variables</category><initializer>#yourself</initializer><attributes><package>Debugger-UI</package></attributes></shared-variable><shared-variable><name>HelpText</name><environment>CraftedSmalltalk.ContextListPolicyEditor</environment><private>false</private><constant>false</constant><category>variables</category><initializer>(Text string: 'The ContextListPolicyEditor is used to create and modify the context list policy.  To understand how this editor works it one should first understand how the context list policy works.Context list policyThe basic concept is that the context list policy matches each context against a sequence of patterns.  If a pattern match is found, the context is displayed in the color associated with the pattern.  If no match is found then the context is filtered from the list.  If there is more than one pattern that will match, it is the first one in the list that is used.More specifically however, the filtering process begins after the number of contexts specified by "Display all limit" have been collected.  This means that the most recent message sends will always be displayed.  If a context is before the Display All Limit and is not matched, it will be displayed in the normal default color for text.When matching a context the policy creates a string to represent the context using the following template:	$P$package or parcel name$C$class name$S$selectorFor example, if you want to display every message send in one of the Collection packages the pattern would be.	$P$*Collections*The "class name" is the absolute class name so it contains the namespace path from Smalltalk.In addition the policy has hooks to allow a pattern matcher other than the VW builtin string patterns to be used.  This is done by specifying the "Conversion selector" and the "Match selector".  For example, if the Regex11 parcel is loaded the "Conversion selector" would be #asRegex and the "Match selector" would be #matches:.A useful setup that would display all contexts but emphasize the more interesting ones would be;MyStuff - *$C$MyNamespace.* - ColorValue redAllElse - * - ColorValue darkGrayContextListPolicyEditorPatterns	This is the list of patterns.  Each pattern has a name which is used for two purposes. First, for the user to identify the pattern.  Second, this is associates the pattern to its color.  If there is more than one pattern with the same name then the contexts that match these patterns will be displayed using the color of the last duplicate name in the list.Reordering	The list can be reordered by simply dragging the list item to the desired location.Menu commands	New - This command will create a new pattern and insert it after the selected pattern.  If no pattern is selected then it will be inserted at the beginning of the list.	Remove - Removes the selected pattern from the list.	Undo - This command will undo last command performed on the selected pattern.  There is no limit to the undo buffer.	Copy - This command makes a copy of the selected pattern in a buffer.	Paste -This command will insert a copy of buffer after the selected pattern.Buttons and fieldsNew	See Menu commands - New.Remove	See Menu commands - Remove.Name	Entry field for the pattern namePick color	Opens a color picker for changing the  color of the selected pattern.Pattern string	The actual pattern string.Match selector	This field specifies the selector to be sent to the converted string for matching.Conversion selector	This field specifies the selector to send to the pattern string to compile into a pattern object.  This is needed for regex patterns.Display all limit	This field specifies the limit where all contexts are displayed.' runs: (Core.RunArray runs: #(186 19 816 22 3 10 3 8 440 7 287 23 10 361 10 87 14 1 3 167 6 48 4 114 4 67 5 73 18 2 3 28 6 31 4 36 10 73 14 30 14 86 19 137 17 66) values: #(nil #bold nil #italic nil #italic nil #italic nil #bold nil #bold #underline nil #underline nil #italic nil #(#underline #italic) nil #(#underline #italic) nil #(#underline #italic) nil #(#underline #italic) nil #(#underline #italic) nil #italic nil #underline nil #underline nil #underline nil #underline nil #underline nil #underline nil #underline nil #underline nil))) asValue</initializer><attributes><package>Debugger-UI</package></attributes></shared-variable><shared-variable><name>MatchSelector</name><environment>CraftedSmalltalk.ContextListPolicyEditor</environment><private>false</private><constant>false</constant><category>variables</category><initializer>#match:</initializer><attributes><package>Debugger-UI</package></attributes></shared-variable><shared-variable><name>Patterns</name><environment>CraftedSmalltalk.ContextListPolicyEditor</environment><private>false</private><constant>false</constant><category>variables</category><initializer>Array new.</initializer><attributes><package>Debugger-UI</package></attributes></shared-variable><methods><class-id>CraftedSmalltalk.ContextListPolicy</class-id> <category>list management</category><body package="Debugger-UI" selector="componentStringFor:">componentStringFor: aMethod	| strm sel pkgs prcls |	strm := WriteStream on: (String new: 64).	sel := aMethod selector.	#{Store.Registry} ifDefinedDo:		[:reg |		pkgs := reg allContainingPackagesForSelector: sel class: aMethod mclass.		pkgs isEmpty			ifFalse: [strm nextPutAll: '$P$'; nextPutAll: pkgs last printString]].	pkgs isNil	"store not loaded"		ifTrue:			[prcls := Parcel parcelsDefiningSelector: sel inClass: aMethod mclass.			prcls isEmpty				ifFalse: [strm nextPutAll: '$P$'; nextPutAll: (prcls detect: [:p | true]) name]].	strm nextPutAll: '$C$'; nextPutAll: aMethod mclass absoluteName.	strm nextPutAll: '$S$'; nextPutAll: sel.	^strm contents</body><body package="Debugger-UI" selector="computeContextList">computeContextList	| stk ctx n includesSelectedCtx selectedContext |	selectedContext := debugger context.	includesSelectedCtx := selectedContext isNil.	stk := WriteStream on: (Array new: stackLimit).	ctx := debugger topContext.	n := 0.	[ctx == nil or: [(includesSelectedCtx or: [includesSelectedCtx := ctx == selectedContext]) and: [(n := n+1) &gt; stackLimit]]]		whileFalse:			[stk nextPut: ctx.			ctx := ctx sender].	stackLimit := n max: stackLimit.	stack := stk contents.	filteredStack := nil.</body><body package="Debugger-UI" selector="filterStack">filterStack	filteredStack := OrderedCollection new.	patterns isEmpty		ifTrue:			[1 to: stack size do: 				[:i | filteredStack add: (Array with: (stack at: i) printString with: i with: nil).].			^filteredStack].	1 to: stack size do:		[:i | | context componentString match id |		context := stack at: i.		componentString := self componentStringFor: context method homeMethod.		context isBlockContext ifTrue:			[componentString := '$B$', componentString].		match := patterns detect: [:pat | pat pattern perform: matchSymbol with: componentString] ifNone: [nil].		id := match notNil			ifTrue: [match name]			ifFalse: [nil].		(id notNil or: [i &lt;= displayAllLimit])			ifTrue: [filteredStack add: (Array with: context printString with: i with: id)]].	^filteredStack</body><body package="Debugger-UI" selector="moreStack">moreStack	self isFullStack		ifTrue: [^false].	stackLimit := stackLimit * 2.	^true</body></methods><methods><class-id>CraftedSmalltalk.ContextListPolicy</class-id> <category>accessing</category><body package="Debugger-UI" selector="contextList">contextList	^stack</body><body package="Debugger-UI" selector="contextSelectedAt:">contextSelectedAt: anIndex	anIndex &lt; 1 		ifTrue: [^nil].	(anIndex &lt;= displayAllLimit and: [stack size &gt;= anIndex])		ifTrue: [^stack at: anIndex].	filteredStack size &lt; anIndex		ifTrue: [^nil].	^stack at: ((filteredStack at: anIndex) at: 2)</body><body package="Debugger-UI" selector="conversionSymbol:">conversionSymbol: aSymbol	conversionSymbol := aSymbol.	self convertPatterns.</body><body package="Debugger-UI" selector="debugger:">debugger: aDebuggerService	debugger := aDebuggerService</body><body package="Debugger-UI" selector="displayAllLimit:">displayAllLimit: anInteger	displayAllLimit := anInteger.	filteredStack := nil.</body><body package="Debugger-UI" selector="filteredStack">filteredStack	filteredStack isNil		ifTrue: [self filterStack].	^filteredStack</body><body package="Debugger-UI" selector="indexOfCurrentContext">indexOfCurrentContext	| idx |	debugger context isNil		ifTrue: [^0].	idx := stack indexOf: debugger context.	1 to: self filteredStack size do: 		[:i |		idx = ((filteredStack at: i) at: 2)			ifTrue: [^i]].	^0</body><body package="Debugger-UI" selector="matchSymbol:">matchSymbol: aSymbol	matchSymbol := aSymbol.	filteredStack := nil.</body><body package="Debugger-UI" selector="patterns:">patterns: anOrderedCollection	patterns := anOrderedCollection.	self convertPatterns.</body><body package="Debugger-UI" selector="stackLimit:">stackLimit: anInteger	stackLimit := anInteger</body></methods><methods><class-id>CraftedSmalltalk.ContextListPolicy</class-id> <category>private</category><body package="Debugger-UI" selector="convertPatterns">convertPatterns	| nuPatterns |	filteredStack := nil.	(patterns isEmpty or: [conversionSymbol isNil])		ifTrue: [^self].	nuPatterns := OrderedCollection new.	patterns do: 		[:ps | 		[nuPatterns add:					((ServerContextPatternSpec new)						pattern: (ps pattern perform: conversionSymbol);						name: ps name;						yourself)] 				on: Error				do:	[:ex | 					Dialog warn: (#ErrorConvertingPattern &lt;&lt; #pdp &gt;&gt; 'Error converting pattern').					ex inspect.					ps inspect.					patterns := nil.					^self]].	patterns := nuPatterns</body></methods><methods><class-id>CraftedSmalltalk.ContextListPolicy</class-id> <category>initialize-release</category><body package="Debugger-UI" selector="initialize">initialize	displayAllLimit := 5.	stackLimit := ObjectMemory current availableFreeBytes &gt; 500000		ifTrue: [500]		ifFalse: [16].	conversionSymbol := #yourself.	patterns := #().</body></methods><methods><class-id>CraftedSmalltalk.ContextListPolicy</class-id> <category>testing</category><body package="Debugger-UI" selector="isFullStack">isFullStack	^stack isEmpty or: [stack last sender isNil]</body></methods><methods><class-id>CraftedSmalltalk.ContextListPolicy class</class-id> <category>instance creation</category><body package="Debugger-UI" selector="debugger:">debugger: aDebuggerService	^self new initialize debugger: aDebuggerService</body></methods><methods><class-id>CraftedSmalltalk.RestartSignal class</class-id> <category>class initialization</category><body package="Debugger-UI" selector="initialize">initialize	notifierString := (#RestartProbeInsertion &lt;&lt; #pdp &gt;&gt; 'Restart probe insertion') asString</body></methods><methods><class-id>CraftedSmalltalk.DebugProbeInserter</class-id> <category>inserting</category><body package="Debugger-UI" selector="addProbe:using:for:">addProbe: aProbeSpec using: aProbeRecord for: aDebugger	debugger := aDebugger.	probeSpec := aProbeSpec.	probeRecord := aProbeRecord.	exitBlock := [:str | ^false -&gt; str].	"non-local exit"	[self basicAddProbe]		on: RestartSignal		do: [:ex | ex restart].	^true -&gt; probe</body></methods><methods><class-id>CraftedSmalltalk.DebugProbeInserter</class-id> <category>private - adjusting</category><body package="Debugger-UI" selector="adjustDynamicsReplacing:with:from:atPC:addProbe:originalPCMap:">adjustDynamicsReplacing: origMethod with: nuMethod from: blkIndex atPC: aPC addProbe: addProbe originalPCMap: oldPCMap	"This method attempts to 'fix' all the contexts and block closures.  However, it cannot fix closures	that are not full closures.  Furthermore, if a closure has been instantiated and does not have	an active context then its method will not be changed to a probed method.  We could find them	by sending allOwnersWeakly: to every block in the method but it could be very time consuming	and not finding them does not appear to create a problem.  We do check two branches; the branch	the current context is in, and the branch containing the block where the probe is to be inserted." 	| nuSelectedBlock origBlock nuBlock methodMap methodsToCheck closuresToFix ctxs ctx depthLimit nuPCMap jumpAmount nuBlocks origBlocks |	homeContext := debugger context supposedHome.	"Construct map to map original blocks to probed blocks."	nuSelectedBlock := nuMethod blockAt: blkIndex.	origBlock := origMethod blockAt: blkIndex.	addProbe		ifTrue:			[depthLimit := ((AuxCodeInfoExtractor new method: nuSelectedBlock) depthAt: aPC) + 3.			jumpAmount := 7]		ifFalse:			[depthLimit := 0.			jumpAmount := -7].	oldPCMap notNil		ifTrue: [nuPCMap := nuMethod sourceMapAt: blkIndex].	"Map blocks to new blocks."	methodMap := IdentityDictionary new.	nuBlocks := nuMethod withAllBlockMethods.	origBlocks := origMethod withAllBlockMethods.	1 to: nuBlocks size do:		[:i |		methodMap at: (origBlocks at: i) put: (nuBlock := nuBlocks at: i).		methodMap at: nuBlock put: nuBlock].	"Create list of blocks to check for exisiting closures."	methodsToCheck := IdentitySet new.	[origBlock ~~ origMethod]		whileTrue:			[methodsToCheck add: origBlock.			origBlock := origBlock outerMethod].	"Get list of active contexts that have homeContext as sender."	closuresToFix := IdentitySet new.	ctxs := IdentitySet with: homeContext.	ctx := debugger topContext.	[ctx == nil or: [ctx == homeContext]]		whileFalse: 			[ctx supposedHome == homeContext				ifTrue:					[ctxs add: ctx.					closuresToFix add: ctx receiver].			ctx := ctx sender].	"The following is executed unpreemptively because it attempts to find and correct	all block contexts whose method is being changed.  This includes block contexts	that are in other processes!!"	[	"Replace method in closures and block contexts that have homeContext as home context."	methodsToCheck do:		[:aMethod |		(aMethod allOwnersWeakly: false) do:			[:obj |			(obj class == BlockClosure and: [obj home == homeContext])				ifTrue: [closuresToFix add: obj].			(obj isBlockContext and: [obj home == homeContext])				ifTrue: [ctxs add: obj]]].	closuresToFix do: [:bc | bc method: (methodMap at: bc method)].	"replace method in block contexts"	ctxs do: [:aCtx | aCtx probeMethod: (methodMap at: aCtx method ifAbsent: [aCtx method])].	self flushMethodCacheFor: methodsToCheck.	ctxs := OrderedCollection new.	blkIndex = 1		ifTrue: [ctxs add: homeContext]		ifFalse:			[(nuSelectedBlock allOwnersWeakly: false) do:				[:obj |				(obj isBlockContext and: [obj sender notNil and: [obj method == nuSelectedBlock]])					ifTrue: [ctxs add: obj]]].	ctxs do:		[:aCtx | | ctxPC i |		(depthLimit &gt; aCtx size)			ifTrue: [aCtx growBy: 3].		(ctxPC := aCtx pc) &gt; aPC			ifTrue:				[oldPCMap notNil					ifTrue:						[i := self findMapIndexFor: ctxPC inMap: oldPCMap.						jumpAmount := (nuPCMap at: i) key - (oldPCMap at: i) key].				aCtx jump: jumpAmount]]	] valueUnpreemptively.</body></methods><methods><class-id>CraftedSmalltalk.DebugProbeInserter</class-id> <category>private</category><body package="Debugger-UI" selector="basicAddProbe">basicAddProbe	self verifyTextUnchanged.	self getAndVerifyHomeContext.	self initializeMethods.	self getProbeRecord.	self verifyProbeSpec.	self verifyFullBlocks.	self makeProbe.	self insertProbeAndFixContext.	self installProbedMethod.</body><body package="Debugger-UI" selector="findMapIndexFor:inMap:">findMapIndexFor: aPC inMap: aMap	"This method does a binary search to find the index of a map entry	corresponding to aPC."	| index low high |	low := 1.	high := aMap size.	[index := high + low // 2.	low &gt; high]		whileFalse: 			[((aMap at: index) key &lt; aPC)				ifTrue: [low := index + 1]				ifFalse: [high := index - 1]].	[(aMap at: low) key &gt; aPC]		whileTrue: [low := low - 1].	(aMap at: low) key = aPC		ifFalse: [low := low + 1].	^low</body><body package="Debugger-UI" selector="flushMethodCacheFor:">flushMethodCacheFor: methods"	| meth |	meth := methods detect: [:m | true].	meth isNil		ifTrue: [^self].	meth := meth homeMethod.	meth mclass flushVMmethodCacheEntriesFor: meth selector.	ObjectMemory compactingGC"	methods do: [:m | m flushCachedVMCode].</body><body package="Debugger-UI" selector="getAndVerifyHomeContext">getAndVerifyHomeContext	homeContext := debugger context home.	homeContext notNil		ifTrue: [^self].	(probeSpec isNil or: [probeSpec isPermanent not])		ifTrue:			[self changeClassTo: DebugTempProbeInserter.			^RestartSignal raise].	exitBlock value: (#PermProbeCannonBeInserted &lt;&lt; #pdp &gt;&gt; '	A permanent probe cannot be inserted.All block closures from the current contextto the home method must be full closures.You can either insert a temporary probe oruse the "make full blocks" command onthe edit menu.').</body><body package="Debugger-UI" selector="getProbeRecord">getProbeRecord	| insertionRange |	insertionRange := probeRecord isNil		ifTrue: [debugger selectionRange]		ifFalse: [probeRecord insertionRange].	probeRecord := tempMethod probeRecordFor: insertionRange.</body><body package="Debugger-UI" selector="initializeMethods">initializeMethods	tempMethod := debugger tempMethods at: homeContext ifAbsent: [].	contextHomeMethod := homeContext method.	origPermMethod := tempMethod isNil		ifTrue: [contextHomeMethod]		ifFalse: [tempMethod permanentMethod].	origPermMethod isProbeable		ifFalse: [exitBlock value: (#CannotInsertProbeIntoThisMethodType &lt;&lt; #pdp &gt;&gt; 'Sorry, probes cannot be inserted into this method type.')].	(addToTempMethods := tempMethod isNil)		ifTrue: [tempMethod := contextHomeMethod newTempProbedMethod].	contextHomeMethod isPartiallyBound		ifFalse: [self changeClassTo: DebugTempProbeInserter]</body><body package="Debugger-UI" selector="insertProbeAndFixContext">insertProbeAndFixContext	| oldPCMap |	"Preserve a copy of the pc map before inserting the probe.  The difference between the	old map and the map after the probe is inserted will be used to adjust the context pc."	oldPCMap := (tempMethod sourceMapAt: probeRecord blockMethodIndex) dcopy.	[tempMethod addProbe: tempProbe]		on: BranchLimit		do:				[:ex |			exitBlock value: (#CannotInsertProbeBranchLimitExceeded &lt;&lt; #pdp &gt;&gt; 'The probe could not be entered because abranch limit in the method was exceeded.').].	addToTempMethods		ifTrue: [debugger tempMethods at: homeContext put: tempMethod].	self		adjustDynamicsReplacing: origPermMethod		with: tempMethod		from: probeRecord blockMethodIndex		atPC: probeRecord insertionPC		addProbe: true		originalPCMap: oldPCMap.</body><body package="Debugger-UI" selector="installProbedMethod">installProbedMethod	| topView mclass |	mclass := tempMethod mclass.	(probe isKindOf: DisplayProbe) | probeSpec isConditional		ifFalse:			[probe finishSetup.			probeSpec isPermanent				ifTrue: [mclass addSelector: debugger selector withMethod: probedMethod].			^self].	topView := probe createEditorOn: probedMethod.	topView model		closeAction: [probeSpec isPermanent						ifTrue: [mclass addSelector: debugger selector withMethod: probedMethod]].	topView open.	^self</body><body package="Debugger-UI" selector="makeFullBlocks">makeFullBlocks 	| stack ctx |	"We can make a full method because we know that no messages have been	sent.  That also means we can copy the stack and replace it after the method	has been recreated.  We do this for insurance, just in case the user manually	put something on the stack and then inserted a probe.  However, we do not copy	a block closure because its method is changed to a ProbedCompiledBlock."	ctx := debugger context.	stack := Array new: ctx stackP.	1 to: stack size do: [:i | stack at: i put: (ctx localAt: i)].	debugger basicMakeFullMethod.	ctx := debugger context.	1 to: stack size do:		[:i | | obj |		((obj := stack at: i) isKindOf: BlockClosure)			ifFalse: [ctx localAt: i put: obj]].	RestartSignal raiseSignal.</body><body package="Debugger-UI" selector="makeProbe">makeProbe	probe := debugger		makeProbeTyped: probeSpec probeClass		using: probeRecord		at: nil		method: tempMethod.	probe isNil		ifTrue: [exitBlock value: nil].			"exit if no probe"	probeSpec isConditional		ifTrue: [probe setNoAction]		ifFalse: [probe setAction].	probeSpec isAutoProbe		ifTrue: [probe setAlwaysAction].	"If a permanent probe is being inserted we must create a new method to put	into the method dictionary."	probeSpec isPermanent		ifTrue:			[probedMethod := (tempMethod mclass compiledMethodAt: debugger selector) newFullProbedMethod.		"A new record must be obtained because there may be more probes in the temp method		than in the perm method which would result in different insertion pcs."			probe record: (probedMethod probeRecordFor: probeRecord insertionRange).			probedMethod addProbe: probe.			tempProbe := ProbeClone parent: probe.			"Set the temp probe's record back to the record from the temp method."			tempProbe record: probeRecord]		ifFalse:			[probe setTemporary.			tempProbe := probe.			probedMethod := tempMethod].</body><body package="Debugger-UI" selector="verifyFullBlocks">verifyFullBlocks	"Make sure that all closures will be full closures."	(tempMethod blockAt: probeRecord blockMethodIndex) isFullBlockChain		ifTrue: [^self].	debugger hasHomeContextStepped		ifFalse: [^self makeFullBlocks].	probeSpec isPermanent		ifTrue:			[exitBlock value: (#PermProbeCannonBeInserted2 &lt;&lt; #pdp &gt;&gt; '	A permanent probe cannot be inserted.All block closures from the selected block tothe compiled method must be full block closures.You can either insert a temporary probe oruse the "make full blocks" command onthe edit menu.').].	self changeClassTo: DebugTempProbeInserter.	RestartSignal raise.</body><body package="Debugger-UI" selector="verifyProbeSpec">verifyProbeSpec	probeSpec notNil		ifTrue: [^self].	"Prompt user for probe selection."	probeSpec := CodeProbe selectDebuggerProbeTypeAsTemp: false.	probeSpec isNil		"Exit if user canceled."		ifTrue: [exitBlock value: nil].</body><body package="Debugger-UI" selector="verifyTextUnchanged">verifyTextUnchanged	debugger changeRequest		ifFalse:			[exitBlock value: (#CannotInsertProbeSourceChanged &lt;&lt; #pdp &gt;&gt; 'A probe cannot be inserted because the source code has changed.')].</body></methods><methods><class-id>CraftedSmalltalk.DebugProbeInserter</class-id> <category>removing</category><body package="Debugger-UI" selector="basicRemoveProbe:">basicRemoveProbe: aProbe	| replacementMethod |	self removeProbe: aProbe fromContextMethod: debugger context.	aProbe isTemporary		ifTrue: [^self].	"Now remove the probe from the stored compiled method."	probedMethod := debugger context mclass compiledMethodAt: aProbe selector.	"Make sure the method actually contains the probe."	(probedMethod isProbed and: [probedMethod includesProbe: aProbe])		ifFalse: [^self].	"If we removed the last probe then revert back to the unprobed compiled method."	probedMethod totalProbes = 1		ifTrue: [replacementMethod := probedMethod originalMethod]		ifFalse:			[replacementMethod := probedMethod newNormalProbedMethod.			replacementMethod removeProbe: aProbe].	probedMethod mclass		addSelector: aProbe selector		withMethod: replacementMethod.</body><body package="Debugger-UI" selector="basicRemoveProbe:fromExistingTemp:">basicRemoveProbe: aProbe fromExistingTemp: aMethod	"This method removes a probe from a temp method and adjusts the	context pc if the probe is a temp probe."		| aCtx breakMethod |	breakMethod := aMethod blockAt: aProbe blockMethodIndex.	breakMethod basicRemoveProbe: aProbe.	aProbe isTemporary		ifFalse: [^self].	aCtx := debugger topContext.	[aCtx == nil]		whileFalse:			[aCtx method == breakMethod &amp; (aCtx pc &gt; aProbe insertionPC)				ifTrue: [aCtx jump: -7].			aCtx := aCtx sender].	self flushMethodCacheFor: (Array with: breakMethod).</body><body package="Debugger-UI" selector="removeAllProbes:from:">removeAllProbes: probes from: aContext	(probes asSortedCollection: [:a1 :a2 | a1 insertionPC &gt; a2 insertionPC])		do: [:p | self removeProbe: p fromContextMethod: aContext].</body><body package="Debugger-UI" selector="removeProbe:fromContextMethod:">removeProbe: aProbe fromContextMethod: aContext		| methodIsTemp |	homeContext := aContext supposedHome.	probedMethod := aContext method homeMethod.	methodIsTemp := debugger tempMethods includesKey: homeContext.	methodIsTemp		ifTrue:			[self basicRemoveProbe: aProbe fromExistingTemp: probedMethod.			aProbe isTemporary				ifTrue: [^self].			tempMethod := probedMethod.			probedMethod := probedMethod originalMethod]		ifFalse:			[tempMethod := probedMethod newTempProbedMethod.			tempMethod removeProbe: aProbe.			debugger tempMethods at: homeContext put: tempMethod].	self		adjustDynamicsReplacing: probedMethod		with: tempMethod		from: aProbe blockMethodIndex		atPC: aProbe insertionPC		addProbe: false		originalPCMap: nil.</body><body package="Debugger-UI" selector="removeProbe:fromExistingTemp:">removeProbe: aProbe fromExistingTemp: aMethod	"This method removes a probe from a temp method and adjusts the	context pc if the probe is a temp probe.  It also flushes the	method cache."		self basicRemoveProbe: aProbe fromExistingTemp: aMethod.</body><body package="Debugger-UI" selector="removeStepProbes:">removeStepProbes: probes	probes do:		[:ac |		self			removeProbe: ac key			fromExistingTemp: ac value method].</body></methods><methods><class-id>CraftedSmalltalk.DebugProbeInserter</class-id> <category>initialize-release</category><body package="Debugger-UI" selector="for:">for: aDebugger	debugger := aDebugger</body></methods><methods><class-id>CraftedSmalltalk.DebugProbeInserter class</class-id> <category>instance creation</category><body package="Debugger-UI" selector="addProbe:using:for:">addProbe: aProbeSpec using: aProbeRecord for: aDebugger	^self new addProbe: aProbeSpec using: aProbeRecord for: aDebugger"Smalltalk Professional Debug Package Version 1.6 (c) 1998 Crafted Smalltalk"</body><body package="Debugger-UI" selector="for:">for: aDebugger	^self new for: aDebugger</body></methods><methods><class-id>CraftedSmalltalk.DebuggerClient</class-id> <category>accessing</category><body package="Debugger-UI" selector="abortDebugging">abortDebugging	self abortDebugOperation.</body><body package="Debugger-UI" selector="contextChanged">contextChanged	contextIndex := stackList selectionIndex.	service selectContextAt: contextIndex.	self buttonEnablement.</body><body package="Debugger-UI" selector="ctrlyAbort">ctrlyAbort	"ignore, done by service"</body><body package="Debugger-UI" selector="isBusy">isBusy	^busy</body><body package="Debugger-UI" selector="service:">service: aDebuggerService	service := aDebuggerService.	tags := service tagMenuList.	service addDependent: self</body><body package="Debugger-UI" selector="shortClassNames">shortClassNames	^shortClassNames</body><body package="Debugger-UI" selector="stackFilteringEnabled">stackFilteringEnabled	^enableStackFiltering</body><body package="Debugger-UI" selector="toolbarView">toolbarView	| lookPolicy |	lookPolicy := LookPreferences widgetPolicy lookPolicyClass new.	^lookPolicy toolBarClass menu: self class toolbarMenu performer: self</body></methods><methods><class-id>CraftedSmalltalk.DebuggerClient</class-id> <category>actions</category><body package="Debugger-UI" selector="abortDebugOperation">abortDebugOperation	busy		ifFalse: [^self].	service abortDebugOperation</body><body package="Debugger-UI" selector="abortDebugOperationInProcess:">abortDebugOperationInProcess: proc	busy		ifFalse: [^proc debug].	service abortDebugOperation</body><body package="Debugger-UI" selector="continue">continue	"Continue execution from the interrupted state of the top context."	service hasSuspendedOperations		ifTrue: [^Dialog warn: (#YouMustCompleteOperationBeforeContinuing &lt;&lt; #pdp &gt;&gt; 'You must complete the suspended debugger operationsbefore continuing process execution.')].	closeAction := #continue.	self closeRequest.</body><body package="Debugger-UI" selector="copyStack">copyStack	ParagraphEditor currentSelection: service stackForCopy</body><body package="Debugger-UI" selector="correctSpelling">correctSpelling	"Attempt to correct the spelling of the not-understood message"	| selectors guess nArgs |	selectors := service possibleDNUCorrections.	selectors isEmpty		ifTrue:			[nArgs := service dnuSelector numArgs.			[guess := (Dialog request: (#CouldNotCorrectEnterNewSelectorC &lt;&lt; #pdp &gt;&gt; 'Could not correct. Enter new selector:')) asSymbol.			nArgs = guess numArgs]				whileFalse:					[(Dialog confirm: (#NumArgsMustNotChangeRetryQ &lt;&lt; #pdp &gt;&gt; 'The number of arguments must not change.Retry?'))						ifFalse: [^self]]]		ifFalse:			[selectors := selectors asArray.			guess := Dialog				choose: (#CorrectToC &lt;&lt; #pdp &gt;&gt; 'Correct to:')				fromList: selectors				values: selectors				lines: 8				cancel: [^'']				for: nil.].	(Dialog confirm: ((#RetryWithSelectorCnt1s &lt;&lt; #pdp &gt;&gt; 'Retry with Selector:&lt;nt&gt;&lt;1s&gt;')			expandMacrosWith: guess) for: self interfaceWindow)		ifFalse: [^self].	self performDebugOperation: #correctDNUWith: with: guess.</body><body package="Debugger-UI" selector="defineMethod">defineMethod	self changeRequest		ifFalse:			[^Dialog warn: (#CannotPerformOperationSrcChanged &lt;&lt; #pdp &gt;&gt; 'The operation cannot be performed because the source code has changed.')].	self performDebugOperation: #defineMethod.</body><body package="Debugger-UI" selector="firstLoop">firstLoop	self changeRequest		ifFalse:			[^Dialog warn: (#CannotPerformOperationSrcChanged &lt;&lt; #pdp &gt;&gt; 'The operation cannot be performed because the source code has changed.')].	self performDebugOperation: #firstLoop.</body><body package="Debugger-UI" selector="inspectContext">inspectContext	service inspectCurrentContext</body><body package="Debugger-UI" selector="jumpToCaret">jumpToCaret	"Finds the closest proper point before the caret and causes the context to jump to it,	then completely pops the context stack.  Proper jump points cannot be inside a loop,	or cannot be after loop preperation, and must have a stack depth of 0.  Also, jumps	into or out of blocks are not permitted."	self changeRequest		ifFalse:			[^Dialog warn: (#CannotPerformOperationSrcChanged &lt;&lt; #pdp &gt;&gt; 'The operation cannot be performed because the source code has changed.')].	self performDebugOperation: #jumpToCaretAt: with: self textController selectionRange.</body><body package="Debugger-UI" selector="makeFullMethod">makeFullMethod	service isMethodContextSelected		ifFalse:			[^Dialog warn: (#ContextIsNotForMethodSelectAnother &lt;&lt; #pdp &gt;&gt; 'The selected context is not a method context.&lt;n&gt;Please select the method context and reissue this command.') expandMacros].	(Dialog choose: (#WillCutStackAndReenter &lt;&lt; #pdp &gt;&gt; 'This command will cut the context stack back to the selected context&lt;n&gt;and re-enter the method.') expandMacros		labels: (Array with: (#Proceed &lt;&lt; #pdp &gt;&gt; 'Proceed') with: (#Cancel &lt;&lt; #pdp &gt;&gt; 'Cancel'))		values: #(true false)		default: false)		ifFalse: [^self].	self performDebugOperation: #makeFullMethod.</body><body package="Debugger-UI" selector="moreStack">moreStack	self canShowMore		ifTrue: [service moreStack]</body><body package="Debugger-UI" selector="nextLoop">nextLoop	self changeRequest		ifFalse:			[^Dialog warn: (#CannotPerformOperationSrcChanged &lt;&lt; #pdp &gt;&gt; 'The operation cannot be performed because the source code has changed.')].	self performDebugOperation: #nextLoop.</body><body package="Debugger-UI" selector="pause">pause	"Places the process back into the paused state and closes the debugger."	service hasSuspendedOperations		ifTrue: [^Dialog warn: (#YouMustCompleteOperationBeforeContinuing &lt;&lt; #pdp &gt;&gt; 'You must complete the suspended debugger operationsbefore continuing process execution.')].	self performDebugOperation: #pause.</body><body package="Debugger-UI" selector="proceed">proceed	"Proceed from the interrupted state of the currently selected context.	Instructions pending execution in methods entered after the selected	context are not executed."	service hasSuspendedOperations		ifTrue: [^Dialog warn: (#YouMustCompleteOperationBeforeContinuing &lt;&lt; #pdp &gt;&gt; 'You must complete the suspended debugger operationsbefore continuing process execution.')].	self performDebugOperation: #proceed.</body><body package="Debugger-UI" selector="reenter">reenter	"Reset to the initial state of the currently selected context, i.e. as if the	context had just been entered."	self performDebugOperation: #reenter.</body><body package="Debugger-UI" selector="restart">restart	"Proceed from the initial state of the currently selected context.	The argument is a controller on a view of the receiver.  That view	is closed."	service hasSuspendedOperations		ifTrue: [^Dialog warn: (#YouMustCompleteOperationBeforeContinuing &lt;&lt; #pdp &gt;&gt; 'You must complete the suspended debugger operationsbefore continuing process execution.')].	self performDebugOperation: #restart.</body><body package="Debugger-UI" selector="return">return	self hasValidContext		ifFalse: [^self].	service isMethodContextSelected		ifTrue: [self returnFromMethodContext]		ifFalse: [self returnFromBlockContext].</body><body package="Debugger-UI" selector="revert">revert	self changeRequest		ifFalse: [^self].	(Dialog confirm: (#RevertToLastPublishedVersionQ &lt;&lt; #pdp &gt;&gt; 'Revert this method to the last published version?')) 				ifFalse: [^self].	^service revert</body><body package="Debugger-UI" selector="selectHomeContext">selectHomeContext	self changeRequest		ifFalse:			[^self].	service selectHomeContext</body><body package="Debugger-UI" selector="send">send	self changeRequest		ifFalse:			[^Dialog warn: (#CannotPerformOperationSrcChanged &lt;&lt; #pdp &gt;&gt; 'The operation cannot be performed because the source code has changed.')].	self performDebugOperation: #send.</body><body package="Debugger-UI" selector="skipToCaret">skipToCaret	self changeRequest		ifFalse:			[^Dialog warn: (#CannotPerformOperationSrcChanged &lt;&lt; #pdp &gt;&gt; 'The operation cannot be performed because the source code has changed.')].	self performDebugOperation: #skipToCaretAt: with: self textController selectionRange.</body><body package="Debugger-UI" selector="step">step	self changeRequest		ifFalse:			[^Dialog warn: (#CannotPerformOperationSrcChanged &lt;&lt; #pdp &gt;&gt; 'The operation cannot be performed because the source code has changed.')].	self performDebugOperation: #step.</body><body package="Debugger-UI" selector="stepIntoBlock">stepIntoBlock	self changeRequest		ifFalse:			[^Dialog warn: (#CannotPerformOperationSrcChanged &lt;&lt; #pdp &gt;&gt; 'The operation cannot be performed because the source code has changed.')].	self performDebugOperation: #stepIntoBlock.</body><body package="Debugger-UI" selector="toggleShortClassNames">toggleShortClassNames	shortClassNames := shortClassNames not.	self refreshContextList.</body><body package="Debugger-UI" selector="toggleStackFiltering">toggleStackFiltering	enableStackFiltering		ifTrue: [self disableStackFiltering]		ifFalse: [self enableStackFiltering].	self refreshAll.</body></methods><methods><class-id>CraftedSmalltalk.DebuggerClient</class-id> <category>menus</category><body package="Debugger-UI" selector="addBookmarkItemsTo:">addBookmarkItemsTo: aMenu	| serviceTags |	serviceTags := service tagMenuList.	serviceTags isEmpty ifFalse: [aMenu addLine].	serviceTags keysAndValuesDo:		[:index :each | | item |		item := index &lt; 10			ifTrue: [MenuItem labeled: ('&amp;&lt;1p&gt;. &lt;2s&gt;' 						expandMacrosWith: index 						with: each)]			ifFalse: [MenuItem labeled: each].		item value: [service selectTag: each].		aMenu addItem: item]</body><body package="Debugger-UI" selector="bookmarkMenu">bookmarkMenu	| menu |	menu := self class bookmarkMenu.	self addBookmarkItemsTo: menu.	(menu atNameKey: #addTag) enabled: self canAddTag.	(menu atNameKey: #removeTag) enabled: self canRemoveTag.	^menu</body><body package="Debugger-UI" selector="contextMenu">contextMenu	| mainMenu |	mainMenu := self class contextMenu.	self setQuerySubmenuBlocksIn: mainMenu.	self setVisibilityForStoreCommandsIn: mainMenu.	(mainMenu atNameKey: #bookmarkMenu) submenu: [self bookmarkMenu].	^mainMenu</body><body package="Debugger-UI" selector="editMenu">editMenu	"Evaluation and clipboard actions shortcuts need to be made	display-only to not steal keystrokes from the widget.	The value also has to be changed to make the widget performs it	when the item is selected using the mouse, because the application	does not understand these actions."	| menu |	menu := self textMenu.	#(cut copySelection paste doIt printIt inspectIt debugIt accept find replace hardcopy) do:		[:each | | item |		item := menu menuItemWithValue: each.		item			value: [self textController perform: each];			makeShortcutDisplayOnly].	^menu</body><body package="Debugger-UI" selector="executeMenu">executeMenu	^self class executeMenu</body><body package="Debugger-UI" selector="setQuerySubmenuBlocksIn:">setQuerySubmenuBlocksIn: aMenu	(aMenu atNameKey: #allSenders) submenu: [self querySubmenuSending: #browseAllReferences:].	(aMenu atNameKey: #allImplementors) submenu: [self querySubmenuSending: #browseAllImplementors:].	(aMenu atNameKey: #localSenders) submenu: [self querySubmenuSending: #browseLocalReferences:].	(aMenu atNameKey: #localImplementors) submenu: [self querySubmenuSending: #browseLocalImplementors:].</body><body package="Debugger-UI" selector="setupMenuBarMenu:">setupMenuBarMenu: aMenu	(aMenu atNameKey: #stackMenu) submenu: [self stackMenu].	(aMenu atNameKey: #editMenu) submenu: self editMenu.	(aMenu atNameKey: #executeMenu) submenu: [self executeMenu].	self setQuerySubmenuBlocksIn: aMenu.	self setVisibilityForStoreCommandsIn: aMenu.</body><body package="Debugger-UI" selector="setVisibilityForStoreCommandsIn:">setVisibilityForStoreCommandsIn: aMenu	| storeNotLoaded mi |	storeNotLoaded := service isStoreLoaded not.	(mi := aMenu atNameKey: #revert) notNil		ifTrue: [mi hidden: storeNotLoaded].	(aMenu atNameKey: #browseVersions) 		ifNotNil: [:item | item hidden: storeNotLoaded].</body><body package="Debugger-UI" selector="stackMenu">stackMenu	| menu |	menu := self class stackMenu.	self addBookmarkItemsTo: menu.	(menu atNameKey: #filterStack) indication: self stackFilteringEnabled.	(menu atNameKey: #toggleShortClassNames) indication: self shortClassNames.	(menu atNameKey: #newTag) enablement: self canIssueContextCommand.	(menu atNameKey: #removeTag) enablement: self canIssueContextCommand.	^menu</body><body package="Debugger-UI" selector="textMenu">textMenu	| pdpMenu |	pdpMenu := self class pdpTextMenuAdditions.	self validateTextProbeMenuItemsInMenu: pdpMenu.	^Menu new		addPart: self class acceptGroup;		addPart: (self withDisabledItemsHidden: self class browseGroup);		addPart: pdpMenu;		addPart: self class evaluateGroup;		addPart: self class editGroup;		addPart: self class hardcopyGroup;		addPart: self class cancelGroup;		yourself</body></methods><methods><class-id>CraftedSmalltalk.DebuggerClient</class-id> <category>probes</category><body package="Debugger-UI" selector="addBreakpoint">addBreakpoint	self changeRequest		ifFalse:			[^Dialog warn: (#CannotInsertBreakSourceChanged &lt;&lt; #pdp &gt;&gt; 'A breakpoint cannot be inserted because the source code has changed.')].	PDPManager debugActive		ifFalse: [PDPTransientWarning on: (#ProbesAreDisabled &lt;&lt; #pdp &gt;&gt; 'Probes are disabled')].	service addBreakpointAt: self textController selectionRange.</body><body package="Debugger-UI" selector="addProbe">addProbe	self changeRequest		ifFalse:			[^Dialog warn: (#CannotInsertProbeSourceChanged &lt;&lt; #pdp &gt;&gt; 'A probe cannot be inserted because the source code has changed.')].	PDPManager debugActive		ifFalse: [PDPTransientWarning on: (#ProbesAreDisabled &lt;&lt; #pdp &gt;&gt; 'Probes are disabled')].	service addProbeAt: self textController selectionRange.</body><body package="Debugger-UI" selector="areTextProbeCommandsLegal">areTextProbeCommandsLegal	^self canIssueContextCommand</body><body package="Debugger-UI" selector="modifyProbe">modifyProbe	| aController |	aController := self textController.	service isProbedMethod		ifFalse: [^aController view invalidate].	service modifyProbeAt: aController selectionRange from: aController text.</body><body package="Debugger-UI" selector="removeAllProbes">removeAllProbes	"Removes all the probes from the selected method."	self textController textHasChanged		ifTrue:			[(Dialog				choose: (#RemovingProbesWillLoseChanges &lt;&lt; #pdp &gt;&gt; 'Removing the probes will result in losing your changes.&lt;n&gt;What do you want do?') expandMacros				labels: (Array with: (#RemoveProbes &lt;&lt; #pdp &gt;&gt; 'Remove Probes') with: (#Cancel &lt;&lt; #pdp &gt;&gt; 'Cancel'))				values: #(true false)				default: false)				ifFalse: [^self]].	service isProbedMethod		ifFalse: [^self textController view invalidate].	service removeAllProbes.</body><body package="Debugger-UI" selector="removeProbe">removeProbe	| aController |	aController := self textController.	aController textHasChanged		ifTrue:			[(Dialog				choose: (#RemovingProbesWillLoseChanges &lt;&lt; #pdp &gt;&gt; 'Removing the probes will result in losing your changes.&lt;n&gt;What do you want do?') expandMacros				labels: (Array with: (#Remove &lt;&lt; #pdp &gt;&gt; 'Remove') with: (#Cancel &lt;&lt; #pdp &gt;&gt; 'Cancel'))				values: #(true false)				default: false)				ifFalse: [^self]].	service isProbedMethod		ifFalse: [^aController view invalidate].	service removeProbeAt: aController selectionRange from: aController text.</body><body package="Debugger-UI" selector="validateTextProbeMenuItemsInMenu:">validateTextProbeMenuItemsInMenu: aMenu	#(insertBreakpoint insertProbe modifyProbe removeSelectedProbe removeAllProbes) do:		[:each |		(aMenu atNameKey: each) enablementSelector: #areTextProbeCommandsLegal]</body></methods><methods><class-id>CraftedSmalltalk.DebuggerClient</class-id> <category>tags</category><body package="Debugger-UI" selector="addTag">addTag	service addTag.	self refreshContextList</body><body package="Debugger-UI" selector="hasTags">hasTags	tags := service tagMenuList.	^tags size &gt; 0</body><body package="Debugger-UI" selector="removeTag">removeTag	service removeTag.	self refreshContextList</body><body package="Debugger-UI" selector="tagMenu">tagMenu	^Menu		labelArray: tags		lines: Array new		values: (tags collect: [:ctx | [service selectTag: ctx]])</body></methods><methods><class-id>CraftedSmalltalk.DebuggerClient</class-id> <category>actions-browsing</category><body package="Debugger-UI" selector="browseAllImplementors">browseAllImplementors	self browseAllImplementors: service selector</body><body package="Debugger-UI" selector="browseAllImplementors:">browseAllImplementors: aSelector	| realSelector mc |	realSelector := aSelector == nil		ifTrue: [self chooseSelector: (#ViewImplementorsnofWhichSelector &lt;&lt; #pdp &gt;&gt; 'View implementors&lt;n&gt;of which selector?')]		ifFalse: [aSelector].	realSelector == nil ifTrue: [^self].	mc := self methodCollector.	^mc browseSelect: (mc implementorsOf: realSelector)</body><body package="Debugger-UI" selector="browseAllReferences:">browseAllReferences: aSelector	| realSelector mc |	realSelector := aSelector == nil		ifTrue: [self chooseSelector: (#ViewSendersnofWhichSelector &lt;&lt; #pdp &gt;&gt; 'View senders&lt;n&gt;of which selector?')]		ifFalse: [aSelector].	realSelector == nil ifTrue: [^self].	mc := self methodCollector.	^mc browseSelect: (mc referencesTo: realSelector)</body><body package="Debugger-UI" selector="browseAllSenders">browseAllSenders	self browseAllReferences: service selector.</body><body package="Debugger-UI" selector="browseClass">browseClass	service browseClass</body><body package="Debugger-UI" selector="browseClassFromSourceView">browseClassFromSourceView	| binding |	binding := self selectedVariableBinding.	binding isNil ifTrue: [^self].	RefactoringBrowser open navigator		setBinding: binding;		changed</body><body package="Debugger-UI" selector="browseClassReferencesFromSourceView">browseClassReferencesFromSourceView	| binding |	binding := self selectedVariableBinding.	binding isNil ifTrue: [^self].	Cursor wait showWhile:		[(BrowserEnvironment new referencesTo: binding) openEditor]</body><body package="Debugger-UI" selector="browseImplementorsFromSourceView">browseImplementorsFromSourceView	| node |	node := self findNode.	(node isNil or: [node isMessage not]) ifTrue: [^self].	(BrowserEnvironment new implementorsOf: node selector) openEditor</body><body package="Debugger-UI" selector="browseInstanceVariableReaders">browseInstanceVariableReaders	self selectedVariableName ifNotNil:		[:name | 		Cursor wait showWhile: 			[(BrowserEnvironment new instVarReadersTo: name in: service selectedClass) openEditor]]</body><body package="Debugger-UI" selector="browseInstanceVariableReferences">browseInstanceVariableReferences	self selectedVariableName ifNotNil:		[:name | 		Cursor wait showWhile: 			[(BrowserEnvironment new instVarRefsTo: name in: service selectedClass) openEditor]]</body><body package="Debugger-UI" selector="browseInstanceVariableWriters">browseInstanceVariableWriters	self selectedVariableName ifNotNil:		[:name | 		Cursor wait showWhile: 			[(BrowserEnvironment new instVarWritersTo: name in: service selectedClass) openEditor]]</body><body package="Debugger-UI" selector="browseLocalImplementors">browseLocalImplementors	self browseLocalImplementors: service selector</body><body package="Debugger-UI" selector="browseLocalImplementors:">browseLocalImplementors: aSelector	| realSelector mc |	realSelector := aSelector == nil		ifTrue: [self chooseSelector: (#ViewLocalImplementorsOfWhichQ &lt;&lt; #pdp &gt;&gt; 'View local implementors&lt;n&gt;of which selector?')]		ifFalse: [aSelector].	realSelector == nil ifTrue: [^self].	mc := self methodCollector.	^mc browseSelect:			(mc searchClassHierarchy: service selectedClass)			&amp; (mc implementorsOf: realSelector)</body><body package="Debugger-UI" selector="browseLocalReferences:">browseLocalReferences: aSelector	| realSelector mc |	realSelector := aSelector == nil		ifTrue: [self chooseSelector: (#ViewLocalSendersnofWhichSelector &lt;&lt; #pdp &gt;&gt; 'View local senders&lt;n&gt;of which selector?')]		ifFalse: [aSelector].	realSelector == nil ifTrue: [^self].	mc := self methodCollector.	^mc browseSelect:			(mc searchClassHierarchy: service selectedClass)			&amp; (mc referencesTo: realSelector)</body><body package="Debugger-UI" selector="browseLocalSenders">browseLocalSenders	self browseLocalReferences: service selector</body><body package="Debugger-UI" selector="browseMethod">browseMethod	service browseMethod</body><body package="Debugger-UI" selector="browseSendersFromSourceView">browseSendersFromSourceView	| node |	node := self findNode.	(node isNil or: [node isMessage not]) ifTrue: [^self].	(BrowserEnvironment new referencesTo: node selector) openEditor</body><body package="Debugger-UI" selector="browseVersions">browseVersions	Store.DbRegistry doIfOnlineImage: 		[ TabApplicationSystemBrowser			browseVersionsOfMethodNamed: service selector 			in: service selectedClass		].</body><body package="Debugger-UI" selector="chooseSelector:">chooseSelector: label	| msgs |	msgs := service selectedMethod allSymbolLiterals asSortedCollection.	^Dialog choose: label expandMacros			fromList: msgs			values: msgs			lines: 20			cancel: []			for: self interfaceWindow</body><body package="Debugger-UI" selector="chooseSelector:from:">chooseSelector: label from: def	| msgs |	msgs := def method allSymbolLiterals asSortedCollection.	^Dialog choose: label expandMacros			fromList: msgs			values: msgs			lines: 20			cancel: []			for: self interfaceWindow</body><body package="Debugger-UI" selector="containingPackage">containingPackage	| pkgs |	pkgs := Store.Registry allContainingPackagesForSelector: service selector class: service selectedClass.	self showPackageList: pkgs loaded:true.</body><body package="Debugger-UI" selector="querySubmenuSending:">querySubmenuSending: aSymbol	| selectors displayedSelectors submenu item methodSelector |	self hasValidContext		ifFalse: [^nil].	selectors := service context method homeMethod allSymbolLiterals.	methodSelector := service selector.	selectors remove: methodSelector ifAbsent: [].	submenu := Menu new.	methodSelector notNil ifTrue:		[item := MenuItem labeled: (methodSelector contractTo: Tools.BrowserHelper.MaxMenuEntryWidth).		item value: [self perform: aSymbol with: methodSelector].		submenu 			addItem: item;			addLine].	selectors isEmpty		ifTrue: [^submenu].	selectors := selectors asSortedCollection.	displayedSelectors := selectors		copyFrom: 1 		to: (selectors size min: Tools.BrowserHelper.MaxSelectorSubMenuEntries).	displayedSelectors do: 		[:each | 		item := MenuItem labeled: (each contractTo: Tools.BrowserHelper.MaxMenuEntryWidth).		item value: [self perform: aSymbol with: each].		submenu addItem: item].	displayedSelectors size ~= selectors size ifTrue:		[submenu addLine.		item := MenuItem labeled: (#MoreSelectorsDots &lt;&lt; #pdp &gt;&gt; 'More selectors...').		item value: [self perform: aSymbol with: nil].		submenu addItem: item].	^submenu</body><body package="Debugger-UI" selector="showPackageList:loaded:">showPackageList: packages loaded: aBoolean	"Show a message box with packages - separating overrides if appropiate."	| str |	packages isEmpty		ifTrue: [ ^Dialog warn: (#NotYetAssignedToAPackage &lt;&lt; #pdp &gt;&gt; 'Not yet assigned to a package') ].	str := ( String new: 50 ) writeStream.	str nextPutAll: packages first itemString; cr.	packages size &gt; 1		ifTrue: 			[ aBoolean				ifTrue: [ str nextPutAll: ( String new: packages first itemString size withAll: $_ ) ; cr ].				2 to: packages size do:					[ :index | | pkg |					pkg := packages at: index.										str nextPutAll: pkg itemString; cr					].			].	Dialog warn: str contents.</body></methods><methods><class-id>CraftedSmalltalk.DebuggerClient</class-id> <category>private</category><body package="Debugger-UI" selector="buttonEnablement">buttonEnablement	| container edc priority notTerminated canIssueContextCommand |	builder == nil ifTrue: [^self].	container := self isToolbarBelowContexts		ifTrue: [(builder componentAt: #toolbarHolder) widget]		ifFalse: [builder componentAt: #toolbarMenu].	edc := self enableDebugCommand.	notTerminated := self isTerminated not.	canIssueContextCommand := self canIssueContextCommand.	(container componentAt: #step) ifNotNil: [:c | c isEnabled: canIssueContextCommand].	(container componentAt: #send) ifNotNil: [:c | c isEnabled: canIssueContextCommand &amp; (contextIndex = 1)].	(container componentAt: #stepIntoBlock) ifNotNil: [:c | c  isEnabled: canIssueContextCommand &amp; (contextIndex = 1)].	(container componentAt: #skip) ifNotNil: [:c | c  isEnabled: canIssueContextCommand].	(container componentAt: #return) ifNotNil: [:c | c  isEnabled: canIssueContextCommand].	(container componentAt: #reenter) ifNotNil: [:c | c  isEnabled: canIssueContextCommand].	(container componentAt: #jumpToCaret) ifNotNil: [:c | c  isEnabled: canIssueContextCommand].	(container componentAt: #firstLoop) ifNotNil: [:c | c  isEnabled: canIssueContextCommand].	(container componentAt: #nextLoop) ifNotNil: [:c | c  isEnabled: (canIssueContextCommand and: [service hasLoopControlContext])].	(container componentAt: #selectHome) ifNotNil: [:c | c  isEnabled: (canIssueContextCommand and: [service isMethodContextSelected not])].	(container componentAt: #continue) ifNotNil: [:c | c  isEnabled: notTerminated &amp; busy not].	(builder componentAt: #stackList) ifNotNil: [:c | c  isEnabled: busy not].	(container componentAt: #inspectContext) ifNotNil: [:c | c isEnabled: edc].	(container componentAt: #abort) ifNotNil: [:c | c  isEnabled: busy].	self textWidget isEnabled: edc.	priority := self notBusy		ifTrue: [Processor userSchedulingPriority]		ifFalse: [Processor lowIOPriority -1].	builder window windowProcess priority: priority.</body><body package="Debugger-UI" selector="canContextChange:">canContextChange: aController	^self changeRequest</body><body package="Debugger-UI" selector="changeRequest">changeRequest	| wrapper editor choice |	builder isNil		ifTrue: [^true].	wrapper := builder componentAt: #text.	(wrapper isNil or: [(editor := wrapper widget controller) updateRequest])		ifTrue: [^true].	choice := Dialog 		choose: ((#AcceptUnsavedTextChanges &lt;&lt; #dialogs &gt;&gt; 'Accept unsaved text changes?') expandMacros)		labels: (Array			with: #Yes &lt;&lt; #labels &gt;&gt; 'Yes'			with: #No &lt;&lt; #labels &gt;&gt; 'No'			with: #Cancel &lt;&lt; #labels &gt;&gt; 'Cancel')		values: #(#yes #no #cancel)		default: #yes.	choice = #cancel		ifTrue: [^false].	choice = #yes 		ifTrue: [self textAccepted: editor]		ifFalse: [editor cancel].	^true</body><body package="Debugger-UI" selector="disableStackFiltering">disableStackFiltering	enableStackFiltering := false.	service		stackFilterPatterns: #()		convertSelector: ContextListPolicyEditor ConversionSelector		matchSelector: ContextListPolicyEditor MatchSelector		displayAllLimit: ContextListPolicyEditor DisplayAllLimit.</body><body package="Debugger-UI" selector="enableStackFiltering">enableStackFiltering	| pats |	enableStackFiltering := true.	stackEmphases := Dictionary new.	pats := ContextListPolicyEditor Patterns collect:		[:p |		stackEmphases at: p name put: p color.		(ServerContextPatternSpec new) pattern: p pattern; name: p name; yourself].	service		stackFilterPatterns: pats		convertSelector: ContextListPolicyEditor ConversionSelector		matchSelector: ContextListPolicyEditor MatchSelector		displayAllLimit: ContextListPolicyEditor DisplayAllLimit.</body><body package="Debugger-UI" selector="findNode">findNode	| tree node interval source |	interval := self selectedInterval.	interval isEmpty 		ifTrue: 			[| cursorPosition |			cursorPosition := self selectionIndex.			cursorPosition = 1 ifTrue: [^nil].			interval := cursorPosition to: cursorPosition].	source := self text asString.	source size &gt; 10000 ifTrue: [^nil].	tree := self parseSource: source.	tree isNil ifTrue: [^self parseSelection].	node := tree whichNodeIsContainedBy: interval.	node isNil ifTrue: [node := tree bestNodeFor: interval].	^node</body><body package="Debugger-UI" selector="interfaceWindow">interfaceWindow	^builder window</body><body package="Debugger-UI" selector="methodCollector">methodCollector	^MethodCollector new browser: self</body><body package="Debugger-UI" selector="parseSelection">parseSelection	^RBParser 		parseExpression: self selectedText		onError: [:str :pos | ^nil]</body><body package="Debugger-UI" selector="parseSource:">parseSource: aString 	parsedSource = aString ifTrue: [^parseTree].	parsedSource := aString.	parseTree := nil.	^parseTree := service selector = #unboundMethod		ifTrue: [RBParser parseExpression: aString onError: [:str :error | ^nil]]		ifFalse: [RBParser parseMethod: aString onError: [:str :err | ^nil]]</body><body package="Debugger-UI" selector="performDebugOperation:">performDebugOperation: actionSym	busy := true.	self buttonEnablement.	service perform: actionSym</body><body package="Debugger-UI" selector="performDebugOperation:with:">performDebugOperation: actionSym with: anObject	^self performDebugOperation: actionSym withArgs: (Array with: anObject)</body><body package="Debugger-UI" selector="performDebugOperation:withArgs:">performDebugOperation: actionSym withArgs: anArray	busy := true.	self buttonEnablement.	service perform: actionSym withArguments: anArray.</body><body package="Debugger-UI" selector="requestComplete">requestComplete	busy := false.	self isTerminated.	self buttonEnablement.</body><body package="Debugger-UI" selector="selectedInterval">selectedInterval	| controller |	controller := self textController.	controller isNil ifTrue: [^1 to: 0].	^controller selectionStartIndex to: controller selectionStopIndex - 1</body><body package="Debugger-UI" selector="selectedText">selectedText	| interval |	interval := self selectedInterval.	interval isEmpty ifTrue: [^''].	^self textController text asString copyFrom: interval first		to: interval last</body><body package="Debugger-UI" selector="selectedVariableBinding">selectedVariableBinding	| name |	name := self selectedVariableName.	name isNil ifTrue: [^nil].	^(name includes: $.)		ifTrue: [name asQualifiedReference bindingOrNil]		ifFalse: [service selectedClass environment bindingFor: name asSymbol]</body><body package="Debugger-UI" selector="selectedVariableName">selectedVariableName	| node |	node := self findNode.	^(node notNil and: [node isVariable]) ifTrue: [node name] ifFalse: [nil]</body><body package="Debugger-UI" selector="selectionIndex">selectionIndex	| controller |	controller := self textController.	controller isNil ifTrue: [^1].	^controller selectionStartIndex</body><body package="Debugger-UI" selector="shortenClassNameFor:">shortenClassNameFor: str	| strm parts classParts |	strm := WriteStream on: (String new: str size).	parts := str tokensBasedOn: $&gt;.	classParts := (parts at: 1) tokensBasedOn: $(.	strm nextPutAll: ((classParts at: 1) tokensBasedOn: $.) last.	classParts size &gt; 1		ifTrue:			[strm nextPut: $(;				nextPutAll: ((classParts at: 2) tokensBasedOn: $.) last].	strm nextPutAll: '&gt;&gt;';		nextPutAll: parts last.	^strm contents</body><body package="Debugger-UI" selector="stackView">stackView	^(builder componentAt: #stackList) widget</body><body package="Debugger-UI" selector="textController">textController	^self textWidget controller</body><body package="Debugger-UI" selector="textEditor:keyPress:">textEditor: aTextController keyPress: aKeyPressedEvent	^aKeyPressedEvent keyValue = Graphics.TextConstants.Ctrlo		ifTrue: 			[self format. 			nil]		ifFalse:			[aKeyPressedEvent]</body><body package="Debugger-UI" selector="textWidget">textWidget	^(builder componentAt: #text) widget</body><body package="Debugger-UI" selector="withDisabledItemsHidden:">withDisabledItemsHidden: aMenu	aMenu menuItems do:		[:each | each hidden: [each isEnabled not]].	^aMenu</body></methods><methods><class-id>CraftedSmalltalk.DebuggerClient</class-id> <category>testing</category><body package="Debugger-UI" selector="canAddTag">canAddTag	^self canIssueContextCommand and: [service isCurrentContextTagged not]</body><body package="Debugger-UI" selector="canCorrectSpelling">canCorrectSpelling	^self canIssueContextCommand and: [service canCorrectSpelling]</body><body package="Debugger-UI" selector="canDefineMethod">canDefineMethod	^self canIssueContextCommand and: [service canDefineMethod]</body><body package="Debugger-UI" selector="canDoNextLoop">canDoNextLoop	^self canIssueContextCommand and: [service hasLoopControlContext]</body><body package="Debugger-UI" selector="canIssueContextCommand">canIssueContextCommand	^self hasValidContext and: [self notBusy and: [self isTerminated not]]</body><body package="Debugger-UI" selector="canRemoveTag">canRemoveTag	^self canIssueContextCommand and: [service isCurrentContextTagged]</body><body package="Debugger-UI" selector="canRun">canRun	^self notBusy and: [self isTerminated not]</body><body package="Debugger-UI" selector="canSelectHome">canSelectHome	^self canIssueContextCommand and: [service isMethodContextSelected not]</body><body package="Debugger-UI" selector="canShowMore">canShowMore	^self isTerminated not</body><body package="Debugger-UI" selector="enableDebugCommand">enableDebugCommand	^self hasValidContext &amp; self notBusy</body><body package="Debugger-UI" selector="enableSendCommand">enableSendCommand	^(contextIndex = 1) and: [self canIssueContextCommand]</body><body package="Debugger-UI" selector="hasClassSelected">hasClassSelected	| node |	node := self findNode.	(node isNil or: [node isVariable not]) ifTrue: [^false].	^node name asQualifiedReference bindingOrNil		ifNil: [false]		ifNotNil: [:b | b isForClass]</body><body package="Debugger-UI" selector="hasInstanceVariableSelected">hasInstanceVariableSelected	| class name |	class := service selectedClass.	name := self selectedVariableName.	^class notNil and: [name notNil and: [(class allInstVarNames indexOf: name) &gt; 0]]</body><body package="Debugger-UI" selector="hasMessageNodeSelected">hasMessageNodeSelected	| node |	node := self findNode.	^node notNil and: [node isMessage]</body><body package="Debugger-UI" selector="hasValidContext">hasValidContext	^contextIndex &gt; 0</body><body package="Debugger-UI" selector="isTerminated">isTerminated	terminated		ifFalse:			[terminated := service isTerminated.			terminated				ifTrue: [self changed: #windowLabel with: service label]].	^terminated</body><body package="Debugger-UI" selector="isToolbarBelowContexts">isToolbarBelowContexts	^(builder componentAt: #toolbarHolder) notNil</body><body package="Debugger-UI" selector="notBusy">notBusy	^busy not</body></methods><methods><class-id>CraftedSmalltalk.DebuggerClient</class-id> <category>updating</category><body package="Debugger-UI" selector="changeWindowLabelTo:">changeWindowLabelTo: aString	^self changed: #windowLabel with: aString</body><body package="Debugger-UI" selector="highlightRange:">highlightRange: range	| tv |	builder isNil		ifTrue: [^self].	tv := self textWidget.	tv isOpen		ifFalse: [^self].	tv deselect.	tv controller selectAndScrollFrom: range value first to: range value last.	tv displaySelection: true.</body><body package="Debugger-UI" selector="redisplayText">redisplayText	self textHolder setValue: self text.	builder isNil		ifTrue: [^self].	self textWidget updateTheDisplay.</body><body package="Debugger-UI" selector="refreshAll">refreshAll	self changed: #windowLabel with: service label.	self updateContextList: service indexOfCurrentContext.	self redisplayText.	self highlightRange: service pcRange.	self buttonEnablement.</body><body package="Debugger-UI" selector="refreshContextList">refreshContextList	self updateContextList: service indexOfCurrentContext.</body><body package="Debugger-UI" selector="showMessage:">showMessage: anObject	Dialog warn: anObject</body><body package="Debugger-UI" selector="update:with:">update: aSymbol with: anObject	aSymbol = #pcRange		ifTrue: 			[^	[(Delay forMilliseconds: 20) wait. 				builder window send: #highlightRange: to: self with: (Array with: anObject)] fork].	aSymbol = #showMessage		ifTrue: [^builder window send: #showMessage: to: self with: (Array with: anObject)].	aSymbol = #contextList		ifTrue: [^builder window send: #updateContextList: to: self with: (Array with: anObject)].	aSymbol = #contextSelection		ifTrue: [^builder window send: #updateContextSelection: to: self with: (Array with: anObject)].	aSymbol = #text		ifTrue: [^builder window send: #redisplayText to: self].	aSymbol = #requestComplete		ifTrue: [^builder window send: #requestComplete to: self].	aSymbol = #windowLabel		ifTrue: [^builder window send: #changeWindowLabelTo: to: self with: (Array with: anObject)].	aSymbol = #closeDebugger		ifTrue: [^builder window send: #closeRequest to: self].</body><body package="Debugger-UI" selector="updateContextList:">updateContextList: contextIdx	| scrollPosition nLines sv |	nLines := stackList list size.	sv := self stackView.	scrollPosition := sv scrollOffsetHolder value.	sv scrollOffsetHolder retractInterestIn: #value for: self.	stackList selectionIndexHolder retractInterestsFor: self.	stackList list: self contextList.	contextIndex := contextIdx.	stackList selectionIndex: contextIndex.	stackList list size &gt;= nLines		ifTrue: [sv scrollTo: scrollPosition].	service isFullStack		ifFalse:			[sv scrollOffsetHolder				expressInterestIn: #value				for: self				sendBack: #listScrolled].	stackList selectionIndexHolder onChangeSend: #contextChanged to: self</body><body package="Debugger-UI" selector="updateContextSelection:">updateContextSelection: contextIdx	stackList selectionIndexHolder retractInterestsFor: self.	contextIndex := contextIdx.	stackList selectionIndex: contextIndex.	stackList selectionIndexHolder onChangeSend: #contextChanged to: self</body></methods><methods><class-id>CraftedSmalltalk.DebuggerClient</class-id> <category>aspects</category><body package="Debugger-UI" selector="contextInspector">contextInspector	^service contextInspector</body><body package="Debugger-UI" selector="contextList">contextList	^service contextListForUI collect: 		[:a | | emp txt str |		str := a at: 1.		shortClassNames			ifTrue: [str := self shortenClassNameFor: str].		txt := str asText.		(service isTagged: (a at: 1)) ifTrue: [txt := txt allBold].		emp := a at: 3.		emp notNil			ifTrue: [txt emphasizeAllWith: (#color -&gt; (stackEmphases at: emp))].		txt]</body><body package="Debugger-UI" selector="listScrolled">listScrolled	| sv |	sv := self stackView.	(sv scrollOffsetHolder value - sv visibleExtent + sv scrollableExtent) y &lt; 10		ifTrue: [self moreStack]</body><body package="Debugger-UI" selector="receiverInspector">receiverInspector	^service receiverInspector</body><body package="Debugger-UI" selector="stackInspector">stackInspector	^service stackInspector</body><body package="Debugger-UI" selector="stackList">stackList	^stackList</body><body package="Debugger-UI" selector="text">text	^service text</body><body package="Debugger-UI" selector="textHolder">textHolder	^text</body></methods><methods><class-id>CraftedSmalltalk.DebuggerClient</class-id> <category>doIt/accept/explain</category><body package="Debugger-UI" selector="doItContext">doItContext	"Answer the context in which a text selection can be evaluated."	^service doItContext</body><body package="Debugger-UI" selector="doItEnvironment">doItEnvironment	"Answer the object that should be informed of the result of evaluating a	text selection."	^service doItEnvironment</body><body package="Debugger-UI" selector="doItReceiver">doItReceiver	"Answer the object that should be informed of the result of evaluating a	text selection."	^service doItReceiver</body><body package="Debugger-UI" selector="doItValue:">doItValue: anObject 	"Set the value to be returned when the interrupted process proceeds."	^service doItValue: anObject</body><body package="Debugger-UI" selector="explain">explain	service explainFor: self textController</body><body package="Debugger-UI" selector="format">format	service formatFor: self textController</body><body package="Debugger-UI" selector="textAccepted:">textAccepted: textController	"Recompile the method of the selected context."	service isInstalledMethodSourceOutOfSync		ifTrue:			[(Dialog				choose: (#SourcesOutOfSyncWhatToDo &lt;&lt; #pdp &gt;&gt; 'Installed method source and selected context original source areout of sync.  Accepting new source may result in losing prior changes.')				labels: (Array with: (#AcceptSource &lt;&lt; #pdp &gt;&gt; 'Accept Source') with: (#Cancel &lt;&lt; #pdp &gt;&gt; 'Cancel'))				values: #(true false)				default: false)				ifFalse: [^false]].	^service acceptTextFrom: textController.</body></methods><methods><class-id>CraftedSmalltalk.DebuggerClient</class-id> <category>private-return</category><body package="Debugger-UI" selector="hookupMethodReturnFor:">hookupMethodReturnFor: dialog	| aBuilder result accept pa |	aBuilder := dialog builder.	accept := dialog accept.	result := ValueHolder with: nil.	pa := PluggableAdaptor on: result.	pa 		getBlock: [:m | m]		putBlock: [:m :v | ]		updateBlock: [:m :a :p | a == #value ifTrue: [accept value: true]. true].	result addDependent: pa.	aBuilder		aspectAt: #returnSelf		put: [result value: #returnSelf:].	aBuilder		aspectAt: #returnTOS		put: [result value: #returnTOS:].	aBuilder		aspectAt: #returnLastDoIt		put: [result value: #returnLastDoIt:].	aBuilder		aspectAt: #returnNewExpr		put: [result value: #returnNewExpr:].	accept onChangeSend: #close to: dialog.	dialog cancel onChangeSend: #close to: dialog.	^result</body><body package="Debugger-UI" selector="returnFromBlockContext">returnFromBlockContext	| windoe dialog aBuilder result returnType |	windoe := builder window.	dialog := SimpleDialog new.	dialog initializeBuilderFor: windoe.	aBuilder := dialog builder.	aBuilder source: self.	result := self hookupMethodReturnFor: dialog.	returnType := ValueHolder with: #return:.	aBuilder		aspectAt: #returnType		put: returnType.	aBuilder add: (UISpecification from: self class blockReturnSpec).	dialog initializeWindowFor: windoe.	service doesContextHaveInterimValues		ifFalse: [(aBuilder componentAt: #returnTOS) disable].	service contextHasHome		ifFalse:			[(aBuilder componentAt: #methodReturn) disable.			(aBuilder componentAt: #blockReturn) disable].	dialog preOpen.	aBuilder openDialogWithExtent: aBuilder window displayBox extent.	result value isNil		ifTrue: [^nil].	self perform: result value with: returnType value.</body><body package="Debugger-UI" selector="returnFromMethodContext">returnFromMethodContext	| windoe dialog aBuilder result |	windoe := builder window.	dialog := SimpleDialog new.	dialog initializeBuilderFor: windoe.	aBuilder := dialog builder.	aBuilder source: self.	result := self hookupMethodReturnFor: dialog.	aBuilder add: (UISpecification from: self class methodReturnSpec).	dialog initializeWindowFor: windoe.	service doesContextHaveInterimValues		ifFalse: [(aBuilder componentAt: #returnTOS) disable].	dialog preOpen.	aBuilder openDialogWithExtent: aBuilder window displayBox extent.	result value isNil		ifTrue: [^nil].	self perform: result value with: #return:.</body><body package="Debugger-UI" selector="returnLastDoIt:">returnLastDoIt: rtnMsg	self performDebugOperation: #returnLastDoIt: with: rtnMsg.</body><body package="Debugger-UI" selector="returnNewExpr:">returnNewExpr: rtnMsg	| string retry result |	[string := Dialog				request: (#EnterExpressionC &lt;&lt; #pdp &gt;&gt; 'Enter expression:')				initialAnswer: 'nil'.	string isEmpty		ifTrue: [^self].	result := service evaluateExpressionInReceiver: string.	result key		ifTrue: [retry := false]		ifFalse:			[retry := Dialog						confirm: (#ExprInvalidRetryQ &lt;&lt; #pdp &gt;&gt; 'The expression is invalid. Retry?')						initialAnswer: true.			retry				ifFalse: [^self]].	retry] whileTrue.	self performDebugOperation: #returnNewExpr:with: withArgs: (Array with: rtnMsg with: result value).</body><body package="Debugger-UI" selector="returnSelf:">returnSelf: rtnMsg	self performDebugOperation: #returnSelf: with: rtnMsg.</body><body package="Debugger-UI" selector="returnTOS:">returnTOS: rtnMsg	self performDebugOperation: #returnTOS: with: rtnMsg.</body></methods><methods><class-id>CraftedSmalltalk.DebuggerClient</class-id> <category>initialize - release</category><body package="Debugger-UI" selector="initialize">initialize	super initialize.	shortClassNames := busy := false.	terminated := false.	text := String new asValue.	contextIndex := 0.	stackList := SelectionInList new.	stackList list: List new.	stackList selectionIndexHolder onChangeSend: #contextChanged to: self.	stackEmphases := Dictionary new.	ContextListPolicyEditor Patterns do: [:ps | stackEmphases at: ps name put: ps color].	closeAction := #terminate</body><body package="Debugger-UI" selector="noticeOfWindowClose:">noticeOfWindowClose: aWindow	EventQueue allInstancesDo: [:each | each restoreReadSynchSignals].	service removeAllDependents.</body><body package="Debugger-UI" selector="windowClosed">windowClosed	service perform: closeAction.</body></methods><methods><class-id>CraftedSmalltalk.DebuggerClient</class-id> <category>interface opening</category><body package="Debugger-UI" selector="postBuildWith:">postBuildWith: aBuilder	self enableStackFiltering.	self textController 		autoAccept: false;		doNotHandleLocally: #explain;		keyboardHook: [:e :c | self textEditor: c keyPress: e].	self setupMenuBarMenu: (aBuilder menuAt: #menuBarMenu).	self stackView scrollOffsetHolder		expressInterestIn: #value		for: self		sendBack: #listScrolled.</body><body package="Debugger-UI" selector="postOpenWith:">postOpenWith: aBuilder 	| windowProcess |	windowProcess := aBuilder window windowProcess.	windowProcess environmentAt: #debugger put: self.	windowProcess environmentAt: #WindowManagerUsagePolicy put: MakeNewWindowManagerUsagePolicy new.	self refreshAll.	aBuilder window when: #closed send: #windowClosed to: self</body></methods><methods><class-id>CraftedSmalltalk.DebuggerClient class</class-id> <category>resources</category><body package="Debugger-UI" selector="executeMenu">executeMenu	menuHolder isNil ifTrue: [self initializeMenu].	^menuHolder value decodeAsLiteralArray</body></methods><methods><class-id>CraftedSmalltalk.DebuggerClient class</class-id> <category>interface specs</category><body package="Debugger-UI" selector="windowSpec">windowSpec	^PlaceToolbarBelowContexts		ifTrue: [self toolbarInTheMiddleWindowSpec]		ifFalse: [self toolbarOnTopWindowSpec]</body></methods><methods><class-id>CraftedSmalltalk.DebuggerClient class</class-id> <category>private</category><body package="Debugger-UI" selector="classMethodsChanged">classMethodsChanged	menuHolder := nil</body><body package="Debugger-UI" selector="initializeMenu">initializeMenu	"self initializeMenu"	self menuHolder value: self executeMenuDefault literalArrayEncoding.	^menuHolder value</body><body package="Debugger-UI" selector="menuHolder">menuHolder	menuHolder isNil		ifTrue: [menuHolder := self executeMenuDefault literalArrayEncoding asValue].	^menuHolder</body></methods><methods><class-id>CraftedSmalltalk.DebuggerClient class</class-id> <category>class initialization</category><body package="Debugger-UI" selector="initialize">initialize	"self initialize"	#{PlaceToolbarBelowContexts} initialize.	self initializeMenu</body></methods><methods><class-id>CraftedSmalltalk.DebuggerClient class</class-id> <category>instance creation</category><body package="Debugger-UI" selector="openFullViewOn:label:">openFullViewOn: aDebuggerService label: aString	[| win |	win := (self service: aDebuggerService) open window.	win label: aString.	win windowProcess name: aString.]		on: GetWindowManagerUsagePolicy		do: [:ex | ex resume: MakeNewWindowManagerUsagePolicy new]	"Smalltalk Professional Debug Package Version 3.1 (c) 2002 Crafted Smalltalk"</body><body package="Debugger-UI" selector="service:">service: aDebuggerService	^self new service: aDebuggerService	"Smalltalk Professional Debug Package Version 3.0 (c) 2001 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.ServerContextPatternSpec</class-id> <category>initialize-release</category><body package="Debugger-UI" selector="initialize">initialize	name := ''.	pattern := ''</body></methods><methods><class-id>CraftedSmalltalk.ServerContextPatternSpec</class-id> <category>accessing</category><body package="Debugger-UI" selector="name">name	^name</body><body package="Debugger-UI" selector="name:">name: aString	name := aString</body><body package="Debugger-UI" selector="pattern">pattern	^pattern</body><body package="Debugger-UI" selector="pattern:">pattern: aString	pattern := aString</body></methods><methods><class-id>CraftedSmalltalk.ServerContextPatternSpec class</class-id> <category>instance creation</category><body package="Debugger-UI" selector="new">new	^super new initialize</body></methods><methods><class-id>CraftedSmalltalk.DebugTempProbeInserter</class-id> <category>private - adjusting</category><body package="Debugger-UI" selector="adjustDynamicsReplacing:with:from:atPC:addProbe:originalPCMap:">adjustDynamicsReplacing: origMethod with: nuMethod from: blkIndex atPC: aPC addProbe: addProbe originalPCMap: oldPCMap	"This method attempts to 'fix' all the contexts and block closures.  We do check two branches; the branch	the current context is in, and the branch containing the block where the probe is to be inserted."  	| nuSelectedBlock methodMap ctxs ctx depthLimit nuPCMap jumpAmount nuBlocks origBlocks homeMethod closureMap done methodsToFlush |	homeContext := debugger context supposedHome.	homeMethod := homeContext method.	"Construct map to map original blocks to probed blocks."	nuSelectedBlock := nuMethod blockAt: blkIndex.	addProbe		ifTrue:			[depthLimit := ((AuxCodeInfoExtractor new method: nuSelectedBlock) depthAt: aPC) + 3.			jumpAmount := 7]		ifFalse:			[depthLimit := 0.			jumpAmount := -7].	oldPCMap notNil		ifTrue: [nuPCMap := nuMethod sourceMapAt: blkIndex].	"Map blocks to new blocks and clean closures to new clean closures."	methodMap := IdentityDictionary new.	closureMap := IdentityDictionary new.	nuBlocks := nuMethod withAllBlockMethods.	origBlocks := origMethod withAllBlockMethods.	1 to: nuBlocks size do:		[:i | | oldBlock nuBlock |		methodMap at: (oldBlock := origBlocks at: i) put: (nuBlock := nuBlocks at: i).		methodMap at: nuBlock put: nuBlock.		1 to: oldBlock numLiterals do:			[:j | | lit |			lit := oldBlock basicAt: j.			lit class == BlockClosure				ifTrue: [closureMap at: lit put: (nuBlock basicAt: j)]]].	"The following is executed unpreemptively because it attempts to find and correct	all block contexts whose method is being changed."	ctx := debugger topContext.	ctxs := OrderedCollection new.	methodsToFlush := IdentitySet new.	done := false.	[	[ctx == nil or: [done]]		whileFalse: 			[done := ctx == homeContext.			ctx method homeMethod == homeMethod				ifTrue:					[methodsToFlush add: ctx method.					ctx probeMethod: (methodMap at: ctx method ifAbsent: [ctx method]).					ctx method == nuSelectedBlock						ifTrue: [ctxs add: ctx].					1 to: ctx stackP do:						[:i | | obj vals |						obj := ctx localAt: i.						(obj class == BlockClosure and: [obj method homeMethod == homeMethod])							ifTrue:								[methodsToFlush add: obj method.								obj isClean									ifTrue: [ctx localAt: i put: (closureMap at: obj ifAbsent: [obj])]									ifFalse:										[vals := obj copiedValues.										obj method numCopiedValues = 1											ifTrue: [vals := Array with: vals].										obj method: (methodMap at: obj method).										1 to: vals size do: 											[:j | | val |											(val := vals at: j) class == BlockClosure												ifTrue:													[(val isClean and: [val method homeMethod == homeMethod])														ifTrue:															[methodsToFlush add: val method.															vals at: j put: (closureMap at: val ifAbsent: [val])]]												ifFalse:													[val class == Array														ifTrue:															[1 to: val size do:																[:k | | aVal |																aVal := val at: k.																(aVal class == BlockClosure and: [aVal isClean and: [aVal method homeMethod == homeMethod]])																	ifTrue:																		[methodsToFlush add: val method.																		val at: k put: (closureMap at: aVal ifAbsent: [aVal])]]]]]]]]].			ctx := ctx sender].	self flushMethodCacheFor: methodsToFlush.	ctxs do:		[:aCtx | | ctxPC i |		(depthLimit &gt; aCtx size)			ifTrue: [aCtx growBy: 3].		(ctxPC := aCtx pc) &gt; aPC			ifTrue:				[oldPCMap notNil					ifTrue:						[i := self findMapIndexFor: ctxPC inMap: oldPCMap.						jumpAmount := (nuPCMap at: i) key - (oldPCMap at: i) key].				aCtx jump: jumpAmount]]	] valueUnpreemptively.</body></methods><methods><class-id>CraftedSmalltalk.DebugTempProbeInserter</class-id> <category>private</category><body package="Debugger-UI" selector="getAndVerifyHomeContext">getAndVerifyHomeContext	homeContext := debugger context supposedHome.	homeContext isNil		ifTrue:			[exitBlock value: (#CannotInsertProbeHomeNotInProcess &lt;&lt; #pdp &gt;&gt; '		A probe cannot be inserted.The home context is not in the process').].</body><body package="Debugger-UI" selector="verifyFullBlocks">verifyFullBlocks	"Make full block closures if we can."	debugger hasHomeContextStepped		ifTrue: [^self].	"Cannot make full closure."	probeSpec isPermanent		ifTrue: [self changeClassTo: DebugProbeInserter].	self makeFullBlocks.</body><body package="Debugger-UI" selector="verifyProbeSpec">verifyProbeSpec	probeSpec notNil		ifTrue: [^self].	"Prompt user for probe selection."	probeSpec := CodeProbe selectDebuggerProbeTypeAsTemp: true.	probeSpec isNil		"Exit if user canceled."		ifTrue: [exitBlock value: nil].</body></methods><methods><class-id>CraftedSmalltalk.ContextListPolicyEditor</class-id> <category>commands</category><body package="Debugger-UI" selector="accept">accept	Patterns := OrderedCollection new: patternList size.	patternList list do:		[:ps |		ps name isEmpty			ifFalse: [Patterns add: ps copyWithoutText]].	MatchSelector := matchSelector value asSymbol.	ConversionSelector := conversionSelector value asSymbol.	DisplayAllLimit := displayAllLimit value truncated.	self closeRequest.</body><body package="Debugger-UI" selector="cancel">cancel	self closeRequest.</body><body package="Debugger-UI" selector="copy">copy	buffer := selection value copy.</body><body package="Debugger-UI" selector="help"> help	| mod aBuilder spec |	aBuilder := UIBuilder new.	aBuilder aspectAt: #helpText put: HelpText.	mod := ApplicationModel new.	mod builder: aBuilder.	aBuilder source: mod.	spec := self class interfaceSpecFor: #helpSpec.	mod		hookUpWindow: nil		spec: spec		builder: aBuilder.	aBuilder add: spec.	aBuilder window model: mod.	aBuilder bindings at: #__specName put: #helpSpec.	aBuilder openFromWindowSpec: spec window.	aBuilder window displayPendingInvalidation.	^aBuilder</body><body package="Debugger-UI" selector="newPattern">newPattern	| idx |	idx := patternList selectionIndex + 1.	patternList list add: self emptyPattern beforeIndex: idx.	patternList selectionIndex: idx.</body><body package="Debugger-UI" selector="paste">paste	patternList list add: buffer copy beforeIndex: patternList selectionIndex + 1.</body><body package="Debugger-UI" selector="removePattern">removePattern	patternList list remove: selection value ifAbsent: [].</body><body package="Debugger-UI" selector="selectColor">selectColor	| dialog color |	dialog := ColorSelectionDialog new.	dialog selection: colorHolder value.	dialog open.	dialog accept value		ifFalse: [^self].	color := dialog selection.	colorHolder value: color.	self refreshColorButton.</body><body package="Debugger-UI" selector="undo">undo	| pattern uBuff command |	pattern := selection value.	uBuff := undoBuffer at: pattern ifAbsent: [^self].	command := uBuff removeLast.	uBuff isEmpty		ifTrue: [undoBuffer removeKey: pattern].	pattern perform: command key with: command value.	command key == #pattern:		ifFalse: [pattern emphasize].	command key == #color: 		ifTrue: [self refreshColorButton].	self refreshList.	selection changed: #value.</body></methods><methods><class-id>CraftedSmalltalk.ContextListPolicyEditor</class-id> <category>private</category><body package="Debugger-UI" selector="addUndoCommand:oldValue:">addUndoCommand: symbol oldValue: obj	| uBuffer |	uBuffer := undoBuffer at: selection value ifAbsentPut: [OrderedCollection new]. 	uBuffer add: symbol -&gt; obj.</body><body package="Debugger-UI" selector="emptyPattern">emptyPattern	^(ClientContextPatternSpec new)		name: (#Everything &lt;&lt; #pdp &gt;&gt; 'Everything') asString;		pattern: '*';		color: ColorValue black;		yourself.</body><body package="Debugger-UI" selector="patternColorHolder">patternColorHolder	| pa |	pa := (PluggableAdaptor on: selection)		getBlock: [:m | m value color]		putBlock:			[:m :v | 			self addUndoCommand: #color: oldValue: m value color.			(m value) color: v; emphasize]		updateBlock: [:m :a :p | a == #value].	pa onChangeSend: #refreshList to: self.	^pa</body><body package="Debugger-UI" selector="refreshColorButton">refreshColorButton	(self widgetAt: #colorButton) widgetState colors: ((self widgetAt: #colorButton) lookPreferences setForegroundColor: selection value color).	(self widgetAt: #colorButton) invalidate.</body><body package="Debugger-UI" selector="refreshList">refreshList	(self widgetAt: #patternList) invalidate.</body></methods><methods><class-id>CraftedSmalltalk.ContextListPolicyEditor</class-id> <category>accessing</category><body package="Debugger-UI" selector="buttonEnablement">buttonEnablement	| enable |	enable := self patternIsSelected.	(builder componentAt: #removeButton) isEnabled: enable.	(builder componentAt: #colorButton) isEnabled: enable.</body><body package="Debugger-UI" selector="conversionSelector">conversionSelector	^conversionSelector</body><body package="Debugger-UI" selector="displayAllLimit">displayAllLimit	^displayAllLimit</body><body package="Debugger-UI" selector="matchSelector">matchSelector	^matchSelector</body><body package="Debugger-UI" selector="patternList">patternList	^patternList</body></methods><methods><class-id>CraftedSmalltalk.ContextListPolicyEditor</class-id> <category>aspects</category><body package="Debugger-UI" selector="canPaste">canPaste	^buffer notNil</body><body package="Debugger-UI" selector="canUndo">canUndo	^undoBuffer includesKey: selection value</body><body package="Debugger-UI" selector="patternIsSelected">patternIsSelected	^patternList selection notNil</body><body package="Debugger-UI" selector="patternName">patternName	| pa |	pa := (PluggableAdaptor on: selection)		getBlock: [:m | m value name string]		putBlock:			[:m :v | 			self addUndoCommand: #name: oldValue: m value name.			(m value) name: v; emphasize]		updateBlock: [:m :a :p | a == #value].	pa onChangeSend: #refreshList to: self.	^pa</body><body package="Debugger-UI" selector="patternString">patternString	| pa |	pa := (PluggableAdaptor on: selection)		getBlock: [:m | m value pattern]		putBlock:			[:m :v | 			self addUndoCommand: #pattern: oldValue: m value pattern.			m value pattern: v string]		updateBlock: [:m :a :p | a == #value].	pa onChangeSend: #refreshList to: self.	^pa</body><body package="Debugger-UI" selector="selectionChanged">selectionChanged	| pat |	pat := patternList selection.	pat isNil		ifTrue: [pat := ClientContextPatternSpec new].	selection value: pat.	self refreshColorButton.	self buttonEnablement.</body></methods><methods><class-id>CraftedSmalltalk.ContextListPolicyEditor</class-id> <category>drag &amp; drop</category><body package="Debugger-UI" selector="doDrag:">doDrag: aController 	"Drag the currently selected change. Include all available information so that the 	drop target can use whatever it needs."	| data |	data := DragDropData new.	data key: #ContextPatternSpec.	data contextWindow: self builder window.	data contextWidget: aController.	data contextApplication: self; contextApplicationType: #ContextListPolicyEditor.	data clientData: patternList selection.	(DragDropManager			withDropSource: DropSource new			withData: data) doDragDrop.</body><body package="Debugger-UI" selector="dragEnter:">dragEnter: aDragContext	"A drag has entered the class list of a change browser.	 If the receiver is happy to accept a drag from the target the	 fill-in the appropriate data and answer that dragging should continue."	self == aDragContext data contextApplication		ifFalse: [^#dropEffectNone].	aDragContext dropTarget clientData: self initialDropState.	^#dropEffectMove</body><body package="Debugger-UI" selector="dragLeave:">dragLeave: aDragContext	"A drag has left the change list of a change browser. If the drag contains a 	change, we must restore the state of the list."	self == aDragContext data contextApplication		ifTrue:			[self restoreListStateFrom: aDragContext dropTarget clientData.			aDragContext dropTarget clientData: nil].	^#dropEffectNone</body><body package="Debugger-UI" selector="dragOver:">dragOver: aDragContext	^self == aDragContext data contextApplication		ifTrue: [			(self builder componentAt: #patternList) widget				showDropFeedbackIn: aDragContext				allowScrolling: true.			#dropEffectMove]		ifFalse: [#dropEffectNone]</body><body package="Debugger-UI" selector="drop:">drop: aDragContext 	| view patternSpec list effectiveTargetIndex sourceIndex destIndex |	self == aDragContext data contextApplication		ifFalse: [^#dropEffectNone].	patternSpec := aDragContext data clientData.	list := patternList list.	view := (self builder componentAt: #patternList) widget.	effectiveTargetIndex := view elementIndexFor: view controller sensor cursorPoint.	destIndex := (effectiveTargetIndex min: list size) max: 1.	sourceIndex := list indexOf: patternSpec.	list removeAtIndex: sourceIndex.	destIndex &gt;= sourceIndex		ifTrue:			[destIndex &gt; list size				ifTrue: [list addLast: patternSpec]				ifFalse: [list add: patternSpec beforeIndex: destIndex]]		ifFalse:			[list add: patternSpec beforeIndex: destIndex].	patternList selection: patternSpec.	^#dropEffectNone</body><body package="Debugger-UI" selector="initialDropState">initialDropState	"Answer the initial state of the list when a drag has begun within its 	bounds. The state will be used to re-establish the appearance of the list when 	a drag leaves."	| dict view ctrl |	ctrl := (view := (self builder componentAt: #patternList) widget) controller.	dict := IdentityDictionary new.	dict at: #ctrl put: ctrl.	dict at: #targetIndex put: view targetIndex.	dict at: #effectiveTargetIndex put: (view elementIndexFor: ctrl sensor cursorPoint).	dict at: #hasFocus put: ctrl view hasFocus.	ctrl view hasFocus: true.	^dict</body><body package="Debugger-UI" selector="restoreListStateFrom:">restoreListStateFrom: aDictionary 	"Reset the state of the list when a drag has left its bounds."	| ctrl |	ctrl := aDictionary at: #ctrl.	ctrl view targetIndex: (aDictionary at: #targetIndex).	ctrl view hasFocus: (aDictionary at: #hasFocus)</body><body package="Debugger-UI" selector="wantToDrag:">wantToDrag: listController	"Answer true if the receiver wants to initiate a drag."	^patternList list size &gt; 1 and: [patternList selectionIndex &gt; 0]</body></methods><methods><class-id>CraftedSmalltalk.ContextListPolicyEditor</class-id> <category>initialize-release</category><body package="Debugger-UI" selector="initialize">initialize	patternList := SelectionInList new.	patternList list: self initialList.	patternList selectionIndexHolder onChangeSend: #selectionChanged to: self.	conversionSelector := ConversionSelector asValue.	matchSelector := MatchSelector asValue.	selection := ClientContextPatternSpec new asValue.	colorHolder := self patternColorHolder.	displayAllLimit := DisplayAllLimit asValue.	undoBuffer := IdentityDictionary new.</body><body package="Debugger-UI" selector="initialList">initialList	| list |	list := List new.	Patterns do: [:a | list add: a copyWithText].	^list</body></methods><methods><class-id>CraftedSmalltalk.ContextListPolicyEditor</class-id> <category>interface opening</category><body package="Debugger-UI" selector="postBuildWith:">postBuildWith: aBuilder 	(self widgetAt: #patternList) displayStringSelector: #name</body><body package="Debugger-UI" selector="postOpenWith:">postOpenWith: aBuilder 	self buttonEnablement.</body></methods><methods><class-id>CraftedSmalltalk.ContextListPolicyEditor class</class-id> <category>variables</category><body package="Debugger-UI" selector="ConversionSelector">ConversionSelector	^ConversionSelector</body><body package="Debugger-UI" selector="DisplayAllLimit">DisplayAllLimit	^DisplayAllLimit</body><body package="Debugger-UI" selector="MatchSelector">MatchSelector	^MatchSelector</body><body package="Debugger-UI" selector="Patterns">Patterns	^Patterns</body></methods><methods><class-id>CraftedSmalltalk.ContextDumpPolicy</class-id> <category>accessing</category><body package="Debugger-UI" selector="actualNumberToDump">actualNumberToDump	^numberToDump isNil		ifTrue: [stack size]		ifFalse: [numberToDump min: stack size]</body><body package="Debugger-UI" selector="errorMessage:">errorMessage: aString	errorMessage := aString</body><body package="Debugger-UI" selector="numberToDump:">numberToDump: anInteger	numberToDump := anInteger</body><body package="Debugger-UI" selector="printedString">printedString	^stream contents</body><body package="Debugger-UI" selector="stack:">stack: aCollection	stack := aCollection</body><body package="Debugger-UI" selector="stream">stream	^stream</body><body package="Debugger-UI" selector="stream:">stream: aStream	stream := aStream.</body></methods><methods><class-id>CraftedSmalltalk.ContextDumpPolicy</class-id> <category>private printing</category><body package="Debugger-UI" selector="basicPrintObject:">basicPrintObject: anObject	stream nextPutAll:		(((self _objectClass: anObject) name at: 1) isVowel ifTrue: ['an '] ifFalse: ['a ']).	stream print: (self _objectClass: anObject).</body><body package="Debugger-UI" selector="basicPrintVarName:value:">basicPrintVarName: aString value: anObject	stream nextPutAll: aString.	stream nextPutAll: ' = '.	[anObject forStackDumpPrintUsing: self]		on: Error		do: [:ex1 | 			[self basicPrintObject: anObject]				on: Error				do: [:ex2 | stream nextPutAll: (#ErrorInPrintingObject &lt;&lt; #pdp &gt;&gt; 'Error in printing object') asString]].</body><body package="Debugger-UI" selector="printContextParmsAndTemps:">printContextParmsAndTemps: aContext	| nArgs |	nArgs := aContext method numArgs.	nArgs &gt; 0		ifTrue: [stream nextPutAll: (#ArgumentsC &lt;&lt; #pdp &gt;&gt; 'Arguments:') asString; cr].	aContext pdpSlotAccessors do:		[:sa |		nArgs = 0			ifTrue: [stream nextPutAll: (#TemporariesC &lt;&lt; #pdp &gt;&gt; 'Temporaries:') asString; cr].		nArgs := nArgs - 1.		stream tab.		self basicPrintVarName: (sa at: 1) value: (aContext getTempVar: (sa at: 2)).		stream cr].</body><body package="Debugger-UI" selector="printContextReceiver:">printContextReceiver: aContext	stream nextPutAll: (#ReceiverC &lt;&lt; #pdp &gt;&gt; 'Receiver:') asString; crtab.	self basicPrintObject: aContext homeReceiver.	stream cr.</body><body package="Debugger-UI" selector="printContextReceiverInstVars:">printContextReceiverInstVars: aContext	| ivars i |	ivars := OrderedCollection new.	aContext homeReceiver class accumulateInstVarNames: ivars.	ivars isEmpty		ifTrue: [^self].	stream nextPutAll: (#InstanceVariablesC &lt;&lt; #pdp &gt;&gt; 'Instance Variables:') asString; cr.	i := 1.	ivars do:		[:str |		stream tab.		self basicPrintVarName: str value: (aContext _object: aContext homeReceiver instVarAt: i).		i := i + 1.		stream cr].</body><body package="Debugger-UI" selector="printContextVerbosely:">printContextVerbosely: aContext	stream		cr; 		nextPutAll: (#Dashes &lt;&lt; #pdp &gt;&gt; '----------------------------------------------------------------------') asString;		cr.		aContext printOn: stream.	stream cr.	self printContextReceiver: aContext.	self printContextReceiverInstVars: aContext.	self printContextParmsAndTemps: aContext.	stream nextPutAll: (#ContextPCEq &lt;&lt; #pdp &gt;&gt; 'Context PC = ') asString.	aContext pc printOn: stream</body><body package="Debugger-UI" selector="printErrorMessage">printErrorMessage	| errorString |	(errorMessage isNil or: [(errorString := errorMessage asString) isEmpty])		ifTrue: [^self].	stream nextPutAll: errorString; cr</body><body package="Debugger-UI" selector="printHeader">printHeader</body></methods><methods><class-id>CraftedSmalltalk.ContextDumpPolicy</class-id> <category>printing</category><body package="Debugger-UI" selector="copyStackString">copyStackString	self printErrorMessage.	self printSimpleStack.	self printVerboseStack.	^self printedString</body><body package="Debugger-UI" selector="printSimple">printSimple	self printHeader.	self printErrorMessage.	self printSimpleStack.</body><body package="Debugger-UI" selector="printSimpleStack">printSimpleStack	[1 to: self actualNumberToDump do:		[:i |		(stack at: i) printOn: stream.		stream cr].	]		on: Object errorSignal		do: [:ex | ex inspect. ex return].</body><body package="Debugger-UI" selector="printVerbose">printVerbose	self printHeader.	self printErrorMessage.	self printVerboseStack.</body><body package="Debugger-UI" selector="printVerboseStack">printVerboseStack	[1 to: self actualNumberToDump do:		[:i |		self printContextVerbosely: (stack at: i).		stream cr].	]		on: Object errorSignal		do: [:ex | ex inspect. ex return].</body></methods><methods><class-id>CraftedSmalltalk.ContextDumpPolicy</class-id> <category>initialize-release</category><body package="Debugger-UI" selector="initialize">initialize	stack := Array new.	stream := WriteStream on: (String new: 500).</body></methods><methods><class-id>CraftedSmalltalk.ContextDumpPolicy</class-id> <category>visitor printing</category><body package="Debugger-UI" selector="printCollection:">printCollection: aCollection	self basicPrintObject: aCollection.	stream nextPut: $[.	aCollection size printOn: stream.	stream nextPut: $].</body><body package="Debugger-UI" selector="printObject:">printObject: anObject	"Default printing"	^anObject printOn: stream</body><body package="Debugger-UI" selector="printString:">printString: anObject	(anObject contractTo: 60) printOn: stream.</body></methods><methods><class-id>CraftedSmalltalk.ContextDumpPolicy</class-id> <category>private-reflection protocol</category><body package="Debugger-UI" selector="_objectClass:">_objectClass: anObject	"Answer the object which is the argument's class.."	&lt;primitive: 211&gt;	^self primitiveFailed</body></methods><methods><class-id>CraftedSmalltalk.ContextDumpPolicy class</class-id> <category>instance creation</category><body package="Debugger-UI" selector="new">new	^super new initialize</body></methods><methods><class-id>CraftedSmalltalk.ClientContextPatternSpec</class-id> <category>accessing</category><body package="Debugger-UI" selector="color">color	^color</body><body package="Debugger-UI" selector="color:">color: aColorValue	color := aColorValue</body></methods><methods><class-id>CraftedSmalltalk.ClientContextPatternSpec</class-id> <category>copying</category><body package="Debugger-UI" selector="copyWithoutText">copyWithoutText	| cpy |	cpy := self shallowCopy.	cpy removeText.	^cpy</body><body package="Debugger-UI" selector="copyWithText">copyWithText	| cpy |	cpy := self shallowCopy.	cpy emphasize.	^cpy</body></methods><methods><class-id>CraftedSmalltalk.ClientContextPatternSpec</class-id> <category>emphasis</category><body package="Debugger-UI" selector="emphasize">emphasize	name := name string asText.	color isNil		ifTrue: [^self].	name emphasizeAllWith: #color -&gt; color.</body><body package="Debugger-UI" selector="removeText">removeText	name := name string</body></methods><methods><class-id>CraftedSmalltalk.ClientContextPatternSpec</class-id> <category>initialize-release</category><body package="Debugger-UI" selector="initialize">initialize	super initialize.	color := ColorValue black.</body></methods><methods><class-id>UI.EventSensor</class-id> <category>event processing</category><body package="Debugger-UI" selector="keyAt:character:alternative:down:">keyAt: keyNumber character: aCharacter alternative: alternativeCharacter down: isDownTransition 	"A keyboard key has been pressed or released; take appropriate action"	| keyboardEvent |	(self state isModifierKey: aCharacter) ifTrue: [^self].	(self allProcessInterruptMatchesCharacter: aCharacter inTransition: isDownTransition) ifTrue: 		[^DebuggerService interruptAllUserProcesses].	(self warpToLauncherMatchesCharacter: aCharacter inTransition: isDownTransition) ifTrue: 		[^#{VisualLauncher} ifDefinedDo: [:launcherClass | launcherClass raiseOrOpen]].	(aCharacter = self state class interruptKeyValue and: [isDownTransition]) 		ifTrue: 			[(self state shiftDown or: [(keyNumber bitAnd: 256) ~= 0]) 				ifTrue: [[EmergencyWindow open] fork]				ifFalse: [DebuggerService interruptActiveUserProcess]]		ifFalse: 			[isDownTransition 				ifTrue: [keyboardEvent := KeyPressedEvent new]				ifFalse: [keyboardEvent := KeyReleasedEvent new].			keyboardEvent := keyboardEvent 						code: aCharacter						meta: (self state metaState bitOr: (keyNumber bitShift: -8))						alternative: alternativeCharacter.			self addMetaInput: (keyboardEvent window: window)]</body></methods><methods><class-id>Tools.Notifier class</class-id> <category>class initialization</category><body package="Debugger-UI" selector="beDevelopment">beDevelopment	"Initialize the current instance variable with a DevelopmentNotifier."	current := self developmentNotifier.</body></methods><methods><class-id>Tools.Notifier class</class-id> <category>accessing</category><body package="Debugger-UI" selector="developmentNotifier">developmentNotifier	^DebuggerService</body></methods><methods><class-id>Tools.Notifier class</class-id> <category>testing</category><body package="Debugger-UI" selector="isDevelopment">isDevelopment	"Answer true if the current notifier is for a development image."	^current == self developmentNotifier</body></methods><methods><class-id>Core.SystemNotification</class-id> <category>private - actions</category><body package="Debugger-UI" selector="defaultAction">defaultAction	self aboutToDebug.	^Notifier openException: self</body></methods><methods><class-id>UI.ScrollingView</class-id> <category>scrolling</category><body package="Debugger-UI" selector="scrollOffsetHolder">scrollOffsetHolder	^scrollOffset</body></methods><methods><class-id>CraftedSmalltalk.DebuggerClient class</class-id> <category>resources</category><body package="Debugger-UI" selector="acceptGroup">acceptGroup	"Tools.MenuEditor new openOnClass: self andSelector: #acceptGroup"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Accept 					#defaultString: '&amp;Accept' 					#catalogID: #menus ) 				#value: #accept 				#shortcutKeyCharacter: $s 				#shortcutModifiers: 2 )			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Format 					#defaultString: '&amp;Format' 					#catalogID: #menus ) 				#value: #format 				#shortcutKeyCharacter: $O 				#shortcutModifiers: 2 ) ) #(2 ) nil ) decodeAsLiteralArray</body><body package="Debugger-UI" selector="bookmarkMenu">bookmarkMenu	"Tools.MenuEditor new openOnClass: self andSelector: #bookmarkMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Set #defaultString: '&amp;Set' #catalogID: #pdp) 				#nameKey: #addTag 				#value: #addTag 				#enablementSelector: #canAddTag ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Clear #defaultString: '&amp;Clear' #catalogID: #pdp) 				#nameKey: #removeTag 				#value: #removeTag 				#enablementSelector: #canRemoveTag ) ) #(2 ) nil ) decodeAsLiteralArray</body><body package="Debugger-UI" selector="browseGroup">browseGroup	"Tools.MenuEditor new openOnClass: self andSelector: #browseGroup"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseClass 					#defaultString: 'Browse Class' 					#catalogID: #pdp ) 				#value: #browseClassFromSourceView 				#enablementSelector: #hasClassSelected 				#shortcutKeyCharacter: #F12 				#shortcutModifiers: 2 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseReferencesToClass 					#defaultString: 'Browse References to Class' 					#catalogID: #pdp ) 				#value: #browseClassReferencesFromSourceView 				#enablementSelector: #hasClassSelected 				#shortcutKeyCharacter: #F11 				#shortcutModifiers: 2 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseVariableReferences 					#defaultString: 'Browse Variable References'					#catalogID: #pdp ) 				#value: #browseInstanceVariableReferences 				#enablementSelector: #hasInstanceVariableSelected 				#shortcutKeyCharacter: #F11 				#shortcutModifiers: 2 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseVariableReaders 					#defaultString: 'Browse Variable Readers' 					#catalogID: #pdp ) 				#value: #browseInstanceVariableReaders 				#enablementSelector: #hasInstanceVariableSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseVariableWriters 					#defaultString: 'Browse Variable Writers' 					#catalogID: #pdp ) 				#value: #browseInstanceVariableWriters 				#enablementSelector: #hasInstanceVariableSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseSendersOfSelector 					#defaultString: 'Browse Senders of Selector' 					#catalogID: #pdp ) 				#value: #browseSendersFromSourceView 				#enablementSelector: #hasMessageNodeSelected 				#shortcutKeyCharacter: #F11 				#shortcutModifiers: 2 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #BrowseImplementorsOfSelector 					#defaultString: 'Browse Implementors of Selector' 					#catalogID: #pdp ) 				#value: #browseImplementorsFromSourceView 				#enablementSelector: #hasMessageNodeSelected 				#shortcutKeyCharacter: #F12 				#shortcutModifiers: 2 ) ) #(7 ) nil ) decodeAsLiteralArray</body><body package="Debugger-UI" selector="cancelGroup">cancelGroup	"Tools.MenuEditor new openOnClass: self andSelector: #cancelGroup"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Cancel 					#defaultString: '&amp;Cancel' 					#catalogID: #menus ) 				#value: #redisplayText ) ) #(1 ) nil ) decodeAsLiteralArray</body><body package="Debugger-UI" selector="contextMenu">contextMenu	"Tools.MenuEditor new openOnClass: self andSelector: #contextMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Bookmark #defaultString: '&amp;Bookmark' #catalogID: #pdp) 				#nameKey: #bookmarkMenu ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Select_HomeContext #defaultString: 'Select &amp;Home Context' #catalogID: #pdp) 				#value: #selectHomeContext 				#enablementSelector: #canSelectHome 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #home ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Inspect #defaultString: '&amp;Inspect' #catalogID: #pdp) 				#nameKey: #inspectContext 				#value: #inspectContext 				#enablementSelector: #hasValidContext 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #inspect ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Senders #defaultString: '&amp;Senders' #catalogID: #pdp) 				#nameKey: #allSenders 				#value: #browseAllSenders 				#enablementSelector: #hasValidContext ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #I_mplementors #defaultString: 'I&amp;mplementors' #catalogID: #pdp) 				#nameKey: #allImplementors 				#value: #browseAllImplementors 				#enablementSelector: #hasValidContext ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #HierarchySe_nders #defaultString: 'Hierarchy Se&amp;nders' #catalogID: #pdp) 				#nameKey: #localSenders 				#value: #browseLocalSenders 				#enablementSelector: #hasValidContext ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #HierarchyIm_plementors #defaultString: 'Hierarchy Im&amp;plementors' #catalogID: #pdp) 				#nameKey: #localImplementors 				#value: #browseLocalImplementors 				#enablementSelector: #hasValidContext ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_BrowseClass #defaultString: '&amp;Browse Class' #catalogID: #pdp) 				#nameKey: #browseClass 				#value: #browseClass 				#enablementSelector: #hasValidContext ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_DefineMethod #defaultString: '&amp;Define Method' #catalogID: #pdp) 				#nameKey: #defineMethod 				#value: #defineMethod 				#enablementSelector: #canDefineMethod ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_CorrectSelector #defaultString: '&amp;Correct Selector' #catalogID: #pdp) 				#nameKey: #correctSpelling 				#value: #correctSpelling 				#enablementSelector: #canCorrectSpelling ) ) #(3 4 1 2 ) nil ) decodeAsLiteralArray</body><body package="Debugger-UI" selector="editGroup">editGroup	"Tools.MenuEditor new openOnClass: self andSelector: #editGroup"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cu_t 					#defaultString: 'Cu&amp;t' 					#catalogID: #menus ) 				#value: #cut 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #cut ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Copy 					#defaultString: '&amp;Copy' 					#catalogID: #menus ) 				#value: #copySelection 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #copy ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Paste 					#defaultString: '&amp;Paste' 					#catalogID: #menus ) 				#value: #paste 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #paste ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_FindDot 					#defaultString: '&amp;Find...' 					#catalogID: #menus ) 				#value: #find ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_ReplaceDot 					#defaultString: '&amp;Replace...' 					#catalogID: #menus ) 				#value: #replace ) ) #(3 2 ) nil ) decodeAsLiteralArray</body><body package="Debugger-UI" selector="evaluateGroup">evaluateGroup	"Tools.MenuEditor new openOnClass: self andSelector: #evaluateGroup"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DoIt 					#defaultString: '&amp;Do it' 					#catalogID: #menus ) 				#value: #doIt 				#shortcutKeyCharacter: $d 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #doIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_PrintIt 					#defaultString: '&amp;Print it' 					#catalogID: #menus ) 				#value: #printIt 				#shortcutKeyCharacter: $p 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #printIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_InspectIt 					#defaultString: '&amp;Inspect it' 					#catalogID: #menus ) 				#value: #inspectIt 				#shortcutKeyCharacter: $q 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #inspectIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #De_bugIt 					#defaultString: 'De&amp;bug it' 					#catalogID: #menus ) 				#value: #debugIt 				#shortcutKeyCharacter: $B 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #debugIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Explain 					#defaultString: '&amp;Explain' 					#catalogID: #menus ) 				#value: #explain 				#shortcutKeyCharacter: $E 				#shortcutModifiers: 2 ) ) #(4 1 ) nil ) decodeAsLiteralArray</body><body package="Debugger-UI" selector="executeMenuDefault">executeMenuDefault	"Tools.MenuEditor new openOnClass: self andSelector: #executeMenuDefault"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Step_Into #defaultString: 'Step &amp;Into' #catalogID: #pdp) 				#nameKey: #send 				#value: #send 				#enablementSelector: #enableSendCommand 				#shortcutKeyCharacter: #F5 				#shortcutModifiers: 0 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #debugStepInto ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Step #defaultString: '&amp;Step' #catalogID: #pdp) 				#nameKey: #stepIntoBlock 				#value: #stepIntoBlock 				#enablementSelector: #enableSendCommand 				#shortcutKeyCharacter: #F6 				#shortcutModifiers: 0 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #debugStep ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Step_Over #defaultString: 'Step &amp;Over' #catalogID: #pdp) 				#nameKey: #step 				#value: #step 				#enablementSelector: #canIssueContextCommand 				#shortcutKeyCharacter: #F7 				#shortcutModifiers: 0 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #debugStepOver ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #R_estart #defaultString: 'R&amp;estart' #catalogID: #pdp) 				#nameKey: #reenter 				#value: #reenter 				#enablementSelector: #canIssueContextCommand 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #debugRestart ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Ret_urnDots #defaultString: 'Ret&amp;urn...' #catalogID: #pdp) 				#nameKey: #return 				#value: #return 				#enablementSelector: #canIssueContextCommand 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #debugReturn ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #RunTo_Caret #defaultString: 'Run to &amp;Caret' #catalogID: #pdp) 				#nameKey: #skip 				#value: #skipToCaret 				#enablementSelector: #canIssueContextCommand 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #debugRunToCaret ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_JumpToCaret #defaultString: '&amp;Jump to Caret' #catalogID: #pdp) 				#nameKey: #jump 				#value: #jumpToCaret 				#enablementSelector: #canIssueContextCommand 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #debugJumpToCaret ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Run #defaultString: '&amp;Run' #catalogID: #pdp) 				#nameKey: #continue 				#value: #continue 				#enablementSelector: #canRun 				#shortcutKeyCharacter: #F9 				#shortcutModifiers: 0 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #debugRun ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #RunWith_BreakOnReturn #defaultString: 'Run with &amp;Break on Return' #catalogID: #pdp) 				#nameKey: #firstLoop 				#value: #firstLoop 				#enablementSelector: #canIssueContextCommand 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #debugFirstLoop ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #RunWithBrea_kAgain #defaultString: 'Run with Brea&amp;k Again' #catalogID: #pdp) 				#nameKey: #nextLoop 				#value: #nextLoop 				#enablementSelector: #canDoNextLoop 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #debugNextLoop ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Terminate #defaultString: '&amp;Terminate' #catalogID: #pdp) 				#value: #closeRequest 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #delete ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Abort #defaultString: '&amp;Abort' #catalogID: #pdp) 				#nameKey: #abortDebugOperation 				#value: #abortDebugOperation 				#enablementSelector: #isBusy 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #abort ) ) ) #(3 4 1 2 1 1 ) nil ) decodeAsLiteralArray</body><body package="Debugger-UI" selector="hardcopyGroup">hardcopyGroup	"MenuEditor new openOnClass: self andSelector: #hardcopyGroup"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Hardcopy 					#defaultString: '&amp;Hardcopy' 					#catalogID: #menus ) 				#value: #hardcopy ) ) #(1 ) nil ) decodeAsLiteralArray</body><body package="Debugger-UI" selector="menuBarMenu">menuBarMenu	"Tools.MenuEditor new openOnClass: self andSelector: #menuBarMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Stack 					#defaultString: '&amp;Stack' 					#catalogID: #pdp ) 				#nameKey: #stackMenu ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Method 					#defaultString: '&amp;Method' 					#catalogID: #pdp ) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Senders 								#defaultString: '&amp;Senders' 								#catalogID: #pdp ) 							#nameKey: #allSenders 							#value: #browseAllSenders 							#enablementSelector: #hasValidContext ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Implementors 								#defaultString: '&amp;Implementors' 								#catalogID: #pdp ) 							#nameKey: #allImplementors 							#value: #browseAllImplementors 							#enablementSelector: #hasValidContext ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #HierarchySe_nders 								#defaultString: 'Hierarchy Se&amp;nders' 								#catalogID: #pdp ) 							#nameKey: #localSenders 							#value: #browseLocalSenders 							#enablementSelector: #hasValidContext ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #HierarchyI_mplementors 								#defaultString: 'Hierarchy I&amp;mplementors' 								#catalogID: #pdp ) 							#nameKey: #localImplementors 							#value: #browseLocalImplementors 							#enablementSelector: #hasValidContext ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_BrowseClass 								#defaultString: '&amp;Browse Class' 								#catalogID: #pdp ) 							#nameKey: #browseClass 							#value: #browseClass 							#enablementSelector: #hasValidContext ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Browse_Versions 								#defaultString: 'Browse &amp;Versions' 								#catalogID: #pdp ) 							#nameKey: #browseVersions 							#value: #browseVersions 							#enablementSelector: #hasValidContext ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ShowContaining_PackageDots 								#defaultString: 'Show Containing &amp;Package...' 								#catalogID: #pdp ) 							#nameKey: #containingPackage 							#value: #containingPackage 							#enablementSelector: #hasValidContext ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_RecompileWithFullBlocks 								#defaultString: '&amp;Recompile with Full Blocks' 								#catalogID: #pdp ) 							#nameKey: #makeFullMethod 							#value: #makeFullMethod 							#enablementSelector: #canIssueContextCommand ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Re_vertDots 								#defaultString: 'Re&amp;vert...' 								#catalogID: #pdp ) 							#nameKey: #revert 							#value: #revert 							#enablementSelector: #enableDebugCommand ) ) #(2 2 3 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Edit 					#defaultString: '&amp;Edit' 					#catalogID: #pdp ) 				#nameKey: #editMenu ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #E_xecute 					#defaultString: 'E&amp;xecute' 					#catalogID: #pdp ) 				#nameKey: #executeMenu ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Correct 					#defaultString: '&amp;Correct' 					#catalogID: #pdp ) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_DefineMethod 								#defaultString: '&amp;Define Method' 								#catalogID: #pdp ) 							#nameKey: #defineMethod 							#value: #defineMethod 							#enablementSelector: #canDefineMethod 							#shortcutKeyCharacter: #F4 							#shortcutModifiers: 0 ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_CorrectSelector 								#defaultString: '&amp;Correct Selector' 								#catalogID: #pdp ) 							#nameKey: #correctSpelling 							#value: #correctSpelling 							#enablementSelector: #canCorrectSpelling 							#shortcutKeyCharacter: #F4 							#shortcutModifiers: 2 ) ) #(2 ) nil ) ) ) #(5 ) nil ) decodeAsLiteralArray</body><body package="Debugger-UI" selector="pdpTextMenuAdditions">pdpTextMenuAdditions	"Tools.MenuEditor new openOnClass: self andSelector: #pdpTextMenuAdditions"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #InsertBreakpoint 					#defaultString: 'Insert Breakpoint' 					#catalogID: #pdp ) 				#nameKey: #insertBreakpoint 				#value: #addBreakpoint ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #InsertProbeDots 					#defaultString: 'Insert Probe...' 					#catalogID: #pdp ) 				#nameKey: #insertProbe 				#value: #addProbe ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #EditProbeDots 					#defaultString: 'Edit Probe...' 					#catalogID: #pdp ) 				#nameKey: #modifyProbe 				#value: #modifyProbe ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #RemoveThisProbe 					#defaultString: 'Remove This Probe' 					#catalogID: #pdp ) 				#nameKey: #removeSelectedProbe 				#value: #removeProbe ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #RemoveAllProbes 					#defaultString: 'Remove All Probes' 					#catalogID: #pdp ) 				#nameKey: #removeAllProbes 				#value: #removeAllProbes ) ) #(5 ) nil ) decodeAsLiteralArray</body><body package="Debugger-UI" selector="stackMenu">stackMenu	"Tools.MenuEditor new openOnClass: self andSelector: #stackMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_CopyStackReport #defaultString: '&amp;Copy Stack Report' #catalogID: #pdp) 				#nameKey: #copyStack 				#value: #copyStack 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #copy ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Show_More #defaultString: 'Show &amp;More' #catalogID: #pdp) 				#nameKey: #moreStack 				#value: #moreStack 				#enablementSelector: #canShowMore ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_FilterStack #defaultString: '&amp;Filter Stack' #catalogID: #pdp) 				#nameKey: #filterStack 				#value: #toggleStackFiltering ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #UseShortClass_Names #defaultString: 'Use Short Class &amp;Names' #catalogID: #pdp) 				#nameKey: #toggleShortClassNames 				#value: #toggleShortClassNames ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Select_HomeContext #defaultString: 'Select &amp;Home Context' #catalogID: #pdp) 				#nameKey: #selectHomeContext 				#value: #selectHomeContext 				#enablementSelector: #canSelectHome 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #home ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_InspectContext #defaultString: '&amp;Inspect Context' #catalogID: #pdp) 				#nameKey: #inspectContext 				#value: #inspectContext 				#enablementSelector: #hasValidContext 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #inspect ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_BookmarkContext #defaultString: '&amp;Bookmark Context' #catalogID: #pdp) 				#nameKey: #newTag 				#value: #addTag 				#enablementSelector: #canAddTag 				#shortcutKeyCharacter: #F2 				#shortcutModifiers: 0 ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Clear_Bookmark #defaultString: 'Clear &amp;Bookmark' #catalogID: #pdp) 				#nameKey: #removeTag 				#value: #removeTag 				#enablementSelector: #canRemoveTag ) ) #(2 2 4 ) nil ) decodeAsLiteralArray</body><body package="Debugger-UI" selector="textMenuExtras">textMenuExtras	"Tools.MenuEditor new openOnClass: self andSelector: #textMenuExtras"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Format 					#defaultString: '&amp;Format' 					#catalogID: #menus ) 				#nameKey: #Format 				#value: #format 				#shortcutKeyCharacter: $o 				#shortcutModifiers: 2 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Explain 					#defaultString: '&amp;Explain' 					#catalogID: #menus ) 				#value: #explain ) ) #(2 ) nil ) decodeAsLiteralArray</body><body package="Debugger-UI" selector="toolbarMenu">toolbarMenu	"Tools.MenuEditor new openOnClass: self andSelector: #toolbarMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #StepInto #defaultString: 'Step Into' #catalogID: #pdp) 				#nameKey: #send 				#value: #send 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #debugStepInto ) 				#helpText: #(#{Kernel.UserMessage} #key: #StepIntoButtonHelp #defaultString: 'Step, stepping into message sends' #catalogID: #pdp) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Step #defaultString: 'Step' #catalogID: #pdp) 				#nameKey: #stepIntoBlock 				#value: #stepIntoBlock 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #debugStep ) 				#helpText: #(#{Kernel.UserMessage} #key: #StepButtonHelp #defaultString: 'Step' #catalogID: #pdp) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #StepOver #defaultString: 'Step Over' #catalogID: #pdp) 				#nameKey: #step 				#value: #step 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #debugStepOver ) 				#helpText: #(#{Kernel.UserMessage} #key: #StepOverButtonHelp #defaultString: 'Step, stepping over blocks' #catalogID: #pdp) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Restart #defaultString: 'Restart' #catalogID: #pdp) 				#nameKey: #reenter 				#value: #reenter 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #debugRestart ) 				#helpText: #(#{Kernel.UserMessage} #key: #RestartButtonHelp #defaultString: 'Restart execution from the beginning of this context' #catalogID: #pdp) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Return #defaultString: 'Return' #catalogID: #pdp) 				#nameKey: #return 				#value: #return 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #debugReturn ) 				#helpText: #(#{Kernel.UserMessage} #key: #ReturnButtonHelp #defaultString: 'Return from this context' #catalogID: #pdp) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #RunToCaret #defaultString: 'Run to Caret' #catalogID: #pdp) 				#nameKey: #skip 				#value: #skipToCaret 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #debugRunToCaret ) 				#helpText: #(#{Kernel.UserMessage} #key: #RunToCaretButtonHelp #defaultString: 'Run to caret' #catalogID: #pdp) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #JumpToCaret #defaultString: 'Jump to Caret' #catalogID: #pdp) 				#nameKey: #jumpToCaret 				#value: #jumpToCaret 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #debugJumpToCaret ) 				#helpText: #(#{Kernel.UserMessage} #key: #JumpToCaretButtonHelp #defaultString: 'Jump to caret without executing any code' #catalogID: #pdp) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Run #defaultString: 'Run' #catalogID: #pdp) 				#nameKey: #continue 				#value: #continue 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #debugRun ) 				#helpText: #(#{Kernel.UserMessage} #key: #RunButtonHelp #defaultString: 'Run' #catalogID: #pdp) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #RunWithBreakOnReturn #defaultString: 'Run with Break on Return' #catalogID: #pdp) 				#nameKey: #firstLoop 				#value: #firstLoop 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #debugFirstLoop ) 				#helpText: #(#{Kernel.UserMessage} #key: #RunWithBreakOnReturnButtonHelp #defaultString: 'Run with break on return' #catalogID: #pdp) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #RunWithBreakAgain #defaultString: 'Run with Break Again' #catalogID: #pdp) 				#nameKey: #nextLoop 				#value: #nextLoop 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #debugNextLoop ) 				#helpText: #(#{Kernel.UserMessage} #key: #RunWithBreakAgainButtonHelp #defaultString: 'Run with break on return again' #catalogID: #pdp) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Terminate #defaultString: 'Terminate' #catalogID: #pdp) 				#value: #closeRequest 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #delete ) 				#helpText: #(#{Kernel.UserMessage} #key: #TerminateButtonHelp #defaultString: 'Terminate this process and close the debugger' #catalogID: #pdp) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #SelectHome #defaultString: 'Select Home' #catalogID: #pdp) 				#nameKey: #selectHome 				#value: #selectHomeContext 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #home ) 				#helpText: #(#{Kernel.UserMessage} #key: #SelectHomeButtonHelp #defaultString: 'Select the home of this context' #catalogID: #pdp) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #InspectContext #defaultString: 'Inspect Context' #catalogID: #pdp) 				#nameKey: #inspectContext 				#value: #inspectContext 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #inspect ) 				#helpText: #(#{Kernel.UserMessage} #key: #InspectThisContextButtonHelp #defaultString: 'Inspect this context' #catalogID: #pdp) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Abort #defaultString: 'Abort' #catalogID: #pdp) 				#nameKey: #abort 				#value: #abortDebugOperation 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #abort ) 				#helpText: #(#{Kernel.UserMessage} #key: #AbortButtonHelp #defaultString: 'Abort current debug operation' #catalogID: #pdp) ) ) #(3 4 1 2 1 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>CraftedSmalltalk.DebuggerClient class</class-id> <category>interface specs</category><body package="Debugger-UI" selector="blockReturnSpec">blockReturnSpec	"UIPainter new openOnClass: self andSelector: #blockReturnSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #ReturnFromBlock #defaultString: 'Return from block' #catalogID: #pdp) 			#bounds: #(#{Graphics.Rectangle} 640 512 979 758 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 204 42 ) 					#name: #methodReturn 					#model: #returnType 					#label: #(#{Kernel.UserMessage} #key: #MethodReturn #defaultString: 'Method Return' #catalogID: #pdp) 					#select: 					#methodReturn: ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 204 74 ) 					#name: #blockReturn 					#model: #returnType 					#label: #(#{Kernel.UserMessage} #key: #BlockReturn #defaultString: 'Block Return' #catalogID: #pdp) 					#select: 					#return: ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.Rectangle} 0 0 206 237 ) 					#flags: 0 					#majorKey: #{CraftedSmalltalk.DebuggerClient} 					#minorKey: #methodReturnSpec ) ) ) )</body><body package="Debugger-UI" selector="methodReturnSpec">methodReturnSpec	"UIPainter new openOnClass: self andSelector: #methodReturnSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #MethodReturn #defaultString: 'Method Return' #catalogID: #pdp) 			#min: #(#Point 200 246 ) 			#max: #(#Point 200 246 ) 			#bounds: #(#Rectangle 614 301 814 547 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#Point 35 9 ) 					#label: #(#{Kernel.UserMessage} #key: #SelectReturnValue #defaultString: 'Select Return Value' #catalogID: #pdp) ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 20 39 177 65 ) 					#model: #returnSelf 					#label: #(#{Kernel.UserMessage} #key: #self #defaultString: 'self' #catalogID: #pdp) 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 20 72 177 98 ) 					#name: #returnTOS 					#model: #returnTOS 					#label: #(#{Kernel.UserMessage} #key: #TopOfStack #defaultString: 'Top of Stack' #catalogID: #pdp) 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 20 106 177 132 ) 					#model: #returnLastDoIt 					#label: #(#{Kernel.UserMessage} #key: #ResultOfLastDoIt #defaultString: 'Result of last DoIt' #catalogID: #pdp) 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 20 140 177 166 ) 					#model: #returnNewExpr 					#label: #(#{Kernel.UserMessage} #key: #EvaluateExpression #defaultString: 'Evaluate Expression' #catalogID: #pdp) 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 20 191 177 217 ) 					#model: #cancel 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #pdp) 					#defaultable: true ) ) ) )</body><body package="Debugger-UI" selector="toolbarInTheMiddleWindowSpec">toolbarInTheMiddleWindowSpec	"Tools.UIPainter new openOnClass: self andSelector: #toolbarInTheMiddleWindowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 720 312 1301 900 ) 			#flags: 4 			#menu: #menuBarMenu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 2 0.3 0 1 -2 0.8 ) 					#name: #text 					#model: #textHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#textAccepted: ) 					#tabable: true 					#menu: #textMenu 					#tabRequiresControl: true ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 2 0.8 -2 0.5 0 1 ) 					#name: #receiverInspector 					#flags: 0 					#majorKey: #{Tools.Inspector} 					#minorKey: #windowSpec 					#clientKey: #receiverInspector ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.5 2 0.8 0 1 0 1 ) 					#name: #contextInspector 					#flags: 0 					#majorKey: #{Tools.Inspector} 					#minorKey: #windowSpec 					#clientKey: #contextInspector ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -2 0.8 0 1 2 0.8 ) 					#name: #BottomResizer 					#horizontal: true 					#minAboveSize: 60 					#minBelowSize: 60 					#aboveWidgets: '#text' 					#belowWidgets: '#receiverInspector #contextInspector #BotInspectResizer' ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -2 0.3 0 1 2 0.3 ) 					#name: #TopResizer 					#horizontal: true 					#minAboveSize: 60 					#minBelowSize: 60 					#aboveWidgets: 'TopComposite' 					#belowWidgets: 'text' ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -2 0.5 0 0.8 2 0.5 0 1 ) 					#name: #BotInspectResizer 					#horizontal: false 					#minAboveSize: 60 					#minBelowSize: 60 					#aboveWidgets: '#receiverInspector' 					#belowWidgets: 'contextInspector' ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.SequenceViewSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -2 0.6 -28 1 ) 							#name: #stackList 							#model: #stackList 							#callbacksSpec: 							#(#{UI.UIEventCallbackSubSpec} 								#doubleClickSelector: #browseMethod 								#requestValueChangeSelector: 								#canContextChange: ) 							#menu: #contextMenu 							#useModifierKeys: true 							#selectionType: #highlight ) 						#(#{UI.SubCanvasSpec} 							#layout: #(#{Graphics.LayoutFrame} 2 0.6 0 0 0 1 -28 1 ) 							#name: #stackInspector 							#flags: 0 							#majorKey: #{CraftedSmalltalk.StackInspector} 							#minorKey: #windowSpec 							#clientKey: #stackInspector ) 						#(#{UI.ResizingSplitterSpec} 							#layout: #(#{Graphics.LayoutFrame} -2 0.6 0 0 2 0.6 -28 1 ) 							#name: #ResizingSplitter1 							#horizontal: false 							#minAboveSize: 60 							#minBelowSize: 60 							#aboveWidgets: '#stackList' 							#belowWidgets: '#stackInspector' ) 						#(#{UI.ArbitraryComponentSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0 -28 1 0 1 0 1 ) 							#name: #toolbarHolder 							#flags: 0 							#component: #toolbarView ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 -2 0.3 ) 						#name: #TopComposite ) ) ) ) )</body><body package="Debugger-UI" selector="toolbarOnTopWindowSpec">toolbarOnTopWindowSpec	"Tools.UIPainter new openOnClass: self andSelector: #toolbarOnTopWindowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 720 312 1301 900 ) 			#flags: 4 			#menu: #menuBarMenu 			#toolBar: #toolbarMenu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 2 0.3 0 1 -2 0.8 ) 					#name: #text 					#model: #textHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#textAccepted: ) 					#tabable: true 					#menu: #textMenu 					#tabRequiresControl: true ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 2 0.8 -2 0.5 0 1 ) 					#name: #receiverInspector 					#flags: 0 					#majorKey: #{Tools.Inspector} 					#minorKey: #windowSpec 					#clientKey: #receiverInspector ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.5 2 0.8 0 1 0 1 ) 					#name: #contextInspector 					#flags: 0 					#majorKey: #{Tools.Inspector} 					#minorKey: #windowSpec 					#clientKey: #contextInspector ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -2 0.8 0 1 2 0.8 ) 					#name: #BottomResizer 					#horizontal: true 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: '#text' 					#belowWidgets: '#receiverInspector #contextInspector #BotInspectResizer' ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -2 0.3 0 1 2 0.3 ) 					#name: #TopResizer 					#horizontal: true 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'TopComposite' 					#belowWidgets: 'text' ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.SubCanvasSpec} 							#layout: #(#{Graphics.LayoutFrame} 2 0.6 0 0 0 1 0 1 ) 							#name: #stackInspector 							#flags: 0 							#majorKey: #{CraftedSmalltalk.StackInspector} 							#minorKey: #windowSpec 							#clientKey: #stackInspector ) 						#(#{UI.SequenceViewSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -2 0.6 0 1 ) 							#name: #stackList 							#model: #stackList 							#callbacksSpec: 							#(#{UI.UIEventCallbackSubSpec} 								#doubleClickSelector: #browseMethod 								#requestValueChangeSelector: 								#canContextChange: ) 							#menu: #contextMenu 							#useModifierKeys: true 							#selectionType: #highlight ) 						#(#{UI.ResizingSplitterSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.6 -2 0 2 0.6 0 1 ) 							#name: #ResizingSplitter1 							#horizontal: false 							#minAboveSize: 30 							#minBelowSize: 30 							#aboveWidgets: '#stackList' 							#belowWidgets: '#stackInspector' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 -2 0.3 ) 						#name: #TopComposite ) ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -2 0.5 0 0.8 2 0.5 0 1 ) 					#name: #BotInspectResizer 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: '#receiverInspector' 					#belowWidgets: 'contextInspector' ) ) ) )</body></methods><methods><class-id>CraftedSmalltalk.ContextListPolicyEditor class</class-id> <category>interface specs</category><body package="Debugger-UI" selector="helpSpec">helpSpec	"UIPainter new openOnClass: self andSelector: #helpSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #Help #defaultString: 'Help' #catalogID: #pdp) 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 1024 768 ) 			#bounds: #(#{Graphics.Rectangle} 640 512 1140 912 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #TextEditor 					#model: #helpText 					#isReadOnly: false 					#tabRequiresControl: true ) ) ) )</body><body package="Debugger-UI" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #ContextListPolicyEditor #defaultString: 'Context list policy editor' #catalogID: #pdp) 			#min: #(#{Core.Point} 528 401 ) 			#max: #(#{Core.Point} 1024 768 ) 			#bounds: #(#{Graphics.Rectangle} 592 427 1120 828 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.175 5 0 0.5 0 ) 					#name: #PatternListLabel 					#label: #(#{Kernel.UserMessage} #key: #Patterns #defaultString: 'Patterns' #catalogID: #pdp) ) 				#(#{UI.SequenceViewSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragOkSelector 						#wantToDrag: #dragEnterSelector 						#dragEnter: #dragOverSelector 						#dragOver: #dragStartSelector 						#doDrag: #dropSelector 						#drop: #dragExitSelector 						#dragLeave: ) 					#layout: #(#{Graphics.LayoutFrame} 2 0 30 0 0 0.35 -60 1 ) 					#name: #patternList 					#model: #patternList 					#menu: #menu 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 25 0.35 30 0 90 0.35 53 0 ) 					#name: #newButton 					#model: #newPattern 					#label: #(#{Kernel.UserMessage} #key: #New #defaultString: 'New' #catalogID: #pdp) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 115 0.35 30 0 180 0.35 53 0 ) 					#name: #removeButton 					#model: #removePattern 					#label: #(#{Kernel.UserMessage} #key: #Remove #defaultString: 'Remove' #catalogID: #pdp) 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 13 0.35 105 0 -9 0.75 128 0 ) 					#name: #patternNameInput 					#model: #patternName ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 8 0.75 105 0 87 0.75 128 0 ) 					#name: #colorButton 					#model: #selectColor 					#label: #(#{Kernel.UserMessage} #key: #PickColor #defaultString: 'Pick Color' #catalogID: #pdp) 					#defaultable: true ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 13 0.35 160 0 -8 1 -155 1 ) 					#name: #TextEditor1 					#model: #patternString 					#tabRequiresControl: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 13 0.35 85 0 ) 					#name: #Label1 					#label: #(#{Kernel.UserMessage} #key: #Name #defaultString: 'Name' #catalogID: #pdp) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.675 137 0 0.5 0 ) 					#name: #Label3 					#label: #(#{Kernel.UserMessage} #key: #PatternString #defaultString: 'Pattern String' #catalogID: #pdp) ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 6 0.35 65 0 -2 1 -145 1 ) 					#name: #GroupBox1 					#label: #(#{Kernel.UserMessage} #key: #Pattern #defaultString: 'Pattern' #catalogID: #pdp) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 12 0.35 -118 1 0 0.679924 -92 1 ) 					#name: #matchSelectorInputField 					#model: #matchSelector 					#type: #symbol ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 6 0.68 -118 1 -8 1 -92 1 ) 					#name: #conversionSelectorInputField 					#model: #conversionSelector 					#type: #symbol ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 12 0.35 -137 1 ) 					#name: #Label4 					#label: #(#{Kernel.UserMessage} #key: #MatchSelector #defaultString: 'Match Selector' #catalogID: #pdp) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 6 0.68 -137 1 ) 					#name: #Label5 					#label: #(#{Kernel.UserMessage} #key: #ConversionSelector #defaultString: 'Conversion Selector' #catalogID: #pdp) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} -100 0.5 -33 1 80 23 ) 					#name: #okButton 					#model: #accept 					#label: #(#{Kernel.UserMessage} #key: #Ok #defaultString: 'Ok' #catalogID: #pdp) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 20 0.5 -33 1 81 23 ) 					#name: #cancelButton 					#model: #cancel 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #pdp) 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 12 0.35 -82 1 ) 					#name: #Label2 					#label: #(#{Kernel.UserMessage} #key: #DisplayAllLimit #defaultString: 'Display all limit' #catalogID: #pdp) ) 				#(#{UI.SpinButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 90 0.35 -83 1 150 0.35 -60 1 ) 					#name: #displayAllLimitField 					#model: #displayAllLimit 					#type: #number 					#formatString: '0' 					#low: 1 					#high: 100 					#interval: 1 ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} -10 1 -10 1 1 1 ) 					#name: #HelpButton 					#model: #help 					#label: #(#{Kernel.UserMessage} #key: #Help #defaultString: 'Help' #catalogID: #pdp) 					#defaultable: true ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -48 1 0 1 -44 1 ) 					#name: #Divider1 ) ) ) )</body></methods><methods><class-id>CraftedSmalltalk.ContextListPolicyEditor class</class-id> <category>resources</category><body package="Debugger-UI" selector="menu">menu	"MenuEditor new openOnClass: self andSelector: #menu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #New #defaultString: 'New' #catalogID: #pdp) 				#value: #newPattern ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Remove #defaultString: 'Remove' #catalogID: #pdp) 				#value: #removePattern 				#enablementSelector: #patternIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Undo #defaultString: 'Undo' #catalogID: #pdp) 				#nameKey: #undo 				#value: #undo 				#enablementSelector: #canUndo ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Copy #defaultString: 'Copy' #catalogID: #pdp) 				#value: #copy 				#enablementSelector: #patternIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Paste #defaultString: 'Paste' #catalogID: #pdp) 				#value: #paste 				#enablementSelector: #canPaste ) ) #(2 1 2 ) nil ) decodeAsLiteralArray</body><body package="Debugger-UI" selector="menuBar">menuBar	"MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Edit #defaultString: 'Edit' #catalogID: #pdp) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #New #defaultString: 'New' #catalogID: #pdp) 							#value: #newPattern ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Remove #defaultString: 'Remove' #catalogID: #pdp) 							#value: #removePattern 							#enablementSelector: #patternIsSelected ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Undo #defaultString: 'Undo' #catalogID: #pdp) 							#nameKey: #undo 							#value: #undo 							#enablementSelector: #canUndo ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Copy #defaultString: 'Copy' #catalogID: #pdp) 							#value: #copy 							#enablementSelector: #patternIsSelected ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Paste #defaultString: 'Paste' #catalogID: #pdp) 							#value: #paste 							#enablementSelector: #canPaste ) ) #(2 1 2 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><initialize><class-id>CraftedSmalltalk.RestartSignal</class-id></initialize><initialize><class-id>CraftedSmalltalk.DebuggerClient</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Notification</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>EventSensor</name><environment>UI</environment><super>UI.ApplicationWindowSensor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collapseEvents queueLocked </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events-Support</category><attributes><package>Interface-Events-Support</package></attributes></class><class><name>ScrollingView</name><environment>UI</environment><super>UI.SimpleView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scrollOffset </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>UserInterrupt</name><environment>Core</environment><super>Core.ControlInterrupt</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>SystemNotification</name><environment>Core</environment><super>Core.ControlInterrupt</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class></st-source>