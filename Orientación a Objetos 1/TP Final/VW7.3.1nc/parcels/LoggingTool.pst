<?xml version="1.0"?><st-source><!-- Name: LoggingToolNotice: Copyright © 2000-2005 Cincom Systems, Inc.  All Rights Reserved.Comment: LoggingTool provides support to log diagnostic messages and trace execution to a window.  Any object may send a diagnostic string with an optional identifying debug level name to the log.  The LoggingTool control environment logs messages from objects whose class and debug level name match those registered with the environment.  The contents of the log window may be saved to a file.DbIdentifier: bear73DbTrace: 35891PackageName: LoggingToolPackageName:: LoggingToolParcel: #('LoggingTool')ParcelName: LoggingToolPrintStringCache: (7.2 3,bobw)Version: 7.3.1Date: 5:51:30 pm April 10, 2005 --><time-stamp>From VisualWorks®, 7.3.1 of April 10, 2005 on April 10, 2005 at 5:51:30 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>LoggingTool</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Logging Tool</category><attributes><package>LoggingTool</package></attributes></class><comment><class-id>Tools.LoggingTool</class-id><body>Logging Tool is a user interface to display debugging information.Instance Variables:Class Variables:	LastBounds	&lt;Rectangle&gt;	The interface size	MyCollector	&lt;LogTextCollector&gt;	Collects debugging information</body></comment><class><name>LogTextCollector</name><environment>Tools</environment><super>UI.TextCollector</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Logging Tool</category><attributes><package>LoggingTool</package></attributes></class><comment><class-id>Tools.LogTextCollector</class-id><body>Class LogTextCollector  represents a ValueHolder for LoggingTool classInstance Variables:</body></comment><class><name>LogEnvironment</name><environment>Tools</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>debugStream debugCategories debugClasses trace logFileName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Logging Tool</category><attributes><package>LoggingTool</package></attributes></class><comment><class-id>Tools.LogEnvironment</class-id><body>Now the LogEnvironment class is used mostly for tracing and debugging purposes.Instance Variables:	debugStream	&lt;Stream&gt;	The debugged class put the information to the stream to display it using Logging Tool	debugCategories	&lt;Collection&gt;	The list of debug categories from the debugged classes	debugClasses	&lt;Collection&gt;	The list of registered classes to debug	trace	&lt;Boolean&gt;	Turns on and off the debug	logFileName	&lt;String&gt;	The name of external file to file out the debug informationClass Variables:	Environment	&lt;LogEnvironment&gt;	To be register for debugging the class should implement the following protocol:1. Specify the list of the class categories to debugaClass class &gt;&gt;debugLabelsAndValues 	^List new		add: ('IMAP Client Messages'-&gt;#IMAPClient);		add: ('IMAP Server Messages'-&gt;#IMAPServer);		yourself2. Menu item name for the class in Logging ToolaClass class &gt;&gt;menuItemName	^'IMAPClient Messages'3. Register with the LogEnvironment registerToDebug	Tools.LogEnvironment default addToDebug: selfTo print the debugging information into Logging Tool can be used 	LogEnvironment default log: aString level: aLevel</body></comment><shared-variable><name>Environment</name><environment>Tools.LogEnvironment</environment><private>false</private><constant>false</constant><category>default</category><initializer></initializer><attributes><package>LoggingTool</package></attributes></shared-variable><shared-variable><name>CharacterLimit</name><environment>Tools.LogTextCollector</environment><private>false</private><constant>false</constant><category>constants</category><initializer>50000</initializer><attributes><package>LoggingTool</package></attributes></shared-variable><shared-variable><name>LastBounds</name><environment>Tools.LoggingTool</environment><private>false</private><constant>false</constant><category>unknown</category><attributes><package>LoggingTool</package></attributes></shared-variable><shared-variable><name>MyCollector</name><environment>Tools.LoggingTool</environment><private>false</private><constant>false</constant><category>constants</category><attributes><package>LoggingTool</package></attributes></shared-variable><methods><class-id>Tools.LoggingTool</class-id> <category>private</category><body package="LoggingTool" selector="buildLoggingMenu">buildLoggingMenu	| logMenu |	logMenu := Menu new. 	self debugClasses do:		[ :debugClass | | item submenu | 			item := MenuItem labeled: debugClass menuItemName.			submenu := Menu new.			debugClass debugLabelsAndValues do: 				[ :association | | menuitem  |					menuitem := MenuItem labeled: association key.					menuitem indication: 						[ self debugCategories includes: association value ].					menuitem value: 						[( self debugCategories includes: association value)							ifTrue: 								[ self environment removeDebugCategory: association value]							ifFalse: 								[ self environment addDebugCategory: association value]].					submenu addItem: menuitem.				].			item submenu: submenu.			logMenu addItem: item.		].	^logMenu</body><body package="LoggingTool" selector="buildTracingMenu">buildTracingMenu	| menu menuitem |		menu := Menu new.	menuitem := MenuItem labeled: (#TraceON &lt;&lt; #dialogs &gt;&gt; 'Trace ON').	menuitem value: [ self environment traceOn ].	menuitem indication: [ self environment trace ].	menu addItem: menuitem.	menuitem := MenuItem labeled: (#TraceOFF &lt;&lt; #dialogs &gt;&gt; 'Trace OFF').	menuitem value: [ self environment traceOff ].	menuitem indication:  [ self environment trace not ].	menu addItem: menuitem.	^menu.</body><body package="LoggingTool" selector="debugCategories">debugCategories	^self environment debugCategories</body><body package="LoggingTool" selector="debugClasses">debugClasses	^self environment debugClasses</body></methods><methods><class-id>Tools.LoggingTool</class-id> <category>menu messages</category><body package="LoggingTool" selector="clear">clear	"Clears output."	self textCollector clear.</body><body package="LoggingTool" selector="saveOutput">saveOutput	^self environment saveOutput</body></methods><methods><class-id>Tools.LoggingTool</class-id> <category>views</category><body package="LoggingTool" selector="collector">collector	| textCollectorView |	textCollectorView := TextCollectorView model: self textCollector.	textCollectorView editText: self textCollector value.	textCollectorView controller: ParagraphEditor new.	^textCollectorView</body></methods><methods><class-id>Tools.LoggingTool</class-id> <category>accessing</category><body package="LoggingTool" selector="environment">environment	^self model</body><body package="LoggingTool" selector="model">model	model isNil		ifTrue: 			[model := LogEnvironment default.			model addDependent: self].	^model</body><body package="LoggingTool" selector="model:">model: aLogEnvironment		model := aLogEnvironment.	model addDependent: self.</body><body package="LoggingTool" selector="textCollector">textCollector	^self class myCollector</body></methods><methods><class-id>Tools.LoggingTool</class-id> <category>update</category><body package="LoggingTool" selector="noticeOfWindowClose:">noticeOfWindowClose: aWindow	"The ApplicationWindow aWindow is in the process of closing."	model removeDependent: self.	super noticeOfWindowClose: aWindow</body></methods><methods><class-id>Tools.LoggingTool</class-id> <category>interface opening</category><body package="LoggingTool" selector="postBuildWith:">postBuildWith: aBuilder 	super postBuildWith: aBuilder.	((builder menuAt: #windowMenu) atNameKey: #logging) 		submenu: self buildLoggingMenu.	((builder menuAt: #windowMenu) atNameKey: #trace) 		submenu: self buildTracingMenu.	self environment debugStream: self textCollector.</body><body package="LoggingTool" selector="postOpenWith:">postOpenWith: aBuilder 	| view |	super postOpenWith: aBuilder.	view := (aBuilder componentAt: #collector) widget.	view selectionIndex: view text size + 1.	view selectAndScroll.	view deselect.</body></methods><methods><class-id>Tools.LoggingTool class</class-id> <category>accessing</category><body package="LoggingTool" selector="clear">clear	self myCollector clear</body><body package="LoggingTool" selector="initCollector">initCollector	MyCollector := nil</body><body package="LoggingTool" selector="lastBounds">lastBounds	"Clients should check for nil."	^LastBounds</body><body package="LoggingTool" selector="lastBounds:">lastBounds: rectangle	LastBounds := rectangle</body><body package="LoggingTool" selector="myCollector">myCollector	MyCollector isNil		ifTrue: [ MyCollector := LogTextCollector new ].	^ MyCollector</body></methods><methods><class-id>Tools.LoggingTool class</class-id> <category>class-initialization</category><body package="LoggingTool" selector="obsolete">obsolete	MyCollector := nil.	super obsolete</body></methods><methods><class-id>Tools.LoggingTool class</class-id> <category>interface opening</category><body package="LoggingTool" selector="open">open	"Open an Interface.  If an interface is already open raise it."	self raiseSingleInstance isNil ifTrue: [^super open]</body><body package="LoggingTool" selector="openWith:">openWith: aLogEnvironment	"Open an interface.  If an interface is already open raise it."	| obj |	(obj := self new)		model: aLogEnvironment.	obj open.</body></methods><methods><class-id>Tools.LogTextCollector</class-id> <category>entry control</category><body package="LoggingTool" selector="beginEntry">beginEntry	"use a text stream"	entryStream := TextStream on: (String new: CharacterLimit)</body></methods><methods><class-id>Tools.LogTextCollector</class-id> <category>private</category><body package="LoggingTool" selector="characterLimit">characterLimit	^characterLimit isNil		ifTrue: [characterLimit := CharacterLimit]		ifFalse: [characterLimit]</body></methods><methods><class-id>Tools.LogTextCollector</class-id> <category>accessing</category><body package="LoggingTool" selector="nextPutAll:">nextPutAll: aCollection 	"Append all the characters in aCollection to the text."	^entryStream nextPutAllText: aCollection</body></methods><methods><class-id>Tools.LogEnvironment</class-id> <category>private</category><body package="LoggingTool" selector="addDebugCategory:">addDebugCategory: symbol 	self debugCategories add: symbol</body><body package="LoggingTool" selector="removeDebugCategory:">removeDebugCategory: symbol 	self debugCategories remove: symbol</body><body package="LoggingTool" selector="reset">reset	self resetDebugClasses.	self resetDebugCategories.</body><body package="LoggingTool" selector="resetDebugCategories">resetDebugCategories	debugCategories := nil</body><body package="LoggingTool" selector="resetDebugClasses">resetDebugClasses	debugClasses := nil</body></methods><methods><class-id>Tools.LogEnvironment</class-id> <category>registration</category><body package="LoggingTool" selector="addToDebug:">addToDebug: aClass	self debugClasses add: aClass.</body></methods><methods><class-id>Tools.LogEnvironment</class-id> <category>debugging</category><body package="LoggingTool" selector="debug:level:">debug: aBlock level: aLevel	( self trace and: [ self debugCategories includes: aLevel ] ) ifTrue: [ aBlock value]</body><body package="LoggingTool" selector="log:">log: aStringOrBlock		self log: aStringOrBlock level: #general</body><body package="LoggingTool" selector="log:level:">log: aStringOrBlock level: aLevel	| stream i briefMsg aMsg |	self 		debug:			[(stream := self debugStream) == nil ifTrue: [^self].			aMsg := ((aStringOrBlock isKindOf: BlockClosure)				ifTrue: [ aStringOrBlock value ]				ifFalse: [ aStringOrBlock ]) asString.			i := aMsg size.			[i &gt; 0 and: [(aMsg at: i) isSeparator]] whileTrue: [i := i - 1].			briefMsg := aMsg copyFrom: 1 to: i.			stream cr; nextPutAll: briefMsg; cr; flush]		level: aLevel</body><body package="LoggingTool" selector="printTrace:">printTrace: aString	| stream |	(stream := self debugStream) == nil ifTrue: [^self].	stream cr; cr; nextPutAll: ' **** ' asString.	Date today printOn: stream.	stream nextPutAll: ' '.		Time now printOn: stream.	stream nextPutAll: ' ', aString asString, ' ****'; flush.</body><body package="LoggingTool" selector="traceOff">traceOff	self printTrace: (#StopTrace &lt;&lt; #dialogs &gt;&gt; 'Stop Trace').	self trace: false.</body><body package="LoggingTool" selector="traceOn">traceOn	self trace: true.	self printTrace: (#StartTrace &lt;&lt; #dialogs &gt;&gt; 'Start Trace').</body></methods><methods><class-id>Tools.LogEnvironment</class-id> <category>accessing</category><body package="LoggingTool" selector="debugCategories">debugCategories	debugCategories isNil		ifTrue: [ debugCategories := Set new.				debugCategories add: #general ].	^debugCategories</body><body package="LoggingTool" selector="debugClasses">debugClasses	^debugClasses isNil		ifTrue: [ debugClasses  := Set new.]		ifFalse: [ debugClasses ].</body><body package="LoggingTool" selector="debugStream">debugStream	^debugStream</body><body package="LoggingTool" selector="debugStream:">debugStream: aStream	debugStream := aStream</body><body package="LoggingTool" selector="logFileName">logFileName	logFileName isNil		ifTrue: [ logFileName  := 'LogOutput.txt'].	^ logFileName</body><body package="LoggingTool" selector="logFileName:">logFileName: aString	logFileName := aString</body><body package="LoggingTool" selector="trace">trace	trace isNil		ifTrue: [ trace := false].	^ trace</body><body package="LoggingTool" selector="trace:">trace: aBoolean	 trace := aBoolean</body></methods><methods><class-id>Tools.LogEnvironment</class-id> <category>actions</category><body package="LoggingTool" selector="getFileName">getFileName	"Prompt the user for a filename and open the file."	| fileName  |	fileName := self logFileName.	fileName := Dialog 					requestFileName: (#PleaseEnterFileName &lt;&lt; #dialogs &gt;&gt; 'Please, enter file name ')					default: fileName.	^fileName isEmpty 		ifTrue: [nil]		ifFalse: [ fileName]</body><body package="LoggingTool" selector="saveOutput">saveOutput	"Prompt the user for a filename and save the log in to this file."	| fileName logFile |	(fileName := self getFileName) isNil ifTrue: [ ^nil].	logFile := (Filename named: fileName) writeStream.	[logFile nextPutAll: self debugStream value string.	logFile flush.	] ensure: [ logFile close ].</body></methods><methods><class-id>Tools.LogEnvironment class</class-id> <category>accessing</category><body package="LoggingTool" selector="default">default	^ Environment isNil		ifTrue: [ Environment := self new ]		ifFalse: [ Environment ].</body></methods><methods><class-id>Tools.LoggingTool class</class-id> <category>resources</category><body package="LoggingTool" selector="windowMenu">windowMenu	"MenuEditor new openOnClass: self andSelector: #windowMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_File #defaultString: '&amp;File' #catalogID: #menus) 				#nameKey: #file 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #SaveOutput #defaultString: 'Save Output...' #catalogID: #menus) 							#value: #saveOutput ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ClearLog #defaultString: 'Clear log' #catalogID: #menus) 							#value: #clear ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #E_xit #defaultString: 'E&amp;xit' #catalogID: #menus) 							#value: #closeRequest 							#shortcutKeyCharacter: $x ) ) #(2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Logging #defaultString: '&amp;Logging' #catalogID: #menus) 				#nameKey: #logging ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Utils #defaultString: '&amp;Utils' #catalogID: #menus) 				#nameKey: #utils 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #InspectDots #defaultString: 'Inspect...' #catalogID: #menus) 							#value: #inspect ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #BrowseDot #defaultString: 'Browse...' #catalogID: #menus) 							#value: #browse ) ) #(2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Trace #defaultString: '&amp;Trace' #catalogID: #menus) 				#nameKey: #trace ) ) #(4 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.LoggingTool class</class-id> <category>interface specs</category><body package="LoggingTool" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #LogWindow #defaultString: 'Log Window' #catalogID: #labels) 			#bounds: #(#{Graphics.Rectangle} 293 265 732 503 ) 			#flags: 4 			#menu: #windowMenu 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.00683371 0 0.0178571 0 0.995444 0 0.986607 ) 					#name: #collector 					#flags: 9 					#component: #collector ) ) ) )</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>TextCollector</name><environment>UI</environment><super>UI.ValueHolder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>entryStream characterLimit writeSequencer nextEntry autoFlush </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Support</category><attributes><package>Interface-Support</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class></st-source>