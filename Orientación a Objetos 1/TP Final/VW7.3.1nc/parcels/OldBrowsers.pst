<?xml version="1.0"?><st-source><!-- Name: OldBrowsersNotice: Copyright © 1999-2005 Cincom Systems, Inc.  All Rights Reserved.Comment: OldBrowsers contains the some of the VisualWorks 5i Browser framework.  That browser framework has been replaced by the Refactoring Browser, however some VisualWorks Tools (such as the Store Database browsers) still require these classes.  Not all of the classes (such as the original Debugger) that are part of the framework are in this parcel, some are still in the base image.  However at some point in the future, we will be removing all of the 5i Browser framework.DbIdentifier: bear73DbTrace: 52937PackageName: OldBrowsersParcel: #('OldBrowsers')ParcelName: OldBrowsersPrintStringCache: (7.3.1 - 1.0,bobw)Version: 7.3.1Date: 5:52:59 pm April 10, 2005 --><time-stamp>From VisualWorks®, 7.3.1 of April 10, 2005 on April 10, 2005 at 5:52:59 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>BlankUI</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blankList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>ParcelListBrowserHelper</name><environment>Tools</environment><super>Tools.BrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>OldBrowsers</package></attributes></class><class><name>MorphingBrowserModule</name><environment>Tools</environment><super>Tools.SimpleBrowserModule</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><comment><class-id>Tools.MorphingBrowserModule</class-id><body>This class refines its superclass to allow more than one BrowserHelper, with a very specific mechanism for choosing. If the primaryObject is a class, and the browser's "mode" for classes is either #instance or #class, then the module uses the BrowserHelper that is appropriate for looking at the class's methods (or those of its metaclass). But if the primaryObject is a NameSpace, or if it is a class but the browser's mode is #data, then the module's currentHelper is the BrowserHelper appropriate for showing static variables in a NameSpace. In this case, the BrowserHelper treats a Class as a NameSpace by showing the contents of its classPool.Instance Variables:specName	&lt;Symbol&gt;	class-side message selector that returns an encoded UISpec for the list view.</body></comment><class><name>TabbedDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>list disturbed subBuilder </inst-vars><class-inst-vars>developmentSpecList runtimeSpecList </class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>OldBrowsers</package></attributes></class><comment><class-id>UI.TabbedDialog</class-id><body>TabbedDialog is an abstract class that provides for tabbed selection and acceptance of user modifiable setting or property pages. Subclasses must implement the following messages:	class protocol:		constants			windowLabelInstance Variables:	disturbed	&lt;ValueModel on: Boolean&gt;	True on page entry change.	list	&lt;SelectionInList&gt;	Selection model.	subBuilder	&lt;UIBuilder&gt;	Page subcanvas builder.Class Instance Variables:	developmentSpecList	&lt;(OrderedCollection of: Association) | nil&gt;  Page label and its associated edit and help canvas specs for a development image.  	runtimeSpecList	&lt;(OrderedCollection of: Association) | nil&gt; Alternate page label and its associated edit and help canvas specs for a runtime image.  </body></comment><class><name>NameSpaceNavigator</name><environment>Tools</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>home list path action </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>PickASomethingDialog</name><environment>Tools</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>list </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>OldBrowsers</package></attributes></class><class><name>PackagePropertiesDialog</name><environment>UI</environment><super>UI.TabbedDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>package properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>OldBrowsers</package></attributes></class><comment><class-id>UI.PackagePropertiesDialog</class-id><body>A PackagePropertiesDialog provides an user-interface for editing a CodeComponents properties.  Typically, this will be a parcel, package or bundle.  These properties include the various action blocks (preload, postload, presave, etc), development and deployed prerequisites properties.  The receiver also provides the ability to add or remove arbitrary properties via a specialized inspector embedded  in the Other Properties tab.  All of the editing is buffered, i.e. a user will have to click on the accept button on each page to cause the desired property to be effected.Instance Variables:	package	&lt;Parcel | PackageModel | BundleModel&gt;  The component whose properties are being modified	properties	&lt;IdentityDictionary key: Symbol value: ValueHolder&gt;  The aspects for the components on each tab</body></comment><class><name>SelectorBrowserHelper</name><environment>Tools</environment><super>Tools.MethodsBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><comment><class-id>Tools.SelectorBrowserHelper</class-id><body>This class represents a list of all the message selectors that are in a particular protocol of a particular class or metaclass. It requires that its module's "primaryObject" be a Class or Metaclass, which is accessed via "self targetClass". The module's "secondaryObject" must be a Symbol, which names a particular protocol within the class, and is accessed via "self protocol".</body></comment><class><name>ParcelSelectorBrowserHelper</name><environment>Tools</environment><super>Tools.SelectorBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>OldBrowsers</package></attributes></class><class><name>MethodListBrowserHelper</name><environment>Tools</environment><super>Tools.MethodsBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label baseList initialSelection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><comment><class-id>Tools.MethodListBrowserHelper</class-id><body>This class represents a list of independent MethodDefinitions collected from some external source.Instance Variables:label	&lt;String&gt;	label for the windowbaseList	&lt;List&gt;		collection of MethodDefinitions to be displayed. This list may shrink over time as methods are found to no longer exist.initialSelection	&lt;String&gt;	When a method is selected, the string that should be high-lighted in the method's source code.</body></comment><class><name>BrowserTabApplication</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>components canvas browser blankCategoryCanvas indexOfCategoryCanvas icon categoryIcon emphasizer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>NamespaceTabApplication</name><environment>Tools</environment><super>Tools.BrowserTabApplication</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>ParcelTabApplication</name><environment>Tools</environment><super>Tools.BrowserTabApplication</super><private>false</private><indexed-type>none</indexed-type><inst-vars>manager parcelFilterOn unparceledFilterOn conflictsFilterOn savedParcels parcelDefType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>TabApplicationSystemBrowser</name><environment>Tools</environment><super>Tools.FullSystemBrowser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tabApplication </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>HierarchicalBrowserModule</name><environment>Tools</environment><super>Tools.SimpleBrowserModule</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>HierarchyBrowserHelper</name><environment>Tools</environment><super>Tools.BrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>NameSpaceHierarchyBrowserHelper</name><environment>Tools</environment><super>Tools.HierarchyBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>FullNotebookSystemBrowser</name><environment>Tools</environment><super>Tools.FullSystemBrowser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>majorTabs currentTabApplication labelApplicationDictionary tabApplications searchChildNamespaces </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>Emphasizer</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><comment><class-id>Tools.Emphasizer</class-id><body>An emphasizer provides the emphasis for items displayed the browser. Emphasis is based on a criteria (eg. parcel or package) queried from the browser, which allowsthe client to display emphasis without knowing the criteria upon which it's based.Subclasses should define:	#currentCriteria: aBrowser id: selectionId - answer the basis for emphaisand all the "private-staus" methods not provided by the superclass.#emphasisForAttribute: can be used to override the default highlighting.</body></comment><class><name>ParcelEmphasizer</name><environment>Tools</environment><super>Tools.Emphasizer</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>ClassesBrowserHelper</name><environment>Tools</environment><super>Tools.BrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lastSelection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><comment><class-id>Tools.ClassesBrowserHelper</class-id><body>This class represents a list of static variables--frequently classes.</body></comment><class><name>ClassHierarchyBrowserHelper</name><environment>Tools</environment><super>Tools.ClassesBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>baseClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><comment><class-id>Tools.ClassHierarchyBrowserHelper</class-id><body>This class represents a class hierarchy, including a class, all of its superclasses, and all of its subclasses. It requires that its module's "primaryObject" be a class, which it uses as the starting point for creating the class hierarchy. This primaryObject can be accessed via "self baseClass".</body></comment><class><name>NameSpaceCategoryBrowserHelper</name><environment>Tools</environment><super>Tools.ClassesBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><comment><class-id>Tools.NameSpaceCategoryBrowserHelper</class-id><body>This class represents a list of all the static variables that are in a particular category of a particular NameSpace. It requires that its module's "primaryObject" be a Class or NameSpace--if it is a Class, its class pool is treated as a NameSpace for purposes of browsing. This NameSpace can be accessed via "self environment". The module's "secondaryObject" must be a Symbol, which names a particular category within the NameSpace, and can be accessed via "self category".</body></comment><class><name>ParcelNameSpaceCategoryBrowserHelper</name><environment>Tools</environment><super>Tools.NameSpaceCategoryBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>OldBrowsers</package></attributes></class><class><name>ParcelNameSpaceGlobalCategoryBrowserHelper</name><environment>Tools</environment><super>Tools.ParcelNameSpaceCategoryBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>OldBrowsers</package></attributes></class><class><name>NameSpaceGlobalCategoryBrowserHelper</name><environment>Tools</environment><super>Tools.NameSpaceCategoryBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>NameSpaceOrganizerBrowserHelper</name><environment>Tools</environment><super>Tools.BrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>searchChildNamespaces </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><comment><class-id>Tools.NameSpaceOrganizerBrowserHelper</class-id><body>This class represents a list of all the categories that are in a particular NameSpace (or the classPool of a Class). It requires that its module's "primaryObject" be a Class or NameSpace, which is accessed via "self environment".</body></comment><class><name>ParcelNameSpaceOrganizerBrowserHelper</name><environment>Tools</environment><super>Tools.NameSpaceOrganizerBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><class><name>ProtocolBrowserHelper</name><environment>Tools</environment><super>Tools.BrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><comment><class-id>Tools.ProtocolBrowserHelper</class-id><body>This class represents a list of all the categories that are in a particular NameSpace (or the classPool of a Class). It requires that its module's "primaryObject" be a Class or Metaclass, which can be accessed via "self targetClass".Class Variables:LastProtocol	&lt;Symbol&gt;	The last protocol selected--used as a possible name when adding a new protocol.</body></comment><class><name>ParcelProtocolBrowserHelper</name><environment>Tools</environment><super>Tools.ProtocolBrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>OldBrowsers</package></attributes></class><shared-variable><name>LastProtocol</name><environment>Tools.ProtocolBrowserHelper</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>OldBrowsers</package></attributes></shared-variable><shared-variable><name>ApplicationTabs</name><environment>Tools.FullNotebookSystemBrowser</environment><private>false</private><constant>false</constant><category>Class Variables</category><attributes><package>OldBrowsers</package></attributes></shared-variable><methods><class-id>Tools.BlankUI</class-id> <category>responding</category><body package="OldBrowsers" selector="buildMenuBar:">buildMenuBar: menu	"here so we can respond but do nothing with any menu."</body><body package="OldBrowsers" selector="menuHeader">menuHeader^nil</body></methods><methods><class-id>Tools.BlankUI</class-id> <category>aspects</category><body package="OldBrowsers" selector="blankList">blankList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^blankList isNil		ifTrue:			[blankList := SelectionInList new]		ifFalse:			[blankList]</body><body package="OldBrowsers" selector="specName">specName	^self class preferredSpecName</body></methods><methods><class-id>Tools.BlankUI class</class-id> <category>interface specs</category><body package="OldBrowsers" selector="preferredSpecName">preferredSpecName	^#windowSpec</body></methods><methods><class-id>Tools.ParcelListBrowserHelper</class-id> <category>menus accessing</category><body package="OldBrowsers" selector="actionsForMultiSelect">actionsForMultiSelect	^#()</body><body package="OldBrowsers" selector="actionsForNoSelect">actionsForNoSelect	^#(selectHelp newParcel loadParcel filter updateBrowser find)</body><body package="OldBrowsers" selector="buildViewMenu:">buildViewMenu: aMenu	| menu |	menu := self class defTypeMenu.	menu menuItems do: 		[ :i | i indication: ( self browser parcelDefType value = i value ) ].	aMenu addPart: menu</body><body package="OldBrowsers" selector="doesNotUnderstand:">doesNotUnderstand: aMessage	| browser |	(self browser respondsTo: #currentTabApplication ) ifTrue:[ ^self browser perform: aMessage selector withArguments: aMessage arguments].	((browser := self browser) respondsTo: aMessage selector) ifFalse:		[^super doesNotUnderstand: aMessage].	^browser perform: aMessage selector withArguments: aMessage arguments</body><body package="OldBrowsers" selector="getListMenu:">getListMenu: forMenuBar	| menu browser filterSubMenu |	menu := super getListMenu: forMenuBar.	menu selectionMemory: nil.	browser := self browser.	filterSubMenu := (menu atNameKey: #filter) submenu.	(filterSubMenu atNameKey: #showOnlyParceled)		indication: browser isParcelFilterOn.	(filterSubMenu atNameKey: #showOnlyUnparceled)		indication: browser isUnparceledFilterOn.	(filterSubMenu atNameKey: #showMultiplyParceled)		indication: browser isConflictsFilterOn.	(menu atNameKey: #doUndo) enablementSelector: #canUndo.	^menu</body></methods><methods><class-id>Tools.ParcelListBrowserHelper</class-id> <category>accessing</category><body package="OldBrowsers" selector="windowLabel">windowLabel	^self currentParcel isNil		ifTrue: [#Parcel &lt;&lt; #labels &gt;&gt; 'Parcel']		ifFalse: [#x1sParcel &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; Parcel'			expandMacrosWith: self currentParcel name]</body></methods><methods><class-id>Tools.ParcelListBrowserHelper</class-id> <category>list accessing</category><body package="OldBrowsers" selector="selectionChanged">selectionChanged	self setSelection.	self browser updateButtonLabels.	self nextModule updateList</body><body package="OldBrowsers" selector="selectParcel:">selectParcel: aParcel	| newSelection |	(newSelection := aParcel) == nil		ifTrue: [ module deselect ].	self module selection: newSelection</body><body package="OldBrowsers" selector="textForItem:">textForItem:  aParcel	^aParcel listEntry asText</body><body package="OldBrowsers" selector="updateListFull">updateListFull	"Must cleanse all parcels to make sure they're current."	|pList|	self manager parcels do: [ :aParcel | aParcel cleanse ].	pList := SortedCollection withAll: self manager parcels sortBlock: [:p1 :p2 | p1 name &lt; p2 name].	module setNewList: pList asList. 		"parcelNameList"</body></methods><methods><class-id>Tools.ParcelListBrowserHelper</class-id> <category>actions</category><body package="OldBrowsers" selector="addChangeSet">addChangeSet	self changeRequest ifFalse: [^self].	self browser saveParcelsForUndo.	self selectedParcel addChangeSet: ChangeSet current.	self browser updateLists</body><body package="OldBrowsers" selector="addToChanges">addToChanges	"Add the Parcel's contents to the current ChangeSet."	self selectedParcel cleanse.	ChangeSet current addChangeSet: self currentParcel</body><body package="OldBrowsers" selector="browseChangedMethods">browseChangedMethods	"Browse all methods that have changed in the currently selected parcel.	 Changed is defined as not having the same source file as the Parcel."	| extensions fileIndex sfm |	((self selectedParcel propertyAt: #hideSource) notNil	and: [self selectedParcel propertyAt: #hideSource]) ifTrue: [^Dialog warn: (#ParcelSourceHidden &lt;&lt; #dialogs &gt;&gt; 'Parcel source is hidden.  Cannot determine changed methods')].	extensions := SortedCollection new.	fileIndex := self selectedParcel propertyAt: #sourceIndex.	sfm := SourceFileManager default.	self currentParcel methodsDo:		[:cm| | def |		(fileIndex ~= (sfm fileIndexFor: cm sourcePointer)		and: [(def := cm definition) ~~ nil]) ifTrue:			[extensions add: def]].	self methodCollector		openListBrowserOn: extensions		label: ((#ChangedMethodsIn1s &lt;&lt; #dialogs &gt;&gt; 'Changed methods in &lt;1s&gt;')			expandMacrosWith: self selectedParcel name)		initialSelection: nil</body><body package="OldBrowsers" selector="browseClassExports">browseClassExports	"Browse references in the system to classes or names of classes	 exported from this Parcel.  Open a list browser on references from	 methods and a category browser for references from subclasses"	Cursor execute showWhile:		[| names references subclassExports org |		names := self selectedParcel definedClasses collect: [:ea| ea name].		references := Set new.		SystemUtils allBehaviorsDo: [:class| | extends |			extends := self selectedParcel definesOrExtendsBehavior: class.			class selectorsAndMethodsDo: [:sel :meth|				(extends				and: [self currentParcel definesSelector: sel forClass: class]) ifFalse:					[meth allLiteralsDo: [:lit| | litVal |						"If the method refers to more than one class then the set will						 eliminate multiple entries for this method."						((lit isSymbol						and: [names includes: lit])						or: [lit isVariableBinding							and: [(litVal := lit value) isBehavior							and: [self selectedParcel definesClass: litVal]]]) ifTrue:							[references add: ((MethodDefinition class: class selector: sel) extraText: ((#Exports1p &lt;&lt; #dialogs &gt;&gt; ' exports: &lt;1p&gt;') expandMacrosWith: litVal))]]]]].		subclassExports := IdentitySet new.		self selectedParcel definedClasses do: [:class|			subclassExports addAll: (class subclasses select: [:subclass|				| pcls |				(pcls := self manager parcelsForClassOrNameSpace: subclass) size = 0				or: [pcls contains: [:p| p ~= self selectedParcel and: [p definesClass: subclass]]]])].		(references isEmpty		and: [subclassExports isEmpty]) ifTrue:			[^Dialog warn: (#NoExports &lt;&lt; #dialogs &gt;&gt; 'No exports')].		references isEmpty ifFalse:			[self methodCollector				openListBrowserOn: references asSortedCollection 				label: ((#ReferencesToClassesExportedFrom1sParcel &lt;&lt; #dialogs &gt;&gt; 'References to Classes Exported from &lt;1s&gt; Parcel') expandMacrosWith: self currentParcel name)				initialSelection: nil].		subclassExports isEmpty ifFalse:			[self notYetImplemented.			"org := SystemOrganizer new.			subclassExports do:				[:class|				org classify: class fullName					under: 'Inherited Class Exports From ', self currentParcel name, ' Parcel'].			self class openOn: (ParcelBrowser new on: org)"]]</body><body package="OldBrowsers" selector="browseClassImports">browseClassImports	"Browse references to classes defined by the rest of the system from within this Parcel."	Cursor execute showWhile:		[| references superclassImports extendedImports |		references := Set new.		superclassImports := IdentitySet new.		extendedImports := IdentitySet new.		SystemUtils allBehaviorsDo: [:class| | defines extends |			((defines := self selectedParcel definesClass: class)			and: [class superclass notNil			and: [(self selectedParcel definesClass: class superclass) not]]) ifTrue:				[superclassImports add: class instanceBehavior superclass].			(extends := self selectedParcel extendsBehavior: class) ifTrue:				[extendedImports add: class instanceBehavior].			class selectorsAndMethodsDo: [:sel :meth|				(defines				or: [extends					and: [self selectedParcel definesSelector: sel forClass: class]]) ifTrue:					[meth allLiteralsDo: [:lit| | litVal |						"If the method refers to more than one class then the set will						 eliminate multiple entries for this method."						(lit isVariableBinding						and: [(litVal := lit value) isBehavior						and: [(self selectedParcel definesClass: litVal) not]]) ifTrue:							[references add: ((MethodDefinition class: class selector: sel) extraText: ((#ImportsColon1p &lt;&lt; #dialogs &gt;&gt; ' imports: &lt;1p&gt;') expandMacrosWith: litVal))]]]]].		(references isEmpty		and: [superclassImports isEmpty		and: [extendedImports isEmpty]]) ifTrue:			[^Dialog warn: (#NoImports &lt;&lt; #dialogs &gt;&gt; 'No imports')].		references isEmpty ifFalse:			[self methodCollector				openListBrowserOn: references asSortedCollection				label: ((#ReferencesToClassesImportedBy1sParcel &lt;&lt; #dialogs &gt;&gt; 'References to Classes Imported by &lt;1s&gt; Parcel') expandMacrosWith: self currentParcel name)				initialSelection: nil].		superclassImports isEmpty ifFalse:			[self notYetImplemented.			"org := SystemOrganizer new.			superclassImports do:				[:class|				org classify: class fullName					under: 'Class Imports into ', self currentParcel name, ' Parcel'].			self class openOn: (ParcelBrowser new on: org)"].		extendedImports isEmpty ifFalse:			[self notYetImplemented.			"org := SystemOrganizer new.			extendedImports do:				[:class|				org classify: class fullName					under: 'Classes Extended by ', currentParcel name, ' Parcel'].			self class openOn: (ParcelBrowser new on: org)"]]</body><body package="OldBrowsers" selector="browseDanglingReferences">browseDanglingReferences	"Browse references in the system to classes or names of classes 	exported from this Parcel. Open a list browser on references from 	methods and a category browser for references from subclasses"	Cursor execute showWhile: 		[| references subclassExports |		references := Set new.		subclassExports := IdentitySet new.		self selectedParcel danglingReferencesIfUnloadedDo:			[:referer :referent|				referer isBehavior ifTrue:					[subclassExports add: referer] ifFalse:					[referer isSymbol ifTrue:					[references add: (MethodDefinition class: referent selector: referer)] ifFalse:					[references add: (referer definition										extraText: ' -&gt; ', referent fullName;										yourself)]]].		(references isEmpty		and: [subclassExports isEmpty]) ifTrue:			[^Dialog warn: (#NoDanglingReferences &lt;&lt; #dialogs &gt;&gt; 'No dangling references')].		references isEmpty ifFalse:			[self methodCollector				openListBrowserOn: references asSortedCollection				label: ((#ClassRefsInParcel &lt;&lt; #dialogs &gt;&gt; 'References to Classes in &lt;1s&gt; Parcel')					expandMacrosWith: self currentParcel name)				initialSelection: nil].		subclassExports isEmpty ifFalse:			[| namespace |			namespace := NameSpace new name: ((#InheritedClassRefs &lt;&lt; #dialogs &gt;&gt; 'Inheriting Class References From &lt;1s&gt;') asString					expandMacrosWith: self currentParcel name).			subclassExports do: [:class | namespace addBinding: (class environment bindingFor: class name)].			self browser spawnOnNameSpace: namespace]]</body><body package="OldBrowsers" selector="browseExclusiveMethodImports">browseExclusiveMethodImports	"Browse methods imported by this Parcel and unused elsewhere."	| danglingMethods |	Cursor execute showWhile:		[danglingMethods := self computeExclusiveMethodImports].	self methodCollector		openListBrowserOn: danglingMethods asSortedCollection		label: ((#PossibleDanglingMethods &lt;&lt; #dialogs &gt;&gt; 'Methods Used Only by &lt;1s&gt; but not in &lt;2s&gt;')			expandMacrosWith: self selectedParcel name			with: self currentParcel name)		initialSelection: nil</body><body package="OldBrowsers" selector="browseExtensionMethods">browseExtensionMethods	"Browse all extension methods in the currently selected parcel."	| extensions |	extensions := SortedCollection new.	self currentParcel extensionsDo:		[:aClass :aSelector|		extensions add: (MethodDefinition class: aClass selector: aSelector)].	self methodCollector		openListBrowserOn: extensions		label: ((#ExtensionMethodsIn1s &lt;&lt; #dialogs &gt;&gt; 'Extension methods in &lt;1s&gt;')			expandMacrosWith: self currentParcel name)		initialSelection: nil</body><body package="OldBrowsers" selector="browseImplementorsOf">browseImplementorsOf	"Prompt the user for a selector or selector pattern.  If only one existing	message selector matches that selector (case insensitive) or pattern,	then browse all implementors of that selector.  If more than one match, 	then present a menu of the matching selectors and browse all implementors	of the selected one."	| trial coll selector mc |	"Two things; a) this should open a Parcel Method List Browser, b) the prompting for selectors should be in some central place"	trial := Dialog request: (#BrowseImplementorsOfWhatQ &lt;&lt; #dialogs &gt;&gt; 'Browse implementors of what?').	trial isEmpty ifTrue: [^self].	coll := OrderedCollection new.	Cursor wait showWhile:		[Symbol allSubInstancesDo:			[:sym | (trial match: sym) ifTrue: [coll add: sym]]].	coll isEmpty ifTrue:		[^Dialog warn: (#NoMatchingMessages &lt;&lt; #dialogs &gt;&gt; 'No matching messages')].	selector := coll size = 1				ifTrue: [coll first]				ifFalse:					[Dialog						choose: (#FindAllImplementorsOfDot &lt;&lt; #dialogs &gt;&gt; 'Find all implementors of...')						fromList: (coll collect: [:sel | sel asString])						values: coll						lines: 20						cancel: [^self]].	mc := self methodCollector.	mc browseSelect: (mc parcel: self currentParcel) &amp; (mc implementorsOf: selector)</body><body package="OldBrowsers" selector="browseOverriddenByOthers">browseOverriddenByOthers	"Browse all methods in the currently selected parcel that are overridden	 by other parcels.  These methods prevent a parcel from being saved."	| overrides current currentParcel |	currentParcel := self currentParcel.	( overrides := currentParcel overrides ) isEmpty 		ifTrue: [ ^Dialog warn: (#NothingOverriddenByOthers &lt;&lt; #dialogs &gt;&gt; 'Nothing overridden by others') ].	current := OrderedCollection new.	overrides do:		[ :over |		over isForMethod			ifTrue: [ 	current add: ( MethodDefinition class: over owner selector: over selector) ]		].	OverrideList new 		listName: ((#OverriddenDefsInParcel &lt;&lt; #dialogs &gt;&gt; 'Definitions in &lt;1s&gt; overridden by others')			expandMacrosWith: currentParcel name);		checkSystem: #code;		showConflicts: true;		openOn: overrides.	current isEmpty		ifFalse: 			[ self methodCollector				openListBrowserOn: current asSortedCollection				label: ((#CurrentMethodOverridden &lt;&lt; #dialogs &gt;&gt; 'Current method overridden in &lt;1s&gt;')					expandMacrosWith: self currentParcel name)				initialSelection: nil			].</body><body package="OldBrowsers" selector="browseOverriddenExtensions">browseOverriddenExtensions	"Browse all methods in the currently selected parcel that are overrides of previous versions. 	 To allow comparison of the old and the new open up a ChangeList switched to conflicts	 containing the original versions.  To allow parcelling, open up a MethodListParcelBrowser."	| overrides current currentParcel |	currentParcel := self currentParcel.	( overrides := Override overriddenByComponent: currentParcel ) isEmpty 		ifTrue: [ ^Dialog warn: (#NoOverriddenExtensions &lt;&lt; #dialogs &gt;&gt; 'No overridden extensions') ].	current := OrderedCollection new.	overrides do:		[ :over |		over isForMethod			ifTrue: [ 	current add: ( MethodDefinition class: over owner selector: over selector) ]		].	OverrideList new 		listName: ((#DefinitionsOverriddenByParcel &lt;&lt; #dialogs &gt;&gt; 'Definitions overridden by &lt;1s&gt; parcel')			expandMacrosWith: self currentParcel name);		checkSystem: #code;		showConflicts: true;		openOn: overrides.	current isEmpty		ifFalse: 			[ self methodCollector				openListBrowserOn: current asSortedCollection				label: ((#CurrentMethodOverrides &lt;&lt; #dialogs &gt;&gt; 'Current method overrides defined in &lt;1s&gt;')					expandMacrosWith: self currentParcel name)				initialSelection: nil			].</body><body package="OldBrowsers" selector="browseSendersOf">browseSendersOf	"Prompt the user for a selector or selector pattern.  If only one existing	message selector matches that selector (case insensitive) or pattern,	then browse all senders of that selector.  If more than one match, 	then present a menu of the matching selectors and browse all senders	of the selected one."	| trial coll selector mc |	"Two things; a) this should open a Parcel Method List Browser, b) the prompting for selectors should be in some central place"	trial := Dialog request: (#BrowseSendersOfWhatQ &lt;&lt; #dialogs &gt;&gt; 'Browse senders of what?').	trial isEmpty ifTrue: [^self].	coll := OrderedCollection new.	Cursor wait showWhile:		[Symbol allSubInstancesDo:			[:sym | (trial match: sym) ifTrue: [coll add: sym]]].	coll isEmpty ifTrue:		[^Dialog warn: (#NoMatchingMessages &lt;&lt; #dialogs &gt;&gt; 'No matching messages')].	selector := coll size = 1				ifTrue: [coll first]				ifFalse:					[Dialog						choose: (#FindAllSendersOfDot &lt;&lt; #dialogs &gt;&gt; 'Find all senders of...')						fromList: (coll collect: [:sel | sel asString])						values: coll						lines: 20						cancel: [^self]].	mc := self methodCollector.	mc browseSelect: (mc parcel: self currentParcel) &amp; (mc referencesTo: selector)</body><body package="OldBrowsers" selector="browseUnparceledMethodsOnDefinedClasses">browseUnparceledMethodsOnDefinedClasses	"Browse methods on classes defined by this Parcel that are not in the Parcel."	^self methodCollector		openListBrowserOn: self computeUnparceledMethodsOnDefinedClasses asSortedCollection		label: ((#UnparcelledMethods &lt;&lt; #dialogs &gt;&gt; 'Unparcelled methods in classes defined in &lt;1s&gt;')			expandMacrosWith: self currentParcel name)		initialSelection: nil</body><body package="OldBrowsers" selector="discardParcel">discardParcel	"Discard the selected parcel.  This discards the Parcel but does not remove its code."	self changeRequest ifFalse: [^self].	(Dialog confirm: (#DiscardBbutNotUnloadParcelQ &lt;&lt; #dialogs &gt;&gt; 'Really discard (but not unload) the parcel?')) ifTrue:		[ self manager destroyParcelNamed: self currentParcel name.		self updateListFull.		self selectParcel: nil		]</body><body package="OldBrowsers" selector="emptyParcel">emptyParcel	"Empty the current parcel, but do not remove the code it defined from the system."	self changeRequest ifFalse: [^self].	self currentParcel uiForEmpty 		ifTrue:	[self browser updateLists]</body><body package="OldBrowsers" selector="fileIntoParcel">fileIntoParcel	| fileName |	self changeRequest ifFalse: [^self].	fileName := Dialog		requestFileName: (#FileInFromFileNamed &lt;&lt; #dialogs &gt;&gt; 'File in from file named')		default: '*.st'		version: #mustBeOld		ifFail: [nil]		for: self browser builder window.	fileName size = 0 ifTrue: [^self].	self currentParcel fileIntoFrom: fileName.	self browser updateLists</body><body package="OldBrowsers" selector="fileOutParcel">fileOutParcel	self changeRequest ifFalse: [^self].	self currentParcel fileOutAsFor: nil.			"builder window"</body><body package="OldBrowsers" selector="find">find	"Prompt for a name and position myself there."	| obj parcelSet found |	self changeRequest ifFalse: [^self].	obj := self findASomething: (#FindColon &lt;&lt; #labels &gt;&gt; 'Find:').	obj == nil ifTrue: [^self]."if we can't see it, we can't select it....."	obj isBindingReference		ifTrue:			[self browser batchUpdates:				[self browser metaShowData.				self browser setAndUpdateEnvironment: obj environment environment.				self browser selectCategory: obj environment category.				self browser selectBehavior: obj environment.				self browser selectProtocol: (obj environment asNameSpace categoryFor: obj name).				self browser selectMethod: obj name]]		ifFalse: 			[self environment == nil &amp; (self category == nil)				ifFalse: 					[self browser setAndUpdateEnvironment: obj environment.					self category == obj category ifFalse:						[module nextModule							select: obj category							whenFinished: ["module nextModule updateList"]]].			found := self browser manager parcelsForClassOrNameSpace: obj.			found isNil ifFalse:				[|foundCollection|				foundCollection := found asOrderedCollection.				parcelSet := foundCollection select: [:each | (each definesClass: obj) or: [each definesObject: obj]].				parcelSet isEmpty ifTrue: [parcelSet := foundCollection]].			found notNil ifTrue:				[self module					select: parcelSet first					whenFinished: [module updateList]].			module nextModule nextModule				select: obj				whenFinished: [self browser updateBrowser]]</body><body package="OldBrowsers" selector="inspectParcel">inspectParcel	self selectedParcel inspect</body><body package="OldBrowsers" selector="loadParcel">loadParcel	self changeRequest ifFalse: [ ^self ].	self manager loadParcelFor:  nil.			"builder window."	self browser updateParcelLists.	self browser updateNamespaceListFull.</body><body package="OldBrowsers" selector="newParcel">newParcel	"Pop dialog to prompt user for new name. Tell def mgr to make it"	| newName currentParcel |	self changeRequest ifFalse: [^self].	newName := Dialog						request: (#EnterNameForNewParcel &lt;&lt; #dialogs &gt;&gt; 'Enter name for the new parcel')						initialAnswer: ''						onCancel: [nil].	newName := self manager normalizedNameFor: newName.	(newName isNil or: [newName isEmpty]) ifTrue: [^self].	(self manager parcelNamed: newName) notNil ifTrue:		[Dialog warn: (#parcelExists &lt;&lt; #dialogs &gt;&gt; 'A parcel with this name already exists').		^self].	currentParcel := self manager createParcelNamed: newName.	currentParcel == nil 		ifFalse: 			[ self browser updateLists.			self module selection: currentParcel			]</body><body package="OldBrowsers" selector="openParcelProperties">openParcelProperties	PackagePropertiesDialog on: self currentParcel</body><body package="OldBrowsers" selector="removeChangeSet">removeChangeSet	self changeRequest ifFalse: [^self].	self browser saveParcelsForUndo.	self currentParcel removeChangeSet: ChangeSet current.	self browser updateLists</body><body package="OldBrowsers" selector="removeFromChanges">removeFromChanges	"Remove the Parcel's contents from the current ChangeSet."	self currentParcel cleanse.	ChangeSet current removeChangeSet: self currentParcel</body><body package="OldBrowsers" selector="removeParcel">removeParcel	"Remove the currently selected parcel.  This unloads the Parcel's code	 and updates the current change set with the removals."	self changeRequest ifFalse: [^self].	(Dialog confirm: (#UnloadAndRemoveParcelCodeQ &lt;&lt; #dialogs &gt;&gt; 'Really unload (and remove) the parcel''s code?')) ifTrue:		[Cursor wait showWhile:			[self currentParcel hasDanglingReferencesIfUnloaded ifTrue:				[(Dialog confirm: ((#HasDanglingReferencesRemoveParcelQ &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; has dangling references.&lt;n&gt;Do you really want to remove the parcel''s code?') expandMacrosWith: self currentParcel name)) ifFalse: [^self]].			(self manager removeParcelNamed: self currentParcel name) ifTrue:				[self postUnloadParcel]]].	self browser updateParcelLists</body><body package="OldBrowsers" selector="removeScript">removeScript	| fileName  stream |	fileName := self currentParcel name asString, '.rm'.	fileName := self buildPlatformFilename: fileName.	fileName := Dialog					requestNewFileName: (#SaveRemoveScriptToFileNamed &lt;&lt; #dialogs &gt;&gt; 'Save remove script to file named?')					default: fileName.	fileName isEmpty ifTrue: [^self].	stream := fileName asFilename writeStream.	[self currentParcel writeRemovalScriptOn: stream]		ensure: [stream close]</body><body package="OldBrowsers" selector="renameParcel">renameParcel	self changeRequest ifFalse: [^self].	"Remember currentParcel because rename sets currentParcel to nil"	self currentParcel uiForRename 		ifTrue:	[ self updateLists ]</body><body package="OldBrowsers" selector="saveParcelDialog">saveParcelDialog	"Put up a Dialog that allows the user to save the Parcel in various forms."	self changeRequest ifFalse: [^self].	self currentParcel saveParcelDialogFor: nil	.		"builder window."	self browser updateLists</body><body package="OldBrowsers" selector="showComputedPrerequisites">showComputedPrerequisites	| prerequisites |	self changeRequest ifFalse: [^self].	prerequisites := self computePrerequisites.	self parcelTextMode: #parcelPrerequisites		value: ((#EditAndAcceptPrereqs &lt;&lt; #dialogs &gt;&gt; '"Edit as required and then choose accept to set the parcel''s prerequisites."&lt;nn&gt;&lt;1s&gt;')			expandMacrosWith: ((prerequisites asSortedCollection: [:p1 :p2 | p1 name &lt;= p2 name]) asArray collect: [:p | Array with: p name with: (p propertyStringAt: #version)]) storeString asText)</body><body package="OldBrowsers" selector="showSummary">showSummary	self browser parcelTextMode: #parcelSummary</body><body package="OldBrowsers" selector="spawn">spawn	"Not supported."	Dialog warn: (#NotImplemented &lt;&lt; #dialogs &gt;&gt; 'Not implemented.')</body><body package="OldBrowsers" selector="unloadParcel">unloadParcel	self changeRequest ifFalse: [^self].	self currentParcel isNil		ifTrue:			[| parcels unloaded |			parcels := self manager parcels select: [:ea| ea isLoaded].			parcels := SimpleDialog new						chooseMultiple: (#SelectParcelsToUnload &lt;&lt; #dialogs &gt;&gt; 'Select parcels to unload.')						fromList: (parcels collect: [:p| p listEntry])						values: parcels						buttons: #() values: #()						lines: 8						cancel: []						for: Dialog defaultParentWindow.			parcels notNil ifTrue:				[unloaded := false.				Cursor wait showWhile:					[(SystemUtils sortForLoading: parcels) reverseDo:						[:p|						p hasDanglingReferencesIfUnloaded ifTrue:							[(Dialog confirm: ((#ParcelHasDanglingRefs &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; has dangling references.&lt;n&gt;Do you really want to unload the parcel''s code?') expandMacrosWith: p name)) ifFalse: [^self]].						(self manager unloadParcelNamed: p name) ifTrue:							[unloaded := true]].				unloaded ifTrue: [self postUnloadParcel]]]]		ifFalse:			[(Dialog confirm: (#UnloadAndDiscardParcelCodeQ &lt;&lt; #dialogs &gt;&gt; 'Really unload (and discard) the parcel''s code?')) ifTrue:				[Cursor wait showWhile:					[self currentParcel hasDanglingReferencesIfUnloaded ifTrue:						[(Dialog confirm: ((#ParcelHasDanglingRefs &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; has dangling references.&lt;n&gt;Do you really want to unload the parcel''s code?') expandMacrosWith: self currentParcel name)) ifFalse: [^self]].					(self manager unloadParcelNamed: self currentParcel name) ifTrue:						[self postUnloadParcel]]]].	self browser updateParcelLists</body><body package="OldBrowsers" selector="updateBrowser">updateBrowser	self browser updateBrowser</body></methods><methods><class-id>Tools.ParcelListBrowserHelper</class-id> <category>text processing</category><body package="OldBrowsers" selector="acceptText:from:">acceptText: aText from: textController	| currentParcel textMode |	(currentParcel := self currentParcel) isNil ifTrue: [^nil].	textMode := self browser parcelDefType value.	textMode == #parcelComment ifTrue:		[currentParcel comment: aText string.		self updateListFull.		^true].	textMode == #parcelVersion ifTrue:		[currentParcel version: aText string.		self updateListFull.		^true].	textMode == #parcelNotice ifTrue:		[currentParcel propertyAt: #notice put: aText string.		self updateListFull.		^true].	textMode == #parcelPrerequisites ifTrue:		[currentParcel prerequisiteParcels: (Compiler new								evaluate: aText string								in: nil								allowReceiver: true								receiver: currentParcel								environment: nil								notifying: textController								ifFail: [^false]).		self updateListFull.		^true].	textMode == #parcelDefintion		ifTrue: [ ^self acceptDefinition: aText from: textController ].	^nil</body><body package="OldBrowsers" selector="text">text	| currentParcel textMode |	(currentParcel := self currentParcel) isNil ifTrue: [^'' asText].	textMode := self browser parcelDefType value.	textMode = #parcelDefintion		ifTrue: [ textMode := #parcelComment ].		"Should be something"	textMode == #parcelSummary ifTrue:		[^('Parcel ', (currentParcel listEntry), '\\' withCRs) asText, currentParcel summary asText].	textMode == #parcelComment ifTrue: [^currentParcel comment asText].	textMode == #parcelVersion ifTrue: [^currentParcel version asText].	textMode == #parcelNotice ifTrue:		[^(currentParcel			propertyAt: #notice			ifAbsent: ['Copyright © &lt;1p&gt; ????. All Rights Reserved.' expandMacrosWith: Date today year]) asText].	textMode == #parcelPrerequisites ifTrue:		[^('"Supply Parcel prerequisites as Parcel name, Version string pairs.  E.g.\	#(#(''Foo'' ''0.1'')\	  #(''Bar'' ''0.2''))"\\' withCRs asText emphasizeAllWith: #italic), currentParcel prerequisiteParcels storeString asText].	textMode == #parcelProperties ifTrue:		[ | properties s |		properties := currentParcel properties.		s := (String new: 64) writeStream.		(properties keys asSortedCollection asOrderedCollection			remove: #name;			addFirst: #name;			yourself) do:				[:key| | value source |				value := properties at: key.				value isString ifFalse: [value := value printString].				s	cr;					nextPut: key first asUppercase;					nextPutAll: (key copyFrom: 2 to: key size);					nextPut: $:;					space;					nextPutAll: value.				key == #sourceIndex ifTrue:					[source := SourceFileManager default nameStringAt: (properties at: key).					source := source isNil ifTrue: [source printString] ifFalse: [source].					s space; nextPut: $(; nextPutAll: source; nextPut: $)]].		^s contents asText].	textMode == #parcelDanglingReferences ifTrue:		[| s |		s := (String new: 64) writeStream.		Cursor wait showWhile:			[currentParcel danglingReferencesIfUnloadedDo: [:referer :referent|				referer isBehavior ifTrue:					[s nextPutAll: referer printString; nextPutAll: ' subclasses '; nextPutAll: referent printString] ifFalse:					[referer isSymbol ifTrue:					[s nextPutAll: referer; nextPutAll: ' extends '; nextPutAll: referent printString] ifFalse:					[referer printNameOn: s inClass: referer mclass.					s nextPutAll: ' refers to '; nextPutAll: referent printString]].				s cr]].		s isEmpty ifTrue: [s nextPutAll: 'none'].		^s contents asText].	^nil</body></methods><methods><class-id>Tools.ParcelListBrowserHelper</class-id> <category>private</category><body package="OldBrowsers" selector="buildPlatformFilename:">buildPlatformFilename: aString	| oldSeparator |	oldSeparator := (aString includes: UnixFilename separator)		ifTrue:	[ UnixFilename separator ]		ifFalse:	[ (aString includes: PCFilename separator)					ifTrue:	[ PCFilename separator ]					ifFalse:	[ (aString includes: MacFilename separator)								ifTrue:	[ MacFilename separator ]								ifFalse:	[ nil ] ] ].	aString replaceAll: oldSeparator with: Filename separator.	^aString copyWithout: Character space.</body><body package="OldBrowsers" selector="computeExclusiveMethodImports">computeExclusiveMethodImports	"The algorithm computes a fixed point of the methods used	  by the parcel which are unused outside it.  The algorithm is			compute messages sent within parcel			repeat until at a fixed point:				compute intersection of this with methods implemented outside parcel				compute messages sent outside parcel not within the intersection				remove these from intersection"	| parcelMessages "&lt;IdentitySet of: Symbol&gt;							messages sent within this parcel"	  externalMethods "&lt;Set of: MethodDescription&gt;							methods implemented outside this parcel"	  danglingMethods "&lt;Set of: MethodDescription&gt;							methods importeded only by this parcel"	  previousDangling "&lt;Set of: MethodDescription&gt;							intermediate value of danglingMethods (for determining if fixed point is reached)"	  danglingMessages "&lt;Set of: Symbol&gt; selectors of methods in danglingMethods"	  noLongerDangling "&lt;Set of: Symbol&gt; selectors to be moved from dangling" |	parcelMessages := IdentitySet new.	self currentParcel methodsDo:		[:meth| parcelMessages addAll: meth allSymbolLiterals].	"compute starting points for danglingMethods and externalMethods"	danglingMethods := Set new: 50.	externalMethods := Set new: 20000.	SystemUtils allBehaviorsDo:		[:aBehavior| | extends |		(self currentParcel definesClass: aBehavior) ifFalse:			[extends := self currentParcel extendsBehavior: aBehavior.			aBehavior selectorsAndMethodsDo:				[:sel :meth|				(extends				and: [self currentParcel definesSelector: sel forClass: aBehavior]) ifFalse:					[((parcelMessages includes: sel)						ifTrue: [danglingMethods]						ifFalse: [externalMethods])							add: (MethodDefinition class: aBehavior selector: sel)]]]].	["Now iterate to the fixed-point.  Any method in dangling with a selector sent	  in external must be moved into external until dangling reaches its fixed point."	previousDangling := danglingMethods copy.	danglingMessages := danglingMethods collect: [:md| md selector].	noLongerDangling := Set new: danglingMethods size.	externalMethods do:		[:md|		md method allSymbolLiteralsDo:			[:l|			(danglingMessages includes: l) ifTrue:				[noLongerDangling add: l]]].	externalMethods := danglingMethods select: [:md| noLongerDangling includes: md selector].	danglingMethods removeAll: externalMethods.	danglingMethods size ~= previousDangling size] whileTrue.	^danglingMethods</body><body package="OldBrowsers" selector="computePrerequisites">computePrerequisites	"Compute the Parcel's prerequisites and display them in the text pane;	 The programmer can then edit and accept."	| importedClasses prerequisites |	importedClasses := IdentitySet new.	"Collect imported classes.  These are the superclasses of	 classes in the parcel, the classes extended by the parcel,	 and any classes referred to by methods in the parcel."	self currentParcel definedClasses do:		[:class| | superclass |		((superclass := class superclass) notNil		and: [(self currentParcel definesClass: superclass) not]) ifTrue:			[importedClasses add: superclass]].	importedClasses addAll: self currentParcel extendedClasses.	self currentParcel methodsDo:		[:meth|		meth allLiteralsDo:			[:lit| | thing |			(lit isSymbol and: [lit size &gt; 0])				ifTrue:					[((thing := Smalltalk at: lit ifAbsent: []) isBehavior					and: [(self currentParcel definesClass: thing) not]) ifTrue:						[importedClasses add: thing]]				ifFalse:					[(lit isVariableBinding					and: [(thing := lit value) isBehavior					and: [(self currentParcel definesClass: thing) not]]) ifTrue:						[importedClasses add: thing]]]].	prerequisites := Set new.	importedClasses do:		[:class| | parcels |		parcels := self manager parcelsForClassOrNameSpace: class.		parcels notNil ifTrue: [prerequisites addAll: (parcels select: [:p| p definesClass: class])]].	prerequisites remove: self currentParcel ifAbsent: nil.	^prerequisites</body><body package="OldBrowsers" selector="computeUnparceledMethodsOnDefinedClasses">computeUnparceledMethodsOnDefinedClasses	"Answer a Set of methods on classes defined by this Parcel that are not in the Parcel."	| references |	references := Set new.	SystemUtils allBehaviorsDo: [:class|		(self currentParcel definesClass: class) ifTrue:			[class selectorsAndMethodsDo: [:sel :meth|				(self currentParcel definesSelector: sel forClass: class) ifFalse:					[references add: (MethodDefinition class: class selector: sel)]]]].	^references</body><body package="OldBrowsers" selector="postUnloadParcel">postUnloadParcel	"Clean-up after unloading a Parcel."	self component1 updateListFull.	self component2 updateListFull.	self browser updateLists.	(Dialog confirm: (#removeCatagoriesAndPurge &lt;&lt; #dialogs &gt;&gt; 'Remove empty categories and purge Undeclared?')) ifTrue:		[ Cursor execute showWhile:			[ Root allNameSpaces do: [ :ns | ns organization removeEmptyCategories ].			ClassOrganizer allInstancesDo: [ :clo| clo removeEmptyCategories ].			Undeclared purgeUnusedBindings ]		]</body></methods><methods><class-id>Tools.ParcelListBrowserHelper</class-id> <category>selections</category><body package="OldBrowsers" selector="defaultAttribute">defaultAttribute	"Answer the default attribute that this helper is responsible for selecting."	^#parcel</body></methods><methods><class-id>Tools.ParcelListBrowserHelper</class-id> <category>drag and drop</category><body package="OldBrowsers" selector="canAcceptDropFrom:">canAcceptDropFrom: aDC 	"respond to objects that can be added to a Parcel"	^aDC key == self classOrNamespaceKey or: [  aDC key == self selectorOrStaticKey]</body></methods><methods><class-id>Tools.ParcelListBrowserHelper class</class-id> <category>menus accessing</category><body package="OldBrowsers" selector="menuHeader">menuHeader	^(#Par_cel &lt;&lt; #menus &gt;&gt; 'Par&amp;cel') asString</body></methods><methods><class-id>Tools.MorphingBrowserModule</class-id> <category>accessing</category><body package="OldBrowsers" selector="currentHelper">currentHelper	| primary |	primary := helpers first selected: #environment.	primary == nil		ifTrue: [ ^helpers first ].	^( primary isBehavior and: [ browser isData not ] )		ifTrue: [ helpers first ]		ifFalse: [ helpers at: 2 ]</body><body package="OldBrowsers" selector="meta">meta	^self browser meta</body></methods><methods><class-id>Tools.MorphingBrowserModule class</class-id> <category>interface specs</category><body package="OldBrowsers" selector="preferredSpec">preferredSpec	^self listSpecProtocols</body><body package="OldBrowsers" selector="preferredSpecName">preferredSpecName	^#listSpecProtocols</body></methods><methods><class-id>UI.TabbedDialog</class-id> <category>initialize-release</category><body package="OldBrowsers" selector="initialize">initialize	super initialize.	list := SelectionInList new.	list list: self masterList.	list selectionIndexHolder value: 1.	list selectionIndexHolder onChangeSend: #updatePreferences to: self.	(disturbed := false asValue) onChangeSend: #enableButtons to: self</body></methods><methods><class-id>UI.TabbedDialog</class-id> <category>top level</category><body package="OldBrowsers" selector="preferenceChoice">preferenceChoice	^list selectionIndexHolder</body><body package="OldBrowsers" selector="preferenceMasterList">preferenceMasterList	^list</body><body package="OldBrowsers" selector="preferenceTopMenu">preferenceTopMenu	| menuList |	menuList := list list.	^Menu labelArray: (menuList collect: [:item | item key])		values: (1 to: menuList size)</body><body package="OldBrowsers" selector="updatePreferences">updatePreferences	"Update the subcanvas for the currently selected preference item. Answer the receiver."	self rebuild.	self setFocus</body></methods><methods><class-id>UI.TabbedDialog</class-id> <category>events</category><body package="OldBrowsers" selector="requestForWindowClose">requestForWindowClose	builder window keyboardProcessor requestGlobalAutoAccept.	^self requestSliceChange</body></methods><methods><class-id>UI.TabbedDialog</class-id> <category>accessing</category><body package="OldBrowsers" selector="disturbed">disturbed	^disturbed value</body></methods><methods><class-id>UI.TabbedDialog</class-id> <category>private</category><body package="OldBrowsers" selector="disturb">disturb	disturbed value: true.	^true</body><body package="OldBrowsers" selector="enableButtons">enableButtons	| button |	(button := subBuilder namedComponents at: #resetButton ifAbsent: []) notNil		ifTrue: [self disturbed ifTrue: [button enable] ifFalse: [button disable]].	(button := subBuilder namedComponents at: #acceptButton ifAbsent: []) notNil		ifTrue: [self disturbed ifTrue: [button enable] ifFalse: [button disable]]</body><body package="OldBrowsers" selector="helpAction">helpAction	| sh |	sh := SimpleHelp helpString: self helpString.	sh class  openOn: sh</body><body package="OldBrowsers" selector="helpString">helpString	^self perform: list selection value last.</body><body package="OldBrowsers" selector="masterList">masterList	^self class masterList.</body><body package="OldBrowsers" selector="rebuild">rebuild	| canvas next |	canvas := builder componentAt: #activeComponents.	(next := list selection value first) == #textSizeBSpec		ifTrue:			[Cursor execute showWhile:				[canvas widget					client: self					spec: next					builder: (subBuilder := self builder newSubBuilder)]]		ifFalse:			[canvas widget				client: self				spec: next				builder: (subBuilder := self builder newSubBuilder)]</body><body package="OldBrowsers" selector="requestSliceChange">requestSliceChange	| win |	builder notNil ifTrue: [win := builder window].	self disturbed		ifTrue:			[(Dialog					confirm: (#alteredNotAccepted &lt;&lt; #dialogs &gt;&gt; 'Settings have been altered but not accepted.Do you wish to discard the changes?')					for: win)				ifTrue: [self resetForSlice. ^true]				ifFalse: [^false]]		ifFalse: [^true]</body><body package="OldBrowsers" selector="resetForSlice">resetForSlice	(subBuilder componentAt: #resetButton) widget model value: true.	self undisturb</body><body package="OldBrowsers" selector="setFocus">setFocus	"Set the keyboard input focus to be the first text input widget on the focus chain."	| newFocus |	(newFocus := builder keyboardProcessor keyboardConsumers			detect: [:aWidget | (aWidget isKindOf: NoteBookComposite) not]			ifNone: [nil]) notNil		ifTrue:			[builder keyboardProcessor setActive: newFocus controller.			(newFocus isKindOf: TextEditorView)				ifTrue: [newFocus controller selectEntireText].			newFocus invalidate]</body><body package="OldBrowsers" selector="undisturb">undisturb	disturbed value: false</body></methods><methods><class-id>UI.TabbedDialog</class-id> <category>interface opening</category><body package="OldBrowsers" selector="postOpenWith:">postOpenWith: aBuilder 	| canvas |	canvas := builder componentAt: #notebook.	canvas isNil ifTrue: [^self].	canvas widget		client: self		spec: #activeAreaSpec		builder: builder.	builder window keyboardProcessor keyboardHook: [:ev :ctrlr | self disturb. ev].	self updatePreferences</body></methods><methods><class-id>UI.TabbedDialog class</class-id> <category>interface specs</category><body package="OldBrowsers" selector="windowSpec">windowSpec	^( UISettings preferenceFor: #notebookStyle ) == #notebook		ifTrue: [ self windowNotebookSpec ]		ifFalse: [ self windowMenuSpec ]</body></methods><methods><class-id>UI.TabbedDialog class</class-id> <category>constants</category><body package="OldBrowsers" selector="windowLabel">windowLabel	"Answer a string for the window label."	self subclassResponsibility</body></methods><methods><class-id>UI.TabbedDialog class</class-id> <category>accessing</category><body package="OldBrowsers" selector="developmentSpecs">developmentSpecs	^developmentSpecList</body><body package="OldBrowsers" selector="masterList">masterList	^Notifier isDevelopment		ifTrue: [ self developmentSpecs ]		ifFalse: [ self runtimeSpecs ]</body><body package="OldBrowsers" selector="runtimeSpecs">runtimeSpecs	^runtimeSpecList</body></methods><methods><class-id>Tools.NameSpaceNavigator</class-id> <category>initialize</category><body package="OldBrowsers" selector="initialize">initialize	super initialize.	home := nil asValue.	home onChangeSend: #updateList to: self.	action := nil asValue.	action onChangeSend: #doAction to: self.	list := SelectionInList new.	path := SelectionInList new.	list selectionIndexHolder onChangeSend: #maybeNoPath to: self.	path selectionIndexHolder onChangeSend: #maybeNoList to: self.</body></methods><methods><class-id>Tools.NameSpaceNavigator</class-id> <category>accessing</category><body package="OldBrowsers" selector="action">action	^action</body><body package="OldBrowsers" selector="doAction">doAction	self perform: action value</body><body package="OldBrowsers" selector="finalSelection">finalSelection	^list selection == nil		ifTrue: [path selection == nil			ifTrue: [home value]			ifFalse: [path selection value]]		ifFalse: [list selection value]</body><body package="OldBrowsers" selector="home">home	^home</body><body package="OldBrowsers" selector="list">list	^list</body><body package="OldBrowsers" selector="openSelection">openSelection	list selection == nil		ifTrue: [path selection == nil			ifTrue: []			ifFalse: [home value: path selection value]]		ifFalse: [home value: list selection value]</body><body package="OldBrowsers" selector="path">path	^path</body></methods><methods><class-id>Tools.NameSpaceNavigator</class-id> <category>updating</category><body package="OldBrowsers" selector="maybeNoList">maybeNoList	path selectionIndex = 0		ifTrue: [(list selectionIndex = 0 and: [path list size ~= 0])			ifTrue: [path selectionIndex: path list size]]		ifFalse: [list selectionIndex: 0]</body><body package="OldBrowsers" selector="maybeNoPath">maybeNoPath	list selectionIndex = 0		ifTrue: [path list size = 0			ifFalse: [path selection: path list last]]		ifFalse: [path selectionIndex: 0]</body><body package="OldBrowsers" selector="updateList">updateList	| vars newPath |	vars := SortedCollection new.	home value bindingsDo: [:var |		var isForNameSpace			ifTrue: [vars add: var]].	list list: vars asList.	newPath := List with: home value.	[newPath first environment == nil]		whileFalse: [newPath addFirst: newPath first environment].	newPath := newPath collect: [:env | BrowserListEntry new value: env].	1 to: newPath size do: [:i |		(newPath at: i) offset: i-1*12@0].	path list: newPath.	path selection: newPath last</body></methods><methods><class-id>Tools.NameSpaceNavigator</class-id> <category>searching</category><body package="OldBrowsers" selector="addList:lines:validation:">addList: model lines: maxLines validation: valid	| height layout field grid font scrollW max fullMax |	height := builder window displayBox height.	layout := LayoutFrame new.	layout leftOffset: 16.	layout rightFraction: 1 offset: -16.	layout topOffset: height.	field := SequenceViewSpec model: model menu: nil layout: layout.	field selectionType: #normalSelection.	builder add: field.	builder wrapper widget controller setDispatcher:		(UIDispatcher new doubleClick: [valid value ifTrue: [self doubleClickList]]).	builder wrapper widget setValidTargetIndex: model selectionIndex.	scrollW := builder wrapper decorator scrollerComponent.	scrollW preferredBoundsBlock:				[:sw | | rect |				rect := sw component preferredBounds						translatedBy: sw translation.				rect height: maxLines*sw scrollGrid y.				rect].	font := builder wrapper widget textStyle defaultFont.	font := Screen default defaultFontPolicy findFont: font.	max := model list inject: 0 into: [:i :str | i max: str size].		"Instead of exactly measuring every string, we		assume that $o will be a fairly representative		character.  Actually, $o will probably be wider		than the average, but this will usually be OK."	max := (font widthOf: $o) * max.		"Don't let the dialog get too wide."	fullMax := 350.	max &gt; fullMax		ifTrue:			[max := fullMax.			builder wrapper decorator useHorizontalScrollBar.			builder wrapper widget measureWidth: true].	grid := builder wrapper preferredBounds height.	layout bottomOffset: height+grid.	self addGap: grid.	self minWidth: max + 48.	^builder wrapper</body><body package="OldBrowsers" selector="addNoCloseLabels:values:default:storeInto:takeKeyboard:equalize:">addNoCloseLabels: labels values: values default: defaultValue storeInto: result takeKeyboard: takeKeyboard equalize: eqBoolean	| num maxButtonWidth maxButtonHeight separation buttonWAs buttonWidth window box layout left top actualColumns actualRows |	num := labels size.	maxButtonWidth := 0.	maxButtonHeight := 0.	separation := 20.	buttonWAs := OrderedCollection new.	window := builder window.	box := window displayBox.	actualColumns := SmallInteger maxVal min: labels size.	actualRows := num + actualColumns - 1 // actualColumns.	"We have to create and place the buttons before we can ask them their	preferred bounds and refine their spacing."	layout := LayoutFrame new.	layout leftFraction: 0.5; rightFraction: 0.5.	builder newComposite.	1 to: num do:		[:index |		| lbl val buttonSpec buttonW bExt |		lbl := labels at: index.		val := values at: index.		(buttonSpec :=			ActionButtonSpec				model: (result == nil						ifTrue: [val]						ifFalse: [[result value: val]])				label: lbl				layout: (0@0 extent: 1@1))			defaultable: (values includes: defaultValue);			isDefault: val == defaultValue.		builder add: buttonSpec.		buttonW := builder wrapper.		(takeKeyboard and: [val == defaultValue])			ifTrue: [builder keyboardProcessor setActive: buttonW widget controller].		maxButtonWidth := maxButtonWidth max: (bExt := buttonW preferredBounds extent) x.		maxButtonHeight := maxButtonHeight max: bExt y.		buttonWAs add: buttonW -&gt; bExt]. 	buttonWidth := eqBoolean		ifTrue: [actualColumns * maxButtonWidth + ((actualColumns - 1) * separation)]		ifFalse: [buttonWAs				inject: separation negated				into: [:x :assoc | x + assoc value x + separation]].	layout topOffset: box height; bottomOffset: box height+(actualRows * maxButtonHeight).	layout		leftOffset: 0 - ((buttonWidth + 1) // 2);		rightOffset: (buttonWidth + 1) // 2.	builder endCompositeLayout: layout.	left := 0.	top := 0.	1 to: num do:		[:index |		| bttnWA width |		bttnWA := buttonWAs at: index.		width := eqBoolean				ifTrue: [maxButtonWidth]				ifFalse: [bttnWA value x].		bttnWA key newLayout:			(Rectangle				left: left				right: left + width				top: top				bottom: top + maxButtonHeight).		index \\ actualColumns = 0			ifTrue:				[left := 0.				top := top + maxButtonHeight]			ifFalse: [left := left + width + separation]].	self addGap: maxButtonHeight * actualRows.	buttonWidth := buttonWidth + separation.	self minWidth: buttonWidth.	^builder wrapper</body><body package="OldBrowsers" selector="doubleClickList">doubleClickList	list selection == nil		ifTrue: [path selection == nil			ifFalse: [home value: path selection value]]		ifFalse: [home value: list selection value].</body></methods><methods><class-id>Tools.NameSpaceNavigator class</class-id> <category>searching</category><body package="OldBrowsers" selector="searchFrom:label:">searchFrom: aNameSpace label: label	"NameSpaceNavigator searchFrom: Smalltalk			label: 'Move to which environment?' "	| sd spec listW buttons |	sd := self new.	sd home value: aNameSpace.	spec := (sd class interfaceSpecFor: #emptySpec).	sd builder add: spec window.	sd builder add: spec component.	sd setInitialGap.	sd addMessage: label centered: true. 	sd addGap: 8.	sd		addList: sd path		lines: 4		validation: [sd path selectionIndex &gt; 0].	sd addGap: 8.	listW := sd			addList: sd list			lines: 8			validation: [sd list selectionIndex &gt; 0].	listW widget setValidTargetIndex: sd list selectionIndex.	sd addGap: 4.	buttons := sd addOK: [true].	sd addGap: 15.	sd addNoCloseLabels: (Array with: (#Open &lt;&lt; #dialogs &gt;&gt; 'Open'))		values: #(#openSelection)		default: nil		storeInto: sd action		takeKeyboard: true		equalize: true.	sd addGap: 6.	sd bottomAlignLowerEdge: listW.	sd bottomAlign: (Array with: buttons).	sd preOpen.	sd builder openDialogWithExtent: sd builder window displayBox extent.	^sd accept value		ifTrue: [sd finalSelection]		ifFalse: [nil]</body></methods><methods><class-id>Tools.PickASomethingDialog</class-id> <category>intialize</category><body package="OldBrowsers" selector="intialize">intialize	self list onChangeSend: #changedSelection to: self</body></methods><methods><class-id>Tools.PickASomethingDialog</class-id> <category>actions</category><body package="OldBrowsers" selector="doAccept">doAccept	self list selection isNil		ifTrue: [accept value: false]		ifFalse: 			[accept value: true.			self close]</body><body package="OldBrowsers" selector="doubleClick">doubleClick	self doAccept</body></methods><methods><class-id>Tools.PickASomethingDialog</class-id> <category>interface opening</category><body package="OldBrowsers" selector="postBuildWith:">postBuildWith: aBuilder	| component |	(component := aBuilder componentAt: #list) isNil ifTrue: [^self].	component widget		visualBlock: self visualBlock;		selectedVisualBlock: self selectedVisualBlock</body></methods><methods><class-id>Tools.PickASomethingDialog</class-id> <category>private</category><body package="OldBrowsers" selector="selectedVisualBlock">selectedVisualBlock	"Supply the block that determins the appearance for selected list entries."	^[ :view :index | | aText anItem listEntry label |	   listEntry :=  view sequence at: index.	   anItem := listEntry value.	   aText := self textForItem: anItem.	   aText emphasizeAllWith: (self textEmphasisForItem: anItem).  	   (label:= listEntry displayLabel: aText) attributes: view textStyle; offset: label offset.	   label:= ReversingWrapper on: label.	   label reverse setValue: true.	   BoundedWrapper on: label]</body><body package="OldBrowsers" selector="textEmphasisForItem:">textEmphasisForItem: anItem	"Supply the default emphasis for list items"		^#( #norm )</body><body package="OldBrowsers" selector="textForItem:">textForItem: aListEntry	^aListEntry fullName asText</body><body package="OldBrowsers" selector="visualBlock">visualBlock	"Supply the block that determins the appearance for unselected list entries."	^[:view :index | | aText anItem listEntry label |	   listEntry := view sequence at: index.	   anItem := listEntry value.	   aText := self textForItem: anItem.	   aText emphasizeAllWith: (self textEmphasisForItem: anItem).	   (label := listEntry displayLabel: aText) attributes: view textStyle; offset: label offset.	   BoundedWrapper on: label]</body></methods><methods><class-id>Tools.PickASomethingDialog</class-id> <category>aspects</category><body package="OldBrowsers" selector="list">list	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^list isNil		ifTrue:			[list := SelectionInList new]		ifFalse:			[list]</body></methods><methods><class-id>Tools.PickASomethingDialog</class-id> <category>change</category><body package="OldBrowsers" selector="changedSelection">changedSelection	self list selection isNil 		ifTrue: [accept value: false]		ifFalse: [accept value: true]</body></methods><methods><class-id>Tools.PickASomethingDialog class</class-id> <category>opening</category><body package="OldBrowsers" selector="pickASomethingFrom:">pickASomethingFrom: aListOfBrowserListEntries	| sd |	sd := self new.	sd list list: aListOfBrowserListEntries.	sd open ifFalse:[^nil].	^sd list selection</body></methods><methods><class-id>UI.PackagePropertiesDialog</class-id> <category>help</category><body package="OldBrowsers" selector="generalPropertiesHelp">generalPropertiesHelp	^(#generalPropertiesHelp &lt;&lt; #dialogs &gt;&gt; 'This is an inspector on &lt;1s&gt;''s properties.  The properties are stored in a IdentityDictionary, and what you see is something that should have the same type of behavior as a normal DictionaryInspector. &lt;n&gt;&lt;n&gt;You should be able  to add any key-&gt;value pair you want.  For example, one might want to add a Author property for &lt;1s&gt;.  To do so, simply invoke the operate menu from the left pane of the inspector and select "add-field".   The Accept button at the bottom of this page will only be enabled after you actually accept from the operate menu in the embedded inspector''s right pane.&lt;n&gt;NOTE: properties with a value of nil will be removed.') expandMacrosWith: self package name</body><body package="OldBrowsers" selector="loadHelp">loadHelp^(#packagePropertiesHelp &lt;&lt; #dialogs &gt;&gt; 'Loading actions are one argument blocks that take the package / parcel being loaded as an argument.In the case of parcels, the PreLoadAction is run after all the code from a parcel has been parsed but before the code has been installed in the system.  Hence the pre-load action may happen too late to do things that affect the contents of a parcel.  Use the pre-read action if you want an action that runs before the parcel''s contents are parsed.In the case of packages, code is currently compiled definition by definition so the pre-read and pre-load actions are run immediately consecutively.	PreReadAction	&lt;code parsed from parcel and built&gt;	PreLoadAction	&lt;code installed into the system&gt;	PostLoadAction')</body><body package="OldBrowsers" selector="loadOptionsHelp">loadOptionsHelp	^(#loadOptionsHelp &lt;&lt; #dialogs &gt;&gt; 'A Parcel''s warning suppression action must be a block taking one argument, the name of a prerequisite Parcel being loaded.  The block should answer true if any warnings caused by loading the prerequsiite shouild be suppressed.The warning suppression block is run before any of the Parcel''s code is loaded. Consequently it cannot and should not mention any code in this Parcel.')</body><body package="OldBrowsers" selector="preReadHelp">preReadHelp^(#preReadHelp &lt;&lt; #dialogs &gt;&gt; 'A Parcel''s pre-read action is a zero argument block, which is run before any of the Parcel is read, but after any of its prerequisites are loaded.  The block should answer true if loading is to continue; any other return value will abort the load.A Parcel''s prerequisite version block must be a block taking three arguments, the name of a prerequisite Parcel being loaded, its version string, and the version string defined in the Parcel''s list of prerequisites. The block should answer true if the prerequsite''s version is acceptable, and should be loaded.  Otherwise the loader will continue to search for another parcel of the same name with a different version.')</body><body package="OldBrowsers" selector="prerequisitesHelp">prerequisitesHelp	^(#prerequisitesHelp &lt;&lt; #dialogs &gt;&gt; 'Deployment prerequsites are an array of prerequisite parcels.  Each individual prerequisite is a name, version pair.  On loading the Parcel loader searches along the SearchPath for .pcl files that have the required name and attempts to load them.  All parcels have a version which is an arbitrary string, that defaults to the empty string.  Each Parcel can also define a prerequisite version block which it can use to select appropriate versions of prerequisite parcels.Development prerequisites are used in loading from Store. Each prerequisite is an array with a type (#parcel #package #bundle or #any), a name and a version string. Developement prerequisites are usually supersets of the deployment prerequisities.')</body><body package="OldBrowsers" selector="saveHelp">saveHelp	^(#saveHelp &lt;&lt; #dialogs &gt;&gt; 'Save actions are one argument blocks that take the package / parcel being saved as an argument.	PreSaveAction')</body><body package="OldBrowsers" selector="unloadHelp">unloadHelp	^(#unloadHelp &lt;&lt; #dialogs &gt;&gt; 'Unloading actions are actions run when unloading a package or parcel.  The preUnloadAction is run before unloading commences.  It is a one-argument block that takes the package or parcel being unloaded as an argument.  The postUnloadAction is a zero-argument block run after the package or parcel has been unloaded and discarded.	PreUnloadAction	&lt;code removed from system&gt;	PostUnloadAction')</body></methods><methods><class-id>UI.PackagePropertiesDialog</class-id> <category>accessing</category><body package="OldBrowsers" selector="package">package	^package</body><body package="OldBrowsers" selector="package:">package: aPackage	package := aPackage.	self initializeProperties.</body></methods><methods><class-id>UI.PackagePropertiesDialog</class-id> <category>interface</category><body package="OldBrowsers" selector="labelFor:">labelFor: aKey 	"Return an instance of a non-abstract subclass of CharacterArray, 	that will be used as a label for a component."	^[ self perform: aKey ] on: MessageNotUnderstood do:		[ : e | e return: aKey ].</body><body package="OldBrowsers" selector="windowLabel">windowLabel	^package  == nil		ifTrue: [ (#PackageProperties &lt;&lt; #labels &gt;&gt; 'Package properties') ]		ifFalse: [ (#packageName &lt;&lt; #labels &gt;&gt; '&lt;1s&gt; properties') expandMacrosWith: package name ]</body></methods><methods><class-id>UI.PackagePropertiesDialog</class-id> <category>initialization</category><body package="OldBrowsers" selector="actionStringFor:numArgs:">actionStringFor: aPackageAction numArgs: numArgs	| string |	string := CodeComponent stringFromAction: (package perform: aPackageAction).	^(string isNil		ifTrue: [self defaultActionTextFor: numArgs]		ifFalse: [string]) asText</body><body package="OldBrowsers" selector="initializeProperties">initializeProperties	"Initialize the receiver's values from the package."	properties := IdentityDictionary new.	properties		at: #deploymentPrerequisites		put: package deploymentPrerequisites storeString asValue;		at: #developmentPrerequisites		put: package developmentPrerequisites storeString asValue;		at: #versionSelection		put: (package versionSelectionBlock == nil					ifTrue: [self defaultVersionSelectionText]					ifFalse: [package versionSelectionBlock]) asValue.	#(#preload #postload #preunload #presave)	  with: #(#preLoadBlock #postLoadBlock #preUnloadBlock #preSaveBlock)	  do: [:aspect :action |		properties at: aspect put: (self actionStringFor: action numArgs: 1) asValue].	properties		at: #warningSuppression		put: (package warningSuppressionBlock == nil					ifTrue: [self defaultWarningSuppressionText]					ifFalse: [package warningSuppressionBlock]) asValue.	properties		at: #preRead		put: (package preReadBlock == nil				ifTrue: [self defaultPreReadText]				ifFalse: [self actionStringFor: #preReadBlock numArgs: 0]) asValue.	properties		at: #postunload		put: (self actionStringFor: #postUnloadBlock numArgs: 0) asValue.	properties		at: #generalProperties		put: (ParcelPropertiesInspector new inspect: package properties).	^properties</body></methods><methods><class-id>UI.PackagePropertiesDialog</class-id> <category>private</category><body package="OldBrowsers" selector="defaultActionTextFor:">defaultActionTextFor: numArgs	^(numArgs =1 ifTrue: [(#defaultActionText &lt;&lt; #dialogs &gt;&gt; '[ :pkg | &lt;nn&gt;]')] ifFalse: ['[&lt;nn&gt;]']) expandMacros asText</body><body package="OldBrowsers" selector="defaultPreReadText">defaultPreReadText	^(#defaultPreReadText &lt;&lt; #dialogs &gt;&gt; '[&lt;nn&gt;booleanExpression&lt;nn&gt;]') expandMacros asText</body><body package="OldBrowsers" selector="defaultVersionSelectionText">defaultVersionSelectionText	^(#defaultVersionSelectionText &lt;&lt; #dialogs &gt;&gt; '[ :parcelName :versionString :requiredVersionString |&lt;n&gt;  booleanExpression&lt;n&gt;]') expandMacros asText</body><body package="OldBrowsers" selector="defaultWarningSuppressionText">defaultWarningSuppressionText	^(#defaultWarningSuppressionText &lt;&lt; #dialogs &gt;&gt; '[:prerequisiteName|&lt;n&gt;booleanExpression&lt;n&gt;]') expandMacros asText</body><body package="OldBrowsers" selector="rebuild">rebuild	"We need to ensure that we get callback notification on changes 	to the TextEditors and that the proper menu is used for the TextEditor.	Fortunately, we thought ahead and chose a naming convention for the 	editors to allow for easy selecting from the subBuilder."	| textEditorNames |	super rebuild.	textEditorNames := subBuilder namedComponents keys select: [:name | '*Text' match: name].	textEditorNames do: [:name | | textController |		textController := (subBuilder componentAt: name) widget controller.		textController continuousAccept: true.		textController initializeMenuForCode]</body><body package="OldBrowsers" selector="removeAction:">removeAction: actionSymbol	( Dialog confirm: 		( (#prereqRemove &lt;&lt; #dialogs &gt;&gt; 'Remove &lt;1s&gt; from &lt;2s&gt;?') expandMacrosWith: actionSymbol with: package name )	)		ifTrue: [ package propertyAt: actionSymbol put: nil ]</body><body package="OldBrowsers" selector="validateBlock:numberOfArguments:notifying:">validateBlock: code numberOfArguments: integer notifying: aController 	"Validate that code compiles to a block with integer # of arguments. 	Accepts empty strings as an attempt to remove an attribute. 	Return a symbol to the receiver that indicates what the problem is."	| blk |	(code == nil or: [code isEmpty])		ifTrue: [^#ok].	code = (self defaultActionTextFor: integer) ifTrue: [ ^#unspecified ].	blk := self class compilerClass new				evaluate: code string				in: nil				allowReceiver: false				receiver: nil				environment: Object environment				notifying: aController				ifFail: [^#compile].	^[blk numArgs == integer			ifTrue: [#ok]			ifFalse: [#arguments]]		on: MessageNotUnderstood		do: [:e | e return: #compile]</body></methods><methods><class-id>UI.PackagePropertiesDialog</class-id> <category>properties</category><body package="OldBrowsers" selector="deploymentPrerequisitesText">deploymentPrerequisitesText	^properties at: #deploymentPrerequisites</body><body package="OldBrowsers" selector="developmentPrerequisitesText">developmentPrerequisitesText	^properties at: #developmentPrerequisites</body><body package="OldBrowsers" selector="generalProperties">generalProperties	^properties at: #generalProperties</body><body package="OldBrowsers" selector="generalPropertiesAccept">generalPropertiesAccept	"Update the properties to the package/parcel with the modified properties."	| editingProperties |	editingProperties := self generalProperties object.	editingProperties associationsDo:		[ :assoc | 		( self package propertyAt: assoc key ) = assoc value			ifTrue: [ editingProperties removeKey: assoc key ]		].	self package copyPropertiesFrom: editingProperties.	self generalProperties inspect: self package properties.</body><body package="OldBrowsers" selector="generalPropertiesReset">generalPropertiesReset	| oldSelection |	oldSelection := self generalProperties fieldListHolder selection.	[self generalProperties inspect: self package properties]		ensure: [self generalProperties fieldListHolder selection: oldSelection]</body><body package="OldBrowsers" selector="loadAccept">loadAccept	| postLoadStatus textController numBlockArgs preLoadStatus |	numBlockArgs := 1.	textController := (subBuilder componentAt: #postloadText) widget controller.	subBuilder keyboardProcessor setActive: textController.	textController selectEntireText.	postLoadStatus := self						validateBlock: (properties at: #postload) value						numberOfArguments: numBlockArgs						notifying: textController.	postLoadStatus == #arguments ifTrue:		[^Dialog warn: ((#errPostLoadArguments &lt;&lt; #dialogs &gt;&gt; 'Post-Load action has wrong number of arguments. It expects &lt;1p&gt;')expandMacrosWith:numBlockArgs)].	postLoadStatus == #compile ifTrue: 		[self undisturb.		 ^Dialog warn: (#errFixCompilation &lt;&lt; #dialogs &gt;&gt; 'Fix the compiliation error')].	textController := (subBuilder componentAt: #preloadText) widget controller.	subBuilder keyboardProcessor setActive: textController.	textController selectEntireText.	preLoadStatus := self						validateBlock: (properties at: #preload) value						numberOfArguments: numBlockArgs						notifying: textController.	preLoadStatus == #arguments ifTrue:		[^Dialog warn: ((#errPreLoadArguments &lt;&lt; #dialogs &gt;&gt; 'Pre-Load action has wrong number of arguments. It expects &lt;1p&gt;') expandMacrosWith: numBlockArgs)].	preLoadStatus == #compile ifTrue: 		[self undisturb.		 ^Dialog warn: (#errFixCompilation &lt;&lt; #dialogs &gt;&gt; 'Fix the compiliation error')].	package preLoadBlock:		(preLoadStatus == #unspecified			ifTrue: [nil]			ifFalse: [CodeComponent asActionBlock: (properties at: #preload) value]).	package postLoadBlock:		(postLoadStatus == #unspecified			ifTrue: [nil]			ifFalse: [CodeComponent asActionBlock: (properties at: #postload) value])</body><body package="OldBrowsers" selector="loadOptionsAccept">loadOptionsAccept	| numBlockArgs textController warningSuppressionStatus |	numBlockArgs := 1.	textController := (subBuilder componentAt: #warningSuppressionText) widget controller.	subBuilder keyboardProcessor setActive: textController.	textController selectEntireText.	warningSuppressionStatus := self						validateBlock: (properties at: #warningSuppression) value						numberOfArguments: numBlockArgs						notifying: textController.	warningSuppressionStatus == #arguments ifTrue:		[^Dialog warn: ((#errSuppressionArguments &lt;&lt; #dialogs &gt;&gt; 'Warning suppression action has wrong number of arguments. It expects &lt;1p&gt;') expandMacrosWith: numBlockArgs)].	warningSuppressionStatus == #compile ifTrue: 		[self undisturb.		 ^Dialog warn: (#errFixCompilation &lt;&lt; #dialogs &gt;&gt; 'Fix the compiliation error')].	package warningSuppressionBlock:		(warningSuppressionStatus == #unspecified			ifTrue: [nil]			ifFalse: [(CodeComponent asActionBlock: (properties at: #warningSuppression) value)])</body><body package="OldBrowsers" selector="loadOptionsRemove">loadOptionsRemove	self removeAction: #warningSuppressionBlock.	self loadOptionsReset.</body><body package="OldBrowsers" selector="loadOptionsReset">loadOptionsReset	| warningSuppression |	(warningSuppression := CodeComponent stringFromAction: (package perform: 	#warningSuppressionBlock)) isNil		ifTrue: [warningSuppression := self defaultWarningSuppressionText].	( properties at: #warningSuppression )		value: ( warningSuppression ).</body><body package="OldBrowsers" selector="loadRemove">loadRemove	self removeAction: #preLoadBlock.	self removeAction: #postLoadBlock.	self loadReset.</body><body package="OldBrowsers" selector="loadReset">loadReset	(properties at: #preload)		value: (self actionStringFor: #preLoadBlock numArgs: 1).	(properties at: #postload)		value: (self actionStringFor: #postLoadBlock numArgs: 1)</body><body package="OldBrowsers" selector="postloadText">postloadText	^properties at: #postload</body><body package="OldBrowsers" selector="postunloadText">postunloadText	^properties at: #postunload</body><body package="OldBrowsers" selector="preloadText">preloadText	^properties at: #preload</body><body package="OldBrowsers" selector="preReadAccept">preReadAccept	| readStatus textController numBlockArgs versionStatus |	numBlockArgs := 0.	textController := (subBuilder componentAt: #preReadText) widget controller.	subBuilder keyboardProcessor setActive: textController.	textController selectEntireText.	readStatus := (properties at: #preRead) value = self defaultPreReadText					ifTrue: [#unspecified]					ifFalse:						[self							validateBlock: (properties at: #preRead) value							numberOfArguments: 0							notifying: textController].	readStatus == #arguments ifTrue:		[^Dialog warn: ((#errPreLoadArguments &lt;&lt; #dialogs &gt;&gt; 'Pre-Load action has wrong number of arguments. It expects &lt;1p&gt;') expandMacrosWith: numBlockArgs)].	readStatus == #compile ifTrue:		[self undisturb.		 ^Dialog warn: (#errFixCompilation &lt;&lt; #dialogs &gt;&gt; 'Fix the compiliation error')].	numBlockArgs := 0.	versionStatus :=		(properties at: #versionSelection) value = self defaultVersionSelectionText			ifTrue: [#unspecified]			ifFalse: [(self						validateBlock: ( properties at: #versionSelection ) value						numberOfArguments: 3						notifying: (subBuilder componentAt: #versionSelectionText) widget controller)].	versionStatus == #arguments ifTrue:		[^Dialog warn: ((#errVersionSelectionArguments &lt;&lt; #dialogs &gt;&gt; 'version selection action has wrong number of arguments. It expects &lt;1p&gt;') expandMacrosWith: numBlockArgs)].	versionStatus == #compile ifTrue:		[self undisturb.		 ^Dialog warn: (#errFixCompilation &lt;&lt; #dialogs &gt;&gt; 'Fix the compiliation error')].	package preReadBlock: 		(readStatus == #unspecified			ifTrue: [nil]			ifFalse: [CodeComponent asActionBlock: (properties at: #preRead) value]).	package versionSelectionBlock:		(versionStatus == #unspecified			ifTrue: [nil]			ifFalse: [CodeComponent asActionBlock: (properties at: #versionSelection) value])</body><body package="OldBrowsers" selector="preReadRemove">preReadRemove	self removeAction: #preReadBlock.	self removeAction: #versionSelectionBlock.	self preReadReset</body><body package="OldBrowsers" selector="preReadReset">preReadReset	( properties at: #preRead ) value:			( package preReadBlock == nil				ifTrue: [ self defaultPreReadText ]				ifFalse: [ self actionStringFor: #preReadBlock numArgs: 0 ] ).	( properties at: #versionSelection ) value: 			( package versionSelectionBlock == nil				ifTrue: [ self defaultVersionSelectionText ]				ifFalse: [ package versionSelectionBlock ] ).</body><body package="OldBrowsers" selector="preReadText">preReadText	^properties at: #preRead</body><body package="OldBrowsers" selector="prerequisitesAccept">prerequisitesAccept	| missing devSet |	package deploymentPrerequisites: 		(Compiler evaluate: ( properties at: #deploymentPrerequisites ) value asString).	package developmentPrerequisites: 		(Compiler evaluate: ( properties at: #developmentPrerequisites ) value asString).	missing := OrderedCollection new.	devSet := ( package developmentPrerequisites collect: [ :array | array at: 2 ] ) asSet.	package deploymentPrerequisites do:		[ :array |		( devSet includes: array first )			ifFalse: [ missing add: ( array first ) ].		].	missing isEmpty 		ifFalse: 			[ | str |			str := (String new: 256) writeStream.			missing do: [ :name | str nextPutAll: ' ', name ].			Dialog warn: ((#DevPrereqsMissing &lt;&lt; #dialogs &gt;&gt; 'Development prerequisites appear to be missing:&lt;1s&gt;.')				expandMacrosWith: str contents).			].</body><body package="OldBrowsers" selector="prerequisitesRemove">prerequisitesRemove	( Dialog confirm: 		( (#prereqRemove &lt;&lt; #dialogs &gt;&gt; 'Remove &lt;1s&gt; from &lt;2s&gt;?') expandMacrosWith:  #deploymentPrerequisites with: package name )	)		ifTrue: [ package deploymentPrerequisites: nil ].	self removeAction: #developmentPrerequisites.	self prerequisitesReset.</body><body package="OldBrowsers" selector="prerequisitesReset">prerequisitesReset	( properties at: #deploymentPrerequisites ) 		value: ( package deploymentPrerequisites storeString ).	( properties at: #developmentPrerequisites ) 		value: ( package developmentPrerequisites storeString ).</body><body package="OldBrowsers" selector="prerequisitesText">prerequisitesText	^properties at: #prerequisites</body><body package="OldBrowsers" selector="presaveText">presaveText	^properties at: #presave</body><body package="OldBrowsers" selector="preunloadText">preunloadText	^properties at: #preunload</body><body package="OldBrowsers" selector="saveAccept">saveAccept	| validationStatus textController numBlockArgs |	numBlockArgs := 1.	textController := (subBuilder componentAt: #presaveText) widget controller.	subBuilder keyboardProcessor setActive: textController.	textController selectEntireText.	validationStatus := self						validateBlock: (properties at: #presave) value						numberOfArguments: numBlockArgs						notifying: textController.	validationStatus == #arguments ifTrue:		[^Dialog warn: ((#errPreSaveArguments &lt;&lt; #dialogs &gt;&gt; 'Pre-Save action has wrong number of arguments. It expects &lt;1p&gt;') expandMacrosWith: numBlockArgs)].	validationStatus == #compile ifTrue: 		[self undisturb.		 ^Dialog warn: (#errFixCompilation &lt;&lt; #dialogs &gt;&gt; 'Fix the compiliation error')].	package preSaveBlock: 		(validationStatus == #unspecified			ifTrue: [nil]			ifFalse: [CodeComponent asActionBlock: (properties at: #presave) value])</body><body package="OldBrowsers" selector="saveRemove">saveRemove	self removeAction: #preSaveBlock.	self saveReset.</body><body package="OldBrowsers" selector="saveReset">saveReset	(properties at: #presave)		value: (self actionStringFor: #preSaveBlock numArgs: 1).</body><body package="OldBrowsers" selector="unloadAccept">unloadAccept	| postUnloadStatus textController numPreUnloadBlockArgs numPostUnloadBlockArguments preUnloadStatus |	numPreUnloadBlockArgs := 1.	numPostUnloadBlockArguments := 0.	textController := (subBuilder componentAt: #postunloadText) widget controller.	subBuilder keyboardProcessor setActive: textController.	textController selectEntireText.	postUnloadStatus := self							validateBlock: (properties at: #postunload) value							numberOfArguments: numPostUnloadBlockArguments							notifying: textController.	postUnloadStatus == #arguments ifTrue:		[^Dialog warn: ((#errPostLoadArguments &lt;&lt; #dialogs &gt;&gt; 'Post-Load action has wrong number of arguments. It expects &lt;1p&gt;') expandMacrosWith: numPostUnloadBlockArguments)].	postUnloadStatus == #compile ifTrue: 		[self undisturb.		 ^Dialog warn: (#errFixCompilation &lt;&lt; #dialogs &gt;&gt; 'Fix the compiliation error')].	textController := (subBuilder componentAt: #preunloadText) widget controller.	subBuilder keyboardProcessor setActive: textController.	textController selectEntireText.	preUnloadStatus := self							validateBlock: (properties at: #preunload) value							numberOfArguments: numPreUnloadBlockArgs							notifying: textController.	preUnloadStatus == #arguments ifTrue:		[^Dialog warn: ((#errPreUnloadArguments &lt;&lt; #dialogs &gt;&gt; 'Pre-Unload action has wrong number of arguments. It expects &lt;1p&gt;') expandMacrosWith: numPreUnloadBlockArgs)].	preUnloadStatus == #compile		ifTrue: 			[self undisturb.			^Dialog warn: (#errFixCompilation &lt;&lt; #dialogs &gt;&gt; 'Fix the compiliation error')].	package preUnloadBlock: 		(preUnloadStatus == #unspecified 			ifTrue: [nil]			ifFalse: [(CodeComponent asActionBlock: (properties at: #preunload) value)]).	package postUnloadBlock: 		(postUnloadStatus == #unspecified			ifTrue: [nil]			ifFalse: [(CodeComponent asActionBlock: (properties at: #postunload) value)])</body><body package="OldBrowsers" selector="unloadRemove">unloadRemove	self removeAction: #preUnloadBlock.	self removeAction: #postUnloadBlock.	self unloadReset.</body><body package="OldBrowsers" selector="unloadReset">unloadReset	(properties at: #preunload)		value: (self actionStringFor: #preUnloadBlock numArgs: 1).	(properties at: #postunload)		value: (self actionStringFor: #postUnloadBlock numArgs: 0)</body><body package="OldBrowsers" selector="versionSelectionText">versionSelectionText	^properties at: #versionSelection</body><body package="OldBrowsers" selector="warningSuppressionText">warningSuppressionText	^properties at: #warningSuppression</body></methods><methods><class-id>UI.PackagePropertiesDialog</class-id> <category>events</category><body package="OldBrowsers" selector="noticeOfWindowClose:">noticeOfWindowClose: aWindow 	super noticeOfWindowClose: aWindow.	self release</body></methods><methods><class-id>UI.PackagePropertiesDialog</class-id> <category>updating</category><body package="OldBrowsers" selector="update:with:from:">update: anAspectSymbol with: aParameter from: aSender 	(anAspectSymbol = #accept and: ([aSender class = ParcelPropertiesInspector and: [aParameter]]))		ifTrue: [self disturb].	^super update: anAspectSymbol with: aParameter</body></methods><methods><class-id>UI.PackagePropertiesDialog</class-id> <category>interface opening</category><body package="OldBrowsers" selector="postOpenWith:">postOpenWith: aBuilder 	"We do not use the keyboard hook that the superclass sets up 	because of our implementation of #rebuild. Also, we set up a 	dependency on our embedded inspector to get the Accept and 	Reset buttons to reflect the true state of things"	super postOpenWith: aBuilder.	self builder window keyboardProcessor keyboardHook: nil.	self generalProperties fieldListHolder listHolder onChangeSend: #disturb to: self.	self generalProperties addDependent: self</body></methods><methods><class-id>UI.PackagePropertiesDialog</class-id> <category>initialize-release</category><body package="OldBrowsers" selector="release">release	super release.	self generalProperties removeDependent: self.	self generalProperties fieldListHolder listHolder retractInterestsFor: self</body></methods><methods><class-id>UI.PackagePropertiesDialog class</class-id> <category>initialization</category><body package="OldBrowsers" selector="initialize">initialize	"self initialize"	developmentSpecList :=		OrderedCollection new			add: (#Prerequisites &lt;&lt; #labels &gt;&gt; 'Prerequisites')-&gt;#(#prerequisitesSpec #prerequisitesHelp);			add: (#LoadOptions &lt;&lt; #labels &gt;&gt; 'Load Options')-&gt;#(#loadOptionsSpec #loadOptionsHelp);			add: (#PrereadActions &lt;&lt; #labels &gt;&gt; 'Preread Actions')-&gt;#(#preReadSpec #preReadHelp);			add: (#LoadActions &lt;&lt; #labels &gt;&gt; 'Load Actions')-&gt;#(#loadSpec #loadHelp);			add: (#UnloadActions &lt;&lt; #labels &gt;&gt; 'Unload Actions')-&gt;#(#unloadSpec #unloadHelp);			add: (#SaveActions &lt;&lt; #labels &gt;&gt; 'Save Actions')-&gt;#(#saveSpec #saveHelp);			add: (#OtherProperties &lt;&lt; #labels &gt;&gt; 'Other Properties')-&gt;#(#generalPropertiesSpec #generalPropertiesHelp);			asArray.	runtimeSpecList := Array new</body><body package="OldBrowsers" selector="on:">on: aPackage	"Open  a properties dialog  on aPackage."	self openOn: ( self new package: aPackage; yourself )</body></methods><methods><class-id>UI.PackagePropertiesDialog class</class-id> <category>interface opening</category><body package="OldBrowsers" selector="invalidUseWarning">invalidUseWarning	"Raise a Dialog to warn the client of the receiver that they are not	using the correct protocol to open an instance."	Dialog warn: ((#invalidDialogUseWarning &lt;&lt; #dialogs &gt;&gt; 'You must open up &lt;1s&gt; with #on:&lt;n&gt;&lt;1s&gt; requires a subclass of&lt;n&gt;CodeComponent to be properly initialized.') expandMacrosWith: self name)</body><body package="OldBrowsers" selector="open">open	"Use #on: instead, as the receiver relies on a CodeComponent to 	properly initialize itself."	self invalidUseWarning</body></methods><methods><class-id>Tools.SelectorBrowserHelper</class-id> <category>accessing</category><body package="OldBrowsers" selector="proposedWindowLabel">proposedWindowLabel	| writeStream |	self selection isNil ifFalse:		[^(#Ip2sMessageBrowser &lt;&lt; #dialogs &gt;&gt; '&lt;1p&gt;&gt;&gt;&lt;2s&gt; Message Browser')			expandMacrosWith: self selectedClassOrNameSpace			with: self selection].	writeStream := (String new: 30) writeStream.	self protocols do: [:protocol | writeStream nextPutAll: protocol; space].	^(#Ip2sMessageCategoryBrowser &lt;&lt; #dialogs &gt;&gt; '&lt;1p&gt; {&lt;2s&gt;} Message Category Browser')			expandMacrosWith: self selectedClassOrNameSpace			with: writeStream contents</body><body package="OldBrowsers" selector="protocols">protocols	"This replaces #protocol from the older code now that multiple	selection is supported.  It answers a collection of selected protocols,	or an empty collection; never nil. The original #protocol is obsolete	and its use is discouraged."	| protocols |	protocols := self selected: #protocol.	^protocols isNil 		ifTrue: [#()] 		ifFalse: [protocols]</body><body package="OldBrowsers" selector="windowLabel">windowLabel	| stream |	stream := String new writeStream.	self protocols 		do: [ :p | stream nextPutAll: p ]		separatedBy: [ stream nextPutAll: ', ' ].	^(#Ip2sMessageCategoryBrowser &lt;&lt; #dialogs &gt;&gt; '&lt;1p&gt; {&lt;2s&gt;} Message Category Browser')			expandMacrosWith: self selectedClassOrNameSpace			with: stream contents</body></methods><methods><class-id>Tools.SelectorBrowserHelper</class-id> <category>list accessing</category><body package="OldBrowsers" selector="definitionOf:">definitionOf: anItem	| target |	target := self selectedClassOrNameSpace.	target == nil ifTrue: [ ^nil ].	^(  self isData or: [ target isForNameSpace ] )		ifTrue: [ BindingReference simpleName: anItem in: target ]		ifFalse: [ MethodDefinition class: target selector: anItem ]</body><body package="OldBrowsers" selector="updateListFull">updateListFull	| protocolList target newList |	protocolList := self protocols.	target := self targetClassOrNameSpace.	(target isNil or: [protocolList isNil or: [protocolList isEmpty]])		ifTrue: [^module setNewList: List new].	newList := (target organization listAtCategoriesNamed: protocolList)		asSortedCollection.	target isForNameSpace		ifTrue: [ newList := newList select: [ :key | ( target bindingFor: key ) isForGeneral ] ].	module setNewList: newList asList</body></methods><methods><class-id>Tools.SelectorBrowserHelper</class-id> <category>text processing</category><body package="OldBrowsers" selector="acceptTextForData:from:">acceptTextForData: text from: textController	^Compiler 		evaluate: text 		notifying: textController 		logged: true</body><body package="OldBrowsers" selector="acceptTextForMethod:from:">acceptTextForMethod: text from: textController	"If more than one protocol is selected, guess the one to use as follows:	if there is a selector selected, put the new method in the same protocol,	else ask the user.  This preserves the protocol of already existing	methods."	| protocol |	self protocols size = 0 ifTrue: 		[protocol := nil].	self protocols size = 1 ifTrue:		[protocol := self protocols first].	self protocols size &gt; 1 ifTrue:		[protocol := self targetClassOrNameSpace organization			categoryOfElement: self selector.		protocol isNil ifTrue:			[protocol := Dialog choose: (#PutMethodInColon &lt;&lt; #dialogs &gt;&gt; 'Put the method in:')					fromList: self protocols					values: self protocols					lines: 8					cancel: [^nil]]].	^self targetClass		compile: text		classified: protocol		notifying: textController.</body></methods><methods><class-id>Tools.SelectorBrowserHelper</class-id> <category>obsolete</category><body package="OldBrowsers" selector="protocol">protocol	"This method was used to return the selected protocol or nil. Now that multiple selection	of protocols is allowed, it is being sunset in favour of #protocols. Ideally, all users of this	method should switch to using #protocols. For now, it is here to prevent things from	breaking but it returns only the first selected protocol."	| protocols |	protocols := self protocols.	^protocols isEmpty 		ifTrue: [nil]		ifFalse: [protocols first]</body></methods><methods><class-id>Tools.ParcelSelectorBrowserHelper</class-id> <category>parcel actions</category><body package="OldBrowsers" selector="addSelectionToParcel">addSelectionToParcel	| target |	self changeRequest ifFalse: [^self].	self browser saveParcelsForUndo.	target := self targetClassOrNameSpace.	target isForNameSpace		ifTrue: [ self selectedParcel addName: self selection in: target ]		ifFalse: [ self selectedParcel	addSelector: self selection forClass: target ].	self browser updateLists</body><body package="OldBrowsers" selector="moveSelectionToParcel:">moveSelectionToParcel: aParcel	| target |	self changeRequest ifFalse: [^self].	target := self targetClassOrNameSpace.	self browser saveParcelsForUndo.	target isForNameSpace		ifTrue: 			[ self browser 				moveData: ( IdentitySet with: self selection )				inNameSpace: target				fromParcel: self  selectedParcel 				toParcel: aParcel			]		ifFalse:			[ self browser				moveSelectors: ( IdentitySet with: self selection )				inClass: target				fromParcel: self  selectedParcel 				toParcel: aParcel			].	self browser updateLists</body><body package="OldBrowsers" selector="removeSelectionConflictsFromParcel">removeSelectionConflictsFromParcel	self unimplemented</body><body package="OldBrowsers" selector="removeSelectionFromParcel">removeSelectionFromParcel	| target |	self changeRequest ifFalse: [^self].	self browser saveParcelsForUndo.	target := self targetClassOrNameSpace.	target isForNameSpace		ifTrue: [ self selectedParcel removeName: self selection in: target ]		ifFalse: [ self selectedParcel	removeSelector: self selection forClass: target ].	self browser updateLists</body></methods><methods><class-id>Tools.ParcelSelectorBrowserHelper</class-id> <category>menus accessing</category><body package="OldBrowsers" selector="getListMenu:">getListMenu: forMenuBar	| selector parcels cl menu |	selector := self selection.	cl := self targetClass.		"nil if namespace selected."	menu := super getListMenu: forMenuBar.	^self browser		addParceling: 			(selector isNil				ifTrue: [#()]				ifFalse:					[nil ~~ (parcels := self browser manager parcelsForClassOrNameSpace: cl) ifTrue:						[(self definitionOf: selector) isBindingReference							ifTrue: [parcels select: [:p| p definesName: selector in: cl]]							ifFalse: [parcels select: [:p| p definesSelector: selector forClass: cl]]]])		to: menu		forHelper: self</body></methods><methods><class-id>Tools.ParcelSelectorBrowserHelper</class-id> <category>text processing</category><body package="OldBrowsers" selector="acceptText:from:">acceptText: text from: textController	"Override to add prompt for parcel membership, and	 retention of old method in parcel overrides."	| currentParcel theClass previousSelector result selector dialog spec aBuilder addSelector addOverride extent over |	currentParcel := self selectedParcel.	"below, answers nil if namespace. doesn't handle statics."	(theClass := self targetClass) isNil ifTrue: [^nil].	(currentParcel notNil	and: [(currentParcel definesClass: theClass) not	and: [(previousSelector := self selection) notNil]]) ifTrue:		[ over := Override forSelector: self selection class: theClass ].	result := super acceptText: text from: textController.	result ~~ true ifTrue: [^result].	selector := self selection.	selector isNil ifTrue:[^true ].	(currentParcel isNil	or: [currentParcel definesSelector: selector forClass: theClass]) ifTrue: [^true].	(over isNil	or: [previousSelector ~= selector]) ifTrue:		[(Dialog confirm: ((#Add1sToParcel &lt;&lt; #dialogs &gt;&gt; 'Add &lt;1s&gt; to parcel?') expandMacrosWith: selector)) ifTrue:			[self addSelectionToParcel].		^true].	dialog := SimpleDialog new.	spec := (dialog class interfaceSpecFor: #emptySpec).	aBuilder := dialog builder.	dialog initializeBuilderFor: self browser builder window.	aBuilder add: spec window.	aBuilder add: spec component.	dialog initializeWindowFor: self browser builder window.	dialog setInitialGap.	dialog		addMessage: ((#Add1sToParcel &lt;&lt; #dialogs &gt;&gt; 'Add &lt;1s&gt; to parcel?') expandMacrosWith: selector)		centered: true. 	dialog addGap: 4.	dialog		addCheckLabels: (Array with: (#addToParcel &lt;&lt; #dialogs &gt;&gt; 'add to parcel') with: (#overrideMove &lt;&lt; #dialogs &gt;&gt; 'move old version to overridden'))		values: (Array					with: (addSelector := true asValue)					with: (addOverride := over notNil asValue))		equalize: true		columns: 1.	dialog addDivider.	dialog addOK: [true].	dialog preOpen.	extent := aBuilder window displayBox extent.	aBuilder window maximumSize: extent.	aBuilder window minimumSize: extent.	aBuilder openDialogWithExtent: extent.	dialog cancel value ifTrue: [^true].	addSelector value ifTrue:		[self addSelectionToParcel.		(over notNil and: [addOverride value]) 			ifTrue: [ Override installMethodOverride: over ].		].	^true</body></methods><methods><class-id>Tools.ParcelSelectorBrowserHelper</class-id> <category>emphasis</category><body package="OldBrowsers" selector="textEmphasisForItem:">textEmphasisForItem: anItem	| target |	target := self selectedClassOrNameSpace.	target == nil ifTrue: [ ^#( norm ) ].	^( ( self isData or: [ target isForNameSpace ] )			ifTrue:				[ self emphasizer 					emphasisForStaticKey: anItem					for: self browser 					id: self selectionId				]			ifFalse: 				[ self emphasizer 					emphasisForSelector: anItem					for: self browser 					id: self selectionId				]			)</body></methods><methods><class-id>Tools.ParcelSelectorBrowserHelper</class-id> <category>accessing</category><body package="OldBrowsers" selector="selector">selector	^self selection</body></methods><methods><class-id>Tools.ParcelSelectorBrowserHelper</class-id> <category>actions</category><body package="OldBrowsers" selector="remove">remove	"Override to ensure the parcel forgets the selector if removed."	| removed parcel |	(removed := super remove) ifTrue:		[(parcel := self selectedParcel) notNil ifTrue: [parcel cleanse]].	^removed</body></methods><methods><class-id>Tools.MethodListBrowserHelper</class-id> <category>initialize</category><body package="OldBrowsers" selector="baseList:">baseList: aList	baseList := aList</body><body package="OldBrowsers" selector="initialSelection:">initialSelection: aString	initialSelection := aString</body><body package="OldBrowsers" selector="label:">label: aLabel	label := aLabel</body></methods><methods><class-id>Tools.MethodListBrowserHelper</class-id> <category>accessing</category><body package="OldBrowsers" selector="windowLabel">windowLabel	^label == nil		ifTrue: [(#Methods &lt;&lt; #dialogs &gt;&gt; 'Methods')]		ifFalse: [label]</body></methods><methods><class-id>Tools.MethodListBrowserHelper</class-id> <category>list accessing</category><body package="OldBrowsers" selector="definitionOf:">definitionOf: anItem	^anItem</body><body package="OldBrowsers" selector="updateListFull">updateListFull	baseList := baseList select: [:md | md isBindingReference ifTrue:[true] ifFalse:[md method notNil]].	module setNewList: (List withAll: baseList)</body></methods><methods><class-id>Tools.MethodListBrowserHelper</class-id> <category>private</category><body package="OldBrowsers" selector="initialSelection">initialSelection	^initialSelection</body></methods><methods><class-id>Tools.MethodListBrowserHelper</class-id> <category>actions</category><body package="OldBrowsers" selector="remove">remove	"Override to remember the nearest selection"	| indices listSize max min choice result |	indices := module listSelectionIndexes.	listSize := module list list size.	(indices isEmpty	or: [indices size = listSize]) ifTrue: [^super remove].	indices := indices asSortedCollection.	min := indices first.	max := indices last.	choice := max - min + 1 &gt; indices size "must be an interior unselected element, use the first one as the next selection"				ifTrue:					[| priorEntries interior |					 priorEntries := 0. "Count of how many selections before the first interior unselected element"					 interior := (min to: max) detect: [:n| priorEntries := priorEntries + 1. (indices at: n - min + 1) ~= n].					interior - priorEntries]				ifFalse:					[max &lt; listSize						ifTrue: [min] "after removals min is the index of the entry after last selection"						ifFalse: [min - 1]]. "no entries after last; choose one before first removal"	(result := super remove) ifTrue:		[module listSelectionIndexes: (Set with: choice)].	^result</body></methods><methods><class-id>Tools.MethodListBrowserHelper</class-id> <category>selections</category><body package="OldBrowsers" selector="targetClass">targetClass	"Answer the browsers currently selected class."	^self selection implementingClass</body><body package="OldBrowsers" selector="targetClassOrNameSpace">targetClassOrNameSpace	"Answer the browsers currently selected class, namespace or classes namespace."	^self selection isBindingReference		ifTrue: [ self selection environment asNameSpace ]		ifFalse: [ self targetClass ]</body></methods><methods><class-id>Tools.BrowserTabApplication</class-id> <category>components</category><body package="OldBrowsers" selector="windowLabel">windowLabel	^components isEmpty		ifTrue: [(#FullBrowser &lt;&lt; #labels &gt;&gt; 'Full Browser')]		ifFalse: [components first windowLabel]</body></methods><methods><class-id>Tools.BrowserTabApplication</class-id> <category>accessing subcanvases</category><body package="OldBrowsers" selector="getCanvas">getCanvas	self subclassResponsibility</body></methods><methods><class-id>Tools.BrowserTabApplication</class-id> <category>release</category><body package="OldBrowsers" selector="release">release		canvas == nil		ifFalse: [ self canvas release ].	self components do:[:each | each release].</body></methods><methods><class-id>Tools.BrowserTabApplication</class-id> <category>initialize</category><body package="OldBrowsers" selector="initialize">initialize	self buildComponentArray.</body><body package="OldBrowsers" selector="initializeForClass:">initializeForClass: aClass	self subclassResponsibility</body><body package="OldBrowsers" selector="initializeForClassHierarchy:">initializeForClassHierarchy: aClass	self subclassResponsibility</body><body package="OldBrowsers" selector="initializeForMethodsLabel:list:initialSelection:">initializeForMethodsLabel: labelString list: aCollection initialSelection: selector	self subclassResponsibility</body><body package="OldBrowsers" selector="initializeForNameSpace:">initializeForNameSpace: aNameSpace	self subclassResponsibility</body><body package="OldBrowsers" selector="initializeForNameSpaces">initializeForNameSpaces	self subclassResponsibility</body><body package="OldBrowsers" selector="initializeForNameSpaces:category:">initializeForNameSpaces: aNameSpace category: aCategory	self subclassResponsibility</body><body package="OldBrowsers" selector="initializeNull">initializeNull	components := #() copy</body></methods><methods><class-id>Tools.BrowserTabApplication</class-id> <category>componentBuilding</category><body package="OldBrowsers" selector="buildComponentArray">buildComponentArray	self buildComponentList.	self setComponentIds: components.	self linkComponentsInArray: components.	self linkFirstComponentToSubcanvas.</body><body package="OldBrowsers" selector="buildComponentList">buildComponentList	components := List new.	components add: self categoriesComponent.	components add:  self classesComponent.	components add: self protocolsComponent.	components add: self selectorsComponent.</body><body package="OldBrowsers" selector="categoriesComponent">categoriesComponent	self subclassResponsibility</body><body package="OldBrowsers" selector="classesComponent">classesComponent	self subclassResponsibility</body><body package="OldBrowsers" selector="componentId">componentId	^#default</body><body package="OldBrowsers" selector="protocolsComponent">protocolsComponent	self subclassResponsibility</body><body package="OldBrowsers" selector="selectorsComponent">selectorsComponent	self subclassResponsibility</body><body package="OldBrowsers" selector="setComponentIds">setComponentIds	components do:		[ :comp | comp helpers do: [ :h | h selectionId: self componentId ] ]</body><body package="OldBrowsers" selector="setComponentIds:">setComponentIds: aComponentList	aComponentList do:		[ :comp | comp helpers do: [ :h | h selectionId: self componentId ] ]</body></methods><methods><class-id>Tools.BrowserTabApplication</class-id> <category>menus</category><body package="OldBrowsers" selector="buildToolBar:">buildToolBar: aMenu	canvas buildToolBar: aMenu.	self components do:		[ :comp | comp buildToolBar: aMenu ]</body><body package="OldBrowsers" selector="buildViewMenu:">buildViewMenu: aMenu	canvas buildViewMenu: aMenu.	self components do:		[ :comp | comp buildViewMenu: aMenu ]</body></methods><methods><class-id>Tools.BrowserTabApplication</class-id> <category>spawning</category><body package="OldBrowsers" selector="spawnForMethodsLabel:list:initialSelection:with:">spawnForMethodsLabel: aLabel list: list initialSelection: selection with: aTabApplication 	TabApplicationSystemBrowser initializeForMethodsLabel: aLabel list: list initialSelection: selection with: NamespaceTabApplication</body><body package="OldBrowsers" selector="spawnOnClass:with:">spawnOnClass: aClass with: aTabApplication 	TabApplicationSystemBrowser openOnClass: aClass with: NamespaceTabApplication</body><body package="OldBrowsers" selector="spawnOnClass:with:protocol:">spawnOnClass: aClass with: aTabApplication protocol: aSelection	TabApplicationSystemBrowser openOnClass: aClass with: NamespaceTabApplication protocol: aSelection</body><body package="OldBrowsers" selector="spawnOnClassHierarchy:">spawnOnClassHierarchy: aClass 	TabApplicationSystemBrowser openOnClassHierarchy: aClass with: NamespaceTabApplication</body><body package="OldBrowsers" selector="spawnOnClassHierarchy:with:">spawnOnClassHierarchy: aClass with: aTabApplication 	TabApplicationSystemBrowser openOnClassHierarchy: aClass with: NamespaceTabApplication</body><body package="OldBrowsers" selector="spawnOnNameSpace:with:">spawnOnNameSpace: aNamespace with: aTabApplication 	TabApplicationSystemBrowser 		openOnNameSpace: aNamespace 		with: NamespaceTabApplication</body><body package="OldBrowsers" selector="spawnOnNameSpace:with:category:">spawnOnNameSpace: aNamespace with: aTabApplication category: aCategory 	TabApplicationSystemBrowser		openOnNameSpace: aNamespace		with: NamespaceTabApplication		on: aCategory</body></methods><methods><class-id>Tools.BrowserTabApplication</class-id> <category>private</category><body package="OldBrowsers" selector="eraseBackgroundOnImage:">eraseBackgroundOnImage: anImage	| pix im2   imageMask sourceImage |"inactiveMasks  := masks  := nil.""	rule		result 		0			0 	1			D bitAnd: S 	2			D bitInvert bitAnd: S 	3			S 	4			D bitAnd: S bitInvert 	5			D 	6			D bitXor: S 	7			D bitOr: S 	8			D bitInvert bitAnd: S bitInvert 	9			D bitXor: S bitInvert  &lt;----- This is the rule we use to get the resulting interiror figure 	10			D bitInvert 	11			D bitInvert bitOr: S 	12			S bitInvert 	13			D bitOr: S bitInvert 	14			D bitInvert bitOr: S bitInvert 	15			1 "	imageMask := nil.	"	imageMask := self masks at: anImage hash ifAbsent: [nil]." " we have precomputed masks so we don't have to do this all the time"	"The mask is in the shape of the figure so the rest can be the back ground color" 	imageMask == nil		ifTrue:			[sourceImage := anImage asImage.			pix := sourceImage atPoint: 0@0. "Take the Pixel at 0@0 as the one you want to be the background sourounding the figure" 			imageMask := Image extent: sourceImage extent depth: 1 palette: CoveragePalette monoMaskPalette.			"find and write the interiror shape"			0 to: sourceImage width-1 do: [:x |				0 to: sourceImage height-1 do: [:y |					(sourceImage atPoint: x@y) = pix						ifFalse: [imageMask atPoint: x@y put: 1]]].			"get the exteriror mess"			im2 := imageMask filledShapeAround: 0@0.			"now combine the two according to rule 9 the D bitXor: S bitInvert"			imageMask copy: imageMask bounds from: 0@0 in: im2 rule: 9.			imageMask := CachedImage on: imageMask.			"self masks at: anImage hash put: imageMask"]."	self inactiveMasks at: anImage hash	ifAbsent: 			[self inactiveMasks at: anImage hash					put: (self masks at: anImage hash)]."	"Return the neat class the knows how to display himself with the background left untouched according to the mask we just built"	"^OpaqueImageWithEnablement figure: anImage shape: imageMask 				inactiveMask: (self inactiveMasks at: anImage hash)."^OpaqueImageWithEnablement figure: anImage shape: imageMask 				inactiveMask: (imageMask).</body><body package="OldBrowsers" selector="linkComponentsInArray:">linkComponentsInArray: aCollection 	1 to: aCollection size - 1 do: [:i | (aCollection at: i)			browser: self browser;			nextModule: (aCollection at: i + 1)].	aCollection last browser: self browser.	self browser currentTabApplication: self. 	aCollection first intializeListFull</body><body package="OldBrowsers" selector="linkFirstComponentToSubcanvas">linkFirstComponentToSubcanvas	self canvas browser: self browser.	self canvas nextModule: self components first."	self canvas updateList."</body></methods><methods><class-id>Tools.BrowserTabApplication</class-id> <category>accessing</category><body package="OldBrowsers" selector="blankCategoryCanvas">blankCategoryCanvas	^blankCategoryCanvas isNil ifTrue:[blankCategoryCanvas := BlankUI new] ifFalse:[blankCategoryCanvas ]</body><body package="OldBrowsers" selector="browser">browser	^browser</body><body package="OldBrowsers" selector="browser:">browser: aBrowser	browser := aBrowser</body><body package="OldBrowsers" selector="canvas">canvas	^canvas isNil ifTrue:[canvas := self getCanvas] ifFalse:[canvas]</body><body package="OldBrowsers" selector="categoriesLabel">categoriesLabel	^(#NoCategories &lt;&lt; #labels &gt;&gt; 'No Categories')</body><body package="OldBrowsers" selector="categoryIcon">categoryIcon	^categoryIcon isNil ifTrue:[ categoryIcon := self eraseBackgroundOnImage: self class categoryIcon] ifFalse:[categoryIcon ]</body><body package="OldBrowsers" selector="components">components	components == nil 		ifTrue:[ self buildComponentArray ].	^components</body><body package="OldBrowsers" selector="defaultEmphasizer">defaultEmphasizer	^Emphasizer new.</body><body package="OldBrowsers" selector="emphasizer">emphasizer	emphasizer == nil ifTrue:		[emphasizer := self defaultEmphasizer].	^emphasizer</body><body package="OldBrowsers" selector="emphasizer:">emphasizer: anEmphasizer	emphasizer := anEmphasizer</body><body package="OldBrowsers" selector="icon">icon	^icon isNil ifTrue:[ icon := self class blankIcon] ifFalse:[icon ]</body><body package="OldBrowsers" selector="indexOfCategoryCanvas">indexOfCategoryCanvas	" I am defauling this to 0 so teamworks code will run on entry. 0 means there is no categories component"	^indexOfCategoryCanvas isNil ifTrue:[ indexOfCategoryCanvas := 0] ifFalse:[indexOfCategoryCanvas ]</body><body package="OldBrowsers" selector="indexOfCategoryCanvas:">indexOfCategoryCanvas: aNumber	"index in the compnents array of the categories subcanvas"	indexOfCategoryCanvas:= aNumber</body><body package="OldBrowsers" selector="label">label	^self class label</body><body package="OldBrowsers" selector="rightHandComponents">rightHandComponents	^components copyFrom: 2 to: components size</body><body package="OldBrowsers" selector="subCanvasSpec">subCanvasSpec	^canvas listSpec"^#listSpec"</body><body package="OldBrowsers" selector="systemBrowserComponents">systemBrowserComponents	^self components</body></methods><methods><class-id>Tools.BrowserTabApplication</class-id> <category>updating</category><body package="OldBrowsers" selector="intializeListFull">intializeListFull	self canvas intializeListFull.	^self</body><body package="OldBrowsers" selector="refreshLists">refreshLists</body><body package="OldBrowsers" selector="swapIn">swapIn</body><body package="OldBrowsers" selector="swapOut">swapOut</body><body package="OldBrowsers" selector="updateList">updateList	self canvas updateList</body></methods><methods><class-id>Tools.BrowserTabApplication</class-id> <category>canvases</category><body package="OldBrowsers" selector="categoryTabCanvas">categoryTabCanvas	"By default this is blank. if a subclass has a categories view then they nee to supply one with this by setting indexOfCategoryCanvas"	^self indexOfCategoryCanvas == 0 ifTrue:[self blankCategoryCanvas ] ifFalse:[components at: self indexOfCategoryCanvas ]</body></methods><methods><class-id>Tools.BrowserTabApplication</class-id> <category>testing</category><body package="OldBrowsers" selector="isNamspaceTabApp">isNamspaceTabApp	^false</body></methods><methods><class-id>Tools.BrowserTabApplication</class-id> <category>selection utlity</category><body package="OldBrowsers" selector="selectBehavior:">selectBehavior: aBehavior 	(self components at: components size - 2) currentHelper selectBehavior: aBehavior</body><body package="OldBrowsers" selector="selectCategory:">selectCategory: aCategory 	(self components at: components size - 3) currentHelper selectCategory: aCategory</body><body package="OldBrowsers" selector="selectMethod:">selectMethod: aSymbol 	(self components at: components size) currentHelper selectMethod: aSymbol</body><body package="OldBrowsers" selector="selectProtocol:">selectProtocol: aProtocol 	(self components at: components size - 1) currentHelper selectProtocol: aProtocol</body></methods><methods><class-id>Tools.BrowserTabApplication class</class-id> <category>instance creation</category><body package="OldBrowsers" selector="basicNewOnBrowser:">basicNewOnBrowser: aBrowser	| inst |	inst := self basicNew.	inst browser: aBrowser.	inst initializeNull.	^inst</body><body package="OldBrowsers" selector="newOnBrowser:">newOnBrowser: aBrowser	| inst |	inst := self basicNew.	inst browser: aBrowser.	inst initialize.	^inst</body></methods><methods><class-id>Tools.BrowserTabApplication class</class-id> <category>accessing</category><body package="OldBrowsers" selector="label">label	self subclassResponsibility</body></methods><methods><class-id>Tools.NamespaceTabApplication</class-id> <category>componentBuilding</category><body package="OldBrowsers" selector="allCategoriesComponent">allCategoriesComponent	^SimpleBrowserModule new		helpers: (Array with: (NameSpaceOrganizerBrowserHelper new searchChildNamespaces: true) ).</body><body package="OldBrowsers" selector="allClassesComponent">allClassesComponent	^SimpleBrowserModule new 		helperType: NameSpaceGlobalCategoryBrowserHelper;		yourself</body><body package="OldBrowsers" selector="buildComponentArray">buildComponentArray	super buildComponentArray.	self indexOfCategoryCanvas: 1.</body><body package="OldBrowsers" selector="categoriesComponent">categoriesComponent	^SimpleBrowserModule new		helperType: NameSpaceOrganizerBrowserHelper.</body><body package="OldBrowsers" selector="classesComponent">classesComponent	^SimpleBrowserModule new 		helperType: NameSpaceCategoryBrowserHelper</body><body package="OldBrowsers" selector="classHierarchyComponent">classHierarchyComponent	^SimpleBrowserModule new		helperType: ClassHierarchyBrowserHelper;		yourself</body><body package="OldBrowsers" selector="componentId">componentId	^#NameSpaceTab</body><body package="OldBrowsers" selector="protocolsComponent">protocolsComponent	^SimpleBrowserModule new		specName: #listSpecProtocols;		helperType: ProtocolBrowserHelper.</body><body package="OldBrowsers" selector="selectorsComponent">selectorsComponent	^SimpleBrowserModule new		helperType: SelectorBrowserHelper</body></methods><methods><class-id>Tools.NamespaceTabApplication</class-id> <category>accessing subcanvases</category><body package="OldBrowsers" selector="getCanvas">getCanvas	| module |	module := self namespaceHierachyComponent.						 module	browser: self browser.	^module</body><body package="OldBrowsers" selector="namespaceHierachyComponent">namespaceHierachyComponent	^HierarchicalBrowserModule new		helperType: NameSpaceHierarchyBrowserHelper</body></methods><methods><class-id>Tools.NamespaceTabApplication</class-id> <category>accessing</category><body package="OldBrowsers" selector="categoriesLabel">categoriesLabel	^self browser selectedEnvironment notNil		ifTrue: [self categoryTabCanvas selection notNil				ifTrue: [self categoryTabCanvas selection]				ifFalse: [((#x1sCategories &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; Categories')			expandMacrosWith: self browser selectedEnvironment name asString)]]		ifFalse: [(#Categories &lt;&lt; #labels &gt;&gt; 'Categories') asString]</body><body package="OldBrowsers" selector="icon">icon	^icon isNil ifTrue:[ icon := self eraseBackgroundOnImage: (self class folderIcon)] ifFalse:[icon ]</body><body package="OldBrowsers" selector="label">label	^self browser selectedEnvironment notNil		ifTrue: [((#x1sNameSpace &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; NameSpace')			expandMacrosWith: self browser selectedEnvironment name asString)]		ifFalse: [self class label]</body></methods><methods><class-id>Tools.NamespaceTabApplication</class-id> <category>testing</category><body package="OldBrowsers" selector="isNamspaceTabApp">isNamspaceTabApp	^true</body></methods><methods><class-id>Tools.NamespaceTabApplication</class-id> <category>initialize</category><body package="OldBrowsers" selector="initializeForAllNameSpaces">initializeForAllNameSpaces	self	browser setNameSpaceFor: #default to: Root.	components := List new.	components add: self allCategoriesComponent.	components add: self allClassesComponent.	components add: self protocolsComponent.	components add: self selectorsComponent.	self linkComponentsInArray: components.	self browser updateLists</body><body package="OldBrowsers" selector="initializeForClass:">initializeForClass: aClass	self	browser setNameSpaceFor: #default to: aClass environment.	self browser meta value: (aClass isMeta ifTrue: [#class] ifFalse: [#instance]).	components := List new.	components add: self classesComponent.	components add: self protocolsComponent.	components add: self selectorsComponent.	self  browser setClassOrNameSpaceFor: #default to: aClass.	self linkComponentsInArray: components.	self linkFirstComponentToSubcanvas.	components first		forceSelection: aClass;		updateList</body><body package="OldBrowsers" selector="initializeForClass:protocol:">initializeForClass: aClass protocol: aProtocol	self	browser setNameSpaceFor: #default to: aClass environment.	self browser meta value: (aClass isMeta ifTrue: [#class] ifFalse: [#instance]).	components := List new.	components add: self protocolsComponent.	components add: self selectorsComponent.	self  browser setClassOrNameSpaceFor: #default to: aClass.	self	browser setProtocolFor: #default to: aProtocol.	self linkComponentsInArray: components.	self linkFirstComponentToSubcanvas.	components first		forceSelection: aProtocol;		updateList</body><body package="OldBrowsers" selector="initializeForClassHierarchy:">initializeForClassHierarchy: aClass	| cls |	self	browser setNameSpaceFor: #default to: aClass environment.	self browser meta value: (aClass isMeta ifTrue: [#class] ifFalse: [#instance]).	cls := aClass instanceBehavior.	self browser	setClassOrNameSpaceFor: #default to: aClass.	components := List new.	components add: self classHierarchyComponent.	components add: self protocolsComponent.	components add: self selectorsComponent.	self linkComponentsInArray: components.		self browser updateLists.	"self linkFirstComponentToSubcanvas."	components first		selection: cls;		updateList.</body><body package="OldBrowsers" selector="initializeForMethodsLabel:list:initialSelection:">initializeForMethodsLabel: labelString list: aCollection initialSelection: selector	| helper module |	helper := MethodListBrowserHelper new.	helper		label: labelString;		baseList: aCollection;		initialSelection: selector.	module := SimpleBrowserModule new			helpers: (Array with: helper).	components := List new.	components add: module.self linkComponentsInArray: components.	self linkFirstComponentToSubcanvas.		self browser updateLists.</body><body package="OldBrowsers" selector="initializeForNameSpace:">initializeForNameSpace: aNameSpace	components := List new.	self browser	setNameSpaceFor: #default to: aNameSpace.	components add: self categoriesComponent.	components add: self classesComponent.	components add: self protocolsComponent.	components add: self selectorsComponent.	self linkComponentsInArray: components.	self browser updateLists</body><body package="OldBrowsers" selector="initializeForNameSpaces">initializeForNameSpaces	self browser	setNameSpaceFor: #default to: nil.	components := List new.	components add: self categoriesComponent.	components add: self classesComponent.	components add: self protocolsComponent.	components add: self selectorsComponent.	self linkComponentsInArray: components.	self browser updateLists</body><body package="OldBrowsers" selector="initializeForNameSpaces:category:">initializeForNameSpaces: aNameSpace category: aCategory		components := List new.	components add: self categoriesComponent.	components add: self classesComponent.	components add: self protocolsComponent.	components add: self selectorsComponent.	self browser	setNameSpaceFor: #default to: aNameSpace.	self browser setCategoryFor: #default to: aCategory.	self linkComponentsInArray: components.	self browser updateLists	components first		forceSelection: aCategory;		updateList</body></methods><methods><class-id>Tools.NamespaceTabApplication class</class-id> <category>accessing</category><body package="OldBrowsers" selector="label">label	^(#NameSpaces &lt;&lt; #labels &gt;&gt; 'NameSpaces') asString</body></methods><methods><class-id>Tools.ParcelTabApplication</class-id> <category>menus</category><body package="OldBrowsers" selector="addParceling:to:forHelper:">addParceling: parcelSet to: aMenu forHelper: aBrowserHelper 	^self class		addParceling: parcelSet		to: aMenu		forHelper: aBrowserHelper</body></methods><methods><class-id>Tools.ParcelTabApplication</class-id> <category>parcel Specific accessing </category><body package="OldBrowsers" selector="behaviorStatus:currentParcel:">behaviorStatus: aBehavior currentParcel: aParcel	"Compute the status for a Behavior (class or metaclass)."	| parcels status definedCount extendedCount |	status := Set new: 4.	aBehavior isNil ifTrue: [^status "shouldn't happen"].	parcels := self manager parcelsForClassOrNameSpace: aBehavior.	nil == parcels ifFalse:		[definedCount := extendedCount := 0.		parcels do:			[:parcel|			(parcel definesClass: aBehavior) ifTrue:				[definedCount := definedCount + 1.				status add: (parcel == aParcel ifTrue: [#defined] ifFalse: [#definedByOther]).				(parcel == aParcel				and: [| defined selectors |					"This is a performance-critical piece of code since it dominates					 computing category emphases for categories that are entirely					 defined by a Parcel.  Hence there is some effort to optimize					 the comparison of defined and implemented selectors."					defined := parcel definedSelectorsFor: aBehavior.					selectors := aBehavior organization elements.					defined size = selectors size					and: [nil == (selectors detect: [:sel| (defined includes: sel) not] ifNone: [])]]) ifTrue:						[status add: #entirelyDefined]].			(parcel extendsBehavior: aBehavior) ifTrue:				[extendedCount := extendedCount + 1.				status add: (parcel == aParcel ifTrue: [#extended] ifFalse: [#extendedByOther])]].			(definedCount &gt; 1 "more than one parcel defines the behavior"			or: [definedCount + extendedCount &gt; 1 "may be multiply parcelled selectors - go check"				and: [(self computeConflictsFor: (Array with: aBehavior) within: nil) first size &gt; 0]])				ifTrue:					[status add: #conflict]].	^status</body><body package="OldBrowsers" selector="classDataStatus:currentParcel:">classDataStatus: aClass  currentParcel: aParcel	"Compute the status for a Class's static variables."	| parcels status definedCount names |	status := Set new: 4.	aClass isNil ifTrue: [^status "shouldn't happen"].	names := aClass asNameSpace localBindingNames.	names isEmpty ifTrue:		[(aParcel ~~ nil		   and: [aParcel definesClass: aClass])			ifTrue: [status add: #entirelyDefined].		^status].	parcels := manager parcelsForClassOrNameSpace: aClass.	nil == parcels ifTrue: [^status].	definedCount := 0.	parcels do:		[:parcel| | defined |		(defined := parcel definedNamesFor: aClass) size &gt; 0 ifTrue:			[definedCount := definedCount + 1.			parcel == aParcel				ifTrue:					["This is a performance-critical piece of code since it dominates					 computing category emphases for categories that are entirely					 defined by a Parcel.  Hence there is some effort to optimize					 the comparison of defined and implemented names."					status add: (((parcel definesClass: aClass)								and: [defined size = names size								and: [nil == (names detect: [:name| (defined includes: name) not] ifNone: nil)]])									ifTrue: [#entirelyDefined]									ifFalse: [#defined])]				ifFalse: [status add: #extendedByOther]].	(definedCount &gt; 1 "more than one parcel defines data in aClass"	and: [(self computeDataConflictsFor: (Array with: aClass) within: nil) first size &gt; 0])		ifTrue:			[status add: #conflict]].	^status</body><body package="OldBrowsers" selector="classNameStatus:environment:currentParcel:">classNameStatus: aClass environment: environment currentParcel: aParcel	"Compute the status for a class name (class and its metaclass)."	| classStatus metaclassStatus entirelyDefined |	aClass isBehavior ifFalse: [^self definedThingStatus: aClass  currentParcel: aParcel].	classStatus := self behaviorStatus: aClass currentParcel: aParcel.	metaclassStatus := self behaviorStatus: aClass class currentParcel: aParcel.	entirelyDefined := (classStatus includes: #entirelyDefined)							and: [metaclassStatus includes: #entirelyDefined].	classStatus addAll: metaclassStatus.	entirelyDefined ifFalse: [classStatus remove: #entirelyDefined ifAbsent: nil].	^classStatus</body><body package="OldBrowsers" selector="classNameStatusOLD:environment:currentParcel:">classNameStatusOLD: aBindingReferenceOrSymbol environment: environment currentParcel: aParcel	"Compute the status for a class name (class and its metaclass)."	| aClass classStatus metaclassStatus entirelyDefined binding |	binding := aBindingReferenceOrSymbol isSymbol ifTrue:[ environment bindingFor: aBindingReferenceOrSymbol ]  ifFalse: [aBindingReferenceOrSymbol bindingOrNil].	binding == nil ifTrue: [^Set with: #notFound].	aClass := binding value.	binding isForClass ifFalse: [^self definedThingStatus: aClass  currentParcel: aParcel].	classStatus := self behaviorStatus: aClass currentParcel: aParcel.	metaclassStatus := self behaviorStatus: aClass class currentParcel: aParcel.	entirelyDefined := (classStatus includes: #entirelyDefined)							and: [metaclassStatus includes: #entirelyDefined].	classStatus addAll: metaclassStatus.	entirelyDefined ifFalse: [classStatus remove: #entirelyDefined ifAbsent: nil].	^classStatus</body><body package="OldBrowsers" selector="currentParcel">currentParcel	^self canvas currentParcel</body><body package="OldBrowsers" selector="currentParcelsFor:currentParcel:">currentParcelsFor: aClass currentParcel: aParcel	"Answer the current set of relevant parcels.  If the currentParcel is selected	 then this is simply the set containing the currentParcel.  Otherwise it is the	 set of parcels that define or extend aClass."	| parcels |	^aParcel isNil		ifTrue:			[(parcels := self manager parcelsForClassOrNameSpace: aClass) isNil				ifTrue: [IdentitySet new]				ifFalse: [parcels]]		ifFalse: [IdentitySet with: aParcel]</body><body package="OldBrowsers" selector="dataKeyStatus:class:currentParcel:">dataKeyStatus: aKey class: aClass currentParcel: aParcel	"Compute the status for a data key in a given class/namespace with respect to 	the parcels in manager and aParcelOrNil."	| status parcels count |	status := Set new: 4.	(nil == aClass or: [nil == aKey]) ifTrue: [^status].	nil == (parcels := manager parcelsForClassOrNameSpace: aClass) ifFalse:		[count := 0.		parcels do:			[:p|			(p definesName: aKey in: aClass) ifTrue:				[count := count + 1.				status add: (aParcel == p ifTrue: [#defined] ifFalse: [#definedByOther])]].		count &gt; 1 ifTrue: [status add: #conflict]].	^status</body><body package="OldBrowsers" selector="dataProtocolStatus:class:currentParcel:">dataProtocolStatus: aSymbol class: aClass currentParcel: aParcel	"Compute the status for a data protocol in a class."	| thingsInProtocol status parcels |	status := Set new: 4.	nil == aClass ifTrue: [^status].	thingsInProtocol := aClass asNameSpace organization listAtCategoryNamed: aSymbol.	(thingsInProtocol isEmpty	or: [nil == (parcels := manager parcelsForClassOrNameSpace: aClass)]) ifTrue:		[^status].	"Assume entirely defined; search for exceptions in the loop below."	(aParcel notNil	and: [parcels includes: aParcel]) ifTrue:		[status add: #entirelyDefined].	thingsInProtocol do:		[:aThing| | count |		count := 0.		parcels do:			[:p|			(p definesName: aThing in: aClass)				ifTrue:					[count := count + 1.					status add: (aParcel == p ifTrue: [#defined] ifFalse: [#definedByOther])]				ifFalse: [aParcel == p ifTrue: [status remove: #entirelyDefined ifAbsent: nil]]].		count &gt; 1 ifTrue: [status add: #conflict]].	^status</body><body package="OldBrowsers" selector="dataStatus:class:currentParcel:">dataStatus: aBinding class: aClass currentParcel: aParcel	"Compute the status for aBinding in a given class with respect to the parcels	 in manager and aParcelOrNil."	^self  dataKeyStatus: aBinding key class: aClass currentParcel: aParcel</body><body package="OldBrowsers" selector="isUnparceledCodeInBehavior:currentParcel:">isUnparceledCodeInBehavior: aBehavior  currentParcel: aParcel	"Answer if there is any unparceled code in aBehavior (either it is undefined	 or contains methods that are undefined) for the currently 'relevant' parcels."	| parcels selectors |	"This also needs to account for unparcelled statics"	aParcel isNil		ifTrue: [parcels := manager parcelsForClassOrNameSpace: aBehavior.				parcels isNil ifTrue: [^true].				parcels := parcels asArray]		ifFalse: [parcels := Array with: aParcel].	parcels do: [:p| (p definesClass: aBehavior) ifFalse: [^true]].	"This is performance critical.  So we unroll the loop and use the class's organization.	 Code should be equivalent to		^class selectors contains: [:sel| parcels contains: [:p| (p definesSelector: sel forClass: class) not]]"	selectors := aBehavior organization elements.	1 to: selectors size do:		[:si| | sel |		sel := selectors at: si.		1 to: parcels size do:			[:pi|			((parcels at: pi) definesSelector: sel forClass: aBehavior) ifFalse: [^true]]].	^false</body><body package="OldBrowsers" selector="isUnparceledCodeInClass:currentParcel:">isUnparceledCodeInClass: aClass  currentParcel: aParcel 	"Answer if there is any unparceled code in aClass (either it is undefined or	 contains methods that are undefined) for the currently 'relevant' parcels."	^(self isUnparceledCodeInBehavior: aClass currentParcel: aParcel)		or: [self isUnparceledCodeInBehavior: aClass class currentParcel: aParcel]</body><body package="OldBrowsers" selector="isUnparceledCodeInNameSpace:">isUnparceledCodeInNameSpace: aNamespace	"This isn't implemented yet."	^false</body><body package="OldBrowsers" selector="manager">manager	^manager</body><body package="OldBrowsers" selector="mapStatusToEmphasis:">mapStatusToEmphasis: statusSet	"Compute the emphasis for aSet.  aSet has the following members		#entirelyDefined		#defined		#definedByOther		#extended		#extendedByOther		#conflict"	| emphasis |	emphasis := Set new: 4.	statusSet do:		[:status|		(#extended == status		or: [#defined == status]) ifTrue: [emphasis add: #bold] ifFalse: [		#entirelyDefined == status ifTrue:			[emphasis add: #bold; add: #underline] ifFalse: [		(#definedByOther == status		or: [#extendedByOther == status]) ifTrue: [emphasis add: #italic] ifFalse: [		#conflict == status ifTrue:			[emphasis add: #color-&gt;ColorValue red] ifFalse: [		#notFound == status ifFalse: [Transcript cr; print: status; endEntry].		emphasis add: #strikeout "as an error indication"]]]]].	^emphasis asArray</body><body package="OldBrowsers" selector="selectorStatus:class:currentParcel:">selectorStatus: aSelector class: aClass  currentParcel: aParcel 	"Compute the status for a selector in a given classwith respect to the parcels	 in manager and aParcelOrNil."	| status parcels count |	status := Set new: 4.	(nil == aClass or: [nil == aSelector]) ifTrue: [^status].	nil == (parcels := manager parcelsForClassOrNameSpace: aClass) ifFalse:		[count := 0.		parcels do:			[:p|			(p definesSelector: aSelector forClass: aClass) ifTrue:				[count := count + 1.				status add: (aParcel == p ifTrue: [#defined] ifFalse: [#definedByOther])]].		count &gt; 1 ifTrue: [status add: #conflict]].	^status</body></methods><methods><class-id>Tools.ParcelTabApplication</class-id> <category>parcel emphassis</category><body package="OldBrowsers" selector="computeConflictsFor:within:">computeConflictsFor: aSetOfClasses within: aSetOfParcelsOrNil	"Answer a triple of a Set of MethodDefinitions identifying all methods that are	 multiply parcelled, a Set of statics that are multiply parcelled, and a Set	 of classes that either contain multiply parcelled methods or are themselves	 multiply parcelled.  If aSetOfParcelsOrNil is non-nil then only include conflicts	 that are parcelled within aSetOfParcels	 Express the triple as an Array, method definitions first, bindings next, classes last."	| methods bindings classes |	methods := Set new: 64.	bindings := IdentitySet new: 8.	classes := IdentitySet new: 4.	aSetOfClasses do:		[:class| | parcels |		(parcels := manager parcelsForClassOrNameSpace: class) notNil ifTrue:			[| instanceSelectorBag classSelectorBag staticBag classBag |			instanceSelectorBag := Bag identityNew: 32.			classSelectorBag := Bag identityNew: 32.			staticBag := Bag identityNew: 4.			classBag := Bag identityNew: 2.			parcels do:				[:parcel|				(parcel definesClass: class) ifTrue: [classBag add: class].				instanceSelectorBag addAll: (parcel definedSelectorsFor: class).				classSelectorBag addAll: (parcel definedSelectorsFor: class class).				staticBag addAll: (parcel definedBindingsFor: class)].			instanceSelectorBag valuesAndCountsDo:				[:sel :count|				(count &gt; 1				and: [aSetOfParcelsOrNil isNil						or: [aSetOfParcelsOrNil contains: [:parcel| parcel definesSelector: sel forClass: class]]])					ifTrue:						[classes add: class.						methods add: (MethodDefinition class: class selector: sel)]].			classSelectorBag valuesAndCountsDo:				[:sel :count|				(count &gt; 1				and: [aSetOfParcelsOrNil isNil						or: [aSetOfParcelsOrNil contains: [:parcel| parcel definesSelector: sel forClass: class class]]])					ifTrue:						[classes add: class.						methods add: (MethodDefinition class: class class selector: sel)]].			classBag valuesAndCountsDo:				[:clss :count|				(count &gt; 1				and: [aSetOfParcelsOrNil isNil						or: [aSetOfParcelsOrNil contains: [:parcel| parcel definesClass: class]]])					ifTrue:						[classes add: class]].			staticBag valuesAndCountsDo:				[:binding :count|				(count &gt; 1				and: [aSetOfParcelsOrNil isNil						or: [aSetOfParcelsOrNil contains: [:parcel| parcel definesClass: class]]])					ifTrue:						[bindings add: binding.						classes add: class]]]].	^Array with: methods with: bindings with: classes</body><body package="OldBrowsers" selector="definedThingStatus:currentParcel:">definedThingStatus: anObject  currentParcel: aParcel	"Compute the status for a Static."	| status definedCount |	status := Set new: 4.	anObject isNil ifTrue: [^status "shouldn't happen"].	definedCount := 0.	manager parcels do:		[:parcel|		(parcel definesObject: anObject) ifTrue:			[definedCount := definedCount + 1.			status add: (parcel == aParcel ifTrue: [#defined] ifFalse: [#definedByOther]).			(parcel == aParcel) ifTrue:				[status add: #entirelyDefined]]].	(definedCount &gt; 1 "more than one parcel defines the behavior") ifTrue:		[status add: #conflict].	^status</body></methods><methods><class-id>Tools.ParcelTabApplication</class-id> <category>parcel actions</category><body package="OldBrowsers" selector="moveSelectionToParcel:">moveSelectionToParcel: aParcel	self changeRequest ifFalse: [^self].	self 		saveParcelsForUndo;		moveSelectors: ( IdentitySet with: self selection )			inClass: self targetClass			fromParcel: self  selectedParcel 			toParcel: aParcel;		updateLists</body><body package="OldBrowsers" selector="openParcelProperties">openParcelProperties	PackagePropertiesDialog on: self currentParcel</body><body package="OldBrowsers" selector="parcelComment">parcelComment	self parcelTextMode:  #parcelComment</body><body package="OldBrowsers" selector="parcelDanglingReferences">parcelDanglingReferences	self parcelTextMode:  #parcelDanglingReferences</body><body package="OldBrowsers" selector="parcelDefinition">parcelDefinition	"Fake parcel mode so we can accept class defs with only the 	parcel selected."	self parcelTextMode: #parcelDefintion</body><body package="OldBrowsers" selector="parcelSummary">parcelSummary	self parcelTextMode:  #parcelSummary</body><body package="OldBrowsers" selector="selectParcel:">selectParcel: aParcel	| newSelection |	newSelection := aParcel notNil ifTrue: [aParcel].	self canvas  module select: newSelection whenFinished:[self canvas module updateList].</body><body package="OldBrowsers" selector="updateBrowser">updateBrowser	self canvas updateLists.	self updateWindowLabel.		manager flushClassParcelMap</body><body package="OldBrowsers" selector="updateLists">updateLists	self browser batchUpdates:		[| theParcel | 		"Remember the currentParcel because updating the parcel list		 will change the currentParcel."		theParcel := self currentParcel.		self canvas updateListFull.		((self components) at:1  ) updateListFull.		((self components) at: 2  ) updateList.		 self selectParcel: theParcel.		self browser updateWindowLabel]</body><body package="OldBrowsers" selector="updateListsForParcels">updateListsForParcels	self browser batchUpdates:		[ self components first updateListFull ].</body></methods><methods><class-id>Tools.ParcelTabApplication</class-id> <category>private-parcel operations</category><body package="OldBrowsers" selector="addClassToParcel">addClassToParcel	| thing |	self changeRequest ifFalse: [^self].	self saveParcelsForUndo.	thing := self selectedThing.	thing == nil ifFalse:		[thing isBehavior			ifTrue: [ self currentParcel addEntiretyOfClass: thing]			ifFalse: [self currentParcel addObject: thing]].	self updateBrowser</body><body package="OldBrowsers" selector="canUndo">canUndo	"Answer if the receiver can do an undo."	^savedParcels notNil</body><body package="OldBrowsers" selector="clearUndoState">clearUndoState	"Free the Parcel copies for undo."	savedParcels := nil</body><body package="OldBrowsers" selector="doUndo">doUndo	"Restore the previous set of Parcels prior to the last parcelling operation and clear the history."	(Dialog confirm: (#UndoLastParcellingQ &lt;&lt; #dialogs &gt;&gt; 'Undo last parcelling?')) ifTrue:		[savedParcels notNil ifTrue:			[savedParcels do: [:parcel| manager replaceParcel: parcel].			savedParcels := nil.			self updateLists]]</body><body package="OldBrowsers" selector="moveBehaviors:toParcel:">moveBehaviors: aBehaviorSet toParcel: theParcelOrNil	"Move the classes in aBehaviorSet into theParcelOrNil according	 to the current filtering and selected parcel.  Read the comment	 in moveSelectors:inClass:toParcel: for a specification."	| classesToMove theClasses parcels |	(self currentParcel notNil and: [unparceledFilterOn]) ifTrue: [^Screen default ringBell].	"First move the selectors..."	aBehaviorSet do:		[:aBehavior|		self moveSelectors: aBehavior selectors			inClass: aBehavior			toParcel: theParcelOrNil].	"Now handle class definitions..."	theClasses := (aBehaviorSet collect: [:ea| ea instanceBehavior]) asSet.	classesToMove := IdentitySet new.	parcels := theClasses inject: IdentitySet new into:					[:set :aClass| | ps |					(ps := manager parcelsForClass: aClass) isNil ifFalse:						[set addAll: ps].					set].	parcelFilterOn		ifTrue:			[conflictsFilterOn				ifTrue:					[parcels size &gt; 1 ifTrue: "optimization - only conflicts if more than 1 parcel"						[theClasses do: [:aClass| | count |							count := 0.							parcels do: [:p|								(p definesClass: aClass) ifTrue:									[count := count + 1]].							count &gt; 1 ifTrue:								[self currentParcel isNil									ifTrue:										[classesToMove add: aClass.										parcels do: [:p| p undefineClass: aClass]]									ifFalse:										[(self currentParcel definesClass: aClass) ifTrue:											[classesToMove add: aClass.											self currentParcel undefineClass: aClass]]]]]]				ifFalse:					[self currentParcel notNil ifTrue: [parcels := IdentitySet with: self currentParcel].					theClasses do: [:aClass|						parcels do: [:p|							(p definesClass: aClass) ifTrue:								[classesToMove add: aClass.								p undefineClass: aClass]]]]]		ifFalse:			[unparceledFilterOn				ifTrue:					[theClasses do: [:aClass|						(parcels contains: [:p| p definesClass: aClass]) ifFalse:							[classesToMove add: aClass]]]				ifFalse:					[theClasses do: [:aClass|						classesToMove add: aClass.						parcels do: [:p| p undefineClass: aClass]]]].	theParcelOrNil notNil ifTrue:		[classesToMove do: [:aClass| theParcelOrNil addClass: aClass]]</body><body package="OldBrowsers" selector="moveClassesAndNameSpaces:toParcel:">moveClassesAndNameSpaces: aSet toParcel: theParcelOrNil	"Move the classes in aSet into theParcelOrNil according to the current filtering and selected parcel.  	Read the comment in moveSelectors:inClass:toParcel: for a specification."	self notImplemented.</body><body package="OldBrowsers" selector="moveData:inNameSpace:fromParcel:toParcel:">moveData: aKeySet inNameSpace: theNameSpace fromParcel: fromParcel toParcel: theParcelOrNil	self notYetImplemented.	"Move the methods in aSelectorSet into theParcel according to the following rules.	 If no Parcel is selected ...		- If filtering is off then move all the methods to theParcelOrNil		and remove all the methods from all other parcels.	 	- If filtering is on then move all the methods that are		defined by other parcels into theParcelOrNil, and		remove just those methods from all other parcels.	 	- If conflict filtering is on then move all the methods that		are defined by more than one parcel into theParcelOrNil,		and remove just those methods from all other parcels.		- if unparcelled filtering is on then add only code that is		unparcelled.  This is a noop if theParcelOrNil is nil.	 If a Parcel is selected ...		move as described above, but only code that is defined		by the selected parcel.	 If aParcelOrNil is nil then the effect is simply to remove the methods from	 other parcels as described above.  This is used in e.g. removing conflicts."</body><body package="OldBrowsers" selector="moveSelectors:inClass:fromParcel:toParcel:">moveSelectors: aSelectorSet inClass: theClass fromParcel: fromParcel toParcel: theParcelOrNil	"Move the methods in aSelectorSet into theParcel according to the following rules.	 If no Parcel is selected ...		- If filtering is off then move all the methods to theParcelOrNil		and remove all the methods from all other parcels.	 	- If filtering is on then move all the methods that are		defined by other parcels into theParcelOrNil, and		remove just those methods from all other parcels.	 	- If conflict filtering is on then move all the methods that		are defined by more than one parcel into theParcelOrNil,		and remove just those methods from all other parcels.		- if unparcelled filtering is on then add only code that is		unparcelled.  This is a noop if theParcelOrNil is nil.	 If a Parcel is selected ...		move as described above, but only code that is defined		by the selected parcel.	 If aParcelOrNil is nil then the effect is simply to remove the methods from	 other parcels as described above.  This is used in e.g. removing conflicts."	| selectorsToMove parcels |	"Here's the state space:	MA = move all/move any	MU = move unparcelled	MCP = move only in current	MCC = move only conflicts in current	MAC = move any conflicts	MAP = move any parcelled		filter:			none	x	unparcelled	x	parcelled	x	multiply parcelled	current parcel		MA				nop				MAC			MCC	no current parcel	MA				MU					MAP			MAC"	(fromParcel notNil and: [unparceledFilterOn]) ifTrue: [^Screen default ringBell].	selectorsToMove := IdentitySet new: aSelectorSet size.	parcels := manager parcelsForClassOrNameSpace: theClass.	nil == parcels ifTrue: [parcels := IdentitySet new].	parcelFilterOn		ifTrue:			[conflictsFilterOn				ifTrue:					[parcels size &gt; 1 ifTrue: "optimization - only conflicts if more than 1 parcel"						[aSelectorSet do: [:sel| | count |							count := 0.							parcels do: [:p|								(p definesSelector: sel forClass: theClass) ifTrue:									[count := count + 1]].							count &gt; 1 ifTrue:								[fromParcel isNil									ifTrue:										[selectorsToMove add: sel.										parcels do: [:p| p removeSelector: sel forClass: theClass]]									ifFalse:										[(fromParcel definesSelector: sel forClass: theClass) ifTrue:											[selectorsToMove add: sel.											fromParcel removeSelector: sel forClass: theClass]]]]]]				ifFalse:					[fromParcel notNil ifTrue: [parcels := IdentitySet with: fromParcel].					aSelectorSet do: [:sel|						parcels do: [:p|							(p definesSelector: sel forClass: theClass) ifTrue:								[selectorsToMove add: sel.								p removeSelector: sel forClass: theClass]]]]]		ifFalse:			[unparceledFilterOn				ifTrue:					[aSelectorSet do: [:sel|						(parcels contains: [:p| p definesSelector: sel forClass: theClass]) ifFalse:							[selectorsToMove add: sel]]]				ifFalse:					[aSelectorSet do: [:sel|						selectorsToMove add: sel.						parcels do: [:p| p removeSelector: sel forClass: theClass]]]].	theParcelOrNil notNil ifTrue:		[selectorsToMove do:			[:aSelector|			theParcelOrNil addSelector: aSelector forClass: theClass]].	self updateListsForParcels.</body><body package="OldBrowsers" selector="moveSelectors:inClass:toParcel:">moveSelectors: aSelectorSet inClass: theClass toParcel: theParcelOrNil	"Move the methods in aSelectorSet into theParcel according to the following rules.	 If no Parcel is selected ...		- If filtering is off then move all the methods to theParcelOrNil		and remove all the methods from all other parcels.	 	- If filtering is on then move all the methods that are		defined by other parcels into theParcelOrNil, and		remove just those methods from all other parcels.	 	- If conflict filtering is on then move all the methods that		are defined by more than one parcel into theParcelOrNil,		and remove just those methods from all other parcels.		- if unparcelled filtering is on then add only code that is		unparcelled.  This is a noop if theParcelOrNil is nil.	 If a Parcel is selected ...		move as described above, but only code that is defined		by the selected parcel.	 If aParcelOrNil is nil then the effect is simply to remove the methods from	 other parcels as described above.  This is used in e.g. removing conflicts."	| selectorsToMove parcels |	"Here's the state space:	MA = move all/move any	MU = move unparcelled	MCP = move only in current	MCC = move only conflicts in current	MAC = move any conflicts	MAP = move any parcelled		filter:			none	x	unparcelled	x	parcelled	x	multiply parcelled	current parcel		MA				nop				MAC			MCC	no current parcel	MA				MU					MAP			MAC"	(self currentParcel notNil and: [unparceledFilterOn]) ifTrue: [^Screen default ringBell].	selectorsToMove := IdentitySet new: aSelectorSet size.	parcels := manager parcelsForClassOrNameSpace: theClass.	nil == parcels ifTrue: [parcels := IdentitySet new].	parcelFilterOn		ifTrue:			[conflictsFilterOn				ifTrue:					[parcels size &gt; 1 ifTrue: "optimization - only conflicts if more than 1 parcel"						[aSelectorSet do: [:sel| | count |							count := 0.							parcels do: [:p|								(p definesSelector: sel forClass: theClass) ifTrue:									[count := count + 1]].							count &gt; 1 ifTrue:								[self currentParcel isNil									ifTrue:										[selectorsToMove add: sel.										parcels do: [:p| p removeSelector: sel forClass: theClass]]									ifFalse:										[(self currentParcel definesSelector: sel forClass: theClass) ifTrue:											[selectorsToMove add: sel.											self currentParcel removeSelector: sel forClass: theClass]]]]]]				ifFalse:					[self currentParcel notNil ifTrue: [parcels := IdentitySet with: self currentParcel].					aSelectorSet do: [:sel|						parcels do: [:p|							(p definesSelector: sel forClass: theClass) ifTrue:								[selectorsToMove add: sel.								p removeSelector: sel forClass: theClass]]]]]		ifFalse:			[unparceledFilterOn				ifTrue:					[aSelectorSet do: [:sel|						(parcels contains: [:p| p definesSelector: sel forClass: theClass]) ifFalse:							[selectorsToMove add: sel]]]				ifFalse:					[aSelectorSet do: [:sel|						selectorsToMove add: sel.						parcels do: [:p| p removeSelector: sel forClass: theClass]]]].	theParcelOrNil notNil ifTrue:		[selectorsToMove do:			[:aSelector|			theParcelOrNil addSelector: aSelector forClass: theClass]].	self updateListsForParcels</body><body package="OldBrowsers" selector="saveParcelsForUndo">saveParcelsForUndo	"Compute a set of Parcel copies for undo."	manager broadcastClearUndoStateFrom: self.	savedParcels := manager parcels collect: [:ea| ea copy]</body></methods><methods><class-id>Tools.ParcelTabApplication</class-id> <category>private parcel</category><body package="OldBrowsers" selector="computeDataConflictsFor:within:">computeDataConflictsFor: aSetOfClasses within: aSetOfParcelsOrNil	"Answer a Set of statics that are multiply parcelled	return and Array with a Set of statics that have conflicts"	| bindings |	bindings := IdentitySet new: 8.	aSetOfClasses do:		[:class| | parcels |		(parcels := manager parcelsForClassOrNameSpace: class) notNil ifTrue:			[|  staticBag  |			staticBag := Bag identityNew: 4.			parcels do:				[:parcel|				staticBag addAll: (parcel definedBindingsFor: class)].			staticBag valuesAndCountsDo:				[:binding :count|				(count &gt; 1				and: [aSetOfParcelsOrNil isNil						or: [aSetOfParcelsOrNil contains: [:parcel| parcel definesClass: class]]])					ifTrue:						[bindings add: binding]]]].	^Array with: bindings</body><body package="OldBrowsers" selector="isConflictsFilterOn">isConflictsFilterOn	^conflictsFilterOn</body><body package="OldBrowsers" selector="isParcelFilterOn">isParcelFilterOn	"Determine if filtering by Parcel is in effect."	^parcelFilterOn or: [conflictsFilterOn]</body><body package="OldBrowsers" selector="isUnparceledFilterOn">isUnparceledFilterOn	"Determine if filtering by Parcel is in effect."	^unparceledFilterOn</body><body package="OldBrowsers" selector="parcelTextMode:">parcelTextMode: aSymbol	self changeRequest ifFalse: [ ^self ].	components do: [ :comp | comp deselect ].	parcelDefType value: aSymbol.	self browser updateText</body><body package="OldBrowsers" selector="parcelTextMode:value:">parcelTextMode: aSymbol value: aText	self changeRequest ifFalse: [ ^self ].	components do: [ :comp | comp deselect ].	parcelDefType value: aSymbol.	self browser text value: aText</body><body package="OldBrowsers" selector="toggleConflicts">toggleConflicts	"Toggle multiply parcelled code filtering."	self changeRequest ifFalse: [^false].	conflictsFilterOn		ifTrue: [conflictsFilterOn := false]		ifFalse:			[unparceledFilterOn := false.			parcelFilterOn := conflictsFilterOn := true].	self updateBrowser.	self updateLists.</body><body package="OldBrowsers" selector="toggleParceled">toggleParceled	"Toggle by-Parcel code filtering."	self changeRequest ifFalse: [^false].	parcelFilterOn		ifTrue: [parcelFilterOn := conflictsFilterOn := false]		ifFalse:			[unparceledFilterOn := false.			parcelFilterOn := true].	self updateBrowser</body><body package="OldBrowsers" selector="toggleUnparceled">toggleUnparceled	"Toggle Unparceled code filtering."	self changeRequest ifFalse: [^false].	unparceledFilterOn		ifTrue: [unparceledFilterOn := false]		ifFalse:			[unparceledFilterOn := true.			parcelFilterOn := conflictsFilterOn := false].	self updateBrowser.	self updateLists</body><body package="OldBrowsers" selector="turnOffParcelFilters">turnOffParcelFilters	parcelFilterOn := unparceledFilterOn := conflictsFilterOn := false.</body><body package="OldBrowsers" selector="updateWindowLabel">updateWindowLabel	(self browser builder notNil	and: [self browser builder window notNil]) ifTrue:		[self browser builder window label: self windowLabel]</body><body package="OldBrowsers" selector="windowLabel">windowLabel	^components isEmpty		ifTrue: [(#ParcelBrowser &lt;&lt; #labels &gt;&gt; 'Parcel Browser')]		ifFalse: [self canvas windowLabel asString, ' ', (components at: 2) windowLabel asString]</body></methods><methods><class-id>Tools.ParcelTabApplication</class-id> <category>updating</category><body package="OldBrowsers" selector="update:with:from:">update: anAspectSymbol with: aParameter from: aSender 	browser currentTabApplication == self		ifFalse: [ ^super update: anAspectSymbol with: aParameter from: aSender ].	#parcels == anAspectSymbol 		ifTrue: 			[ ^self ~~ aSender 				ifTrue: [ self clearUndoState. self updateList ].			].		#clearUndoState == anAspectSymbol 		ifTrue: [  ^self ~~ aSender ifTrue: [ self clearUndoState ] ].	^super update: anAspectSymbol with: aParameter from: aSender</body></methods><methods><class-id>Tools.ParcelTabApplication</class-id> <category>initialize</category><body package="OldBrowsers" selector="addDependents">addDependents	self manager addDependent: self.</body><body package="OldBrowsers" selector="initialize">initialize	manager := Parcel.	parcelFilterOn := unparceledFilterOn := conflictsFilterOn := false.	parcelDefType := #parcelComment asValue.	self addDependents.	super initialize.</body><body package="OldBrowsers" selector="initializeForClassHierarchy:">initializeForClassHierarchy: aClass	| cls |	self browser meta value: (aClass isMeta ifTrue: [#class] ifFalse: [#instance]).	cls := aClass instanceBehavior.	components := List new.	components add: self parcelsComponent.	components add: self classHierarchyComponent.	components add: self protocolsComponent.	components add: self selectorsComponent.	self linkComponentsInArray: components.	self linkFirstComponentToSubcanvas.	self browser updateLists.	self	setClassOrNameSpaceFor: #default to: aClass.	components first		updateList;		selection:  ( cls fullyQualifiedReference ).</body><body package="OldBrowsers" selector="release">release	super release.	self removeDependents.</body><body package="OldBrowsers" selector="removeDependents">removeDependents	self manager removeDependent: self.</body></methods><methods><class-id>Tools.ParcelTabApplication</class-id> <category>componentBuilding</category><body package="OldBrowsers" selector="allCategoriesComponent">allCategoriesComponent	^SimpleBrowserModule singleSelect		specName: #listSpecSingleSelect;		helpers: (Array with: (ParcelNameSpaceOrganizerBrowserHelper new searchChildNamespaces: true) ).</body><body package="OldBrowsers" selector="allClassesComponent">allClassesComponent	^SimpleBrowserModule new 		helperType: ParcelNameSpaceGlobalCategoryBrowserHelper;		yourself</body><body package="OldBrowsers" selector="buildComponentArray">buildComponentArray	super buildComponentArray.	self indexOfCategoryCanvas: 1.</body><body package="OldBrowsers" selector="categoriesComponent">categoriesComponent	^self browser searchChildNamespaces		ifTrue: [self allCategoriesComponent]		ifFalse: [(SimpleBrowserModule singleSelect) specName: #listSpecSingleSelect; helperType: ParcelNameSpaceOrganizerBrowserHelper]</body><body package="OldBrowsers" selector="classesComponent">classesComponent	^self browser searchChildNamespaces		ifTrue: [self allClassesComponent]		ifFalse: [	SimpleBrowserModule new		helperType: ParcelNameSpaceCategoryBrowserHelper;		yourself]</body><body package="OldBrowsers" selector="componentId">componentId	^#parcelTab</body><body package="OldBrowsers" selector="protocolsComponent">protocolsComponent	^SimpleBrowserModule singleSelect		specName: #listSpecProtocolsSingleSelect;		helperType: ParcelProtocolBrowserHelper;		yourself</body><body package="OldBrowsers" selector="selectorsComponent">selectorsComponent	^SimpleBrowserModule new		helperType: ParcelSelectorBrowserHelper;		yourself</body></methods><methods><class-id>Tools.ParcelTabApplication</class-id> <category>accessing subcanvases</category><body package="OldBrowsers" selector="getCanvas">getCanvas	| module |	module := self parcelsComponent.						 module	browser: self browser.	^module</body><body package="OldBrowsers" selector="parcelsComponent">parcelsComponent	^SimpleBrowserModule singleSelect		deselectNextModuleOnReselect: false;		helperType: ParcelListBrowserHelper;		yourself</body></methods><methods><class-id>Tools.ParcelTabApplication</class-id> <category>accessing</category><body package="OldBrowsers" selector="categoriesLabel">categoriesLabel	^self browser selectedEnvironment notNil		ifTrue: [ self categoryTabCanvas selection notNil ifTrue:[self categoryTabCanvas selection ] ifFalse:[(#ParcelCategories &lt;&lt; #labels &gt;&gt; 'Parcel Categories') asString]]		ifFalse: [(#ParcelCategories &lt;&lt; #labels &gt;&gt; 'Parcel Categories') asString]</body><body package="OldBrowsers" selector="defaultEmphasizer">defaultEmphasizer	^ParcelEmphasizer new.</body><body package="OldBrowsers" selector="icon">icon	^icon isNil ifTrue:[ icon := self eraseBackgroundOnImage: (self class parcelIcon)] ifFalse:[icon ]</body><body package="OldBrowsers" selector="label">label	^self canvas selection == nil 		ifTrue: [ self class label ] 		ifFalse: [ self canvas selection name ]</body><body package="OldBrowsers" selector="parcelDefType">parcelDefType	^parcelDefType</body></methods><methods><class-id>Tools.ParcelTabApplication class</class-id> <category>accessing</category><body package="OldBrowsers" selector="label">label	^(#Parcels &lt;&lt; #menus &gt;&gt; 'Parcels') asString</body></methods><methods><class-id>Tools.ParcelTabApplication class</class-id> <category>menus</category><body package="OldBrowsers" selector="addParceling:to:forHelper:">addParceling: parcelSet to: aMenu forHelper: aBrowserHelper	"Add the various parcelling operations and undo to aMenu.	 Make sure the various actions refer to parcels weakly so as	 not to prevent clean unloading."	| parcelMenuItem parcelSubMenu submenu	 locateParcels locateList locateNames	 moveToParcels moveToList moveToNames |		parcelMenuItem := aMenu atNameKey: #parcelSubMenu.	parcelMenuItem == nil ifTrue:		[parcelMenuItem := (MenuItem labeled: (#Parcel &lt;&lt; #menus &gt;&gt; 'Parcel'))				nameKey: #parcelSubMenu;				submenu: self parcelSubMenu.		aMenu addItem: parcelMenuItem atPosition: 33.01].	parcelSubMenu := parcelMenuItem submenu.	1 to: parcelSubMenu numberOfItems - 2 do: "add to, remove from, move to"		[:i| 			(parcelSubMenu menuItemAt: i) nameKey = #parcelAddTo ifTrue:[(parcelSubMenu menuItemAt: i)  enabled: (aBrowserHelper selectedParcel notNil and:[(aBrowserHelper selectedParcel definesClass: aBrowserHelper selection) not]) ]		ifFalse:[ (parcelSubMenu menuItemAt: i) enabled: aBrowserHelper selectedParcel notNil]].	locateParcels :=  parcelSubMenu atNameKey: #parcelLocate.	locateList := (parcelMenuItem isEnabled				and: [parcelSet size &gt; 0])					ifTrue: [(parcelSet asSortedCollection: [:p1 :p2| p1 name &lt;= p2 name])]					ifFalse: [#()].	locateList isEmpty		ifTrue:			[locateParcels disable; submenu: nil]		ifFalse:			[locateNames := (locateList collect: [:ea| ea name]) asArray.			locateList := WeakArray withAll: locateList.			submenu := (Menu							labelArray: locateNames							values: ((1 to: locateList size) collect:										[:i|										[| p |										((p := locateList at: i) ~= locateList tombstone and: [p ~= nil]) ifTrue:											[Cursor execute showWhile:												[aBrowserHelper browser selectParcel: p]]]])).			locateParcels submenu: submenu; enable].	moveToParcels :=  parcelSubMenu atNameKey: #parcelMoveTo.	moveToList := parcelMenuItem isEnabled					ifTrue: [(aBrowserHelper browser manager parcels								asSortedCollection: [:p1 :p2| p1 name &lt;= p2 name])]					ifFalse: [#()].	moveToList isEmpty		ifTrue:			[moveToParcels disable; submenu: nil]		ifFalse:			[moveToNames := (moveToList collect: [:ea| ea name]) asArray.			moveToList := WeakArray withAll: moveToList.			submenu := (Menu							labelArray: moveToNames							values: ((1 to: moveToList size) collect:										[:i|										[| p |										((p := moveToList at: i) ~= moveToList tombstone and: [p ~= nil]) ifTrue:											[Cursor execute showWhile:												[aBrowserHelper  moveSelectionToParcel: p]]]])).			moveToParcels submenu: submenu; enable].	aBrowserHelper augmentMenuBarMenu: parcelSubMenu.	^aMenu</body></methods><methods><class-id>Tools.TabApplicationSystemBrowser</class-id> <category>accessing</category><body package="OldBrowsers" selector="components">components	^self tabApplication systemBrowserComponents</body><body package="OldBrowsers" selector="components:">components: aList	self tabApplication components: aList.	self linkComponents</body><body package="OldBrowsers" selector="currentTabApplication">currentTabApplication	"for sideways compatibility."	^tabApplication</body><body package="OldBrowsers" selector="currentTabApplication:">currentTabApplication: aTabApplication	"for sideways compatibility."	self tabApplication: aTabApplication</body><body package="OldBrowsers" selector="tabApplication">tabApplication	^tabApplication</body><body package="OldBrowsers" selector="tabApplication:">tabApplication: aBrowserTabApplication	tabApplication := aBrowserTabApplication</body></methods><methods><class-id>Tools.TabApplicationSystemBrowser</class-id> <category>delagating</category><body package="OldBrowsers" selector="doesNotUnderstand:">doesNotUnderstand: aMessage	"this delegates anything I don't understand to the current tab application.	this is so that behavour normally needed to be sent to the browser can be offloaded to the BrowserTabApplication. Thismakes adding Tab Applications that don't step on each other easier."	| tabApp |	tabApp := self tabApplication.	((tabApp) respondsTo: aMessage selector) ifFalse:		[^super doesNotUnderstand: aMessage].	^tabApp perform: aMessage selector withArguments: aMessage arguments</body></methods><methods><class-id>Tools.TabApplicationSystemBrowser</class-id> <category>actions</category><body package="OldBrowsers" selector="module:action:">module: moduleName action: action	(coordinator notNil and: [coordinator menuHeader = moduleName])		ifTrue: [^coordinator perform: action].	self components do: [:comp |		comp menuHeader = moduleName			ifTrue: [^comp dispatch: action]].	self error: (#ThisMenuItemIsNotSupported &lt;&lt; #dialogs &gt;&gt; 'This menu item is not supported')</body><body package="OldBrowsers" selector="module:action:with:">module: moduleName action: action with: value	(coordinator notNil and: [coordinator menuHeader = moduleName])		ifTrue: [^coordinator dispatch: action with: value].	self components do: [:comp |		comp menuHeader = moduleName			ifTrue: [^comp dispatch: action with: value]].	self error: (#ThisMenuItemIsNotSupported &lt;&lt; #dialogs &gt;&gt; 'This menu item is not supported')</body><body package="OldBrowsers" selector="truePerformerFor:">truePerformerFor: moduleName	"Answer the module that is responsible for performing menu 	actions for moduleName. Answer the receiver if none."	( coordinator notNil and: [ coordinator menuHeader = moduleName ] )		ifTrue: [ ^coordinator ].	self components do: 		[ :comp |		comp menuHeader = moduleName			ifTrue: [ ^comp ]		].	^nil</body><body package="OldBrowsers" selector="updateLists">updateLists	self tabApplication components isEmpty		ifFalse: [self tabApplication components first updateList]</body></methods><methods><class-id>Tools.TabApplicationSystemBrowser</class-id> <category>initialize</category><body package="OldBrowsers" selector="initialize">initialize	inBatchMode := false.	text := String new asValue.	meta := #instance asValue.	meta onChangeSend: #updateProtocolLists to: self.	defType := #showDefinition asValue.	defType onChangeSend: #updateText to: self.	toolBar := nil asValue.	selectionDictionary := IdentityDictionary new.	"self  initializeForNameSpace: Smalltalk."</body><body package="OldBrowsers" selector="initializeForAllNameSpaces">initializeForAllNameSpaces	self ignoreNamepaceChanges: true.	self tabApplication initializeForAllNameSpaces.	self setNameSpaceFor: #default to: Smalltalk.</body><body package="OldBrowsers" selector="initializeForClass:">initializeForClass: aClass	self tabApplication initializeForClass: aClass</body><body package="OldBrowsers" selector="initializeForClass:protocol:">initializeForClass: aClass protocol: aProtocol	self tabApplication initializeForClass: aClass protocol: aProtocol</body><body package="OldBrowsers" selector="initializeForClassHierarchy:">initializeForClassHierarchy: aClass	self tabApplication initializeForClassHierarchy: aClass</body><body package="OldBrowsers" selector="initializeForMethodsLabel:list:initialSelection:">initializeForMethodsLabel: labelString list: aCollection initialSelection: selectorself tabApplication initializeForMethodsLabel: labelString list: aCollection initialSelection: selector</body><body package="OldBrowsers" selector="initializeForNameSpace:">initializeForNameSpace: aNameSpace	self tabApplication initializeForNameSpace: aNameSpace</body><body package="OldBrowsers" selector="initializeForNameSpaces">initializeForNameSpacesself tabApplication initializeForNameSpaces</body><body package="OldBrowsers" selector="initializeForNameSpaces:category:">initializeForNameSpaces: aNameSpace category: aCategory	self tabApplication initializeForNameSpaces: aNameSpace category: aCategory</body><body package="OldBrowsers" selector="release">release	self tabApplication release.	super release</body></methods><methods><class-id>Tools.TabApplicationSystemBrowser</class-id> <category>private</category><body package="OldBrowsers" selector="linkComponents">linkComponents	1 to:  self components size-1 do: [:i |		(components at: i)			browser: self;			nextModule: ((i+1) &gt; components size ifTrue:[nil] ifFalse:[ components at: i+1])].	self components last browser: self.	self updateLists</body><body package="OldBrowsers" selector="numberOfLists">numberOfLists	| n |	n := coordinator == nil		ifTrue: [0]		ifFalse: [coordinator numberOfLists].	^self components inject: n into: [:i :comp | i + comp numberOfLists]</body><body package="OldBrowsers" selector="tryAll:default:">tryAll: testBlock default: defaultBlock	self components reverseDo:		[:comp | | val |		val := testBlock value: comp.		val == nil ifFalse: [^val]].	^defaultBlock value</body><body package="OldBrowsers" selector="visibleComponentAt:">visibleComponentAt: index	| n |	n := 0.	coordinator == nil		ifFalse:			[n := n + coordinator numberOfLists.			n &gt;= index ifTrue: [^coordinator]].	self components do: [:comp |		n := n + comp numberOfLists.		n &gt;= index ifTrue: [^comp]].	^self error: ((#Component1pNotFound &lt;&lt; #dialogs &gt;&gt; 'Component &lt;1p&gt; not found') expandMacrosWith: index)</body></methods><methods><class-id>Tools.TabApplicationSystemBrowser</class-id> <category>components</category><body package="OldBrowsers" selector="menuBar">menuBar	| menu |	menu := Menu new		addPart: self class menuBarStart.	coordinator == nil ifFalse: [coordinator buildMenuBar: menu].	self components do: [:comp | comp buildMenuBar: menu].	menu addPart: self class menuBarEnd.	(menu atNameKey: #edit) submenu: self remoteTextMenu.	(menu atNameKey: #view) submenu: [self viewMenu].	^menu</body><body package="OldBrowsers" selector="resetToolBar">resetToolBar	| menu |	menu := Menu new.	coordinator == nil ifFalse: [coordinator buildToolBar: menu].	self components do: [:comp | comp buildToolBar: menu].	toolBar value: menu</body><body package="OldBrowsers" selector="viewMenu">viewMenu	| menu |	menu := Menu new.	coordinator == nil ifFalse: [coordinator buildViewMenu: menu].	self components do: [:comp | comp buildViewMenu: menu].	^menu</body><body package="OldBrowsers" selector="windowLabel">windowLabel	^self components isEmpty		ifTrue: [(#SystemBrowser &lt;&lt; #labels &gt;&gt; 'System Browser')]		ifFalse: [self components first windowLabel]</body></methods><methods><class-id>Tools.TabApplicationSystemBrowser</class-id> <category>text processing</category><body package="OldBrowsers" selector="updateText">updateText	| sel tv |	text value: (self tryAll: [:c | c text] default: [Text new]).	(sel := self tabApplication components first initialSelection) == nil		ifFalse: [builder == nil			ifFalse:				[tv := (builder componentAt: #text) widget.				tv deselect.				tv controller find: sel.				tv displaySelection: true.				tv selectAndScroll]]</body></methods><methods><class-id>Tools.TabApplicationSystemBrowser</class-id> <category>spawning</category><body package="OldBrowsers" selector="spawnForMethodsLabel:list:initialSelection:">spawnForMethodsLabel: aLabel list: list initialSelection: selection 	self currentTabApplication		spawnForMethodsLabel: aLabel		list: list		initialSelection: selection		with: self currentTabApplication</body><body package="OldBrowsers" selector="spawnOnClass:">spawnOnClass: aClass	self currentTabApplication spawnOnClass: aClass with: self currentTabApplication</body><body package="OldBrowsers" selector="spawnOnClass:protocol:">spawnOnClass: aClass protocol: aSelection	self currentTabApplication spawnOnClass: aClass with: self currentTabApplication protocol: aSelection</body><body package="OldBrowsers" selector="spawnOnClassHierarchy:">spawnOnClassHierarchy: aClass	self currentTabApplication spawnOnClassHierarchy: aClass with: self currentTabApplication</body><body package="OldBrowsers" selector="spawnOnNameSpace:">spawnOnNameSpace:  aNamespace	self currentTabApplication 		spawnOnNameSpace: aNamespace 		with: self currentTabApplication</body><body package="OldBrowsers" selector="spawnOnNameSpaces:category:">spawnOnNameSpaces: aNamespace category: aCategory  	self currentTabApplication 		spawnOnNameSpace: aNamespace 		with: self currentTabApplication 		category: aCategory</body></methods><methods><class-id>Tools.TabApplicationSystemBrowser</class-id> <category>selection utlity</category><body package="OldBrowsers" selector="selectBehavior:">selectBehavior: aBehaviorself currentTabApplication selectBehavior: aBehavior</body><body package="OldBrowsers" selector="selectCategory:">selectCategory: aCategoryself currentTabApplication selectCategory: aCategory</body><body package="OldBrowsers" selector="selectMethod:">selectMethod: aSymbolself currentTabApplication  selectMethod: aSymbol</body><body package="OldBrowsers" selector="selectProtocol:">selectProtocol: aProtocolself currentTabApplication selectProtocol: aProtocol</body></methods><methods><class-id>Tools.TabApplicationSystemBrowser</class-id> <category>change</category><body package="OldBrowsers" selector="updateButtonLabels">updateButtonLabels	self	updateMajorTabsListFor: self currentTabApplication</body></methods><methods><class-id>Tools.TabApplicationSystemBrowser</class-id> <category>interface opening</category><body package="OldBrowsers" selector="postOpenWith:">postOpenWith: aBuilder 	"Make current selection visible."	super postOpenWith: aBuilder.	tabApplication components first checkVisibility</body></methods><methods><class-id>Tools.TabApplicationSystemBrowser class</class-id> <category>application configuration</category><body package="OldBrowsers" selector="allButOpenOnClass:">allButOpenOnClass: aClass	^self openOnClass: aClass with: NamespaceTabApplication</body><body package="OldBrowsers" selector="initializeForMethodsLabel:list:initialSelection:with:">initializeForMethodsLabel: labelString list: aCollection initialSelection: selector with: aBrowserTabApplicationClass 	| inst aBrowserTabApplication |	inst := self new.	aBrowserTabApplication := aBrowserTabApplicationClass basicNewOnBrowser: inst.	inst tabApplication: aBrowserTabApplication;		initializeForMethodsLabel: labelString		list: aCollection		initialSelection: selector.	aCollection size = 1		ifTrue: 			[inst components first forceSelection: aCollection first.			inst updateLists].	^inst open</body><body package="OldBrowsers" selector="initializeForNamespacesWith:">initializeForNamespacesWith: aBrowserTabApplicationClass | inst aBrowserTabApplication |	inst := self new.	aBrowserTabApplication := aBrowserTabApplicationClass basicNewOnBrowser: inst.	^inst			tabApplication: aBrowserTabApplication;		initializeForAllNameSpaces;		open.</body><body package="OldBrowsers" selector="openOnAllNameSpaces">openOnAllNameSpaces		"self openOnAllNameSpaces"	^self initializeForNamespacesWith:  NamespaceTabApplication.</body><body package="OldBrowsers" selector="openOnClass:">openOnClass: aClass	^self openOnClass: aClass with: NamespaceTabApplication</body><body package="OldBrowsers" selector="openOnClass:with:">openOnClass: aClass with: aBrowserTabApplicationClass		"self openOnClass: self"	 | inst aBrowserTabApplication |	inst := self new.	aBrowserTabApplication := aBrowserTabApplicationClass basicNewOnBrowser: inst.	^inst			tabApplication: aBrowserTabApplication;		initializeForClass: aClass;		open.</body><body package="OldBrowsers" selector="openOnClass:with:protocol:">openOnClass: aClass with: aBrowserTabApplicationClass protocol: aSelection		"self openOnClass: self"	 | inst aBrowserTabApplication |	inst := self new.	aBrowserTabApplication := aBrowserTabApplicationClass basicNewOnBrowser: inst.	^inst			tabApplication: aBrowserTabApplication;		initializeForClass: aClass protocol: aSelection;		open.</body><body package="OldBrowsers" selector="openOnClassHierarchy:">openOnClassHierarchy: aClass 		^self openOnClassHierarchy: aClass with: NamespaceTabApplication</body><body package="OldBrowsers" selector="openOnClassHierarchy:with:">openOnClassHierarchy: aClass with: aBrowserTabApplicationClass		"self openOnClassHierarchy: self"	 | inst aBrowserTabApplication |	inst := self new.	aBrowserTabApplication := aBrowserTabApplicationClass basicNewOnBrowser: inst.	^inst		tabApplication: aBrowserTabApplication;		initializeForClassHierarchy: aClass;		open.</body><body package="OldBrowsers" selector="openOnNameSpace:with:">openOnNameSpace: aNameSpace with: aBrowserTabApplicationClass	 | inst aBrowserTabApplication |	inst := self new.	aBrowserTabApplication := aBrowserTabApplicationClass basicNewOnBrowser: inst.	^inst			tabApplication: aBrowserTabApplication;		initializeForNameSpace: aNameSpace;		open.</body><body package="OldBrowsers" selector="openOnNameSpace:with:on:">openOnNameSpace: aNameSpace with: aBrowserTabApplicationClass on: aCategory	 | inst aBrowserTabApplication |	inst := self new.	aBrowserTabApplication := aBrowserTabApplicationClass basicNewOnBrowser: inst.	^inst			tabApplication: aBrowserTabApplication;		initializeForNameSpaces: aNameSpace category: aCategory ;		open.</body></methods><methods><class-id>Tools.HierarchicalBrowserModule</class-id> <category>accessing</category><body package="OldBrowsers" selector="allowsMultiSelect">allowsMultiSelect	^false</body><body package="OldBrowsers" selector="defaultSpecName">defaultSpecName	^#listSpec</body></methods><methods><class-id>Tools.HierarchicalBrowserModule</class-id> <category>list accessing</category><body package="OldBrowsers" selector="currentNodeSelection">currentNodeSelection	^list currentNodeSelection</body><body package="OldBrowsers" selector="selection:">selection: aValue	self allowsMultiSelect		ifTrue: [self list selections: (Set with: ( aValue))]		ifFalse: [ self list selection: ( aValue)]</body><body package="OldBrowsers" selector="setNewList:">setNewList: newList 	| decoratedList |	decoratedList := newList.	list		setTree: decoratedList		selecting: (selectionCandidates == nil					ifTrue: [list selection]					ifFalse: [selectionCandidates asArray first])		childAccessor: #sortedChildren		childNameAccessor: #key.	self checkVisibility</body><body package="OldBrowsers" selector="setNewListSilently:">setNewListSilently: aList	| newlist |	newlist := aList.	 list selectionIndexHolder  retractInterestsFor: self.	list		setTree: newlist		selecting: (selectionCandidates == nil				ifTrue: [list selection]				ifFalse: [selectionCandidates asArray first])		childAccessor: #sortedChildren		childNameAccessor: #key.	self checkVisibility.	list selectionIndexHolder onChangeSend: #selectionChanged to: self.	^self</body></methods><methods><class-id>Tools.HierarchicalBrowserModule</class-id> <category>actions</category><body package="OldBrowsers" selector="doubleClick">doubleClick	"Expand/collapse the current selection."	self list toggleCurrent</body><body package="OldBrowsers" selector="setPresetWidthTo:">setPresetWidthTo: anInteger	self builder isNil ifTrue:[^self].	(self builder componentAt: #list ) widget presetWidth: anInteger</body><body package="OldBrowsers" selector="spawnBrowser">spawnBrowser	"Since this is a hierachy check first to see if we have some thing selected that is spawnable.	Trigger the 'spawn' action, via a double-click.	If there are more than one types of spawning,	this may not necessarily be the same as the	'spawn' menu item.""	self halt."	self selection isSymbol ifTrue:[self list toggleCurrent  ].	self spawn</body></methods><methods><class-id>Tools.HierarchicalBrowserModule</class-id> <category>copying</category><body package="OldBrowsers" selector="postCopy">postCopy	| old |	super postCopy.	builder := browser := nextModule := nil.	helpers := helpers collect: [:i | i copy module: self].	old := list.		list := IndentedTreeSelectionInList new.	list list: old list copy.	self allowsMultiSelect		ifTrue: [list selectionIndexes: old selectionIndexes copy]		ifFalse: [list selectionIndex: old selectionIndex].	list selectionIndexHolder onChangeSend: #selectionChanged to: self.</body></methods><methods><class-id>Tools.HierarchicalBrowserModule</class-id> <category>testing</category><body package="OldBrowsers" selector="testChangeSelection:">testChangeSelection: controller 	self changeRequest ifFalse: [^false].	nextModule == nil 		ifTrue: [self list selectionIndexes: Set new]		ifFalse: [nextModule list selectionIndexes: Set new].	^true</body></methods><methods><class-id>Tools.HierarchicalBrowserModule</class-id> <category>private</category><body package="OldBrowsers" selector="selectedVisualBlock">selectedVisualBlock	"Supply the block that determins the appearance for selected list entries."	^[ :view :index | | aText anItem listEntry label |	   listEntry :=  view sequence at: index.	   anItem := listEntry .	   aText := self textForItem: anItem.	   aText emphasizeAllWith: (self textEmphasisForItem: anItem).  	   (label:= Label with: listEntry ) attributes: view textStyle; offset: label offset.	   label:= ReversingWrapper on: label.	   label reverse setValue: true.	   BoundedWrapper on: label]</body><body package="OldBrowsers" selector="visualBlock">visualBlock	"Supply the block that determins the appearance for unselected list entries."	^[:view :index | | aText anItem listEntry label |	   listEntry := view sequence at: index.	   anItem := listEntry .	   aText := self textForItem: anItem.	   aText emphasizeAllWith: (self textEmphasisForItem: anItem).	   (label := Label with: listEntry ) attributes: view textStyle; offset: label offset.	   BoundedWrapper on: label]</body></methods><methods><class-id>Tools.HierarchicalBrowserModule</class-id> <category>initialize</category><body package="OldBrowsers" selector="initialize">initialize	list := IndentedTreeSelectionInList newEmptyInstance."	list := self allowsMultiSelect			ifTrue: [MultiSelectionInList new]			ifFalse: [SelectionInList new]."	list selectionIndexHolder onChangeSend: #selectionChanged to: self.	specName := self defaultSpecName</body></methods><methods><class-id>Tools.HierarchicalBrowserModule</class-id> <category>release</category><body package="OldBrowsers" selector="release">release	self breakDependents.	self releaseEventTable	list selectionIndexHolder removeDependent: self.	list selectionIndexHolder retractInterestsFor: self.	self cachedComponents notNil		ifTrue: [ self cachedComponents do: [ :ea | ea release ] ].	self browser: nil.</body></methods><methods><class-id>Tools.HierarchicalBrowserModule</class-id> <category>private-emphasis</category><body package="OldBrowsers" selector="postBuildWith:">postBuildWith: aBuilder	super postBuildWith: aBuilder. 	self setPresetWidthTo: 500</body></methods><methods><class-id>Tools.HierarchyBrowserHelper</class-id> <category>menus accessing</category><body package="OldBrowsers" selector="actionsForMultiSelect">actionsForMultiSelect	^#()</body><body package="OldBrowsers" selector="actionsForNoSelect">actionsForNoSelect	^#(#find)</body></methods><methods><class-id>Tools.HierarchyBrowserHelper</class-id> <category>list accessing</category><body package="OldBrowsers" selector="addCategoryTreeToTree:">addCategoryTreeToTree: aTree	| categoryTree |	categoryTree :=  AssociationTreeWithParent key: (#Categories &lt;&lt; #dialogs &gt;&gt; 'Categories') value: #category.	aTree addChild: categoryTree.</body><body package="OldBrowsers" selector="addChildNamespace:to:">addChildNamespace: aNamespace to: namespaceTree	aNamespace bindingsDo:[:var | |namespaceChild | 									var isForNameSpace ifTrue:[									namespaceChild := (AssociationTreeWithParent key: var value name value: var value).								  namespaceTree addChild: namespaceChild.									self addChildNamespace: var value to: namespaceChild.]].</body><body package="OldBrowsers" selector="addNamespaceTreeToTree:">addNamespaceTreeToTree: aTree	| namespaceTree |	namespaceTree :=  AssociationTreeWithParent key: 'Root' value:  Root.	aTree addChild: namespaceTree.	self addChildNamespace: Root to: namespaceTree.</body><body package="OldBrowsers" selector="addParcelNamespaceTreeToTree:">addParcelNamespaceTreeToTree: aTree	| namespaceTree |	namespaceTree :=  AssociationTreeWithParent key: (#Namespaces &lt;&lt; #dialogs &gt;&gt; 'Namespaces') value:  #parcelNamespaces.	aTree addChild: namespaceTree.	self addChildNamespace: Root to: namespaceTree.</body><body package="OldBrowsers" selector="addParcelTreeToTree:">addParcelTreeToTree: aTree	| parcelTree |	parcelTree :=  AssociationTreeWithParent key: (#Parcels &lt;&lt; #dialogs &gt;&gt; 'Parcels') value: #parcels.	aTree addChild: parcelTree.	Parcel parcels do:				[ :each | | parcelChild | 		parcelChild := AssociationTreeWithParent key: each listEntry value: each.		parcelTree addChild: parcelChild.			self addParcelNamespaceTreeToTree: parcelChild.		].</body><body package="OldBrowsers" selector="currentNodeSelection">currentNodeSelection	^module currentNodeSelection</body><body package="OldBrowsers" selector="getEnvironmentForSelection">getEnvironmentForSelection		(self currentNodeSelection == nil	or: [self currentNodeSelection parent == nil])		ifTrue: [ ^nil ].	self selectionIsParcel ifTrue:[ ^self environment ].	self selectionIsNamespace ifTrue:[ ^self selection ].	^self environment</body><body package="OldBrowsers" selector="intializeListFull">intializeListFull	| tree |	tree  := AssociationTreeWithParent key: (#Filters &lt;&lt; #dialogs &gt;&gt; 'Filters') value: #filters.	self addNamespaceTreeToTree: tree.	self addParcelTreeToTree: tree.	self addCategoryTreeToTree: tree.	module setNewListSilently: tree</body><body package="OldBrowsers" selector="selectedItem">selectedItem	| thing |	thing := self selection .	(self selectionIsClass and: [self browser meta value == #class])		ifTrue: [thing := thing class].	^thing</body><body package="OldBrowsers" selector="selectionChanged">selectionChanged	module nextModule == nil ifTrue: [^super selectionChanged].	self browser		batchUpdates:			[ | env |			env := self getEnvironmentForSelection.			self setSelection: env.  			module nextModule currentHelper searchChildNamespaces: env isNil.			module nextModule updateList.			self browser				updateWindowLabel;				updateButtonLabels]</body><body package="OldBrowsers" selector="selectionIsClass">selectionIsClass	^(self selection notNil  and:[ self selection isSymbol not])		and: [self selection binding isForClass]</body><body package="OldBrowsers" selector="selectionIsDefined">selectionIsDefined	^(self selection notNil and:[ self selection isSymbol not]) and: [self selection binding isForGeneral not]</body><body package="OldBrowsers" selector="selectionIsNames">selectionIsNames	^(self selection notNil and:[ self selection isSymbol not])		and: [self selection binding isForClass		or: [self selection binding isForNameSpace]]</body><body package="OldBrowsers" selector="selectionIsNamespace">selectionIsNamespace	^(self selection notNil  and:[ self selection isSymbol not])		and: [self selection isNameSpace]</body><body package="OldBrowsers" selector="selectionIsParcel">selectionIsParcel	^(self selection notNil  and:[ self selection isSymbol not])		and: [self selection class name == #Parcel]</body><body package="OldBrowsers" selector="selectionIsSymbol">selectionIsSymbol	^self selection isSymbol</body><body package="OldBrowsers" selector="updateListFull">updateListFull	| tree |	tree  := AssociationTreeWithParent key: (#Filters &lt;&lt; #dialogs &gt;&gt; 'Filters') value: #filters.	self addNamespaceTreeToTree: tree.	self addParcelTreeToTree: tree.	self addCategoryTreeToTree: tree.	module setNewList: tree</body></methods><methods><class-id>Tools.HierarchyBrowserHelper</class-id> <category>private</category><body package="OldBrowsers" selector="defaultEnvironment">defaultEnvironment	^Smalltalk</body><body package="OldBrowsers" selector="selectedThingsWithOrder:">selectedThingsWithOrder: aBlock	| things |	things := OrderedCollection new.	things add: self selection.	things addAll: (self selection allClasses ).	things addAll: (self selection allNameSpaces ).	things := SystemUtils sortForLoading: things.	aBlock value: things</body></methods><methods><class-id>Tools.HierarchyBrowserHelper</class-id> <category>templates</category><body package="OldBrowsers" selector="addClassType:">addClassType: type	"Display a template for adding a class of type type."	| env cat |	( env:= self  selectedNameSpace ) == nil		ifTrue: [ env := Smalltalk ].	cat := self  category.	self browser defType value: #showDefinition.	module nextModule nextModule deselect.	"next module is categories...."	self browser text value: 		( self templateClass: env category: cat type: type )</body><body package="OldBrowsers" selector="templateBinding:category:">templateBinding: nameSpace category: category	^'&lt;1s&gt; defineSharedVariable: #&lt;2s&gt;	private: false	constant: false	category: &lt;3p&gt;	initializer: ''Array new: 5'''		expandMacrosWith: (nameSpace namedReferent unambiguousName)		with: #NameOfBinding &lt;&lt; #browser &gt;&gt; 'NameOfBinding'		with: (category == nil				ifTrue: [NameSpaceOrganizer defaultProtocol asString]				ifFalse: [category asString])</body><body package="OldBrowsers" selector="templateClass:category:type:">templateClass: nameSpace category: category type: type	^'&lt;1p&gt; defineClass: #&lt;2s&gt;	superclass: #{&lt;3s&gt;}	indexedType: #&lt;4s&gt;	private: false	instanceVariableNames: ''&lt;5s&gt;''	classInstanceVariableNames: ''''	imports: ''''	category: &lt;6p&gt;' 		expandMacrosWithArguments: (OrderedCollection new			add: (nameSpace namedReferent unambiguousName);			add: #NameOfClass &lt;&lt; #browser &gt;&gt; 'NameOfClass';			add: #NameOfSuperclass &lt;&lt; #browser &gt;&gt; 'NameOfSuperclass';			add: type;			add: (type == #bytes				ifTrue: ['']				ifFalse: [(#instVarName1InstVarName2 &lt;&lt; #browser &gt;&gt; 'instVarName1 instVarName2')]);			add: (category == nil				ifTrue: [NameSpaceOrganizer defaultProtocol asString]				ifFalse: [category asString]);			yourself)</body><body package="OldBrowsers" selector="templateNameSpace:category:">templateNameSpace: nameSpace category: category	^'&lt;1s&gt; defineNameSpace: #&lt;2s&gt;	private: false	imports: ''			&lt;3s&gt;.*			private Smalltalk.*			''	category: &lt;4p&gt;'		expandMacrosWith: (nameSpace namedReferent unambiguousName)		with: #NameOfPool &lt;&lt; #browser &gt;&gt; 'NameOfPool'		with: #OtherNameSpace &lt;&lt; #browser &gt;&gt; 'OtherNameSpace'		with: (category == nil				ifTrue: [NameSpaceOrganizer defaultProtocol asString]				ifFalse: [category asString])</body></methods><methods><class-id>Tools.HierarchyBrowserHelper</class-id> <category>actions</category><body package="OldBrowsers" selector="addBinding">addBinding	| env cat |	( env:= self  selectedNameSpace ) == nil		ifTrue: [ env := Smalltalk ].	cat := self category.	self browser defType value: #showDefinition.	module nextModule nextModule deselect.	"next module is categories...."	self browser text value: 		( self templateBinding: env category: cat )</body><body package="OldBrowsers" selector="addClassBytes">addClassBytes	"Display a template for adding a class of type bytes."	self addClassType: #bytes</body><body package="OldBrowsers" selector="addClassFixedSize">addClassFixedSize	"Display a template for adding a class of type fixed size (none)."	self addClassType: #none</body><body package="OldBrowsers" selector="addClassVariableSize">addClassVariableSize	"Display a template for adding a class of type bytes."	self addClassType: #objects</body><body package="OldBrowsers" selector="addNameSpace">addNameSpace	| env cat |	( env:= self  selectedNameSpace ) == nil		ifTrue: [ env := Smalltalk ].	cat := self category.	self browser defType value: #showDefinition.	module nextModule nextModule deselect.	"next module is categories...."	self browser text value: 		( self templateNameSpace: env category: cat )</body><body package="OldBrowsers" selector="fileOut">fileOut	| fileName fileManager nm |	nm := self selection == nil			ifTrue: [(#Definitions &lt;&lt; #dialogs &gt;&gt; 'Definitions') asString]			ifFalse: [self selection name asString].	fileName := Dialog			requestNewFileName: (#fileOutOn &lt;&lt; #dialogs &gt;&gt; 'File out on')			default: (Filename filterFilename: nm, '.st'). 	fileName = '' ifTrue: [^nil].	fileManager := SourceCodeStream write: fileName encoding: self fileEncoding.	[fileManager timeStamp.	fileManager deferInitializations.	self selectedThingsWithOrder:			[:definedObjects |			definedObjects				do: [:thing |					thing fileOutSourceOn: fileManager.					fileManager cr]].	fileManager finishInitializations.	fileManager cr]		ensure: [fileManager close].</body><body package="OldBrowsers" selector="find">find	"Prompt for a name and position myself there."	| obj |	self changeRequest ifFalse: [^self].	obj := self findASomething: (#FindColon &lt;&lt; #labels &gt;&gt; 'Find:').	obj == nil ifTrue: [^self].	obj isBindingReference		ifTrue:			[self browser batchUpdates:				[self browser metaShowData.				obj environment environment isNil					ifTrue: [self module setSelection: nil]					ifFalse: [self module selection: obj environment environment].				self browser selectCategory: obj environment category.				self browser selectBehavior: obj environment.				self browser selectProtocol: (obj environment asNameSpace categoryFor: obj name).				self browser selectMethod: obj name]]		ifFalse: 			[self module selection: obj environment.			module nextModule				select: obj category				whenFinished:					[module nextModule nextModule						select: obj						whenFinished: [module nextModule updateList]]]</body><body package="OldBrowsers" selector="moveTo">moveTo	| newSpace |	newSpace := NameSpaceNavigator				searchFrom: self defaultEnvironment				label: (#MoveToWhichEnvironmentQ &lt;&lt; #dialogs &gt;&gt; 'Move to which environment?').	newSpace == nil		ifTrue: [^self].	module selections do: 		[ :sel | sel relocateTo: newSpace].	module updateList</body><body package="OldBrowsers" selector="remove">remove	"Prompt the user to remove the namespace.  Answer if the namespace was removed or not."	| bindings parentEvironment| 	self changeRequest ifFalse: [^false].	bindings := module selections asArray collect:				[:nm | | ref |				(ref := ((BindingReference simpleName: nm name) home: nm environment)) isDefined					ifTrue: [ref]					ifFalse:						[Dialog warn: ((#CantRemoveObject1sNoLongerExists &lt;&lt; #dialogs &gt;&gt; 'Can''t remove the object. &lt;1s&gt; no longer exists.')										expandMacrosWith: nm asString)							for: self interfaceWindow.						nil]].	bindings := bindings copyWithout: nil.	bindings isEmpty ifTrue: [^false].	bindings := SystemUtils sortForLoading: bindings.	bindings reverseDo:		[:varRef |		(Dialog confirm: ((#DoYouWantToRemove1sQ &lt;&lt; #dialogs &gt;&gt; 'Are you certain that you&lt;n&gt;want to remove &lt;1s&gt;?')					expandMacrosWith: varRef asString)				for: self interfaceWindow)			ifTrue: 				[(varRef subrequisites size = 0					or: [Dialog confirm: ((#HasDependentObjectsRemoveItAnywayQ &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; has dependent objects. Remove it anyway?')									expandMacrosWith: varRef asString)							for: self interfaceWindow])					ifTrue: [parentEvironment := varRef environment.							varRef removeFromSystem. 							module updateListFull.]]].self browser setAndUpdateEnvironment: parentEvironment. module list toggleSelection.		^false</body><body package="OldBrowsers" selector="renameAs">renameAs	| aString newName |	self changeRequest ifFalse: [^self].	aString := self				prompt: (#EnterNewName &lt;&lt; #dialogs &gt;&gt; 'Enter new name')				initially: self selection  name asString.	aString = '' ifTrue: [^self].	aString := SystemUtils validateStaticVariableName: aString					for: self interfaceWindow.	aString == nil ifTrue: [^self].	newName := aString asSymbol.	SmalltalkWorkbench		rename: module selection 		to: newName 		do: [:cls :nm | module select: cls whenFinished: [module updateList]]		for: self interfaceWindow		browser: self browser</body><body package="OldBrowsers" selector="spawn">spawn	self selectionIsSymbol ifTrue: [^self].	self selectionIsClass ifTrue: [^super spawn].	self selectionIsNamespace ifTrue: 		[self browser spawnOnNameSpace: module selection]</body></methods><methods><class-id>Tools.HierarchyBrowserHelper</class-id> <category>text processing</category><body package="OldBrowsers" selector="acceptText:from:">acceptText: text from: textController	"Indicate that we didn't even try."	^self selection == nil		ifTrue: [nil]		ifFalse: [self acceptDefinition: text from: textController]</body><body package="OldBrowsers" selector="text">text	| item |	^( item := self  selectedNameSpace ) == nil		ifTrue: [ Text new ]		ifFalse: 	[ item definition  asText ]</body><body package="OldBrowsers" selector="updateListForDefinedThing:">updateListForDefinedThing: thing	thing isForNameSpace ifTrue:[self module updateList].	self module selection: (thing isForNameSpace ifTrue:[thing] ifFalse:[thing environment]).	module nextModule updateListForDefinedThing: thing</body></methods><methods><class-id>Tools.HierarchyBrowserHelper</class-id> <category>accessing</category><body package="OldBrowsers" selector="selectedNameSpace">selectedNameSpace	^self  selection == nil		ifTrue: [ nil ]		ifFalse: 			[ self selection isSymbol				ifTrue: [ Root ]				ifFalse: [ self selection ]			  ]</body><body package="OldBrowsers" selector="windowLabel">windowLabel	^(#NameSpaceHierarchyBrowserOn1p &lt;&lt; #dialogs &gt;&gt; 'NameSpaceHierarchy Browser on &lt;1p&gt;') expandMacrosWith: self selection value</body></methods><methods><class-id>Tools.HierarchyBrowserHelper</class-id> <category>selections</category><body package="OldBrowsers" selector="defaultAttribute">defaultAttribute	"Answer the default attribute that this helper is responsible for selecting."	^#environment</body></methods><methods><class-id>Tools.HierarchyBrowserHelper</class-id> <category>drag and drop</category><body package="OldBrowsers" selector="canAcceptDropFrom:">canAcceptDropFrom: aDC	^false</body></methods><methods><class-id>Tools.HierarchyBrowserHelper class</class-id> <category>menus accessing</category><body package="OldBrowsers" selector="menuHeader">menuHeader	^(#Namespace &lt;&lt; #menus &gt;&gt; '&amp;Namespace') asString</body></methods><methods><class-id>Tools.NameSpaceHierarchyBrowserHelper</class-id> <category>list accessing</category><body package="OldBrowsers" selector="intializeListFull">intializeListFull	| tree |	tree  := AssociationTreeWithParent key: (#Filters &lt;&lt; #dialogs &gt;&gt; 'Filters') value: #filters.	self addNamespaceTreeToTree: tree.	module setNewListSilently: tree.	"Lets be nice and show all namespaces within Smalltalk"	module list deepOpenCurrentTo:3.</body><body package="OldBrowsers" selector="selectionIsClass">selectionIsClass	^self selection isBehavior</body><body package="OldBrowsers" selector="updateListFull">updateListFull	| tree |	tree  := AssociationTreeWithParent key: (#Filters &lt;&lt; #dialogs &gt;&gt; 'Filters') value: #filters.	self addNamespaceTreeToTree: tree.	module setNewList: tree</body></methods><methods><class-id>Tools.NameSpaceHierarchyBrowserHelper</class-id> <category>drag and drop</category><body package="OldBrowsers" selector="canAcceptDropFrom:">canAcceptDropFrom: aDC	^aDC key == self  classOrNamespaceKey</body><body package="OldBrowsers" selector="drop:">drop: aDragContext	"A drop has occured in the Namespace l list of the browser. see if we can accept and if so move the class(es)."	| ctrl idx cNameArray |	(self canAcceptDropFrom: aDragContext) ifFalse:[^#dragEffectNone ].	self browser changeRequest ifFalse: [^#dropEffectNone].	"Locate the target namspace's index"	ctrl := aDragContext clientData at: #ctrl.	idx := ctrl view targetIndex.	idx = 0 ifTrue: [^#dropEffectNone].	"If the data is not available in the correct format, do not drop."	cNameArray := aDragContext sourceData clientData 				at: self classOrNamespaceKey ifAbsent: [^#dropEffectNone].	"Move the class or namspace to the new Namespace"	"The class name is in the clientData of the dropSource"	cNameArray do:[:eachCName |  eachCName relocateTo: (self module list selectionForIndex: idx).		ChangeSet changeClass: eachCName ].	"Restore the state of the list before leaving."	self restoreListStateFrom: aDragContext clientData.	aDragContext clientData: nil.	self nextModule updateList.	^#dropEffectMove</body></methods><methods><class-id>Tools.NameSpaceHierarchyBrowserHelper</class-id> <category>text processing</category><body package="OldBrowsers" selector="doItEnvironment">doItEnvironment	| selection |	(selection := self selection) isNil ifTrue: [^nil].	^selection environment = Root		ifTrue: [self defaultEnvironment]		ifFalse: [selection environment]</body><body package="OldBrowsers" selector="doItReceiver">doItReceiver	"The receiver's selection can be nil, and that is an acceptable 	receiver for evaluation."	^self selection</body></methods><methods><class-id>Tools.FullNotebookSystemBrowser</class-id> <category>components</category><body package="OldBrowsers" selector="broadcastUpdate:">broadcastUpdate: aspect	self currentSubCanvas broadcastUpdate: aspect</body><body package="OldBrowsers" selector="menuBar">menuBar	| menu |	menu := Menu new		addPart: self class menuBarStart.	coordinator == nil ifFalse: [coordinator buildMenuBar: menu].	self currentSubCanvas notNil ifTrue:[self currentSubCanvas buildMenuBar: menu.].	components do: [:comp |comp buildMenuBar: menu].	menu addPart: self class menuBarEnd.	(menu atNameKey: #edit) submenu: self remoteTextMenu.	(menu atNameKey: #view) submenu: [self viewMenu].	^menu</body><body package="OldBrowsers" selector="menuBarForCategories">menuBarForCategories	| menu |	menu := Menu new		addPart: self class menuBarStart.	coordinator == nil ifFalse: [coordinator buildMenuBar: menu].	self currentTabApplication categoryTabCanvas notNil ifTrue:[self currentTabApplication categoryTabCanvas buildMenuBar: menu.].	components do: [:comp |comp buildMenuBar: menu].	menu addPart: self class menuBarEnd.	(menu atNameKey: #edit) submenu: self remoteTextMenu.	(menu atNameKey: #view) submenu: [self viewMenu].	^menu</body><body package="OldBrowsers" selector="resetToolBar">resetToolBar	| menu menuBar |	self builder isNil ifTrue:[ ^self].	menu := self menuBar.	menuBar := self builder window keyboardProcessor menuBar.	menuBar menuChannel: menu.</body><body package="OldBrowsers" selector="resetToolBarForCategories">resetToolBarForCategories	| menu menuBar |	self builder isNil ifTrue:[ ^self].	menu := self menuBarForCategories.	menuBar := self builder window keyboardProcessor menuBar.	menuBar menuChannel: menu.</body><body package="OldBrowsers" selector="viewMenu">viewMenu	| menu |	menu := Menu new.	self labelApplicationDictionary keysAndValuesDo:		[ :key :appTab | 	appTab buildToolBar: menu ].	currentTabApplication buildViewMenu: menu.	^menu</body><body package="OldBrowsers" selector="windowLabel">windowLabel	^self  currentTabApplication notNil ifTrue:[self currentTabApplication windowLabel] ifFalse:[(#FullSystemBrowser &lt;&lt; #labels &gt;&gt; 'Full System Browser') ]</body></methods><methods><class-id>Tools.FullNotebookSystemBrowser</class-id> <category>change</category><body package="OldBrowsers" selector="changedMajorTab">changedMajorTab	| tabApplication |	self majorTabs selection isNil ifTrue: [^nil].	self selectionIsTabApplicationCategory		ifTrue: 			[self updateMajorTabsListFor: self currentTabApplication.			self setSubCanvasToCategory.			self resetToolBarForCategories]		ifFalse: 			[tabApplication := self tabApplicationForLabel: self majorTabs selection.			self updateMajorTabsListFor: tabApplication.			self currentTabApplication notNil ifTrue: [self currentTabApplication swapIn].			self currentTabApplication: tabApplication.			self currentTabApplication swapOut.			self setSubCanvas.			self swapoutVisualComponents.			self resetToolBar.			self updateWindowLabel.			self currentTabApplication refreshLists]</body><body package="OldBrowsers" selector="selectionIsTabApplicationCategory">selectionIsTabApplicationCategory	^(self labelApplicationDictionary 		detect: [:ea | ea label = self majorTabs selection or: [self majorTabs selection = 'Root']]		ifNone: [nil]) isNil</body><body package="OldBrowsers" selector="setSubCanvas">setSubCanvas	self currentSubCanvas notNil		ifTrue: [ self currentSubCanvas updateForSwapOut ].	self setSubCanvas: self currentSubCanvas spec: self currentTabApplication subCanvasSpec.</body><body package="OldBrowsers" selector="setSubCanvasToCategory">setSubCanvasToCategory		self currentSubCanvas notNil		ifTrue: [ self currentSubCanvas updateForSwapOut ].	self setSubCanvas: self currentTabApplication categoryTabCanvas spec: self currentTabApplication categoryTabCanvas specName.</body><body package="OldBrowsers" selector="swapoutVisualComponents">swapoutVisualComponents	| theSelection componentList tabApplication |	(self builder isNil	or: [(theSelection := self majorTabs selection) isNil]) 		ifTrue: [^self].	tabApplication := self tabApplicationForLabel: theSelection.	componentList := tabApplication rightHandComponents.	1 to: componentList size do: 		[:index | 		| widgetWrapper compsubcanvas compClient |		(widgetWrapper := self builder componentAt: (self componentIDs at: index)) notNil ifTrue: 			[compsubcanvas := widgetWrapper widget.			compClient := componentList at: index.			compClient builder isNil				ifTrue: [compsubcanvas client: compClient spec: compClient specName]				ifFalse: 					[compsubcanvas							client: compClient							spec: compClient specName							builder: compClient builder]]].	components := componentList</body><body package="OldBrowsers" selector="updateButtonLabels">updateButtonLabels	self	updateMajorTabsListFor: self currentTabApplication</body><body package="OldBrowsers" selector="updateMajorTabsList">updateMajorTabsList	| newLabels newIcons |	newLabels := self labels asOrderedCollection.	newLabels add: (self currentTabApplication notNil			ifTrue: [self currentTabApplication categoriesLabel]			ifFalse: [(#NoCategories &lt;&lt; #labels &gt;&gt; 'No Categories')]).	newIcons := self icons.	newIcons add: self currentTabApplication categoryIcon.	self majorTabs setListSilently: newLabels</body><body package="OldBrowsers" selector="updateMajorTabsListFor:">updateMajorTabsListFor: tabApplication 	| newLabels newIcons |	newLabels := self labels asOrderedCollection.	newLabels add: tabApplication categoriesLabel.	newIcons := self icons.	newIcons add: tabApplication categoryIcon.	self majorTabs setListSilently: newLabels.	self builder isNil ifTrue: [^self].	(self builder componentAt: #notebook) widget		icons: newIcons;		setNewLabelsSilently.</body><body package="OldBrowsers" selector="updateParcelLists">updateParcelLists	self currentTabApplication updateLists</body></methods><methods><class-id>Tools.FullNotebookSystemBrowser</class-id> <category>notebook accessing</category><body package="OldBrowsers" selector="currentSubCanvas">currentSubCanvas	^self currentTabApplication isNil		ifTrue: [nil]		ifFalse: [self currentTabApplication canvas]</body><body package="OldBrowsers" selector="currentTabApplication">currentTabApplication	^currentTabApplication</body><body package="OldBrowsers" selector="currentTabApplication:">currentTabApplication: aValue	currentTabApplication := aValue</body><body package="OldBrowsers" selector="icons">icons	^self labelApplicationDictionary collect: [ :ea | ea icon ]</body><body package="OldBrowsers" selector="labels">labels	^self labelApplicationDictionary collect: [:ea | ea label]</body><body package="OldBrowsers" selector="nameSpaceTabApps">nameSpaceTabApps	^self labelApplicationDictionary select: [ :ea | ea isNamspaceTabApp ]</body><body package="OldBrowsers" selector="subCanvases">subCanvases	^labelApplicationDictionary collect: [:eachTabApp | eachTabApp canvas]</body></methods><methods><class-id>Tools.FullNotebookSystemBrowser</class-id> <category>accessing</category><body package="OldBrowsers" selector="componentIDs">componentIDs	^#(#component1#component2 #component3 #component4)</body><body package="OldBrowsers" selector="getLabelApplicationDictionary">getLabelApplicationDictionary	| dict |	dict := Dictionary new.	self tabApplications do:[:each | dict at: each label put:(each newOnBrowser: self)].	^dict</body><body package="OldBrowsers" selector="labelApplicationDictionary">labelApplicationDictionary	^labelApplicationDictionary</body><body package="OldBrowsers" selector="labelApplicationDictionary:">labelApplicationDictionary: aDictionary	labelApplicationDictionary := aDictionary</body><body package="OldBrowsers" selector="searchChildNamespaces">searchChildNamespaces	^searchChildNamespaces isNil ifTrue:[searchChildNamespaces := false] ifFalse:[searchChildNamespaces]</body><body package="OldBrowsers" selector="searchChildNamespaces:">searchChildNamespaces: aBooleen	searchChildNamespaces := aBooleen</body><body package="OldBrowsers" selector="setAndUpdateEnvironment:">setAndUpdateEnvironment: anEnvironment	self	setNameSpaceFor: #default to: anEnvironment.	self nameSpaceTabApps do:[:each | each canvas selection: anEnvironment].</body><body package="OldBrowsers" selector="tabApplications">tabApplications	^tabApplications</body><body package="OldBrowsers" selector="tabApplications:">tabApplications: aDictionary	tabApplications := aDictionary</body></methods><methods><class-id>Tools.FullNotebookSystemBrowser</class-id> <category>private</category><body package="OldBrowsers" selector="areConnectedAndSelected">areConnectedAndSelected	^true</body><body package="OldBrowsers" selector="resetTabs">resetTabs	| oldSelection newLabels |	oldSelection := self majorTabs selection.	newLabels := self labels asOrderedCollection.	newLabels add: (self currentTabApplication notNil ifTrue:[self currentTabApplication categoriesLabel] ifFalse:[ (#NoCategories &lt;&lt; #labels &gt;&gt; 'No Categories')]).	self majorTabs list: newLabels.	(newLabels includes: oldSelection)		ifTrue: [ self majorTabs selection: oldSelection ].	self majorTabs selection isNil		ifTrue: [ self majorTabs selectionIndex: 1 ].	self changedMajorTab</body><body package="OldBrowsers" selector="setSubCanvas:spec:">setSubCanvas: aClient spec: aSymbol 	| localClient localSymbol notebookSubcanvas |	self builder isNil ifTrue: [^self].	localClient := aClient.	localSymbol := aSymbol.	notebookSubcanvas := (self builder componentAt: #notebook) widget.	localClient builder isNil		ifTrue: [notebookSubcanvas client: localClient spec: localSymbol]		ifFalse: [notebookSubcanvas				client: localClient				spec: localSymbol				builder: localClient builder].	localClient postOpenWith: localClient builder</body><body package="OldBrowsers" selector="setSubCanvas:withSpec:">setSubCanvas: aClient withSpec: aSpec	self currentSubCanvas notNil		ifTrue: [ self currentSubCanvas updateForSwapOut ].	self setSubCanvas: aClient spec: aSpec.</body><body package="OldBrowsers" selector="tabApplicationForLabel:">tabApplicationForLabel: aString 	^self labelApplicationDictionary 		detect: [:ea | ea label = aString]		ifNone: [self labelApplicationDictionary detect: [:ea | ea isNamspaceTabApp]]</body><body package="OldBrowsers" selector="tryAll:default:">tryAll: testBlock default: defaultBlock	| val |	components reverseDo:		[:comp | | val |		val := testBlock value: comp.		val == nil ifFalse: [^val]].	self currentSubCanvas isNil ifFalse:		[val := testBlock value: self currentSubCanvas.		val == nil ifFalse: [^val]].	^defaultBlock value</body></methods><methods><class-id>Tools.FullNotebookSystemBrowser</class-id> <category>aspects</category><body package="OldBrowsers" selector="majorTabs">majorTabs	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^majorTabs isNil		ifTrue:			[majorTabs := ColorTextSelectionInList new]		ifFalse:			[majorTabs]</body></methods><methods><class-id>Tools.FullNotebookSystemBrowser</class-id> <category>interface opening</category><body package="OldBrowsers" selector="interfaceName">interfaceName	^#windowSpec5</body><body package="OldBrowsers" selector="postOpenWith:">postOpenWith: aBuilder	| old |	super postOpenWith: aBuilder.	disableBatchUpdates := true.	[ self changedMajorTab ]		ensure: [ disableBatchUpdates := false ].	old := self currentTabApplication.	[self  labelApplicationDictionary		do:			[:each |			self currentTabApplication: each.			each intializeListFull.			self updateMajorTabsListFor: self currentTabApplication]]		ensure:			[self currentTabApplication: old]</body></methods><methods><class-id>Tools.FullNotebookSystemBrowser</class-id> <category>actions</category><body package="OldBrowsers" selector="displayAboutBox">displayAboutBox	self notYetImplemented</body><body package="OldBrowsers" selector="module:action:">module: moduleName action: action 	(coordinator notNil	and: [coordinator menuHeader = moduleName]) ifTrue: 		[^coordinator perform: action].	self currentSubCanvas menuHeader = moduleName ifTrue:		[^self currentSubCanvas dispatch: action].	self categoryTabCanvas menuHeader = moduleName ifTrue: 		[^self categoryTabCanvas dispatch: action].	components do: [:comp | comp menuHeader = moduleName ifTrue: [^comp dispatch: action]].	self error: (#ThisMenuItemIsNotSupported &lt;&lt; #dialogs &gt;&gt; 'This menu item is not supported')</body><body package="OldBrowsers" selector="module:action:with:">module: moduleName action: action with: value	(coordinator notNil and: [coordinator menuHeader = moduleName])		ifTrue: [^coordinator dispatch: action with: value].	self currentSubCanvas  menuHeader = moduleName ifTrue: [^self currentSubCanvas dispatch: action with: value].self categoryTabCanvas  menuHeader = moduleName ifTrue: [^self currentSubCanvas dispatch: action ].	components do: [:comp |		comp menuHeader = moduleName			ifTrue: [^comp dispatch: action with: value]].	self error: (#ThisMenuItemIsNotSupported &lt;&lt; #dialogs &gt;&gt; 'This menu item is not supported')</body><body package="OldBrowsers" selector="toggleNamespaceList">toggleNamespaceList	self currentTabApplication isNamspaceTabApp ifTrue:[self  currentTabApplication canvas list toggleSelection]</body><body package="OldBrowsers" selector="truePerformerFor:">truePerformerFor: moduleName	"Answer the module that is responsible for performing menu 	actions for moduleName. Answer the receiver if none."	self currentSubCanvas menuHeader = moduleName ifTrue:[^self currentSubCanvas ].self categoryTabCanvas  menuHeader = moduleName ifTrue: [^self categoryTabCanvas ].	components do: 		[ :comp | 		comp menuHeader = moduleName			ifTrue: [ ^comp ]		].	^nil</body><body package="OldBrowsers" selector="updateAllCanvases">updateAllCanvases	| old |	old := self currentTabApplication.	[self labelApplicationDictionary		do: 			[:each | 			self currentTabApplication: each.			each updateList]]		ensure: [self currentTabApplication: old]</body><body package="OldBrowsers" selector="updateNamespaceListFull">updateNamespaceListFull	| old |	old := self currentTabApplication.	[self labelApplicationDictionary do: [:each | each isNamspaceTabApp ifTrue: [each updateList]]]		ensure: [self currentTabApplication: old].	self updateMajorTabsList</body></methods><methods><class-id>Tools.FullNotebookSystemBrowser</class-id> <category>text processing</category><body package="OldBrowsers" selector="batchUpdates:">batchUpdates: aBlock	| old |	self disableBatchUpdates  ifTrue:[^self].	old := inBatchMode.	inBatchMode := true.	aBlock ensure: [inBatchMode := old].	old ifFalse: [self updateText].</body></methods><methods><class-id>Tools.FullNotebookSystemBrowser</class-id> <category>spawning</category><body package="OldBrowsers" selector="spawnForMethodsLabel:list:initialSelection:">spawnForMethodsLabel: aLabel list: list initialSelection: selection 	self currentTabApplication		spawnForMethodsLabel: aLabel		list: list		initialSelection: selection		with: self currentTabApplication</body><body package="OldBrowsers" selector="spawnOnClass:">spawnOnClass:  aClass	self currentTabApplication spawnOnClass: aClass with: self currentTabApplication</body><body package="OldBrowsers" selector="spawnOnClass:protocol:">spawnOnClass:  aClass protocol: aSelection	self currentTabApplication spawnOnClass: aClass with: self currentTabApplication protocol: aSelection</body><body package="OldBrowsers" selector="spawnOnClassHierarchy:">spawnOnClassHierarchy: aClass	self currentTabApplication spawnOnClassHierarchy: aClass with: self currentTabApplication</body><body package="OldBrowsers" selector="spawnOnNameSpace:">spawnOnNameSpace:  aNamespace	self currentTabApplication 		spawnOnNameSpace: aNamespace 		with: self currentTabApplication</body><body package="OldBrowsers" selector="spawnOnNameSpaces:category:">spawnOnNameSpaces: aNamespace category: aCategory  	self currentTabApplication 		spawnOnNameSpace: aNamespace 		with: self currentTabApplication 		category: aCategory</body></methods><methods><class-id>Tools.FullNotebookSystemBrowser</class-id> <category>selection utlity</category><body package="OldBrowsers" selector="selectBehavior:">selectBehavior: aBehaviorself currentTabApplication selectBehavior: aBehavior</body><body package="OldBrowsers" selector="selectCategory:">selectCategory: aCategoryself currentTabApplication selectCategory: aCategory</body><body package="OldBrowsers" selector="selectMethod:">selectMethod: aSymbolself currentTabApplication  selectMethod: aSymbol</body><body package="OldBrowsers" selector="selectProtocol:">selectProtocol: aProtocolself currentTabApplication selectProtocol: aProtocol</body></methods><methods><class-id>Tools.FullNotebookSystemBrowser</class-id> <category>initialize-release</category><body package="OldBrowsers" selector="initialize">initialize	self initializeColorSelections.	self majorTabs selectionIndexHolder onChangeSend: #changedMajorTab to: self.	super initialize.</body><body package="OldBrowsers" selector="initializeColorSelections">initializeColorSelections	self majorTabs		applyListColor: ColorValue black		selectedColor: ColorValue red		disabledItemsColor: ColorValue gray</body><body package="OldBrowsers" selector="initializeForSystem">initializeForSystem	self tabApplications: self class applicationTabs.	disableBatchUpdates := true.	self initializeTabs.</body><body package="OldBrowsers" selector="initializeForTabApplications:">initializeForTabApplications: aCollectionOfTabApplications	self tabApplications: aCollectionOfTabApplications.	disableBatchUpdates := true.	self initializeTabs.</body><body package="OldBrowsers" selector="initializeTabs">initializeTabs	self labelApplicationDictionary: self getLabelApplicationDictionary.	self resetTabs</body><body package="OldBrowsers" selector="release">release	super release.	self majorTabs selectionIndexHolder removeDependent: self.	self labelApplicationDictionary notNil ifTrue:		[self labelApplicationDictionary do: [:each | each release]].	self components notNil ifTrue:		[self components do:[:each | each release]].	components := nil.</body></methods><methods><class-id>Tools.FullNotebookSystemBrowser</class-id> <category>delegating</category><body package="OldBrowsers" selector="doesNotUnderstand:">doesNotUnderstand: aMessage 	"Delegates anything I don't understand to the current tab application. This 	allows adding Tab Applications that don't conflict with each other easier."	| tabApp |	tabApp := self currentTabApplication.	(tabApp respondsTo: aMessage selector)		ifFalse: [^super doesNotUnderstand: aMessage].	^tabApp perform: aMessage selector withArguments: aMessage arguments</body></methods><methods><class-id>Tools.FullNotebookSystemBrowser class</class-id> <category>application configuration</category><body package="OldBrowsers" selector="addApplicationTab:">addApplicationTab: aBrowserTabApplicationself applicationTabs add: aBrowserTabApplication</body><body package="OldBrowsers" selector="applicationTabs">applicationTabs	^ApplicationTabs isNil ifTrue:[ApplicationTabs := OrderedCollection new ] ifFalse:[ApplicationTabs]</body><body package="OldBrowsers" selector="getLabelApplicationDictionaryFor:">getLabelApplicationDictionaryFor: aBrowser	| dict |	dict := Dictionary new.	self applicationTabs do:[:each | dict at: each label put:(each newOnBrowser: aBrowser)].	^dict</body><body package="OldBrowsers" selector="removeApplicationTab:">removeApplicationTab: aBrowserTabApplicationself applicationTabs remove: aBrowserTabApplication</body></methods><methods><class-id>Tools.FullNotebookSystemBrowser class</class-id> <category>initialization</category><body package="OldBrowsers" selector="initialize">initialize	"self initialize"	self addApplicationTab: ParcelTabApplication.	self addApplicationTab: NamespaceTabApplication.</body></methods><methods><class-id>Tools.FullNotebookSystemBrowser class</class-id> <category>actions</category><body package="OldBrowsers" selector="openNormal">openNormal" self openNormal"	^self new		initializeForTabApplications: (Array with: NamespaceTabApplication);		open</body><body package="OldBrowsers" selector="openOnParcels">openOnParcels" self openOnParcels"	^self new		searchChildNamespaces: true;		initializeForTabApplications: (Array with: ParcelTabApplication);		open</body><body package="OldBrowsers" selector="openOnParcelsAndNamespaces">openOnParcelsAndNamespaces	"self openOnParcelsAndNamespaces"	| browser |	browser := self new initializeForTabApplications:		(Array with:NamespaceTabApplication with: ParcelTabApplication).	browser majorTabs selectionIndex: 2.	browser open</body><body package="OldBrowsers" selector="openOnSystem">openOnSystem" self openOnSystem"	^self new		initializeForTabApplications: self applicationTabs;		open</body></methods><methods><class-id>Tools.Emphasizer</class-id> <category>private-status</category><body package="OldBrowsers" selector="classOrNameSpaceStatus:criteria:">classOrNameSpaceStatus: anObject  criteria: criteria	^anObject isForClass		ifTrue: [ self classStatus: anObject criteria: criteria ]		ifFalse: [ self nameSpaceStatus: anObject criteria: criteria ]</body><body package="OldBrowsers" selector="dataDefinitionStatus:criteria:">dataDefinitionStatus: aStaticDef  criteria: package 	^#( )		"the default highlighting is none."</body><body package="OldBrowsers" selector="methodDefinitionStatus:criteria:">methodDefinitionStatus: aMethodDef  criteria: package 	^self 		selectorStatus: aMethodDef selector 		class: aMethodDef implementingClass		criteria: package</body></methods><methods><class-id>Tools.Emphasizer</class-id> <category>api</category><body package="OldBrowsers" selector="emphasisForCategory:for:id:">emphasisForCategory: aCategory for: aBrowser id: selectionId	"Answer the emphasis set for aCategory displayed in aBrowser with a selectionId."	| criteria |	( criteria := self currentCriteria: aBrowser id: selectionId ) == nil		ifTrue: [ ^#( #norm ) ].	^self  mapStatusToEmphasis:			( self categoryStatus: aCategory in: nil criteria: criteria ).</body><body package="OldBrowsers" selector="emphasisForCategory:in:for:id:">emphasisForCategory: aCategory in: anEnvironment for: aBrowser id: selectionId	"Answer the emphasis set for aCategory displayed in aBrowser with a selectionId."	| criteria |	( criteria := self currentCriteria: aBrowser id: selectionId ) == nil		ifTrue: [ ^#( #norm ) ].	^self  mapStatusToEmphasis:			( self categoryStatus: aCategory in: anEnvironment criteria: criteria ).</body><body package="OldBrowsers" selector="emphasisForClassButtons:for:id:">emphasisForClassButtons: aBehavior for: aBrowser id: selectionId	"Answer an array of emphasis sets for aBehavior (class or metaclass)	for the instance, class and static buttons."	| criteria ref |	( ( ( criteria := self currentCriteria: aBrowser id: selectionId ) == nil ) or: [ aBehavior == nil ] ) 		ifTrue: [ ^#( #( #norm ) #( #norm ) #( norm ) ) ].	ref := aBehavior isForNameSpace		ifTrue: [ aBehavior namedReferent ] 		ifFalse: [ aBehavior ].	^ref isForNameSpace		ifTrue: 			[ Array 				with: #( #norm ) 				with: #( #norm )				with: ( self  mapStatusToEmphasis: ( self classDataStatus: ref criteria: criteria  ) )			]		ifFalse:			[ ^Array 				with: ( self  mapStatusToEmphasis: 						( self behaviorStatus: ref instanceBehavior criteria: criteria  ) )				with: ( self  mapStatusToEmphasis: 						( self behaviorStatus: ref classBehavior criteria: criteria  ) )				with: ( self  mapStatusToEmphasis: 						( self classDataStatus: ref instanceBehavior criteria: criteria  ) )			]</body><body package="OldBrowsers" selector="emphasisForClassOrNameSpace:for:id:">emphasisForClassOrNameSpace: aClassOrNameSpace for: aBrowser id: selectionId	"Answer the emphasis set for aClassOrNameSpace displayed in aBrowser with a selectionId."	| criteria |	( criteria := self currentCriteria: aBrowser id: selectionId ) == nil		ifTrue: [ ^#( #norm ) ].	^self  mapStatusToEmphasis:			( self 			classOrNameSpaceStatus: aClassOrNameSpace  			criteria: criteria		).</body><body package="OldBrowsers" selector="emphasisForMethodDefinition:for:id:">emphasisForMethodDefinition: aMethodDef for: aBrowser id: selectionId	"Answer the emphasis set for aMethodDef displayed in aBrowser with a selectionId."	| criteria |	( criteria := self currentCriteria: aBrowser id: selectionId ) == nil		ifTrue: [ ^#( #norm ) ].	^self  mapStatusToEmphasis: 		( self methodDefinitionStatus: aMethodDef criteria: criteria )</body><body package="OldBrowsers" selector="emphasisForProtocol:for:id:">emphasisForProtocol: aProtocol for: aBrowser id: selectionId	"Answer the emphasis set for aProtocol displayed in aBrowser with a selectionId."	| criteria owner status |	( criteria := self currentCriteria: aBrowser id: selectionId ) == nil		ifTrue: [ ^#( #norm ) ].	( owner := aBrowser selectedClassOrNameSpaceFor: selectionId ) == nil		ifTrue: [ ^#( #norm ) ].	status := ( owner isForNameSpace or: [ aBrowser isData ] )		ifTrue: [ self dataProtocolStatus: aProtocol owner: owner criteria: criteria ]		ifFalse: [ self methodProtocolStatus: aProtocol class: owner criteria: criteria ].	^self  mapStatusToEmphasis: status.</body><body package="OldBrowsers" selector="emphasisForSelector:for:id:">emphasisForSelector: aSelector for: aBrowser id: selectionId	"Answer the emphasis set for aSelector displayed in aBrowser with a selectionId."	| criteria |	( criteria := self currentCriteria: aBrowser id: selectionId ) == nil		ifTrue: [ ^#( #norm ) ].	^self  mapStatusToEmphasis:			( self			selectorStatus: aSelector 			class: ( aBrowser selectedClassOrNameSpaceFor: selectionId )			criteria: criteria		)</body><body package="OldBrowsers" selector="emphasisForSelectorProtocol:for:id:">emphasisForSelectorProtocol: aProtocol for: aBrowser id: selectionId	"Answer the emphasis set for aProtocol displayed in aBrowser with a selectionId."	| criteria |	( criteria := self currentCriteria: aBrowser id: selectionId ) == nil		ifTrue: [ ^#( #norm ) ].	^self  mapStatusToEmphasis:			( self 			methodProtocolStatus: aProtocol 			class: ( aBrowser selectedClassOrNameSpaceFor: selectionId )			criteria: criteria		)</body><body package="OldBrowsers" selector="emphasisForStaticDefinition:for:id:">emphasisForStaticDefinition: aStaticDef for: aBrowser id: selectionId	"Answer the emphasis set for aStaticDef displayed in aBrowser with a selectionId."	| criteria |	( criteria := self currentCriteria: aBrowser id: selectionId ) == nil		ifTrue: [ ^#( #norm ) ].	^self  mapStatusToEmphasis: ( self dataDefinitionStatus: aStaticDef criteria: criteria )</body><body package="OldBrowsers" selector="emphasisForStaticKey:for:id:">emphasisForStaticKey: aStaticKey for: aBrowser id: selectionId	"Answer the emphasis set for aStaticKey displayed in aBrowser with a selectionId."	| criteria |	( criteria := self currentCriteria: aBrowser id: selectionId ) == nil		ifTrue: [ ^#( #norm ) ].	^self  mapStatusToEmphasis:			( self 		dataKeyStatus: aStaticKey 			owner: ( aBrowser selectedClassOrNameSpaceFor: selectionId )			criteria: criteria		)</body></methods><methods><class-id>Tools.Emphasizer</class-id> <category>private</category><body package="OldBrowsers" selector="currentCriteria:id:">currentCriteria: aBrowser id: selectionId	"Answer what we are highlighting based on."		^nil	"Ensures that the default Emphasizer adds no emphasis."</body><body package="OldBrowsers" selector="emphasisForAttribute:">emphasisForAttribute: status	"Answer an array of emphasis for a status. Default mapping is:		#entirelyDefined 	bold &amp; underline		#defined			bold		#definedByOther	italic		#extended			bold		#extendedByOther	italic		#conflict			red "	( ( #extended ==  status ) or: [ #defined == status] ) 		ifTrue: [ ^#( bold ) ].	#entirelyDefined == status 		ifTrue: [ ^#( #bold #underline ) ].	( ( #definedByOther == status ) or: [ #extendedByOther == status ] ) 		ifTrue: [ ^( #italic ) ].	#conflict == status 		ifTrue: [ ^Array with: ( #color-&gt;ColorValue red ) ] .	#notFound == status 		ifFalse: [ Transcript cr; print: status; endEntry ].	^#( #strikeout ) "as an error indication"</body><body package="OldBrowsers" selector="manager">manager	self subclassResponsibility</body><body package="OldBrowsers" selector="mapStatusToEmphasis:">mapStatusToEmphasis: statusSet	"Answer an array of emphasis for statusSet.	Status is: 		#entirelyDefined 			#defined  		#definedByOther			#extended					#extendedByOther			#conflict"	| emphasis |	emphasis := Set new: 4.	statusSet do: 		[ :status | emphasis addAll: ( self emphasisForAttribute: status ) ].	^emphasis asArray</body></methods><methods><class-id>Tools.ParcelEmphasizer</class-id> <category>private-status</category><body package="OldBrowsers" selector="behaviorStatus:criteria:">behaviorStatus: aBehavior criteria: aParcel	"Compute the status for a Behavior (class or metaclass)."	| parcels status definedCount extendedCount |	status := Set new: 4.	aBehavior isNil ifTrue: [ ^status "shouldn't happen" ].	parcels := self manager parcelsForClassOrNameSpace: aBehavior.	nil == parcels ifTrue: [ ^status ].	definedCount := extendedCount := 0.	parcels do:		[ :parcel |		( parcel definesClass: aBehavior ) 			ifTrue:				[ definedCount := definedCount + 1.				status add: ( parcel == aParcel ifTrue: [ #defined ] ifFalse: [ #definedByOther ] ).				( parcel == aParcel				and: [((aBehavior isMeta					   or: [aBehavior hasClassPool not])						ifTrue: [true]						ifFalse: [nil == (aBehavior classVarNames											detect: [:cvn| (parcel definesName: cvn in: aBehavior) not]											ifNone: [])])				and: [ | defined selectors |					"This is a performance-critical piece of code since it dominates					 computing category emphases for categories that are entirely					 defined by a Parcel.  Hence there is some effort to optimize					 the comparison of defined and implemented selectors."					defined := parcel definedSelectorsFor: aBehavior.					selectors := aBehavior organization elements.					defined size = selectors size				and: [nil == (selectors detect: [:sel| (defined includes: sel) not] ifNone: [])]]]) 						ifTrue: [ status add: #entirelyDefined ] 				].		( parcel extendsBehavior: aBehavior) 			ifTrue:				[ extendedCount := extendedCount + 1.				status add: (parcel == aParcel 					ifTrue: [ #extended ] 					ifFalse: [ #extendedByOther ] )				]		].		( definedCount &gt; 1 	"more than one parcel defines the behavior"				or: [ definedCount + extendedCount &gt; 1 "may be multiply parcelled selectors - go check"				and: [(self computeConflictsFor: ( Array with: aBehavior  ) within: nil) first size &gt; 0]])			ifTrue: [ status add: #conflict ].	^status</body><body package="OldBrowsers" selector="categoryStatus:in:criteria:">categoryStatus: aCategory  in: environment criteria: aParcel	"Compute the status for aCategory."	| list status definedEntirely |	status := Set new: 4.	environment == nil 		ifTrue: 			[ list := OrderedCollection new.			Root withAllNameSpaces do: 				[ :env | list addAll: ( env organization thingsAtCategoryNamed: aCategory ) ].			]		ifFalse: [ list := ( environment organization thingsAtCategoryNamed: aCategory ) ].	list := list reject:[ :each | each ==nil ].	list isEmpty ifTrue: [ ^status ].	definedEntirely := true.	list do: 		[ :aThing |  | thingStatus |		thingStatus := aThing isForNameSpace			ifTrue: [ self nameSpaceStatus: aThing criteria: aParcel ]			ifFalse:				[ aThing isForClass					ifTrue: [ self classStatus: aThing criteria: aParcel ]					ifFalse: [ #( #entirelyDefined ) ].	"ignore bindings"				].		definedEntirely := definedEntirely and: [ thingStatus includes: #entirelyDefined ].		status addAll: thingStatus		].	definedEntirely ifFalse: [ status remove: #entirelyDefined ifAbsent: nil ].	^status</body><body package="OldBrowsers" selector="classDataStatus:criteria:">classDataStatus: aClass  criteria: aParcel	"Compute the status for a Class's static variables."	| parcels status definedCount names |	status := Set new: 4.	aClass isNil ifTrue: [ ^status "shouldn't happen" ].	names := aClass asNameSpace localBindingNames.	names isEmpty 		ifTrue: [ ( aParcel definesClass: aClass )					ifTrue: [ status add: #entirelyDefined ].		"why?"				^status				].	parcels := self manager parcelsForClassOrNameSpace: aClass.	nil == parcels ifTrue: [ ^status ].	definedCount := 0.	parcels do:		[ :parcel| | defined |		( defined := parcel definedNamesFor: aClass) size &gt; 0 			ifTrue:				[ definedCount := definedCount + 1.				parcel == aParcel					ifTrue:						["This is a performance-critical piece of code since it dominates						 computing category emphases for categories that are entirely						 defined by a Parcel.  Hence there is some effort to optimize						 the comparison of defined and implemented names."						status add: (((parcel definesClass: aClass)									and: [defined size = names size									and: [nil == (names detect: [:name| (defined includes: name) not] ifNone: nil)]])							ifTrue: [#entirelyDefined]							ifFalse: [#defined])]					ifFalse: [status add: #extendedByOther]].	( definedCount &gt; 1 "more than one parcel defines data in aClass"			and: [ (self computeDataConflictsFor: (Array with: aClass) within: nil) first size &gt; 0])		ifTrue:[ status add: #conflict ]].	^status</body><body package="OldBrowsers" selector="classStatus:criteria:">classStatus: aClass  criteria: aParcel	"Compute the status for a Class."	| classStatus metaclassStatus entirelyDefined |	classStatus := self behaviorStatus: aClass criteria: aParcel.	metaclassStatus := self behaviorStatus: aClass class criteria: aParcel.	entirelyDefined := (classStatus includes: #entirelyDefined)							and: [metaclassStatus includes: #entirelyDefined].	classStatus addAll: metaclassStatus.	entirelyDefined ifFalse: [classStatus remove: #entirelyDefined ifAbsent: nil].	^classStatus</body><body package="OldBrowsers" selector="dataKeyStatus:owner:criteria:">dataKeyStatus: aKey owner: anOwner criteria: aParcel	"Compute the status for a data key in a given class/namespace with respect to 	the parcels in manager and aParcelOrNil."	| status parcels count |	status := Set new: 4.	(nil == anOwner or: [nil == aKey]) ifTrue: [^status].	nil == (parcels := self manager parcelsForClassOrNameSpace: anOwner) ifFalse:		[count := 0.		parcels do:			[:p|			(p definesName: aKey in: anOwner) ifTrue:				[count := count + 1.				status add: (aParcel == p ifTrue: [#defined] ifFalse: [#definedByOther])]].		count &gt; 1 ifTrue: [status add: #conflict]].	^status</body><body package="OldBrowsers" selector="dataProtocolStatus:owner:criteria:">dataProtocolStatus: aSymbol owner: aClassOrNameSpace criteria: aParcel	"Compute the status for a data protocol in a class."	| thingsInProtocol status parcels |	status := Set new: 4.	nil == aClassOrNameSpace ifTrue: [^status].	thingsInProtocol := aClassOrNameSpace asNameSpace organization listAtCategoryNamed: aSymbol.	( thingsInProtocol isEmpty			or: [nil == (parcels := self manager parcelsForClassOrNameSpace: aClassOrNameSpace)]) 		ifTrue: [ ^status ].	"Assume entirely defined; search for exceptions in the loop below."	(aParcel notNil	and: [parcels includes: aParcel]) ifTrue:		[status add: #entirelyDefined].	thingsInProtocol do:		[:aThing| | count |		count := 0.		parcels do:			[:p|			(p definesName: aThing in: aClassOrNameSpace)				ifTrue:					[count := count + 1.					status add: (aParcel == p ifTrue: [#defined] ifFalse: [#definedByOther])]				ifFalse: [aParcel == p ifTrue: [status remove: #entirelyDefined ifAbsent: nil]]].		count &gt; 1 ifTrue: [status add: #conflict]].	^status</body><body package="OldBrowsers" selector="definedThingStatus:criteria:">definedThingStatus: anObject  criteria: aParcel	"Compute the status for a Static."	| status definedCount |	status := Set new: 4.	anObject isNil ifTrue: [ ^status "shouldn't happen"].	definedCount := 0.	self manager parcels do:		[ :parcel |		( parcel definesObject: anObject) 			ifTrue:				[ definedCount := definedCount + 1.				status add: (parcel == aParcel ifTrue: [#defined] ifFalse: [#definedByOther]).				( parcel == aParcel) 					ifTrue: [ status add: #entirelyDefined ]				]		].	(definedCount &gt; 1 "more than one parcel defines the behavior") ifTrue:		[status add: #conflict].	^status</body><body package="OldBrowsers" selector="methodProtocolStatus:class:criteria:">methodProtocolStatus: aSymbol class: aClass criteria: currentParcel	"Compute the status for a message protocol in a class."	| selectorsInProtocol status parcels |	status := Set new: 4.	nil == aClass ifTrue: [^status].	selectorsInProtocol := aClass organization listAtCategoryNamed: aSymbol.	(selectorsInProtocol isEmpty	or: [nil == (parcels := self manager parcelsForClassOrNameSpace: aClass)]) ifTrue:		[^status].	"Assume entirely defined; search for exceptions in the loop below."	(currentParcel notNil	and: [parcels includes: currentParcel]) ifTrue:		[status add: #entirelyDefined].	selectorsInProtocol do:		[:aSelector| | count |		count := 0.		parcels do:			[:p|			(p definesSelector: aSelector forClass: aClass)				ifTrue:					[count := count + 1.					status add: (currentParcel == p ifTrue: [#defined] ifFalse: [#definedByOther])]				ifFalse: [currentParcel == p ifTrue: [status remove: #entirelyDefined ifAbsent: nil]]].		count &gt; 1 ifTrue: [status add: #conflict]].	^status</body><body package="OldBrowsers" selector="nameSpaceStatus:criteria:">nameSpaceStatus: anObject  criteria: aParcel	"Compute the status for a NameSpace."	| status definedCount |	status := Set new: 4.	anObject isNil ifTrue: [ ^status "shouldn't happen"].	definedCount := 0.	self manager parcels do:		[ :parcel |		( parcel definesObject: anObject) 			ifTrue:				[ definedCount := definedCount + 1.				status add: (parcel == aParcel ifTrue: [#defined] ifFalse: [#definedByOther]).				( parcel == aParcel) 					ifTrue: [ status add: #entirelyDefined ]				]		].	(definedCount &gt; 1 "more than one parcel defines the behavior") ifTrue:		[status add: #conflict].	^status</body><body package="OldBrowsers" selector="selectorStatus:class:criteria:">selectorStatus: aSelector class: aClass  criteria: aParcel 	"Compute the status for a selector in a given classwith respect to the parcels	 in manager and aParcelOrNil."	| status parcels count |	status := Set new: 4.	(nil == aClass or: [nil == aSelector]) ifTrue: [^status].	nil == (parcels := self manager parcelsForClassOrNameSpace: aClass) ifFalse:		[count := 0.		parcels do:			[:p|			(p definesSelector: aSelector forClass: aClass) ifTrue:				[count := count + 1.				status add: (aParcel == p ifTrue: [#defined] ifFalse: [#definedByOther])]].		count &gt; 1 ifTrue: [status add: #conflict]].	^status</body></methods><methods><class-id>Tools.ParcelEmphasizer</class-id> <category>private</category><body package="OldBrowsers" selector="computeConflictsFor:within:">computeConflictsFor: aSetOfClasses within: aSetOfParcelsOrNil	"Answer a triple of a Set of MethodDefinitions identifying all methods that are	 multiply parcelled, a Set of statics that are multiply parcelled, and a Set	 of classes that either contain multiply parcelled methods or are themselves	 multiply parcelled.  If aSetOfParcelsOrNil is non-nil then only include conflicts	 that are parcelled within aSetOfParcels	 Express the triple as an Array, method definitions first, bindings next, classes last."	| methods bindings classes |	methods := Set new: 64.	bindings := IdentitySet new: 8.	classes := IdentitySet new: 4.	aSetOfClasses do:		[:class| | parcels |		(parcels := self manager parcelsForClassOrNameSpace: class) notNil ifTrue:			[| instanceSelectorBag classSelectorBag staticBag classBag |			instanceSelectorBag := Bag identityNew: 32.			classSelectorBag := Bag identityNew: 32.			staticBag := Bag identityNew: 4.			classBag := Bag identityNew: 2.			parcels do:				[:parcel|				(parcel definesClass: class) ifTrue: [classBag add: class].				instanceSelectorBag addAll: (parcel definedSelectorsFor: class).				classSelectorBag addAll: (parcel definedSelectorsFor: class class).				staticBag addAll: (parcel definedBindingsFor: class)].			instanceSelectorBag valuesAndCountsDo:				[:sel :count|				(count &gt; 1				and: [aSetOfParcelsOrNil isNil						or: [aSetOfParcelsOrNil contains: [:parcel| parcel definesSelector: sel forClass: class]]])					ifTrue:						[classes add: class.						methods add: (MethodDefinition class: class selector: sel)]].			classSelectorBag valuesAndCountsDo:				[:sel :count|				(count &gt; 1				and: [aSetOfParcelsOrNil isNil						or: [aSetOfParcelsOrNil contains: [:parcel| parcel definesSelector: sel forClass: class class]]])					ifTrue:						[classes add: class.						methods add: (MethodDefinition class: class class selector: sel)]].			classBag valuesAndCountsDo:				[:clss :count|				(count &gt; 1				and: [aSetOfParcelsOrNil isNil						or: [aSetOfParcelsOrNil contains: [:parcel| parcel definesClass: class]]])					ifTrue:						[classes add: class]].			staticBag valuesAndCountsDo:				[:binding :count|				(count &gt; 1				and: [aSetOfParcelsOrNil isNil						or: [aSetOfParcelsOrNil contains: [:parcel| parcel definesClass: class]]])					ifTrue:						[bindings add: binding.						classes add: class]]]].	^Array with: methods with: bindings with: classes</body><body package="OldBrowsers" selector="computeDataConflictsFor:within:">computeDataConflictsFor: aSetOfClasses within: aSetOfParcelsOrNil	"Answer a Set of statics that are multiply parcelled	return and Array with a Set of statics that have conflicts"	| bindings |	bindings := IdentitySet new: 8.	aSetOfClasses do:		[:class| | parcels |		(parcels := self manager parcelsForClassOrNameSpace: class) notNil ifTrue:			[|  staticBag  |			staticBag := Bag identityNew: 4.			parcels do:				[:parcel|				staticBag addAll: (parcel definedBindingsFor: class)].			staticBag valuesAndCountsDo:				[:binding :count|				(count &gt; 1				and: [aSetOfParcelsOrNil isNil						or: [aSetOfParcelsOrNil contains: [:parcel| parcel definesClass: class]]])					ifTrue:						[bindings add: binding]]]].	^Array with: bindings</body><body package="OldBrowsers" selector="currentCriteria:id:">currentCriteria: aBrowser id: selectionId	"Answer what we are highlighting based on."		^aBrowser selectedParcelFor: selectionId</body><body package="OldBrowsers" selector="manager">manager	^Parcel</body></methods><methods><class-id>Tools.ClassesBrowserHelper</class-id> <category>menus accessing</category><body package="OldBrowsers" selector="actionsForMultiSelect">actionsForMultiSelect	^#(#fileOut #hardcopy #add #browseClass #move #remove)</body><body package="OldBrowsers" selector="buildViewMenu:">buildViewMenu: aMenu	| menu |	menu := self class metaMenu.	menu menuItems do: [:i |		i labelImage: nil.		i indication: self browser meta value == i nameKey].	aMenu addPart: menu.	menu := self class defTypeMenu.	menu menuItems do: [:i |		i labelImage: nil.		i indication: (self browser defType value = i value)].	aMenu addPart: menu</body><body package="OldBrowsers" selector="setEnablement:">setEnablement: menu	"Set the menu's items enabled/disabled state."	"Don't override a menu items particular enablement"	| item |	menu enablementSelector == nil		ifFalse: [ ^menu ].	super setEnablement: menu.	( self selection == nil or: [ self selectionIsClass ] )		ifFalse:			[ self actionsForClassesOnly do: 				[:nm | 				( item := menu atNameKey: nm ) == nil					ifFalse: [ item disable ] 				]			].	^menu</body></methods><methods><class-id>Tools.ClassesBrowserHelper</class-id> <category>list accessing</category><body package="OldBrowsers" selector="selectedItem">selectedItem	| thing |	thing := self selection.	( self selectionIsClass and: [ self isMeta ] )		ifTrue: [ thing := thing class].	^thing</body><body package="OldBrowsers" selector="selectionChanged">selectionChanged	module nextModule == nil ifTrue: [ ^super selectionChanged ].	self browser updateWindowLabel.	self browser batchUpdates:		[		self setSelection.		self selection isNameSpace ifTrue:[ self browser metaShowDataSilently].		module nextModule updateList		]</body><body package="OldBrowsers" selector="selectionIsClass">selectionIsClass	^self selection notNil and: 		[ self selection isSymbol 			ifTrue:[ false ] 			ifFalse:[ module selection isForClass ]		]</body><body package="OldBrowsers" selector="selectionIsDefined">selectionIsDefined	^self selection notNil and: [ self selection isSymbol not ]</body></methods><methods><class-id>Tools.ClassesBrowserHelper</class-id> <category>actions</category><body package="OldBrowsers" selector="browseClassReferences">browseClassReferences	| calls mc filter |	mc := self methodCollector.	filter := mc nullFilter.	self selections do:		[ :obj |		filter := filter				| (mc referencesTo: obj name)				| (mc referencesTo: ( obj environment bindingFor: obj name ) )].	calls := mc select: filter.	calls isEmpty		ifTrue:			[Dialog warn: (#None &lt;&lt; #dialogs &gt;&gt; 'None')				for: self interfaceWindow.			^self].	^mc 		openListBrowserOn: calls		label: (self selection == nil				ifTrue: [(#ReferencesToVariousVariables &lt;&lt; #dialogs &gt;&gt; 'References to various variables')]				ifFalse: [(#ReferencesTo1s &lt;&lt; #dialogs &gt;&gt; 'References to &lt;1s&gt;') expandMacrosWith: self selection fullName])		initialSelection: (self selection == nil				ifTrue: [nil]				ifFalse: [self selection name])</body><body package="OldBrowsers" selector="browseClassVariables">browseClassVariables	"Show a menu of all class variables of the currently selected class  	and its superclasses.  Browse all methods which refer to the variable selected."	| binding selectedClass mc |	selectedClass := self selectedItem instanceBehavior.	binding := self forClass: selectedClass		showVariableMenu: [:class | class localBindings asSortedCollection]		collect: [:bnd | bnd key].	binding notNil ifTrue:		[mc := self methodCollector.		mc browseSelect: (mc searchClassHierarchy: self selectedItem)							&amp; (mc referencesTo: binding)]</body><body package="OldBrowsers" selector="browseFieldReferences">browseFieldReferences	"Show a menu of all instance variables of the currently selected class 	and its superclasses. Browse all methods which refer to the variable 	selected."	| name mc |	name := self forClass: self selectedItem			showVariableMenu: [:class | class instVarNames]			collect: [:cname | cname].	name isNil ifTrue: [^self].	mc := self methodCollector.	mc browseSelect:			(mc searchBehaviorHierarchy: self selectedItem)			&amp; (mc instVarUse: name access: #readWrite).</body><body package="OldBrowsers" selector="fileOut">fileOut	| fileName fileManager nm |	nm := self defaultFileName.	fileName := Dialog			requestNewFileName: (#fileOutOn &lt;&lt; #dialogs &gt;&gt; 'File out on')			default: (Filename filterFilename: nm, '.st'). 	fileName = '' ifTrue: [^nil].	fileManager := SourceCodeStream write: fileName encoding: self fileEncoding.	[fileManager timeStamp.	fileManager deferInitializations.	self selectedThingsWithOrder:			[:definedObjects |			definedObjects				do: [:thing |					thing fileOutSourceOn: fileManager.					fileManager cr]].	fileManager finishInitializations.	fileManager cr]		ensure: [fileManager close].</body><body package="OldBrowsers" selector="hardcopy">hardcopy	"Print the category."		| stream |	stream := TextStream on: (String new: 1000).	self selectedThingsWithOrder:			[:definedObjects |			definedObjects				do: [:thing |					thing printOutOn: stream.					stream cr; nextPut: Character newPage; cr]].	self hardcopyStream: stream</body><body package="OldBrowsers" selector="move">move	"Move the selected classes to a user provided category." 	| selectedCategory aString newCategory |	self changeRequest ifFalse: [^self].	selectedCategory := self category.	aString := self				prompt: (#EnterNewCategoryName &lt;&lt; #dialogs &gt;&gt; 'Enter new category name') 				initially: (selectedCategory isNil ifTrue: [(#NewCategory &lt;&lt; #labels &gt;&gt; 'New Category') asString] ifFalse: [selectedCategory]).	aString isEmpty ifTrue: [^self].	newCategory := aString asSymbol.	newCategory = selectedCategory ifTrue: [^self].	module selections do: 		[:aClass |		self environment classifySymbol: aClass name under: newCategory.		ChangeSet changeClass: aClass].	self browser broadcastUpdate: #category -&gt; newCategory</body><body package="OldBrowsers" selector="moveNameSpace">moveNameSpace	| newSpace |	newSpace := NameSpaceNavigator					searchFrom:						(self defaultEnvironment isNil							ifTrue: [Smalltalk]							ifFalse: [self defaultEnvironment])					label: (#MoveToWhichEnvironmentQ &lt;&lt; #dialogs &gt;&gt; 'Move to which environment?').	newSpace == nil ifTrue: [^self].	module selections do:		[:sel | sel relocateTo: newSpace].	module updateList</body><body package="OldBrowsers" selector="remove">remove	"Prompt the user to remove the current class.  Answer if the class was removed or not."	| objs parentEvironment | 	self changeRequest ifFalse: [^false].	objs := module selections asArray collect: 		[ :obj |		obj isObsolete			ifFalse: [ obj ]			ifTrue:				[Dialog warn: ((#CantRemoveObject1sNoLongerExists &lt;&lt; #dialogs &gt;&gt; 'Can''t remove the object. &lt;1s&gt; no longer exists.')							expandMacrosWith: obj fullName)					for: self interfaceWindow.				nil]		].	objs := objs copyWithout: nil.	objs isEmpty ifTrue: [ ^false ].	objs := SystemUtils sortForLoading: objs.	objs reverseDo: 		[ :obj |		(Dialog confirm: ((#DoYouWantToRemove1sQ &lt;&lt; #dialogs &gt;&gt; 'Are you certain that you&lt;n&gt;want to remove &lt;1s&gt;?')					expandMacrosWith: obj fullName )				for: self interfaceWindow)			ifTrue: 				[(obj subrequisites size = 0					or: [Dialog confirm: ((#HasDependentObjectsRemoveItAnywayQ &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; has dependent objects. Remove it anyway?')									expandMacrosWith: obj fullName)							for: self interfaceWindow])					ifTrue: [parentEvironment := obj environment.							obj removeFromSystem]]].	module updateList.	self browser class name = #FullNotebookSystemBrowser ifTrue:[self browser setAndUpdateEnvironment: parentEvironment.	self browser toggleNamespaceList ].	^false</body><body package="OldBrowsers" selector="rename">rename	"Rename the currently selected thing, which can be (depending on the	selection and the meta switch) either a class, or a metaclass, 	or a namespace."	| newName target kind |	self changeRequest ifFalse: [^self].	target := self selected: #classOrNameSpace.	target isBehavior		ifTrue: 			[kind := (#class &lt;&lt; #labels &gt;&gt; 'class').			target := target instanceBehavior]		ifFalse: 			[kind := (#namespace &lt;&lt; #labels &gt;&gt; 'namespace')].	newName := self		prompt: ((#EnterNew1sName &lt;&lt; #dialogs &gt;&gt; 'Enter new &lt;1s&gt; name') expandMacrosWith: kind)		initially: self selection name asString.	newName isEmpty ifTrue: [^self].	newName := SystemUtils		validateStaticVariableName: newName		confirm: [:msg :nm | Dialog confirm: msg for: self interfaceWindow]		warn: [:msg | Dialog warn: msg for: self interfaceWindow].	newName isNil ifTrue: [^self].	SmalltalkWorkbench		rename: target		to: newName asSymbol		do: [:cls :nm | module select: cls whenFinished: [module updateList]]		for: self interfaceWindow		browser: self browser</body><body package="OldBrowsers" selector="spawn">spawn	self selectedItem isNil ifTrue:[^self].    self browser spawnOnClass: (self selectedItem isMeta ifTrue:[ self selectedItem instanceBehavior] ifFalse:[ self selectedItem]).</body><body package="OldBrowsers" selector="spawnBrowser">spawnBrowser	"Trigger the 'spawn' action, via a double-click.	If there are more than one types of spawning,	this may not necessarily be the same as the	'spawn' menu item."	self selectionIsClass		ifTrue: [SmalltalkWorkbench browseClass: self selectedItem]		ifFalse: [self spawn]</body><body package="OldBrowsers" selector="spawnHierarchy">spawnHierarchy	self selectedItem isForNameSpace ifTrue:[^self].	self browser spawnOnClassHierarchy: (self selectedItem isMeta ifTrue:[self selectedItem instanceBehavior] ifFalse:[self selectedItem ]).</body></methods><methods><class-id>Tools.ClassesBrowserHelper</class-id> <category>text processing</category><body package="OldBrowsers" selector="acceptText:from:">acceptText: text from: textController 	self selection == nil ifTrue: [^nil].	(self browser defType value == #showHierarchy and: [self selectionIsClass])		ifTrue: [^false].	(self browser defType value == #showComment and: [self selectionIsDefined])		ifTrue: 			[self selection asNameSpace namedReferent comment: text.			^true].	^self acceptDefinition: text from: textController</body><body package="OldBrowsers" selector="doItEnvironment">doItEnvironment	^self selectionIsClass		ifTrue: [self selectedItem environment]		ifFalse: [self environment]</body><body package="OldBrowsers" selector="doItReceiver">doItReceiver	^self selectionIsClass		ifTrue: [self selectedItem instanceBehavior]		ifFalse: [nil]</body><body package="OldBrowsers" selector="explainerClass">explainerClass	^self selectionIsClass		ifTrue: [self selectedItem]		ifFalse: [nil]</body><body package="OldBrowsers" selector="text">text	^self selection == nil		ifTrue: [self selections isEmpty			ifTrue: [nil]			ifFalse: [Text new]]		ifFalse:			[self textWhenSelected]</body><body package="OldBrowsers" selector="textWhenSelected">textWhenSelected	"Boy I hate this 'architecture'."	(self browser defType value == #showHierarchy and: [self selectionIsClass])		ifTrue: [^self isData				ifTrue: [self selectedItem printHierarchyWithStatics]				ifFalse: [self selectedItem printHierarchy]].	(self browser defType value == #showComment and: [self selectionIsDefined])		ifTrue: 			[ | comment |			comment := self selection comment.			^comment isEmpty 				ifTrue: [self selection commentTemplateString]				ifFalse: [comment]].	^self selectionIsDefined ifTrue: 		[self selection definition]</body><body package="OldBrowsers" selector="updateListForDefinedThing:">updateListForDefinedThing: thing	module select: thing whenFinished: [ module updateList ]</body></methods><methods><class-id>Tools.ClassesBrowserHelper</class-id> <category>private</category><body package="OldBrowsers" selector="decorate:">decorate: item	| type |	type := nil.	item isForNameSpace		ifTrue: [type := #nameSpace].	^BrowserListEntry value: item type: type</body><body package="OldBrowsers" selector="defaultEnvironment">defaultEnvironment	| all |	all := module selections collect: [:i | i environment].	all := all asSet asArray.	^all size = 1		ifTrue: [all first]		ifFalse: [Smalltalk]</body><body package="OldBrowsers" selector="defaultFileName">defaultFileName	"Answer a string as a suggested filename"	^self selection == nil		ifTrue: [ (#Definitions &lt;&lt; #labels &gt;&gt; 'Definitions') asString]		ifFalse: [ ( self textForItem: self selection ) asString ].</body><body package="OldBrowsers" selector="definitionOfStatic:">definitionOfStatic: aVar	self subclassResponsibility</body><body package="OldBrowsers" selector="forClass:showVariableMenu:collect:">forClass: aClass showVariableMenu: generatorBlock collect: valueBlock	"Construct a menu of variable names supplied by the generatorBlock,	with lines between classes in the superclass chain.  Show the menu,	returning the variable chosen by the user, or nil if no variable was chosen."	| variables labels tab listW sd spec buttons | 	variables := OrderedCollection new.	labels := SelectionInList new.	tab := String with: Character tab.	aClass withAllSuperclasses reverseDo:		[:eachClass | | varList |		varList := generatorBlock value: eachClass.		varList isEmpty			ifFalse:				[labels list add: (Text string: eachClass name emphasis: #italic).				labels selectionIndex: labels list size + 1.  "we know this will be legal"				variables add: nil.				(generatorBlock value: eachClass) do:					[:var |					labels list add: tab, (valueBlock value: var).					variables addLast: var]]].	variables isEmpty ifTrue: [^nil].  "Nothing to choose from"	sd := SimpleDialog new.	spec := (sd class interfaceSpecFor: #emptySpec).	sd builder add: spec window.	sd builder add: spec component.	sd setInitialGap.	sd addMessage: (#BrowseReferencesToWhichVariableQ &lt;&lt; #dialogs &gt;&gt; 'Browse references&lt;n&gt;to which variable?') expandMacros centered: true.	sd addGap: 8.	listW := sd			addList: labels			lines: (20 min: variables size+2)			validation: [labels selectionIndex &gt; 0].	listW widget setValidTargetIndex: labels selectionIndex.	sd addGap: 4.	buttons := sd addOK: [labels selectionIndex ~= 0].	sd addGap: 6.	sd bottomAlignLowerEdge: listW.	sd bottomAlign: (Array with: buttons).	labels selectionIndexHolder compute:			[:v |			(v &gt; 0 and: [(variables at: v) == nil])				ifTrue: [labels selectionIndex: 0.						listW widget targetIndex: 0]].	sd preOpen.	sd builder openDialogWithExtent: sd builder window displayBox extent.	^sd accept value		ifTrue: [variables at: labels selectionIndex]		ifFalse: [nil]</body><body package="OldBrowsers" selector="selectedThingsWithOrder:">selectedThingsWithOrder: aBlock	aBlock value: ( SystemUtils sortForLoading: self selections ).</body><body package="OldBrowsers" selector="textEmphasisForItem:">textEmphasisForItem: anItem	^self emphasizer 		emphasisForClassOrNameSpace: anItem		for: self browser 		id: self selectionId</body><body package="OldBrowsers" selector="textForItem:">textForItem: aListEntry	^aListEntry name asText</body></methods><methods><class-id>Tools.ClassesBrowserHelper</class-id> <category>selections</category><body package="OldBrowsers" selector="defaultAttribute">defaultAttribute	"Answer the default attribute that this helper is responsible for selecting."	^#classOrNameSpace</body></methods><methods><class-id>Tools.ClassesBrowserHelper</class-id> <category>drag and drop</category><body package="OldBrowsers" selector="addClientDataTo:">addClientDataTo: anIdentityDict 	self hasSelections ifFalse: [^false].	anIdentityDict at: self classOrNamespaceKey put: self selections.	^true</body><body package="OldBrowsers" selector="canAcceptDropFrom:">canAcceptDropFrom: aDC	^false</body><body package="OldBrowsers" selector="dragEnter:">dragEnter: aDragContext 	"Typically a class pane doesn't accept drops"^#dropEffectNone</body><body package="OldBrowsers" selector="dragLeave:">dragLeave: aDragContext 	"Typically a class pane doesn't accept drops"^#dropEffectNone</body><body package="OldBrowsers" selector="dragOver:">dragOver: aDragContext 	"Typically a class pane doesn't accept drops"^#dropEffectNone</body><body package="OldBrowsers" selector="getDragDropKey">getDragDropKey	"return the data key for the drag"	^self classOrNamespaceKey.</body></methods><methods><class-id>Tools.ClassesBrowserHelper class</class-id> <category>resources</category><body package="OldBrowsers" selector="commentIcon">commentIcon	^OpaqueImage		figure: self commentIconColor		shape: self commentIconMask</body><body package="OldBrowsers" selector="definitionIcon">definitionIcon	^OpaqueImage		figure: self definitionIconColor		shape: self definitionIconMask</body><body package="OldBrowsers" selector="hierarchyIcon">hierarchyIcon	^OpaqueImage		figure: self hierarchyIconColor		shape: self hierarchyIconMask</body></methods><methods><class-id>Tools.ClassesBrowserHelper class</class-id> <category>menus accessing</category><body package="OldBrowsers" selector="menuHeader">menuHeader	^(#Class &lt;&lt; #menus &gt;&gt; '&amp;Class') asString</body></methods><methods><class-id>Tools.ClassHierarchyBrowserHelper</class-id> <category>accessing</category><body package="OldBrowsers" selector="baseClass">baseClass	baseClass == nil		ifTrue: [ baseClass := self targetClass ].	^baseClass.</body><body package="OldBrowsers" selector="baseClass:">baseClass: aClass	^baseClass := aClass</body><body package="OldBrowsers" selector="windowLabel">windowLabel	^(#HierarchyBrowserOn1p &lt;&lt; #labels &gt;&gt; 'Hierarchy Browser on &lt;1p&gt;') expandMacrosWith: self baseClass</body></methods><methods><class-id>Tools.ClassHierarchyBrowserHelper</class-id> <category>menus accessing</category><body package="OldBrowsers" selector="setEnablement:">setEnablement: menu	"Set the menu's items enabled/disabled state."	super setEnablement: menu.		(menu atNameKey: #add) disable.	^menu</body></methods><methods><class-id>Tools.ClassHierarchyBrowserHelper</class-id> <category>list accessing</category><body package="OldBrowsers" selector="updateListFull">updateListFull	| newList |	(self baseClass == nil	or: [self baseClass isObsolete])		ifTrue: [newList := List new]		ifFalse: [newList := self generateHierarchy].	module setNewList: newList</body></methods><methods><class-id>Tools.ClassHierarchyBrowserHelper</class-id> <category>private</category><body package="OldBrowsers" selector="decorate:">decorate: item	| thing |	thing := super decorate: item.	thing offset: (self nesting: item)@0.	^thing</body><body package="OldBrowsers" selector="generateHierarchy">generateHierarchy	| newList |	newList := List new.	self generateSuper: self baseClass into: newList.	self generateSubs: self baseClass into: newList.	^newList</body><body package="OldBrowsers" selector="generateSubs:into:">generateSubs: cls into: newList	| subs |	cls == nil ifTrue: [^self].	subs := cls subclasses.	subs := subs asSortedCollection: [:c1 :c2 | c1 fullName &lt; c2 fullName].	subs do: [:cl |		cl isMeta			ifFalse:				[newList add: cl.				self generateSubs: cl into: newList]]</body><body package="OldBrowsers" selector="generateSuper:into:">generateSuper: cls into: newList	cls == nil		ifFalse:			[self generateSuper: cls superclass into: newList.			cls isMeta ifFalse:[newList add: cls ]]</body><body package="OldBrowsers" selector="howManySuperclasses:">howManySuperclasses: item	^(item isBehavior	 and: [item superclass ~~ nil])		ifTrue: [(self howManySuperclasses: item superclass) + 1]		ifFalse: [0]</body><body package="OldBrowsers" selector="nesting:">nesting: item	^(self howManySuperclasses: item ) * 12</body></methods><methods><class-id>Tools.NameSpaceCategoryBrowserHelper</class-id> <category>accessing</category><body package="OldBrowsers" selector="windowLabel">windowLabel	^(#ClassBrowserOn &lt;&lt; #labels &gt;&gt; 'Class Browser on &lt;1p&gt;') expandMacrosWith: self selection</body></methods><methods><class-id>Tools.NameSpaceCategoryBrowserHelper</class-id> <category>list accessing</category><body package="OldBrowsers" selector="generateListFull">generateListFull	| env newList cat |	env := self environment.	cat := self category.	newList := env == nil		ifTrue: 			[ newList := cat == nil						ifTrue: [ Root withAllNameSpacesAndAllClasses ]						ifFalse: [ Root withAllNameSpacesAndAllClasses									select: [:ea| ea category == cat ] ] ]		ifFalse:			[ newList := cat == nil				ifTrue: [ env asNameSpace organization elements ]				ifFalse: [ env asNameSpace organization listAtCategoryNamed: cat ].			newList := newList collect: 				[ :nm | | bind |				( bind := env bindingFor: nm ) isForGeneral not					ifTrue: [ bind value ]				].			newList := newList reject: [ :ref | ref == nil ].			].	^newList.</body><body package="OldBrowsers" selector="updateListFull">updateListFull	module setNewList: 		( self generateListFull asSortedCollection: 			[ :a :b | a name &lt; b name ] 		) asList.	module list list isEmpty ifTrue: 		[self broadcastUpdate: #classOrNameSpace -&gt; self environment]</body></methods><methods><class-id>Tools.NameSpaceCategoryBrowserHelper</class-id> <category>menus accessing</category><body package="OldBrowsers" selector="actionsForNoSelect">actionsForNoSelect	^#(#add #addClassBytes #addClassFixedSize #addClassVariableSize)</body><body package="OldBrowsers" selector="enhance:for:submenu:subMenuName:">enhance: menu for: md submenu: nameKey subMenuName: aName	| item |	item := menu atNameKey: nameKey.	item isNil ifTrue: [^self].	((nameKey == #spawnHierarchy ))		ifTrue: [^self selection == nil				ifTrue: [item disable]				ifFalse: [self selection isForNameSpace ifTrue:[item disable] ifFalse:[item enable]]].</body><body package="OldBrowsers" selector="getListMenu:">getListMenu: forMenuBar	| menu |	menu := super getListMenu: forMenuBar.	self enhance: menu for: self selection submenu:  #spawnHierarchy   subMenuName: (#SpawnHierarchy &lt;&lt; #menus &gt;&gt; 'Spawn Hierarchy') .	^menu</body></methods><methods><class-id>Tools.NameSpaceCategoryBrowserHelper</class-id> <category>templates</category><body package="OldBrowsers" selector="templateBinding:category:">templateBinding: nameSpace category: category	^'&lt;1s&gt; defineSharedVariable: #&lt;2s&gt;	private: false	constant: false	category: &lt;3p&gt;	initializer: ''Array new: 5'''		expandMacrosWith: (nameSpace namedReferent unambiguousName)		with: #NameOfBinding &lt;&lt; #browser &gt;&gt; 'NameOfBinding'		with: (category == nil				ifTrue: [NameSpaceOrganizer defaultProtocol asString]				ifFalse: [category asString])</body><body package="OldBrowsers" selector="templateClass:category:type:">templateClass: nameSpace category: category type: type	| ns |	ns := nameSpace == nil		ifTrue: [ Smalltalk ]		ifFalse: [ nameSpace ].	^'&lt;1p&gt; defineClass: #&lt;2s&gt;	superclass: #{&lt;3s&gt;}	indexedType: #&lt;4s&gt;	private: false	instanceVariableNames: ''&lt;5s&gt;''	classInstanceVariableNames: ''''	imports: ''''	category: &lt;6p&gt;' 		expandMacrosWithArguments: (OrderedCollection new			add: (ns namedReferent unambiguousName);			add: #NameOfClass &lt;&lt; #browser &gt;&gt; 'NameOfClass';			add: #NameOfSuperclass &lt;&lt; #browser &gt;&gt; 'NameOfSuperclass';			add: type;			add: (type == #bytes				ifTrue: ['']				ifFalse: [(#instVarName1InstVarName2 &lt;&lt; #browser &gt;&gt; 'instVarName1 instVarName2')]);			add: (category == nil				ifTrue: [NameSpaceOrganizer defaultProtocol asString]				ifFalse: [category asString]);			yourself)</body><body package="OldBrowsers" selector="templateNameSpace:category:">templateNameSpace: nameSpace category: category	^'&lt;1s&gt; defineNameSpace: #&lt;2s&gt;	private: false	imports: ''			&lt;3s&gt;.*			private Smalltalk.*			''	category: &lt;4p&gt;'		expandMacrosWith: (nameSpace namedReferent unambiguousName)		with: #NameOfPool &lt;&lt; #browser &gt;&gt; 'NameOfPool'		with: #OtherNameSpace &lt;&lt; #browser &gt;&gt; 'OtherNameSpace'		with: (category == nil				ifTrue: [NameSpaceOrganizer defaultProtocol asString]				ifFalse: [category asString])</body></methods><methods><class-id>Tools.NameSpaceCategoryBrowserHelper</class-id> <category>actions</category><body package="OldBrowsers" selector="addBinding">addBinding	self browser defType value: #showDefinition.	module deselect.	self browser text value: (self			templateBinding: self environment			category: self category)</body><body package="OldBrowsers" selector="addClassBytes">addClassBytes	self browser defType value: #showDefinition.	module deselect.	self browser text value: (self			templateClass: self environment			category: self category			type: #bytes)</body><body package="OldBrowsers" selector="addClassFixedSize">addClassFixedSize	self browser defType value: #showDefinition.	module deselect.	self browser text value: (self			templateClass: self environment			category: self category			type: #none)</body><body package="OldBrowsers" selector="addClassVariableSize">addClassVariableSize	self browser defType value: #showDefinition.	module deselect.	self browser text value: (self			templateClass: self environment			category: self category			type: #objects)</body><body package="OldBrowsers" selector="addNameSpace">addNameSpace	self browser defType value: #showDefinition.	module deselect.	self browser text value: (self			templateNameSpace: self environment			category: self category)</body><body package="OldBrowsers" selector="move">move	| aString newCategory |	self changeRequest ifFalse: [^self].	aString := self prompt: (#EnterNewCategoryName &lt;&lt; #dialogs &gt;&gt; 'Enter new category name') initially: (self category isNil ifTrue:[(#NewCategory &lt;&lt; #labels &gt;&gt; 'New Category') asString]ifFalse:[ self category]).	aString isEmpty ifTrue: [^ self].	newCategory := aString asSymbol.	newCategory == self category		ifTrue: [^self].	module selections do: 		[ :selection |		selection environment classifySymbol: selection name under: newCategory.		selection isForClass			ifTrue: [ ChangeSet changeClass: selection ]			ifFalse: [ ChangeSet changeNameSpace: selection ].		].	self browser broadcastUpdate: #category -&gt; newCategory</body><body package="OldBrowsers" selector="moveNewParcel">moveNewParcel	| newName currentParcel obj |	self changeRequest ifFalse: [^self].	newName := Dialog						request: (#EnterNameForNewParcel &lt;&lt; #dialogs &gt;&gt; 'Enter name for the new parcel')						initialAnswer: ''						onCancel: [nil].	newName := Parcel normalizedNameFor: newName.	(newName isNil or: [newName isEmpty]) ifTrue: [^self].	(Parcel parcelNamed: newName) notNil ifTrue:		[Dialog warn: (#parcelExists &lt;&lt; #dialogs &gt;&gt; 'A parcel with this name already exists').		^self].	(currentParcel := Parcel createParcelNamed: newName) == nil ifTrue:		[^self].	obj := self selection.	obj isForClass		ifTrue: [ currentParcel addEntiretyOfClass: obj ]		ifFalse: 	[currentParcel addObject: obj ].</body><body package="OldBrowsers" selector="selectBehavior:">selectBehavior: aBehavior	self setSelection: aBehavior.	module select: aBehavior whenFinished: [module updateList]</body><body package="OldBrowsers" selector="spawn">spawn	self selection isNil ifTrue: [^self].	self selectionIsClass ifTrue: [^super spawn].	self selection isForNameSpace ifTrue: 		[self browser spawnOnNameSpace: module selection]</body></methods><methods><class-id>Tools.NameSpaceCategoryBrowserHelper</class-id> <category>private</category><body package="OldBrowsers" selector="defaultEnvironment">defaultEnvironment	^self environment</body></methods><methods><class-id>Tools.ParcelNameSpaceCategoryBrowserHelper</class-id> <category>emphasis</category><body package="OldBrowsers" selector="textEmphasisForItem:">textEmphasisForItem: anItem	anItem isSymbol ifTrue:[ ^Set new ].	^self emphasizer emphasisForClassOrNameSpace: anItem for: self browser id: selectionId.</body></methods><methods><class-id>Tools.ParcelNameSpaceCategoryBrowserHelper</class-id> <category>actions</category><body package="OldBrowsers" selector="addBinding">addBinding	self browser parcelDefType value: #parcelDefintion.	super addBinding.</body><body package="OldBrowsers" selector="addClassBytes">addClassBytes	self browser parcelDefType value: #parcelDefintion.	super addClassBytes.</body><body package="OldBrowsers" selector="addClassFixedSize">addClassFixedSize	self browser parcelDefType value: #parcelDefintion.	super addClassFixedSize.</body><body package="OldBrowsers" selector="addClassVariableSize">addClassVariableSize	self browser parcelDefType value: #parcelDefintion.	super addClassVariableSize.</body><body package="OldBrowsers" selector="addNameSpace">addNameSpace	self browser parcelDefType value: #parcelDefintion.	super addNameSpace.</body><body package="OldBrowsers" selector="addSelectionToParcel">addSelectionToParcel	| obj |	self changeRequest ifFalse: [^self].	self browser saveParcelsForUndo.	obj := self selection.	obj isForClass		ifTrue: [ self currentParcel addEntiretyOfClass: obj ]		ifFalse: [ self currentParcel addObject: obj ].	self browser updateLists</body><body package="OldBrowsers" selector="moveNewParcel">moveNewParcel	| newName currentParcel obj |	self changeRequest ifFalse: [^self].	newName := Dialog						request: (#EnterNameForNewParcel &lt;&lt; #dialogs &gt;&gt; 'Enter name for the new parcel')						initialAnswer: ''						onCancel: [nil].	newName := self browser manager normalizedNameFor: newName.	(newName isNil or: [newName isEmpty]) ifTrue: [^self].	(self browser manager parcelNamed: newName) notNil ifTrue:		[Dialog warn: (#parcelExists &lt;&lt; #dialogs &gt;&gt; 'A parcel with this name already exists').		^self].	(currentParcel := self browser manager createParcelNamed: newName) == nil ifTrue:		[^self].	obj := self selection.	obj isForClass		ifTrue: [ currentParcel addEntiretyOfClass: obj ]		ifFalse: 	[ currentParcel addObject: obj ].	self browser updateParcelLists.	self module selection: currentParcel</body><body package="OldBrowsers" selector="removeSelectionFromParcel">removeSelectionFromParcel	self changeRequest ifFalse: [^self].	self browser saveParcelsForUndo.	self selection isForClass		ifTrue: [self currentParcel					removeEntiretyOfClass: self selection ]		ifFalse:	[self currentParcel					removeNameSpace: self selection ].	self browser updateLists</body></methods><methods><class-id>Tools.ParcelNameSpaceCategoryBrowserHelper</class-id> <category>Parcel actions</category><body package="OldBrowsers" selector="moveSelectionToParcel:">moveSelectionToParcel: aParcel 	"Move the selected class into theParcel according to the current 	parcel and filtering. A Namespace move is not currently implemented."	self changeRequest ifFalse: [ ^self ].	self browser saveParcelsForUndo.	self selection isForClass		ifTrue: [ self browser moveBehaviors: (Set with: self nonMetaClass with: self nonMetaClass class)				toParcel: aParcel ]		ifFalse: [ Dialog warn: (#NotImplemented &lt;&lt; #dialogs &gt;&gt; 'Not implemented.') ].	self browser updateLists</body></methods><methods><class-id>Tools.ParcelNameSpaceCategoryBrowserHelper</class-id> <category>menus accessing</category><body package="OldBrowsers" selector="enhance:for:submenu:subMenuName:">enhance: menu for: md submenu: nameKey subMenuName: aName	| item |	item := menu atNameKey: nameKey.	item isNil ifTrue: [^self].	((nameKey == #moveNewParcel  )) ifTrue: [item enable ; hidden: false].</body><body package="OldBrowsers" selector="getListMenu:">getListMenu: forMenuBar	|  selection menu |	menu := super getListMenu: forMenuBar.	selection := ( self selection == nil or: [ self selection isSymbol ] )		ifTrue: [ #() ]		ifFalse: [ self selection ].	self enhance: menu for: self selection submenu:  #moveNewParcel   subMenuName: (#NewParcel &lt;&lt; #menus &gt;&gt; 'New Parcel') .	^self browser 		addParceling: ( self browser manager parcelsForClassOrNameSpace: selection )		to: (menu)		forHelper: self</body></methods><methods><class-id>Tools.ParcelNameSpaceCategoryBrowserHelper</class-id> <category>list accessing</category><body package="OldBrowsers" selector="intializeListFull">intializeListFull	| newList |	"why no filtering with no category?"	self category == nil ifTrue: [ ^super updateListFull ].	newList := (self generateListFull asSortedCollection: [ :a :b | a name &lt; b name ]) asList.	module setNewListSilently: ( self filter: newList )</body><body package="OldBrowsers" selector="updateListFull">updateListFull	| newList |	newList := (self generateListFull asSortedCollection: [ :a :b | a name &lt; b name ]) asList.	module setNewList: ( self filter: newList )</body></methods><methods><class-id>Tools.ParcelNameSpaceCategoryBrowserHelper</class-id> <category>private</category><body package="OldBrowsers" selector="decorate:">decorate: item	| type | 	type := nil.	item class  name == #Parcel ifTrue:[type := #parcel]	ifFalse:[item isForNameSpace		ifTrue: [type := #nameSpace]].	^BrowserListEntry value: item type: type</body><body package="OldBrowsers" selector="filter:">filter: ClassNameSpaceList	"Compute the list of things for the selected category.  Things are either	 classes  or nameSpaces.	 If the isInParcel filter is on and there is no selected parcel	 then display all classes in the category."	| browser currentParcel manager |	browser := self browser.	manager := browser manager.	currentParcel := self currentParcel.	browser isUnparceledFilterOn ifTrue:		[ ^ClassNameSpaceList select:			[ :obj |			obj isForClass				ifTrue: [browser isUnparceledCodeInClass: obj  currentParcel: currentParcel]				ifFalse:  [browser isUnparceledCodeInNameSpace: obj ]			]		].	browser isParcelFilterOn ifFalse: [^ClassNameSpaceList].	browser isConflictsFilterOn ifTrue:		[| conflicts |		conflicts := browser 						computeConflictsFor: ClassNameSpaceList 						within: (currentParcel notNil ifTrue: [Array with: currentParcel]).		conflicts := conflicts last collect: [:class| class fullName].		^ClassNameSpaceList select: [:obj| conflicts includes: obj fullName]].	currentParcel isNil ifTrue:		[^ClassNameSpaceList select:			[:ea| | |			(manager parcelsForClassOrNameSpace: ea ) size &gt; 0]].	^ClassNameSpaceList select:		[ :obj | 		obj isForClass  			ifTrue: [currentParcel definesOrExtendsClass: obj ]			ifFalse: [currentParcel definesObject: obj]		]</body><body package="OldBrowsers" selector="nonMetaClass">nonMetaClass	"Answer the class that is currently selected (nil if none), even	if looking at the metaClass."	| classOrNil |	classOrNil := self selection.	(self isMeta and: [classOrNil notNil])		ifTrue: [classOrNil := classOrNil instanceBehavior].	^classOrNil</body></methods><methods><class-id>Tools.ParcelNameSpaceGlobalCategoryBrowserHelper</class-id> <category>private</category><body package="OldBrowsers" selector="textForItem:">textForItem: aListEntry	^aListEntry displayString asText</body></methods><methods><class-id>Tools.ParcelNameSpaceGlobalCategoryBrowserHelper</class-id> <category>list accessing</category><body package="OldBrowsers" selector="generateListFull">generateListFull	| env newList  |	env := self environment.	newList := env == nil		ifTrue: 			[ newList := Root withAllNameSpacesAndAllClasses ]		ifFalse:			[ self category == nil 				ifTrue: [Root withAllNameSpacesAndAllClasses]				ifFalse: [  newList := Root withAllNameSpacesAndAllClasses select:[:each | each category = self category].						].].	^newList.</body></methods><methods><class-id>Tools.NameSpaceGlobalCategoryBrowserHelper</class-id> <category>list accessing</category><body package="OldBrowsers" selector="generateListFull">generateListFull	^(self environment == nil)		ifTrue: 			[Root withAllNameSpacesAndAllClasses ]		ifFalse:			[self category == nil 				ifTrue: [Root withAllNameSpacesAndAllClasses]				ifFalse: [Root withAllNameSpacesAndAllClasses select: [:each | each category = self category]]]</body><body package="OldBrowsers" selector="updateListFull">updateListFull	Cursor wait showWhile: 		[module setNewList: (self generateListFull asSortedCollection: [:a :b | a name &lt; b name]) asList]</body></methods><methods><class-id>Tools.NameSpaceGlobalCategoryBrowserHelper</class-id> <category>private</category><body package="OldBrowsers" selector="textForItem:">textForItem: aListEntry	^aListEntry displayString asText</body></methods><methods><class-id>Tools.NameSpaceOrganizerBrowserHelper</class-id> <category>accessing</category><body package="OldBrowsers" selector="searchChildNamespaces">searchChildNamespaces	^searchChildNamespaces isNil ifTrue:[searchChildNamespaces := false] ifFalse:[ searchChildNamespaces]</body><body package="OldBrowsers" selector="searchChildNamespaces:">searchChildNamespaces: aBooleen	searchChildNamespaces := aBooleen</body><body package="OldBrowsers" selector="selectCategory:">selectCategory: categoryName	module		select: categoryName asSymbol		whenFinished: [module updateList]</body><body package="OldBrowsers" selector="windowLabel">windowLabel	^module hasList		ifTrue: [(#SystemBrowserOn &lt;&lt; #labels &gt;&gt; 'System Browser on &lt;1p&gt;') expandMacrosWith: self environment]		ifFalse: [(#CategoryBrowserOn1pIn2p &lt;&lt; #labels &gt;&gt; 'Category Browser on &lt;1p&gt; in &lt;2p&gt;')					expandMacrosWith: self selection					with: self environment]</body></methods><methods><class-id>Tools.NameSpaceOrganizerBrowserHelper</class-id> <category>menus accessing</category><body package="OldBrowsers" selector="actionsForMultiSelect">actionsForMultiSelect	^#(#fileOut #hardcopy #add #remove #findClass)</body><body package="OldBrowsers" selector="actionsForNoSelect">actionsForNoSelect	^#(#add #findClass)</body></methods><methods><class-id>Tools.NameSpaceOrganizerBrowserHelper</class-id> <category>list accessing</category><body package="OldBrowsers" selector="generateList">generateList	^self searchChildNamespaces		ifTrue: [self allOrganizations]		ifFalse: [self environment organization categories asList]</body><body package="OldBrowsers" selector="selectionChanged">selectionChanged	module nextModule == nil ifTrue: [^super selectionChanged].	self setSelection.	self browser updateWindowLabel.	self browser batchUpdates: 		[module nextModule updateList.		module list list isEmpty ifTrue:			[self broadcastUpdate: #classOrNameSpace-&gt;self environment]]</body><body package="OldBrowsers" selector="updateListFull">updateListFull	| newList |	newList := self environment == nil			ifTrue: [self allOrganizations]			ifFalse: [self generateList].	module setNewList: newList</body></methods><methods><class-id>Tools.NameSpaceOrganizerBrowserHelper</class-id> <category>actions</category><body package="OldBrowsers" selector="addCategory">addCategory	"Prompt the user for a new category name. Insert the category into 	the class organization before the currently selected category."	| newCategory indx env list association |	self changeRequest ifFalse: [ ^self ].		list := (searchChildNamespaces				ifTrue: 					[self environment withAllNameSpaces						asSortedCollection: [:n1 :n2 | n1 name &lt; n2 name]]				ifFalse: [List with: self environment]).	(association := SmalltalkWorkbench 						promptForCategoryAndNamespace: list 						from: self browser builder window) isNil ifTrue: [^self].	newCategory := association key.	env := association value.	env organization addCategory: newCategory before: self selection.	env reorganize.	indx := module selectionIndex.	indx == nil		ifTrue: [module list list add: (self decorate: newCategory)]		ifFalse: [module list list add: (self decorate: newCategory) beforeIndex: indx].	module		select: newCategory		whenFinished: [module updateList].</body><body package="OldBrowsers" selector="broadcastUpdate:">broadcastUpdate: aspect	aspect key == #category		ifTrue: 			[ module hasList				ifTrue: [module select: aspect value whenFinished: [module updateList]]				ifFalse:					[module forceSelection: aspect value.					self setSelection: aspect value.					"module nextModule secondaryObject: aspect value"					]			]		ifFalse: [super broadcastUpdate: aspect]</body><body package="OldBrowsers" selector="fileOut">fileOut	| fileName fileManager nm |	nm := self selection == nil			ifTrue: [(#Definitions &lt;&lt; #dialogs &gt;&gt; 'Definitions') asString]			ifFalse: [module selection asString].	fileName := Dialog			requestNewFileName: (#fileOutOn &lt;&lt; #dialogs &gt;&gt; 'File out on')			default: (Filename filterFilename: nm, '.st'). 	fileName = '' ifTrue: [^nil].	fileManager := SourceCodeStream write: fileName encoding: self fileEncoding.	[fileManager timeStamp.	fileManager deferInitializations.	self selectedThingsWithOrder:			[:definedObjects |			definedObjects				do: [:thing |					thing fileOutSourceOn: fileManager.					fileManager cr]].	fileManager finishInitializations.	fileManager cr]		ensure: [fileManager close].</body><body package="OldBrowsers" selector="findClass">findClass	"Prompt for a class and position myself there."	| obj |	obj := self findASomething: (#FindClassColon &lt;&lt; #dialogs &gt;&gt; 'Find class:').	obj == nil ifTrue: [^self].	self changeRequest ifFalse: [^self].	self browser setAndUpdateEnvironment: obj environment.	obj isBindingReference		ifTrue:			[self browser batchUpdates:				[self browser metaShowData.				self browser selectCategory: obj environment category.				self browser selectBehavior: obj environment.				self browser selectProtocol: (obj environment asNameSpace categoryFor: obj name).				self browser selectMethod: obj name]]		ifFalse:			[module				select: obj category				whenFinished:					[module nextModule						select: obj						whenFinished: [module updateList]]]</body><body package="OldBrowsers" selector="hardcopy">hardcopy	"Print the category."		| stream lastItemWasBig first |	stream := TextStream on: (String new: 1000).	lastItemWasBig := false.	first := true.	self selectedThingsWithOrder:			[:definedObjects |			definedObjects				do: [:thing || newItemIsBig |					newItemIsBig := thing isBindingReference not.					(first not and: [lastItemWasBig or: [newItemIsBig]])						ifTrue: [stream nextPut: Character newPage].					lastItemWasBig := newItemIsBig.					first := false.					thing printOutOn: stream.					stream cr; cr]].	self hardcopyStream: stream</body><body package="OldBrowsers" selector="remove">remove	self changeRequest ifFalse: [^self].	self selectedThingsWithOrder:			[:definedObjects |			definedObjects size = 0				ifFalse:					[(Dialog confirm: (#AreYouCertainRemoveAllDefinitionsInThisCategoryQ &lt;&lt; #dialogs &gt;&gt; 'Are you certain that you want to remove all definitions in this category?')							for: self interfaceWindow)						ifFalse: [^self].					definedObjects reverseDo: [:thing | thing removeFromSystem]]].	self selections do: 		[ :category |		( self environmentsForCategory: category ) do:			[ :env | 			env organization removeCategory: category.			env reorganize			]		].	module listSelectionIndexes asSortedCollection reverseDo: 		[ :index | module list list removeAtIndex: index ].	module deselect</body><body package="OldBrowsers" selector="rename">rename	| aString newCategory envlist changed |	self changeRequest ifFalse: [^self].	aString := self prompt: (#EnterNewCategoryName &lt;&lt; #dialogs &gt;&gt; 'Enter new category name') initially: self selection.	aString isEmpty ifTrue: [^self].	newCategory := aString asSymbol.	(envlist := self environmentsForCategory: self selection) == nil ifTrue: [^self].	changed := false.	envlist do: 		[:env | 		(env renameCategory: self selection to: newCategory) ifTrue: 			[changed := true]].	changed ifTrue: 		[module list list at: module list selectionIndexes asArray first put: (self decorate: newCategory).		self browser updateText]</body><body package="OldBrowsers" selector="spawn">spawn	| envlist |	( envlist := self environmentsForCategory: self selection ) == nil		ifTrue: [ ^self ].	envlist isEmpty 		ifTrue: [ ^self ].	envlist do:		[ :env | self browser spawnOnNameSpaces: env category: self selection ].</body></methods><methods><class-id>Tools.NameSpaceOrganizerBrowserHelper</class-id> <category>templates</category><body package="OldBrowsers" selector="templateBinding:category:">templateBinding: nameSpace category: category	^'&lt;1s&gt; defineSharedVariable: #&lt;2s&gt;	private: false	constant: false	category: &lt;3p&gt;	initializer: ''Array new: 5'''		expandMacrosWith: (nameSpace namedReferent unambiguousName)		with: #NameOfBinding &lt;&lt; #browser &gt;&gt; 'NameOfBinding'		with: (category == nil				ifTrue: [NameSpaceOrganizer defaultProtocol asString]				ifFalse: [category asString])</body><body package="OldBrowsers" selector="templateClass:category:type:">templateClass: nameSpace category: category type: type	^'&lt;1p&gt; defineClass: #&lt;2s&gt;	superclass: #{&lt;3s&gt;}	indexedType: #&lt;4s&gt;	private: false	instanceVariableNames: ''&lt;5s&gt;''	classInstanceVariableNames: ''''	imports: ''''	category: &lt;6p&gt;' 		expandMacrosWithArguments: (OrderedCollection new			add: (nameSpace namedReferent unambiguousName);			add: #NameOfClass &lt;&lt; #browser &gt;&gt; 'NameOfClass';			add: #NameOfSuperclass &lt;&lt; #browser &gt;&gt; 'NameOfSuperclass';			add: type;			add: (type == #bytes				ifTrue: ['']				ifFalse: [(#instVarName1InstVarName2 &lt;&lt; #browser &gt;&gt; 'instVarName1 instVarName2')]);			add: (category == nil				ifTrue: [NameSpaceOrganizer defaultProtocol asString]				ifFalse: [category asString]);			yourself)</body></methods><methods><class-id>Tools.NameSpaceOrganizerBrowserHelper</class-id> <category>text processing</category><body package="OldBrowsers" selector="acceptText:from:">acceptText: text from: textController	"Indicate that we didn't even try."	^self selection == nil		ifTrue: [nil]		ifFalse: [self acceptDefinition: text from: textController]</body><body package="OldBrowsers" selector="doItEnvironment">doItEnvironment	^self environment</body><body package="OldBrowsers" selector="explainerClass">explainerClass	^nil</body><body package="OldBrowsers" selector="text">text	^self selection == nil		ifTrue:			[self selections isEmpty				ifTrue: [nil]				ifFalse: [Text new]]		ifFalse:			[self browser meta value == #data				ifTrue:					[self						templateBinding: self environment						category: self selection]				ifFalse:					[self						templateClass: self environment						category: self selection						type: #none]]</body><body package="OldBrowsers" selector="updateListForDefinedThing:">updateListForDefinedThing: class	module nextModule updateListForDefinedThing: class</body></methods><methods><class-id>Tools.NameSpaceOrganizerBrowserHelper</class-id> <category>private</category><body package="OldBrowsers" selector="allOrganizations">allOrganizations	| list env |	list := IdentitySet new: 400.	env := self environment isNil				ifTrue: [Root]				ifFalse: [self environment].	list addAll: env organization categories.	env withAllNameSpaces do: 		[:nameSpace | 		nameSpace bindingsDo:			[:i | i isForClass ifTrue: [list add: i value category]]].	self selection notNil ifTrue:		[list add: self selection].	^list asSortedCollection asList</body><body package="OldBrowsers" selector="environmentsForCategory:">environmentsForCategory: aCategory	"Answer all of the environments for aCategory."	| env |	env := self environment.	env == nil ifTrue: [ env := Root ].	searchChildNamespaces		ifFalse: [ ^Array with: env ].	^env withAllNameSpaces select:		[ :ns | ns organization categories includes: aCategory ].</body><body package="OldBrowsers" selector="pickAClass:">pickAClass: prompt		"Choose a class or global name with a prompter."	"Prompt the user for a name or pattern.	Answer an empty string if that's what the user returned.	Answer the class, if there is only one class that matches.	If there is more than one class match, prompt the user with a choice		of matches, and return the class selected or an empty string.	If there are no class matches, answer the first global name that		matches, or nil if there are none."	| destClassName classes  |	destClassName := Dialog request: prompt for: self interfaceWindow. 	destClassName = '' ifTrue: [^''].	classes := OrderedCollection new.	Cursor execute showWhile:		[classes := self environment keys select: [ :cn | destClassName match:cn]].		classes := classes asSortedCollection.		(classes == nil or: [classes size = 0])			ifTrue:				[^nil]			ifFalse: 				[classes size = 1					ifTrue: [destClassName := classes first]					ifFalse: [destClassName := Dialog								choose: (#ChooseAClass &lt;&lt; #dialogs &gt;&gt; 'Choose a class')								fromList: classes values: classes								lines: 10 cancel: [^'']								for: self interfaceWindow]].	^destClassName</body><body package="OldBrowsers" selector="selectedNamesDo:">selectedNamesDo: aBlock	"For every selected category, within every visible namespace,	evaluate aBlock with the name &amp; environment."	self selections do: 		[ :category |		( self environmentsForCategory: category ) do:			[ :env |			( env organization listAtCategoryNamed: category ) do: 				[ :key | aBlock value: key value: env ].			]		].</body><body package="OldBrowsers" selector="selectedThingsWithOrder:">selectedThingsWithOrder: aBlock	| things |	things := OrderedCollection new.	module selections do: 		[ :category |		( self environmentsForCategory: category ) do:			[ :env |  			( env organization listAtCategoryNamed: category ) do: 				[ :key | | thing |				thing := env bindingFor: key.				thing := thing isForGeneral					ifTrue: [BindingReference simpleName: key in: env]					ifFalse: [thing value].				things add: thing ]			]		].	things := SystemUtils sortForLoading: things.	aBlock value: things</body></methods><methods><class-id>Tools.NameSpaceOrganizerBrowserHelper</class-id> <category>selections</category><body package="OldBrowsers" selector="defaultAttribute">defaultAttribute	"Answer the default attribute that this helper is responsible for selecting."	^#category</body></methods><methods><class-id>Tools.NameSpaceOrganizerBrowserHelper</class-id> <category>drag and drop</category><body package="OldBrowsers" selector="addClientDataTo:">addClientDataTo: anIdentityDict 	self hasSelections ifFalse: [^false].	anIdentityDict at: #category put: self selection.	anIdentityDict at: #environment put: self environment.	^true</body><body package="OldBrowsers" selector="canAcceptDropFrom:">canAcceptDropFrom: aDC	^aDC key == self classOrNamespaceKey or: [  aDC key == self selectorOrStaticKey]</body><body package="OldBrowsers" selector="drop:">drop: aDragContext	"A drop has occured in the category list of the browser. see if we can accept and if so move the class(es)."	| ctrl idx cNameArray |	(self canAcceptDropFrom: aDragContext) ifFalse:[^#dragEffectNone ].	self browser changeRequest ifFalse: [^#dropEffectNone].	"Locate the target category's index"	ctrl := aDragContext clientData at: #ctrl.	idx := ctrl view targetIndex.	idx = 0 ifTrue: [^#dropEffectNone].	"If the data is not available in the correct format, do not drop."	cNameArray := aDragContext sourceData clientData 				at: self classOrNamespaceKey ifAbsent: [^#dropEffectNone].	"Move the class or namspace to the new category"	"The class name is in the clientData of the dropSource"	cNameArray do:[:eachCName | 		eachCName environment classifySymbol: eachCName name under: (self module list list at: idx) value.		ChangeSet changeClass: eachCName ].	"Restore the state of the list before leaving."	self restoreListStateFrom: aDragContext clientData.	aDragContext clientData: nil.	self nextModule updateList.	^#dropEffectMove</body><body package="OldBrowsers" selector="getDragDropKey">getDragDropKey	"return the data key for the drag"	^self categoryKey</body></methods><methods><class-id>Tools.NameSpaceOrganizerBrowserHelper class</class-id> <category>menus accessing</category><body package="OldBrowsers" selector="menuHeader">menuHeader	^(#Category &lt;&lt; #menus &gt;&gt; '&amp;Category') asString</body></methods><methods><class-id>Tools.ParcelNameSpaceOrganizerBrowserHelper</class-id> <category>emphasis</category><body package="OldBrowsers" selector="textEmphasisForItem:">textEmphasisForItem: anItem	^self emphasizer 		emphasisForCategory: anItem		in: self environment		for: self browser 		id: self selectionId</body></methods><methods><class-id>Tools.ParcelNameSpaceOrganizerBrowserHelper</class-id> <category>menus accessing</category><body package="OldBrowsers" selector="getListMenu:">getListMenu: forMenuBar	| parcels manager |	parcels := IdentitySet new: 16.	manager := self browser manager.	self selections do:		[ :selection | | parcelsOrNil |		parcelsOrNil := manager parcelsForClassOrNameSpace: selection.		nil == parcelsOrNil ifFalse: [ parcels addAll: parcelsOrNil ]		].	^self browser 		addParceling: parcels		to: ( super getListMenu: forMenuBar )		forHelper: self</body></methods><methods><class-id>Tools.ParcelNameSpaceOrganizerBrowserHelper</class-id> <category>private</category><body package="OldBrowsers" selector="filter:">filter: allCategoriesList	| env mgr browser currentParcel usedCategories filteredCategories orgCollection findBindingBlock |	env := self environment isNil ifTrue:[Root] ifFalse:[self environment ].	orgCollection := OrderedCollection new: 100.	self searchChildNamespaces	ifTrue: [ env allNameSpaces do:[:each | orgCollection add: each organization]]	ifFalse:[orgCollection add: env organization ].	findBindingBlock := [:aSymbol | | class | 					class := env at: aSymbol ifAbsent: nil.					class isNil ifFalse:[ env allNameSpaces detect:[:each | | cls| 										cls := env at: aSymbol ifAbsent: nil.										cls isNil ifFalse:[ class := cls. true] ifTrue:[false]] ifNone:[false]]].	mgr := (browser := self browser) manager.	currentParcel := self selectedParcel.	browser isUnparceledFilterOn ifTrue:		[ filteredCategories := OrderedCollection new: 500.		orgCollection do:[:eachOrg | filteredCategories addAll: (allCategoriesList select:			[:cat|			(eachOrg listAtCategoryNamed: cat) contains:				[:cn| browser isUnparceledCodeInClass: (findBindingBlock value: cn) currentParcel: currentParcel]])].			^filteredCategories ].	browser isParcelFilterOn ifFalse: [^allCategoriesList].	browser isConflictsFilterOn ifTrue:		[| conflicts |		conflicts := (browser computeConflictsFor: mgr multiplyParcelledThings						within: (currentParcel notNil ifTrue: [Array with: currentParcel])) last.		usedCategories := conflicts collect: [:class| class category].		^allCategoriesList select: [:cat| usedCategories includes: cat]].	currentParcel == nil ifTrue:		[ filteredCategories := OrderedCollection new: 500.		orgCollection do:[:eachOrg | filteredCategories addAll: (allCategoriesList select:			[:cat|			(eachOrg listAtCategoryNamed: cat) contains:				[:cn| (mgr parcelsForClassOrNameSpace: (findBindingBlock value: cn)) size &gt; 0]])].			^filteredCategories].	usedCategories := IdentitySet new.	usedCategories		addAll: currentParcel definedClasses;		addAll: currentParcel extendedClasses.	usedCategories := usedCategories collect: [:class| class category].	^allCategoriesList select: [:categorySymbol | usedCategories includes: categorySymbol]</body></methods><methods><class-id>Tools.ParcelNameSpaceOrganizerBrowserHelper</class-id> <category>list accessing</category><body package="OldBrowsers" selector="updateListFull">updateListFull	| newList |	newList := self environment == nil			ifTrue: [List new]			ifFalse: [self generateList].	module setNewList: (self filter: newList)</body></methods><methods><class-id>Tools.ParcelNameSpaceOrganizerBrowserHelper</class-id> <category>accessing</category><body package="OldBrowsers" selector="selectCategory:">selectCategory: categoryName	module		select: categoryName asSymbol		whenFinished: ["module updateList"]</body></methods><methods><class-id>Tools.ParcelNameSpaceOrganizerBrowserHelper</class-id> <category>actions</category><body package="OldBrowsers" selector="addSelectionToParcel">addSelectionToParcel	| currentParcel |	self changeRequest ifFalse: [ ^self ].	self browser saveParcelsForUndo.	currentParcel := self currentParcel.	self selectedNamesDo:		[ :name :env | | obj |		( obj := env at: name ) isForClass			ifTrue: [ currentParcel addEntiretyOfClass: obj ]			ifFalse: [ currentParcel addNameSpace: obj ]		].	self browser updateLists</body><body package="OldBrowsers" selector="moveSelectionToParcel:">moveSelectionToParcel: aParcel	"Move the selected category into theParcel according to the current parcel and filtering."	self changeRequest ifFalse: [ ^self ].	self browser saveParcelsForUndo.	self selectedNamesDo:		[ :name :env | | obj |		( obj := env at: name ) isForClass			ifTrue: [ aParcel addEntiretyOfClass: obj ]			ifFalse: [ aParcel addNameSpace: obj ]		].	self browser updateLists.</body><body package="OldBrowsers" selector="removeSelectionFromParcel">removeSelectionFromParcel	| currentParcel |	self changeRequest ifFalse: [ ^self ].	self browser saveParcelsForUndo.	currentParcel := self currentParcel.	self selectedNamesDo:		[ :name :env | | obj |		( obj := env at: name ) isForClass			ifTrue: [ currentParcel removeEntiretyOfClass: obj ]			ifFalse: [ currentParcel removeNameSpace: obj ]		].	self browser updateLists</body></methods><methods><class-id>Tools.ProtocolBrowserHelper</class-id> <category>accessing</category><body package="OldBrowsers" selector="meta">meta	^self browser meta</body><body package="OldBrowsers" selector="windowLabel">windowLabel	^module hasList		ifTrue: [(#xpBrowser &lt;&lt; #labels &gt;&gt; '&lt;1p&gt; Browser')					expandMacrosWith: self selectedClassOrNameSpace ]		ifFalse: [(#xpxsMessageCategoryBrowser &lt;&lt; #labels &gt;&gt; '&lt;1p&gt; {&lt;2s&gt;} Message Category Browser')					expandMacrosWith: self selectedClassOrNameSpace					with: self selection]</body></methods><methods><class-id>Tools.ProtocolBrowserHelper</class-id> <category>list accessing</category><body package="OldBrowsers" selector="selectionChanged">selectionChanged	module nextModule == nil ifTrue: [^super selectionChanged].	self selection == nil ifFalse: [LastProtocol := self selection].	self setSelection.	self browser	batchUpdates: [ module nextModule updateList ]</body><body package="OldBrowsers" selector="updateListFull">updateListFull	| newList target |	( target := self targetClassOrNameSpace ) == nil		ifTrue: [ newList := List new ]		ifFalse: [ newList := target organization categories asList ].	module setNewList: newList</body></methods><methods><class-id>Tools.ProtocolBrowserHelper</class-id> <category>menus accessing</category><body package="OldBrowsers" selector="actionsForMultiSelect">actionsForMultiSelect	^#(#fileOut #hardcopy #add #remove #findMethod)</body><body package="OldBrowsers" selector="actionsForNoSelect">actionsForNoSelect	^self targetClassOrNameSpace == nil		ifTrue: [#()]		ifFalse: [#(#add #findMethod )]</body><body package="OldBrowsers" selector="getListMenu">getListMenu	"Items in the list are either method protocols or static	categories. We need to be sure the label of the 'Find...' 	menu item makes sense. (So the label of that item in	the resource spec on the class side does not actually matter.)"	| menu target |	menu := super getListMenu.	target := self targetClassOrNameSpace.	(menu menuItemWithValue: #findMethod) rawLabel:		((target isNil or: [target isForNameSpace])			ifTrue: [(#FindVariable &lt;&lt; #menus &gt;&gt; 'Find Variable...')]			ifFalse: [(#FindMethod &lt;&lt; #menus &gt;&gt; 'Find Method...')]).	^menu</body></methods><methods><class-id>Tools.ProtocolBrowserHelper</class-id> <category>actions</category><body package="OldBrowsers" selector="add">add	| aString newProtocol target |	self changeRequest ifFalse: [^self].	aString := self			prompt: (#EnterNewCategoryName &lt;&lt; #dialogs &gt;&gt; 'Enter new category name')			initially: (LastProtocol == nil ifTrue: [(#protocolName &lt;&lt; #dialogs &gt;&gt; 'protocol name') asString] ifFalse: [LastProtocol]).	aString isEmpty ifTrue: [^ self].	newProtocol := aString asSymbol.	target := self targetClassOrNameSpace.	target organization addCategory: newProtocol before: self selection.	SourceFileManager default logChange:				('&lt;1p&gt; organization addCategory: &lt;2p&gt; before: &lt;3p&gt;'					expandMacrosWith: target					with: newProtocol					with: module selection).	target reorganize.	module select: newProtocol whenFinished: [module updateList]</body><body package="OldBrowsers" selector="broadcastUpdate:">broadcastUpdate: aspect 	aspect key == #classOrNameSpace		ifTrue: 			[self				setSelection: aspect key				for: self selectionId				to: aspect value.			module hasList				ifTrue: [module select: aspect value whenFinished: [module updateList]]				ifFalse: 					[module forceSelection: aspect value.					self setSelection: aspect value]]		ifFalse: [super broadcastUpdate: aspect]</body><body package="OldBrowsers" selector="fileOut">fileOut	| target suggestion fileName fileManager  |	target := self selectedClassOrNameSpace.	suggestion := self selection isNil					ifTrue: ['-protocols.st']					ifFalse: [self selections size &gt; 1								ifTrue: ['-protocols.st'] 								ifFalse: ['-', self selection, '.st']].	fileName := target name, suggestion.	fileName := Dialog				requestNewFileName: (#FileOutAs &lt;&lt; #dialogs &gt;&gt; 'File out as')				default: ( Filename filterFilename: fileName ). 	fileName isEmpty ifTrue: [ ^nil ].	fileManager := SourceCodeStream write: fileName encoding: self fileEncoding.	[fileManager timeStamp.	 fileManager deferInitializations.	 self selections do: 		[:protocol |		(target isForNameSpace or: [self isData])			ifTrue:				[(target asNameSpace organization listAtCategoryNamed: protocol) do:					[:key | | ref |					ref := target asNameSpace fullyQualifiedReferenceOf: key.					fileManager storeObjectDefinition: ref.					ref binding hasInitializer ifTrue:						[fileManager initializeThisObject: ref]]]			ifFalse:				[fileManager fileOutMessages: (target organization listAtCategoryNamed: protocol) for: target]].	 fileManager finishInitializations]  				ensure: [ fileManager close ]</body><body package="OldBrowsers" selector="findMethod">findMethod	"Show a list of the methods implemented by this class, 	OR a list of statics.  Select the chosen one."	| collection target prompt chosen |	( target := self targetClassOrNameSpace ) == nil	ifTrue: [ ^self ].	self changeRequest ifFalse: [ ^self ].	prompt := target isForNameSpace		ifTrue: [ (#FindWhichSharedVariableQ &lt;&lt; #dialogs &gt;&gt; 'Find which shared variable?') ] ifFalse: [ (#FindWhichMethodQ &lt;&lt; #dialogs &gt;&gt; 'Find which method?') ].	( collection := target organization elements asSortedCollection ) size = 0		ifTrue: [ ^self ].	chosen := Dialog			choose: prompt			fromList: collection			values: collection			lines: 20			cancel: [nil]			for: self interfaceWindow.	chosen isNil ifFalse:		[module select: ( target organization categoryOfElement: chosen )			whenFinished: [module nextModule					select: chosen					whenFinished: [module updateList]]].</body><body package="OldBrowsers" selector="hardcopy">hardcopy	"Print out protocol."	| stream |	stream := TextStream on: (String new: 1000).	self selections do: 		[ :protocol |		self targetClassOrNameSpace printOutCategory: protocol on: stream		].	self hardcopyStream: stream</body><body package="OldBrowsers" selector="remove">remove	"Remove the selected protocol if the user confirms.	Answer a Boolean indicating whether a protocol has indeed been removed."	| keys target |	self changeRequest ifFalse: [ ^false ].	target := self targetClassOrNameSpace.	keys := Set new.	module selections do: 		[ :protocol |		keys addAll: ( target organization listAtCategoryNamed: protocol )		].	keys isEmpty 		ifFalse:			[ ( Dialog confirm: (#YouWantToRemoveMethodsInCategoriesQ &lt;&lt; #dialogs &gt;&gt; 'Are you certain that you want to&lt;n&gt;remove all methods in these categories?')								expandMacros						for: self interfaceWindow)				ifFalse: [ ^false ].			target isForNameSpace 				ifTrue: [ keys do: [ :key | | ref |					ref := BindingReference simpleName: key in: target namedReferent.					(target includesKey: key) ifTrue: [ref removeFromSystem]]]				ifFalse: [ keys do: [:sel | target removeSelector: sel ] ]			].	module selections do: 		[ :protocol |		target organization removeCategory: protocol.		self logProtocolChange: ('&lt;1p&gt; organization removeCategory: &lt;2p&gt;'					expandMacrosWith: target					with: protocol)].	target reorganize.	module updateList.	^true</body><body package="OldBrowsers" selector="rename">rename	| aString newProtocol target |	self changeRequest ifFalse: [^self].	target := self targetClassOrNameSpace.	aString := self prompt: (#EnterNewCategoryName &lt;&lt; #dialogs &gt;&gt; 'Enter new category name') initially: self selection.	aString isEmpty ifTrue: [^ self].	newProtocol := aString asSymbol.	( target renameCategory: module selection to: newProtocol)		ifTrue:			[self logProtocolChange: ('&lt;1p&gt; organization renameCategory: &lt;2p&gt; to: &lt;3p&gt;'						expandMacrosWith: target						with: self selection						with: newProtocol).			module select: newProtocol whenFinished: [module updateList]]</body><body package="OldBrowsers" selector="selectProtocol:">selectProtocol: aSymbol	module select: aSymbol whenFinished: [module updateList]</body><body package="OldBrowsers" selector="spawn">spawn	| target |	( target := self targetClassOrNameSpace ) isForClass		ifTrue: [ self browser spawnOnClass: target protocol: self selection ]		ifFalse: 	[ self browser spawnOnNameSpace: target protocol: self selection ]</body></methods><methods><class-id>Tools.ProtocolBrowserHelper</class-id> <category>text processing</category><body package="OldBrowsers" selector="doItEnvironment">doItEnvironment	| target |	( target := self selectedClassOrNameSpace ) == nil		ifTrue: [ ^nil ].	^target isForNameSpace		ifTrue: [ target ]		ifFalse: [ target environment ]</body><body package="OldBrowsers" selector="doItReceiver">doItReceiver	| target |	( target := self selectedClassOrNameSpace ) == nil		ifTrue: [ ^nil ].	^target isForNameSpace		ifTrue: [ target ]		ifFalse: [ target instanceBehavior ]</body><body package="OldBrowsers" selector="explainerClass">explainerClass	^self selectedClassOrNameSpace</body><body package="OldBrowsers" selector="formatFor:">formatFor: aController	"Format the text. Have the controller replace its contents with the new Text, 	or nil if the format operation was unsuccessful."	| selectedClass aCompiler newText aText |	selectedClass := self targetClassOrNameSpace.	( selectedClass isNil or: [ selectedClass isForNameSpace ] )		ifTrue: [ ^self ].	aText := aController text.	aCompiler := selectedClass compilerClass new.	newText := aCompiler			format: aText			in: selectedClass			notifying: aController.	newText == nil		ifFalse: [ newText := newText asText makeSelectorBoldIn: selectedClass ].	newText == nil		ifFalse:			[ aController				selectFrom: 1 to: aController text size;				deselect;				replaceSelectionWith: newText asText;				selectAt: 1			]</body><body package="OldBrowsers" selector="text">text	| target |	target := self targetClassOrNameSpace.	^( ( self selection == nil ) |  ( target == nil ) )		ifTrue: 			[ self selections isEmpty				ifTrue: [ nil ]				ifFalse: [ Text new ]			]		ifFalse: 			[ ^( target isForClass				ifTrue: [ target sourceCodeTemplate ]				ifFalse: [ self module templateBinding: target category: self selection ]			   )  asText			].</body></methods><methods><class-id>Tools.ProtocolBrowserHelper</class-id> <category>selections</category><body package="OldBrowsers" selector="defaultAttribute">defaultAttribute	"Answer the default attribute that this helper is responsible for selecting."	^#protocol</body><body package="OldBrowsers" selector="setSelection">setSelection	"Inform the browser that the selection has changed;	unlike the superclass allow multiple selections."	self setSelection: self selections</body></methods><methods><class-id>Tools.ProtocolBrowserHelper</class-id> <category>drag and drop</category><body package="OldBrowsers" selector="addClientDataTo:">addClientDataTo: anIdentityDict 	self hasSelections ifFalse: [^false].	anIdentityDict at: #class put: self targetClassOrNameSpace.	anIdentityDict at: #protocol put: self selections.	anIdentityDict at: #meta put: self meta.	anIdentityDict at: #category put: self category.	^true</body><body package="OldBrowsers" selector="canAcceptDropFrom:">canAcceptDropFrom: aDC	^aDC key == self selectorOrStaticKey or: [  aDC key == self protocolKey]</body><body package="OldBrowsers" selector="drop:">drop: aDragContext	"A drop has occured in the protocol list of the browser. see if we can accept and if so move the methods."	| ctrl idx prot protUnder protocolList selectors statics |	(self canAcceptDropFrom: aDragContext)  ifFalse: [^#dropEffectNone].	"Locate the target protocol's index"	aDragContext clientData isNil ifTrue: [aDragContext clientData: self module initialListDropState].	ctrl := aDragContext clientData at: #ctrl 				ifAbsent: 					[self module addControllerDataTo: aDragContext clientData. 					ctrl := aDragContext clientData at: #ctrl].	(idx := ctrl view targetIndex) = 0 ifTrue: [^#dropEffectNone].	protocolList := self module list list.	"If a protocol has been dropped, do not do a move unless from the same browser."	aDragContext key == self protocolKey ifTrue: [		prot := aDragContext sourceData clientData at: #protocol.		idx := ctrl view elementIndexFor: ctrl sensor cursorPoint.  		protUnder := idx &lt; protocolList  size ifTrue: [protocolList  at: idx].		"Ignore other browsers"		aDragContext data contextApplication ~~ self module browser ifTrue: [^#dropEffectNone].		prot do:[:eachProtocol | self selectedClassOrNameSpace organization addCategory: eachProtocol value before: protUnder value.].		(self selectedClassOrNameSpace) 			reorganize; 			logOrganizationChange.		self module updateList.		^#dropEffectMove].	"If there are changes to the text, prompt before discarding them"	self changeRequest ifFalse: [^#dropEffectNone].	"If the data is not available in the correct format, do not drop."	selectors := aDragContext sourceData clientData at: #selector ifAbsent: [#()].	statics := aDragContext sourceData clientData at: #data ifAbsent: [#()].	(selectors isEmpty and: [statics isEmpty]) ifTrue: [^#dropEffectNone].	"Move the selector to the new protocol.  The selector is in the clientData of the dropSource"	selectors do:[:eachSelector |  self moveSelector: eachSelector intoProtocol: ((protocolList  at: idx) value)].	statics do: [:eachStatic |  eachStatic environment asNameSpace classifySymbol: eachStatic name under:  ((protocolList  at: idx) value)].	"Restore the state of the protocol list before leaving."	self restoreListStateFrom: aDragContext clientData.	aDragContext clientData: nil.	self module updateList.	self module nextModule updateList.	^#dropEffectMove</body><body package="OldBrowsers" selector="getDragDropKey">getDragDropKey	"return the data key for the drag"	^self protocolKey</body><body package="OldBrowsers" selector="moveSelector:intoProtocol:">moveSelector: aSelectorSymbol intoProtocol: aProtocolSymbol 	"Move aSelectorSymbol to protocol named aProtocolSymbol."	| destClass |	destClass := self targetClassOrNameSpace.	destClass classifySymbol: aSelectorSymbol under: aProtocolSymbol.	self module logProtocolChange: destClass fullName , ' organization classify: ' , 			aSelectorSymbol storeString , ' under: ' , aProtocolSymbol storeString.	Transcript cr; show: ((#MethodInNewProtocol &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt;%&gt;%&gt;&lt;2s&gt; &lt;nt&gt;moved from protocol ''&lt;3s&gt;'' to protocol ''&lt;4s&gt;''')			expandMacrosWith: destClass printString			with: aSelectorSymbol asString			with: self selection asString			with: aProtocolSymbol asString).	self nextModule updateList</body></methods><methods><class-id>Tools.ProtocolBrowserHelper class</class-id> <category>menus accessing</category><body package="OldBrowsers" selector="menuHeader">menuHeader	^(#Protocol &lt;&lt; #menus &gt;&gt; '&amp;Protocol') asString</body></methods><methods><class-id>Tools.ParcelProtocolBrowserHelper</class-id> <category>emphasis</category><body package="OldBrowsers" selector="setButtonEmphasisFor:">setButtonEmphasisFor: classOrNameSpace 	| buttons |	module builder == nil ifTrue: [^self].	buttons := self emphasizer 				emphasisForClassButtons: classOrNameSpace				for: self browser				id: self selectionId.	buttons with: #(#instanceButton #classButton #dataButton)		do: 			[:emphasis :componentName | 			| component widget text |			(component := module builder componentAt: componentName) ~~ nil 				ifTrue: 					[text := (widget := component widget) label text.					(text emphasisAt: 1) ~= emphasis 						ifTrue: 							[text emphasizeAllWith: emphasis.							widget invalidate.							widget label text: text.							widget invalidate]]]</body><body package="OldBrowsers" selector="textEmphasisForItem:">textEmphasisForItem: anItem	^self emphasizer emphasisForProtocol: anItem for: self browser id: self selectionId</body></methods><methods><class-id>Tools.ParcelProtocolBrowserHelper</class-id> <category>menus accessing</category><body package="OldBrowsers" selector="getListMenu:">getListMenu: forMenuBar	| protocol parcels cl parcelsForClass selectorsInProtocol |	(protocol := self selection) isNil		ifTrue: [parcels := #()]		ifFalse:			[parcels := IdentitySet new: 4.			cl := self selectedClassOrNameSpace.			nil == (parcelsForClass := self browser manager parcelsForClassOrNameSpace: cl) ifFalse:				[selectorsInProtocol := cl organization listAtCategoryNamed: protocol.				parcelsForClass do:					[:p|					selectorsInProtocol do:						[:sel|						(p definesSelector: sel forClass: cl) ifTrue: [parcels add: p]]]]].	^self browser 		addParceling: parcels		to: (super getListMenu: forMenuBar)		forHelper: self</body></methods><methods><class-id>Tools.ParcelProtocolBrowserHelper</class-id> <category>list accessing</category><body package="OldBrowsers" selector="updateListFull">updateListFull	| class list |	( class := self targetClassOrNameSpace ) == nil		ifTrue: [ list := List new ]		ifFalse: 	[ list := class organization categories asList ].	self setButtonEmphasisFor: class.	module setNewList: ( self filter: list )</body></methods><methods><class-id>Tools.ParcelProtocolBrowserHelper</class-id> <category>private</category><body package="OldBrowsers" selector="filter:">filter: protocols	| class browser parcels currentParcel |	(protocols isEmpty or: [(class := self targetClassOrNameSpace) isNil]) ifTrue:		[^protocols].	class isForNameSpace ifTrue: [ ^self filterStatics: protocols in: class ].	browser := self browser.	currentParcel  := self selectedParcel.	browser isUnparceledFilterOn ifTrue:		[(parcels := browser currentParcelsFor: class currentParcel: currentParcel) isEmpty			ifTrue: [^protocols].		^protocols select:			[:prot| | list |			(list := class organization listAtCategoryNamed: prot) isEmpty			or: [list contains:					[:sel|					parcels contains: [:p| (p definesSelector: sel forClass: class) not]]]]].	browser isParcelFilterOn ifFalse: [^protocols].	browser isConflictsFilterOn ifTrue:		[| conflicts |		conflicts := browser computeConflictsFor: (Set with: class instanceBehavior)						within: (currentParcel notNil ifTrue: [Array with: currentParcel]).		conflicts := conflicts first collect: [:md| md protocol].		^protocols select: [:prot| conflicts includes: prot]].	(parcels := self browser currentParcelsFor: class currentParcel: currentParcel ) isNil 		ifTrue:[ parcels := #() ].	^protocols select:		[:prot|		prot == #'parcel load/unload/save'		or: [parcels contains:				[:p|				(p definedSelectorsFor: class andProtocol: prot) size &gt; 0]]]</body><body package="OldBrowsers" selector="filterStatics:in:">filterStatics: protocols in: nameSpace	| browser currentParcel org mgr usedCategories classOrNameSpace |	classOrNameSpace := nameSpace namedReferent.	mgr := (browser := self browser) manager.	currentParcel  := self selectedParcel.	org := nameSpace organization.	browser isUnparceledFilterOn ifTrue:		[^protocols select:			[:cat|			(org listAtCategoryNamed: cat) contains:				[:bn| | binding |				binding := nameSpace bindingFor: bn.				binding isForNameSpace "Treat NameSpaces as flat; don't consider contained NameSpaces"					ifTrue: [(mgr parcelsForClassOrNameSpace: binding value) size = 0]					ifFalse:						[binding isForClass							ifTrue: [browser									isUnparceledCodeInClass: binding value									currentParcel: currentParcel]							ifFalse: [(mgr parcelsForBinding: binding) size = 0]]]]].	browser isParcelFilterOn ifFalse: [^protocols].	browser isConflictsFilterOn ifTrue:		[| multiplyParcelledThings conflicts |		 multiplyParcelledThings := mgr multiplyParcelledThings.		 classOrNameSpace isBehavior ifTrue:			[^protocols select:				[:cat|				(org listAtCategoryNamed: cat) contains:					[:bn|					(multiplyParcelledThings includes: (nameSpace bindingFor: bn))					and: [currentParcel isNil or: [currentParcel definesName: bn in: classOrNameSpace]]]]].		 conflicts := browser						computeConflictsFor: (multiplyParcelledThings select: [:thing| thing isBehavior])						within: (currentParcel notNil ifTrue: [Array with: currentParcel]).		^protocols select:			[:cat| | list |			(list := org listAtCategoryNamed: cat) isEmpty			or: [list contains:				[:bn| | binding parcels |				binding := nameSpace bindingFor: bn.				binding isForNameSpace					ifTrue:						[parcels := (mgr parcelsForClassOrNameSpace: binding value) select:										[:p| p definesObject: binding value].						parcels size &gt; 1 and: [currentParcel isNil or: [parcels includes: currentParcel]]]					ifFalse:						[binding isForClass							ifTrue:								[((conflicts last contains: binding value)								  or: [conflicts first contains:										[:md| md protocol == cat and: [md class == binding value]]])]							ifFalse: [(conflicts at: 2) includes: binding]]]]]].	currentParcel == nil ifTrue:		[^protocols select:			[:cat| | list |			(list := org listAtCategoryNamed: cat) isEmpty			or: [list contains:				[:bn| | binding |				binding := nameSpace bindingFor: bn.				(binding isForNameSpace				or: [binding isForClass])					ifTrue: [(mgr parcelsForClassOrNameSpace: binding value) size &gt; 0]					ifFalse: [(mgr parcelsForBinding: binding) size &gt; 0]]]]].	classOrNameSpace isBehavior ifTrue:		[^protocols select:			[:cat| | list |			(list := org listAtCategoryNamed: cat) isEmpty			or: [list contains:					[:bn|					currentParcel definesName: bn in: classOrNameSpace]]]].	usedCategories := IdentitySet new.	usedCategories		addAll: currentParcel definedClasses;		addAll: currentParcel extendedClasses.	usedCategories := usedCategories collect: [:class| class category].	^protocols select: [:categorySymbol | usedCategories includes: categorySymbol]</body></methods><methods><class-id>Tools.ParcelProtocolBrowserHelper</class-id> <category>actions</category><body package="OldBrowsers" selector="addSelectionToParcel">addSelectionToParcel	| target parcel selectorsOrKeys |	self changeRequest ifFalse: [^self].	self browser saveParcelsForUndo.	target := self targetClassOrNameSpace.	parcel := self selectedParcel.	selectorsOrKeys := target organization listAtCategoryNamed: self selection.	target isForNameSpace		ifTrue: [parcel addNames: selectorsOrKeys in: target]		ifFalse: [parcel addSelectors: selectorsOrKeys forClass: target].	self browser updateLists</body><body package="OldBrowsers" selector="moveSelectionToParcel:">moveSelectionToParcel: aParcel	"Move all methods in the current protocol into aParcel according to the following rules.	 If no Parcel is selected ...		If filtering is off then move all the methods to theParcel		and remove all the methods from all other parcels.	 	If filtering is on then move all the methods that are defined		by other parcels into theParcel, and remove just those methods		from all other parcels.	 If a Parcel is selected ...		move all the methods that are defined in the selected Parcel to		theParcel and remove just those methods from the selected parcel."	| theClass |	self changeRequest ifFalse: [^self].	self  browser saveParcelsForUndo.	theClass := self targetClassOrNameSpace.	( theClass isForNameSpace or: [ self isData ] )		ifTrue: [ ^Dialog warn: (#MoveOfSharedVariableNotYetSupported &lt;&lt; #dialogs &gt;&gt; 'Move of shared variables not yet supported.'). ].	self browser moveSelectors: (theClass organization listAtCategoryNamed: self selection)		inClass: theClass		toParcel: aParcel.	self browser updateBrowser</body><body package="OldBrowsers" selector="remove">remove	"Override to ensure the parcel forgets the protocol if removed."	| removed parcel |	(removed := super remove) ifTrue:		[(parcel := self selectedParcel) notNil ifTrue: [parcel cleanse]].	^removed</body><body package="OldBrowsers" selector="removeSelectionConflictsFromParcel">removeSelectionConflictsFromParcel	self unimplemented</body><body package="OldBrowsers" selector="removeSelectionFromParcel">removeSelectionFromParcel	| target parcel|	self changeRequest ifFalse: [^self].	self browser saveParcelsForUndo.	target := self targetClassOrNameSpace.	parcel := self selectedParcel.	target isForNameSpace		ifTrue: [ ^Dialog warn: (#NotImplemented &lt;&lt; #dialogs &gt;&gt; 'Not implemented.'). ]		ifFalse: [ parcel removeSelectors: ( target organization listAtCategoryNamed: self selection )  							forClass: target ].	self browser updateLists</body></methods><methods><class-id>Tools.BrowserHelper</class-id> <category>utility</category><body package="OldBrowsers" selector="findASomething:">findASomething: prompt		"Repeatedly prompt the user for a name or pattern, allowing retries	until the user cancel's or returns an empty string.	Answer the obj or nil"	| test |	[ test := self pickASomething: prompt.	( test == false )		and:	[ ( Dialog confirm: (#NoMatchingObjectTryAgainQ &lt;&lt; #dialogs &gt;&gt; 'No matching object, try again?') for: self interfaceWindow )					ifFalse: [ ^nil ]					ifTrue: [ true ] 		]	] whileTrue.	^test</body><body package="OldBrowsers" selector="pickASomething:">pickASomething: prompt 	"Choose a class, namespace or global name with a prompter."	"Prompt the user for a name or pattern. 	Answer nil if the user cancelled. 	Answer the class/namespace, if there is only one class/namespace that matches. 	If there is more than one match, prompt the user with a choice of matches, and	return the selected or an empty string. 	If there are no matches, answer the first global name that 		matches, or nil if there are none."	| destName pick matches |	destName := Dialog request: prompt for: self interfaceWindow.	destName = '' ifTrue: [^nil].	Cursor execute		showWhile: 			[| objects |			objects := Root withAllNameSpacesAndAllClassesAndStatics.			matches := objects select: [:mod | (destName includes: $.)							ifFalse: [destName match: mod name]							ifTrue: [destName match: mod fullName]]].	(matches == nil or: [matches size = 0])		ifTrue: [^false].	matches size = 1 ifTrue: [^matches first].	matches := matches asSortedCollection: [:a :b | a fullName &lt; b fullName].	pick := PickASomethingDialog pickASomethingFrom: (matches collect: [:m | self decorateForAnyType: m]).	^pick value</body></methods><methods><class-id>Tools.BlankUI class</class-id> <category>interface specs</category><body package="OldBrowsers" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{FullSpec} 		#window: 		#(#{WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #labels) 			#min: #(#{Point} 20 20 ) 			#bounds: #(#{Rectangle} 260 292 460 492 ) ) 		#component: 		#(#{SpecCollection} 			#collection: #(				#(#{SequenceViewSpec} 					#layout: #(#{LayoutFrame} 1 0 1 0 -1 1 -1 1 ) 					#model: #blankList ) ) ) )</body></methods><methods><class-id>Tools.ParcelListBrowserHelper class</class-id> <category>resources</category><body package="OldBrowsers" selector="defTypeMenu">defTypeMenu	"MenuEditor new openOnClass: self andSelector: #defTypeMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #ParcelComment #defaultString: 'Parcel comment' #catalogID: #menus) 				#nameKey: #parcelComment 				#value: #parcelComment ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #parcelSummary 					#defaultString: 'Parcel summary' 					#catalogID: #menus ) 				#nameKey: #parcelSummary 				#value: #parcelSummary ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #DanglingReferences #defaultString: 'Dangling references' #catalogID: #menus) 				#nameKey: #parcelDanglingReferences 				#value: #parcelDanglingReferences ) ) #(3 ) nil ) decodeAsLiteralArray</body><body package="OldBrowsers" selector="listMenu">listMenu	"MenuEditor new openOnClass: self andSelector: #listMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_NewDot #catalogID: #menus #defaultString: '&amp;New...') 				#nameKey: #newParcel 				#value: #newParcel ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_LoadDot #catalogID: #menus #defaultString: '&amp;Load...') 				#nameKey: #loadParcel 				#value: #loadParcel ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_SaveDot #catalogID: #menus #defaultString: '&amp;Save...') 				#nameKey: #saveParcelDialog 				#value: #saveParcelDialog ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #FileOutAsDot #catalogID: #menus #defaultString: 'File &amp;Out As...') 				#nameKey: #fileOutParcel 				#value: #fileOutParcel ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Re_nameAsDot #catalogID: #menus #defaultString: 'Re&amp;name As...') 				#nameKey: #renameParcel 				#value: #renameParcel ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #UnloadDot #catalogID: #menus #defaultString: '&amp;Unload...') 				#nameKey: #unloadParcel 				#value: #unloadParcel ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_RemoveDot #catalogID: #menus #defaultString: '&amp;Remove...') 				#nameKey: #removeParcel 				#value: #removeParcel ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Discard #catalogID: #menus #defaultString: '&amp;Discard') 				#nameKey: #discardParcel 				#value: #discardParcel ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Empty #catalogID: #menus #defaultString: '&amp;Empty') 				#nameKey: #emptyParcel 				#value: #emptyParcel ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #BuildDot #catalogID: #menus #defaultString: '&amp;Build...') 				#nameKey: #buildSubMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #AddFileIn #catalogID: #menus #defaultString: 'Add &amp;File-In') 							#nameKey: #fileIntoParcel 							#value: #fileIntoParcel ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #AddChanges #catalogID: #menus #defaultString: 'Add &amp;Changes') 							#nameKey: #addChangeSet 							#value: #addChangeSet ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #RemoveChanges #catalogID: #menus #defaultString: '&amp;Remove Changes') 							#nameKey: #removeChangeSet 							#value: #removeChangeSet ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #AddToChanges #catalogID: #menus #defaultString: 'Add &amp;to Changes') 							#nameKey: #addToChanges 							#value: #addToChanges ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #RemoveFromChanges #catalogID: #menus #defaultString: 'Remove &amp;from Changes') 							#nameKey: #removeFromChanges 							#value: #removeFromChanges ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #MakeRemoveScript #catalogID: #menus #defaultString: '&amp;Make Remove Script') 							#nameKey: #removeScript 							#value: #removeScript ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ComputePrerequisites #catalogID: #menus #defaultString: '&amp;Compute Prerequisites') 							#nameKey: #showComputedPrerequisites 							#value: #showComputedPrerequisites ) ) #(3 4 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Browse #catalogID: #menus #defaultString: '&amp;Browse') 				#nameKey: #browseSubMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ImportedClassReferences #catalogID: #menus #defaultString: '&amp;Imported Class References') 							#value: #browseClassImports ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ExportedClassReferences #catalogID: #menus #defaultString: '&amp;Exported Class References') 							#value: #browseClassExports ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #UnparcelledMethodsUsedExclusively #catalogID: #menus #defaultString: 'Unparcelled Methods &amp;Used Exclusively') 							#value: #browseExclusiveMethodImports ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #UnparcelledMethodsInDefinedClasses #catalogID: #menus #defaultString: 'Unparcelled Methods in &amp;Defined Classes') 							#value: #browseUnparceledMethodsOnDefinedClasses ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ExtensionMethods #catalogID: #menus #defaultString: '&amp;Extension Methods') 							#value: #browseExtensionMethods ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #OverriddenExtensions #catalogID: #menus #defaultString: '&amp;Overridden Extensions') 							#value: #browseOverriddenExtensions ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #MethodsOverriddenByOthers #catalogID: #menus #defaultString: '&amp;Methods Overridden by Others') 							#nameKey: #browseOverriddenByOthers 							#value: #browseOverriddenByOthers ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ChangedMethods #catalogID: #menus #defaultString: 'C&amp;hanged Methods') 							#value: #browseChangedMethods ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Dan_glingReferences #catalogID: #menus #defaultString: 'Dan&amp;gling References') 							#value: #browseDanglingReferences ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ReferencesToDot #catalogID: #menus #defaultString: '&amp;References to...') 							#value: #browseSendersOf ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ImplementorsOfDot #catalogID: #menus #defaultString: '&amp;Implementors of...') 							#value: #browseImplementorsOf ) ) #(4 3 2 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Filter #catalogID: #menus #defaultString: 'Fi&amp;lter') 				#nameKey: #filter 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ShowOnlyParceled #catalogID: #menus #defaultString: 'Show Only &amp;Parceled')							#nameKey: #showOnlyParceled							#value: #toggleParceled ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ShowOnlyUnparceled #catalogID: #menus #defaultString: 'Show Only &amp;Unparceled') 							#nameKey: #showOnlyUnparceled							#value: #toggleUnparceled ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ShowMultiplyParceled #catalogID: #menus #defaultString: 'Show &amp;Multiply Parceled') 							#nameKey: #showMultiplyParceled							#value: #toggleConflicts ) ) #(3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #PropertiesDot #catalogID: #menus #defaultString: '&amp;Properties...') 				#value: #openParcelProperties ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #UndoLastParcelling #catalogID: #menus #defaultString: '&amp;Undo Last Parcelling') 				#nameKey: #doUndo 				#value: #doUndo ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Inspect #catalogID: #menus #defaultString: '&amp;Inspect') 				#value: #inspectParcel ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_FindDot #catalogID: #menus #defaultString: '&amp;Find...') 				#nameKey: #find 				#value: #find ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Update #catalogID: #menus #defaultString: '&amp;Update') 				#nameKey: #updateBrowser 				#value: #updateBrowser ) ) #(2 2 3 2 3 3 2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.MorphingBrowserModule class</class-id> <category>resources</category><body package="OldBrowsers" selector="metaMenu">metaMenu	"MenuEditor new openOnClass: self andSelector: #metaMenu"	&lt;resource: #menu&gt;	^#(#{Menu} #(			#(#{MenuItem} 				#rawLabel: 				#(#{UserMessage} 					#key: #InstanceDefinitions 					#defaultString: '&amp;Instance Methods' 					#catalogID: #menus ) 				#nameKey: #instance 				#value: #instance ) 			#(#{MenuItem} 				#rawLabel: 				#(#{UserMessage} 					#key: #ClassDefinitions 					#defaultString: '&amp;Class Methods' 					#catalogID: #menus ) 				#nameKey: #class 				#value: #class ) 			#(#{MenuItem} 				#rawLabel: 				#(#{UserMessage} 					#key: #Data 					#defaultString: '&amp;Shared Variables' 					#catalogID: #menus ) 				#nameKey: #data 				#value: #data ) ) #(3 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>UI.TabbedDialog class</class-id> <category>interface specs</category><body package="OldBrowsers" selector="activeAreaSpec">activeAreaSpec	"UIPainter new openOnClass: self andSelector: #activeAreaSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #windowLabel 			#min: #(#Point 265 317 ) 			#max: #(#Point 265 317 ) 			#bounds: #(#Rectangle 260 120 525 437 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#SubCanvasSpec 					#layout: #(#LayoutFrame 2 0 2 0 -2 1 -2 1 ) 					#name: #activeComponents 					#flags: 0 ) ) ) )</body><body package="OldBrowsers" selector="windowMenuSpec">windowMenuSpec	"UIPainter new openOnClass: self andSelector: #windowMenuSpec"	&lt;resource: #canvas&gt;	^#(#{FullSpec} 		#window: 		#(#{WindowSpec} 			#label: #windowLabel 			#min: #(#{Point} 378 325 ) 			#bounds: #(#{Rectangle} 244 138 622 463 ) 			#isEventDriven: true ) 		#component: 		#(#{SpecCollection} 			#collection: #(				#(#{SubCanvasSpec} 					#layout: #(#{LayoutFrame} 2 0 40 0 -2 1 -2 1 ) 					#name: #notebook ) 				#(#{MenuButtonSpec} 					#layout: #(#{LayoutFrame} 2 0 8 0 -2 0.5 33 0 ) 					#model: #preferenceChoice 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#requestValueChangeSelector: #requestSliceChange ) 					#menu: #preferenceTopMenu ) ) ) )</body><body package="OldBrowsers" selector="windowNotebookSpec">windowNotebookSpec	"UIPainter new openOnClass: self andSelector: #windowNotebookSpec"	&lt;resource: #canvas&gt;	^#(#{FullSpec} 		#window: 		#(#{WindowSpec} 			#label: #windowLabel 			#min: #(#{Point} 523 340 ) 			#bounds: #(#{Rectangle} 186 175 762 517 ) 			#isEventDriven: true ) 		#component: 		#(#{SpecCollection} 			#collection: #(				#(#{NoteBookSpec} 					#layout: #(#{LayoutFrame} 2 0 5 0 -6 1 -3 1 ) 					#name: #notebook 					#model: #preferenceMasterList 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#requestValueChangeSelector: #requestSliceChange ) 					#rightInset: 120 					#bottomInset: 0 ) ) ) )</body></methods><methods><class-id>Tools.PickASomethingDialog class</class-id> <category>interface specs</category><body package="OldBrowsers" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 728 554 924 781 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0.00440529 0 0.989796 0 0.814978 ) 					#name: #list 					#flags: 15 					#model: #list 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #doubleClick ) 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0918367 0 0.85022 0 0.357143 0 0.960352 ) 					#name: #ok 					#model: #doAccept 					#label: #(#{Kernel.UserMessage} #key: #OK #catalogID: #labels #defaultString: 'OK') 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.642857 0 0.85022 0 0.908163 0 0.960352 ) 					#name: #cancel 					#model: #closeCancel 					#label: #(#{Kernel.UserMessage} #key: #Cancel #catalogID: #labels #defaultString: 'Cancel') 					#defaultable: true ) ) ) )</body></methods><methods><class-id>UI.PackagePropertiesDialog class</class-id> <category>interface specs</category><body package="OldBrowsers" selector="activeAreaSpec">activeAreaSpec	"UIPainter new openOnClass: self andSelector: #activeAreaSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #windowLabel 			#min: #(#{Core.Point} 265 317 ) 			#max: #(#{Core.Point} 418 452 ) 			#bounds: #(#{Graphics.Rectangle} 206 74 595 526 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 33 0 1 0 29 1 -3 1 ) 					#name: #activeComponents 					#flags: 0 ) ) ) )</body><body package="OldBrowsers" selector="deploymentPropertiesSpec">deploymentPropertiesSpec	"UIPainter new openOnClass: self andSelector: #deploymentPropertiesSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #UnlabeledCanvas #catalogID: #labels #defaultString: 'Unlabeled Canvas' ) 			#min: #(#{Core.Point} 274 270 ) 			#bounds: #(#{Graphics.Rectangle} 335 182 728 599 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.03 0 0.85 -3 0.25 0 0.93 ) 					#name: #acceptButton 					#flags: 40 					#model: #deploymentPropertiesAccept 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Accept #catalogID: #labels #defaultString: 'Accept' )					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.25 0 0.85 -3 0.47 0 0.93 ) 					#name: #resetButton 					#flags: 40 					#model: #deploymentPropertiesReset 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Reset #catalogID: #labels #defaultString: 'Reset' )					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.47 0 0.85 -3 0.69 0 0.93 ) 					#name: #removeButton 					#model: #deploymentPropertiesRemove 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Remove #catalogID: #labels #defaultString: 'Remove' )					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.69 0 0.85 -3 0.89 0 0.93 ) 					#model: #helpAction 					#label: #(#{UserMessage} #key: #Help #catalogID: #labels #defaultString: 'Help' ) 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.0305344 0 0.0479616 ) 					#label: #(#{UserMessage} #key: #warningSuppression #catalogID: #labels #defaultString: 'Warning Suppression Action:') ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 14 0 -121 0.4 -66 1 -157 0.8 ) 					#name: #warningSuppressionText 					#model: #warningSuppressionText 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) ) ) ) )</body><body package="OldBrowsers" selector="generalPropertiesSpec">generalPropertiesSpec	"UIPainter new openOnClass: self andSelector: #generalPropertiesSpec"	&lt;resource: #canvas&gt;	^#(#{FullSpec} 		#window: 		#(#{WindowSpec} 			#label: #(#{UserMessage} #key: #UnlabeledCanvas #catalogID: #labels #defaultString: 'Unlabeled Canvas' ) 			#min: #(#{Point} 274 270 ) 			#bounds: #(#{Rectangle} 890 209 1286 657 ) ) 		#component: 		#(#{SpecCollection} 			#collection: #(				#(#{SubCanvasSpec} 					#layout: #(#{LayoutFrame} 10 0 40 0 0 0.9 0 0.8 ) 					#flags: 0 					#majorKey: #{ParcelPropertiesInspector} 					#minorKey: #windowSpec 					#clientKey: #generalProperties ) 				#(#{LabelSpec} 					#layout: #(#{Point} 10 10 ) 					#label: #(#{UserMessage} #key: #generalPropertiesInspector #catalogID: #labels #defaultString: 'General Properties Inspector' )) 				#(#{ActionButtonSpec} 					#layout: #(#{LayoutOrigin} 0 0.1 0 0.9 ) 					#name: #acceptButton 					#flags: 40 					#model: #generalPropertiesAccept 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Accept #catalogID: #labels #defaultString: 'Accept' )					#isDefault: true 					#defaultable: true ) 				#(#{ActionButtonSpec} 					#layout: #(#{LayoutOrigin} 0 0.4 0 0.9 ) 					#name: #resetButton 					#flags: 40 					#model: #generalPropertiesReset 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Reset #catalogID: #labels #defaultString: 'Reset') 					#defaultable: true ) 				#(#{ActionButtonSpec} 					#layout: #(#{LayoutOrigin} 0 0.7 0 0.9 ) 					#model: #helpAction 					#label: #(#{UserMessage} #key: #Help #catalogID: #labels #defaultString: 'Help' )					#defaultable: true ) ) ) )</body><body package="OldBrowsers" selector="loadOptionsSpec">loadOptionsSpec	"UIPainter new openOnClass: self andSelector: #loadOptionsSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #UnlabeledCanvas #catalogID: #labels #defaultString: 'Unlabeled Canvas' ) 			#min: #(#{Core.Point} 274 270 ) 			#bounds: #(#{Graphics.Rectangle} 327 176 720 593 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.03 0 0.85 -3 0.25 0 0.93 ) 					#name: #acceptButton 					#flags: 40 					#model: #loadOptionsAccept 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Accept #catalogID: #labels #defaultString: 'Accept' )					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.25 0 0.85 -3 0.47 0 0.93 ) 					#name: #resetButton 					#flags: 40 					#model: #loadOptionsReset 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Reset #catalogID: #labels #defaultString: 'Reset' )					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.47 0 0.85 -3 0.69 0 0.93 ) 					#name: #removeButton 					#model: #loadOptionsRemove 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Remove #catalogID: #labels #defaultString: 'Remove' )					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.69 0 0.85 -3 0.89 0 0.93 ) 					#model: #helpAction 					#label: #(#{UserMessage} #key: #Help #catalogID: #labels #defaultString: 'Help' )					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.0305344 0 0.0479616 ) 					#label: #(#{UserMessage} #key: #warningSuppression #catalogID: #labels #defaultString: 'Warning Suppression Action:') ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 14 0 -121 0.4 -66 1 -157 0.8 ) 					#name: #warningSuppressionText 					#model: #warningSuppressionText 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) ) ) ) )</body><body package="OldBrowsers" selector="loadSpec">loadSpec	"UIPainter new openOnClass: self andSelector: #loadSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #UnlabeledCanvas #catalogID: #labels #defaultString: 'Unlabeled Canvas' ) 			#min: #(#{Core.Point} 274 270 ) 			#bounds: #(#{Graphics.Rectangle} 601 376 999 825 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 16 6 ) 					#label: #(#{UserMessage} #key: #preLoadAction #catalogID: #labels #defaultString: 'Pre-load Action:') ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 16 0 6 0.4 ) 					#label: #(#{UserMessage} #key: #postLoadAction #catalogID: #labels #defaultString: 'Post-load Action:') ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0 32 0 -64 1 -4 0.4 ) 					#name: #preloadText 					#model: #preloadText 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0 32 0.4 -64 1 -4 0.8 ) 					#name: #postloadText 					#model: #postloadText 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.03 0 0.85 -3 0.25 0 0.93 ) 					#name: #acceptButton 					#flags: 40 					#model: #loadAccept 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Accept #catalogID: #labels #defaultString: 'Accept' )					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.25 0 0.85 -3 0.47 0 0.93 ) 					#name: #resetButton 					#flags: 40 					#model: #loadReset 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Reset #catalogID: #labels #defaultString: 'Reset')					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.47 0 0.85 -3 0.69 0 0.93 ) 					#name: #removeButton 					#model: #loadRemove 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Remove #catalogID: #labels #defaultString: 'Remove' )					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.69 0 0.85 -3 0.89 0 0.93 ) 					#model: #helpAction 					#label: #(#{UserMessage} #key: #Help #catalogID: #labels #defaultString: 'Help' )					#defaultable: true ) ) ) )</body><body package="OldBrowsers" selector="preReadSpec">preReadSpec	"UIPainter new openOnClass: self andSelector: #preReadSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #UnlabeledCanvas #catalogID: #labels #defaultString: 'Unlabeled Canvas' )			#min: #(#{Core.Point} 274 270 ) 			#bounds: #(#{Graphics.Rectangle} 46 67 444 516 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 16 6 ) 					#label: #(#{UserMessage} #key: #preReadAction #catalogID: #labels #defaultString: 'Pre-read Action:' )) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 16 0 6 0.4 ) 					#label: #(#{UserMessage} #key: #PreReqVersion #catalogID: #labels #defaultString: 'Prerequisite Version Selection Action:') ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0 32 0 -64 1 -4 0.4 ) 					#name: #preReadText 					#model: #preReadText 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0 32 0.4 -64 1 -4 0.8 ) 					#name: #versionSelectionText 					#model: #versionSelectionText 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.03 0 0.85 -3 0.25 0 0.93 ) 					#name: #acceptButton 					#flags: 40 					#model: #preReadAccept 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Accept #catalogID: #labels #defaultString: 'Accept' )					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.25 0 0.85 -3 0.47 0 0.93 ) 					#name: #resetButton 					#flags: 40 					#model: #preReadReset 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Reset #catalogID: #labels #defaultString: 'Reset' )					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.47 0 0.85 -3 0.69 0 0.93 ) 					#name: #removeButton 					#model: #preReadRemove 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Remove #catalogID: #labels #defaultString: 'Remove' )					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.69 0 0.85 -3 0.89 0 0.93 ) 					#model: #helpAction 					#label: #(#{UserMessage} #key: #Help #catalogID: #labels #defaultString: 'Help' )					#defaultable: true ) ) ) )</body><body package="OldBrowsers" selector="prerequisitesSpec">prerequisitesSpec	"UIPainter new openOnClass: self andSelector: #prerequisitesSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #UnlabeledCanvas #catalogID: #labels #defaultString: 'Unlabeled Canvas' )			#min: #(#{Core.Point} 274 270 ) 			#bounds: #(#{Graphics.Rectangle} 316 176 709 593 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.03 0 0.85 -3 0.25 0 0.93 ) 					#name: #acceptButton 					#flags: 40 					#model: #prerequisitesAccept 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Accept #catalogID: #labels #defaultString: 'Accept' )					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.25 0 0.85 -3 0.47 0 0.93 ) 					#name: #resetButton 					#flags: 40 					#model: #prerequisitesReset 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Reset #catalogID: #labels #defaultString: 'Reset' )					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.47 0 0.85 -3 0.69 0 0.93 ) 					#name: #removeButton 					#model: #prerequisitesRemove 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Remove #catalogID: #labels #defaultString: 'Remove' )					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.69 0 0.85 -3 0.89 0 0.93 ) 					#model: #helpAction 					#label: #(#{UserMessage} #key: #Help #catalogID: #labels #defaultString: 'Help' )					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.0356234 0 0.028777 ) 					#label: #(#{UserMessage} #key: #deploymentPrerequisites #catalogID: #labels #defaultString: 'Deployment Prerequisites:' ) )				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0 32 0 -64 1 -4 0.4 ) 					#name: #deploymentPrerequisitesText 					#model: #deploymentPrerequisitesText 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.0407125 0 0.414868 ) 					#label: #(#{UserMessage} #key: #developmentPrerequisites #catalogID: #labels #defaultString: 'Development Prerequisites:' )) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0 32 0.4 -64 1 -4 0.8 ) 					#name: #developmentPrerequisitesText 					#model: #developmentPrerequisitesText 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) ) ) ) )</body><body package="OldBrowsers" selector="saveSpec">saveSpec	"UIPainter new openOnClass: self andSelector: #saveSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #UnlabeledCanvas #catalogID: #labels #defaultString: 'Unlabeled Canvas' )			#min: #(#{Core.Point} 274 270 ) 			#bounds: #(#{Graphics.Rectangle} 601 376 999 825 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.03 0 0.85 -3 0.25 0 0.93 ) 					#name: #acceptButton 					#flags: 40 					#model: #saveAccept 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Accept #catalogID: #labels #defaultString: 'Accept' )					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.25 0 0.85 -3 0.47 0 0.93 ) 					#name: #resetButton 					#flags: 40 					#model: #saveReset 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Reset #catalogID: #labels #defaultString: 'Reset' )					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.47 0 0.85 -3 0.69 0 0.93 ) 					#name: #removeButton 					#model: #saveRemove 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Remove #catalogID: #labels #defaultString: 'Remove' )					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.69 0 0.85 -3 0.89 0 0.93 ) 					#model: #helpAction 					#label: #(#{UserMessage} #key: #Help #catalogID: #labels #defaultString: 'Help' )					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 16 6 ) 					#label: #(#{UserMessage} #key: #preSaveAction #catalogID: #labels #defaultString: 'Pre-save Action:') ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0 32 0 -64 1 -4 0.4 ) 					#name: #presaveText 					#model: #presaveText 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) ) ) ) )</body><body package="OldBrowsers" selector="unloadSpec">unloadSpec	"UIPainter new openOnClass: self andSelector: #unloadSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #UnlabeledCanvas #catalogID: #labels #defaultString: 'Unlabeled Canvas' )			#min: #(#{Core.Point} 274 270 ) 			#bounds: #(#{Graphics.Rectangle} 601 376 999 825 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.03 0 0.85 -3 0.25 0 0.93 ) 					#name: #acceptButton 					#flags: 40 					#model: #unloadAccept 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Accept #catalogID: #labels #defaultString: 'Accept' )					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.25 0 0.85 -3 0.47 0 0.93 ) 					#name: #resetButton 					#flags: 40 					#model: #unloadReset 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Reset #catalogID: #labels #defaultString: 'Reset' )					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.47 0 0.85 -3 0.69 0 0.93 ) 					#name: #removeButton 					#model: #unloadRemove 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Remove #catalogID: #labels #defaultString: 'Remove' )					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.69 0 0.85 -3 0.89 0 0.93 ) 					#model: #helpAction 					#label: #(#{UserMessage} #key: #Help #catalogID: #labels #defaultString: 'Help' )					#defaultable: true ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0 32 0 -64 1 -4 0.4 ) 					#name: #preunloadText 					#model: #preunloadText 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0 32 0.4 -64 1 -4 0.8 ) 					#name: #postunloadText 					#model: #postunloadText 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 16 6 ) 					#label: #(#{UserMessage} #key: #preUnloadAction #catalogID: #labels #defaultString: 'Pre-unload Action:') ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 16 0 6 0.4 ) 					#label: #(#{UserMessage} #key: #postUnloadAction #catalogID: #labels #defaultString: 'Post-unload Action:' ) ) ) ) )</body><body package="OldBrowsers" selector="windowNotebookSpec">windowNotebookSpec	"UIPainter new openOnClass: self andSelector: #windowNotebookSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #windowLabel 			#min: #(#{Core.Point} 523 340 ) 			#bounds: #(#{Graphics.Rectangle} 260 158 830 633 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.NoteBookSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 5 0 -35 1 -18 1 ) 					#name: #notebook 					#model: #preferenceMasterList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: #requestSliceChange ) 					#rightInset: 120 					#bottomInset: 0 ) ) ) )</body></methods><methods><class-id>Tools.MethodListBrowserHelper</class-id> <category>actions</category><body package="OldBrowsers" selector="browseClass">browseClass	"Spawn a Browser on the selected method's class.."	&lt;menuItem: #(#BrowseClass #menus 'Browse Class')		nameKey: nil		menu: #(#listMenu)		position: 20.1 &gt;	| definition |	SmalltalkWorkbench browseClass: ((definition := self selection) isBindingReference											ifTrue: [definition environment]											ifFalse: [definition implementingClass]) instanceBehavior</body></methods><methods><class-id>Tools.BrowserTabApplication class</class-id> <category>resources</category><body package="OldBrowsers" selector="blankIcon">blankIcon	"UIMaskEditor new openOnClass: self andSelector: #blankIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 24@24 depth: 1 bitsPerPixel: 1 palette: (Core.MappedPalette withColors: ((Core.Array new: 2) at: 1 put: Graphics.ColorValue red; at: 2 put: Graphics.ColorValue white; yourself)) usingBits: #[255 255 255 0 255 255 255 0 255 255 255 0 247 251 255 0 243 243 255 0 249 231 255 0 252 207 255 0 254 95 255 0 255 63 255 0 255 63 255 0 254 31 255 0 254 223 255 0 252 207 255 0 249 231 255 0 243 243 255 0 243 243 255 0 255 255 255 0 255 255 255 0 255 255 255 0 255 255 255 0 255 255 255 0 255 255 255 0 255 255 255 0 255 255 255 0])</body><body package="OldBrowsers" selector="categoryIcon">categoryIcon	"UIMaskEditor new openOnClass: self andSelector: #categoryIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 24@24 depth: 2 bitsPerPixel: 2 palette: (Core.MappedPalette withColors: ((Core.Array new: 3) at: 1 put: (Graphics.ColorValue scaledRed: 5460 scaledGreen: 5460 scaledBlue: 5460); at: 2 put: Graphics.ColorValue black; at: 3 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 4111 scaledBlue: 0); yourself)) usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 170 170 170 170 128 0 0 2 170 170 170 170 128 0 0 0 0 0 0 0 0 0 0 2 170 170 170 170 128 0 0 2 170 170 170 170 128 0 0 0 0 0 0 0 0 0 0 1 85 85 85 85 64 0 0 1 85 85 85 85 64 0 0 0 0 0 0 0 0 0 0 2 170 170 170 170 128 0 0 2 170 170 170 170 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body></methods><methods><class-id>Tools.NamespaceTabApplication class</class-id> <category>resources</category><body package="OldBrowsers" selector="folderIcon">folderIcon	"UIMaskEditor new openOnClass: self andSelector: #folderIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@17 depth: 2 bitsPerPixel: 2 palette: (Core.MappedPalette withColors: ((Core.Array new: 3) at: 1 put: Graphics.ColorValue black; at: 2 put: Graphics.ColorValue yellow; at: 3 put: Graphics.ColorValue white; yourself)) usingBits: #[170 170 170 168 170 170 170 168 170 170 170 168 170 170 170 168 128 42 170 168 38 64 0 0 0 25 153 144 38 102 102 96 25 153 153 144 38 102 102 96 25 153 153 144 38 102 102 96 25 153 153 144 38 102 102 96 25 153 153 144 0 0 0 0 170 170 170 168])</body></methods><methods><class-id>Tools.ParcelTabApplication class</class-id> <category>resources</category><body package="OldBrowsers" selector="parcelIcon">parcelIcon	"UIMaskEditor new openOnClass: self andSelector: #parcelIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 24@24 depth: 2 bitsPerPixel: 2 palette: (Core.MappedPalette withColors: ((Core.Array new: 4) at: 1 put: (Graphics.ColorValue scaledRed: 5460 scaledGreen: 5460 scaledBlue: 5460); at: 2 put: Graphics.ColorValue black; at: 3 put: Graphics.ColorValue yellow; at: 4 put: (Graphics.ColorValue scaledRed: 4111 scaledGreen: 4111 scaledBlue: 0); yourself)) usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 89 80 0 0 0 0 0 31 239 212 0 0 0 0 0 127 191 116 0 0 0 0 2 170 169 244 0 0 0 0 7 251 246 244 0 0 0 0 31 239 222 244 0 0 0 0 85 149 126 244 0 0 0 0 127 191 126 208 0 0 0 0 127 191 126 64 0 0 0 0 127 191 125 0 0 0 0 0 127 191 116 0 0 0 0 0 127 191 80 0 0 0 0 0 85 85 64 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="OldBrowsers" selector="parcelSubMenu">parcelSubMenu	"MenuEditor new openOnClass: self andSelector: #parcelSubMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #AddTo #catalogID: #menus #defaultString: '&amp;Add To') 				#nameKey: #parcelAddTo				#value: #addSelectionToParcel ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #RemoveFrom #catalogID: #menus #defaultString: '&amp;Remove From') 				#nameKey: #parcelRemoveFrom				#value: #removeSelectionFromParcel ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #MoveTo #catalogID: #menus #defaultString: '&amp;Move To')				#nameKey: #parcelMoveTo ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Locate #catalogID: #menus #defaultString: '&amp;Locate')				#nameKey: #parcelLocate ) ) #(3 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.HierarchicalBrowserModule class</class-id> <category>interface specs</category><body package="OldBrowsers" selector="listSpec">listSpec	"UIPainter new openOnClass: self andSelector: #listSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #labels) 			#bounds: #(#{Graphics.Rectangle} 324 227 524 427 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.HierarchicalViewSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragOkSelector 						#wantToDrag: #dragEnterSelector 						#dragEnter: #dragOverSelector 						#dragOver: #dragStartSelector 						#doDrag: #dropSelector 						#drop: #dragExitSelector 						#dragLeave: ) 					#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0 0 0.99 0 1.0 ) 					#name: #list 					#flags: 15 					#model: #list 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #doubleClick 						#requestValueChangeSelector: 						#testChangeSelection: ) 					#menu: #listMenu 					#useModifierKeys: true 					#selectionType: #normalSelection ) ) ) )</body></methods><methods><class-id>Tools.HierarchyBrowserHelper class</class-id> <category>resources</category><body package="OldBrowsers" selector="listMenu">listMenu	"MenuEditor new openOnClass: self andSelector: #listMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #FileOutAsDot #catalogID: #menus #defaultString: 'File &amp;Out As...') 				#nameKey: #fileOut 				#value: #fileOut ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Spawn #catalogID: #menus #defaultString: '&amp;Spawn') 				#nameKey: #spawn 				#value: #spawn ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Add #catalogID: #menus #defaultString: '&amp;Add') 				#nameKey: #add 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Namespace #catalogID: #menus #defaultString: '&amp;Namespace') 							#nameKey: #addNameSpace 							#value: #addNameSpace ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #SharedVariable #catalogID: #menus #defaultString: '&amp;Shared Variable') 							#nameKey: #addBinding 							#value: #addBinding ) ) #(2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #MoveToDot #catalogID: #menus #defaultString: '&amp;Move To...') 				#nameKey: #moveTo 				#value: #moveTo ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Re_nameAsDot #catalogID: #menus #defaultString: 'Re&amp;name As...') 				#nameKey: #renameAs 				#value: #renameAs ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_RemoveDot #catalogID: #menus #defaultString: '&amp;Remove...') 				#nameKey: #remove 				#value: #remove ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_FindDot #catalogID: #menus #defaultString: '&amp;Find...') 				#nameKey: #find 				#value: #find ) ) #(2 1 3 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.FullNotebookSystemBrowser class</class-id> <category>interface specs</category><body package="OldBrowsers" selector="windowSpec5">windowSpec5	"UIPainter new openOnClass: self andSelector: #windowSpec5"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #windowLabel 			#bounds: #(#{Graphics.Rectangle} 470 369 1024 768 ) 			#flags: 4 			#menu: #menuBar 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 2 0.4 -1 1 -1 1 ) 					#name: #text 					#model: #text 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#textAccepted: ) 					#menu: #textMenu 					#tabRequiresControl: true ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -1 0.4 0 1 2 0.4 ) 					#name: #ResizingSplitter1 					#horizontal: true 					#minAboveSize: 50 					#minBelowSize: 25 					#aboveWidgets: 'component1 component2 component3 notebook' 					#belowWidgets: 'text' ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.25 0 0 0 0.5 -1 0.4 ) 					#name: #component1 					#flags: 0 					#minorKey: #list1 					#clientKey: #component1 ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.5 0 0 0 0.75 -1 0.4 ) 					#name: #component2 					#flags: 0 					#minorKey: #list2 					#clientKey: #component2 ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.75 0 0 0 1 -1 0.4 ) 					#name: #component3 					#flags: 0 					#minorKey: #list3 					#clientKey: #component3 ) 				#(#{UI.ButtonTabNoteBookSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 0.25 -2 0.4 ) 					#name: #notebook 					#model: #majorTabs 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changedMajorTab ) 					#binderWidth: 0 					#majorTabsOnRight: false 					#rightInset: -19 					#bottomInset: 7 ) ) ) )</body></methods><methods><class-id>Tools.ClassesBrowserHelper</class-id> <category>actions</category><body package="OldBrowsers" selector="browseFieldAssignments">browseFieldAssignments	"Show a menu of all instance variables of the currently selected class  	and its superclasses.  Browse all methods which assign to the variable selected."	&lt;menuItem: #(#InstVarAssignmentsDot #menus 'Inst Var &amp;Assignments...')		nameKey: #instVarAssign		menu: #(#listMenu #browse)		position: 10.011 &gt;	| name |	name := self forClass: self selectedItem			showVariableMenu: [:class | class instVarNames]			collect: [:cname | cname].	name isNil ifTrue: [^self].	self methodCollector		baseClass: self selectedItem;		browseAllAccessesTo: name type: #write</body><body package="OldBrowsers" selector="browseFieldReads">browseFieldReads	"Show a menu of all instance variables of the currently selected class	 and its superclasses.  Browse all methods which read the variable selected."	&lt;menuItem: #(#InstVarReadsDot #menus 'Inst Var &amp;Reads...')		nameKey: #instVarRead		menu: #(#listMenu #browse)		position: 10.012 &gt;	| name |	name := self forClass: self selectedItem			showVariableMenu: [:class | class instVarNames]			collect: [:cname | cname].	name isNil ifTrue: [^self].	self methodCollector		baseClass: self selectedItem;		browseAllAccessesTo: name type: #read</body><body package="OldBrowsers" selector="browseLocalCallsOn">browseLocalCallsOn	"Spawn a Browser on references to anObject within the current class.."	&lt;menuItem: #(#LocalReferencesToDot #menus 'Local References &amp;To...')		nameKey: nil		menu: #(#listMenu #browse)		position: 21.01 &gt;	| aLiteral |	aLiteral := SmalltalkWorkbench				promptForSelector: (#BrowseLocalReferencesToWhatQ &lt;&lt; #dialogs &gt;&gt; 'Browse local references to what?')				for: self interfaceWindow.	aLiteral isNil ifTrue: [^self].	^self methodCollector		baseClass: self selectedItem instanceBehavior;		browseAllReferencesTo: aLiteral</body><body package="OldBrowsers" selector="browseLocalImplementorsOf">browseLocalImplementorsOf	"Spawn a Browser on references to anObject within the current class.."	&lt;menuItem: #(#LocalImplementorsOfDot #menus 'Local Implementors &amp;Of...')		nameKey: nil		menu: #(#listMenu #browse)		position: 21.015 &gt;	| aLiteral |	aLiteral := SmalltalkWorkbench				promptForSelector: (#BrowseLocalImplementorsOfWhatQ &lt;&lt; #dialogs &gt;&gt; 'Browse local implementors of what?')				withinHierarchyOf: self selectedItem instanceBehavior				for: self interfaceWindow.	aLiteral isNil ifTrue: [^self].	^self methodCollector		baseClass: self selectedItem instanceBehavior;		browseAllImplementorsOf: aLiteral</body><body package="OldBrowsers" selector="initializeSelections">initializeSelections	"Any of the selections which may be initialized will be initialized here."	&lt;menuItem: #(#Initialize #menus 'Initialize')		nameKey: nil		menu: #(#listMenu)		position: 30.038 &gt;	self selections do: 		[ :selection |		selection isForClass	ifTrue: [ selection initialize ]		]</body><body package="OldBrowsers" selector="searchForStringInSource">searchForStringInSource	"Spawn a Browser on all methods which contain a specified string."	&lt;menuItem: #(#MethodsWithPhraseDot #menus 'Methods with &amp;Phrase...')		nameKey: nil		menu: #(#listMenu #browse) 		position: 21.03 &gt;	| string class selectors classes allSelectorsMDs |Cursor wait showWhile:[ 	(class := self targetClassOrNameSpace) isNil ifTrue: [^self].	class isForNameSpace ifTrue:[ classes := class allClasses ] ifFalse: [ classes := Array with: class].	string := Dialog request: (#ShowMethodsWithSourceCodeContainingColon &lt;&lt; #dialogs &gt;&gt; 'Show methods with source code containing:') for: self interfaceWindow.	string isEmpty ifTrue: [^self].	allSelectorsMDs := OrderedCollection new: 1000.	classes do:[:eachClass | 	selectors := eachClass selectors.	selectors := selectors select: [:sel| | s |								nil ~~ (s := eachClass sourceCodeAt: sel)								and: [(s indexOfSubCollection: string										startingAt: 1) &gt; 0]].	allSelectorsMDs addAll: (selectors collect: [:sel| (MethodDefinition class: eachClass selector: sel)])].].	^self methodCollector		openListBrowserOn: allSelectorsMDs asSortedCollection asArray		label: ((#SourceIn1sContaining2s &lt;&lt; #dialogs &gt;&gt; 'Source in &lt;1s&gt; containing &lt;2s&gt;')			expandMacrosWith: class printString			with: string)		initialSelection: string</body></methods><methods><class-id>Tools.ClassesBrowserHelper class</class-id> <category>resources</category><body package="OldBrowsers" selector="commentIconColor">commentIconColor	"UIMaskEditor new openOnClass: self andSelector: #commentIconColor"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 24@24 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[255 255 255 0 240 1 255 0 247 252 255 0 247 253 127 0 246 85 191 0 247 253 223 0 246 148 15 0 247 255 239 0 246 42 111 0 247 255 239 0 246 84 239 0 247 255 239 0 246 138 111 0 247 255 239 0 246 42 175 0 247 255 239 0 247 255 239 0 247 255 239 0 247 255 239 0 247 255 239 0 247 255 239 0 247 255 239 0 240 0 15 0 255 255 255 0])</body><body package="OldBrowsers" selector="commentIconMask">commentIconMask	"UIMaskEditor new openOnClass: self andSelector: #commentIconMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 24@24 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 15 254 0 0 15 255 0 0 15 255 128 0 15 255 192 0 15 255 224 0 15 255 240 0 15 255 240 0 15 255 240 0 15 255 240 0 15 255 240 0 15 255 240 0 15 255 240 0 15 255 240 0 15 255 240 0 15 255 240 0 15 255 240 0 15 255 240 0 15 255 240 0 15 255 240 0 15 255 240 0 15 255 240 0 15 255 240 0 0 0 0 0])</body><body package="OldBrowsers" selector="definitionIconColor">definitionIconColor	"UIMaskEditor new openOnClass: self andSelector: #definitionIconColor"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 24@24 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 4) at: 1 put: ColorValue black; at: 2 put: ColorValue red; at: 3 put: ColorValue blue; at: 4 put: ColorValue white; yourself)) usingBits: #[255 255 255 255 255 255 0 0 255 255 255 255 255 255 0 0 253 85 127 213 85 255 0 0 253 255 127 223 253 255 0 0 193 255 64 31 253 255 0 0 253 255 127 223 253 255 0 0 253 255 127 223 253 255 0 0 253 85 127 213 85 255 0 0 255 243 255 255 63 255 0 0 255 243 255 255 63 255 0 0 255 243 255 255 63 255 0 0 255 243 255 255 63 255 0 0 255 234 255 213 85 255 0 0 255 174 191 223 253 255 0 0 254 191 175 223 253 255 0 0 250 255 224 31 253 255 0 0 254 191 175 223 253 255 0 0 255 174 191 213 85 255 0 0 255 234 255 255 255 255 0 0 255 243 255 255 255 255 0 0 255 0 63 255 255 255 0 0 255 192 255 255 255 255 0 0 255 243 255 255 255 255 0 0 255 255 255 255 255 255 0 0])</body><body package="OldBrowsers" selector="definitionIconMask">definitionIconMask	"UIMaskEditor new openOnClass: self andSelector: #definitionIconMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 24@24 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 31 135 240 0 31 135 240 0 127 255 240 0 31 135 240 0 31 135 240 0 31 135 240 0 2 0 128 0 2 0 128 0 2 0 128 0 2 0 128 0 7 7 240 0 15 135 240 0 31 199 240 0 63 255 240 0 31 199 240 0 15 135 240 0 7 0 0 0 2 0 0 0 15 128 0 0 7 0 0 0 2 0 0 0 0 0 0 0])</body><body package="OldBrowsers" selector="defTypeMenu">defTypeMenu	"MenuEditor new openOnClass: self andSelector: #defTypeMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#rawLabel: 				#(#UserMessage 					#key: #showHierarchy 					#defaultString: '&amp;Hierarchy' 					#catalogID: #menus ) 				#nameKey: #hierarchy 				#value: #showHierarchy 				#labelImage: #(#ResourceRetriever #ClassesBrowserHelper #hierarchyIcon ) ) 			#(#MenuItem 				#rawLabel: 				#(#UserMessage 					#key: #showDefinition 					#defaultString: '&amp;Definition' 					#catalogID: #menus ) 				#nameKey: #definition 				#value: #showDefinition 				#labelImage: #(#ResourceRetriever #ClassesBrowserHelper #definitionIcon ) ) 			#(#MenuItem 				#rawLabel: 				#(#UserMessage 					#key: #showComment 					#defaultString: 'Co&amp;mment' 					#catalogID: #menus ) 				#nameKey: #comment 				#value: #showComment 				#labelImage: #(#ResourceRetriever #ClassesBrowserHelper #commentIcon ) ) ) #(3 ) nil ) decodeAsLiteralArray</body><body package="OldBrowsers" selector="hierarchyIconColor">hierarchyIconColor	"UIMaskEditor new openOnClass: self andSelector: #hierarchyIconColor"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 24@24 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 5) at: 1 put: ColorValue black; at: 2 put: ColorValue blue; at: 3 put: (ColorValue scaledRed: 0 scaledGreen: 4111 scaledBlue: 0); at: 4 put: ColorValue white; at: 5 put: ColorValue red; yourself)) usingBits: (ByteArray fromPackedString: 'L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3H"H"H"H"L3L3L3L3L3@3L3L3L3L3L3L3L3@3L3L3L3L3L3L3L3@QDQDQDQL3L3L3L3@3@3L3L3L3L3L3L3@3@3L3L3L3L3L3L3@3ADQDQDQDL3L3L3@3@3L3L3L3L3L3L3@3@3L3L3L3L3L3L3@3ADQDQDQDL3L3L3@3L3L3L3L3L3L3L3@3L3L3L3L3L3L3L3@QDQDQDQL3L3L3L3L3@3L3L3L3L3L3L3L3@3L3L3L3L3L3L3L3ADQDQDQDL3L3L3L3@3L3L3L3L3L3L3L3@3L3L3L3L3L3L3L3ADQDQDQDL3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3'))</body><body package="OldBrowsers" selector="hierarchyIconMask">hierarchyIconMask	"UIMaskEditor new openOnClass: self andSelector: #hierarchyIconMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 24@24 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 31 254 0 0 2 0 0 0 2 0 0 0 3 255 192 0 2 64 0 0 2 64 0 0 2 127 248 0 2 64 0 0 2 64 0 0 2 127 248 0 2 0 0 0 2 0 0 0 3 255 192 0 0 64 0 0 0 64 0 0 0 127 248 0 0 64 0 0 0 64 0 0 0 127 248 0 0 0 0 0 0 0 0 0])</body><body package="OldBrowsers" selector="listMenu">listMenu	"MenuEditor new openOnClass: self andSelector: #listMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #FileOutAsDot #catalogID: #menus #defaultString: 'File &amp;Out As...') 				#nameKey: #fileOut 				#value: #fileOut ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Hardcopy #catalogID: #menus #defaultString: '&amp;Hardcopy') 				#nameKey: #hardcopy 				#value: #hardcopy ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Spawn #catalogID: #menus #defaultString: '&amp;Spawn') 				#nameKey: #spawn 				#value: #spawn ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #S_pawnHierarchy #catalogID: #menus #defaultString: 'S&amp;pawn Hierarchy') 				#nameKey: #spawnHierarchy 				#value: #spawnHierarchy ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #AddClass #catalogID: #menus #defaultString: '&amp;Add Class') 				#nameKey: #add 				#value: #addClassVariableSize 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #FixedSize #catalogID: #menus #defaultString: '&amp;Fixed Size') 							#nameKey: #addClassFixedSize 							#value: #addClassFixedSize ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Indexed #catalogID: #menus #defaultString: '&amp;Indexed') 							#nameKey: #addClassVariableSize 							#value: #addClassVariableSize ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ByteIndexed #catalogID: #menus #defaultString: '&amp;Byte Indexed') 							#nameKey: #addClassBytes 							#value: #addClassBytes ) ) #(3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Browse #catalogID: #menus #defaultString: '&amp;Browse') 				#nameKey: #browse 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #InstVarReferencesDot #catalogID: #menus #defaultString: '&amp;Inst Var References...') 							#nameKey: #browseFieldReferences 							#value: #browseFieldReferences ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #SharedVarReferencesDot #catalogID: #menus #defaultString: '&amp;Shared Var References...') 							#nameKey: #browseClassVariables 							#value: #browseClassVariables ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ClassReferences #catalogID: #menus #defaultString: '&amp;Class References') 							#nameKey: #browseClass 							#value: #browseClassReferences ) ) #(1 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #MoveToDot #catalogID: #menus #defaultString: '&amp;Move To...') 				#nameKey: #move 				#value: #move 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #CategoryDot #catalogID: #menus #defaultString: '&amp;Category...') 							#nameKey: #move 							#value: #move ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #NamespaceDot #catalogID: #menus #defaultString: '&amp;Namespace...') 							#nameKey: #moveNameSpace 							#value: #moveNameSpace ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_ParcelDot #catalogID: #menus #defaultString: '&amp;Parcel...') 							#nameKey: #moveNewParcel 							#value: #moveNewParcel ) ) #(3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Re_nameAsDot #catalogID: #menus #defaultString: 'Re&amp;name As...') 				#nameKey: #rename 				#value: #rename ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_RemoveDot #catalogID: #menus #defaultString: '&amp;Remove...') 				#nameKey: #remove 				#value: #remove ) ) #(4 2 3 ) nil ) decodeAsLiteralArray</body><body package="OldBrowsers" selector="metaMenu">metaMenu	"MenuEditor new openOnClass: self andSelector: #metaMenu"	&lt;resource: #menu&gt;	^#(#{Menu} #(			#(#{MenuItem} 				#rawLabel: 				#(#{UserMessage} 					#key: #InstanceDefinitions 					#defaultString: '&amp;Instance Methods' 					#catalogID: #menus ) 				#nameKey: #instance 				#value: #metaOff ) 			#(#{MenuItem} 				#rawLabel: 				#(#{UserMessage} 					#key: #ClassDefinitions 					#defaultString: '&amp;Class Methods' 					#catalogID: #menus ) 				#nameKey: #class 				#value: #metaOn ) 			#(#{MenuItem} 				#rawLabel: 				#(#{UserMessage} 					#key: #Data 					#defaultString: '&amp;Shared Variables' 					#catalogID: #menus ) 				#nameKey: #data 				#value: #metaShowData ) ) #(3 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.NameSpaceOrganizerBrowserHelper class</class-id> <category>resources</category><body package="OldBrowsers" selector="listMenu">listMenu	"MenuEditor new openOnClass: self andSelector: #listMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #FileOutAsDot #catalogID: #menus #defaultString: 'File &amp;Out As...') 				#nameKey: #fileOut 				#value: #fileOut ) 			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Hardcopy #catalogID: #menus #defaultString: '&amp;Hardcopy') 				#nameKey: #hardcopy 				#value: #hardcopy ) 			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Spawn #catalogID: #menus #defaultString: '&amp;Spawn') 				#nameKey: #spawn 				#value: #spawn ) 			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #AddDot #catalogID: #menus #defaultString: '&amp;Add...') 				#nameKey: #add 				#value: #addCategory ) 			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #Re_nameAsDot #catalogID: #menus #defaultString: 'Re&amp;name As...') 				#nameKey: #rename 				#value: #rename ) 			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #_RemoveDot #catalogID: #menus #defaultString: '&amp;Remove...') 				#nameKey: #remove 				#value: #remove ) 			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #FindClassDot #catalogID: #menus #defaultString: '&amp;Find Class...') 				#nameKey: #findClass 				#value: #findClass ) ) #(3 3 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.ProtocolBrowserHelper class</class-id> <category>resources</category><body package="OldBrowsers" selector="listMenu">listMenu	"MenuEditor new openOnClass: self andSelector: #listMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #FileOutAsDot #catalogID: #menus #defaultString: 'File &amp;Out As...') 				#nameKey: #fileOut 				#value: #fileOut ) 			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Hardcopy #catalogID: #menus #defaultString: '&amp;Hardcopy') 				#nameKey: #hardcopy 				#value: #hardcopy ) 			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Spawn #catalogID: #menus #defaultString: '&amp;Spawn') 				#nameKey: #spawn 				#value: #spawn ) 			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #AddDot #catalogID: #menus #defaultString: '&amp;Add...') 				#nameKey: #add 				#value: #add ) 			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #Re_nameAsDot #catalogID: #menus #defaultString: 'Re&amp;name As...') 				#nameKey: #rename 				#value: #rename ) 			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #_RemoveDot #catalogID: #menus #defaultString: '&amp;Remove...') 				#nameKey: #remove 				#value: #remove ) 			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #_FindDot #catalogID: #menus #defaultString: '&amp;Find...') 				#nameKey: #findMethod 				#value: #findMethod ) ) #(3 3 1 ) nil ) decodeAsLiteralArray</body><body package="OldBrowsers" selector="metaMenu">metaMenu	"MenuEditor new openOnClass: self andSelector: #metaMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #InstanceDefinitions 					#defaultString: '&amp;Instance Methods' 					#catalogID: #menus ) 				#nameKey: #instance 				#value: #instance ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #ClassDefinitions 					#defaultString: '&amp;Class Methods' 					#catalogID: #menus ) 				#nameKey: #class 				#value: #class ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Data 					#defaultString: '&amp;Shared Variables' 					#catalogID: #menus ) 				#nameKey: #data 				#value: #data ) ) #(3 ) nil ) decodeAsLiteralArray</body></methods><initialize><class-id>UI.PackagePropertiesDialog</class-id></initialize><initialize><class-id>Tools.FullNotebookSystemBrowser</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>BrowserHelper</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>module selectionId attribute </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>Tools-Name Spaces</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class><class><name>SimpleBrowserModule</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>list forcedValue nextModule browser selectionCandidates helpers deselectNext cachedComponents allowsMultiSelect specName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>Tools-Name Spaces</package></attributes></class><class><name>FullSystemBrowser</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>componentDictionary components coordinator text inBatchMode meta defType toolBar selectionDictionary disableBatchUpdates ignoreNamepaceChanges listMenuMap menuBarMenuMap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>Tools-Name Spaces</package></attributes></class><class><name>MethodsBrowserHelper</name><environment>Tools</environment><super>Tools.BrowserHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Name Spaces</category><attributes><package>Tools-Name Spaces</package></attributes></class></st-source>