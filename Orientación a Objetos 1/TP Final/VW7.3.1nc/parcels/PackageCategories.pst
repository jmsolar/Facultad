<?xml version="1.0"?><st-source><!-- Name: PackageCategoriesParcel: #('PackageCategories')Version: 7.3.1Date: 11:33:03 am April 20, 2005 --><time-stamp>From VisualWorksÂ®, 7.3.1 of April 20, 2005 on April 20, 2005 at 11:33:03 am</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Store</name><environment>Smalltalk</environment><private>false</private><imports>			private Lens.LensGraphView			private Database.ExternalDatabaseConnection			private Database.ConnectionDialog			private Smalltalk.*			</imports><category>Store-Base</category><attributes><package>PackageCategories</package></attributes></name-space><class><name>Access</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blessingPolicy mergePolicy packagePolicy versionPolicy publishPolicy ownershipPolicy prerequisitePolicy filePolicy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.Access</class-id><body>The singleton is Store.Policies, which is simply an accessor for the current set of Store policies. These policies are meant as user subclassable customizations. Many get their values from the Store/Settings dialog.Instance Variables:	blessingPolicy	&lt;BasicBlessingPolicy or subclass&gt; Describes the available and default blessing levels.	mergePolicy	&lt;BasicMergePolicy or subclass&gt; Provides the merge tool a critera to use when performing a 	packagePolicy	&lt;BasicPackagePolicy or subclass&gt; Determines which package should own new definitions (method,	versionPolicy	&lt;BasicVersionPolicy or subclass&gt; Determines how to increment the version string when publishing.	publishPolicy	&lt;BasicPublishPolicy or subclass&gt; Determines whether a client can publish a pundle.	ownershipPolicy	&lt;BasicOwnershipPolicy or subclass&gt; Provides a mechanism for how to determine who owns a pundle.	prerequisitePolicy	&lt;BasicPrerequisitePolicy or subclass&gt; Provides a mechanism for how to resolve development prerequisites	filePolicy	Class Instance Variables:</body></comment><class><name>PublishAsParcelDialog</name><environment>Store</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundle bundleStructure databaseLinks parcelDirectory parcelSave parcelSaveSource parcelHideSource parcelPadded parcelRepublish parcelBackup parcelOverwrite </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>PackageCategories</package></attributes></class><class><name>ModelForParcel</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>object hasDefinition data </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>BasicPackagePolicy</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>alwaysUse newClassUseCurrent newNameSpaceUseCurrent newMethodUseCurrent newMethodUseClassIfNoCurrent newMethodUseClassIfCurrentSame newMethodUseClass newDatumUseCurrent newDatumUseClassIfNoCurrent newDatumUseClassIfCurrentSame newDatumUseClass warnOnFirstModification </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.BasicPackagePolicy</class-id><body>When a new definition (a new class, new method, new namespace or new shared variable) is introduced to the system, BasicPackagePolicy is asked which package should own the definition.    The system's sole instance of BasicPackagePolicy is owned by the Policies (an instance of Access) global in the Store name space.For a new class or a new namespace definition, this policy helps decide whether the system should use the current package, or if the client should be prompted for a package to use. For a new method or a new shared variable, there are more choices.  For example with a new method the choices are:	Current (#currentINAU - in the settings framework)		Use the current package.  The instance variable, newMethodUseCurrent is set to true.  The instance variables newMethodUseClass, newMethodUseClassIfCurrentSame and newMethodUseClassIfNoCurrent are set to false.	Current or class package (#currentINUTCP - in the settings framework)		Use the current package or package that defines the class.  The instance variables, newMethodUseCurrent and newMethodUseClass are set to true.  The instance variables newMethodUseClassIfCurrentSame and newMethodUseClassIfNoCurrent are set to false.	Class package (#useTCP - in the settings framework)		Use the package that defines the class.   The instance variable newMethodUseClass is set to true.  The instance variables newMethodUseCurrent, newMethodUseClassIfCurrentSame and newMethodUseClassIfNoCurrent are set to false.	Class if same as current  (#useTCPIC - in the settings framework)		The instance variable newMethodUseClass and newMethodUseClassIfCurrentSame are set to true.  The instance variables newMethodUseCurrent and newMethodUseClassIfNoCurrent are set to false.	Class if same as current or none (#useTCPICON - in the settings framework)		The instance variables newMethodUseClassIfCurrentSame and newMethodUseClassIfNoCurrent are set to true.  The instance variables newMethodUseClass and newMethodUseCurrent are set to false.  	Always prompt		Always prompt the client.  The instance variables newMethodUseClassIfNoCurrent, newMethodUseClass, newMethodUseCurrent and newMethodUseClassIfNoCurrent are set to false.  The same set of rules applies to shared variables in a name space or class.This policy also provides the ability to override the current settings, but allowing one to set alwaysUse to be the package to always use.  The system uses this feature by calling the #forcePackage:while: method.Instance Variables:	alwaysUse	&lt;PackageModel&gt;	The package that the policy is being forced to use. 	newClassUseCurrent	&lt;Boolean&gt;	Described above.	newDatumUseClass		&lt;Boolean&gt;	Described above	newDatumUseClassIfCurrentSame	&lt;Boolean&gt;	Described above	newDatumUseClassIfNoCurrent	&lt;Boolean&gt;	Described above	newDatumUseCurrent	&lt;Boolean&gt;	Described above	newMethodUseClass	&lt;Boolean&gt;	Described above	newMethodUseClassIfCurrentSame	&lt;Boolean&gt;	Described above	newMethodUseClassIfNoCurrent	&lt;Boolean&gt;	Described above	newMethodUseCurrent	&lt;Boolean&gt;	Described above	newNameSpaceUseCurrent	&lt;Boolean&gt;	Described above	warnOnFirstModification		&lt;Boolean&gt;	If true, warn the client that the package is being modified for the first time</body></comment><class><name>NameSpaceForParcel</name><environment>Store</environment><super>Store.ModelForParcel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>PackageChooser</name><environment>Store</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objectName withAdd onCancelDo sequence selectedPackage defaultPackage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>PackageCategories</package></attributes></class><class><name>StoreWarning</name><environment>Store</environment><super>Core.Warning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>PundleForParcel</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name properties contents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.PundleForParcel</class-id><body>An abstract superclass for pundle/package conversions. Handles everything not related to contents,which are package/bundle specific. These classes are to save the bundle structure in parcels. They are saved in parcels and converted to pundles after loading.NOTE: Updating for packages is not yet supported.Instance Variables:	name	&lt;string&gt;	pundle name	properties	&lt;IndentityDictionary&gt;	pundle properties	contents	&lt;Object&gt;	subclass specfic.</body></comment><class><name>BundleForParcel</name><environment>Store</environment><super>Store.PundleForParcel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.BundleForParcel</class-id><body>Represents bundles within a parcel.Instance Variables:	contents	&lt;OrderedCollection&gt;	 pundles</body></comment><class><name>BundleSpecEditor</name><environment>Store</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>availablePundles bundle bundleContents bundleName disturbed pundleAvailability </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>PackageCategories</package></attributes></class><class><name>BundleStructureChange</name><environment>Store</environment><super>Kernel.ComponentChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>structure </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.BundleStructureChange</class-id><body>Class BundleStructureChange represents the change to the specification of a Bundle.Instance Variables:	structure	&lt;Array of: (Array with: Symbol with: String)&gt;  An array of two-element arrays.  The two-element array holds the type of CodeComponent (#bundle #package) and the name</body></comment><class><name>ClassForParcel</name><environment>Store</environment><super>Store.ModelForParcel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectors metaSelectors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>Model</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.Model</class-id><body>Abstract superclass for image models.</body></comment><class><name>PundleAccess</name><environment>Store</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packages bundles modelDictionary currentPackage nullPackage containedItemsCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.PundleAccess</class-id><body>Singleton (Store.Registry) is the manager for image model. Tracks loaded bundles/packages and maintains amodel (ie Class/NameSpace models) to packages dictionary. Responsible for definition lookup, creating andorganizing pundles.Instance Variables:	packages	&lt;Dictionary key: name value: PackageModel&gt;  All loaded packages.	bundles	&lt;Dictionary key: name value: BundleModel&gt;  All loaded bundles.	modelDictionary	&lt;IdentityDictionary key: String value: Array of packages&gt;  		key is the #absoluteName of a Class or NameSpace (eg. 'Root.Smalltalk.Store.PundleAccess').		value is an array of PackageModels containing some definitions for that class/namespace. The first		package in the array contains the definiton. The rest contain extension methods or statics.	currentPackage	&lt;PackageModel&gt;  Default package.	nullPackage	&lt;PackageModel&gt;  Where things go when they have nowhere to go.	containedItemsCache	&lt;OrderedCollection of: PunleModels&gt; Saves list of all bundles/packages for browser speedup.Everything is in a package somewhere. The nullPackage is for all unassigned definitions.</body></comment><class><name>StoreError</name><environment>Store</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>UnloadedObjectError</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>DefNameSpaceModel</name><environment>Store</environment><super>Store.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>package name environmentString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.DefNameSpaceModel</class-id><body>Represents a namespace within a package that includes the definition and comment.Instance Variables:	package	&lt;PackageModel&gt;  the receiver's package	name	&lt;Symbol&gt;  the NameSpace name.	environmentString	&lt;String&gt; The absolute path of the NameSpace.The definition namespace model operates on the principle that most statics will be in the same package as the namespace. Any static that is not explicitly in another package is assumed to belong to the receiver's package. This is foot print savings at the cost of some confusion in static status. </body></comment><class><name>PundleModel</name><environment>Store</environment><super>Kernel.CodeComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dbInfo readonly </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.PundleModel</class-id><body>An abstract superclass for Package/Bundle Models.Subclasses must implement the following messages:	accessing		pundleChangesClassInstance Variables:	changeSet	&lt;Store.XChangeSet&gt;  tracks all changes	readonly	&lt;Boolean&gt;  set to true after converting a Parcel that has uninstalled code.Class Variables:	EmergencyUnloadSignal	&lt;Signal&gt;  commentThe XChangeSet determines what gets published when updating.</body></comment><class><name>PackageModel</name><environment>Store</environment><super>Store.PundleModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>models </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.PackageModel</class-id><body>Manages the contents of a package.Instance Variables:	models	&lt;IdentityDictionary key: Class/NameSpace absoluteSymbol value: Class/NameSpaceModel&gt; </body></comment><class><name>DatabaseConnectionInformation</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundle dbIdentifier dbTrace changeSet versionString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.DatabaseConnectionInformation</class-id><body>For tracking connections to different database.Instance Variables:	pundle &lt;PundleModel | BundleModel&gt; The pundle this connection is for.	dbIdentifier &lt;String&gt; The name of the database this connection is to. nil if unhooked.	dbTrace	&lt;Integer&gt; The primary key of the parent package record. nil if unhooked.	changeSet	&lt;XChangeSet&gt;	Changes for the owning package for this database.	versionString &lt;String | nil &gt; The cached versionString. nil if unknown.</body></comment><class><name>PseudoRecord</name><environment>Store</environment><super>Store.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-ImageModel</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.PseudoRecord</class-id><body>Abstract superclass. PseudoRecords substitute for image models. They are used in comparison browsers to represent definitions that don't exist or as a generic model when the real model is not known.. </body></comment><class><name>DatumDescriptor</name><environment>Store</environment><super>Store.PseudoRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dataKey nameSpaceName className </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Subdefs</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.DatumDescriptor</class-id><body>DatumDescriptor provides a model for a shared variable that lives in a namespace or the namespace of a class.Instance Variables:	dataKey	&lt;Symbol&gt;	The name of this SharedVariable	nameSpaceName	&lt;String | nil&gt;	The absolute name of the namespace where this shared variable, nil if it belongs in the namespace of a class.	className	&lt;String | nil&gt;	The absolute name of the class whose namespace this shared variable belongs to, nil if it belongs in a namespace proper.</body></comment><class><name>MethodDescriptor</name><environment>Store</environment><super>Store.PseudoRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector protocol fullClassName meta </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Subdefs</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.MethodDescriptor</class-id><body>MethodDescriptor provides a model of a method.Instance Variables:	selector	&lt;Symbol&gt;	The selector for the method	protocol	&lt;Symbol | nil&gt;	The method's protocol, or nil for some unknown reason	fullClassName	&lt;String&gt;	The absolute name for the class where the method lives	meta	&lt;Boolean&gt;	Indicating whether the method resides on the class or instance side of the class.</body></comment><class><name>ClassDescriptor</name><environment>Store</environment><super>Store.PseudoRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fullClassName meta cachedName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Records</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.ClassDescriptor</class-id><body>Represents a class which may or may not exist in the image. Unlike ClassModels, ClassDescriptors know if they are metaclasses or not.</body></comment><class><name>ClassExtensionDescriptor</name><environment>Store</environment><super>Store.ClassDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Records</category><attributes><package>PackageCategories</package></attributes></class><class><name>DefClassModel</name><environment>Store</environment><super>Store.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>package fullClassSymbol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.DefClassModel</class-id><body>Represents a class within a package that includes the class definition and comment.Instance Variables:	package	&lt;PackageModel&gt;  the receiver's package	fullClassSymbol	&lt;Symbol&gt; the absolute symbol representing the receiver.The definition class model operates on the principle that most methods/statics will be in the same package as the class. Any method/static that is not explicitly in another package is assumed to belong to the receiver's package. This is foot print savings at the cost of some confusion in method/static status. </body></comment><class><name>ExtensionClassModel</name><environment>Store</environment><super>Store.DefClassModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectors metaSelectors data </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.ExtensionClassModel</class-id><body>Represents a class in a package that does not have the class definition, but only extension methods/statics.Instance Variables:	selectors	&lt;IdentitySet of: symbol&gt;  The selectors in this package	metaSelectors	&lt;IdentitySet of: symbol&gt;  The meta class selectors	data	&lt;IdentitySet of: symbol&gt;  The static keys in this package.</body></comment><class><name>XChangeSet</name><environment>Store</environment><super>Core.IdentityDictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>other properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.XChangeSet</class-id><body>Manages changes for an individual package/bundle. A dictionary of Store.Changes keyed by absolute class or namespace name.Instance Variables:	other	&lt;OrderedCollection of: symbol&gt;  general changes, such as property keys or #componentAddedClass Variables:	CurrentSet	&lt;XMainChangeSet&gt;  A singleton that tracks system wide changes 				and manages inter-package movements.</body></comment><class><name>XMainChangeSet</name><environment>Store</environment><super>Store.XChangeSet</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>reorganizeSystem specialDoIts </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.XMainChangeSet</class-id><body>There is one instance of this class (XChangeSet current). It tracks system wide changes.Instance Variables:	reorganizeSystem	&lt;IdentitySet of: symbols&gt;  NameSpaces that have been reorganized.	specialDoIts	&lt;Collection&gt;  usually nil. So.... not being used.</body></comment><class><name>PackageForParcel</name><environment>Store</environment><super>Store.PundleForParcel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>ComponentDescription</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dbIdentifier id componentName fileName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.ComponentDescription</class-id><body>ComponentDescription is a abstract superclass that describes components or prerequisites of abundle. Is also provides the data structure when saving a bundle into the file.Instance Variables:	dbIdentifier	&lt;Symbol&gt;	identifies the database that the id points to	id	&lt;Integer&gt;	primaryKey (aka dbTrace) of the component in the database	componentName	&lt;String&gt;	component name	fileName	&lt;FileName&gt; obsolete. TBR at a later date.Shared Variables:	CannotLoadComponentSignal	&lt;Signal&gt;	Sigaled when component load aborted	CannotStoreComponentSignal	&lt;Signal&gt;		CannotUnloadComponentSignal	&lt;Signal&gt;	Sigaled when component unload aborted</body></comment><class><name>PackageDescription</name><environment>Store</environment><super>Store.ComponentDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.PackageDescription</class-id><body>Represents a package as a component or a prerequsite.</body></comment><class><name>NameSpaceDescriptor</name><environment>Store</environment><super>Store.PseudoRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fullName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Records</category><attributes><package>PackageCategories</package></attributes></class><class><name>NameSpaceExtensionDescriptor</name><environment>Store</environment><super>Store.NameSpaceDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Records</category><attributes><package>PackageCategories</package></attributes></class><class><name>ExtensionNameSpaceModel</name><environment>Store</environment><super>Store.DefNameSpaceModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>data </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.ExtensionNameSpaceModel</class-id><body>Represents a class in a package that does not have the namespace definition, but only extension statics.Instance Variables:	data	&lt;IdentitySet of: symbol&gt;  The static keys in this package.</body></comment><class><name>Changes</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>symbol defChanges dataChanges </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>NameSpaceChanges</name><environment>Store</environment><super>Store.Changes</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>ClassChanges</name><environment>Store</environment><super>Store.Changes</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methodChanges metaMethodChanges </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.ClassChanges</class-id><body>Missing comment</body></comment><class><name>BundleDescription</name><environment>Store</environment><super>Store.ComponentDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.BundleDescription</class-id><body>Represents a bundle as a component or a prerequsite.</body></comment><class><name>DatabaseConnectionBundleInformation</name><environment>Store</environment><super>Store.DatabaseConnectionInformation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contentDescriptions fileDescriptions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.DatabaseConnectionBundleInformation</class-id><body>Specialized DatabaseConnectionBundleInformation for tracking bundle content descriptions.Instance Variables:	contentDescriptions	&lt;List of: PundleDescriptions&gt; - tracks bundle contents and their db links.</body></comment><class><name>BundleModel</name><environment>Store</environment><super>Store.PundleModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.BundleModel</class-id><body>BundleModel is a organization of pundles.Instance Variables:	contents	&lt;List of: PundleModels&gt;  An ordered list of subcomponents.</body></comment><class><name>Change</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type classSymbol meta nameSpaceSymbol subdef key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.Change</class-id><body>Missing comment</body></comment><class><name>ComponentRelatedChange</name><environment>Store</environment><super>Store.Change</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tag </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><shared-variable><name>EmergencyUnloadSignal</name><environment>Store.PundleModel</environment><private>false</private><constant>false</constant><category>signals</category><attributes><package>PackageCategories</package></attributes></shared-variable><shared-variable><name>Policies</name><environment>Store</environment><private>false</private><constant>false</constant><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></shared-variable><shared-variable><name>Registry</name><environment>Store</environment><private>false</private><constant>false</constant><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></shared-variable><shared-variable><name>BundleIcon</name><environment>Store.BundleModel</environment><private>false</private><constant>false</constant><category>visuals</category><initializer>nil</initializer><attributes><package>PackageCategories</package></attributes></shared-variable><shared-variable><name>CheckedPackageImage</name><environment>Store.BundleSpecEditor</environment><private>false</private><constant>false</constant><category>images</category><attributes><package>PackageCategories</package></attributes></shared-variable><shared-variable><name>CheckedBundleImage</name><environment>Store.BundleSpecEditor</environment><private>false</private><constant>false</constant><category>images</category><attributes><package>PackageCategories</package></attributes></shared-variable><shared-variable><name>PackageIcon</name><environment>Store.PackageModel</environment><private>false</private><constant>false</constant><category>visuals</category><initializer>nil</initializer><attributes><package>PackageCategories</package></attributes></shared-variable><shared-variable><name>CurrentSet</name><environment>Store.XChangeSet</environment><private>false</private><constant>false</constant><category>current</category><attributes><package>PackageCategories</package></attributes></shared-variable><methods><class-id>Store.Access</class-id> <category>initialize-release</category><body package="PackageCategories" selector="cloneFrom:">cloneFrom: previous	self publishPolicy: previous publishPolicy.	self ownershipPolicy: previous ownershipPolicy.	self blessingPolicy: previous blessingPolicy.	self mergePolicy: previous mergePolicy.	self packagePolicy: previous packagePolicy.	self versionPolicy: previous versionPolicy.	self prerequisitePolicy: previous prerequisitePolicy.</body></methods><methods><class-id>Store.Access</class-id> <category>accessing</category><body package="PackageCategories" selector="blessingPolicy">blessingPolicy	^blessingPolicy == nil		ifTrue: [ blessingPolicy := self class defaultBlessingPolicy ]		ifFalse: [ blessingPolicy ]</body><body package="PackageCategories" selector="blessingPolicy:">blessingPolicy: aPolicy	blessingPolicy := aPolicy</body><body package="PackageCategories" selector="mergePolicy">mergePolicy	^mergePolicy == nil		ifTrue: [ mergePolicy := self class defaultMergePolicy ]		ifFalse: [ mergePolicy ]</body><body package="PackageCategories" selector="mergePolicy:">mergePolicy: aPolicy	mergePolicy := aPolicy</body><body package="PackageCategories" selector="ownershipPolicy">ownershipPolicy	^ownershipPolicy == nil		ifTrue: [ ownershipPolicy := self class defaultOwnershipPolicy ]		ifFalse: [ ownershipPolicy ]</body><body package="PackageCategories" selector="ownershipPolicy:">ownershipPolicy: aPolicy	ownershipPolicy := aPolicy</body><body package="PackageCategories" selector="packagePolicy">packagePolicy	^packagePolicy == nil		ifTrue: [ packagePolicy := self class defaultPackagePolicy ]		ifFalse: [ packagePolicy ]</body><body package="PackageCategories" selector="packagePolicy:">packagePolicy: aPolicy	packagePolicy := aPolicy</body><body package="PackageCategories" selector="prerequisitePolicy">prerequisitePolicy		^prerequisitePolicy == nil		ifTrue: [ prerequisitePolicy := self class defaultPrerequisitePolicy ]		ifFalse: [ prerequisitePolicy ]</body><body package="PackageCategories" selector="prerequisitePolicy:">prerequisitePolicy: aPolicy		prerequisitePolicy := aPolicy</body><body package="PackageCategories" selector="publishPolicy">publishPolicy	^publishPolicy == nil		ifTrue: [ publishPolicy := self class defaultPublishPolicy ]		ifFalse: [ publishPolicy ]</body><body package="PackageCategories" selector="publishPolicy:">publishPolicy: aPolicy	publishPolicy := aPolicy</body><body package="PackageCategories" selector="versionPolicy">versionPolicy	^versionPolicy == nil		ifTrue: [ versionPolicy := self class defaultVersionPolicy ]		ifFalse: [ versionPolicy ]</body><body package="PackageCategories" selector="versionPolicy:">versionPolicy: aPolicy	versionPolicy := aPolicy</body></methods><methods><class-id>Store.Access class</class-id> <category>class initialization</category><body package="PackageCategories" selector="initialize">initialize	"Need only be executed on first installation or on change in definition."	"self initialize"	Policies == nil		ifTrue: [ Policies := self new. self setDefaultPolicies ]		ifFalse: [ Policies := self new cloneFrom: Policies ]</body></methods><methods><class-id>Store.Access class</class-id> <category>defaults</category><body package="PackageCategories" selector="defaultBlessingPolicy">defaultBlessingPolicy	^#{BasicBlessingPolicy} ifDefinedDo: [ :cls | cls new ].</body><body package="PackageCategories" selector="defaultMergePolicy">defaultMergePolicy	^#{BasicMergePolicy} ifDefinedDo: [ :cls | cls new ].</body><body package="PackageCategories" selector="defaultOwnershipPolicy">defaultOwnershipPolicy	^#{BasicOwnershipPolicy} ifDefinedDo: [ :cls | cls new ].</body><body package="PackageCategories" selector="defaultPackagePolicy">defaultPackagePolicy	^#{BasicPackagePolicy} ifDefinedDo: [ :cls | cls new ].</body><body package="PackageCategories" selector="defaultPrerequisitePolicy">defaultPrerequisitePolicy	^#{BasicPrerequisitePolicy} ifDefinedDo: [ :cls | cls new ].</body><body package="PackageCategories" selector="defaultPublishPolicy">defaultPublishPolicy	^#{BasicPublishPolicy} ifDefinedDo: [ :cls | cls new ].</body><body package="PackageCategories" selector="defaultVersionPolicy">defaultVersionPolicy	^#{BranchingVersionPolicy} ifDefinedDo: [ :cls | cls new ].</body><body package="PackageCategories" selector="setDefaultPolicies">setDefaultPolicies	"self setDefaultPolicies"	Policies blessingPolicy: self defaultBlessingPolicy.	Policies publishPolicy: self defaultPublishPolicy.	Policies mergePolicy: self defaultMergePolicy.	Policies ownershipPolicy: self defaultOwnershipPolicy.	Policies packagePolicy: self defaultPackagePolicy.	Policies versionPolicy: self defaultVersionPolicy.	Policies prerequisitePolicy: self defaultPrerequisitePolicy.</body></methods><methods><class-id>Store.PublishAsParcelDialog</class-id> <category>interface opening</category><body package="PackageCategories" selector="postOpenWith:">postOpenWith: aBuilder 	"This message is sent by the builder after it has opened a completed window."	( pundle hasBeenModified &amp; pundle isBundle )		ifTrue: [ Dialog warn: ( (#PundleHasUnpublishedChanges &lt;&lt; #packages &gt;&gt; '&lt;1s&gt; has unpublished changes. Database links cannot be saved.') 					expandMacrosWith: pundle name ) ].			( pundle isBundle and: 			[ pundle allContainedItems contains: 				[ :p | p properties keys contains: [ :k | CodeComponent binaryActions includes: k ] ]			] 	  ) ifTrue: [ Dialog warn: (#SubPundlesAlsoHaveActions &lt;&lt; #packages &gt;&gt; 'Sub-components have actions that won''t be executed during parcel load.') ].	( self builder componentAt: #parcelSave ) isEnabled: false.	( self builder componentAt: #parcelDirectory ) isEnabled: true.	( self builder componentAt: #bundleStructure ) isEnabled: pundle isBundle.	self bundleStructureChanged.</body></methods><methods><class-id>Store.PublishAsParcelDialog</class-id> <category>aspects</category><body package="PackageCategories" selector="bundleStructure">bundleStructure	bundleStructure == nil		ifTrue: [ bundleStructure := false asValue ].	^bundleStructure</body><body package="PackageCategories" selector="bundleStructureChanged">bundleStructureChanged	"Enable the database links depending on wheter the structure will be saved."	( self builder componentAt: #databaseLinks ) isEnabled: 		( self bundleStructure value  &amp;  pundle hasBeenModified not ).	databaseLinks value: ( databaseLinks value  &amp;  bundleStructure value ).</body><body package="PackageCategories" selector="databaseLinks">databaseLinks	databaseLinks == nil		ifTrue: [ databaseLinks := false asValue ].	^databaseLinks</body><body package="PackageCategories" selector="helpAction">helpAction	| sh |	sh := SimpleHelp helpString: self class parcelHelp.	sh class openOn: sh</body><body package="PackageCategories" selector="parcelBackup">parcelBackup	parcelBackup == nil		ifTrue: [ parcelBackup := false asValue ].	^parcelBackup</body><body package="PackageCategories" selector="parcelDirectory">parcelDirectory	| name |	parcelDirectory ==  nil		ifTrue: 			[ parcelDirectory := UISettings preferenceFor: #packageDir.			( parcelDirectory == nil or: [ parcelDirectory isEmpty ] )				ifTrue: [ parcelDirectory := Filename currentDirectory ].			name := pundle parcelName.			parcelDirectory := ( parcelDirectory asFilename construct: name ) asString asValue.			 ].	^parcelDirectory</body><body package="PackageCategories" selector="parcelHideSource">parcelHideSource	parcelHideSource == nil		ifTrue: [ parcelHideSource := false asValue ].	^parcelHideSource</body><body package="PackageCategories" selector="parcelOverwrite">parcelOverwrite	parcelOverwrite == nil		ifTrue: [ parcelOverwrite := false asValue ].	^parcelOverwrite</body><body package="PackageCategories" selector="parcelPadded">parcelPadded	parcelPadded == nil		ifTrue: [ parcelPadded := true asValue ].	^parcelPadded</body><body package="PackageCategories" selector="parcelRepublish">parcelRepublish	parcelRepublish == nil		ifTrue: [ parcelRepublish := false asValue ].	^parcelRepublish</body><body package="PackageCategories" selector="parcelSave">parcelSave	parcelSave == nil		ifTrue: [ parcelSave := true asValue ].	^parcelSave</body><body package="PackageCategories" selector="parcelSaveSource">parcelSaveSource	parcelSaveSource == nil		ifTrue: [ parcelSaveSource := true asValue ].	^parcelSaveSource</body><body package="PackageCategories" selector="parcelSaveSourceChanged">parcelSaveSourceChanged	"Enable/disable the subcheck boxes depending on sources."	| save |	save := self parcelSaveSource value &amp;  ( self parcelSave value ).	self parcelSaveSourceDetails do:		[ :sym | self enableComponentAt: sym enable: save ].	self parcelRepublish value: ( self parcelRepublish value &amp; save ).	self enableComponentAt: #parcelRepublish enable: save.</body><body package="PackageCategories" selector="parcelSaveSourceDetails">parcelSaveSourceDetails	^#( parcelHideSource 		parcelPadded 		)</body><body package="PackageCategories" selector="pundle:">pundle: aPundle 	| hasSourceIndex |	pundle := aPundle.	"Find out if aPundle (or any of its contained items if aPundle is a bundle) has a 	 sourceIndex.  If so, then make sure we force the republish flag to be true."	hasSourceIndex := (aPundle propertyAt: #sourceIndex) notNil.	aPundle isBundle 		ifTrue: 			[hasSourceIndex := hasSourceIndex or: 							[aPundle allContainedItems 								anySatisfy: [:each | (each propertyAt: #sourceIndex) notNil]]].	self parcelRepublish value: hasSourceIndex</body><body package="PackageCategories" selector="validateParcelSaveString">validateParcelSaveString	"Check wheter save as parcel should be enabled. Answer the message if not, an empty string if okay"	| existing |	( existing := pundle relatedParcel ) == nil		ifFalse: 			[ existing hasUninstalledCode 				ifTrue: [ ^(#uninstalledCode &lt;&lt; #dialogs &gt;&gt; 'Parcel has uninstalled code.&lt;n&gt;Saving will lose it.').					]			].	pundle hasCodeOverridden 		ifTrue: [ ^#parcelCodeOverridden &lt;&lt; #dialogs &gt;&gt; 'Parcel has code overridden by other parcels.&lt;n&gt;Saving would save the override, not the overridden code.&lt;n&gt;Operation cancelled.'.				].	^String new</body></methods><methods><class-id>Store.PublishAsParcelDialog</class-id> <category>private</category><body package="PackageCategories" selector="enableComponentAt:enable:">enableComponentAt: aSymbol enable: aBoolean	| comp |	( comp := self builder componentAt: aSymbol ) == nil		ifFalse: [ comp isEnabled: aBoolean ]</body><body package="PackageCategories" selector="options">options		"Answer a dictionary of all the selections"	^Dictionary new		at: #parcelSave put: self parcelSave value;		at: #databaseLinks put: self databaseLinks value;		at: #bundleStructure put: self bundleStructure value;		at: #parcelDirectory put: self parcelDirectory value;		at: #parcelRepublish put: self parcelRepublish value;		at: #parcelBackup put: self parcelBackup value;		at: #parcelOverwrite put: self parcelOverwrite value;		at: #parcelSaveSource put: self parcelSaveSource value;		at: #parcelHideSource put: self parcelHideSource value;		at: #parcelPadded put: self parcelPadded value;		yourself.</body><body package="PackageCategories" selector="validateParcelOptions">validateParcelOptions	| filename |	( ( filename := self basePath , Parcel fileExtension ) asFilename exists				and: [ self parcelOverwrite value not ] )		ifTrue: 			[ ( Dialog confirm: ( (#OKtoOverwriteParcelQ &lt;&lt; #packages &gt;&gt; '&lt;n&gt;&lt;1s&gt; exists: &lt;n&gt;&lt;n&gt;Overwrite files?&lt;n&gt;') expandMacrosWith: filename ) ) 				ifTrue: [ self parcelOverwrite value: true ]				ifFalse: [ ^false ].			].	^true</body></methods><methods><class-id>Store.PublishAsParcelDialog</class-id> <category>events</category><body package="PackageCategories" selector="requestForWindowClose">requestForWindowClose	"The ApplicationWindow's controller is checking to see if the application is in a state that can be closed."	self validateParcelOptions		ifFalse: [ ^false ].	^super requestForWindowClose</body></methods><methods><class-id>Store.PublishAsParcelDialog</class-id> <category>accessing</category><body package="PackageCategories" selector="basePath">basePath	"Return the base path of the filename for the parcel to be saved."		^( Filename expandEnvironmentIn: ( self parcelDirectory value ) ) asString</body></methods><methods><class-id>Store.PublishAsParcelDialog class</class-id> <category>interface opening</category><body package="PackageCategories" selector="publishAsParcel:">publishAsParcel: aPundle	"Open a dialog for package/bundle parcel publishing."	"self publishAsParcel: ( Registry packageNamed: 'Store-UI' )"	| dialog filename |	aPundle hasCodeOverridden		ifTrue: [ ^Dialog warn: (#NoParcelWithOverrides &lt;&lt; #packages &gt;&gt; 'Parcels cannot be saved with overrides.') ].	( aPundle relatedParcel ~~ nil and: [ aPundle relatedParcel hasUninstalledCode ] )		ifTrue: [ ^Dialog warn: (#NoParcelWithUninstalled &lt;&lt; #packages &gt;&gt; 'Parcels cannot be saved with uninstalled code.') ].	dialog := self new.	dialog pundle: aPundle.	dialog open.	dialog accept value		ifFalse: [ ^nil ].	 	filename := Filename named: ( dialog parcelDirectory value ).	aPundle		saveAsParcel: filename 		saveStructure: dialog bundleStructure value  		saveLinks: dialog databaseLinks value		parcelOptions: dialog options.</body></methods><methods><class-id>Store.PublishAsParcelDialog class</class-id> <category>dummy</category><body package="PackageCategories" selector="parcelWarningMessage">parcelWarningMessage	"We don't need this here, but it's in the dialog we're borrowing from PublishPundleDialog"	^''</body></methods><methods><class-id>Store.PublishAsParcelDialog class</class-id> <category>help</category><body package="PackageCategories" selector="parcelHelp">parcelHelp	^(#parcelHelp &lt;&lt; #packages &gt;&gt; 'The parcel will be saved in the Parcel Path + .pcl, the sources in Parcel Path +.pst.Include Bundle Structure if you would like the bundle to be recreated when loading the parcel into a Store image.  Saving Database Links will hook the components to a particular database. This saves the loader from needing to reconcile source before publishing a new version to the same database.Save source file will create the parcel sources (.pst) file.Hide sources on load will not effect the current image, but will supress sources when it is loaded into a another image. This is for deployment parcels and should not be used during development.Select republish to save with sources to a parcel that is currently loaded to the same file name.  Republishing does not hide sources. Republishing will invalidate other images that point to the original file.') asString</body></methods><methods><class-id>Store.ModelForParcel</class-id> <category>initialization</category><body package="PackageCategories" selector="from:">from: aModel	object := aModel actual.	hasDefinition := aModel hasDefinition.	data := aModel dataKeys.</body></methods><methods><class-id>Store.ModelForParcel</class-id> <category>testing</category><body package="PackageCategories" selector="hasDefinition">hasDefinition	^hasDefinition</body><body package="PackageCategories" selector="isForClass">isForClass	^false</body><body package="PackageCategories" selector="isForNameSpace">isForNameSpace	^false</body></methods><methods><class-id>Store.ModelForParcel</class-id> <category>private</category><body package="PackageCategories" selector="isDataKey:in:">isDataKey: key in: aCollection	"Answer true if aClass&gt;&gt;selector is in a Collection of parcel updates."	| binding |	binding := object bindingFor: key.	^aCollection includes: binding.</body><body package="PackageCategories" selector="isObjectIn:">isObjectIn: aCollection	"Answer true if the receiver's class or namespace is in aCollection."	^aCollection includes: object</body></methods><methods><class-id>Store.ModelForParcel</class-id> <category>accessing</category><body package="PackageCategories" selector="data">data	"Answer the receiver's static data keys."	^data</body><body package="PackageCategories" selector="object">object	"Answer the object that receiver represents. 	Note that this may be a 'shadow' object in a partially loaded Parcel."	^object</body></methods><methods><class-id>Store.ModelForParcel class</class-id> <category>instance creation</category><body package="PackageCategories" selector="classForModel:">classForModel: aModel			^aModel isForNameSpace		ifTrue: [ NameSpaceForParcel ]		ifFalse: [ ClassForParcel ]</body><body package="PackageCategories" selector="from:">from: aModel			^( self classForModel: aModel ) new		from: aModel</body></methods><methods><class-id>Store.BasicPackagePolicy</class-id> <category>private-method-package assignment</category><body package="PackageCategories" selector="newMethodUseClass">newMethodUseClass	newMethodUseClass isNil ifTrue: [newMethodUseClass := true].	^newMethodUseClass</body><body package="PackageCategories" selector="newMethodUseClass:">newMethodUseClass: aBoolean	newMethodUseClass := aBoolean</body><body package="PackageCategories" selector="newMethodUseClassIfCurrentSame">newMethodUseClassIfCurrentSame	newMethodUseClassIfCurrentSame isNil ifTrue: [newMethodUseClassIfCurrentSame := false].	^newMethodUseClassIfCurrentSame</body><body package="PackageCategories" selector="newMethodUseClassIfCurrentSame:">newMethodUseClassIfCurrentSame: aBoolean	newMethodUseClassIfCurrentSame := aBoolean</body><body package="PackageCategories" selector="newMethodUseClassIfNoCurrent">newMethodUseClassIfNoCurrent	newMethodUseClassIfNoCurrent isNil ifTrue: [newMethodUseClassIfNoCurrent := false].	^newMethodUseClassIfNoCurrent</body><body package="PackageCategories" selector="newMethodUseClassIfNoCurrent:">newMethodUseClassIfNoCurrent: aBoolean	newMethodUseClassIfNoCurrent := aBoolean</body><body package="PackageCategories" selector="newMethodUseCurrent">newMethodUseCurrent	newMethodUseCurrent isNil ifTrue: [newMethodUseCurrent := true].	^newMethodUseCurrent</body><body package="PackageCategories" selector="newMethodUseCurrent:">newMethodUseCurrent: aBoolean	newMethodUseCurrent := aBoolean</body></methods><methods><class-id>Store.BasicPackagePolicy</class-id> <category>private-class-package assignment</category><body package="PackageCategories" selector="newClassUseCurrent">newClassUseCurrent	newClassUseCurrent isNil ifTrue: [newClassUseCurrent := true].	^newClassUseCurrent</body><body package="PackageCategories" selector="newClassUseCurrent:">newClassUseCurrent: aBoolean	newClassUseCurrent := aBoolean</body><body package="PackageCategories" selector="newNameSpaceUseCurrent">newNameSpaceUseCurrent	newNameSpaceUseCurrent isNil ifTrue: [newNameSpaceUseCurrent := true].	^newNameSpaceUseCurrent</body><body package="PackageCategories" selector="newNameSpaceUseCurrent:">newNameSpaceUseCurrent: aBoolean	newNameSpaceUseCurrent := aBoolean</body></methods><methods><class-id>Store.BasicPackagePolicy</class-id> <category>private-datum-package assignment</category><body package="PackageCategories" selector="newDatumUseClass">newDatumUseClass	newDatumUseClass isNil ifTrue: [newDatumUseClass := true].	^newDatumUseClass</body><body package="PackageCategories" selector="newDatumUseClass:">newDatumUseClass: aBoolean	newDatumUseClass := aBoolean</body><body package="PackageCategories" selector="newDatumUseClassIfCurrentSame">newDatumUseClassIfCurrentSame	newDatumUseClassIfCurrentSame isNil ifTrue: [newDatumUseClassIfCurrentSame := false].	^newDatumUseClassIfCurrentSame</body><body package="PackageCategories" selector="newDatumUseClassIfCurrentSame:">newDatumUseClassIfCurrentSame: aBoolean	newDatumUseClassIfCurrentSame := aBoolean</body><body package="PackageCategories" selector="newDatumUseClassIfNoCurrent">newDatumUseClassIfNoCurrent	newDatumUseClassIfNoCurrent isNil ifTrue: [newDatumUseClassIfNoCurrent := false].	^newDatumUseClassIfNoCurrent</body><body package="PackageCategories" selector="newDatumUseClassIfNoCurrent:">newDatumUseClassIfNoCurrent: aBoolean	newDatumUseClassIfNoCurrent := aBoolean</body><body package="PackageCategories" selector="newDatumUseCurrent">newDatumUseCurrent	newDatumUseCurrent isNil ifTrue: [newDatumUseCurrent := true].	^newDatumUseCurrent</body><body package="PackageCategories" selector="newDatumUseCurrent:">newDatumUseCurrent: aBoolean	newDatumUseCurrent := aBoolean</body></methods><methods><class-id>Store.BasicPackagePolicy</class-id> <category>testing</category><body package="PackageCategories" selector="checkForFirst">checkForFirst	"Answer true if we need to ask if okay to modify the first time."	^self packageIsForced not  &amp; self warnOnFirstModification</body><body package="PackageCategories" selector="isTemporary">isTemporary	^false</body><body package="PackageCategories" selector="packageIsForced">packageIsForced	"Answer true if we are in a force package block."	^alwaysUse ~~ nil</body></methods><methods><class-id>Store.BasicPackagePolicy</class-id> <category>accessing</category><body package="PackageCategories" selector="forcedPackage">forcedPackage	^alwaysUse</body><body package="PackageCategories" selector="parentPackageFor:">parentPackageFor: aPackage   	"Decide if we ask for the parent version from the database or   	 just assume that trace is OK.	Default implementation just returns the parent of aPackage"	^aPackage tracePackage</body><body package="PackageCategories" selector="warnOnFirstModification">warnOnFirstModification	warnOnFirstModification == nil 		ifTrue: [ warnOnFirstModification := true ].	^#{Store.DbRgistry} isDefined  &amp;  warnOnFirstModification</body><body package="PackageCategories" selector="warnOnFirstModification:">warnOnFirstModification: aBoolean	warnOnFirstModification := aBoolean</body></methods><methods><class-id>Store.BasicPackagePolicy</class-id> <category>package assignment</category><body package="PackageCategories" selector="forceNullPackageWhile:">forceNullPackageWhile: aBlock 	"This method puts everything into the null package when. 	It overrides current policy settings."	^self forcePackage: self nullPackage while: aBlock</body><body package="PackageCategories" selector="forcePackage:while:">forcePackage: aPackage while: aBlock 	"This method designates aPackage to be used whenever 	a new definition is created. It overrides current policy settings."	| old retVal |	old := alwaysUse.		[ alwaysUse := aPackage.	retVal := aBlock value 	] ensure: [ alwaysUse := old ].	^retVal.</body><body package="PackageCategories" selector="packageForClassSymbol:">packageForClassSymbol: classSymbol	"Return the package that this class should be 	placed in. Nil if none can be determined."	| pkg |	alwaysUse notNil ifTrue: [^alwaysUse].	pkg := Registry containingPackageForClassSymbol: classSymbol.	pkg isNil ifTrue: [pkg := self packageForNewClassSymbol: classSymbol].	^pkg</body><body package="PackageCategories" selector="packageForDataKey:classSymbol:">packageForDataKey: dataKey classSymbol: classSymbol 	"Return the package that this data should be 	placed in. Nil if none can be determined."	| pkg |	alwaysUse notNil ifTrue: [^alwaysUse].	pkg := Registry containingPackageForDataKey: dataKey symbol: classSymbol.	pkg isNil ifTrue: [pkg := self packageForNewDataKey: dataKey classSymbol: classSymbol].	^pkg</body><body package="PackageCategories" selector="packageForDataKey:nameSpaceSymbol:">packageForDataKey: dataKey nameSpaceSymbol: nameSpaceSymbol 	"Return the package that this data should be placed in. 	Nil if none can be determined."	| pkg |	alwaysUse notNil ifTrue: [ ^alwaysUse ].	pkg := Registry containingPackageForDataKey: dataKey symbol: nameSpaceSymbol .	pkg isNil ifTrue: [pkg := self packageForNewDataKey: dataKey nameSpaceSymbol: nameSpaceSymbol ].	^pkg</body><body package="PackageCategories" selector="packageForNameSpaceSymbol:">packageForNameSpaceSymbol: nameSpaceSymbol	"Return the package that this class should be 	placed in. Nil if none can be determined."	| pkg |	alwaysUse notNil ifTrue: [ ^alwaysUse ].	pkg := Registry containingPackageForNameSpaceSymbol: nameSpaceSymbol.	pkg isNil ifTrue: [pkg := self packageForNewNameSpaceSymbol: nameSpaceSymbol].	^pkg</body><body package="PackageCategories" selector="packageForNewClassSymbol:">packageForNewClassSymbol: classSymbol	"Return the package that this class should be placed in. The nullPackage if none can be determined."	alwaysUse notNil ifTrue: [ ^alwaysUse ].	^self newClassUseCurrent 		ifTrue: [ Registry currentPackage ]		ifFalse: 	[ PackageChooser chooseOrAdd: classSymbol onCancelDo: [ ^Registry nullPackage ] ]</body><body package="PackageCategories" selector="packageForNewDataKey:classSymbol:">packageForNewDataKey: dataKey classSymbol: classSymbol	"Return the package that this datum should be 	placed in. Nil if none can be determined."	alwaysUse notNil ifTrue: [^alwaysUse].	(self newDatumUseCurrent and: [Registry isCurrentNull not])		ifTrue: [^Registry currentPackage].	self newDatumUseClass		ifTrue: 			[ | clpkg |			clpkg := Registry containingPackageForClassSymbol: classSymbol.			( self newDatumUseClassIfCurrentSame not or: [ Registry isCurrentNull					ifTrue: [ self newDatumUseClassIfNoCurrent ]					ifFalse: [ Registry currentPackage == clpkg ] ]			)				ifTrue: [ ^self validatePackage: clpkg description: classSymbol, '.', dataKey ].			^PackageChooser 				chooseOrAdd:  classSymbol, '.', dataKey 				withDefault: clpkg				onCancelDo: [ ^Registry nullPackage ]			].	^PackageChooser chooseOrAdd: classSymbol, '.', dataKey onCancelDo: 		[ ^Registry nullPackage ].</body><body package="PackageCategories" selector="packageForNewDataKey:nameSpaceSymbol:">packageForNewDataKey: dataKey nameSpaceSymbol: nameSpaceSymbol	"Return the package that this datum should be 	placed in. Nil if none can be determined."	alwaysUse notNil ifTrue: [ ^alwaysUse ].	(self newDatumUseCurrent and: [Registry isCurrentNull not])		ifTrue: [^Registry currentPackage].	self newDatumUseClass		ifTrue: 			[ | clpkg |			clpkg := Registry containingPackageForNameSpaceSymbol: nameSpaceSymbol.			( self newDatumUseClassIfCurrentSame not or: [ Registry isCurrentNull					ifTrue: [ self newDatumUseClassIfNoCurrent ]					ifFalse: [ Registry currentPackage == clpkg ] ]			)				ifTrue: [ ^self validatePackage: clpkg description: nameSpaceSymbol, '.', dataKey ].			^PackageChooser 				chooseOrAdd:  nameSpaceSymbol, '.', dataKey 				withDefault: clpkg				onCancelDo: [ ^Registry nullPackage ]			].	^PackageChooser chooseOrAdd: nameSpaceSymbol, '.', dataKey onCancelDo: [ ^Registry nullPackage ].</body><body package="PackageCategories" selector="packageForNewNameSpaceSymbol:">packageForNewNameSpaceSymbol: nameSpaceSymbol	"Return the package that this namespace should be 	placed in. Nil if none can be determined."	alwaysUse notNil ifTrue: [ ^alwaysUse ].	^self newNameSpaceUseCurrent 		ifTrue: [ Registry currentPackage ]		ifFalse: [ PackageChooser chooseOrAdd:nameSpaceSymbol onCancelDo: [ Registry nullPackage ] ]</body><body package="PackageCategories" selector="packageForNewSelector:classSymbol:meta:">packageForNewSelector: selector classSymbol: classSymbol meta: isMeta	"Return the package that this method should be 	placed in. Nil if none can be determined."	| clpkg |	alwaysUse notNil ifTrue: [ ^alwaysUse ].	( self newMethodUseCurrent and: [ Registry isCurrentNull not ] )		ifTrue: [ ^Registry currentPackage ].	clpkg := Registry containingPackageForClassSymbol: classSymbol.	self newMethodUseClass		ifTrue: 			[ ( self newMethodUseClassIfCurrentSame not or: 				[ Registry isCurrentNull					ifTrue: [ self newMethodUseClassIfNoCurrent ]					ifFalse: [ Registry currentPackage == clpkg ] 				] )  					ifTrue: [ ^self validatePackage: clpkg description: classSymbol, '&gt;&gt;', selector ].			].		^PackageChooser 			chooseOrAdd:  classSymbol,  '&gt;&gt;', selector 			withDefault: clpkg			onCancelDo: [ ^Registry nullPackage ]</body><body package="PackageCategories" selector="packageForSelector:classSymbol:meta:">packageForSelector: selector classSymbol: classSymbol meta: isMeta	"Return the package that this method should be placed in."	| pkg |	alwaysUse notNil ifTrue: [^alwaysUse].	pkg := Registry containingPackageForSelector: selector classSymbol: classSymbol meta: isMeta.	pkg == nil 		ifTrue: [ pkg := self packageForNewSelector: selector classSymbol: classSymbol meta: isMeta ].	^pkg</body></methods><methods><class-id>Store.BasicPackagePolicy</class-id> <category>private</category><body package="PackageCategories" selector="nullPackage">nullPackage	^Registry nullPackage</body><body package="PackageCategories" selector="validatePackage:description:">validatePackage: aPackage description: aString	aPackage hasBeenModifiedSomewhere		ifTrue: [ ^aPackage ].	^self checkForFirst		ifTrue: [ self warnOnFirstModificationOfPackage: aPackage description: aString ]		ifFalse: [ aPackage ].</body><body package="PackageCategories" selector="warnOnFirstModificationOfPackage:description:">warnOnFirstModificationOfPackage: aPackageModel description: aString	"Display warning and answer appropiate package to use."	| msg |	msg := (#WarnModifiedPackage &lt;&lt; #packages &gt;&gt; 'Do you want to add &lt;1s&gt; to the previously unchanged package, &lt;2s&gt;&lt;ntttttt&gt;OK to continue?').	^( Dialog confirm: ( msg expandMacrosWith: aString with: aPackageModel name ) )		ifTrue: [ aPackageModel ]		ifFalse: 			[ PackageChooser 				chooseOrAdd:  aString 				withDefault: nil				onCancelDo: [ Registry nullPackage ]			].</body></methods><methods><class-id>Store.NameSpaceForParcel</class-id> <category>conversion</category><body package="PackageCategories" selector="addToPackage:">addToPackage: aPackage	"Add the receiver to aPackage"	| cset |	cset := XChangeSet current.	hasDefinition 		ifTrue: [ cset addNameSpaceDefinition: object toPackage: aPackage ].	data do:		[ :key | cset changeDataKey: key nameSpace: object package: aPackage ].</body><body package="PackageCategories" selector="updates:package:">updates: updates package: aPackage	"Update aPackage after parcel update."	| cset |	cset :=XChangeSet current.	self hasDefinition		ifTrue:			[ ( ( updates at: #changed ) includes: object )				ifTrue: [ cset changeNameSpace: object toPackage: aPackage ].			( ( updates at: #added ) includes: object )				ifTrue: [ cset addNameSpace: object toPackage: aPackage ].			].	self processDataUpdates: updates package: aPackage.</body></methods><methods><class-id>Store.NameSpaceForParcel</class-id> <category>testing</category><body package="PackageCategories" selector="isForNameSpace">isForNameSpace	^true</body></methods><methods><class-id>Store.NameSpaceForParcel</class-id> <category>private</category><body package="PackageCategories" selector="processDataUpdates:package:">processDataUpdates: updates package: aPackage	| cset |	cset :=XChangeSet current.	data do:		[ :key |		( self isDataKey: key in: ( updates at: #added ) )			ifTrue: [ cset addDataKey: key nameSpace: object package: aPackage ].		( self isDataKey: key in: ( updates at: #changed ) )			ifTrue: [ cset changeDataKey: key nameSpace: object package: aPackage ].		].</body></methods><methods><class-id>Store.PackageChooser</class-id> <category>initialize-release</category><body package="PackageCategories" selector="initialize">initialize	| list pkgs |	super initialize.	pkgs := Registry allPackagesWithNull 				asSortedCollection: [ :p1 :p2 | p1 name &lt; p2 name ].	list := pkgs collect: [ :pk | pk name ].	sequence := SelectionInList new.	sequence list: list.	self cancel onChangeSend: #userCanceled to: self</body></methods><methods><class-id>Store.PackageChooser</class-id> <category>accessing</category><body package="PackageCategories" selector="objectName:">objectName: aString	objectName := aString</body><body package="PackageCategories" selector="selectedPackageOrNil">selectedPackageOrNil	^self accept value		ifTrue: 			[| sel |			(sel := sequence selection) notNil				ifTrue: [Registry packageNamed: sel]				ifFalse: [nil]]		ifFalse: [nil]</body></methods><methods><class-id>Store.PackageChooser</class-id> <category>aspects</category><body package="PackageCategories" selector="dialogHeader">dialogHeader	^objectName== nil		ifTrue: [ Registry currentPackage name ]		"ifTrue: [ 'Choose a Package' ]"		ifFalse: [ objectName ].</body><body package="PackageCategories" selector="labelFor:">labelFor: aSymbol	^self perform: aSymbol</body><body package="PackageCategories" selector="packageList">packageList	^sequence</body></methods><methods><class-id>Store.PackageChooser</class-id> <category>private-accessing</category><body package="PackageCategories" selector="defaultPackage:">defaultPackage: aPkg	defaultPackage := aPkg</body><body package="PackageCategories" selector="onCancelDo:">onCancelDo: aBlock	onCancelDo := aBlock</body><body package="PackageCategories" selector="withAdd:">withAdd: aBoolean	withAdd := aBoolean</body></methods><methods><class-id>Store.PackageChooser</class-id> <category>private-actions</category><body package="PackageCategories" selector="addNewPackage">addNewPackage	| newPkg |	sequence selection: nil.	(newPkg := self addPackage) notNil		ifTrue: 			[sequence list add: newPkg name.			sequence selection: newPkg name.			self accept value: true]</body><body package="PackageCategories" selector="addPackage">addPackage	^SmalltalkWorkbench requestNewPackageName		ifNotNil: [:name | PackageModel named: name]</body><body package="PackageCategories" selector="dClickAccept">dClickAccept	self accept value: true</body><body package="PackageCategories" selector="userCanceled">userCanceled	onCancelDo value</body></methods><methods><class-id>Store.PackageChooser</class-id> <category>interface opening</category><body package="PackageCategories" selector="openFrom:">openFrom: aSpec 	"Open a dialog based on aSpec"	| okButton |	self allButOpenFrom: aSpec.	withAdd ifFalse: [(self builder componentAt: #addButton) beInvisible].	okButton := self builder componentAt: #OKbutton.	sequence selectionHolder compute: [:x | x isNil			ifTrue: [okButton disable]			ifFalse: [okButton enable]].	sequence selection: (defaultPackage isNil			ifTrue: [nil]			ifFalse: [defaultPackage name]).	builder openDialog.	^accept value</body></methods><methods><class-id>Store.PackageChooser class</class-id> <category>interface opening</category><body package="PackageCategories" selector="choose">choose	"Prompt the user to choose a package. 	He can pick one form the list, 	or cancel operation in whichcase a block is executed.	Answer the selected package or nil."	"self choose"	^self chooseOnCancelDo: [nil].</body><body package="PackageCategories" selector="chooseOnCancelDo:">chooseOnCancelDo: cancelBlock	"Prompt the user to choose a package. 	He can pick one form the list	or cancel operation in whichcase a block is executed.	Answer the selected package or nil."	"self chooseOnCancelDo: [nil]"		| defPkg |	defPkg := Registry isCurrentNull ifTrue: [nil] ifFalse: [Registry currentPackage].	^self openWithDefault: defPkg withAdd: false onCancel: cancelBlock</body><body package="PackageCategories" selector="chooseOrAdd">chooseOrAdd	"Prompt the user to choose a package. 	He can pick one form the list, create a new one 	or cancel operation in which case a block is executed.	Answer the selected package or nil."	"self chooseOrAdd"	^self chooseOrAddOnCancelDo: [nil].</body><body package="PackageCategories" selector="chooseOrAdd:noCancelWithDefault:">chooseOrAdd: objectName noCancelWithDefault: defPackage 	"Prompt the user to choose a package. 	He can pick one form the list, or create a new one. 	Answer the selected package."	"self chooseOrAddNoCancel"	^self		openWithDefault: defPackage		objectName: objectName		withAdd: true		onCancel: nil</body><body package="PackageCategories" selector="chooseOrAdd:onCancelDo:">chooseOrAdd: objectName onCancelDo: cancelBlock	"Prompt the user to choose a package. He can pick one form the list	or cancel operation in whichcase a block is executed.	Answer the selected package or nil."	"self chooseOrAdd: 'TestClass' onCancelDo: [Transcript show: 'canceled';cr]"		| defPkg |	defPkg := Registry isCurrentNull ifTrue: [nil] ifFalse: [Registry currentPackage].	^self openWithDefault: defPkg objectName: objectName withAdd: true onCancel: cancelBlock</body><body package="PackageCategories" selector="chooseOrAdd:withDefault:onCancelDo:">chooseOrAdd: objectName withDefault: defPackage onCancelDo: aBlock	"Prompt the user to choose a package. He can pick one form the list, or create a new one. 	Answer the selected package."	"self chooseOrAddNoCancel"	^self		openWithDefault: defPackage		objectName: objectName		withAdd: true		onCancel: aBlock</body><body package="PackageCategories" selector="chooseOrAddNoCancel">chooseOrAddNoCancel	"Prompt the user to choose a package. 	He can pick one form the list, or create a new one. 	Answer the selected package."	"self chooseOrAddNoCancel"	^self chooseOrAddOnCancelDo: nil</body><body package="PackageCategories" selector="chooseOrAddNoCancel:">chooseOrAddNoCancel: objectName	"Prompt the user to choose a package. 	He can pick one form the list, or create a new one. 	Answer the selected package."	"self chooseOrAddNoCancel"	^self chooseOrAdd: objectName onCancelDo: nil</body><body package="PackageCategories" selector="chooseOrAddOnCancelDo:">chooseOrAddOnCancelDo: cancelBlock	"Prompt the user to choose a package. 	He can pick one form the list	or cancel operation in whichcase a block is executed.	Answer the selected package or nil."	"self chooseOrAddOnCancelDo: [Transcript show: 'canceled';cr]"		| defPkg |	defPkg := Registry isCurrentNull ifTrue: [nil] ifFalse: [Registry currentPackage].	^self openWithDefault: defPkg withAdd: true onCancel: cancelBlock</body><body package="PackageCategories" selector="openWithDefault:objectName:withAdd:onCancel:">openWithDefault: aDefaultPackage objectName: objectName withAdd: aBoolean onCancel: cancelBlock 	| interface |	interface := cancelBlock isNil				ifTrue: [ #windowSpecNoCancel ]				ifFalse: [ #windowSpec ].	^self new		withAdd: aBoolean; 		onCancelDo: cancelBlock; 		objectName: objectName;		defaultPackage: aDefaultPackage;		openInterface: interface;		selectedPackageOrNil</body><body package="PackageCategories" selector="openWithDefault:withAdd:onCancel:">openWithDefault: aDefaultPackage withAdd: aBoolean onCancel: cancelBlock 	| baby |	baby := self new.	baby withAdd: aBoolean; onCancelDo: cancelBlock; defaultPackage: aDefaultPackage.	baby openInterface: (cancelBlock isNil			ifTrue: [#windowSpecNoCancel]			ifFalse: [#windowSpec]).	^baby selectedPackageOrNil</body></methods><methods><class-id>Store.PundleForParcel</class-id> <category>initialization</category><body package="PackageCategories" selector="from:saveLinks:">from: aPundle saveLinks: saveLinks	name := aPundle name.	properties := aPundle propertiesForFileOut.	saveLinks		ifTrue:			[ properties 				at: #dbTrace put: aPundle dbTrace;				at: #dbIdentifier put: aPundle dbIdentifier;				at: #printStringCache put: aPundle printStringCache			].</body></methods><methods><class-id>Store.PundleForParcel</class-id> <category>private</category><body package="PackageCategories" selector="asPundle:">asPundle: relink	"Convert the receiver into a pundle. Called on parcel load. Answer the converted pundle"	| pundle |	pundle := self pundleInImage.	pundle startLoad.	[ relink 		ifTrue: [ pundle restoreLinksFrom: properties ].	self removeLinks: properties.	pundle properties: properties.	] ensure: [ pundle endLoad ].	^pundle.</body><body package="PackageCategories" selector="removeLinks:">removeLinks: propertyDictionary	"Remove the database links before coping them over."	propertyDictionary 		removeKey: #databaseId ifAbsent: nil;		removeKey: #dbIdentifier ifAbsent: nil;		removeKey: #dbTrace ifAbsent: nil.</body><body package="PackageCategories" selector="updates:fromParcel:relink:">updates: updates fromParcel: aParcel relink: relink	"Update the pundle in the image from a parcel."	| pundle |	pundle := self pundleInImage.	pundle properties: properties.	relink ifFalse: [ self removeLinks: pundle properties ].	^pundle.</body></methods><methods><class-id>Store.PundleForParcel</class-id> <category>accessing</category><body package="PackageCategories" selector="dbIdentifier">dbIdentifier	| dbid |	^( dbid := properties at: #dbIdentifier ifAbsent: 		[ properties at: #databaseId ifAbsent: [ nil ] ]	) == nil			ifFalse: [ dbid asSymbol ].</body><body package="PackageCategories" selector="properties">properties	^properties</body></methods><methods><class-id>Store.PundleForParcel</class-id> <category>conversion</category><body package="PackageCategories" selector="convert">convert	"Convert the receiver into a pundle. Called on parcel load. Answer the converted pundle"	| pundle relink |	relink := self dbIdentifier ~~ nil.	pundle := self asPundle: relink.	^pundle</body><body package="PackageCategories" selector="installContentsUsing:">installContentsUsing: aCodeReader	"Install the pundle contents through aCodeReader"	self subclassResponsibility</body><body package="PackageCategories" selector="installUsing:">installUsing: aCodeReader	"Install the receiver ordered using aCodeReader."	"This is assumed to be sent to the outermost pundle, and the the actions are being run 	for the parcel itself."		self installContentsUsing: aCodeReader.</body><body package="PackageCategories" selector="updates:fromParcel:">updates: updates fromParcel: aParcel	"A parcel has been updated- update the receiver's image model."	| pundle relink |	relink := self dbIdentifier ~~ nil.	pundle := self updates: updates fromParcel: aParcel relink: relink.	^pundle</body></methods><methods><class-id>Store.PundleForParcel class</class-id> <category>instance creation</category><body package="PackageCategories" selector="classForPundle:">classForPundle: aPundle 			^aPundle isPackage		ifTrue: [ PackageForParcel ]		ifFalse: [ BundleForParcel ]</body><body package="PackageCategories" selector="from:saveLinks:">from: aPundle saveLinks: saveLinks			^( self classForPundle: aPundle ) new		from: aPundle saveLinks: saveLinks</body></methods><methods><class-id>Store.BundleForParcel</class-id> <category>initialization</category><body package="PackageCategories" selector="from:saveLinks:">from: aBundle saveLinks: saveLinks	super from: aBundle saveLinks: saveLinks.	contents := OrderedCollection new.	aBundle containedItems do:		[ :pundle |  contents add: 					( PundleForParcel from: pundle saveLinks: saveLinks )		].</body></methods><methods><class-id>Store.BundleForParcel</class-id> <category>private</category><body package="PackageCategories" selector="asPundle:">asPundle: relink	"Convert the receiver into a pundle. Called on parcel load. Answer the converted pundle"	| bundle |	bundle := super asPundle: relink.	bundle startLoad.	[ bundle containedItems: 		( contents collect: [ :pun | pun asPundle: relink ] ).	bundle markNotModified.	] ensure: [ bundle endLoad ].	^bundle.</body><body package="PackageCategories" selector="pundleInImage">pundleInImage	"Answer the image version of the receiver. Creates one if it doesn't exist."	^Registry bundleNamedOrCreate: name.</body><body package="PackageCategories" selector="updates:fromParcel:relink:">updates: updates fromParcel: aParcel relink: relink	"Update the pundle in the image from a parcel."	| bundle |	bundle := super updates: updates fromParcel: aParcel relink: relink.	bundle containedItems: 		( contents collect: [ :pun | pun updates: updates fromParcel: aParcel relink: relink ] ).	bundle markNotModified.	^bundle.</body></methods><methods><class-id>Store.BundleForParcel</class-id> <category>conversion</category><body package="PackageCategories" selector="installContentsUsing:">installContentsUsing: aCodeReader	"Install the pundle contents through aCodeReader"	contents do:		[ :pundle | 		pundle 			runPreRead;			runPreLoad;			installContentsUsing: aCodeReader;			runPostLoad		].</body></methods><methods><class-id>Store.BundleSpecEditor</class-id> <category>initialize-release</category><body package="PackageCategories" selector="initialize">initialize	super initialize.	disturbed := false.	self availablePundles list: (Registry allPundlesSorted asList).	"make the selectionInList use an OrderedCollection instead of a 	 Set for storing the selections since we want to remember the	 selection order."	self availablePundles selectionIndexes: OrderedCollection new.	pundleAvailability := Array new: self availablePundles list size withAll: true.	Registry addDependent: self</body><body package="PackageCategories" selector="release">release	super release.	Registry removeDependent: self.</body></methods><methods><class-id>Store.BundleSpecEditor</class-id> <category>events</category><body package="PackageCategories" selector="noticeOfWindowClose:">noticeOfWindowClose: aWindow	"The containing window is being closed -- release."	self release</body><body package="PackageCategories" selector="requestForWindowClose">requestForWindowClose	super requestForWindowClose.	^disturbed not or: [Dialog confirm: (#BundleSpecAltered &lt;&lt; #packages &gt;&gt; 'The bundle specification has been altered.  Do you wish to discard the changes?')]</body></methods><methods><class-id>Store.BundleSpecEditor</class-id> <category>updating</category><body package="PackageCategories" selector="update:with:">update: anAspect with: aParameter 	super update: anAspect with: aParameter.	anAspect == #addedPundle ifTrue: [self pundleAdded: aParameter].	anAspect == #removedPundle ifTrue: [self pundleRemoved: aParameter]</body></methods><methods><class-id>Store.BundleSpecEditor</class-id> <category>accessing</category><body package="PackageCategories" selector="bundle">bundle	^bundle</body><body package="PackageCategories" selector="bundle:">bundle: bundleModel	bundle := bundleModel.	self bundleName value: bundle name.	(self builder isNil not and: [bundle isNil not]) 		ifTrue: [self disableBundleNameEdits].	bundle containedItems do: [:aPundleModel |		self pundleAtIndex: (self availablePundles list indexOf: aPundleModel) isAvailable: false].	self pundleAtIndex: (self availablePundles list indexOf: bundle) isAvailable: false.	self builder isNil ifFalse: [(self builder componentAt: #availablePundlesView) invalidate].	self bundleContents list: bundle containedItems.</body></methods><methods><class-id>Store.BundleSpecEditor</class-id> <category>aspects</category><body package="PackageCategories" selector="availablePundles">availablePundles	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^availablePundles isNil		ifTrue:			[availablePundles := MultiSelectionInList new]		ifFalse:			[availablePundles]</body><body package="PackageCategories" selector="bundleContents">bundleContents	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^bundleContents isNil		ifTrue:			[bundleContents := SelectionInList new]		ifFalse:			[bundleContents]</body><body package="PackageCategories" selector="bundleName">bundleName	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^bundleName isNil		ifTrue:			[bundleName := String new asValue]		ifFalse:			[bundleName]</body></methods><methods><class-id>Store.BundleSpecEditor</class-id> <category>actions</category><body package="PackageCategories" selector="accept">accept	"Accept has been selected- answer self to cancel."	( self validateName "and: [ self validateOrder ] " ) 		ifFalse: [ ^self ].			   	bundle == nil		ifTrue: [ self createBundle ]		ifFalse: [ self modifyBundle ].	self undisturb.	self closeRequest</body><body package="PackageCategories" selector="addToBundleContents">addToBundleContents	| selectionIndexes |	selectionIndexes := self availablePundles selectionIndexes.	selectionIndexes isEmpty ifTrue: [^self].	selectionIndexes do: [:i | 		self bundleContents list add: (self availablePundles list at: i).		self pundleAtIndex: i isAvailable: false].	self bundleContents selectionIndex: self bundleContents list size.	"Deselect all items in available pundle list view.  Be sure that the selection in list	 continues to use an OrderedCollection (rather than a Set) to store the selections	 since we want to remember selection order."	self availablePundles selectionIndexes: OrderedCollection new.</body><body package="PackageCategories" selector="cancel">cancel	self undisturb.	self closeRequest</body><body package="PackageCategories" selector="moveBundleItemDown">moveBundleItemDown	| selection currentPosition bundleContentList nextItem |	bundleContentList := self bundleContents list.	currentPosition := self bundleContents selectionIndex.	(currentPosition == self bundleContents zeroIndex or: 			[currentPosition == bundleContentList size]) 		ifFalse: [			"swap the selected item with the next item in the list"			selection := self bundleContents selection.			nextItem := bundleContentList at: currentPosition + 1.			bundleContentList at: currentPosition + 1 put: selection.			bundleContentList at: currentPosition put: nextItem.			self bundleContents selection: selection.]</body><body package="PackageCategories" selector="moveBundleItemUp">moveBundleItemUp	| selection currentPosition bundleContentList previousItem |	bundleContentList := self bundleContents list.	currentPosition := self bundleContents selectionIndex.	(currentPosition == self bundleContents zeroIndex or: 			[currentPosition == 1])		 ifFalse: [			"swap the selected item with the previous item in the list"			selection := self bundleContents selection.			previousItem := bundleContentList at: currentPosition - 1.			bundleContentList at: currentPosition - 1 put: selection.			bundleContentList at: currentPosition put: previousItem.			self bundleContents selection: selection.]</body><body package="PackageCategories" selector="removeBundleItem">removeBundleItem	| itemToRemove availablePundleIndex |		(itemToRemove := self bundleContents selection) isNil ifFalse: [		availablePundleIndex := self availablePundles list indexOf: itemToRemove.		self pundleAtIndex: availablePundleIndex isAvailable: true.		(self builder componentAt: #availablePundlesView) widget updateAt: availablePundleIndex.		self bundleContents selection: nil.		self bundleContents list remove: itemToRemove.]</body><body package="PackageCategories" selector="validateLoadOrder">validateLoadOrder	| errs |	Dialog warn:		( ( errs := BundleModel validateLoadOrder: self bundleContents list ) isEmpty			ifTrue: [ (#LoadOrderValidated &lt;&lt; #packages &gt;&gt; 'Load order validated.') ]			ifFalse:	[ errs ]		)</body></methods><methods><class-id>Store.BundleSpecEditor</class-id> <category>list visuals</category><body package="PackageCategories" selector="initializeVisualBlocksForBundleContentView">initializeVisualBlocksForBundleContentView	| contentView |	contentView := (self builder componentAt: #bundleContentsView) widget.	contentView selectedVisualBlock: [:aView :index | self			makeBundleContentListItemForIndex: index			inView: aView			selected: true].	contentView visualBlock: [:aView :index | self			makeBundleContentListItemForIndex: index			inView: aView			selected: false]</body><body package="PackageCategories" selector="initializeVisualBlocksForPundleView">initializeVisualBlocksForPundleView	| pundleView |	pundleView := (self builder componentAt: #availablePundlesView) widget.	pundleView selectedVisualBlock: [:aView :index | self			makePundleListItemForIndex: index			inView: aView			selected: true].	pundleView visualBlock: [:aView :index | self			makePundleListItemForIndex: index			inView: aView			selected: false]</body><body package="PackageCategories" selector="makeBundleContentListItemForIndex:inView:selected:">makeBundleContentListItemForIndex: index inView: aSelectionView selected: isSelected	| label pundle |	pundle := self bundleContents list at: index.	label := self labelWithString: pundle name		icon: (self class iconForPundle: pundle)		disabled: false		reversed: isSelected		checked: false		inView: aSelectionView.	^BoundedWrapper on: label.</body><body package="PackageCategories" selector="makePundleListItemForIndex:inView:selected:">makePundleListItemForIndex: index inView: aSelectionView selected: isSelected 	| label disable pundle check |	disable := (self isPundleAvailableAtIndex: index) not.	pundle := self availablePundles list at: index.	check := isSelected.	label := self				labelWithString: pundle name				icon: (self class iconForPundle: pundle)				disabled: disable				reversed: check				checked: false				inView: aSelectionView.	^BoundedWrapper on: label</body></methods><methods><class-id>Store.BundleSpecEditor</class-id> <category>private-validation</category><body package="PackageCategories" selector="validateName">validateName	"Answer true if the bundle name is ok. Display warning and answer false if not."	self bundleName value isEmpty		ifTrue: [ Dialog warn: (#EnterBundleNameBeforeAccept &lt;&lt; #packages &gt;&gt; 'Enter a bundle name before accepting.').  ^false ].			   	^bundle == nil    		ifFalse: [ true ]		ifTrue: [ 	( PackageModel validateName: self bundleName value ) 					ifFalse: [ Dialog warn: (#BundleHasIllegalCharacters &lt;&lt; #packages &gt;&gt; 'Bundle name "&lt;1s&gt;" can not contain any of these characters: &lt;2s&gt;.&lt;n&gt;Use a different bundle name.' 							expandMacrosWith: self bundleName value							with: PackageModel illegalCharacters).							^false							].				( Registry isBundleLoaded: self bundleName value ) not					ifTrue: [ true ]					ifFalse: [ Dialog warn: ((#BundleNameConflict &lt;&lt; #packages &gt;&gt; 'The name &lt;1s&gt; is already in use.  Use another bundle name.')								expandMacrosWith: self bundleName value).							false 							].				]</body><body package="PackageCategories" selector="validateOrder">validateOrder	"Answer true bundle contents is ok. Display warning and answer false if not."	| errs |	errs := BundleModel validateLoadOrder: self leafItems.	^errs isEmpty		ifTrue: [ true ]		ifFalse: 			[ errs := ((#BundleCannotBeLoaded &lt;&lt; #packages &gt;&gt; '&lt;1s&gt;&lt;nn&gt;WARNING: the Bundle cannot be loaded. Continue anyway?')				expandMacrosWith: errs).			Dialog confirm: errs.  			].</body></methods><methods><class-id>Store.BundleSpecEditor</class-id> <category>private</category><body package="PackageCategories" selector="addCheckMarkToImage:">addCheckMarkToImage: anImage 	| cp |	cp := CompositePart new.	cp add: self checkMark at: 0 @ 0.	cp add: anImage at: self checkMarkWidth @ 0.	^cp</body><body package="PackageCategories" selector="bundleNameChanged">bundleNameChanged	self disturb.</body><body package="PackageCategories" selector="checkMark">checkMark	^LabelAndIcon checkMark</body><body package="PackageCategories" selector="checkMarkGap">checkMarkGap	^4</body><body package="PackageCategories" selector="checkMarkWidth">checkMarkWidth	^self checkMark width + self checkMarkGap</body><body package="PackageCategories" selector="createBundle">createBundle	| newBundleModel |	newBundleModel := BundleModel named: self bundleName value.	newBundleModel containedItems: self bundleContents list.</body><body package="PackageCategories" selector="disableBundleNameEdits">disableBundleNameEdits	(self builder componentAt: #bundleName) widget isEnabled: false</body><body package="PackageCategories" selector="disturb">disturb	disturbed := true.</body><body package="PackageCategories" selector="isPundleAvailableAtIndex:">isPundleAvailableAtIndex: anIndex	^pundleAvailability at: anIndex</body><body package="PackageCategories" selector="labelWithString:icon:disabled:reversed:checked:inView:">labelWithString: aString icon: anImage disabled: isDisabled reversed: isReversed checked: isChecked inView: aSelectionView	"If isOffset is true, the returned LabalAndIcon will be offset so that the icon 	will align with the icons of other labels preceeded by check marks."	| label disabledText |	label := LabelAndIcon with: aString attributes: aSelectionView textStyle.	isDisabled		ifTrue: 			[disabledText := aString asText.			disabledText emphasizeAllWith: 				(Array					with: #color -&gt; aSelectionView inactiveForegroundColor					with: #italic).			label text: disabledText].	label icon: (isChecked ifTrue: [self addCheckMarkToImage: anImage] ifFalse: [anImage]).	isReversed		ifTrue: 			[label := ReversingWrapper on: label.			label reverse setValue: true].	^label</body><body package="PackageCategories" selector="leafItems">leafItems	| pkgs |	pkgs := OrderedCollection new.	self bundleContents list do:		[ :pundle | pkgs addAll: pundle leafItems ].	^pkgs</body><body package="PackageCategories" selector="modifyBundle">modifyBundle	bundle containedItems ~= self bundleContents list ifTrue: [bundle containedItems: self bundleContents list]</body><body package="PackageCategories" selector="okSelection:">okSelection: aController		"Don't let the selection change if the targeted item is disabled"	^self isPundleAvailableAtIndex: aController view targetIndex</body><body package="PackageCategories" selector="pundleAdded:">pundleAdded: aPundle 	"update the lists after a pundle has been added to the image"	| newPundleList index |	newPundleList := Registry allPundlesSorted.	index := newPundleList indexOf: aPundle.	"insert an element into the pundleAvailability array"	pundleAvailability := pundleAvailability				copyReplaceFrom: index				to: index - 1				with: (Array with: true).		self availablePundles list add: aPundle beforeIndex: index.	self availablePundles selectionIndexes: (self availablePundles selectionIndexes collect: [:i | i &gt;= index				ifTrue: [i + 1]				ifFalse: [i]])</body><body package="PackageCategories" selector="pundleAtIndex:isAvailable:">pundleAtIndex: index isAvailable: aBoolean	pundleAvailability at: index put: aBoolean.</body><body package="PackageCategories" selector="pundleRemoved:">pundleRemoved: aPundle 	"update the lists after a pundle has been removed from the image"	| index removed |	"update available pundles"	index := self availablePundles list indexOf: aPundle.	pundleAvailability := pundleAvailability "remove index'th element from array"				copyReplaceFrom: index				to: index				with: Array new.	self availablePundles list remove: aPundle.	self availablePundles selectionIndexes remove: index ifAbsent: [nil].	self availablePundles selectionIndexes: 		(self availablePundles selectionIndexes collect: [:i | i &gt;= index				ifTrue: [i - 1]				ifFalse: [i]]).	"update bundle contents"	removed := self bundleContents list remove: aPundle ifAbsent: [nil].	removed isNil ifFalse: [self bundleContents selection: nil].</body><body package="PackageCategories" selector="undisturb">undisturb	disturbed := false.</body></methods><methods><class-id>Store.BundleSpecEditor</class-id> <category>interface opening</category><body package="PackageCategories" selector="postBuildWith:">postBuildWith: aBuilder 	self bundle isNil ifFalse: [self disableBundleNameEdits].	self initializeVisualBlocksForPundleView.	self initializeVisualBlocksForBundleContentView.</body></methods><methods><class-id>Store.BundleSpecEditor class</class-id> <category>instance creation</category><body package="PackageCategories" selector="openOnBundle:">openOnBundle: aBundle		BundleSpecEditor new bundle: aBundle; open.</body></methods><methods><class-id>Store.BundleSpecEditor class</class-id> <category>private</category><body package="PackageCategories" selector="bundleImageModified">bundleImageModified	^ListIconLibrary visualFor: #modifiedBundle</body><body package="PackageCategories" selector="bundleImageUnmodified">bundleImageUnmodified	^ListIconLibrary visualFor: #bundle</body><body package="PackageCategories" selector="dbBundleImage">dbBundleImage	^ListIconLibrary visualFor: #bundle</body><body package="PackageCategories" selector="dbPackageImage">dbPackageImage	^ListIconLibrary visualFor: #package</body><body package="PackageCategories" selector="iconForPundle:">iconForPundle: aPundle 	| modified loaded |	modified := aPundle hasBeenModified.	loaded := aPundle isLoaded.	^aPundle isBundle		ifTrue: [loaded				ifTrue: [modified						ifTrue: [self bundleImageModified]						ifFalse: [self bundleImageUnmodified]]				ifFalse: [self dbBundleImage]]		ifFalse: [loaded				ifTrue: [modified						ifTrue: [self packageImageModified]						ifFalse: [self packageImageUnmodified]]				ifFalse: [self dbPackageImage]]</body><body package="PackageCategories" selector="packageImageModified">packageImageModified	^ListIconLibrary visualFor: #modifiedPackage</body><body package="PackageCategories" selector="packageImageUnmodified">packageImageUnmodified	^ListIconLibrary visualFor: #package</body></methods><methods><class-id>Store.BundleStructureChange</class-id> <category>fileIn/Out</category><body package="PackageCategories" selector="fileIn">fileIn	"File-in the receiver - ie. make the change to the system."	self createComponent structure: structure.</body><body package="PackageCategories" selector="fileOutOn:">fileOutOn: aSourceFile	aSourceFile		bundleNamed: componentName		structure: structure</body></methods><methods><class-id>Store.BundleStructureChange</class-id> <category>testing</category><body package="PackageCategories" selector="isStructureTag">isStructureTag	^true</body><body package="PackageCategories" selector="sameAsSystem">sameAsSystem	"Return true if the receiver represents an object that is the same as the system."	| bundle |	( bundle := self component ) == nil		ifTrue: [ ^false ].	^structure = bundle structure</body></methods><methods><class-id>Store.BundleStructureChange</class-id> <category>accessing</category><body package="PackageCategories" selector="component:">component: aBundle	"Extract relevant information from aCodeComponent."		super component: aBundle.	structure := aBundle structure.</body><body package="PackageCategories" selector="componentType">componentType	^#bundle</body><body package="PackageCategories" selector="name">name	"Answer the name which should appear in the list view."	nil == name 		ifTrue: [	name := self description ].	^name</body><body package="PackageCategories" selector="parameters">parameters	"Return the parameters used for the 'same as' test"	^super parameters asOrderedCollection		add: structure;		asArray.</body><body package="PackageCategories" selector="structure">structure	^structure</body><body package="PackageCategories" selector="structure:">structure: anArray	structure := anArray.</body><body package="PackageCategories" selector="structureString:">structureString: aString	structure := Compiler evaluate: aString</body><body package="PackageCategories" selector="systemText">systemText	"Answer the text displayed by the receiver."	| comp |	( comp := self component ) == nil		ifTrue: [ ^(#doesNotExist &lt;&lt; #packages &gt;&gt; 'does not exist') asString ].	^self text: comp structure</body><body package="PackageCategories" selector="text">text	"Answer the text displayed by the receiver."	^self text: structure</body><body package="PackageCategories" selector="text:">text: aStructure	"Answer the text displayed by the receiver with aStructure."	| stream |	stream := ( String new: 100 ) writeStream.	stream nextPutAll: ((#x1sStructureC &lt;&lt; #packages &gt;&gt; '&lt;1s&gt; structure: ')			expandMacrosWith: componentName); cr.	aStructure do:		[ :array | stream tab; nextPutAll: array storeString; cr ].	^stream contents</body><body package="PackageCategories" selector="type">type 	"Answer the sub-type of this kind of change."	^#structure</body></methods><methods><class-id>Store.BundleStructureChange</class-id> <category>store</category><body package="PackageCategories" selector="doChangeTo:">doChangeTo: aChangeSet	"Perfrom the reciever's change onto aChangeSet."	"Used in converting ChangeSet changes to Store changes."	aChangeSet addOtherChange: BundleModel structureMark.</body></methods><methods><class-id>Store.BundleStructureChange</class-id> <category>printing</category><body package="PackageCategories" selector="description">description		^((#x1sStructureChanged &lt;&lt; #packages &gt;&gt; '&lt;1s&gt; structure changed')			expandMacrosWith: super description)</body><body package="PackageCategories" selector="printOn:">printOn: aStream		super printOn: aStream.	aStream 		nextPut: $(;		nextPutAll: (#structureChanged &lt;&lt; #packages &gt;&gt; '&lt;1s&gt; structure changed'			expandMacrosWith: componentName);		nextPut: $)</body></methods><methods><class-id>Store.BundleStructureChange</class-id> <category>converting</category><body package="PackageCategories" selector="sourceTextForImage">sourceTextForImage	| comp |	comp := self component.	^comp == nil		ifTrue: [ nil ]		ifFalse: [ comp structure ]</body></methods><methods><class-id>Store.ClassForParcel</class-id> <category>initialization</category><body package="PackageCategories" selector="from:">from: aModel	super from: aModel.	selectors := aModel selectorsMeta: false.	metaSelectors := aModel selectorsMeta: true.</body></methods><methods><class-id>Store.ClassForParcel</class-id> <category>conversion</category><body package="PackageCategories" selector="addToPackage:">addToPackage: aPackage	( object isKindOf: AbsentClassImport )		ifTrue: [ ^self ].	hasDefinition 		ifTrue: [ XChangeSet current addClassDefinition: object toPackage: aPackage ].	self addAllSubDefsTo: aPackage.</body><body package="PackageCategories" selector="updates:package:">updates: updates package: aPackage	"Update aPackage after parcel update."	| cset |	( object isKindOf: AbsentClassImport )		ifTrue: [ ^self ].	cset :=XChangeSet current.	self hasDefinition		ifTrue:			[ ( self isObjectIn: ( updates at: #added ) )				ifTrue: [ ^self addToPackage: aPackage ].			( self isObjectIn: ( updates at: #changed ) )				ifTrue: [ cset changeClass: object toPackage: aPackage ].			].	( self isObjectIn: ( updates at: #added ) )		ifTrue: [ ^self addAllSubDefsTo: aPackage ].	self processSelectors: selectors class: object updates: updates package: aPackage.	self processSelectors: metaSelectors class: object class			updates: updates package: aPackage.	self processDataUpdates: updates package: aPackage.</body></methods><methods><class-id>Store.ClassForParcel</class-id> <category>testing</category><body package="PackageCategories" selector="isForClass">isForClass	^true</body></methods><methods><class-id>Store.ClassForParcel</class-id> <category>accessing</category><body package="PackageCategories" selector="selectorsMeta:">selectorsMeta: isMeta	^isMeta		ifTrue: [ metaSelectors ]		ifFalse: [ selectors ]</body></methods><methods><class-id>Store.ClassForParcel</class-id> <category>private</category><body package="PackageCategories" selector="addAllSubDefsTo:">addAllSubDefsTo: aPackage	| cset |	cset :=XChangeSet current.	selectors do: 		[ :selector |		( Override isOverriddenSelector: selector class: object )			ifTrue: [ cset changeSelector: selector class: object toPackage: aPackage ]			ifFalse: [ cset addSelector: selector class: object toPackage: aPackage ]		].	metaSelectors do: 		[ :selector |		( Override isOverriddenSelector: selector class: object class )			ifTrue: [ cset changeSelector: selector class: object class toPackage: aPackage ]			ifFalse: [ cset addSelector: selector class: object class toPackage: aPackage ]		].	data do:		[ :key | cset changeDataKey: key class: object package: aPackage ].</body><body package="PackageCategories" selector="isSelector:class:in:">isSelector: selector class: aClass in: aCollection	"Answer true if aClass&gt;&gt;selector is in a Collection of parcel updates."	^aCollection contains:		[ :thing |		( ( thing class = MethodInstallationRecord ) and:			[ thing selector = selector ] ) and: 			[ thing implementingClass = aClass ] 		]</body><body package="PackageCategories" selector="processDataUpdates:package:">processDataUpdates: updates package: aPackage	| cset |	cset :=XChangeSet current.	data do:		[ :key |		( self isDataKey: key in: ( updates at: #added ) )			ifTrue: [ cset addDataKey: key class: object package: aPackage ].		( self isSelector: key class: object in: ( updates at: #changed ) )			ifTrue: [ cset changeDataKey: key class: object package: aPackage ].		].</body><body package="PackageCategories" selector="processSelectors:class:updates:package:">processSelectors: aCollection class: aClass updates: updates package: aPackage	| cset |	cset :=XChangeSet current.	aCollection do:		[ :selector |		( self isSelector: selector class: aClass in: ( updates at: #added ) )			ifTrue: [ cset addSelector: selector class: object toPackage: aPackage ].		( self isSelector: selector class: aClass in: ( updates at: #changed ) )			ifTrue: [ cset changeSelector: selector class: aClass toPackage: aPackage ].		].</body><body package="PackageCategories" selector="processSelectors:updates:package:">processSelectors: aCollection updates: updates package: aPackage	| cset |	cset :=XChangeSet current.	aCollection do:		[ :selector |		( self isSelector: selector class: object in: ( updates at: #added ) )			ifTrue: [ cset addSelector: selector class: object toPackage: aPackage ].		( self isSelector: selector class: object in: ( updates at: #changed ) )			ifTrue: [ cset changeSelector: selector class: object toPackage: aPackage ].		].</body></methods><methods><class-id>Store.Model</class-id> <category>testing</category><body package="PackageCategories" selector="existsInImage">existsInImage	^true</body><body package="PackageCategories" selector="isClassModel">isClassModel	^false</body><body package="PackageCategories" selector="isExtension">isExtension	^false</body><body package="PackageCategories" selector="isForClass">isForClass	^false</body><body package="PackageCategories" selector="isForData">isForData	^false</body><body package="PackageCategories" selector="isForGeneral">isForGeneral	^false</body><body package="PackageCategories" selector="isForMethod">isForMethod	^false</body><body package="PackageCategories" selector="isForNameSpace">isForNameSpace			^false</body><body package="PackageCategories" selector="isLoaded">isLoaded	^self existsInImage</body><body package="PackageCategories" selector="isNameSpaceModel">isNameSpaceModel	^false</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>namespace model</category><body package="PackageCategories" selector="addNameSpaceModel:">addNameSpaceModel: nameSpaceModel	self addModel: nameSpaceModel named: nameSpaceModel absoluteSymbol</body><body package="PackageCategories" selector="containingPackageForNameSpace:">containingPackageForNameSpace: namespace	^self containingPackageForSymbol: namespace absoluteSymbol</body><body package="PackageCategories" selector="nameSpaceModelsForNameSpaceName:do:">nameSpaceModelsForNameSpaceName: aFullSymbol do: aBlock 	self modelsForSymbol: aFullSymbol do: aBlock</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>class model</category><body package="PackageCategories" selector="addClassModel:">addClassModel: cm 	self addModel: cm named: cm absoluteName.</body><body package="PackageCategories" selector="classModelsForClassSymbol:do:">classModelsForClassSymbol: aClassSymbol do: aBlock 	self modelsForSymbol: aClassSymbol do: aBlock</body><body package="PackageCategories" selector="defClassModelForClassSymbol:">defClassModelForClassSymbol: aFullSymbol 	^self defModelForSymbol: aFullSymbol</body><body package="PackageCategories" selector="defNameSpaceModelForNameSpaceSymbol:">defNameSpaceModelForNameSpaceSymbol: aFullSymbol 	^self defModelForSymbol: aFullSymbol</body><body package="PackageCategories" selector="extensionClassModelsForClassSymbol:">extensionClassModelsForClassSymbol: aClassSymbol 	| cms |	cms := modelDictionary at: aClassSymbol ifAbsent: [^#()].	^cms size &gt; 1		ifTrue: [cms copyFrom: 2 to: cms size]		ifFalse: [#()]</body><body package="PackageCategories" selector="extensionModelsForSymbol:">extensionModelsForSymbol: aSymbol 	"Answer all extenstion models for aSymbol or an empty colleciton if none."	| models |	models := modelDictionary at: aSymbol ifAbsent: [ ^#() ].	^models size &gt; 1		ifTrue: [ models copyFrom: 2 to: models size ]		ifFalse: [#() ]</body><body package="PackageCategories" selector="packagesContaining:">packagesContaining: aClassOrNameSpace	"Answer a collection of packages that contain some methods/statics for aClassOrNameSpace.	The first package contains the definition."	"Store.Registry packagesContaining: Object class"	| symbol |	symbol := aClassOrNameSpace isBehavior		ifTrue: [ aClassOrNameSpace instanceBehavior absoluteSymbol ]		ifFalse: [  aClassOrNameSpace absoluteSymbol ].	^( self modelsForSymbol: symbol ) collect:		[ :model | model package ]</body><body package="PackageCategories" selector="packagesContaining:do:">packagesContaining: aClassOrNameSpace do: aBlock 	"Evaluate aBlock for each packages that contain some methods/statics for aClassOrNameSpace."	"Store.Registry packagesContaining: Object class do: [ :pkg | Transcript show: pkg name; tab ]"	| symbol |	symbol := aClassOrNameSpace isBehavior		ifTrue: [ aClassOrNameSpace instanceBehavior absoluteSymbol ]		ifFalse: [  aClassOrNameSpace absoluteSymbol ].	self modelsForSymbol: symbol do: 		[ :model | aBlock value: model package ]</body><body package="PackageCategories" selector="packagesContainingClass:do:">packagesContainingClass: aClass do: aBlock 	"Evaluate aBlock for each packages that contain some methods/statics for aClass."	self classModelsForClassSymbol: aClass instanceBehavior absoluteSymbol do: 		[:cm | aBlock value: cm package]</body><body package="PackageCategories" selector="packagesContainingClassSymbol:do:">packagesContainingClassSymbol: classSymbol do: aBlock 	self classModelsForClassSymbol: classSymbol do: 		[:cm | aBlock value: cm package]</body><body package="PackageCategories" selector="packagesContainingNameSpace:do:">packagesContainingNameSpace: namespace do: aBlock 	self modelsForSymbol: namespace absoluteSymbol do: 		[ :model | aBlock value: model package ]</body><body package="PackageCategories" selector="quickContainingClassModelForSelector:classSymbol:meta:">quickContainingClassModelForSelector: aSelector classSymbol: aClassSymbol meta: isMeta 	"If there are extensions check them for the selector.  	Otherwise use the class' model do not ask the class' model if it includes 	the selector or there will be infinite recursion."	| cms |	cms := modelDictionary at: aClassSymbol ifAbsent: [ ^nil ].	cms size &gt; 1		ifTrue: 			[ 2 to: cms size do: 				[ :index |  | cm |				cm := cms at: index.				( cm includesSelector: aSelector meta: isMeta )					ifTrue: [ ^cm ]				].			].	^cms first</body><body package="PackageCategories" selector="quickContainingModelForDataKey:symbol:">quickContainingModelForDataKey: datakey symbol: aSymbol	"If there are extensions check them for the datakey.  Otherwise use the class' model.	Do not ask the def model if it includes the datakey or there will be infinite recursion."	| models |	models := modelDictionary at: aSymbol ifAbsent: [ ^nil ].	models size &gt; 1		ifTrue: 			[ 2 to: models size do: 				[ :index | | model |				model := models at: index.				( model includesDataKey: datakey )						ifTrue: [ ^model ]				].			].	^models first</body><body package="PackageCategories" selector="removeClassModel:">removeClassModel: cm 	self removeModel: cm named: cm absoluteSymbol</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>private model accessing</category><body package="PackageCategories" selector="addModel:">addModel: model 	self addModel: model named: model absoluteSymbol.</body><body package="PackageCategories" selector="addModel:named:">addModel: aModel named: aFullSymbol	"private- generic for looking up in model dictionaries"	"took out a couple 'snafus'. They can mess the image up."	| models symbol |	symbol := aFullSymbol asSymbol.	models := modelDictionary at: symbol ifAbsentPut: [ Array new: 1 ].	aModel isExtension		"means there should be at least a defmodel there"		ifTrue: [ modelDictionary at: symbol put: ( models copyWith: aModel ) ]		ifFalse: 			[ ( models first isNil )				ifFalse: [ self notify: (#SnafuAddModelToNonEmpty &lt;&lt; #packages &gt;&gt; 'Model snafu: adding a def model to non-empty') ].			models at: 1 put: aModel.			].</body><body package="PackageCategories" selector="definitionModels">definitionModels	^( modelDictionary collect: [ :list | list first ]  )		reject: [ :m | m == nil ]</body><body package="PackageCategories" selector="defModelForSymbol:">defModelForSymbol: aFullSymbol 	^( modelDictionary at: aFullSymbol ifAbsent: [ ^nil ] ) first</body><body package="PackageCategories" selector="modelKeys">modelKeys	^modelDictionary keys</body><body package="PackageCategories" selector="modelsForSymbol:">modelsForSymbol: aFullSymbol 	"Answer a list of def/extenstion models for aFullSymbol"	^( modelDictionary at: aFullSymbol ifAbsent: [ ^#() ] ) 		reject: [ :m | m == nil ]</body><body package="PackageCategories" selector="modelsForSymbol:do:">modelsForSymbol: aFullSymbol do: aBlock 	"Perform aBlock for every def/extenstion model for aFullSymbol"	| models |	models := modelDictionary at: aFullSymbol ifAbsent: [ ^self ].	models do: 		[ :model | model == nil ifFalse: [ aBlock value: model ] ].</body><body package="PackageCategories" selector="removeModel:named:">removeModel: model named: fullSymbol	"Removes all mention of the class/namespace represented by model from the registry."	"Newer version is more forgiving, so we can use it cleaning up."	| models |	models := modelDictionary at: fullSymbol ifAbsent: [ ^self ].	model isExtension		ifTrue: 			[ | index |			index := models indexOf: model ifAbsent: [ ^self ].			index = 1 ifTrue: [self notify: (#ClassModelSnafu &lt;&lt; #packages &gt;&gt; 'Class model snafu')].			models size = 2				ifTrue: 					[ models first isNil 						ifTrue: [ modelDictionary removeKey: fullSymbol ] 						ifFalse: [ modelDictionary at: fullSymbol put: ( models copyWithout: model ) ] 					]				ifFalse: 	[ modelDictionary at: fullSymbol put: ( models copyWithout: model ) ] 			]		ifFalse: 			[ model = models first				ifTrue: 					[ models size == 1 						ifTrue: [ modelDictionary removeKey: fullSymbol ]						ifFalse: [ models at: 1 put: nil ]					]				ifFalse: 					[ models first isNil 						ifTrue: [ ^self ] 						ifFalse: [self halt: (#SnafuRemovedWrongOne &lt;&lt; #packages &gt;&gt; 'Model snafu - attempt to remove the wrong one') ]					]			]</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>package accessing</category><body package="PackageCategories" selector="allPackages">allPackages	"Answer a collection of all the loaded packages."	^packages values</body><body package="PackageCategories" selector="allPackagesWithNull">allPackagesWithNull	| pkgs |	pkgs := OrderedCollection new: packages size + 1.	packages do: [:pkg | pkgs addLast: pkg].	( pkgs includes: self nullPackage )		ifFalse: [ pkgs addFirst: self nullPackage ].	^pkgs</body><body package="PackageCategories" selector="isPackageLoaded:">isPackageLoaded: aName	^packages includesKey: aName asString</body><body package="PackageCategories" selector="packageNamed:">packageNamed: aName	aName == nil		ifTrue: [ ^nil ].	^packages at: aName asString ifAbsent: 		[ aName = self nullPackageName			ifTrue: [ self nullPackage ]			ifFalse: [ nil ]		]</body><body package="PackageCategories" selector="packageNamedOrCreate:">packageNamedOrCreate: aName	^packages at: aName asString ifAbsent: 		[ aName = self nullPackageName			ifTrue: [ self nullPackage ]			ifFalse: [ PackageModel named: aName ]		]</body><body package="PackageCategories" selector="packagesDo:">packagesDo: aBlock	"Execute 'aBlock' for each package loaded.	Access this way to keep 'packages' private."	packages do: aBlock</body><body package="PackageCategories" selector="removePackage:">removePackage: aPackage 	"Unload aPackage and remove it from the 	package list. Answer true if operation succeeds."	aPackage isNil		ifFalse: 			[ self currentPackage = aPackage ifTrue: [self currentPackage: self nullPackage].			packages removeKey: aPackage name ifAbsent: [^false].			self changed: #removedPundle with: aPackage.			( self enclosingComponentsFor: aPackage ) do:				[ :comp | comp removeComponent: aPackage asDescription ].			^true			].	^false</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>private-image delivery</category><body package="PackageCategories" selector="createTableOfContents">createTableOfContents	"Registry createTableOfContents"	| aStream fName |	fName := Dialog requestNewFileName: (#RequestTOCfileName &lt;&lt; #packages &gt;&gt; 'Write the package table of contents to:') default: 'toc'.	fName isEmpty ifTrue: [^self].	aStream := fName asFilename writeStream.	[Registry tableOfContentsOn: aStream]		ensure: [aStream close].	fName := Dialog requestNewFileName: (#RequestTOBCfileName &lt;&lt; #packages &gt;&gt; 'Write the bundle table of contents to:') default: 'tobc'.	fName isEmpty ifTrue: [^self].	aStream := fName asFilename writeStream.	[Registry tableOfBundleContentsOn: aStream]		valueNowOrOnUnwindDo: [aStream close]</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>utility</category><body package="PackageCategories" selector="repairForMethodsInZeroOrMultiplePackages">repairForMethodsInZeroOrMultiplePackages	"Registry repairForMethodsInZeroOrMultiplePackages"	Transcript cr; show: (#CheckingMultiplePackagesOrNone &lt;&lt; #packages &gt;&gt; 'Checking/repairing methods in multiple packages or no package').	Object allSubclassesDo: [:class | class selectors			do: 				[:selector | 				| pkgs cnt |				cnt := 0.				pkgs := self whatPackagesContainSelector: selector class: class.				pkgs size &gt; 1					ifTrue: [Transcript show: class printString , '&gt;&gt;' , selector asString , ' --&gt; ' , pkgs asArray printString; cr]					ifFalse: [(pkgs size &lt; 1 or: [pkgs first name = '(none)'])							ifTrue: 								[cnt := cnt + 1.								XChangeSet current									moveSelector: selector									class: class									toPackage: (self containingPackageForClass: class)]].				cnt &gt; 0 ifTrue: [Transcript cr; show: ((#MovingMethodsToNewPackage &lt;&lt; #packages &gt;&gt; 'Moved &lt;1s&gt; methods in class &lt;2s&gt; to &lt;3s&gt;')								expandMacrosWith: cnt printString								with: class printString								with: (self containingPackageForClass: class) name)]]].	Transcript cr; show: (#Done &lt;&lt; #packages &gt;&gt; 'Done.'); cr.</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>consistency checking</category><body package="PackageCategories" selector="checkConsistencyOn:">checkConsistencyOn: aStream 	"| strm | strm := WriteStream on: String new. 	Registry checkConsistencyOn: strm. 	Transcript show: strm contents; cr"	| checkSize |	checkSize := 		[ ( aStream size &gt; 1000 ) ifTrue: [ ^aStream nextPutAll: '.......' ] ].	self cleanseModels.	self checkModelsOn: aStream .	checkSize value.	self checkPackagesOn: aStream.	checkSize value.	self checkForNameSpaceAndDataInZeroOrMultiplePackagesOn: aStream.	checkSize value.	self checkForClassesAndMethodsInZeroOrMultiplePackagesOn: aStream</body><body package="PackageCategories" selector="checkForClassesAndMethodsInZeroOrMultiplePackagesOn:">checkForClassesAndMethodsInZeroOrMultiplePackagesOn: aStream 	Root allClasses do: 		[ :class | 		( self containingPackageForClass: class ) == nil			ifTrue: [ class isMeta ifFalse: [ aStream nextPutAll: ((#x1sUnpackaged &lt;&lt; #packages &gt;&gt; '&lt;1s&gt; - Unpackaged')						expandMacrosWith: class printString); cr ] ]			ifFalse: 				[ | cms |				cms := self extensionClassModelsForClassSymbol: class absoluteSymbol.				cms size &gt;= 2 ifTrue: 					[ class selectors do: 						[ :selector |   | pkgs |						pkgs := OrderedCollection new.						cms do: 							[ :cm | 							( cm includesSelector: selector meta: class isMeta )								ifTrue: [ pkgs add: cm package ] 							].						pkgs size &gt; 1 							ifTrue: [ aStream nextPutAll: ((#x1s2sInPackages3s &lt;&lt; #packages &gt;&gt; '&lt;1s&gt;%&gt;%&gt;&lt;2s&gt; in packages &lt;3s&gt;')								expandMacrosWith: class printString								with: selector asString								with: pkgs asArray printString); cr ]						]					].					class dataKeys do:						[ :key |  | pkgs |						pkgs := OrderedCollection new.						cms do: 							[ :cm | 							( cm includesDataKey: key )								ifTrue: [ pkgs add: cm package ] 							].						pkgs size &gt; 1 							ifTrue: [ aStream nextPutAll: ((#x1sDot2sInPackages3s &lt;&lt; #packages &gt;&gt; '&lt;1s&gt;.&lt;2s&gt; in packages &lt;3s&gt;')								expandMacrosWith: class printString								with: key asString								with: pkgs asArray printString); cr ]						]				]		]</body><body package="PackageCategories" selector="checkForNameSpaceAndDataInZeroOrMultiplePackagesOn:">checkForNameSpaceAndDataInZeroOrMultiplePackagesOn: aStream 	Root allNameSpaces do: 		[ :ns | 		( self containingPackageForNameSpace: ns ) == nil			ifTrue: [ aStream nextPutAll: ((#x1sUnpackaged &lt;&lt; #packages &gt;&gt; '&lt;1s&gt; - Unpackaged')							expandMacrosWith: ns printString); cr ]			ifFalse: 				[ | models |				models := self extensionModelsForSymbol: ns absoluteSymbol.				models size &gt;= 2 ifTrue: 					[ ns dataKeys do:						[ :key |  | pkgs |						pkgs := OrderedCollection new.						models do: 							[ :model | 							( model includesDataKey: key )								ifTrue: [ pkgs add: model package ] 							].						pkgs size &gt; 1 							ifTrue: [ aStream nextPutAll: ((#x1sdot2sInPackages3s &lt;&lt; #packages &gt;&gt; '&lt;1s&gt;.&lt;2s&gt; in packages &lt;3s&gt;')								expandMacrosWith: ns printString								with: key asString								with: ns asArray printString); cr ]						]					]				]		]</body><body package="PackageCategories" selector="checkModel:symbol:isExtension:on:">checkModel: model symbol: symbol isExtension: isExtension on: aStream 	model absoluteName asSymbol == symbol		ifFalse: 			[aStream nextPutAll: ((#modelDictEntryWrongName &lt;&lt; #packages &gt;&gt; 'model dictionary entry "&lt;1s&gt;" includes model "&lt;2p&gt;" with different name')				expandMacrosWith: symbol				with: model classSymbol).			aStream cr]		ifTrue: [model isExtension ~~ isExtension				ifTrue: 					[aStream nextPutAll: ((#modelDictWrongSlot &lt;&lt; #packages &gt;&gt; 'model dictionary wrong slot "&lt;1s&gt;" in package "&lt;2p&gt;"')						expandMacrosWith: symbol						with: model package).					aStream cr]				ifFalse: 					[model checkConsistencyOn: aStream ]]</body><body package="PackageCategories" selector="checkModels:for:on:">checkModels: models for: aSymbol on: aStream 	"Private- subroutine for #checkClassModelsOn: 	Check that a model collection is correct. Registered in a package, 	that the class to class models dictionary is in proper form, that the class models 	themselves are correct (refer the existent classes and methods, etc)."	| instSelectors metaSelectors dataKeys forClass |	aSymbol isSymbol		ifFalse: [ ^aStream nextPutAll: ((#modelKeyNotSymbol &lt;&lt; #packages &gt;&gt; 'model dictionary key not a symbol: &lt;1s&gt;')					expandMacrosWith: aSymbol); cr ].	models isNil		ifTrue:  [ ^aStream nextPutAll: ((#modelEntryNil &lt;&lt; #packages &gt;&gt; 'model dictionary entry is nil: &lt;1s&gt;')					expandMacrosWith: aSymbol); cr ].	models size = 0		ifTrue: [ ^aStream nextPutAll: ((#modelEntryZeroSize &lt;&lt; #packages &gt;&gt; 'class model dictionary entry is zero size: &lt;1s&gt;')					expandMacrosWith: aSymbol); cr. ].	models first isNil		ifTrue: [aStream nextPutAll: ((#x1sIsNotInAPackage &lt;&lt; #packages &gt;&gt; '&lt;1s&gt; is not in a package')					expandMacrosWith: aSymbol); cr ]		ifFalse: 				[ models first isClassModel 					ifTrue:						[ self							checkModel: models first							symbol: aSymbol							isExtension: false							on: aStream.						forClass := true.						]					ifFalse: 						[ self							checkNameSpaceModel: models first							symbol: aSymbol  							isExtension: false							on: aStream.						forClass := false. 						].				].			"Check extension models"		instSelectors := IdentitySet new.		metaSelectors := IdentitySet new.		dataKeys := IdentitySet new.		2 to: models size do: 			[ :index |   | model |			( model := models at: index ) == nil				ifTrue: 					[ aStream nextPutAll: ((#modelExtensionsNil &lt;&lt; #packages &gt;&gt; 'model dictionary extension is nil: &lt;1s&gt;')						expandMacrosWith: aSymbol).					aStream cr]				ifFalse: 					[ 					model isClassModel 						ifFalse: 							[ | newData | 							forClass == true 								ifTrue: [ aStream nextPutAll: ((#x1sBothClassAndNamespace &lt;&lt; #packages &gt;&gt; '&lt;1s&gt; has both class and namespace models.')										expandMacrosWith: aSymbol); cr ].							forClass := false.							newData := model dataKeys.							newData do: 								[ :dataKey | 								(dataKeys includes: dataKey)										ifTrue: 											[aStream nextPutAll: ((#dataInMultiplePackages &lt;&lt; #packages &gt;&gt; 'data &lt;1s&gt;:&lt;2s&gt; is in another package besides &lt;3p&gt;')												expandMacrosWith: aSymbol												with: dataKey												with: model package).											aStream cr].								self									checkNameSpaceModel: model									symbol: aSymbol									isExtension: true									on: aStream								].							dataKeys addAll: newData.					  ]				ifTrue:						[ | newInst newMeta |						forClass := true.						newInst := model selectorsMeta: false.						newMeta := model selectorsMeta: true.						newInst do: 							[ :selector | 							(instSelectors includes: selector)								ifTrue: 									[aStream nextPutAll: ((#methodInMultiplePackages &lt;&lt; #packages &gt;&gt; 'method &lt;1s&gt;%&gt;&lt;2s&gt; is in another package besides &lt;3p&gt;')											expandMacrosWith: aSymbol											with: selector											with: model package).									aStream cr]							].							instSelectors addAll: newInst.							newMeta do: 								[:selector | 								(metaSelectors includes: selector)									ifTrue: 										[aStream nextPutAll: ((#metaMethodInMultiplePackages &lt;&lt; #packages &gt;&gt; 'method &lt;1s&gt; class%&gt;&lt;2s&gt; is in another package besides &lt;3p&gt;')													expandMacrosWith: aSymbol													with: selector													with: model package).										aStream cr]								].								metaSelectors addAll: newMeta.				]			]		].</body><body package="PackageCategories" selector="checkModelsOn:">checkModelsOn: aStream 	"Check that all models are in their package, that these packages are registered, 	that the class to class models dictionary is in proper form, that the class models 	themselves are correct (refer the existent classes and methods, etc)."	"| strm | strm := WriteStream on: String new. 	TT_Registry checkClassModelsOn: strm. 	Transcript show: strm contents; cr"	modelDictionary keysAndValuesDo: 		[ :symbol :models | 		self checkModels: models for: symbol on: aStream 		].</body><body package="PackageCategories" selector="checkNameSpaceModel:symbol:isExtension:on:">checkNameSpaceModel: model symbol: nsSymbol isExtension: isExtension on: aStream 	model absoluteName asSymbol == nsSymbol		ifFalse: 			[aStream nextPutAll: ((#namespaceModelHasClassNameWrong &lt;&lt; #packages &gt;&gt; 'namespace model dictionary entry "&lt;1s&gt;" includes class model "&lt;2p&gt;" with different name')				expandMacrosWith: nsSymbol				with: model symbol).			aStream cr]		ifTrue: [model isExtension ~~ isExtension				ifTrue: 					[aStream nextPutAll: ((#namespaceModelWrongSlot &lt;&lt; #packages &gt;&gt; 'namespace model dictionary wrong slot "&lt;1s&gt;" in package "&lt;2p&gt;"')						expandMacrosWith: nsSymbol						with: model package).					aStream cr]				ifFalse: 					[model checkConsistencyOn: aStream ]]</body><body package="PackageCategories" selector="checkPackagesOn:">checkPackagesOn: aStream	packages keys do:		[ :key | 		key isSymbol			ifTrue: [ aStream nextPutAll: ((#PackageShouldBeString &lt;&lt; #packages &gt;&gt; 'Package: &lt;1s&gt; is a symbol, not a string).')					expandMacrosWith: key) ]		].	bundles keys do:		[ :key | 		key isSymbol			ifTrue: [ aStream nextPutAll: ((#BundleShouldBeString &lt;&lt; #packages &gt;&gt; 'Bundle: &lt;1s&gt; is a symbol, not a string).')					expandMacrosWith: key) ]		].	self packagesDo: [:pkg | pkg checkConsistencyOn: aStream ].</body><body package="PackageCategories" selector="cleanseModels">cleanseModels	"Check that all models exist - remove non-existant models and dispaly a warning."	self cleanseModels: true</body><body package="PackageCategories" selector="cleanseModels:">cleanseModels: warn	"Check that all models exist - remove non-existant models and display a warning if warn is true."	| real |	modelDictionary values copy do:		[ :models | 		models first == nil			ifTrue: 				[ [ real := ( models at: 2 ) actual ] on: UnloadedObjectError do:					[ :x | modelDictionary removeKey: models second absoluteSymbol ].				real == nil					ifFalse: 						[ modelDictionary removeKey: ( models at: 2 ) absoluteSymbol.						2 to: models size do:							[ :index | | model |							model := models at: index.							model fullClassSymbol: real absoluteSymbol.							self addModel: model							].						].				]			ifFalse:				[ [ models first actual ] on: UnloadedObjectError do:					[ :x |					warn ifTrue:						[ Dialog warn: ((#RemovingNonexistantC1s &lt;&lt; #packages &gt;&gt; 'Removing non-existant: &lt;1s&gt;')							expandMacrosWith: models first absoluteName) ].					modelDictionary removeKey: models first absoluteSymbol.				]			].		].</body><body package="PackageCategories" selector="whatPackagesContainDatum:classOrNameSpace:">whatPackagesContainDatum: aDataKey classOrNameSpace: owner 	| pkgs |	pkgs := OrderedCollection new.	self modelsForSymbol: owner absoluteSymbol do: 		[ :model | ( model includesDataKey: aDataKey )			ifTrue: [ pkgs add: model package ]		].	^pkgs</body><body package="PackageCategories" selector="whatPackagesContainSelector:class:">whatPackagesContainSelector: aSelector class: aClass 	| pkgs |	pkgs := OrderedCollection new.	self classModelsForClassSymbol: aClass absoluteName asClassNameOnly asSymbol do: 		[ :cm | ( cm includesSelector: aSelector meta: aClass isMeta )			ifTrue: [ pkgs add: cm package ]		].	^pkgs</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>pundle accessing</category><body package="PackageCategories" selector="allPundles">allPundles	"Answer a collection of all the loaded packages and bundles."	| all |	all := OrderedCollection new: self size.	packages do: [:value | all add: value].	bundles do: [:value | all add: value].	^all</body><body package="PackageCategories" selector="allPundlesSorted">allPundlesSorted	"Answer a collection of all the loaded packages and bundles. 	Bundles go first in alphabetical order followed by packages."	| all sorted |	sorted := SortedCollection sortBlock: [:x :y | x name &lt; y name].	all := OrderedCollection new: self size.	bundles do: [:value | sorted add: value].	all addAll: sorted.	sorted := SortedCollection sortBlock: [:x :y | x name &lt; y name].	packages do: [:value | sorted add: value].	all addAll: sorted.	^all</body><body package="PackageCategories" selector="renamePundle:to:">renamePundle: aPundle to: aString	"Renames a pundle - assumes user already knows this will lose pundle history."	| dict old |	aPundle name = self nullPackageName		ifTrue: [ ^Dialog warn: (#CannotRenameNullPackage &lt;&lt; #packages &gt;&gt; 'Cannot rename the null package.') ].	aPundle enclosingComponents do:		[ :bundle | bundle component: aPundle beingRenamedTo: aString ].	( dict := aPundle isBundle 		ifTrue: [ bundles ] 		ifFalse: [ packages ] 	) removeKey: aPundle name.	old := aPundle name.	aPundle name: aString.	dict at: aString put:aPundle.	self adjustPrerequisitesFor: old renamedTo: aString.	self changed: #renamedPundle with: aPundle.</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>initialize-release</category><body package="PackageCategories" selector="cloneFrom:">cloneFrom: aPA	"| pa |	pa := PundleAccess new.	pa cloneFrom: Registry.	Registry := pa	"	aPA packagesDo: 		[ :pkg |		packages at: pkg name put: pkg.		pkg modelsDo: [ :cm |  self addClassModel: cm ] 		].	aPA bundlesDo: 		[ :pkg | bundles at: pkg name put: pkg ].</body><body package="PackageCategories" selector="initialize">initialize	nullPackage := PackageModel named: self nullPackageName.	bundles := Dictionary new.	packages := Dictionary new. 	modelDictionary := IdentityDictionary new.	currentPackage := nullPackage.	self addDependent: self.</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>current/null package accessing</category><body package="PackageCategories" selector="currentPackage">currentPackage	^currentPackage</body><body package="PackageCategories" selector="currentPackage:">currentPackage: aPkg 	"Set the current default package"	| newCurrentPackage |	newCurrentPackage := aPkg isNil				ifTrue: [self nullPackage]				ifFalse: [aPkg].	currentPackage == newCurrentPackage		ifFalse: 			[currentPackage := newCurrentPackage.			self changed: #currentPackage with: currentPackage]</body><body package="PackageCategories" selector="isCurrentNull">isCurrentNull	currentPackage isNil ifTrue: [^true].	^currentPackage name = self nullPackageName</body><body package="PackageCategories" selector="nullPackage">nullPackage		"TT_Registry nullPackage"	^nullPackage</body><body package="PackageCategories" selector="nullPackageName">nullPackageName	^'(none)'</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>bundle accessing</category><body package="PackageCategories" selector="allBundles">allBundles	"Answer a collection of all the loaded bundles."	^bundles values</body><body package="PackageCategories" selector="allBundlesWithNewerInDB">allBundlesWithNewerInDB	"Answer a collection of packages with newer published versions."	"Store.Registry allPackagesWithNewerInDB"	| coll |	coll := OrderedCollection new.	bundles do:		[ :bundle |  | versions trace |		trace := bundle dbTrace.		versions := trace == nil			ifTrue: [ bundle class databaseClass allVersionsWithName: bundle name ]			ifFalse: [ bundle class databaseClass allVersionsWithName: bundle name after: trace ].		coll addAll: versions.		].	^coll</body><body package="PackageCategories" selector="allEnclosingBundlesFor:">allEnclosingBundlesFor: aComponent 	"Answer a collection of bundles that contain aComponent, all bundles that contain those bundles, etc."	| findAncestors hasBeenDone |	"deal with potential circular containment structure"	hasBeenDone := Set new.	findAncestors := [:aPundle | 		(hasBeenDone includes: aPundle) ifTrue: [#()]			ifFalse: [ | collectedAncestors parents|				hasBeenDone add: aPundle.				parents := self enclosingComponentsFor: aPundle.				collectedAncestors := Set new addAll: parents; yourself.				parents do: [:aParent | collectedAncestors addAll: (findAncestors value: aParent)].				collectedAncestors]].	^findAncestors value: aComponent.</body><body package="PackageCategories" selector="anyContainedItems">anyContainedItems	"Answer a collection of components."	^self containedItems</body><body package="PackageCategories" selector="bundleNamed:">bundleNamed: aName	^bundles at: aName asString ifAbsent: [nil]</body><body package="PackageCategories" selector="bundleNamedOrCreate:">bundleNamedOrCreate: aName	^bundles at: aName asString ifAbsent: 		[ BundleModel named: aName ]</body><body package="PackageCategories" selector="bundlesDo:">bundlesDo: aBlock	"Execute 'aBlock' for each bundle loaded.	Access this way to keep 'bundles' private."	bundles do: aBlock</body><body package="PackageCategories" selector="containedItems">containedItems	"Answer a collection of components.""	^( self allBundles asSortedCollection: [ :a :b | a name &lt; b name ] ) asOrderedCollection,		( self allPackages asSortedCollection: [ :a :b | a name &lt; b name ] )"	^containedItemsCache isNil 		ifTrue: 			[| blist plist |			blist := ( ( self allBundles select: [ :pkg | pkg enclosingComponents size = 0 ] ) asSortedCollection: [ :a :b | a name &lt; b name ] ) asOrderedCollection.			plist := ( self allPackages select: [ :pkg | pkg enclosingComponents size = 0 ] ) asSortedCollection: [ :a :b | a name &lt; b name ].			containedItemsCache := blist, plist]		ifFalse: [containedItemsCache]</body><body package="PackageCategories" selector="enclosingComponentsFor:">enclosingComponentsFor: aComponent 	"Answer a collection of bundles that contian aComponent."	| answer |	answer := OrderedCollection new.	bundles do: 		[ :aBundle | 		( aBundle containsItem: aComponent )			ifTrue: [ answer add: aBundle ]		].	^answer</body><body package="PackageCategories" selector="isBundleLoaded:">isBundleLoaded: aName	^bundles includesKey: aName asString</body><body package="PackageCategories" selector="isLeaf">isLeaf	^false</body><body package="PackageCategories" selector="pundleNamed:">pundleNamed: aName	"Answer a bundle or a package named aName"	| pundle |	( pundle := self bundleNamed: aName ) == nil		ifTrue: [  pundle := self packageNamed: aName ].	^pundle.</body><body package="PackageCategories" selector="removeBundle:">removeBundle: aBundle 	"Unload aBundle and remove it from the 	bundle list. Answer true if operation succeeds."	aBundle == nil		ifTrue: [ ^false ].	bundles removeKey: aBundle name ifAbsent: [ ^false ].	self changed: #removedPundle with: aBundle.	( self enclosingComponentsFor: aBundle ) do:		[ :comp | comp removeComponent: aBundle asDescription ].	^true.</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>pundle model private access</category><body package="PackageCategories" selector="privateRegisterPundle:">privateRegisterPundle: aPundleModel 	"Private access for loaded pundles to register 	themselves on creation."	( aPundleModel isBundle		ifTrue: [ bundles ]		ifFalse: [ packages ]	 ) at: aPundleModel name put: aPundleModel.	self changed: #addedPundle with: aPundleModel.	ChangeSet createdComponent: aPundleModel.	SourceFileManager default createdComponent: aPundleModel.</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>table of contents</category><body package="PackageCategories" selector="executeCompleteTableOfContentsNamed:">executeCompleteTableOfContentsNamed: aString	"Hook up a parcel to the database. 	aString is a path and name without an extension."	| filename |	filename := aString, '.toc'.	filename asFilename exists		ifTrue: [ self executeTableOfContentsFromFile: filename ].	filename := aString, '.tobc'.	filename asFilename exists		ifTrue: [ self executeTableOfBundleContentsFromFile: filename ].	#{PundleParentMap} ifDefinedDo:		[ :ppm | 		filename := aString, '.tbl'.		filename asFilename exists			ifTrue: [ ppm readParentsAndReconnectFromFile: filename ].		].</body><body package="PackageCategories" selector="executeTableOfBundleContents:">executeTableOfBundleContents: aTC 	^aTC isSequenceable		ifTrue: [aTC first createComponent containedItems: (aTC last collect: [:desc | self executeTableOfBundleContents: desc])]		ifFalse: [aTC createComponent]</body><body package="PackageCategories" selector="executeTableOfBundleContentsFromFile:">executeTableOfBundleContentsFromFile: aString 	"Registry executeTableOfBundleContentsFromFile: 'TOBC'"	| strm tc |		[strm := aString asFilename readStream.	tc := self tableOfBundleContentsFrom: strm]		ensure: [strm close].	tc do: [:tci | self executeTableOfBundleContents: tci]</body><body package="PackageCategories" selector="executeTableOfContents:">executeTableOfContents: aTC	aTC keysAndValuesDo: 		[ :pkgName :tags | 	| pkg |		pkg := self packageNamedOrCreate: pkgName.		tags do: [ :tag | tag moveToPackage: pkg ifNotLoaded: [ ] ]		]</body><body package="PackageCategories" selector="executeTableOfContentsFromFile:">executeTableOfContentsFromFile: aString 	"Registry executeTableOfContentsFromFile: 'TOC'"	| strm tc |		[strm := aString asFilename readStream.	tc := self tableOfContentsFrom: strm]		ensure: [strm close].	self executeTableOfContents: tc</body><body package="PackageCategories" selector="tableOfBundleContents">tableOfBundleContents	"Registry tableOfBundleContents"	| strm |	strm := WriteStream on: (String new: 400000).	self tableOfBundleContentsOn: strm.	^strm contents</body><body package="PackageCategories" selector="tableOfBundleContentsFrom:">tableOfBundleContentsFrom: aStream 	^self tobcComponentsFrom: aStream</body><body package="PackageCategories" selector="tableOfBundleContentsOn:">tableOfBundleContentsOn: aStream 	self bundlesDo: [:bun | bun tableOfBundleContentsOn: aStream]</body><body package="PackageCategories" selector="tableOfBundleContentsOnFile:">tableOfBundleContentsOnFile: aString	"Registry tableOfBundleContentsOnFile: 'TOBC'"	| strm |	strm := aString asFilename writeStream.	self tableOfBundleContentsOn: strm.	strm close.</body><body package="PackageCategories" selector="tableOfContents">tableOfContents	"Registry tableOfContents"	| strm |	strm := WriteStream on: (String new: 400000).	self tableOfContentsOn: strm.	^strm contents</body><body package="PackageCategories" selector="tableOfContentsBundleContentsFrom:">tableOfContentsBundleContentsFrom: aStream 	| itemNames |	itemNames := OrderedCollection new.		[| kind desc |	aStream skipSeparators.	kind := aStream next.	desc := kind = $"				ifTrue: [PackageDescription new]				ifFalse: [kind = $@						ifTrue: [BundleDescription new]						ifFalse: [kind = $;								ifTrue: [^itemNames]								ifFalse: [self error: (#ExpectedQuoteForPackageName &lt;&lt; #packages &gt;&gt; 'Malformed quote for package name expected')]]].	desc componentName: (aStream upTo: $").	itemNames add: desc] repeat</body><body package="PackageCategories" selector="tableOfContentsFrom:">tableOfContentsFrom: aStream 	| dict |	dict := Dictionary new.		[aStream skipSeparators.	aStream atEnd]		whileFalse: 			[| pkgTags pkgName |			aStream next = $" ifFalse: [self error: (#ExpectedQuoteForPackageName &lt;&lt; #packages &gt;&gt; 'Malformed quote for package name expected')].			pkgName := aStream upTo: $".			pkgTags := self tableOfContentsTagsFrom: aStream.			dict at: pkgName put: pkgTags].	^dict</body><body package="PackageCategories" selector="tableOfContentsOn:">tableOfContentsOn: aStream 	self packagesDo: [:pkg | pkg tableOfContentsOn: aStream]</body><body package="PackageCategories" selector="tableOfContentsOnFile:">tableOfContentsOnFile: aString	"Registry tableOfContentsOnFile: 'TOC'"	| strm |	strm := aString asFilename writeStream.	self tableOfContentsOn: strm.	strm close.</body><body package="PackageCategories" selector="tobcBundleFrom:">tobcBundleFrom: aStream 	| desc comps |	aStream next = $@ ifFalse: [self error: (#ExpectedAtSign &lt;&lt; #packages &gt;&gt; 'Expected at-sign to begin bundle name')].	desc := BundleDescription new.	desc componentName: (aStream upTo: $").	comps := self tobcComponentsFrom: aStream.	aStream next = $; ifFalse: [self error: (#ExpectedSemicolon &lt;&lt; #packages &gt;&gt; 'Expected semi-colon to end bundle description')].	^Array with: desc with: comps</body><body package="PackageCategories" selector="tobcComponentFrom:">tobcComponentFrom: aStream 	aStream peek = $" ifTrue: [^self tobcPackageFrom: aStream].	aStream peek = $@ ifTrue: [^self tobcBundleFrom: aStream].	self error: (#ExpectedAtSignOrQuote &lt;&lt; #packages &gt;&gt; 'Expected at-sign or quote to begin component')</body><body package="PackageCategories" selector="tobcComponentsFrom:">tobcComponentsFrom: aStream 	| comps |	comps := OrderedCollection new.		[aStream skipSeparators.	(aStream atEnd or: [aStream peek = $;]) ifTrue: [^comps].	comps add: (self tobcComponentFrom: aStream)] repeat</body><body package="PackageCategories" selector="tobcPackageFrom:">tobcPackageFrom: aStream 	| desc |	aStream next = $" ifFalse: [self error: (#ExpectedQuoteBeforePackageName &lt;&lt; #packages &gt;&gt; 'Expected quote to begin package name')].	desc := PackageDescription new.	desc componentName: (aStream upTo: $").	^desc</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>definition lookup</category><body package="PackageCategories" selector="allContainingPackagesForClass:">allContainingPackagesForClass: aClass	"Answer all the packges that contain the definition for aClass, including overriden."	| coll pkg overs |	( pkg := self containingPackageForSymbol: aClass absoluteSymbol ) == nil		ifTrue: [ ^nil ].	( overs := Override overridesForClassOrNameSpace: aClass ) == nil		ifTrue: [ ^Array with: pkg ].	coll := OrderedCollection with: pkg.	overs do:		[ :over |		( pkg := over package ) == nil			ifFalse: [ coll add: pkg ].		 ].	^coll</body><body package="PackageCategories" selector="allContainingPackagesForClassOrNameSpace:">allContainingPackagesForClassOrNameSpace: aClassOrNameSpace	"Answer all the packges that contain the definition for a class or namespace, including overriden."	| coll pkg overs |	( pkg := self containingPackageForSymbol: aClassOrNameSpace absoluteSymbol ) == nil		ifTrue: [ ^#( ) ].	( overs := Override overridesForClassOrNameSpace: aClassOrNameSpace ) == nil		ifTrue: [ ^Array with: pkg ].	coll := OrderedCollection with: pkg.	overs do:		[ :over |		( pkg := over package ) == nil			ifFalse: [ coll add: pkg ].		 ].	^coll</body><body package="PackageCategories" selector="allContainingPackagesForDataKey:owner:">allContainingPackagesForDataKey: key owner: aClassOrNamespace	"Answer all the packges that contain the definition for aClassOrNamespace.key, including overriden."	| coll pkg overs |	( pkg := self containingPackageForDataKey: key symbol: aClassOrNamespace absoluteSymbol ) == nil		ifTrue: [ ^#( ) ].	( overs := Override overridesForDataKey: key in: aClassOrNamespace ) == nil		ifTrue: [ ^Array with: pkg ].	coll := OrderedCollection with: pkg.	overs do:		[ :over |		( pkg := over package ) == nil			ifFalse: [ coll add: pkg ].		 ].	^coll</body><body package="PackageCategories" selector="allContainingPackagesForSelector:class:">allContainingPackagesForSelector: selector class: aClass	"Answer all the packges that contain the definition for aClass&gt;&gt;selector, including overriden."	| coll pkg overs |	( pkg := self containingPackageForSelector: selector class: aClass ) == nil		ifTrue: [ ^#( ) ].	( overs := Override overridesForSelector: selector class: aClass ) == nil		ifTrue: [ ^Array with: pkg ].	coll := OrderedCollection with: pkg.	overs do:		[ :over |		( pkg := over package ) == nil			ifFalse: [ coll add: pkg ].		 ].	^coll</body><body package="PackageCategories" selector="containingPackageForClass:">containingPackageForClass: aClass 	^self containingPackageForClassSymbol: aClass instanceBehavior absoluteSymbol</body><body package="PackageCategories" selector="containingPackageForClassName:">containingPackageForClassName: aClassName 	^self containingPackageForClassSymbol: aClassName asClassNameOnly asSymbol</body><body package="PackageCategories" selector="containingPackageForClassNamed:">containingPackageForClassNamed: aClassName 	^self containingPackageForClassSymbol: aClassName asClassNameOnly asSymbol</body><body package="PackageCategories" selector="containingPackageForClassSymbol:">containingPackageForClassSymbol: aClassSymbol 	| cm |	cm := self defClassModelForClassSymbol: aClassSymbol.	^cm isNil		ifTrue: [nil]		ifFalse: [cm package]</body><body package="PackageCategories" selector="containingPackageForDataKey:class:">containingPackageForDataKey: dataKey class: aClass	^self containingPackageForDataKey: dataKey 			symbol: aClass absoluteSymbol</body><body package="PackageCategories" selector="containingPackageForDataKey:nameSpace:">containingPackageForDataKey: dataKey nameSpace: aNameSpace	^self containingPackageForDataKey: dataKey 			symbol: aNameSpace absoluteSymbol</body><body package="PackageCategories" selector="containingPackageForDataKey:symbol:">containingPackageForDataKey: dataKey symbol: aSymbol	( self modelsForSymbol: aSymbol ) do: 		[ :model | ( model includesDataKey: dataKey )			ifTrue: [ ^model package ] 		].	^nil</body><body package="PackageCategories" selector="containingPackageForNameSpaceSymbol:">containingPackageForNameSpaceSymbol: aNameSpaceSymbol 	| model |	model := self defNameSpaceModelForNameSpaceSymbol: aNameSpaceSymbol.	^model isNil		ifTrue: [nil]		ifFalse: [model package]</body><body package="PackageCategories" selector="containingPackageForSelector:class:">containingPackageForSelector: aSelector class: aClass 	"Answer the current package for aClass&gt;&gt;aSelector, nil if none."	"HACK- check for proxy class....."	| symbol |	symbol := aClass isBehavior		ifTrue: [ 	aClass instanceBehavior absoluteSymbol ]		ifFalse: [ aClass absoluteName asSymbol ].	^self containingPackageForSelector: aSelector classSymbol: symbol meta: aClass isMeta</body><body package="PackageCategories" selector="containingPackageForSelector:className:meta:">containingPackageForSelector: aSelector className: aClassName meta: isMeta 	^self		containingPackageForSelector: aSelector		classSymbol: aClassName asClassNameOnly asSymbol		meta: isMeta</body><body package="PackageCategories" selector="containingPackageForSelector:classSymbol:meta:">containingPackageForSelector: aSelector classSymbol: aClassSymbol meta: isMeta 	"Check to see if it is in an extension, otherwise check if it is really in the 	definition class model."	| cm |	cm := self quickContainingClassModelForSelector: aSelector				classSymbol: aClassSymbol meta: isMeta.	^cm == nil		ifTrue: [ nil ]		ifFalse: [ cm package ]</body><body package="PackageCategories" selector="containingPackageForSymbol:">containingPackageForSymbol: aSymbol 	| model |	model := self defModelForSymbol: aSymbol.	^model isNil		ifTrue: [ nil ]		ifFalse: [ model package ]</body><body package="PackageCategories" selector="packageForClass:">packageForClass: class	"Return the package that this class is in (or should be	placed in).  Nil if none can be determined."	^self packageForClassSymbol: class absoluteSymbol.</body><body package="PackageCategories" selector="packageForClassSymbol:">packageForClassSymbol: classSymbol 		^Policies packagePolicy packageForClassSymbol: classSymbol</body><body package="PackageCategories" selector="packageForDataKey:classSymbol:">packageForDataKey: dataKey classSymbol: classSymbol 	^Policies packagePolicy 		packageForDataKey: dataKey classSymbol: classSymbol</body><body package="PackageCategories" selector="packageForDataKey:nameSpaceSymbol:">packageForDataKey: dataKey nameSpaceSymbol: nameSpaceSymbol 		^Policies packagePolicy 		packageForDataKey: dataKey nameSpaceSymbol: nameSpaceSymbol</body><body package="PackageCategories" selector="packageForDataKey:owner:">packageForDataKey: dataKey owner: aClassOrNameSpace		| symbol |	symbol := aClassOrNameSpace absoluteSymbol.	^aClassOrNameSpace isBehavior		ifTrue: [ self packageForDataKey: dataKey classSymbol: symbol ]		ifFalse: [  self packageForDataKey: dataKey nameSpaceSymbol: symbol ].</body><body package="PackageCategories" selector="packageForNameSpace:">packageForNameSpace: namespace	"Return the package that this namespace is in (or should be	placed in).  Nil if none can be determined."	^self packageForNameSpaceSymbol: namespace absoluteSymbol.</body><body package="PackageCategories" selector="packageForNameSpaceSymbol:">packageForNameSpaceSymbol: nameSpaceSymbol 	^Policies isNil		ifTrue: [nil]		ifFalse: [Policies packagePolicy packageForNameSpaceSymbol: nameSpaceSymbol]</body><body package="PackageCategories" selector="packageForNewDataKey:classSymbol:">packageForNewDataKey: dataKey classSymbol: classSymbol 	^Policies packagePolicy 		packageForNewDataKey: dataKey classSymbol: classSymbol</body><body package="PackageCategories" selector="packageForNewDataKey:nameSpaceSymbol:">packageForNewDataKey: dataKey nameSpaceSymbol: nameSpaceSymbol 		^Policies packagePolicy 		packageForNewDataKey: dataKey 		nameSpaceSymbol: nameSpaceSymbol</body><body package="PackageCategories" selector="packageForNewSelector:classSymbol:meta:">packageForNewSelector: selector classSymbol: classSymbol meta: isMeta 	^Policies packagePolicy		packageForNewSelector: selector		classSymbol: classSymbol		meta: isMeta</body><body package="PackageCategories" selector="packageForSelector:classSymbol:meta:">packageForSelector: selector classSymbol: classSymbol meta: isMeta 	^Policies packagePolicy		packageForSelector: selector		classSymbol: classSymbol		meta: isMeta</body><body package="PackageCategories" selector="quickContainingPackageForDataKey:symbol:">quickContainingPackageForDataKey: dataKey symbol: aSymbol	"If there are extensions check them for the selector.  Otherwise use the class' package 	Do not ask the class' package if it includes the datakey or there will be infinite recursion."	"This will be wrong if a dataKey is not loaded."	| cm |	cm := self quickContainingModelForDataKey: dataKey symbol: aSymbol.			^cm == nil		ifTrue: [ Registry nullPackage ]		ifFalse: [ cm package ]</body><body package="PackageCategories" selector="quickContainingPackageForSelector:class:">quickContainingPackageForSelector: aSelector class: aClass 	^self		quickContainingPackageForSelector: aSelector		classSymbol: (aClass isMeta				ifTrue: [aClass soleInstance]				ifFalse: [aClass]) name asSymbol		meta: aClass isMeta</body><body package="PackageCategories" selector="quickContainingPackageForSelector:classSymbol:meta:">quickContainingPackageForSelector: aSelector classSymbol: aClassSymbol meta: isMeta 	"If there are extensions check them for the selector.  Otherwise use the class' package do not ask the	class' package if it includes the selector or there will be infinite recursion."	"This will be wrong if 'aSelector' is not loaded."	| cm |	cm := self		quickContainingClassModelForSelector: aSelector		classSymbol: aClassSymbol		meta: isMeta.	^cm == nil		ifTrue: [ Registry nullPackage ]		ifFalse: [ cm package ]</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>updating</category><body package="PackageCategories" selector="adjustPrerequisitesFor:renamedTo:">adjustPrerequisitesFor: aString renamedTo: bString	"Look at every loaded package and adjust the prerequisites to point to the new name."	( Dialog confirm: ( (#ChangePrereqRefsQ &lt;&lt; #packages &gt;&gt; 'Change prerequisite references from &lt;1s&gt; to &lt;2s&gt;?') expandMacrosWith: aString with: bString ) )		ifFalse: [ ^self ].	self allPundles do:		[ :pun |		pun deploymentPrerequisites do:			[  :req | 			req first = aString				ifTrue: [ req at: 1 put: bString ].			].		pun developmentPrerequisites do:			[ :req | 			( req at: 2 ) = aString				ifTrue: [ req at: 2 put: bString	].				] 		].</body><body package="PackageCategories" selector="blessingChangedForPundle:">blessingChangedForPundle: aPundle 	self changed: #pundleBlessing with: aPundle</body><body package="PackageCategories" selector="changedBundleStructure:">changedBundleStructure: aBundle	containedItemsCache := nil.	self changed: #changedBundleStructure with: aBundle.	ChangeSet bundleStructure: aBundle.	SourceFileManager default bundleStructure: aBundle.</body><body package="PackageCategories" selector="modificationChangedForPundle:">modificationChangedForPundle: aPundle 	self changed: #pundleModificationStatus with: aPundle.	(self allEnclosingBundlesFor: aPundle)		do: [:p | self changed: #pundleModificationStatus with: p]</body><body package="PackageCategories" selector="traceChangedForComponent:">traceChangedForComponent: aCodeComponent 	self changed: #pundleTrace with: aCodeComponent</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>parcel support</category><body package="PackageCategories" selector="checkPrerequisite:requiredVersion:codeReader:">checkPrerequisite: aPundle requiredVersion: reqVersion codeReader: codeReader	"Validate the existense of a pundle as a prerequisite. 	Answer true if acceptable version is already loaded"	^aPundle == nil		ifTrue: [ false ]		ifFalse: 			[ codeReader 				checkPrerequisiteNamed: aPundle name 				withVersion: aPundle traceVersion 				requiredVersion: reqVersion			].</body><body package="PackageCategories" selector="checkPrerequisiteNamed:requiredVersion:codeReader:">checkPrerequisiteNamed: reqName requiredVersion: reqVersion codeReader: codeReader	"Validate the existense of a pundle as a prerequisite. 	Answer true if acceptable version is already loaded"	| pundle |	pundle := self bundleNamed: reqName.	pundle == nil		ifTrue: [ pundle := self packageNamed: reqName ].	^pundle == nil		ifTrue: [ false ]		ifFalse: 			[ codeReader 				checkPrerequisiteNamed: reqName 				withVersion: pundle traceVersion 				requiredVersion: reqVersion			].</body><body package="PackageCategories" selector="parcel:added:to:">parcel: aParcel added: aThing to: aPackage	"aThing has been changed - reflect the update in aPackage."	aThing isNameSpace		ifTrue: [ ^XChangeSet current moveWholeNameSpace: aThing toPackage: aPackage ].	aThing isBehavior		ifTrue: [ ^XChangeSet current moveWholeClass: aThing toPackage: aPackage ].	aThing isVariableBinding		ifTrue: 			[ aParcel definedBindings keysAndValuesDo:				[ :env :keySet |				( ( keySet includes: aThing key ) and:						[ ( env asNameSpace bindingFor: aThing key ) = aThing ] )					ifTrue: [ ^XChangeSet current addBinding: aThing in: env  ].				]			].	aThing class == MethodInstallationRecord		ifTrue: [ ^XChangeSet current 					addSelector: aThing selector					class: aThing implementingClass					toPackage: aPackage				].	Dialog warn: ( (#UnknownParcelChange &lt;&lt; #packages &gt;&gt; 'Unknown parcel change (&lt;1s&gt;)&lt;n&gt; in &lt;2s&gt;')					expandMacrosWith: aThing printString 					with: aPackage name ).</body><body package="PackageCategories" selector="parcel:change:to:">parcel: aParcel change: aThing to: aPackage	"aThing has been changed - reflect the update in aPackage."	aThing isNameSpace		ifTrue: [ ^XChangeSet current changeNameSpace: aThing toPackage: aPackage ].	aThing isBehavior		ifTrue: [ ^XChangeSet current changeClass: aThing toPackage: aPackage ].	aThing isVariableBinding		ifTrue: 			[ ^aParcel definedBindings keysAndValuesDo:				[ :env :keySet |				( keySet includes: aThing key )					ifTrue: [ XChangeSet current changeBinding: ( env asNameSpace bindingFor: aThing key ) in: env  ].				]			].	aThing class == MethodInstallationRecord		ifTrue: [ ^XChangeSet current 					changeSelector: aThing selector					class: aThing implementingClass					toPackage: aPackage				].	Dialog warn: ( (#UnknownParcelChange &lt;&lt; #packages &gt;&gt; 'Unknown parcel change (&lt;1s&gt;)&lt;n&gt; in &lt;2s&gt;')					expandMacrosWith: aThing printString 					with: aPackage name ).</body><body package="PackageCategories" selector="parcel:toPackageNamed:">parcel: aParcel toPackageNamed: aString	"Convert aParcel to a package - assumes was saved as a package."	"will... setup database links."	| pkg |	pkg := Registry packageNamedOrCreate: aString.	pkg startLoad.	[ self registerParcel: aParcel to: pkg.			aParcel propertyAt: #packageName put: aString.	pkg propertyAt: #parcelName put: aParcel name.	pkg restoreLinksFrom: aParcel properties.  "special case stored db links."	pkg resetUninstalledStateFrom: aParcel.	pkg markNotModified.	] ensure: [ pkg endLoad ].	"don't mark converted if already published somewhere."	( aParcel properties includesKey: #dbTrace )			ifFalse: 	[ pkg addOtherChange: #convertedParcel ].	Override equateComponent: aParcel with: self.</body><body package="PackageCategories" selector="parcel:updates:to:">parcel: aParcel updates: updates to: aPackage	"aParcel has been updated - reflect updates in its related package.  	 Be careful to maintain the same installation order as the CodeReader.	 Note that the overrides have already been handled"	| changedThings addedThings |	addedThings := ( updates at: #added ).	changedThings := ( updates at: #changed ).	( addedThings select: [ :thing | thing isNameSpace ] ) do:		[ :aNameSpace | self parcel: aParcel change: aNameSpace to: aPackage ].	( addedThings select: [ :thing | thing isBehavior ] ) do:		[ :aClass | self parcel: aParcel change: aClass to: aPackage ].	( addedThings select: [ :thing | thing isVariableBinding ] ) do:		[ :aBinding | self parcel: aParcel change: aBinding to: aPackage ].	( changedThings select: [ :thing | thing isNameSpace ] ) do:		[ :aNameSpace | self parcel: aParcel change: aNameSpace to: aPackage ].	( changedThings select: [ :thing | thing isBehavior ] ) do:		[ :aClass | self parcel: aParcel change: aClass to: aPackage ].	( changedThings select: [ :thing | thing isVariableBinding ] ) do:		[ :aBinding | self parcel: aParcel change: aBinding to: aPackage ].	( addedThings select: [ :ea | ea class == MethodInstallationRecord ] ) do:		[ :thing | self parcel: aParcel change: thing to: aPackage ].	( changedThings select: [ :ea | ea class == MethodInstallationRecord ] ) do:		[ :thing | self parcel: aParcel added: thing to: aPackage ].	"Takes care of removals - which can't be found to remove anyway."	aPackage cleanse: false.</body><body package="PackageCategories" selector="parcelToBundle:">parcelToBundle: aParcel	"Convert aParcel to a bundle - assumes was saved as a bundle and that prereqs reflect bundle contents."	"setup database links if they exist."	| bundle |	[ bundle := ( aParcel propertyAt: #bundleStructure ) convert ]		on: StoreWarning do: [ :ex | ex resume ].		"may be duplicate adds - okay"	aParcel propertyAt: #bundleStructure put: nil.	"Ensure that the sourceIndex gets copied over."	bundle propertyAt: #sourceIndex put: (aParcel propertyAt: #sourceIndex).	bundle allContainedItems do: [:each | each propertyAt: #sourceIndex put: (aParcel propertyAt: #sourceIndex)].	^bundle.</body><body package="PackageCategories" selector="parcelToPackage:">parcelToPackage: aParcel	"Convert aParcel to a package - assumes was saved as a package."	"setup database links if they exist."	self needsMoreWork.	aParcel asPackageNamed: 		( aParcel propertyAt: #packageName ifAbsent: aParcel name ).</body><body package="PackageCategories" selector="parcelToPundle:">parcelToPundle: aParcel	"Convert aParcel to a pundle - setup database links if they exist. Handle updates if package exists."	| string |	"NOTE: Store itself is an exception because contents were already packaged."	aParcel name = 'StoreBase'		ifTrue: [ ^self ].	( aParcel propertyAt: #bundleStructure ) == nil		ifFalse: [ ^self parcelToBundle: aParcel ].	(  string := aParcel propertyAt: #packageName ) == nil		ifFalse: [ ^self parcel: aParcel toPackageNamed: string ].	^self parcel: aParcel toPackageNamed: aParcel name.</body><body package="PackageCategories" selector="parcelUpdated:updates:">parcelUpdated: aParcel updates: updates	"A parcel has been updated. Update the related package(s)"	( aParcel propertyAt: #bundleStructure ) == nil		ifTrue: [ self updatePackageFromParcel: aParcel updates: updates ]		ifFalse: [ self updateBundleFromParcel: aParcel updates: updates ].</body><body package="PackageCategories" selector="registerParcel:to:">registerParcel: aParcel to: aPackage	"Generate update events for the contents of a parcel - put everything in aPackage."	| cset |	"addXDefinition handles new/and existing"	cset := XChangeSet current.	aParcel definedNameSpaces do:		[ :ns | cset addNameSpaceDefinition: ns toPackage: aPackage ].	aParcel definedClasses do:		[ :cls | cset addClassDefinition: cls toPackage: aPackage ].	aParcel classesAndSelectorsDo:		[ :cls :selectors | | hasClass |		hasClass := aPackage includesClass: cls instanceBehavior.		selectors do:			[ :selector |			( Override isOverriddenSelector: selector class: cls )				ifTrue: [ cset changeSelector: selector class: cls toPackage: aPackage ]				ifFalse: 					[ "special case for overridden class defs - 					its selectors have been stolen by the original class"					hasClass						ifTrue: [  cset correctSelector: selector class: cls toPackage: aPackage ]						ifFalse: [ cset addSelector: selector class: cls toPackage: aPackage ]					]			]		].	aParcel definedBindingsDo:				[ :binding :env |		( Override isOverriddenStatic: binding key in: env )			ifTrue: 				[ env isBehavior					ifTrue: [ cset changeDataKey: binding key class: env package: aPackage ]					ifFalse: [ cset changeDataKey: binding key nameSpace: env package: aPackage ]				]			ifFalse:				[ env isBehavior					ifTrue: [ cset addDataKey: binding key class: env package: aPackage ]					ifFalse: [ cset addDataKey: binding key nameSpace: env package: aPackage ]				]		].	aPackage restoreLinksFrom: aParcel properties.  "special case stored db links."	aPackage copyPropertiesFrom: aParcel properties.</body><body package="PackageCategories" selector="update:with:">update: anAspect with: anArgument	"Handle parcel update"	anAspect == #parcelLoaded 		ifTrue: [ ^self parcelToPundle: anArgument ].	anAspect == #parcelUpdated		ifTrue: [ ^self parcelUpdated: anArgument first updates: anArgument last ].	( #( #parcelInstalledClasses #parcelInstalledNameSpaces #parcelInstalledMethods #installedOverrideMethods )			includes: anAspect )		ifTrue: 			[ | parcel pkg cset |			parcel := anArgument first.			( pkg := parcel relatedPackage ) == nil				ifTrue: [ ^self ].			cset := XChangeSet current.			anAspect == #parcelInstalledClasses				ifTrue: [ cset installedClasses: anArgument last toPackage: pkg ].			anAspect == #parcelInstalledNameSpaces				ifTrue: [ cset installedNameSpaces: anArgument last toPackage: pkg ].			anAspect == #parcelInstalledMethods				ifTrue: [ cset installedMethods: anArgument last toPackage: pkg ].			anAspect == #installedOverrideMethods				ifTrue: [ cset installedOverrideMethods: anArgument last toPackage: pkg ].			pkg resetUninstalledStateFrom: parcel.			^self			].	containedItemsCache := nil.	super update: anAspect with: anArgument.</body><body package="PackageCategories" selector="updateBundleFromParcel:updates:">updateBundleFromParcel: aParcel updates: updates	"Update a bundle from aParcel's updates."	| bundle |	[ bundle := ( aParcel propertyAt: #bundleStructure ) 					updates: updates fromParcel: aParcel	] on: StoreWarning do: [ :ex | ex resume ].		"may be duplicate adds - okay"		^bundle.</body><body package="PackageCategories" selector="updatePackageFromParcel:updates:">updatePackageFromParcel: aParcel updates: updates	"aParcel has been updated - reflect updates in it's related package."	| pkg |	( pkg := aParcel relatedPackage ) == nil		ifTrue: [ ^self ].	self parcel: aParcel updates: updates to: pkg.</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>overrides</category><body package="PackageCategories" selector="componentDefiningClass:">componentDefiningClass: aClass	^( self containingPackageForClass: aClass ) "asDescription"</body><body package="PackageCategories" selector="componentDefiningNameSpace:">componentDefiningNameSpace: aNameSpace	^( self containingPackageForNameSpace: aNameSpace ) "asDescription"</body><body package="PackageCategories" selector="componentDefiningSelector:class:">componentDefiningSelector: selector class: aClass	^( self containingPackageForSelector: selector class: aClass ) "asDescription"</body><body package="PackageCategories" selector="componentDefiningStatic:in:">componentDefiningStatic: aStaticBinding in: aNameSpace	^( self 		containingPackageForDataKey: aStaticBinding key 		symbol: aNameSpace absoluteSymbol 	  ) "asDescription"</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>fileout</category><body package="PackageCategories" selector="installCallBacksForFileout">installCallBacksForFileout	"Add the package property to all fileouts."	"Store.Registry  installCallBacksForFileout "	"HACK- for handling class proxies"	SourceFileFormat attributeFor: #package compute: 		[ :obj |   | pkg |  		pkg := obj isBindingReference			ifTrue: 				[ ( obj isKindOf: Kernel.ChangeSupportClassProxy )					ifTrue: [ self containingPackageForSymbol: obj absoluteSymbol ]					ifFalse: [ self containingPackageForDataKey: obj simpleName 							  symbol: obj environment absoluteSymbol ]				]			ifFalse: [ self containingPackageForSymbol: obj absoluteSymbol ].		pkg == nil	ifFalse: [ pkg name ].		  ].	SourceFileFormat attributeForMethods: #package compute: 		[ :cls :selector |   | pkg |		( pkg :=  self containingPackageForSelector: selector class: cls ) == nil			ifTrue: [ nil]			ifFalse: [ pkg name ].		]</body><body package="PackageCategories" selector="removeCallBacksForFileout">removeCallBacksForFileout	"Add the package property to all fileouts." 	SourceFileFormat removeAttributeFor: #package.</body></methods><methods><class-id>Store.PundleAccess class</class-id> <category>instance creation</category><body package="PackageCategories" selector="new">new	^super new initialize</body></methods><methods><class-id>Store.PundleAccess class</class-id> <category>package partitioning</category><body package="PackageCategories" selector="createBaseBundle">createBaseBundle	"Creates the system bundle from the tobc file created with:		( Store.Registry bundleNamed: 'Base VisualWorks' ) 				tableOfBundleContentsOnFile: 'Base VisualWorks.tobc'  "	| filename |	filename := ( Filename fromComponents:			( Array with: '$(VISUALWORKS)' with: 'tocs' with: 'Base VisualWorks.tobc' ) ) asResolvedString.	filename asFilename exists		ifTrue: [ 	Registry executeTableOfBundleContentsFromFile: filename ].</body><body package="PackageCategories" selector="createStoreBundle:">createStoreBundle: storeParcel	"Creates the system bundle from the tobc file created with:		( Store.Registry bundleNamed: 'StoreBase' ) 			completeTableOfContentsNamed: 'Store'  "	| filename |	filename := ( Filename fromComponents:			( Array with: '$(VISUALWORKS)' with: 'tocs' with: 'Store' ) ) asResolvedString.	Registry executeCompleteTableOfContentsNamed: filename.	( Store.Registry bundleNamed: 'StoreBase' ) 		properties: storeParcel propertiesForFileOut;		parcelName: storeParcel name.</body><body package="PackageCategories" selector="moveCategory:in:toPackageName:">moveCategory: cat in: aNameSpace toPackageName: pkgName 	"Private- For initially partitioning the image (without namespaces)."	( aNameSpace organization listAtCategoryNamed: cat ) do: 		[ :classSymbol | 		self moveClassSymbol: ( aNameSpace absoluteName, '.', classSymbol ) asSymbol			toPackageName: pkgName		]</body><body package="PackageCategories" selector="moveClassSymbol:toPackageName:">moveClassSymbol: classSymbol toPackageName: pkgName 	| pkg |	pkg := Registry packageNamedOrCreate: pkgName.	Transcript cr; show: ((#Moving1sInto2s &lt;&lt; #packages &gt;&gt; 'Moving &lt;1s&gt; into &lt;2s&gt;')			expandMacrosWith: classSymbol			with: pkgName).	XChangeSet current moveWholeClass: classSymbol asStrictReference value		toPackage: pkg</body><body package="PackageCategories" selector="moveUnpackagedCategory:in:toPackageName:">moveUnpackagedCategory: cat in: aNameSpace toPackageName: pkgName 	"Private- For initially partitioning the image (without namespaces).""	Transcript show: 'Moving ' , cat , ' into ' , pkgName; cr.  "	( aNameSpace  organization listAtCategoryNamed: cat asSymbol ) do: 		[ :symbol | 		self moveUnpackagedSymbol: aNameSpace absoluteSymbol, '.', symbol 			toPackageName: pkgName		]</body><body package="PackageCategories" selector="moveUnpackagedClassDataIntoPackages">moveUnpackagedClassDataIntoPackages	"self moveUnpackagedClassDataIntoPackages"	Root withAllNameSpaces do:		[ : ns | 		ns dataBindings do:			[ :binding | 			( Registry containingPackageForDataKey: binding key nameSpace: ns ) == nil				ifTrue: 					[ ( Registry defNameSpaceModelForNameSpaceSymbol: 						( ns absoluteName asSymbol )					  ) addDataKey: binding key.					].			]		].</body><body package="PackageCategories" selector="moveUnpackagedSymbol:toPackageName:">moveUnpackagedSymbol: symbol toPackageName: pkgName 	| pkg object |	pkg := Registry packageNamedOrCreate: pkgName."	Transcript show: 'Moving ' , symbol , ' into ' , pkgName; cr. "	object := symbol asStrictReference valueOrDo: [ self error ].	object isBehavior 		ifTrue: [ XChangeSet current moveUnpackagedInWholeClass: object toPackage: pkg ]		ifFalse: 			[ ( object isNameSpace ) 				ifTrue: [ XChangeSet current moveUnpackagedInWholeNameSpace: object toPackage: pkg ]			]</body><body package="PackageCategories" selector="moveUnpackagedToNullPackage">moveUnpackagedToNullPackage	"Move any unpackaged anything into the NullPackage."		"self moveUnpackagedToNullPackage"	| pkg |	pkg := Registry nullPackage.	Root withAllNameSpacesDo: 		[ :ns  | 		( Registry defNameSpaceModelForNameSpaceSymbol: ns absoluteSymbol ) == nil			ifTrue: [  XChangeSet current moveUnpackagedInWholeNameSpace: ns toPackage: pkg ].		ns classes do:			[ :cls |  			( Registry defClassModelForClassSymbol: cls absoluteSymbol ) == nil				ifTrue: [ XChangeSet current moveUnpackagedInWholeClass: cls toPackage: pkg  ]			]		].</body><body package="PackageCategories" selector="splitIntoPackages">splitIntoPackages	"Private- For initially partitioning the  image (w/out namespaces)."	"PundleAccess splitIntoPackages"	Root withAllNameSpacesDo: 		[ :ns  | 		ns organization categories do: 			[ :cat | | pkgName |			pkgName := cat asString copyFrom: 1 to: (cat indexOf: $- ifAbsent: [cat size + 1] )	- 1.			self moveCategory: cat in: ns toPackageName: pkgName 			]		].</body><body package="PackageCategories" selector="splitUnpackagedIntoPackagesAndBundles">splitUnpackagedIntoPackagesAndBundles	"self splitUnpackagedIntoPackagesAndBundles"	| bundle currentGroupName |	currentGroupName := ''.	Root withAllNameSpacesDo: 		[ :ns  | 		ns organization categories do: 			[ :sym | | pkgName tmp index cat |			cat := sym asString.			 index := ( cat indexOf: $- ifAbsent: [ cat size + 1] ) - 1.			tmp := cat asString copyFrom: 1 to: index.			index &gt;= cat size 				ifTrue: [ self moveUnpackagedCategory: cat in: ns toPackageName: cat  ]				ifFalse:					[ pkgName := cat.		"cat copyFrom: ( index + 2 ) to: cat size."					( currentGroupName = tmp )						ifFalse: 							[ currentGroupName := tmp.							bundle := ( currentGroupName indexOfSubCollection: 'Store' startingAt: 1 ) == 1								ifFalse: [ Registry bundleNamedOrCreate: currentGroupName ].							].					self moveUnpackagedCategory: cat in: ns toPackageName: pkgName.					bundle == nil						ifFalse: [ bundle addItem: ( Registry packageNamed: pkgName ) ].					].			].		].	self moveUnpackagedClassDataIntoPackages</body><body package="PackageCategories" selector="unloadEmptyPackages">unloadEmptyPackages	"DANGER unprotected unloads"	"self unloadEmptyPackages"  	Registry allPackages copy do: 		[:pkg | pkg isCompletelyEmpty  ifTrue: [pkg doUnloadFromImage]].	Registry allBundles copy do: 		[ :bundle | 		bundle removeNonexistentComponents.		bundle isCompletelyEmpty   ifTrue: [ bundle doUnloadFromImage ]		]</body></methods><methods><class-id>Store.PundleAccess class</class-id> <category>parcel load/unload/save</category><body package="PackageCategories" selector="addImports">addImports	"Add specific imports to base NameSpaces."	self storeImports do:		[ :import |		UI addImport: import.  		Tools addImport: import.		].</body><body package="PackageCategories" selector="packageOverridden">packageOverridden	"Assigns overridden code to the base packages. This uses the cateogory names from the overridden	definition as the package name. Known limitation: code already overriden by user parcels before	Store was installed."		Override overridesDo:	[ :over | | pkg |	pkg := Registry packageNamed: over packageFromCategoryName.	( over sources includes: pkg )		ifFalse:			[ over sources add: 				( Registry packageNamed: over packageFromCategoryName )			]	]</body><body package="PackageCategories" selector="removeImports">removeImports	"Remove imports added to base NameSpaces during parcel load."	self storeImports do:		[ :import |		UI removeImport: import.  		Tools removeImport: import 		].</body><body package="PackageCategories" selector="storeImports">storeImports	"Answer an array of specific imports to base NameSpaces."	"self storeImports"	^#( #Policies #Registry #DbRegistry #PackageChooser ) collect:		[ :symbol | | import |		import :=  SpecificNameSpaceImport path: ( Array with: #Store with: symbol ).		import private: true.		import.		].</body></methods><methods><class-id>Store.PundleAccess class</class-id> <category>class initialization</category><body package="PackageCategories" selector="initialize">initialize	"Need only be executed on first installation or on change in definition."	"Retrieve old pundle information from old version of PundleAccess if available."	"PundleAccess initialize"	| old |	old := Registry.	Registry :=  self new.	old == nil		ifFalse: 			[ [ Registry cloneFrom: old.			   ( Parcel dependents includes: old )				ifTrue: [ Parcel removeDependent: old ].			  Override unregisterSourceManager: old.			   old removeCallBacksForFileout.			  Override registerSourceManager: Registry.			  ( Parcel dependents includes: Store.Registry )   				ifFalse: [ Parcel addDependent: Store.Registry ].			  Registry installCallBacksForFileout.			  ] on: Error do:					[ :ex | 					Dialog warn: ((#ErrorReinitializingImageModel &lt;&lt; #packages &gt;&gt; 'Error %&lt;&lt;1s&gt;%&gt; reinitializing the image model.&lt;n&gt;See PundleAccess%&gt;initilialize')						expandMacrosWith: ex description).					Registry := old.					ex  return.					]				].</body></methods><methods><class-id>Store.UnloadedObjectError class</class-id> <category>private</category><body package="PackageCategories" selector="baseMessage">baseMessage	^'model references non-loaded '</body></methods><methods><class-id>Store.UnloadedObjectError class</class-id> <category>instance creation</category><body package="PackageCategories" selector="class:">class: aClassName	^self new 		messageText: ((#nonLoadedClass1s &lt;&lt; #packages &gt;&gt; 'model references non-loaded class &lt;1s&gt;')			expandMacrosWith: aClassName).</body><body package="PackageCategories" selector="nameSpace:">nameSpace: aName	^self new 		messageText: ((#nonLoadedNameSpace2s &lt;&lt; #packages &gt;&gt; 'model references non-loaded name space &lt;1s&gt;')			expandMacrosWith: aName)</body></methods><methods><class-id>Store.UnloadedObjectError class</class-id> <category>testing</category><body package="PackageCategories" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Store.DefNameSpaceModel</class-id> <category>testing</category><body package="PackageCategories" selector="hasDefinition">hasDefinition	^true</body><body package="PackageCategories" selector="isEmpty">isEmpty	"Is this class model holding onto nothing?"	"We have a definition so we cannot be."	^false</body><body package="PackageCategories" selector="isExtension">isExtension	^false</body><body package="PackageCategories" selector="isForNameSpace">isForNameSpace	^true</body><body package="PackageCategories" selector="isNameSpaceModel">isNameSpaceModel	^true</body></methods><methods><class-id>Store.DefNameSpaceModel</class-id> <category>private</category><body package="PackageCategories" selector="systemDataKeys">systemDataKeys	^self actual dataKeys</body></methods><methods><class-id>Store.DefNameSpaceModel</class-id> <category>data accessing</category><body package="PackageCategories" selector="addDataKey:">addDataKey: aDataKey	"It's not our problem to track data."	"Well.... it is under a very special circumstance. 	When a parcel is loading and my package overrode this class, some of my subdefs 	were put into the original classes' package and we have to reclaim them."	| pkg owner |	owner :=  self actual.	( pkg := Registry containingPackageForDataKey: aDataKey symbol: owner absoluteSymbol ) = self package		ifTrue: [ ^nil ].		"ok, its already ours"	pkg == nil		ifTrue: [ ^nil ].	pkg relinquishDataKey: aDataKey owner: owner.</body><body package="PackageCategories" selector="dataKeys">dataKeys	^self systemDataKeys select: 		[ :selector | self quickIncludesDataKey: selector ]</body><body package="PackageCategories" selector="dataKeysDo:">dataKeysDo: aBlock	self dataKeys do: aBlock</body><body package="PackageCategories" selector="datumDescriptorForDataKey:">datumDescriptorForDataKey: dataKey	 	^DatumDescriptor fromDataKey: dataKey nameSpaceName: self absoluteName.</body><body package="PackageCategories" selector="datumDescriptors">datumDescriptors		| nsname |	nsname := self absoluteName.	^self dataKeys asSortedCollection asOrderedCollection collect: 		[ :dataKey | 		DatumDescriptor fromDataKey: dataKey nameSpaceName: nsname		]</body><body package="PackageCategories" selector="includesDataKey:">includesDataKey: dataKey	^[ ( ( Registry quickContainingPackageForDataKey: dataKey		symbol: self fullName asSymbol ) == package ) 	and: [ self actual includesDataKey: dataKey ]	] on: UnloadedObjectError do: 		[: exp | exp return: false ].</body><body package="PackageCategories" selector="nameSpaceAndDataKeyDo:">nameSpaceAndDataKeyDo: aBlock 	"For each pair of the namespace and its datakeys, 	evaluate aBlock."	| actual |	actual := self nameSpace.	self dataKeys do: 		[ :dataKey | aBlock value: actual value: dataKey].</body><body package="PackageCategories" selector="nameSpaceNameAndDataKeyDo:">nameSpaceNameAndDataKeyDo: aBlock 	"For each pair of the namespace and its selectors and the meta class and its selectors	evaluate aBlock."	| nsName |	nsName := self fullName.	self dataKeys do: 		[ :dataKey | aBlock value: nsName value: dataKey ].</body><body package="PackageCategories" selector="ownerDataKeyPairs">ownerDataKeyPairs	|  pairs |	pairs := OrderedCollection new.	self nameSpaceAndDataKeyDo: 		[ :ns :dataKey |			pairs add: ( Array with: ns with: dataKey )		].	^pairs</body><body package="PackageCategories" selector="protocols">protocols	^( self datumDescriptors collect: 		[ :d | d protocol ] 	 ) asSet asOrderedCollection.</body><body package="PackageCategories" selector="quickIncludesDataKey:">quickIncludesDataKey: dataKey	"For when you know dataKey is loaded"	^( Registry quickContainingPackageForDataKey: dataKey symbol: self fullName asSymbol	) 			== package</body><body package="PackageCategories" selector="removeDataKey:">removeDataKey: dataKey	"It isn't our problem to track this stuff"	"well... maybe if we were overridden"</body></methods><methods><class-id>Store.DefNameSpaceModel</class-id> <category>accessing</category><body package="PackageCategories" selector="absoluteName">absoluteName	^BindingReference fullNameFrom: self environmentString name: name</body><body package="PackageCategories" selector="absoluteSymbol">absoluteSymbol	^self absoluteName asSymbol</body><body package="PackageCategories" selector="actual">actual	^self nameSpace</body><body package="PackageCategories" selector="asDescription">asDescription	^NameSpaceDescriptor fromModel: self</body><body package="PackageCategories" selector="environment">environment	^self environmentString asStrictReference valueOrDo: [ nil ]</body><body package="PackageCategories" selector="environmentString">environmentString	^environmentString</body><body package="PackageCategories" selector="environmentString:">environmentString: aString	environmentString := aString</body><body package="PackageCategories" selector="fileOutObjectType">fileOutObjectType	"Answer a symbol that represents the type of the receiver."	^#namespace</body><body package="PackageCategories" selector="fullName">fullName	^BindingReference fullNameFrom: self environmentString name: name</body><body package="PackageCategories" selector="fullName:">fullName: aString	"Extract environment and name."	| qual |	qual := aString asStrictReference.	environmentString := qual finalNameSpaceName.	name := qual simpleName.</body><body package="PackageCategories" selector="fullSymbol:">fullSymbol: aSymbol	self fullName: aSymbol asString</body><body package="PackageCategories" selector="name">name	^name</body><body package="PackageCategories" selector="name:">name: aString	^name</body><body package="PackageCategories" selector="nameSpace">nameSpace	^self fullName asStrictReference valueOrDo: 		[ ( UnloadedObjectError nameSpace: self fullName ) raiseSignal. nil.]</body><body package="PackageCategories" selector="package">package	^package</body><body package="PackageCategories" selector="package:">package: ourPackage	package := ourPackage</body></methods><methods><class-id>Store.DefNameSpaceModel</class-id> <category>printing</category><body package="PackageCategories" selector="displayString">displayString	^self name</body><body package="PackageCategories" selector="printOn:">printOn: aStream	aStream nextPutAll: 'NSM:'.	aStream nextPutAll: self fullName.	aStream nextPutAll: ':'.	aStream nextPutAll: self package name.</body></methods><methods><class-id>Store.DefNameSpaceModel</class-id> <category>initialize-release</category><body package="PackageCategories" selector="cloneFrom:">cloneFrom: aNameSpaceModel	"Copy all our data from another namespace model"	aNameSpaceModel dataKeysDo:		[ :key | self addDataKey: key ].</body></methods><methods><class-id>Store.DefNameSpaceModel</class-id> <category>browser support</category><body package="PackageCategories" selector="binding">binding	^self"		| ref |	^( ref := self fullName asQualifiedReference ) isDefined 		ifTrue: [ ref binding ]		ifFalse: [ nil ]."</body><body package="PackageCategories" selector="containingPackages">containingPackages	"Answer all the packges that contain the definition for the receiver, 	including overriden."	^Registry allContainingPackagesForClassOrNameSpace: self actual</body><body package="PackageCategories" selector="value">value	^self fullName asStrictReference valueOrDo: [ nil ].</body><body package="PackageCategories" selector="valueOrDo:">valueOrDo: aBlock	^self fullName asStrictReference valueOrDo: aBlock.</body></methods><methods><class-id>Store.DefNameSpaceModel</class-id> <category>private-unloading</category><body package="PackageCategories" selector="unloadAllDataKeys">unloadAllDataKeys	"Before unloading the receiver- 	Unload all the receiver's data keys from the system."	| actual |	actual := self valueOrDo: [ ^self ].	self dataKeys do:		[ :key | 	Override unloadDataKey: key in: actual from: package ].</body></methods><methods><class-id>Store.DefNameSpaceModel</class-id> <category>consistency checking</category><body package="PackageCategories" selector="checkConsistencyOn:">checkConsistencyOn: aStream 	| pmodel pkg ns |	pmodel := self package modelAtSymbol: self absoluteSymbol ifAbsent: [ nil ].	pmodel == nil		ifTrue: 			[ aStream nextPutAll: ((#x1sNotInPackage &lt;&lt; #packages &gt;&gt; 'namespace model &lt;1s&gt;" not in package "&lt;2p&gt;"  it references. ')				expandMacrosWith: self absoluteSymbol				with: self package).			^self.			].	pmodel == self		ifFalse: 			[ aStream nextPutAll: ((#namespaceModelDifferentThanInPackage &lt;&lt; #packages &gt;&gt; 'namespace model &lt;1s&gt;" is not the same as in package "&lt;2p&gt;"  it references. ')				expandMacrosWith: self absoluteSymbol				with: self package).			^self			].	( pkg := Registry packageNamed: self package name ) == nil		ifTrue: 			[ aStream nextPutAll: ((#x1sRefersToPackageNotLoaded &lt;&lt; #packages &gt;&gt; 'namespace model &lt;1s&gt;" refers to package "&lt;2p&gt;" which is not loaded')				expandMacrosWith: self absoluteSymbol				with: self package).			^self.			].	pkg == self package		ifFalse: 			[ aStream nextPutAll: ((#x1sRefersToPackageDifferentThenLoaded &lt;&lt; #packages &gt;&gt; 'namespace model &lt;1s&gt;" refers to package "&lt;2p&gt;" which is different from the loaded package')				expandMacrosWith: self absoluteSymbol				with: self package).			^self.			].	( ns := self nameSpace ) == nil		ifTrue: 			[ aStream nextPutAll: ((#x1sInPackage &lt;&lt; #packages &gt;&gt; 'namespace model &lt;1s&gt;" in package "&lt;2p&gt;" refers to non-loaded namespace')				expandMacrosWith: self absoluteSymbol				with: self package).			^self.			].	self isExtension 		ifTrue: 			[ self dataKeys do:				[ :key |				( ns includesDataKey:key )					ifFalse: [ aStream nextPutAll: (#namespace &lt;&lt; #packages &gt;&gt; 'namespace "&lt;1p&gt;" in package "&lt;2p&gt;" refers to non-loaded datakey "&lt;3s&gt;"'								expandMacrosWith: ns								with: self package								with: key).							aStream cr						 ]				]			].</body></methods><methods><class-id>Store.DefNameSpaceModel class</class-id> <category>instance creation</category><body package="PackageCategories" selector="package:fullSymbol:">package: ourPackage fullSymbol: aSymbol	^self new package: ourPackage; fullSymbol: aSymbol.</body></methods><methods><class-id>Store.PundleModel</class-id> <category>printing</category><body package="PackageCategories" selector="itemString">itemString	^self name , self versionString</body><body package="PackageCategories" selector="printStringCache">printStringCache	"Answer the db printString for the current connection versioin, nil if none."	| info |	^( info := self databaseInfomation ) == nil		ifFalse: [ info versionString ].</body><body package="PackageCategories" selector="printStringCache:">printStringCache: aString	self databaseInfomationOrCreate		versionString: aString</body><body package="PackageCategories" selector="textForItem">textForItem	"Descriptive text for the browser text window."	| stream dbId |	stream := TextStream on: ( String new: 80 ).	stream nextPutAll: self name; cr.	#{DbRegistry} ifDefinedDo: 		[ :reg | dbId := reg dbIdentifier.		self databaseInformationsDo:			[ :info | | id | 			id := info dbIdentifier.			id = dbId ifTrue: [ stream emphasis: #bold ].			id == nil ifTrue: [ id := '' ]. 			stream tab; nextPutAll: 				( id, info versionString,						( ( self hasBeenModifiedIn: id )							ifTrue: [ '*' ]							ifFalse: [ '=' ]						)				).			stream emphasis: #normal.			stream cr.			].		].	^stream contents</body><body package="PackageCategories" selector="traceVersion">traceVersion 		"Answer a string describing a version of my trace 	pundle appropiate for version	comparisons."   		| info |	^self shouldTrackChanges		ifTrue:	 		[ ( info := self databaseInfomation ) == nil		 		ifTrue: [ '' ]		 		ifFalse: [ info traceVersion ]			]		ifFalse: [ self version ].</body><body package="PackageCategories" selector="versionString">versionString	self shouldTrackChanges		ifFalse: [ ^'' ].	^self traceVersionString , 		( self hasBeenModified			ifTrue: [ '*' ]			ifFalse: [ '=' ]		)</body></methods><methods><class-id>Store.PundleModel</class-id> <category>public-change set access</category><body package="PackageCategories" selector="markNotModified">markNotModified	self shouldTrackChanges 		ifTrue: [ self emptyChangeSet ]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>testing</category><body package="PackageCategories" selector="hasBeenModifiedSomewhere">hasBeenModifiedSomewhere	"Answer true if the receiver has been modified within any database."	| traceableInfos |	^self isImageDatabaseEnabled		ifFalse: [self hasBeenModified]		ifTrue:			[traceableInfos := self databaseInformations select: [:each | each hasTrace].			traceableInfos isEmpty				ifTrue: [self hasBeenModified]				ifFalse: [self hasBeenModified or: [(traceableInfos anySatisfy: [:each | each isChangeSetEmpty]) not]]]</body><body package="PackageCategories" selector="isImageDatabaseEnabled">isImageDatabaseEnabled	^#{Store.DbRegistry} isDefined</body><body package="PackageCategories" selector="shouldTrackChanges">shouldTrackChanges	^#{Store.DbRegistry} isDefined</body></methods><methods><class-id>Store.PundleModel</class-id> <category>initialization</category><body package="PackageCategories" selector="initialize">initialize	super initialize.	dbInfo := IdentityDictionary new: 2.</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="PackageCategories" selector="databaseInformationClass">databaseInformationClass	^DatabaseConnectionInformation</body><body package="PackageCategories" selector="dbIdentifier">dbIdentifier	"Answer the db identifier for the current connection, nil if none."	| info |	^( info := self databaseInfomation ) == nil		ifFalse: [ info dbIdentifier ].</body><body package="PackageCategories" selector="dbIdentifier:">dbIdentifier: dbIdentifier 	"Set the database identifier."	self databaseInfomationForOrCreate: dbIdentifier</body><body package="PackageCategories" selector="dbTrace">dbTrace	"Answer the db parent id for the current connection, nil if none."	| info |	^( info := self databaseInfomation ) == nil		ifFalse: [ info dbTrace ].</body><body package="PackageCategories" selector="getImagePundle">getImagePundle	^self</body><body package="PackageCategories" selector="markReadOnly">markReadOnly	readonly := true.</body><body package="PackageCategories" selector="name:">name: aString	super name: aString asString.</body><body package="PackageCategories" selector="parcelName">parcelName	"Answer the parcel name, or receiver's name if absent."		^self propertyAt: #parcelName ifAbsent: [ self name ].</body><body package="PackageCategories" selector="parcelName:">parcelName: aString	"Answer the parcel name, or receiver's name if absent."		^self propertyAt: #parcelName put: aString</body><body package="PackageCategories" selector="pundleListIcon">pundleListIcon	^ListIconLibrary visualFor: self pundleListIconKey</body><body package="PackageCategories" selector="raiseMismatchedSignal">raiseMismatchedSignal	self class mismatchedDatabaseSignal signalWith: self.</body><body package="PackageCategories" selector="relatedParcel">relatedParcel	"Answer the receiver's coresponding parcel, nil if none"	^Parcel parcelNamed: self parcelName</body><body package="PackageCategories" selector="renameTo:">renameTo: aString	"Rename the receiver. If it has been published, this will disconnect  it from previous versions."	( self dbTrace == nil or: [ self dbTrace == 0 ] )		ifFalse: 			[ ( Dialog confirm: 				( '&lt;1s&gt; has been published. Renaming will lose version history&lt;n&gt;unless your image administrator renames it in the database as well.&lt;ntttt&gt;Continue?' expandMacrosWith: name )			 ) ifFalse: [ ^self ]			].	Registry renamePundle: self to: aString.</body><body package="PackageCategories" selector="silentProperties:">silentProperties: aDictionary	( properties contentsEquals: aDictionary ) 		ifTrue: [ ^self ].	properties := IdentityDictionary new.	self startLoad.	[ self copyPropertiesFrom: aDictionary ]		ensure: [ self endLoad ].</body><body package="PackageCategories" selector="unmarkReadOnly">unmarkReadOnly	readonly := false.</body><body package="PackageCategories" selector="version">version	^(#image &lt;&lt; #packages &gt;&gt; 'image') asString</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private</category><body package="PackageCategories" selector="asDescription">asDescription	^( self descriptionClass new )		componentName: self name;		yourself.</body><body package="PackageCategories" selector="cleanse">cleanse	"Cleanse the component. Remove any class or method definitions	 that are no longer in the system, including the postLoadMethod."</body><body package="PackageCategories" selector="selectIconKeyDefault:modified:noDBdefault:modified:">selectIconKeyDefault: defaultKey modified: modifiedKey noDBdefault: ndDefaultKey modified: ndModified	^(self isImageDatabaseEnabled not or: [self isInCurrentDatabase])		ifTrue:			[self hasBeenModifiedSomewhere				ifTrue: [modifiedKey]				ifFalse: [defaultKey]]		ifFalse:			[self hasBeenModifiedSomewhere				ifTrue: [ndModified]				ifFalse: [ndDefaultKey]]</body><body package="PackageCategories" selector="sortCategories:with:">sortCategories: categories with: orderedCategories	"Answer a collection that is categories sorted according to the image."	| list |	list := OrderedCollection new: categories size.	orderedCategories do:		[ :cat | 			( categories includes: cat )			ifTrue: [ list add: cat ]		].	^list.</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-db management</category><body package="PackageCategories" selector="addOtherChange:">addOtherChange: mark	self updateAfterDo: 		[ self changeSetsDo: [ :cs | cs  addOtherChange: mark ] ]</body><body package="PackageCategories" selector="addPropertyChange:">addPropertyChange: mark	self updateAfterDo: 		[ self changeSetsDo: [ :cs | cs  addPropertyChange: mark ] ]</body><body package="PackageCategories" selector="changeSetsDo:">changeSetsDo: aBlock	"Evaluate aBlock for all of the receiver's changeSets 	(ie. for all database connections). 		If there are no changesets, create an unnamed one"	self shouldTrackChanges		ifTrue:			[ dbInfo isEmpty				ifTrue: [ self databaseInfomationForOrCreate: self noDbSymbol ].			dbInfo values do: 				[ :info | aBlock value: info changeSet ].			].</body><body package="PackageCategories" selector="databaseInfomation">databaseInfomation	"Answer a  DatabaseInformationConnection for the receiver 	and the current/last database"	| dbid |	( dbid := #{DbRegistry} ifDefinedDo: [ :reg | reg dbIdentifier ] ) == nil		ifTrue: [ dbid := self noDbSymbol ].	^dbInfo at: dbid ifAbsent: nil</body><body package="PackageCategories" selector="databaseInfomationForOrCreate:">databaseInfomationForOrCreate: aDatabaseId	"Answer a  DatabaseInformationConnection for the receiver 	and the specified database"	| dbid |	dbid := aDatabaseId == nil		ifTrue: [ self noDbSymbol ]		ifFalse: [ aDatabaseId asSymbol ].	^dbInfo at: dbid ifAbsentPut: 		[ ( self databaseInformationClass dbIdentifier: dbid )				pundle: self ;				yourself		].</body><body package="PackageCategories" selector="databaseInfomationOrCreate">databaseInfomationOrCreate	"Answer a DatabaseInformationConnection for the receiver 	and the current/last database or create a new one and set it up."	| dbid |	( dbid := #{DbRegistry} ifDefinedDo: [ :reg | reg  dbIdentifier ] ) == nil		ifTrue: [ dbid := self noDbSymbol ].	^dbInfo at: dbid ifAbsentPut: 		[ ( self databaseInformationClass dbIdentifier: dbid )				pundle: self;				yourself		].</body><body package="PackageCategories" selector="databaseInformationFor:">databaseInformationFor: aDatabaseId	"Answer a DatabaseInformationConnection for the receiver 	and the specified database"	^dbInfo at: aDatabaseId ifAbsent: nil</body><body package="PackageCategories" selector="databaseInformations">databaseInformations	"Private- Answer the dictionary of databaseConnectionInformations."	^dbInfo</body><body package="PackageCategories" selector="databaseInformationsDo:">databaseInformationsDo: aBlock	"Evaluate aBlock for all all database connections."	dbInfo == nil		ifFalse: [ dbInfo do: aBlock ].</body><body package="PackageCategories" selector="noDbSymbol">noDbSymbol	^'' asSymbol</body><body package="PackageCategories" selector="updateAfterDo:">updateAfterDo: aBlock 	| changeSetState |	changeSetState := self hasBeenModified.	aBlock value.	changeSetState = self hasBeenModified 		ifFalse: [ Registry modificationChangedForPundle: self ]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>browser support</category><body package="PackageCategories" selector="value">value	"Implemented by any subclass wanting to be displayed in a browser."	^self</body></methods><methods><class-id>Store.PundleModel</class-id> <category>parcel support</category><body package="PackageCategories" selector="asParcel">asParcel	"Convert the receiver to a parcel." 	^self asParcel: self name.</body><body package="PackageCategories" selector="asParcel:">asParcel: string 	"Convert the receiver to a parcel named string.	Does not remove anything from existing parcels."	| parcel |	( parcel := Parcel parcelNamed: string ) == nil		ifTrue: [ parcel := Parcel createParcelNamed: string ].	self copyContentsToParcel: parcel.	parcel properties: self propertiesForSave.		^parcel.</body><body package="PackageCategories" selector="cleanseRelatedParcel">cleanseRelatedParcel	"If there is a related parcel to this pundle, cleanse it. This helps keep the parcel void of any obsolete 	definitions. If the parcel is empty the side-effect (yuck) is to ask the user if they want to destroy it."	| parcel |	( parcel := self relatedParcel ) == nil 		ifTrue: [ ^self ].	parcel cleanse.	parcel isEmpty		ifTrue: [ Parcel destroyParcelNamed: parcel name ]</body><body package="PackageCategories" selector="copyPropertiesFrom:">copyPropertiesFrom:  aPropertyDictionary	"Move the relevant properties to the receiver. Uses accessors where  possible."	"NOTE: maybe should to get property list from class"	self restoreLinksFrom: aPropertyDictionary.  "special case stored db links."	super copyPropertiesFrom: aPropertyDictionary</body><body package="PackageCategories" selector="notInParcel:">notInParcel: aParcel 	"Answer a string listing things contained in the receiver but not in a Parcel."	| stream |	stream := ( String new: 100 ) writeStream.	stream nextPutAll: (#ClassesC &lt;&lt; #packages &gt;&gt; 'Classes:') asString; cr.	self definedClassesNotInParcel: aParcel on: stream.	stream cr; nextPutAll: (#MethodsC &lt;&lt; #packages &gt;&gt; 'Methods:') asString; cr.	self methodsNotInParcel: aParcel on: stream.	stream cr; nextPutAll: (#NameSpacesC &lt;&lt; #packages &gt;&gt; 'NameSpaces:') asString; cr.	self definedNameSpacesNotInParcel: aParcel on: stream.	stream cr; nextPutAll: (#DataC &lt;&lt; #packages &gt;&gt; 'Data:') asString; cr.	self dataNotInParcel: aParcel on: stream.	^stream contents.</body><body package="PackageCategories" selector="putStoredPropertiesIn:">putStoredPropertiesIn: aDictionary 	"Put any PundleModel-specific properties into aDictionary for Parcel publishing."	aDictionary at: #name put: self parcelName.</body><body package="PackageCategories" selector="resetUninstalledStateFrom:">resetUninstalledStateFrom: aParcel	"A parcel has changed in some way, recheck and set the uninstalled properties	and the read-only flag"	aParcel hasUninstalledCode		ifTrue: [ self markReadOnly ]		ifFalse: [ self unmarkReadOnly ].	"These serve no purpose in Store"	self propertyAt: 	#uninstalledClasses put: nil.			self propertyAt: 	#uninstalledMethods put: nil.	self propertyAt: 	#uninstalledBindings put: nil.</body><body package="PackageCategories" selector="restoreLinksFrom:">restoreLinksFrom: propertyDictionary	"Called when restoring database links after parcel load."	| dbid |	#{Store.DbRegisry} isDefined		ifTrue:			[ 			dbid := propertyDictionary at: #dbIdentifier ifAbsent: [ propertyDictionary at: #databaseId ifAbsent: nil ].			dbid == nil				ifFalse:					[ ( self databaseInfomationForOrCreate: dbid )						dbTrace: ( propertyDictionary at: #dbTrace ifAbsent: nil );						versionString:  ( propertyDictionary at: #printStringCache ifAbsent: nil );						emptyChangeSet.					dbInfo removeKey: self noDbSymbol ifAbsent: nil. 	"now we be connected"					].				].	"Remove the properties, which don't belong here any more so that	Parcels are not inadvertantly saved with stale package information."	propertyDictionary 		removeKey: #databaseId ifAbsent: nil;		removeKey: #dbIdentifier ifAbsent: nil;		removeKey: #dbTrace ifAbsent: nil;		removeKey: #printStringCache ifAbsent: nil.</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-file out</category><body package="PackageCategories" selector="fileOut">fileOut	"Ask for the file name and file out the content of the pundle into it."	| fileName stream |	fileName := Dialog 		requestNewFileName: (#FileOutOnC &lt;&lt; #packages &gt;&gt; 'File out on:')		default: self name , '.st'.	fileName isEmpty ifTrue: [^nil].	stream := SourceCodeStream write: fileName.		[Notice 		showNotice: ((#FilingOut1s &lt;&lt; #packages &gt;&gt; 'Filing out &lt;1s&gt;')			expandMacrosWith: name)		complete: self itemCount		while: 			[stream timeStamp.			stream deferInitializations.			self fileOutOn: stream.			stream finishInitializations]		title: (#Store &lt;&lt; #packages &gt;&gt; 'Store')] 				ensure: [stream close]</body><body package="PackageCategories" selector="fileOutChangedPropertiesForDb:on:">fileOutChangedPropertiesForDb: dbid on: aFileManager	"File out only changed, saveable properties to aFileManager."	| changed props cs |	( ( cs := self changeSetFor: dbid ) == nil or: [ cs propertiesOrNil == nil ] )		ifTrue: [ ^self ].	props := self propertiesForFileOut.	changed := IdentityDictionary new.	cs properties do:		[ :symbol | 		( props includesKey: symbol ) 			ifTrue: [ changed at: symbol put: ( props at: symbol ) ]		].	changed size == 0 ifTrue: [ ^self ].	self fileOutProperties: changed on: aFileManager</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-load/unload</category><body package="PackageCategories" selector="assertNotLoaded:ifFail:">assertNotLoaded: nameString ifFail: aBlock 	"Check if the receiver is already loaded and if so, raise the parcelAlreadyLoadedSignal.	 If the handler returns false, indicating the load should be aborted, and then raise the	 abortedActionSignal and return its value through aBlock."	self needsMoreWork</body><body package="PackageCategories" selector="assertSelfIsSameComponentAs:ifFail:">assertSelfIsSameComponentAs: parcelName ifFail: aBlock	"For updating from binary (i.e. parcel)"	parcelName ~= self parcelName 		ifTrue:			[ ^aBlock value: 				( self class abortedActionSignal raiseRequestWith:					( Array with: self with: self name						with: #updateWrongComponent &lt;&lt; #dialogs &gt;&gt; 'Attempt to update different component')				errorString: #loadAborted &lt;&lt; #dialogs &gt;&gt; 'Parcel load aborted')			]</body><body package="PackageCategories" selector="prerequisiteProviderFrom:">prerequisiteProviderFrom: aCodeReaderOrNil	^Registry</body><body package="PackageCategories" selector="recordPackageContentsFrom:">recordPackageContentsFrom: aCodeReader	"Override to suppress unnecessary duplicate add warnings."	[super recordPackageContentsFrom: aCodeReader]  		on: Store.StoreWarning 		do: [ :ex | ex resume ]</body><body package="PackageCategories" selector="unloadLogged:">unloadLogged: log	"compatiblity"	( self unloadFromImage and: [ #{Store.DbRegistry} isDefined ] )		ifTrue:			[ ChangeSet unloadComponent: self.			SourceFileManager default unloadComponent: self.			].</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>class initialization</category><body package="PackageCategories" selector="initialize">initialize	"self initialize"	EmergencyUnloadSignal := Object errorSignal newSignal 		notifierString: (#CannotLoadAComponent &lt;&lt; #packages &gt;&gt; 'Cannot load a component');		nameClass: self message: #emergencyUnloadSignal.</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>utility</category><body package="PackageCategories" selector="selectDatabaseFor:">selectDatabaseFor: pundles	"Display a list of existing db names and answer the user's choice."	| dbs |	( dbs := self allDatabasesFor: pundles ) size == 0		ifTrue: [ ^nil ].	dbs size == 1		ifTrue: [ ^dbs first ].	^Dialog		choose: (#ForWhichDatabase &lt;&lt; #packages &gt;&gt; 'For which database?')		fromList: dbs		values: dbs		lines: dbs size + 1		cancel: nil</body><body package="PackageCategories" selector="selectDatabasesFor:prompt:">selectDatabasesFor: pundles prompt: aString	"Display a list of existing db names and answer the user's choices."	"self selectDatabasesFor: ( Store.Registry bundleNamed: 'StoreBase' ) leafItems prompt: 'which?'"	| dbs |	( dbs := self allDatabasesFor: pundles ) size == 0		ifTrue: [ Dialog warn: (#NothingToSelect &lt;&lt; #packages &gt;&gt; 'Nothing to select'). ^nil ].	dbs size == 1		ifTrue: [ ^dbs ].	^SimpleDialog new		chooseMultiple: aString		fromList: dbs values: dbs		buttons: #() values: #()		lines: dbs size + 1		cancel: [ nil ]		for: Dialog defaultParentWindow</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>instance creation</category><body package="PackageCategories" selector="illegalCharacters">illegalCharacters	"Answer a list of characters that should not be in a package name because of possibly illiegal 	directory names that can be constructed from the packagename."	"Using this as the most restrictive list of chars"	^PCFilename badEightDotThreeCharacterList copyWithout: Character space</body><body package="PackageCategories" selector="named:">named: aString 	"The ONLY legitimate method for creating new pundles."	| newPundle |	newPundle := super named: aString.	Registry notNil 		ifTrue: [ Registry privateRegisterPundle: newPundle ].	^newPundle</body><body package="PackageCategories" selector="validateName:">validateName: proposedComponentName 	"Answer true if proposedComponentName does not contain any illegal characters that might be used	as a directory name."	| badChars |	badChars := self illegalCharacters.	^(proposedComponentName contains: [:char | badChars includes: char]) not</body></methods><methods><class-id>Store.PackageModel</class-id> <category>testing</category><body package="PackageCategories" selector="definesClass:">definesClass: aClass 	^(self classModelAtClass: aClass ifAbsent: [^false]) hasDefinition</body><body package="PackageCategories" selector="extendsClass:">extendsClass: aClass 	^(self classModelAtClass: aClass ifAbsent: [ ^false ] ) isExtension</body><body package="PackageCategories" selector="hasBeenModified">hasBeenModified	"Answer true if the receiver has been 	modified or has no dbTrace."	^self shouldTrackChanges and:		[ self hasItselfBeenModified or: 			[ ( self dbTraceFor: self dbIdentifier ) == nil ]		].</body><body package="PackageCategories" selector="hasDataKey:in:">hasDataKey: aSymbol in: aClassOrNameSpace	"Answer true if the receiver owns the definition for aClassOrNameSpace.aSymbol, 	even if it has been overridden."	^( self includesDataKey: aSymbol owner: aClassOrNameSpace )  or:		[ Override isOverriddenStatic: aSymbol in: aClassOrNameSpace  in: self ]</body><body package="PackageCategories" selector="hasDefinitionFor:">hasDefinitionFor: aClassOrNameSpace	"Answer true if the receiver owns the definition for aClassOrNameSpace, 	even if it has been overridden."	^( self includesSymbol: aClassOrNameSpace absoluteSymbol )  or:		[ Override isOverriddenClassOrNameSpace: aClassOrNameSpace  in: self ]</body><body package="PackageCategories" selector="hasExtensions">hasExtensions	"Answer true if the receiver extends a class/namespace not in the package."		models == nil ifTrue: [ ^false ].	^( models detect: [ :model | model hasDefinition not ] ifNone: [ nil ] ) 			notNil</body><body package="PackageCategories" selector="hasSelector:in:">hasSelector: aSelector in: aClass	"Answer true if the receiver owns the definition for aClass&gt;&gt;aSelector, 	even if it has been overridden."	^( self includesSelector: aSelector class: aClass )  or:		[ Override isOverriddenSelector: aSelector class: aClass  in: self ]</body><body package="PackageCategories" selector="hasUninstalledCode">hasUninstalledCode	"Borrowed from parcel. Currently only valid if there was a binary load."	^( ( properties at: #uninstalledClasses ifAbsent: nil ) size ~= 0		or: [ ( properties at: #uninstalledMethods ifAbsent: nil ) size ~= 0 ] )		or: [ ( properties at: #uninstalledBindings ifAbsent: nil ) size ~= 0 ]</body><body package="PackageCategories" selector="includesClass:">includesClass: aClass 	^(self classModelAtClass: aClass ifAbsent: [^false]) hasDefinition</body><body package="PackageCategories" selector="includesClassNamed:">includesClassNamed: aClassName 	^(self classModelAtClassName: aClassName ifAbsent: [^false]) hasDefinition</body><body package="PackageCategories" selector="includesClassSymbol:">includesClassSymbol: aClassSymbol 	^(self classModelAtClassSymbol: aClassSymbol ifAbsent: [^false]) hasDefinition</body><body package="PackageCategories" selector="includesDataKey:nameSpace:">includesDataKey: dataKey nameSpace: namespace	^( self modelAtSymbol: namespace absoluteSymbol ifAbsent: [ ^false ] ) 		includesDataKey: dataKey</body><body package="PackageCategories" selector="includesDataKey:nameSpaceName:">includesDataKey: dataKey nameSpaceName: aNameSpaceName	^( self modelAtName: aNameSpaceName ifAbsent: [ ^false ] ) 		includesDataKey: dataKey</body><body package="PackageCategories" selector="includesDataKey:nameSpaceSymbol:">includesDataKey: dataKey nameSpaceSymbol: nameSpaceSymbol 	^(self modelAtSymbol: nameSpaceSymbol ifAbsent: [ ^false ] )		includesDataKey: dataKey</body><body package="PackageCategories" selector="includesDataKey:owner:">includesDataKey: dataKey owner: owner	^self includesDataKey: dataKey ownerSymbol: owner absoluteSymbol</body><body package="PackageCategories" selector="includesDataKey:ownerName:">includesDataKey: dataKey ownerName: aName	^( self modelAtName: aName ifAbsent: [ ^false ] ) 		includesDataKey: dataKey</body><body package="PackageCategories" selector="includesDataKey:ownerSymbol:">includesDataKey: dataKey ownerSymbol: symbol	^( self modelAtSymbol: symbol ifAbsent: [ ^false ] ) 		includesDataKey: dataKey</body><body package="PackageCategories" selector="includesDatum:">includesDatum: aDataDescriptor	"Answer true if the receiver contains a definition of aDataDescriptor. 	Since this is for package comparisons, include overrides."		^( self 		includesDataKey: aDataDescriptor dataKey 		ownerName: aDataDescriptor absoluteOwnerName	) or: [ Override 			isOverriddenStatic: aDataDescriptor dataKey 			in: aDataDescriptor owner 			in: self 		  ]</body><body package="PackageCategories" selector="includesMethod:">includesMethod: aMethodDescriptor	"Answer true if the receiver contains a definition of aMethodDescriptor. 	Since this is for package comparisons, include overrides."		^( self 		includesSelector: aMethodDescriptor selector 		className: aMethodDescriptor className asClassNameOnly 		meta: aMethodDescriptor isMeta	) or: [ Override 			isOverriddenSelector: aMethodDescriptor selector 			class: aMethodDescriptor implementingClass 			in: self 		  ]</body><body package="PackageCategories" selector="includesNameSpaceNamed:">includesNameSpaceNamed: aName 	^(self modelAtName: aName ifAbsent: [^false] ) hasDefinition</body><body package="PackageCategories" selector="includesSelector:class:">includesSelector: aSelector class: aClass	^(self classModelAtClass: aClass ifAbsent: [^false]) includesSelector: aSelector meta: aClass isMeta</body><body package="PackageCategories" selector="includesSelector:className:meta:">includesSelector: aSelector className: aClassName meta: isMeta	^( self classModelAtClassName: aClassName ifAbsent: [ ^false ] ) 		includesSelector: aSelector meta: isMeta</body><body package="PackageCategories" selector="includesSelector:classSymbol:meta:">includesSelector: aSelector classSymbol: aClassSymbol meta: isMeta 	^(self classModelAtClassSymbol: aClassSymbol ifAbsent: [^false])		includesSelector: aSelector meta: isMeta</body><body package="PackageCategories" selector="includesSymbol:">includesSymbol: aSymbol 	^( self modelAtSymbol: aSymbol ifAbsent: [ ^false ] ) hasDefinition</body><body package="PackageCategories" selector="isEmpty">isEmpty	"Answer true if I do not contain any definitions. This method is used	to distinguish newly created packages from the existing ones."	^models isEmpty</body><body package="PackageCategories" selector="isLeaf">isLeaf	^true</body><body package="PackageCategories" selector="isNullPackage">isNullPackage	^name = Registry nullPackageName</body><body package="PackageCategories" selector="isPackage">isPackage	^true</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-model</category><body package="PackageCategories" selector="addFullSymbol:">addFullSymbol: fullSymbol 	"Add namespace/class."	| model |	model := self modelAtFullSymbol: fullSymbol  hasDefinition: true.	model hasDefinition ifFalse: 		[ self			installModelAtFullSymbol: fullSymbol			hasDefinition: true		]</body><body package="PackageCategories" selector="addModel:">addModel: classOrNameSpaceModel	"Add a classOrNameSpaceModel to the package."	models at: classOrNameSpaceModel absoluteSymbol put: classOrNameSpaceModel.	Registry addModel: classOrNameSpaceModel.</body><body package="PackageCategories" selector="addStatic:to:">addStatic: staticKey to: aClassOrNameSpace	"Add aClassOrNameSpace.staticKey to the receiver."	self addDataKey: staticKey symbol: aClassOrNameSpace absoluteSymbol.</body><body package="PackageCategories" selector="definedModels">definedModels	models == nil ifTrue: [ ^OrderedCollection new ].	^models select: [ :model | model hasDefinition ]</body><body package="PackageCategories" selector="descriptorClassFor:">descriptorClassFor: aSymbol	^aSymbol asStrictReference value isBehavior		ifTrue: [ ClassDescriptor ]		ifFalse:[ NameSpaceDescriptor ]</body><body package="PackageCategories" selector="descriptorClassFor:hasDefinition:">descriptorClassFor: aSymbol hasDefinition: hasDefinition	^aSymbol asStrictReference value isBehavior		ifTrue: [ hasDefinition					ifTrue: [ ClassDescriptor ]					ifFalse: [ ClassExtensionDescriptor ]				]		ifFalse: [ hasDefinition					ifTrue: [ NameSpaceDescriptor ]					ifFalse: [ NameSpaceExtensionDescriptor ]				]</body><body package="PackageCategories" selector="extendedModels">extendedModels	models == nil ifTrue: [ ^OrderedCollection new: 1 ].	^models reject: [ :cm | cm hasDefinition ]</body><body package="PackageCategories" selector="includesDefinitionOf:">includesDefinitionOf: aName 	^( self modelAtSymbol: aName asSymbol ifAbsent: [ ^false ] ) 			hasDefinition</body><body package="PackageCategories" selector="installModelAtFullSymbol:hasDefinition:">installModelAtFullSymbol: aSymbol hasDefinition: hasDefinition 	"This is the ONLY place new models are created."	"Cloning must occur before installation."	| newModel oldModel |	newModel := ( self modelClassFor: aSymbol hasDefinition: hasDefinition )						package: self fullSymbol: aSymbol.	( oldModel := self modelAtSymbol: aSymbol ifAbsent: [ nil ] ) notNil		ifTrue: 			[ newModel cloneFrom: oldModel.			self removeModel: oldModel			].	self addModel: newModel.	^newModel</body><body package="PackageCategories" selector="modelAtFullSymbol:hasDefinition:">modelAtFullSymbol: fullSymbol hasDefinition: hasDefinition 	"Return the namespace/class model for the fully qualified symbol.	If one does not exist create one.  'hasDefinition' is a hint that it is known that 	the namespace/class's definition is in this package."	^models at: fullSymbol ifAbsent:		[ self installModelAtFullSymbol: fullSymbol hasDefinition: hasDefinition ].</body><body package="PackageCategories" selector="modelAtName:ifAbsent:">modelAtName: string ifAbsent: absentBlock	^models at: string asSymbol ifAbsent: absentBlock.</body><body package="PackageCategories" selector="modelAtSymbol:ifAbsent:">modelAtSymbol: symbol ifAbsent: absentBlock	^models at: symbol ifAbsent: absentBlock.</body><body package="PackageCategories" selector="modelClassFor:hasDefinition:">modelClassFor: aSymbol hasDefinition: hasDefinition	^aSymbol asStrictReference value isBehavior		ifTrue: [ hasDefinition					ifTrue: [ DefClassModel ]					ifFalse: [ ExtensionClassModel ]				]		ifFalse: [ hasDefinition					ifTrue: [ DefNameSpaceModel ]					ifFalse: [ ExtensionNameSpaceModel ]				]</body><body package="PackageCategories" selector="modelsDo:">modelsDo: aBlock	models == nil ifTrue: [ ^self ].	models do: aBlock</body><body package="PackageCategories" selector="removeDataKey:ownerSymbol:">removeDataKey: dataKey ownerSymbol: symbol 	"remove the data from package."	( self modelAtSymbol: symbol ifAbsent: [ ^self ] )		removeDataKey: dataKey</body><body package="PackageCategories" selector="removeModel:">removeModel: model	models removeKey: model absoluteSymbol ifAbsent: nil.	Registry removeModel: model named: model absoluteSymbol</body><body package="PackageCategories" selector="removeStatic:from:">removeStatic: staticKey from: aClassOrNameSpace	"Remove aClassOrNameSpace.staticKey from the receiver."	self removeDataKey: staticKey ownerSymbol: aClassOrNameSpace absoluteSymbol</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-class model</category><body package="PackageCategories" selector="addClassModel:">addClassModel: classModel	"Add a classModel to the package."	self addModel: classModel</body><body package="PackageCategories" selector="classModelAtClass:hasDefinition:">classModelAtClass: aClass hasDefinition: hasDefinition 	"Return the class model for the class 'aClass'.	If one does not exist create one.  'hasDefinition' is a	hint that it is known that the class's definition is in	this package."	| class |	class := aClass isMeta				ifTrue: [aClass soleInstance]				ifFalse: [aClass].	^self modelAtFullSymbol: class absoluteSymbol hasDefinition: hasDefinition</body><body package="PackageCategories" selector="classModelAtClass:ifAbsent:">classModelAtClass: aClass ifAbsent: absentBlock	^self classModelAtClassSymbol: aClass instanceBehavior absoluteSymbol ifAbsent: absentBlock.</body><body package="PackageCategories" selector="classModelAtClassName:hasDefinition:">classModelAtClassName: className hasDefinition: hasDefinition 	"Return the class model for the class 'aClass'.	If one does not exist create one.  'hasDefinition' is a	hint that it is known that the class's definition is in	this package."	^self classModelAtClassSymbol: className asClassNameOnly asSymbol hasDefinition: hasDefinition</body><body package="PackageCategories" selector="classModelAtClassName:ifAbsent:">classModelAtClassName: aClassName ifAbsent: absentBlock		| model |	model := self classModelAtClassSymbol: aClassName asClassNameOnly asSymbol 						ifAbsent: absentBlock.	^model isForClass 		ifTrue: [ model ]		ifFalse: [ absentBlock value ]</body><body package="PackageCategories" selector="classModelAtClassNamed:ifAbsent:">classModelAtClassNamed: aClassName ifAbsent: absentBlock	^self classModelAtClassSymbol: aClassName asClassNameOnly asSymbol ifAbsent: absentBlock</body><body package="PackageCategories" selector="classModelAtClassSymbol:hasDefinition:">classModelAtClassSymbol: fullClassSymbol hasDefinition: hasDefinition 	"Return the class model for the class 'aClass'.	If one does not exist create one.  'hasDefinition' is a hint that it is known that 	the class's definition is in this package."	^models at: fullClassSymbol ifAbsent:		[ self installClassModelAtFullClassSymbol: fullClassSymbol hasDefinition: hasDefinition ].</body><body package="PackageCategories" selector="classModelAtClassSymbol:ifAbsent:">classModelAtClassSymbol: classSymbol ifAbsent: absentBlock	^models at: classSymbol ifAbsent: absentBlock.</body><body package="PackageCategories" selector="classModels">classModels	models == nil ifTrue: [ ^OrderedCollection new ].	^models select:  [ :model | model isClassModel ]</body><body package="PackageCategories" selector="classModelsDo:">classModelsDo: aBlock	models == nil ifTrue: [ ^self ].	models do: 		[ :model | model isClassModel ifTrue: [ aBlock value: model ] ]</body><body package="PackageCategories" selector="definedClassModels">definedClassModels	models == nil ifTrue: [ ^OrderedCollection new ].	^self classModels select: [ :cm | cm hasDefinition ]</body><body package="PackageCategories" selector="extendedClassModels">extendedClassModels	models == nil ifTrue: [ ^OrderedCollection new: 1 ].	^self classModels reject: [ :cm | cm hasDefinition ]</body><body package="PackageCategories" selector="extendedNameSpaceModels">extendedNameSpaceModels	models == nil ifTrue: [ ^OrderedCollection new: 1 ].	^self nameSpaceModels reject: [ :model | model hasDefinition ]</body><body package="PackageCategories" selector="installClassModelAtFullClassSymbol:hasDefinition:">installClassModelAtFullClassSymbol: aClassSymbol hasDefinition: hasDefinition 	"This is the ONLY place new class models are created."	"Cloning must occur before installation."	| newCm oldCm |	newCm := (hasDefinition				ifTrue: [DefClassModel]				ifFalse: [ExtensionClassModel])				package: self fullClassSymbol: aClassSymbol.	oldCm := self classModelAtClassSymbol: aClassSymbol ifAbsent: [ nil ].	oldCm notNil		ifTrue: 			[ newCm cloneFrom: oldCm.			self removeClassModel: oldCm			].	self addClassModel: newCm.	^newCm</body><body package="PackageCategories" selector="removeClassModel:">removeClassModel: cm	self removeModel: cm</body><body package="PackageCategories" selector="removeWholeSymbol:">removeWholeSymbol: symbol 	"Remove a definition model and all methods/datakeys defined wherein	This methods removes both class and metaclass."	self removeModel: ( self modelAtSymbol: symbol ifAbsent: [ ^self ] )</body><body package="PackageCategories" selector="renameClassModel:as:">renameClassModel: cm as: newName	self removeClassModel: cm.	cm className: newName.	self addClassModel: cm</body><body package="PackageCategories" selector="renameModel:as:">renameModel: cm as: newName	self removeModel: cm.	cm fullName: newName.	self addModel: cm</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-namespace model</category><body package="PackageCategories" selector="addObject:">addObject: aNameSpace 	"This is for polymorphism with Parcels."	aNameSpace isNameSpace ifFalse: 		[self error: #invalidObjectType &lt;&lt; #dialogs &gt;&gt; 'invalid object type'].	XChangeSet current addNameSpaceDefinition: aNameSpace toPackage: self</body><body package="PackageCategories" selector="dataForNameSpaceName:">dataForNameSpaceName: nameSpaceName 	^( self modelAtSymbol: nameSpaceName ifAbsent: [ ^ OrderedCollection new: 0 ] )			dataKeys asOrderedCollection</body><body package="PackageCategories" selector="definedNameSpaceModels">definedNameSpaceModels	models == nil ifTrue: [ ^OrderedCollection new ].	^self nameSpaceModels select: 	[ :model | model hasDefinition ]</body><body package="PackageCategories" selector="nameSpaceModels">nameSpaceModels	models == nil ifTrue: [ ^OrderedCollection new ].	^models select: [ :model | model isNameSpaceModel ]</body><body package="PackageCategories" selector="nameSpaceModelsDo:">nameSpaceModelsDo: aBlock	models == nil ifTrue: [ ^self ].	models do: 		[ :model | model isNameSpaceModel ifTrue: [ aBlock value: model ] ]</body><body package="PackageCategories" selector="removeDefinitionFullNameSpaceSymbol:">removeDefinitionFullNameSpaceSymbol: symbol 	"Remove a namespace definition."	| model |	model := self modelAtSymbol: symbol ifAbsent: [ ^self ].	model hasDefinition ifTrue: 		[ model := self installModelAtFullSymbol: model absoluteSymbol hasDefinition: false ].	model isEmpty ifTrue: [ self removeModel: model ]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-class model changes</category><body package="PackageCategories" selector="addClass:">addClass: class 	"Add a class to myself."	XChangeSet current addClassDefinition: class toPackage: self</body><body package="PackageCategories" selector="addDataKey:symbol:">addDataKey: dataKey symbol: symbol 	"add the data into package."	( self modelAtFullSymbol: symbol hasDefinition: false )		addDataKey: dataKey</body><body package="PackageCategories" selector="addFullClassSymbol:">addFullClassSymbol: fullClassSymbol 	"Add class."	| cm |	cm := self modelAtFullSymbol: fullClassSymbol  hasDefinition: true.	cm hasDefinition ifFalse: [		self			installClassModelAtFullClassSymbol: cm fullClassSymbol			hasDefinition: true]</body><body package="PackageCategories" selector="addName:in:">addName: dataKey in: anObject 	"For parcel compatibility during binary loading."	(Override isOverriddenStatic: dataKey in: anObject)		ifTrue: [anObject isBehavior				ifTrue: [XChangeSet current						changeDataKey: dataKey						class: anObject						package: self]				ifFalse: [XChangeSet current						changeDataKey: dataKey						nameSpace: anObject						package: self]]		ifFalse: [anObject isBehavior				ifTrue: [XChangeSet current						addDataKey: dataKey						class: anObject						package: self]				ifFalse: [XChangeSet current						addDataKey: dataKey						nameSpace: anObject						package: self]]</body><body package="PackageCategories" selector="addSelector:class:">addSelector: aSymbol class: aBehavior 	"Add the selector aSymbol for aBehavior to myself."	"Used during binary load."	(Override isOverriddenSelector: aSymbol class: aBehavior)		ifTrue: [XChangeSet current				changeSelector: aSymbol				class: aBehavior				toPackage: self]		ifFalse: [XChangeSet current				addSelector: aSymbol				class: aBehavior				toPackage: self]</body><body package="PackageCategories" selector="addSelector:fullClassSymbol:meta:">addSelector: aSymbol fullClassSymbol: fullClassSymbol meta: meta 	"add the method into package."	(self modelAtFullSymbol: fullClassSymbol hasDefinition: false)		addSelector: aSymbol meta: meta</body><body package="PackageCategories" selector="addSelector:toClass:">addSelector: selector toClass: aClass	"Add aClass&gt;&gt;selector to the receiver."	XChangeSet current moveSelector: selector class: aClass toPackage: self</body><body package="PackageCategories" selector="addSelectors:forClass:">addSelectors: aCollection forClass: aBehavior 	"Add all of the selectors for aBehavior in aCollection to myself."	aCollection do: [:selector | self addSelector: selector class: aBehavior]</body><body package="PackageCategories" selector="markModificationAsRemoves:">markModificationAsRemoves: aCollectionOfDefinitions	"Give a collection of modification modify the package change set to contian 	removes of all definitons."	| cs tags |	cs := self changeSet.	tags := aCollectionOfDefinitions collect: [:mod|  mod tag].	tags :=  tags reject: [:tag | tag isCommentTag or: [tag isClassTag and: [tag isMeta]]].	tags do: 		[ :tag | | removeChange |		removeChange := tag asChange.		tag isClassTag | tag isNameSpaceTag			ifTrue: 				[ removeChange removeDefinition.				cs doChange: removeChange				]			ifFalse: 				[ tag isComponentTag					ifTrue: [ removeChange remove ]					ifFalse: 						[ tag isSubdefTag							ifTrue: 								[ removeChange meta: tag isMeta.								removeChange remove.								tag isDataTag 									ifTrue: [ removeChange dataKey: tag dataKey ].								tag isMethodTag 									ifTrue: [ removeChange selector: tag selector ].								cs doSubdefChange: removeChange								]							ifFalse: [ self error: (#WrongModificationType &lt;&lt; #packages &gt;&gt; 'Wrong modification type.') ]					]				]		]</body><body package="PackageCategories" selector="removeDefinitionFullClassSymbol:">removeDefinitionFullClassSymbol: classSymbol 	"Remove a class definition."	| cm |	cm := self classModelAtClassSymbol: classSymbol ifAbsent: 		[ ^Override removeOverridesForClassOrNameSpaceDefinition: classSymbol classNameOnly asQualifiedReference value in: self ].	cm hasDefinition 		ifTrue: [ cm := self installClassModelAtFullClassSymbol: cm fullClassSymbol hasDefinition: false ].	cm isEmpty ifTrue: [ self removeClassModel: cm ].</body><body package="PackageCategories" selector="removeWholeClassSymbol:">removeWholeClassSymbol: classSymbol 	"Remove a class definition and all methods defined in a class. 	This methods removes both class and metaclass."	self removeClassModel: (self classModelAtClassSymbol: classSymbol ifAbsent: [^self])</body></methods><methods><class-id>Store.PackageModel</class-id> <category>printing</category><body package="PackageCategories" selector="classDescription">classDescription	"Answer a string for describing  the class."	^(#Package &lt;&lt; #packages &gt;&gt; 'Package') asString</body><body package="PackageCategories" selector="displayString">displayString	"Answer the string to be displayed for a package in a Package list."	| stream |	stream := WriteStream on: ( String new: 32 ).	stream nextPutAll: self name.	self hasBeenModified ifTrue: [ stream nextPutAll: ' *' ].	self hasExtensions      ifTrue: [ stream nextPutAll: ' +' ].	self hasCodeOverridden ifTrue: [ stream nextPutAll: ' -' ].	^stream contents</body><body package="PackageCategories" selector="printOn:">printOn: aStream		aStream nextPut: $[;		nextPutAll: (name isNil ifTrue: [(#unnamed &lt;&lt; #packages &gt;&gt; '*unnamed*') asString] ifFalse: [name]);		nextPut: $].</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-descriptors</category><body package="PackageCategories" selector="affectedClassNamesMeta:">affectedClassNamesMeta: meta	"Answer a collection of changed  class name symbols."	"Note that this is only called when comparing dbs, so the changeset must have already been validated."	^self isChangeSetEmpty		ifTrue: [OrderedCollection new]		ifFalse: [self changeSet affectedClassNamesMeta: meta]</body><body package="PackageCategories" selector="affectedNameSpaceNames">affectedNameSpaceNames	"Answer a collection of changed  namespace name symbols."	"Note that this is only called when comparing dbs, so the changeset must have already been validated."	^self isChangeSetEmpty		ifTrue: [ OrderedCollection new ]		ifFalse: [ self changeSet affectedNameSpaceNames ]</body><body package="PackageCategories" selector="modifiedAndReorganizedMethodDescriptors">modifiedAndReorganizedMethodDescriptors	| methods |	self isChangeSetEmpty ifTrue: [^OrderedCollection new].	methods := self changeSet modifiedMethodDescriptors.	methods addAll: self reorganizedMethodDescriptors.	^methods asSet asOrderedCollection</body><body package="PackageCategories" selector="modifiedDatumDescriptors">modifiedDatumDescriptors	^self isChangeSetEmpty		ifTrue: [OrderedCollection new]		ifFalse: [self changeSet modifiedDatumDescriptors]</body><body package="PackageCategories" selector="removedClassOrDefinitionNames">removedClassOrDefinitionNames	"Answer a collection of class names that have been removed	from the receiver."	^self isChangeSetEmpty		ifTrue: [ Array new ]		ifFalse: [ self changeSet removedClassOrDefinitionNames ]</body><body package="PackageCategories" selector="removedDatumDescriptors">removedDatumDescriptors	^self isChangeSetEmpty		ifTrue: [Array new]		ifFalse: [self changeSet removedDatumDescriptors]</body><body package="PackageCategories" selector="removedMethodDescriptors">removedMethodDescriptors	^self isChangeSetEmpty		ifTrue: [Array new]		ifFalse: [self changeSet removedMethodDescriptors]</body><body package="PackageCategories" selector="removedNameSpaceOrDefinitionNames">removedNameSpaceOrDefinitionNames	^self isChangeSetEmpty		ifTrue: [Array new]		ifFalse: [self changeSet removedNameSpaceOrDefinitionNames]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>accessing- fake</category><body package="PackageCategories" selector="allContainedItems">allContainedItems	"Answer a collection of components."	^#( )			"don't got none."</body><body package="PackageCategories" selector="anyContainedItems">anyContainedItems	"Answer a collection of components."	^#()			"don't got none."</body><body package="PackageCategories" selector="containedItems">containedItems	"Answer a collection of components."	^#()			"don't got none."</body></methods><methods><class-id>Store.PackageModel</class-id> <category>queries</category><body package="PackageCategories" selector="definedBindings">definedBindings	"Answer a dictionary of bindings (NameSpace/Class to datakey) contained in the receiver."	"Note- duplicates Parcel format."	| bindings keys |	bindings := IdentityDictionary new.	self modelsDo:		[ :model | 		( keys := model dataKeys ) size &gt; 0			ifTrue: [ bindings at: model actual put: ( IdentitySet withAll: keys ) ]		].	^bindings.</body><body package="PackageCategories" selector="definedBindingsFor:">definedBindingsFor: aClassOrNameSpace	"Answer an Array of bindings."	^( self modelAtName: aClassOrNameSpace absoluteName ifAbsent: [ ^#() ] ) 		dataKeys collect: [ :key | aClassOrNameSpace bindingFor: key ]</body><body package="PackageCategories" selector="definedClasses">definedClasses	"Answer a collection of all Classes whose definition is contained in the receiver."	^self classesDefinedInPackage collect: 		[ :each | each actual ].</body><body package="PackageCategories" selector="definedClassesDo:">definedClassesDo: aBlock 		self classModelsDo:		[ :model |		model hasDefinition 			ifTrue: [ aBlock value: model actual ]		].</body><body package="PackageCategories" selector="definedNameSpaces">definedNameSpaces	"Answer a collection of all NameSpaces whose definition is contained in the receiver."	^self nameSpacesDefinedInPackage collect: 		[ :each | each nameSpace ].</body><body package="PackageCategories" selector="definedObjectsDo:">definedObjectsDo: aBlock	^self definedNameSpaces do: aBlock</body><body package="PackageCategories" selector="definedSelectorsFor:">definedSelectorsFor: aBehavior	"Answer an Array of selectors."	^( self modelAtName: aBehavior absoluteName asClassNameOnly ifAbsent: [ ^#() ] ) 		selectorsMeta: aBehavior isMeta</body><body package="PackageCategories" selector="definesClassOrNameSpace:">definesClassOrNameSpace: aClassOrNameSpace	^self includesSymbol: aClassOrNameSpace absoluteName asSymbol</body><body package="PackageCategories" selector="definesName:in:">definesName: key in: nameSpace	^self includesDataKey: key owner: nameSpace</body><body package="PackageCategories" selector="definesObject:">definesObject: aNameSpace	| theNameSpacesAbsoluteName |	theNameSpacesAbsoluteName := aNameSpace absoluteName.	self nameSpaceModelsDo:		[:model |		(model hasDefinition		and: [model absoluteName = theNameSpacesAbsoluteName]) ifTrue:			[^true]].	^false</body><body package="PackageCategories" selector="definesSelector:forClass:">definesSelector: aSelector forClass: aBehavior 	| model |	model := self classModelAtClassSymbol: aBehavior instanceBehavior absoluteSymbol					ifAbsent: nil.	^model ~~ nil	and: [model includesSelector: aSelector meta: aBehavior isMeta]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>accessing browser</category><body package="PackageCategories" selector="allClasses">allClasses	"Answer a collection of class descriptors. The collection contains 	descriptors for classes that are defined in the package and extention 	descriptors for classes for which only methods are defined"	| list overs |	list := self classesDefinedInPackage, self classesExtendedInPackage.	overs := ( ( Override overridesForComponent: self )  select:				[ : over | ( over isForClass | over isForMethod ) | ( over isForGeneral and: [ over owner isForClass ] ) ]			) collect: [ :over | over asPsuedoRecord ].	( list := list asSet ) addAll: overs.	^list asOrderedCollection</body><body package="PackageCategories" selector="allClassNames">allClassNames	"Answer a collection of class names. The collection contains 	names for classes that are defined in the package and names 	of classes for which methods are defined"	| defined extended |	defined := self definedClassModels 		collect: [:cm | cm absoluteName].	extended := self extendedClassModels 		collect: [:cm | cm absoluteName].	^defined asSortedCollection asOrderedCollection , 		extended asSortedCollection asOrderedCollection</body><body package="PackageCategories" selector="allMetaclasses">allMetaclasses	"Answer a collection of class names. The collection contains 	names for classes that are defined in the package and names 	of classes for which methods are defined"	| list overs |	list := self metaclassesDefinedInPackage, self metaclassesExtendedInPackage.	overs := ( ( Override overridesForComponent: self ) select:				[ : over | over isForClass ]			) collect: [ :over | over asPsuedoRecord meta: true ].	list addAll: overs asSet asOrderedCollection.	^list</body><body package="PackageCategories" selector="allMetaclassNames">allMetaclassNames	"Answer a collection of metaclass names. The collection contains 	names for classes that are defined in the package and names 	of classes for which methods are defined"	| defined extended |	defined := self definedClassModels 		collect: [:cm | cm className , ' class'].	extended := self extendedClassModels 		collect: [:cm | cm className , ' class'].	^defined asSortedCollection asOrderedCollection , 		extended asSortedCollection asOrderedCollection</body><body package="PackageCategories" selector="allMethodsBut:">allMethodsBut: oldCollection 	"Answer an array. The first element has collection of methods that are 	defined in the backage but not in oldCollection. 	The second has method defined in oldColection but not in the package."	| coll newColl oldMethod |	coll := oldCollection copy.	newColl := List new.	self methods		do: 			[:method | 			oldMethod := coll detect: [:each | each sameAs: method]						ifNone: [nil].			oldMethod isNil				ifTrue: [newColl add: method]				ifFalse: [coll remove: oldMethod]].	^Array with: newColl with: coll</body><body package="PackageCategories" selector="allNameSpaceNames">allNameSpaceNames	"Answer a collection of class names. The collection contains 	names for classes that are defined in the package and names 	of classes for which methods are defined"	| defined extended |	defined := self definedNameSpaceModels 		collect: [ :model | model absoluteName].	extended := self extendedNameSpaceModels 		collect: [ :model | model absoluteName].	^defined asSortedCollection asOrderedCollection , 		extended asSortedCollection asOrderedCollection</body><body package="PackageCategories" selector="allNameSpaces">allNameSpaces	"Answer a collection of namespace descriptors. The collection contains 	descriptors for namespaces that are defined in the package and extention 	descriptors for namespaces for which only data is defined"	| list overs |	list := self nameSpacesDefinedInPackage, self nameSpacesExtendedInPackage.	overs := ( ( Override overridesForComponent: self )  select:				[ : over | over isForNameSpace | ( over isForGeneral and: [ over owner isForNameSpace ] ) ]			) collect: [ :over | over asPsuedoRecord ].	( list := list asSet ) addAll: overs.	^list asOrderedCollection</body><body package="PackageCategories" selector="classesDefinedInPackage">classesDefinedInPackage	"Answer a collection of class descriptors. The collection contains 	descriptors only for classes that are defined in the package."	^( self definedClassModels 			collect: [:cm | ClassDescriptor fromModel: cm ] )		asOrderedCollection</body><body package="PackageCategories" selector="classesExtendedInPackage">classesExtendedInPackage	"Answer a collection of class descriptors. The collection contains 	descriptors only for classes that are extended (not defined)	in the package."	^( self extendedClassModels 			collect: [:cm | ClassExtensionDescriptor fromModel: cm ] )		asOrderedCollection</body><body package="PackageCategories" selector="classesWithSource">classesWithSource	"For image model, same as defined classes."	^self classesDefinedInPackage.</body><body package="PackageCategories" selector="dataForNamed:">dataForNamed: aFullName	"Answer a collection of datum descriptors."		^( self modelAtName: aFullName asClassNameOnly ifAbsent: [ ^Array new ] )			datumDescriptors</body><body package="PackageCategories" selector="dataForNamed:andProtocol:">dataForNamed: aFullName andProtocol: aSymbol	"Answer a collection of datum descriptors."	^( self modelAtName: aFullName  asClassNameOnly ifAbsent: [^Array new] )			datumDescriptors select:				[ :dd | dd protocolName asSymbol = aSymbol ]</body><body package="PackageCategories" selector="datum:forOwnerNamed:">datum: dataKey forOwnerNamed: aFullName	^( self modelAtSymbol: aFullName ifAbsent: [ ^nil ] )		datumDescriptorForDataKey: dataKey.</body><body package="PackageCategories" selector="metaclassesDefinedInPackage">metaclassesDefinedInPackage	"Answer a collection of class descriptors. The collection contains 	descriptors only for metaclasses that are defined in the package."	^( self definedClassModels 			collect: [:cm | ClassDescriptor fullName: cm absoluteName meta: true ] )		asSortedCollection asOrderedCollection</body><body package="PackageCategories" selector="metaclassesExtendedInPackage">metaclassesExtendedInPackage	"Answer a collection of class descriptors. The collection contains 	descriptors only for metaclasses that are extended (not defined)	in the package."	^( self extendedClassModels 		collect: [:cm | ClassExtensionDescriptor fullName: cm absoluteName meta: true ] )			asSortedCollection asOrderedCollection</body><body package="PackageCategories" selector="method:forClassNamed:meta:">method: aSelector forClassNamed: aClassName meta: isMeta 	"Answer a method with selector aSelector defined in the class 	named aClassName."	^( self modelAtSymbol: aClassName asClassNameOnly asSymbol ifAbsent: [ ^nil ] )		methodDescriptorForSelector: aSelector meta: isMeta.</body><body package="PackageCategories" selector="methodsForClassNamed:andProtocol:meta:">methodsForClassNamed: aClassName andProtocol: aProtocolName meta: isMeta	"Answer a collection of method descriptors."	^(self classModelAtClassName: aClassName ifAbsent: [^Array new])			methodsForProtocol: aProtocolName meta: isMeta</body><body package="PackageCategories" selector="methodsForClassNamed:meta:">methodsForClassNamed: aClassName meta: isMeta	"Answer a collection of method descriptors."	^(self classModelAtClassName: aClassName ifAbsent: [^Array new])			methodsMeta: isMeta</body><body package="PackageCategories" selector="nameSpacesDefinedInPackage">nameSpacesDefinedInPackage	"Answer a collection of namespace descriptors. The collection contains 	descriptors only for NameSpaces that are defined in the package."	^( self definedNameSpaceModels 			collect: [:model | NameSpaceDescriptor fromModel: model ] )		asSortedCollection asOrderedCollection</body><body package="PackageCategories" selector="nameSpacesExtendedInPackage">nameSpacesExtendedInPackage	"Answer a collection of namespace descriptors. The collection contains 	descriptors only for namespaces that are extended (not defined)	in the package."	^( self extendedNameSpaceModels 			collect: [:cm | NameSpaceExtensionDescriptor fromModel: cm ] )		asSortedCollection asOrderedCollection</body><body package="PackageCategories" selector="nameSpacesWithSource">nameSpacesWithSource	"For image model same as defined NameSpace."	^self nameSpacesDefinedInPackage.</body><body package="PackageCategories" selector="packageClasses">packageClasses	"Answer a collection of classes defined in the package."	"For pubishing ONLY. Includes overridden class defs."	^( self definedClassModels collect: [:cm | cm actualClass ] )		addAll: self overriddenClasses;		yourself.</body><body package="PackageCategories" selector="packageNameSpaces">packageNameSpaces	"Answer a collection of NameSpaces defined in the package."	"For pubishing ONLY. Includes overridden class defs."	^( self definedNameSpaceModels collect: [ :model | model nameSpace ] )		addAll: self overriddenNameSpaces;		yourself</body><body package="PackageCategories" selector="protocolsForClassNamed:meta:">protocolsForClassNamed: aClassName meta: isMeta 	| model list cls |	model := self classModelAtClassName: aClassName ifAbsent: [ ^Array new ].	cls := model actual.	isMeta ifTrue: [ cls := cls class ].	list := model protocolsMeta: isMeta.	^self sortCategories: list with: cls organization categories.</body><body package="PackageCategories" selector="protocolsForDataIn:">protocolsForDataIn: anOwner 	^( self modelAtName: anOwner absoluteSymbol ifAbsent: [ ^#() ] )		protocols</body><body package="PackageCategories" selector="protocolsForNameSpaceNamed:">protocolsForNameSpaceNamed: aName 	| model |	model := self modelAtName: aName asSymbol ifAbsent: [ ^#() ].	^self sortCategories: model protocols with: model actual organization categories.</body><body package="PackageCategories" selector="toolListIcon">toolListIcon	^self class packageIcon</body></methods><methods><class-id>Store.PackageModel</class-id> <category>consistency checking</category><body package="PackageCategories" selector="makeConsistent">makeConsistent	self isChangeSetEmpty 		ifFalse: [ self changeSet makeConsistentForPackage: self ].</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-file out</category><body package="PackageCategories" selector="createOrFindExpression">createOrFindExpression	"Answer a string that when evaluated will instantiate the receiver - creating, if neccessary."	^'( Store.Registry packageNamedOrCreate: ', self name printString, ' ) '.</body><body package="PackageCategories" selector="fileOutChangesForDb:on:within:">fileOutChangesForDb: dbid on: aFileManager within: aBundle	| info commentString |	( info := self databaseInformationFor: dbid ) == nil		ifTrue: [ ^self ].	info isChangeSetEmpty ifTrue: [ ^self ].	commentString := ((#PackageChangesFor1s &lt;&lt; #packages &gt;&gt; 'Package Changes for &lt;1s&gt;')			expandMacrosWith: self itemString).	MessageNotification raiseSignal: commentString.	aFileManager addComment: commentString.	( ( UISettings preferenceFor: #fileoutOption ) == #never )		ifFalse:			[ aFileManager sourceFormatter				attributeFor: #package compute: [ : obj | self name ];				attributeForMethods: #package compute: [ :cls :sel | self name ].			self fileOutChangedPropertiesForDb: dbid on: aFileManager.			].	info changeSet fileOutOn: aFileManager within: aBundle.</body><body package="PackageCategories" selector="fileOutClassesOn:">fileOutClassesOn: aFileManager 	"New classes or classes with new definitions."	| cset |	cset := self classesDefinedInPackage collect: [ :each | each myClass ].	cset reject: [ :c | c == nil ].	cset addAll: self overriddenClasses.	cset := SystemUtils sortForLoading: cset.	cset do: 		[ :each | 		each fileOutDefinitionOn: aFileManager.		each fileOutCommentOn: aFileManager.		IncrementNotification raiseSignal.		].</body><body package="PackageCategories" selector="fileOutDataOn:">fileOutDataOn: aFileManager 	"File-out data for every namespace/class. Order is not important."	self modelsDo:		[ :model |		model datumDescriptors do:			[ :dd | 			dd fileOutOn: aFileManager. 			aFileManager cr.			IncrementNotification raiseSignal.			].		aFileManager cr.		].	self overriddenStatics do:		[ :dd |			dd fileOutOn: aFileManager. 			aFileManager cr.		].</body><body package="PackageCategories" selector="fileOutMethodsOn:">fileOutMethodsOn: aFileManager 	"First group methods by class and protocol 	and the ask aFileManager to do the job class by class"	| toFileOut byClass byProtocol |	toFileOut := Dictionary new.	self methods do: 		[ :each | 		byClass := toFileOut at: each implementingClass ifAbsent: [ Dictionary new ].		byProtocol := byClass at: each protocolName ifAbsent: [ Set new ].		byProtocol add: each.		byClass at: each protocolName put: byProtocol.		toFileOut at: each implementingClass put: byClass.		( each selector = #initialize and: [ each implementingClass isMeta] )			ifTrue: [ aFileManager initializeThisClass: each implementingClass instanceBehavior ]		].	( self sortForFileout: toFileOut keys ) do:		[ :cls | | dict |		dict := toFileOut at: cls.		aFileManager			fileOutTTMessages: dict			for: cls fullName			logging: true.		aFileManager cr.		IncrementNotification signalWith: 			( dict inject: 0 into: [ :s :c | s + c size ] )		].</body><body package="PackageCategories" selector="fileOutNameSpacesOn:">fileOutNameSpacesOn: aFileManager 	"New namespaces or namespaces with new definitions."	| cset |	cset := self nameSpacesDefinedInPackage collect: 		[ :each | each nameSpace ].	cset addAll: self overriddenNameSpaces.	cset size &gt; 0 ifFalse: [ ^self ].	cset := SystemUtils sortForLoading: cset.	cset do: 		[ :each | 		each fileOutDefinitionOn: aFileManager.		each fileOutCommentOn: aFileManager.		IncrementNotification raiseSignal.		].</body><body package="PackageCategories" selector="fileOutOn:">fileOutOn: aFileManager 	"File out package on aFileManager"	| commentString |	commentString := ((#Package1s &lt;&lt; #packages &gt;&gt; 'Package &lt;1s&gt;')			expandMacrosWith: self itemString).	MessageNotification raiseSignal: commentString.	aFileManager addComment: commentString.	( ( UISettings preferenceFor: #fileoutOption ) == #never )		ifFalse:			[ aFileManager sourceFormatter				attributeFor: #package compute: [:obj | self name ];				attributeForMethods: #package compute: [:cls :sel | self name ].			self fileOutPropertiesOn: aFileManager.			].	self fileOutNameSpacesOn: aFileManager.	self fileOutClassesOn: aFileManager.	self fileOutDataOn: aFileManager.	self fileOutMethodsOn: aFileManager.	IncrementNotification raiseSignal.	aFileManager cr</body><body package="PackageCategories" selector="sortForFileout:">sortForFileout: classes	"Sort classes based on package inclusion in addition to normal sort."	| in out |	in := OrderedCollection new.	out := OrderedCollection new.	( SystemUtils metaclassesFirst: ( SystemUtils sortForLoading: classes ) ) do:		[ :cls | 		( self includesDefinitionOf: cls instanceBehavior absoluteName )			ifTrue: [ in add: cls ]			ifFalse: [ out add: cls ].		].	^in, out</body></methods><methods><class-id>Store.PackageModel</class-id> <category>initialize-release</category><body package="PackageCategories" selector="initialize">initialize		super initialize.	models := IdentityDictionary new.</body><body package="PackageCategories" selector="release">release	models notNil 		ifTrue: [ models copy do: [ :model | self removeModel: model ] ].	models := IdentityDictionary new.	Registry removePackage: self</body></methods><methods><class-id>Store.PackageModel</class-id> <category>unloading</category><body package="PackageCategories" selector="preUnloadChecks">preUnloadChecks	"Do checks for uses of classes in package."	ObjectMemory globalGarbageCollect.	^self preUnloadChecksFromBundle: nil</body><body package="PackageCategories" selector="preUnloadChecksFromBundle:">preUnloadChecksFromBundle: aBundle 	| probSubclass probExtensions bundles bndls |	probSubclass := Set new.	probExtensions := Set new.	bundles := Set new.	bndls := Registry enclosingComponentsFor: self.	aBundle notNil 		ifTrue: [ bndls remove: aBundle ifAbsent: 					[ aBundle allContainedItems do: [ :b | bndls remove: b ifAbsent: [] ] ].			   ].	bndls do: [:bndl | ( bndl = aBundle ) ifFalse: [ bundles add: bndl name ] ].	self classModelsDo: 		[ :cm | | pkgClass |		pkgClass := [ cm actualClass ] on: UnloadedObjectError 			do: [ :e | Dialog warn: e description. e return: nil ].		( ( pkgClass ~~ nil and: [ cm hasDefinition ] )  				and: [ ( Override isOverriddenClassOrNameSpace: cm actual ) not ] )			ifTrue: 				[ pkgClass allSubclasses , (Array with: pkgClass) do: 					[ :sclass |  | scm |					scm := self classModelAtClass: sclass ifAbsent: [ nil ].					( ( scm isNil or: [ scm isExtension ] ) and: [ ( aBundle notNil and: [aBundle definedClasses includes: sclass] ) not ] )						ifTrue: 							[ probSubclass add: ((#ancestorIsToBeUnloaded &lt;&lt; #packages &gt;&gt; '&lt;1s&gt; (its ancestor &lt;2s&gt; is in the package to be unloaded)')								expandMacrosWith: sclass name								with: cm name) ]						ifFalse: 							[ ( Registry extensionClassModelsForClassSymbol: sclass absoluteSymbol ) do: 								[ :ecm | ecm classNameAndSelectorDo: 									[ :className :selector | 									( aBundle == nil or: [ ( aBundle leafItems includes: ecm package ) not ] )										ifTrue: [ probExtensions add: ((#methodIsExtension &lt;&lt; #packages &gt;&gt; '&lt;1s&gt;%&gt;%&gt;&lt;2s&gt; (an extension in package "&lt;3s&gt;")')											expandMacrosWith: className											with: selector											with: ecm package name) ] ]									]								].					]				]		].	(self unloadProblemsQuery: bundles header: ((#UnloadingPackageWillModifyBundles &lt;&lt; #packages &gt;&gt; 'The package to be unloaded, "&lt;1s&gt;", is contained in the bundles&lt;n&gt;listed below.  Proceeding will modify these bundles.')			expandMacrosWith: self name))		ifFalse: [^false].	(self unloadProblemsQuery: probSubclass header: ((#UnloadingPackageWillRemoveClasses &lt;&lt; #packages &gt;&gt; 'Proceeding will remove the following classes which are not in "&lt;1s&gt;", the package to be unloaded:')			expandMacrosWith: self name))		ifFalse: [^false].	(self unloadProblemsQuery: probExtensions header: ((#UnloadingPackageWillRemoveMethods &lt;&lt; #packages &gt;&gt; 'Proceeding will remove the following methods which are not in &lt;n&gt;"&lt;1s&gt;", the package to be unloaded:')			expandMacrosWith: self name))		ifFalse: [^false].	^self shouldTrackChanges 		ifTrue: [ self checkChangeSet ]		ifFalse: [ true ].</body><body package="PackageCategories" selector="preUnloadChecksThorough">preUnloadChecksThorough	"Do extensive check for uses of classes in package."" ******* out of date, but keep for logic ************	| problems cmeths |	problems := SortedCollection new.	Cursor execute showWhile: [classes			do: 				[:className | 				| classAssoc classSym |				classSym := className asSymbol.				classAssoc := Smalltalk associationAt: classSym.				classAssoc value subclasses do: [:class | (self includesClassNamed: class name asString)						ifFalse: [problems add: class name , ' is a subclass of ' , className]].				Smalltalk allBehaviorsDo: [:class | (self includesClassNamed: class name)						ifFalse: 							[| list |							list := class whichSelectorsReferTo: classAssoc.							list size &gt; 0 ifTrue: [list do: [:sel | (self includesSelector: sel class: class)										ifFalse: [problems add: class name , '&gt;&gt;' , sel , ' uses ' , className]]]]].				cmeths := classToSelectors at: classSym ifAbsent: [Set new].				classAssoc value selectors do: [:sel | (cmeths includes: sel)						ifFalse: [problems add: className , '&gt;&gt;' , sel , ' is an extension from ' , (PackageModel containingPackageForSelector: sel class: classAssoc value) name]]]].	^self unloadProblemsQuery: problems********************* "</body><body package="PackageCategories" selector="runRearguard">runRearguard	"Check if this package can be safetly unloaded from the image."	^true</body><body package="PackageCategories" selector="systemRemoveSelector:fromClass:">systemRemoveSelector: aSymbol fromClass: aClass	"Remove the message whose selector is aSymbol from the method	dictionary of the receiver, if it is there.  Answer nil otherwise."	"RGF 8/5/94 Bernstein:	Based on 'ClassDescription&gt;&gt;removeSelector:' and 	'Behavior&gt;&gt;removeSelector:'.  	Changed to remove write to changes file.  	Notification of change set also removed."	(aClass includesSelector: aSymbol) ifFalse: [^nil].	aClass removeSelectorSimply: aSymbol.	aClass organization removeElement: aSymbol.</body><body package="PackageCategories" selector="unloadFromImage">unloadFromImage	"Remove content of a package from the image. 	Answer true if the operation has succeeded."	self cleanse.	Cursor execute showWhile: 		[ self runPreUnload ifFalse: [ ^false ].		self preUnloadChecks ifFalse: [ ^false ].		self doUnloadFromImage].	^true</body><body package="PackageCategories" selector="unloadSourceSafely">unloadSourceSafely	(properties at: #sourceIndex ifAbsent: nil) ifNotNil: 			[:sourceIndex | 			(SourceFileManager default)				rescueOrphanedSourcesAt: sourceIndex excluding: Set new;				discardSourceAt: sourceIndex]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>accessing</category><body package="PackageCategories" selector="actualClassInPackageNamed:">actualClassInPackageNamed: aClassName 	^(self classModelAtClassName: aClassName ifAbsent: [^nil]) actualClass</body><body package="PackageCategories" selector="allDefinedClasses">allDefinedClasses	"Answer a collection of classes that are defined in the receiver including those overridden."	| list overs |	list := self classesDefinedInPackage collect: [ :cd | cd actual ].	overs := ( ( Override overridesForComponent: self )  select:				[ : over | over isForClass ]			) collect: [ :over | over object ].	( list := list asSet ) addAll: overs.	list remove: nil ifAbsent: nil.	^list asOrderedCollection</body><body package="PackageCategories" selector="classInPackageNamed:">classInPackageNamed: aClassName 	^(self includesClassNamed: aClassName)		ifTrue: [ClassDescriptor fullName: aClassName meta: false]		ifFalse: [nil]</body><body package="PackageCategories" selector="classInPackageNamed:meta:">classInPackageNamed: aClassName meta: aBoolean	^(self includesClassNamed: aClassName)		ifTrue: [ClassDescriptor fullName: aClassName meta: aBoolean] 		ifFalse: [nil]</body><body package="PackageCategories" selector="data">data	| dd |	dd := OrderedCollection new.	self nameSpaceModelsDo: [:cm | dd addAll: cm datumDescriptors].	self classModelsDo: [:cm | dd addAll: cm datumDescriptors].	^dd</body><body package="PackageCategories" selector="dataAsArray">dataAsArray	"Answer a collection of DatumDescriptors."	"This method is used for the DB package creation."	^self data		addAll: self overriddenStatics;		yourself.</body><body package="PackageCategories" selector="dataInstances">dataInstances	"Returns the actual instances associated to the class/key pairs"	^self data collect: [:dd | dd fullName asStrictReference valueOrDo: [nil]]</body><body package="PackageCategories" selector="dataWithSource">dataWithSource	"For the image model this is the same as data."	^self dataAsArray.</body><body package="PackageCategories" selector="inPackageNamed:">inPackageNamed: aName 		"Answer a descriptor for the class/namespace aName"	^( self includesDefinitionOf: aName)		ifTrue: [ ( self descriptorClassFor: aName ) fullName: aName ] 		ifFalse: [ nil ]</body><body package="PackageCategories" selector="itemCount">itemCount	"Answer a count of work to be done. For now, count yourself + models."	^self methods size + self data size + models size + 1.</body><body package="PackageCategories" selector="methods">methods	| meth |	meth := OrderedCollection new.	self classModelsDo: 			[:cm | 			meth addAll: (cm methodsMeta: false).			meth addAll: (cm methodsMeta: true)].	^meth</body><body package="PackageCategories" selector="methodsAsArray">methodsAsArray	"Answer a collection of method descriptors and overridden methods."	"This method is used for the DB package creation."	^self methods 		addAll: self overriddenMethods;		yourself</body><body package="PackageCategories" selector="methodsWithSource">methodsWithSource	"For image model same as methods since sources are already loaded."	"Only called during package comparison, so includes overrridden methods"	^self methodsAsArray.</body><body package="PackageCategories" selector="nameSpaceInPackageNamed:">nameSpaceInPackageNamed: aName 	^( self includesNameSpaceNamed: aName )		ifTrue: [ NameSpaceDescriptor fullName: aName ]		ifFalse: [ nil ]</body><body package="PackageCategories" selector="pundleListIconKey">pundleListIconKey	^self		selectIconKeyDefault: #package 		modified: #modifiedPackage		noDBdefault: #packageNoDB 		modified: #modifiedPackageNoDB</body><body package="PackageCategories" selector="removeMethodDescriptor:">removeMethodDescriptor: aMethod	"Remove aMethod from a collection of methods	defined in the package."	| cm |	cm := self classModelAtClassName: aMethod className ifAbsent: [^self].	cm removeSelector: aMethod selector meta: aMethod className namesMetaClass.	cm isEmpty ifTrue: [self removeClassModel: cm]	.</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-differences calculation</category><body package="PackageCategories" selector="classesNamed:">classesNamed: aSetOfNames 	"Convert aSetOfnames into a collection of ClassDescriptor or ClassExtensionDescriptors."		| names selected |	names := aSetOfNames copy.	selected := SortedCollection sortBlock: [:x :y | x name &lt; y name].	self classesDefinedInPackage do: 		[ :cl | (names includes: cl absoluteName)				ifTrue: 				[ names remove: cl absoluteName.				selected add: cl				]		].	self metaclassesDefinedInPackage do: 		[ :cl | (names includes: cl absoluteName, ' class')			ifTrue: 				[names remove: cl absoluteName, ' class'.				selected add: cl]		].	names do: 		[ :nm|  selected add: ( ClassExtensionDescriptor fullName: nm meta: false ) ].	^selected</body><body package="PackageCategories" selector="modificationsFor:">modificationsFor: dbid	"Answer my content as a collection of modifications."	^self basicModificationsFor: dbid</body><body package="PackageCategories" selector="nameSpacesNamed:">nameSpacesNamed: aSetOfNames 	"Convert aSetOfnames into a collection of NameSpaceDescriptor or NameSpacesExtensionDescriptors."		| names selected |	names := aSetOfNames copy.	selected := SortedCollection sortBlock: [:x :y | x name &lt; y name].	self nameSpacesDefinedInPackage do: 		[ :ns | (names includes: ns absoluteName)				ifTrue: 				[ names remove: ns absoluteName.				selected add: ns				]		].	names do: [:nm|  selected add: ((NameSpaceExtensionDescriptor new) fullName: nm; yourself)].	^selected</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private</category><body package="PackageCategories" selector="checkUndeclared">checkUndeclared	self cleanse.	( models includesKey: Undeclared absoluteSymbol )		ifFalse: [ ^true ].	Undeclared purgeUnusedBindings.	^( models at: Undeclared absoluteSymbol ifAbsent: [ ^true ] ) 		dataKeys isEmpty</body><body package="PackageCategories" selector="cleanse">cleanse	"Cleanse the component. Remove any class or method definitions	 that are no longer in the system, including the postLoadMethod."	self cleanse: true.</body><body package="PackageCategories" selector="cleanse:">cleanse: warn	"Cleanse the component. Remove any class or method definitions	 that are no longer in the system, including the postLoadMethod."	| warnBlock |	warnBlock := [ :str | warn ifTrue: [ Transcript show: ((#nRemovingNonexistant1s &lt;&lt; #packages &gt;&gt; '&lt;n&gt;Removing non-existant &lt;1s&gt;') expandMacrosWith: str)  ] ].	models keys do:		[ :key |		 key asStrictReference isDefined			ifFalse: 				[ warnBlock value: key.				models removeKey: key. 				].		].	self extendedClassModels do:		[ :model | 		model classAndSelectorDo:			[ :cls :selector | 			cls compiledMethodAt: selector ifAbsent: 				[ warnBlock value: ((#x1s2s &lt;&lt; #packages &gt;&gt; '&lt;1s&gt;%&gt;%&gt;&lt;2s&gt;')						expandMacrosWith: cls fullName						with: selector).				model removeSelector: selector meta: cls isMeta 				]			].		model classAndDataKeyDo:			[ :cls :key |			( cls includesDataKey: key )				ifFalse: [ warnBlock value: (cls fullName, '.', key).						model removeDataKey: key ]			]		].	self extendedNameSpaceModels do:		[ :model | 		model nameSpaceAndDataKeyDo:			[ :ns :key |			( ns includesDataKey: key )				ifFalse: [ warnBlock value: (ns fullName, '.', key).						model removeDataKey: key ]			]		].	models copy do:		[ :m | m isEmpty ifTrue: [ self removeModel: m ] ]</body><body package="PackageCategories" selector="descriptionClass">descriptionClass	^PackageDescription</body><body package="PackageCategories" selector="doUnloadDefinitionsFromImage">doUnloadDefinitionsFromImage	"Remove the receiver'ss defined classes and namespaces from the image. 	Answer true if the operation has succeeded."	| mlist |	mlist := [ self definedModels collect: [:cm | cm actual ] ] on: UnloadedObjectError 	do: 				[ :e | Dialog warn: e description. e resume ].	mlist := SystemUtils sortForLoading: ( mlist reject: [ :cm | cm == nil ] ).	mlist reverseDo: 		[ :obj |   | change |		change := Change new removeChanges actual: obj.		Override unloadClassOrNameSpace: obj from: self. 		XChangeSet current doChange: change		].	^true</body><body package="PackageCategories" selector="doUnloadExtensionsFromImage">doUnloadExtensionsFromImage	"Remove the class/namespace extensions of a package from the image. 	Answer true if the operation has succeeded."	| affectedClasses |	affectedClasses := Set new.	XMainChangeSet ignoreMainChangesWhile: 		[ self extendedModels do: 			[ :model | 			model unloadAllDataKeys.			model isForClass 				ifTrue: [ affectedClasses addAll: ( model unloadAllSelectors) ].			]		].	affectedClasses do: 	[ :aClass | aClass instanceMethodsChanged ].	^true</body><body package="PackageCategories" selector="doUnloadFromImage">doUnloadFromImage	"Remove content of a package from the image.  Answer true if the operation has succeeded."	Transcript cr; show: ((#UnloadingPackageC1s &lt;&lt; #packages &gt;&gt; 'Unloading package: &lt;1s&gt;')			expandMacrosWith: self name printString).	self doUnloadExtensionsFromImage.	self doUnloadDefinitionsFromImage.	self doUnloadExtensionsFromImage.		"in case classes were restored and we now own extensions."	self release.	Smalltalk organization removeEmptyCategories.	Override removeOverridesForComponent: self.	Override cleanseLists.	self runPostUnload.	self cleanseRelatedParcel.	self unloadSourceSafely.	^true</body><body package="PackageCategories" selector="manager">manager	^Registry</body><body package="PackageCategories" selector="relinquishDataKey:owner:">relinquishDataKey: aDataKey owner: aClassOrNameSpace	"Called only during parcel loading. Remove the selector without marking anything modified."	( self modelAtName: aClassOrNameSpace absoluteName ifAbsent: [ ^nil ] )		removeDataKey: aDataKey</body><body package="PackageCategories" selector="relinquishSelector:class:">relinquishSelector: aSelector class: aClass	"Called only during parcel loading. Remove the selector without marking anything modified."	( self modelAtName: aClass instanceBehavior absoluteName ifAbsent: [ ^nil ] )		removeSelector: aSelector meta: aClass isMeta</body><body package="PackageCategories" selector="removeEmptyModels">removeEmptyModels	models copy do: 		[ :model | 		model isEmpty			ifTrue: [ self removeModel: model ]		]</body><body package="PackageCategories" selector="removeEmptyProtocols">removeEmptyProtocols	self classModelsDo: 			[:cm | 			(cm selectorsMeta: false) isNil ifFalse: [cm actualClass organization removeEmptyCategories].			(cm selectorsMeta: true) isNil ifFalse: [cm actualClass class organization removeEmptyCategories]]</body><body package="PackageCategories" selector="unloadSource">unloadSource	| sourceIndex |	((sourceIndex := properties at: #sourceIndex ifAbsent: nil) notNil) ifTrue:		[SourceFileManager default discardSourceAt: sourceIndex]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>table of contents</category><body package="PackageCategories" selector="tableOfBundleContentsOn:level:">tableOfBundleContentsOn: aStream level: aLevel	aLevel timesRepeat: [aStream tab].	aStream nextPut: $"; nextPutAll: self name; nextPut: $"; cr.</body><body package="PackageCategories" selector="tableOfContentsOn:">tableOfContentsOn: aStream 	aStream nextPut: $"; nextPutAll: self name; nextPut: $"; cr.	self modelsDo: 		[ :model | 	| mname |		mname := model absoluteName.		model hasDefinition 			ifTrue: 				[ aStream tab.				model isForNameSpace ifTrue: [ aStream nextPut: $! ].				aStream nextPutAll: mname; cr 				].		model isForClass			ifTrue:				[ ( model selectorsMeta: false ) do: 					[ :selector | 					aStream tab; tab; 						nextPutAll: mname; nextPutAll: '&gt;'; 						nextPutAll: selector; cr					].				( model selectorsMeta: true ) do: 					[ :selector | 					aStream tab; tab; nextPut: $%; nextPutAll: mname; 						nextPutAll: '&gt;'; nextPutAll: selector; cr					]				].		model dataKeys do: 			[ :dataKey | 			aStream tab; tab; 				nextPutAll: mname; 				nextPutAll: '@'; 				nextPutAll: dataKey; cr.			]		].	aStream tab; nextPutAll: ';'; cr</body><body package="PackageCategories" selector="tableOfContentsOnFile:">tableOfContentsOnFile: aString	| strm |	strm := aString asFilename writeStream.	self tableOfContentsOn: strm.	strm close.</body></methods><methods><class-id>Store.PackageModel</class-id> <category>main change set access</category><body package="PackageCategories" selector="doClassChange:">doClassChange: change 	self	updateAfterDo: 		[ | classSymbol |		classSymbol := change fullClassSymbol.		change isRemove			ifTrue: 				[ self removeAllChangeSetClassSymbol: classSymbol.				self removeWholeClassSymbol: classSymbol				]			ifFalse: 				[ self changeSetsDo: 					[ :cs | cs doClassChange: change ].				change isRemoveDefinition					ifTrue: [ self removeDefinitionFullClassSymbol: classSymbol ].				change isAdd					ifTrue: [ self addFullClassSymbol: classSymbol ]				]		]</body><body package="PackageCategories" selector="doNameSpaceChange:">doNameSpaceChange: change 	"Apply the change to the receiver."	self updateAfterDo: 		[ | nsSymbol |		nsSymbol := change nameSpaceSymbol.		change isRemove			ifTrue: 				[ self removeAllChangeSetNameSpaceSymbol: nsSymbol.				self removeWholeSymbol: nsSymbol				]			ifFalse: 				[ self changeSetsDo: [ :cs | cs doNameSpaceChange: change ].				change isRemoveDefinition					ifTrue: [ self removeDefinitionFullNameSpaceSymbol: nsSymbol ].				change isAdd					ifTrue: [ self addFullSymbol: nsSymbol ]				]		]</body><body package="PackageCategories" selector="doSubdefChange:">doSubdefChange: change 	"Apply the method/static change to the receiver."	self updateAfterDo: 		[ | symbol |		self changeSetsDo: [ :cs | cs doSubdefChange: change ].		symbol := change symbol.		change isRemove			ifTrue: 				[ | model |				model := self modelAtSymbol: symbol ifAbsent: [^self].				change isMethodChange					ifTrue: [ model removeSelector: change selector meta: change meta ]					ifFalse: [ model removeDataKey: change dataKey ].					model isEmpty ifTrue: [ self removeModel: model ]				]			ifFalse: 				[ change isAdd					ifTrue:						[ change isMethodChange							ifTrue: [ self addSelector: change selector fullClassSymbol: symbol meta: change meta ]							ifFalse: [ self addDataKey: change dataKey symbol: symbol ]						]				]			]</body><body package="PackageCategories" selector="removeAllChangeSetClassSymbol:">removeAllChangeSetClassSymbol: classSymbol	"Propagate the removal of everything in this class which is not in 	another package to the package change sets."	| cm |	cm := self classModelAtClassSymbol: classSymbol ifAbsent: [ ^self ].	self updateAfterDo: 		[ | change |		change := ( Change new ) classSymbol: classSymbol.		cm hasDefinition 			ifTrue: [ self changeSetsDo: [ :cs | cs doChange: change remove "Definition" ] ].		change remove.		( cm selectorsMeta: false ) do: 			[ :selector | 			self changeSetsDo: [ :cs | cs doSubdefChange: ( change selector: selector; meta: false ) ]			].		( cm selectorsMeta: true ) do: 			[ :selector | 			self changeSetsDo: [ :cs | cs doSubdefChange: ( change selector: selector; meta: true ) ]			].		cm dataKeys do:			[ :key |			self changeSetsDo: [ :cs | cs doSubdefChange: ( change dataKey: key ) ]			]		]</body><body package="PackageCategories" selector="removeAllChangeSetNameSpaceSymbol:">removeAllChangeSetNameSpaceSymbol: nsSymbol	"Propagate the removal of everything in this namesapce which is not in 	another package to the package change sets."	| model |	model := self modelAtSymbol: nsSymbol ifAbsent: [ ^self ].	self updateAfterDo: 		[ | change |		change := (Change new) nameSpaceSymbol: nsSymbol.		model hasDefinition ifTrue: 			[ self changeSetsDo: [ :cs | cs doNameSpaceChange: change remove "Definition" ] ].		change remove.		( model dataKeys ) do: 			[ :dataKey | 			self changeSetsDo: [ :cs | cs doSubdefChange: (change dataKey: dataKey) ]			].		]</body><body package="PackageCategories" selector="renameAllChangeSetClassSymbol:to:">renameAllChangeSetClassSymbol: oldSymbol to: newSymbol 	"Propagate the removal of everything in this class which is not in 	another package to the package change sets."	| cm |	cm := self classModelAtClassSymbol: oldSymbol ifAbsent: [ ^self ].	self updateAfterDo: 		[ | removeChange addChange |		removeChange := Change new classSymbol: oldSymbol.		addChange := Change new classSymbol: newSymbol.		addChange add.		cm hasDefinition			ifTrue: 				[ self changeSetsDo: 					[ :cs | 					cs doChange: removeChange removeDefinition.					cs doChange: addChange					]				].		removeChange remove.		cm dataKeys do: 			[ :dataKey | 			self changeSetsDo: 				[ :cs | 				cs doSubdefChange: ( removeChange dataKey: dataKey ).				cs doSubdefChange: ( addChange dataKey: dataKey )				]			].		( cm selectorsMeta: false ) do: 			[ :selector | 			self changeSetsDo: 				[ :cs | 				cs doSubdefChange: ( removeChange selector: selector; meta: false ).				cs doSubdefChange: ( addChange selector: selector; meta: false ) 				]			].		( cm selectorsMeta: true ) do: 			[ :selector | 			self changeSetsDo: 				[ :cs | 				cs doSubdefChange: ( removeChange selector: selector; meta: true ).				cs doSubdefChange: ( addChange selector: selector; meta: true ) 				]			]		]</body><body package="PackageCategories" selector="renameAllChangeSetNameSpaceSymbol:to:">renameAllChangeSetNameSpaceSymbol: oldSymbol to: newSymbol 	"Propagate the removal of everything in this namespace which is not in 	another package to the package change sets."	| model |	model := self modelAtSymbol: oldSymbol ifAbsent: [ ^self ].	self updateAfterDo: 		[ | removeChange addChange |		removeChange := Change new nameSpaceSymbol: oldSymbol.		addChange := Change new nameSpaceSymbol: newSymbol.		addChange add.		model hasDefinition			ifTrue: 				[ self changeSetsDo: 					[ :cs | 					cs doChange: removeChange removeDefinition.					cs doChange: addChange					]				].		removeChange remove.		model dataKeys do: 			[ :dataKey | 			self changeSetsDo: 				[ :cs | 				cs doSubdefChange: (removeChange dataKey: dataKey).				cs doSubdefChange: (addChange dataKey: dataKey) 				]			].		]</body><body package="PackageCategories" selector="renameClassSymbol:as:">renameClassSymbol: oldClassSymbol as: newClassSymbol 	| cm |	cm := self classModelAtClassSymbol: oldClassSymbol ifAbsent: [^self].	self renameAllChangeSetClassSymbol: oldClassSymbol to: newClassSymbol.	self renameModel: cm as: newClassSymbol.</body><body package="PackageCategories" selector="renameNameSpaceSymbol:as:">renameNameSpaceSymbol: oldNameSpaceSymbol as: newNameSpaceSymbol 	| model |	model := self modelAtSymbol: oldNameSpaceSymbol ifAbsent: [ ^self ].	self renameAllChangeSetNameSpaceSymbol: oldNameSpaceSymbol to: newNameSpaceSymbol.	self renameModel: model as: newNameSpaceSymbol.</body></methods><methods><class-id>Store.PackageModel</class-id> <category>parcel support</category><body package="PackageCategories" selector="copyContentsToParcel:">copyContentsToParcel: parcel	 	self definedClassModels do: [ :cm  | parcel addClass: cm actual ].	self definedNameSpaceModels do: [ :nsm | parcel addNameSpace: nsm actual ].	self classModels do:		[ :cm | cm classAndSelectorDo:			[ :cls :selector | 	parcel addSelector: selector class: cls ]		].	self modelsDo:		[ :model | 		model dataKeys do:	[ :key | parcel addName: key in: model actual ]		]</body><body package="PackageCategories" selector="dataNotInParcel:on:">dataNotInParcel: aParcel on: aStream	"Write method&gt;&gt;selectors contained in the receiver but not in a Parcel."	self modelsDo:		[ :model |		model dataKeys do:			[ :key |			( aParcel definesName: key in: model actual )				ifFalse: [ aStream nextPutAll: ( model name, '.', key ); cr ]			]		].</body><body package="PackageCategories" selector="definedClassesExcludedSelectors">definedClassesExcludedSelectors	"Answer an IdentityDictionary of Class -&gt; &lt;Set of selectors&gt;"	"Parcel compatibility."	| coll selectors |	coll := IdentityDictionary new.	self definedClasses do:		[ :cls | 		( Registry extensionClassModelsForClassSymbol: cls absoluteSymbol ) do:			[ : exm | 			( selectors := exm selectorsMeta: false ) isEmpty				ifFalse: [ ( coll at: cls ifAbsentPut: [ Set new ] ) addAll: selectors ].			( selectors := exm selectorsMeta: true ) isEmpty				ifFalse: [ ( coll at: cls class ifAbsentPut: [ Set new ] ) addAll: selectors ].			]		].	^coll</body><body package="PackageCategories" selector="definedClassesNotInParcel:on:">definedClassesNotInParcel: aParcel on: aStream	"Write classes whose definition is contained in the receiver but not in a Parcel."	| pclasses |	pclasses  := aParcel definedClasses.	self definedClassModels do:		[ :model |		( pclasses includes: model actual )			ifFalse: [ aStream nextPutAll: model name; cr ]		].</body><body package="PackageCategories" selector="definedNameSpacesNotInParcel:on:">definedNameSpacesNotInParcel: aParcel on: aStream	"Write namespaces whose definition is contained in the receiver but not in a Parcel."	self definedNameSpaceModels do:		[ :model |		( aParcel definedObjects includes: model actual )			ifFalse: [ aStream nextPutAll: model name; cr ]		].</body><body package="PackageCategories" selector="definedObjects">definedObjects	"Parcel compatibility"	^self definedNameSpaces</body><body package="PackageCategories" selector="extensionMethods">extensionMethods 	"Answer an IdentitySet of CompiledMethods"	"Parcel compatibility."	| coll |	coll := OrderedCollection new.	self extendedModels do:		[ :model | 		model isForClass			ifTrue: [ model methods do: [ :md | coll add: md method ] ]		].	^coll reject: [ :cm | cm == nil ].</body><body package="PackageCategories" selector="extensionsDo:">extensionsDo: aBlock 	"Evaluate aBlock with MethodDefinitions for all defined extension methods"	"Parcel compatibility."	| cls |	self extendedClassModels do:		[ :model |		cls := model actual.		( model selectorsMeta: true ) do:			[ :selector |	aBlock value: cls class value: selector ].		( model selectorsMeta: false ) do:			[ :selector |	aBlock value: cls value: selector ].		]</body><body package="PackageCategories" selector="methodsNotInParcel:on:">methodsNotInParcel: aParcel on: aStream	"Write method&gt;&gt;selectors contained in the receiver but not in a Parcel."	self classModels do:		[ :model |		model classAndSelectorDo:			[ :cls :sel |			( aParcel definesSelector: sel forClass: cls )				ifFalse: [ aStream nextPutAll: ( cls name, '&gt;&gt;', sel ); cr ]			]		].</body><body package="PackageCategories" selector="namedObjects">namedObjects	^Dictionary new.</body><body package="PackageCategories" selector="putStoredPropertiesIn:">putStoredPropertiesIn: aDictionary 	"Put any PundleModel-specific properties into aDictionary for Parcel publishing."	super putStoredPropertiesIn: aDictionary. 	aDictionary 		at: #packageName put: name;		at: #dbTrace put: self dbTrace;		at: #dbIdentifier put: self dbIdentifier;		at: #printStringCache put: self printStringCache.</body><body package="PackageCategories" selector="saveAsParcel:saveStructure:saveLinks:">saveAsParcel: fullPathName saveStructure: saveStructure saveLinks: saveLinks	"Save the receiver as a parcel -without creating the parcel in the image.	fullPathName is a directory/parcelName with no extension.	If saveStructure is meaningless for packages	If saveLinks is true, save the db link."	| dir pname |	pname := fullPathName tail.	dir := fullPathName directory.	dir exists 		ifFalse:			[ ( Dialog confirm: ( (#CreateDirectory1s &lt;&lt; #packages &gt;&gt; 'Create directory &lt;1s&gt;?') expandMacrosWith: dir asString ) )				ifFalse: [ ^self ].			dir makeDirectory.			].	properties at: #packageName put: name.	self		parcelOutTo: ( dir  construct: ( pname, '.pcl' ) ) asString		sourceFileName: ( dir construct: ( pname, '.pst' ) ) asString.</body><body package="PackageCategories" selector="saveAsParcel:saveStructure:saveLinks:parcelOptions:">saveAsParcel: fullPathName saveStructure: saveStructure saveLinks: saveLinks parcelOptions: aDictionary	"Save the receiver as a parcel -without creating the parcel in the image.	fullPathName is a directory/parcelName with no extension.	If saveStructure is meaningless for packages	If saveLinks is true, save the db link."	| dir pname |	pname := fullPathName tail.	dir := fullPathName directory.	dir exists 		ifFalse:			[ ( Dialog confirm: ( (#CreateDirectory1s &lt;&lt; #packages &gt;&gt; 'Create directory &lt;1s&gt;?') expandMacrosWith: dir asString ) )				ifFalse: [ ^self ].			dir makeDirectory.			].	properties at: #packageName put: name.	self		parcelOutTo: ( dir  construct: ( pname, '.pcl' ) ) asString		sourceFileName: ( dir construct: ( pname, '.pst' ) ) asString		parcelOptions: aDictionary.</body></methods><methods><class-id>Store.PackageModel</class-id> <category>overrides</category><body package="PackageCategories" selector="cleanUpOverrides">cleanUpOverrides	self overrides copy do:		[ :over | | obj |		( obj := over object ) == nil			ifFalse: 				[ ( ( over getSources: obj ) includes: self )					ifTrue: [ over silentlyRemove ]				].		].</body><body package="PackageCategories" selector="comparesTo:">comparesTo: aCodeComponent	"Answer true if the receiver is some version of aCodeComponent."	^aCodeComponent isPackage and: [ name = aCodeComponent name ].</body><body package="PackageCategories" selector="overriddenClass:">overriddenClass: aClass	"The class definition has been redefined for another package."	".... the new definition has just been installed..."	self changeSetsDo: 		[ :cs | cs overriddenClass: aClass ].</body><body package="PackageCategories" selector="overriddenNameSpace:">overriddenNameSpace: aNameSpace	"The nameSpace definition has been redefined for another package."	".... the new definition  has just been installed	...."	self changeSetsDo: 		[ :cs | cs overriddenNameSpace: aNameSpace ].</body><body package="PackageCategories" selector="overriddenSelector:class:">overriddenSelector: selector class: aClass	"aClass&gt;&gt;selector has been redefined for another package."	self changeSetsDo: 		[ :cs | cs overriddenSelector: selector class: aClass ].</body><body package="PackageCategories" selector="overriddenStatic:in:">overriddenStatic: key in: aNameSpace	"aNameSpace.key defintion has been redefined for another package."	self changeSetsDo: 		[ :cs | cs overriddenStatic: key in: aNameSpace ].</body><body package="PackageCategories" selector="reinstalledClass:">reinstalledClass: aClass 	"A previously overriden class definition has been restored."	XChangeSet current moveClassDefinition: aClass toPackage: self.</body><body package="PackageCategories" selector="reinstalledNameSpace:">reinstalledNameSpace: aNameSpace	"A previously overriden namespace definition has been restored."	XChangeSet current moveNameSpaceDefinition: aNameSpace toPackage: self.</body><body package="PackageCategories" selector="reinstalledSelector:class:">reinstalledSelector: selector class: aClass	"A previously overriden namespace definition has been restored."	XChangeSet current moveSelector: selector class: aClass toPackage: self.	self changeSetsDo:		[ :cs | cs forgetMethodChange: selector class: aClass ]</body><body package="PackageCategories" selector="reinstalledStatic:in:">reinstalledStatic: aStaticKey in: aNameSpace 	"A previously static definition has been restored."	XChangeSet current moveDataKey: aStaticKey owner: aNameSpace toPackage: self.	self changeSetsDo:		[ :cs | cs forgetDataChange: aStaticKey owner: aNameSpace ]</body><body package="PackageCategories" selector="removeOverriddenClass:">removeOverriddenClass: aClass	"Remove only the class definition that has been overridden by another component."	"Record in changeset"	self doClassChange: 		( Change new class: aClass; remove ).</body><body package="PackageCategories" selector="removeOverriddenNameSpace:">removeOverriddenNameSpace: aNameSpace	"Remove only the namespace definition that has been overridden by another component."	"Record in changeset"	self doNameSpaceChange: 		( Change new nameSpace: aNameSpace; remove ).</body><body package="PackageCategories" selector="removeOverriddenSelector:class:">removeOverriddenSelector: selector class: aClass	"Remove  a  selector that was overridden by another component."	"Record in changeset"	self doSubdefChange: 		( Change new class: aClass; selector: selector; remove ).</body><body package="PackageCategories" selector="removeOverriddenStatic:nameSpace:">removeOverriddenStatic: symbol nameSpace: aNameSpace	"Remove only the static that has been overridden by another component."	"Record in changeset"	self doSubdefChange: 		( Change new actual: aNameSpace; dataKey: symbol; remove ).</body></methods><methods><class-id>Store.PackageModel</class-id> <category>change set conversion</category><body package="PackageCategories" selector="conversionPackage">conversionPackage	"Answer a copy of the receiver suitable for publishing change fragments."	^( self class new )		name: name;		copyPropertiesFrom: properties;		copyModels: models;		dbIdentifier: self dbIdentifier;		dbTrace: self dbTrace;		yourself.</body><body package="PackageCategories" selector="copyModels:">copyModels: modelDictionary	"Deep copy the modelDictionary into the receiver."	"Meant for internal use only."	models := IdentityDictionary new.	modelDictionary keysAndValuesDo:		[ :key :value | models at: key put: value copy ].</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-loading/unloading</category><body package="PackageCategories" selector="removeClass:unloaded:">removeClass: aClass unloaded: aBoolean	"Remove a class from the receiver. aBoolean is true means that the class	was removed from the system. If false, an override was reinstalled."	aBoolean		ifTrue: [ self removeClass: aClass ].</body><body package="PackageCategories" selector="removeNameSpace:unloaded:">removeNameSpace: aNameSpace unloaded: aBoolean	"Remove a namespace from the receiver. aBoolean is true means that 	the	namespace was removed from the system. If false, an override was reinstalled."	aBoolean		ifTrue: [ self removeNameSpace: aNameSpace ].</body></methods><methods><class-id>Store.PackageModel</class-id> <category>editing</category><body package="PackageCategories" selector="addClasses:">addClasses: classes 	classes do: [:aClass | self addClass: aClass]</body><body package="PackageCategories" selector="addEntiretyOfClass:">addEntiretyOfClass: class 	"Add a class and all its methods to myself."	XChangeSet current moveWholeClass: class toPackage: self</body><body package="PackageCategories" selector="addSelector:forClass:">addSelector: aSymbol forClass: aBehavior	"Used during binary load."	self addSelector: aSymbol class: aBehavior</body><body package="PackageCategories" selector="removeName:in:">removeName: aSymbol in: aNameSpace 	XChangeSet current removeDataKey: aSymbol nameSpace: aNameSpace</body><body package="PackageCategories" selector="removeSelector:forClass:">removeSelector: aSelector forClass: aBehavior	XMainChangeSet current removeSelector: aSelector class: aBehavior fromPackage: self.</body></methods><methods><class-id>Store.PackageModel</class-id> <category>change management</category><body package="PackageCategories" selector="removeClass:">removeClass: aClass	XChangeSet current removeClass: aClass from: self</body><body package="PackageCategories" selector="removeNameSpace:">removeNameSpace: aNameSpace	(Registry containingPackageForNameSpace: aNameSpace) = self ifFalse: [^self].	XChangeSet current removeNameSpace: aNameSpace</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-load/unload</category><body package="PackageCategories" selector="queryLoaded:ifLoadedAndOK:ifFail:">queryLoaded: nameString ifLoadedAndOK: updateBlock ifFail: failBlock 	"Check if the receiver is already loaded and if so, take whatever error actions are required and 	 evaluate aBlock with the error value, which will probably be derived from some exception handler.	 By default there's nothing to do.  With StORE ."	| oldPackage |	oldPackage := Registry packageNamed: nameString.	(oldPackage isNil or: [oldPackage isEmpty]) ifTrue: [^self].	^(Parcel parcelAlreadyLoadedSignal raiseRequestWith: nameString)		ifTrue: [updateBlock value: oldPackage]		ifFalse:			[failBlock value: (self class abortedActionSignal									raiseRequestWith:										(Array											with: self											with: nameString											with: #packageAlreadyLoaded &lt;&lt; #dialogs &gt;&gt; 'Package already loaded')									errorString: #packageLoadAborted &lt;&lt; #dialogs &gt;&gt; 'Package load aborted')]</body><body package="PackageCategories" selector="unloadProblemsQuery:header:">unloadProblemsQuery: aProblemSet header: aHeader	| probStream problems indent |	aProblemSet size = 0 ifTrue: [^true].	probStream := WriteStream on: String new.	probStream nextPutAll: aHeader;  cr.	problems := aProblemSet asSortedCollection.	problems size = 0 ifTrue: [^true].	indent := '         '.	problems size &lt; 20 		ifTrue: [problems do: [:prob| 			probStream nextPutAll: indent.			probStream nextPutAll: prob.			probStream cr]]		ifFalse: [1 to: 14 do: [:inx|  			probStream nextPutAll: indent.			probStream nextPutAll: (problems at: inx).			probStream cr].			probStream nextPutAll: '...'; cr].	^#proceed == (Dialog		choose: probStream contents		labels: (Array with: (#Proceed &lt;&lt; #packages &gt;&gt; 'Proceed') with: (#Cancel &lt;&lt; #packages &gt;&gt; 'Cancel'))		values: #(#proceed #cancel)		default: #cancel)</body></methods><methods><class-id>Store.PackageModel class</class-id> <category>private</category><body package="PackageCategories" selector="emptyFrom:">emptyFrom: aPublishedPackage 	"Create a new EMPTY package using aPublishedPackage. 	In order to make the package change set reflect this situation 	convert the contents of aPublishedPackage into removes. 	Answer a collection of modifications."	| imPkg mods |	imPkg := self named: aPublishedPackage name.	imPkg dbTrace: aPublishedPackage primaryKey.	mods := aPublishedPackage modificationsFor: aPublishedPackage dbIdentifier.	imPkg markModificationAsRemoves: mods.	^mods</body></methods><methods><class-id>Store.PackageModel class</class-id> <category>constants</category><body package="PackageCategories" selector="componentType">componentType	"Answer a symbol representing the class of the receiver."	^#package</body><body package="PackageCategories" selector="descriptionString">descriptionString	"Answer a string for error messages."	^(#package &lt;&lt; #packages &gt;&gt; 'package') asString</body><body package="PackageCategories" selector="packageIcon">packageIcon	^PackageIcon ifNil: [PackageIcon := ListIconLibrary visualFor: #package]</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>accessing</category><body package="PackageCategories" selector="dbIdentifier">dbIdentifier 	^dbIdentifier</body><body package="PackageCategories" selector="dbIdentifier:">dbIdentifier: aSymbol	dbIdentifier := aSymbol asSymbol</body><body package="PackageCategories" selector="manager">manager	^Registry</body><body package="PackageCategories" selector="pundle">pundle	^pundle</body><body package="PackageCategories" selector="pundle:">pundle: aPundle	^pundle := aPundle</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>testing</category><body package="PackageCategories" selector="isInCurrentDatabase">isInCurrentDatabase	^#{DbRegistry} 		ifDefinedDo: [ :reg | reg dbIdentifier = self dbIdentifier ]		elseDo: [ false ].</body><body package="PackageCategories" selector="shouldTrackChanges">shouldTrackChanges	^#{Store.DbRegistry} isDefined</body></methods><methods><class-id>Store.DatabaseConnectionInformation class</class-id> <category>instance creation</category><body package="PackageCategories" selector="dbIdentifier:">dbIdentifier: aSymbol	"Answer an instance of the receiver for a database."	^self new		dbIdentifier: aSymbol asSymbol;		yourself.</body></methods><methods><class-id>Store.PseudoRecord</class-id> <category>testing</category><body package="PackageCategories" selector="isDataModel">isDataModel	"Is this a Bernstein data model?"	^true</body><body package="PackageCategories" selector="isExtension">isExtension	^false</body></methods><methods><class-id>Store.PseudoRecord</class-id> <category>comparing</category><body package="PackageCategories" selector="sameAs:">sameAs: aThing	| thing |			thing := aThing isDataModel 		"Munched for browser support-DS"		ifFalse: [ aThing absoluteName ]		ifTrue: [ aThing ].	thing isString ifTrue: [ ^self absoluteName = thing ].	^thing sameAsImThing: self</body></methods><methods><class-id>Store.PseudoRecord</class-id> <category>printing</category><body package="PackageCategories" selector="itemString">itemString	^self fullName , self versionString</body><body package="PackageCategories" selector="versionString">versionString	^(#parenImage &lt;&lt; #packages &gt;&gt; '(image)') asString</body></methods><methods><class-id>Store.PseudoRecord</class-id> <category>accessing</category><body package="PackageCategories" selector="asDescriptor">asDescriptor		^self</body><body package="PackageCategories" selector="myClass">myClass	"Give a class name answer a class."	| cls |	cls := self fullClassName asClassNameOnly asStrictReference valueOrDo: [ ^nil ].	self isMeta ifTrue: [ cls := cls class ].	^cls</body></methods><methods><class-id>Store.PseudoRecord</class-id> <category>accessing browser</category><body package="PackageCategories" selector="primaryKey">primaryKey	^0</body><body package="PackageCategories" selector="version">version	^(#image &lt;&lt; #packages &gt;&gt; 'image') asString</body></methods><methods><class-id>Store.PseudoRecord</class-id> <category>merge</category><body package="PackageCategories" selector="loadCommentFor:">loadCommentFor: aClass 	"Load the receiver's comment."	"Already in the image, so no action required."</body><body package="PackageCategories" selector="loadDefinition:logged:">loadDefinition: aString logged: logFlag	"Load the receiver into the image by compiling it's definition."	"Already in the image, so no action required."</body></methods><methods><class-id>Store.PseudoRecord class</class-id> <category>instance creation</category><body package="PackageCategories" selector="fromModel:">fromModel: aModel	^aModel isForClass		ifTrue: [ ClassDescriptor fromModel: aModel ]		ifFalse: [ NameSpaceDescriptor  fromModel: aModel ].</body></methods><methods><class-id>Store.DatumDescriptor</class-id> <category>printing</category><body package="PackageCategories" selector="displayString">displayString	^SystemUtils convertAbsoluteNameToFull: self name</body><body package="PackageCategories" selector="itemString">itemString	^self name , self versionString</body><body package="PackageCategories" selector="printOn:">printOn: aStream	 	aStream nextPutAll: self fullName.</body><body package="PackageCategories" selector="versionString">versionString	^''</body></methods><methods><class-id>Store.DatumDescriptor</class-id> <category>testing</category><body package="PackageCategories" selector="isForData">isForData	^true</body><body package="PackageCategories" selector="isForGeneral">isForGeneral	^true</body><body package="PackageCategories" selector="isInClass">isInClass 	^className ~~  nil</body><body package="PackageCategories" selector="isInNameSpace">isInNameSpace 	^nameSpaceName ~~ nil</body></methods><methods><class-id>Store.DatumDescriptor</class-id> <category>accessing browser</category><body package="PackageCategories" selector="name">name 	^self dataKey asString</body></methods><methods><class-id>Store.DatumDescriptor</class-id> <category>accessing</category><body package="PackageCategories" selector="absoluteName">absoluteName	^self fullName</body><body package="PackageCategories" selector="absoluteOwnerName">absoluteOwnerName 	^self environmentString</body><body package="PackageCategories" selector="binding">binding	| ns |	^( ns := self nameSpace ) == nil		ifTrue: [ nil ]		ifFalse: [ ns bindingFor: dataKey ]</body><body package="PackageCategories" selector="className">className 	^className</body><body package="PackageCategories" selector="className:">className: aString 	className := aString</body><body package="PackageCategories" selector="containingPackages">containingPackages	"Answer all the packges that contain the definition for the receiver, 	including overriden."	| owner |	( owner := self owner ) == nil		ifTrue: [ ^OrderedCollection new ].	^Registry allContainingPackagesForDataKey: dataKey owner: owner.</body><body package="PackageCategories" selector="dataKey">dataKey	^dataKey asSymbol</body><body package="PackageCategories" selector="dataKey:">dataKey: aValue	dataKey := aValue asSymbol</body><body package="PackageCategories" selector="definition">definition	| ns |	^( ns := self nameSpace ) == nil		ifTrue: [ '' ]		ifFalse: [ ns definitionOf: dataKey ifAbsent: [ '' ] ]</body><body package="PackageCategories" selector="environmentString">environmentString 	^nameSpaceName == nil		ifTrue: [ className ]		ifFalse: [ nameSpaceName ]</body><body package="PackageCategories" selector="fullClassName">fullClassName	^className</body><body package="PackageCategories" selector="fullName">fullName 	^self environmentString, '.', dataKey.</body><body package="PackageCategories" selector="key">key	^self dataKey</body><body package="PackageCategories" selector="nameSpace">nameSpace	"Answer the nameSpace the receiver belongs in.	May be a class' namespace." 		^( self environmentString asStrictReference valueOrDo: [ ^nil ] ) 		asNameSpace</body><body package="PackageCategories" selector="nameSpaceName">nameSpaceName 	^nameSpaceName</body><body package="PackageCategories" selector="nameSpaceName:">nameSpaceName: aString 	nameSpaceName := aString</body><body package="PackageCategories" selector="owner">owner	"Answer the thing the receiver belongs in."	"Is a NameSpace, or a class'" 	^self environmentString asStrictReference valueOrDo: [ nil ]</body><body package="PackageCategories" selector="ownerName">ownerName 	^nameSpaceName == nil		ifTrue: [ className ]		ifFalse: [ nameSpaceName ]</body><body package="PackageCategories" selector="protocol">protocol	^self nameSpace organization categoryOfElement: self dataKey</body><body package="PackageCategories" selector="protocol:">protocol: aValue	"data does not have a protocol."	"no-op"</body><body package="PackageCategories" selector="protocolName">protocolName	| name |	^( name := self protocol ) == nil		ifTrue: [ (#unknown &lt;&lt; #packages &gt;&gt; 'unknown') asString ]		ifFalse: [ name ]</body><body package="PackageCategories" selector="sourceCode">sourceCode	"fake it"	^self textRepresentation</body><body package="PackageCategories" selector="textRepresentation">textRepresentation	| namespace |	( namespace := self nameSpace ) isNil		ifTrue: [ ^'' ]		ifFalse: [^( namespace definitionOf: dataKey ifAbsent: [ '' ] ) ]</body><body package="PackageCategories" selector="xmlDefinition">xmlDefinition	(self nameSpace includesKey: dataKey) ifFalse: [^nil].	^(BindingReference simpleName: dataKey in: self nameSpace namedReferent)		xmlDefinition</body></methods><methods><class-id>Store.DatumDescriptor</class-id> <category>private-testing</category><body package="PackageCategories" selector="existsInImage">existsInImage	"Answer if the receiver is a valid description of data."	^self fullName asStrictReference isDefined</body></methods><methods><class-id>Store.DatumDescriptor</class-id> <category>comparing</category><body package="PackageCategories" selector="=">= aThing	^self sameAs: aThing</body><body package="PackageCategories" selector="hash">hash	^self nameSpaceName hash + self dataKey hash</body><body package="PackageCategories" selector="sameAs:">sameAs: aDatum	^aDatum sameAsImThing: self</body><body package="PackageCategories" selector="sameAsImThing:">sameAsImThing: aDatum 	| res |	self debugVersionOnly.	res := ( self nameSpaceName = aDatum nameSpaceName 		and: [ self className = aDatum className ] )		and: [ self dataKey = aDatum dataKey ].	^res</body><body package="PackageCategories" selector="sourceMatches:">sourceMatches: aDatum 	"Answer wheter the source matches."	"Note: since protocol is part of the definition, we don't need to check it."	^self definition equalsAcrossPlatforms: aDatum definition</body></methods><methods><class-id>Store.DatumDescriptor</class-id> <category>private</category><body package="PackageCategories" selector="fileOutOn:">fileOutOn: aSourceCodeStream		| env str |	str := ((#NoSouceForC1s &lt;&lt; #packages &gt;&gt; 'No souce for: &lt;1s&gt;')			expandMacrosWith: self fullName).	( env := self nameSpace ) == nil		ifTrue: [ ^Dialog warn: str ].	( env asNameSpace includesKey: dataKey )		ifFalse: [^Dialog warn: str].	aSourceCodeStream storeObjectDefinition: (env asNameSpace fullyQualifiedReferenceOf: dataKey).	self fullName asStrictReference fileOutInitializerOn: aSourceCodeStream.</body><body package="PackageCategories" selector="loadSrcIntoPackage:confirm:">loadSrcIntoPackage: imPkg confirm: aBoolean	"Do nothing since I'm already in the image."</body></methods><methods><class-id>Store.DatumDescriptor</class-id> <category>bogus</category><body package="PackageCategories" selector="forDbPackage">forDbPackage	"Answer an array with a first element being a namespace and second	being a dataKey. This method is used for the DB package creation."	^Array with: self nameSpace with: dataKey</body></methods><methods><class-id>Store.DatumDescriptor class</class-id> <category>instance creation</category><body package="PackageCategories" selector="fromDataKey:class:">fromDataKey: dataKey class: aClass	^self fromDataKey: dataKey className: aClass absoluteName.</body><body package="PackageCategories" selector="fromDataKey:className:">fromDataKey: dataKey className: aName	^self new		dataKey: dataKey; 		className: aName;		yourself.</body><body package="PackageCategories" selector="fromDataKey:nameSpace:">fromDataKey: dataKey nameSpace: namespace	^self fromDataKey: dataKey nameSpaceName: namespace absoluteName.</body><body package="PackageCategories" selector="fromDataKey:nameSpaceName:">fromDataKey: dataKey nameSpaceName: nameSpaceName	^self new		dataKey: dataKey; 		nameSpaceName: nameSpaceName;		yourself.</body><body package="PackageCategories" selector="fromDataKey:owner:">fromDataKey: dataKey owner: anOwner	^anOwner isBehavior		ifTrue: [ self fromDataKey: dataKey class: anOwner ]		ifFalse: [ self fromDataKey: dataKey nameSpace: anOwner ].</body></methods><methods><class-id>Store.MethodDescriptor</class-id> <category>printing</category><body package="PackageCategories" selector="asMethodString">asMethodString	| string |	string := ( SystemUtils convertAbsoluteNameToFull: self className ), ' '.	self isMeta		ifTrue: [ string := string, 'class  ' ].	^string, self itemString.</body><body package="PackageCategories" selector="displayString">displayString	^self itemString</body><body package="PackageCategories" selector="itemString">itemString	^self name , self versionString</body><body package="PackageCategories" selector="printOn:">printOn: aStream	 	aStream nextPutAll: self classNameWithMeta; 			nextPutAll: '&gt;&gt;'; 			nextPutAll: self protocolName; 			nextPutAll: '&gt;&gt;';			nextPutAll: selector asString.</body><body package="PackageCategories" selector="versionString">versionString	^''</body></methods><methods><class-id>Store.MethodDescriptor</class-id> <category>accessing browser</category><body package="PackageCategories" selector="asString">asString	^self name.</body><body package="PackageCategories" selector="name">name 	^self selector asString</body></methods><methods><class-id>Store.MethodDescriptor</class-id> <category>accessing</category><body package="PackageCategories" selector="absoluteClassName">absoluteClassName	^fullClassName</body><body package="PackageCategories" selector="className">className	^fullClassName</body><body package="PackageCategories" selector="classNameWithMeta">classNameWithMeta	^self isMeta		ifTrue: [ self fullClassName fullMetaName]		ifFalse: [  self fullClassName ].</body><body package="PackageCategories" selector="containingPackages">containingPackages	"Answer all the packges that contain the definition for the receiver, 	including overriden."	| cls |	( cls := self implementingClass ) == nil		ifTrue: [ ^OrderedCollection new ].	^Registry allContainingPackagesForSelector: selector class: cls.</body><body package="PackageCategories" selector="definition">definition	^self sourceCode</body><body package="PackageCategories" selector="fullClassName">fullClassName	^fullClassName</body><body package="PackageCategories" selector="fullClassName:">fullClassName: aString	aString namesMetaClass ifTrue: [ self notify: #InvalidClassName &lt;&lt; #packages &gt;&gt; 'Invalid class name'  ].	fullClassName := aString</body><body package="PackageCategories" selector="fullName">fullName	^fullClassName, '&gt;&gt;', self name</body><body package="PackageCategories" selector="implementingClass">implementingClass	^self myClass</body><body package="PackageCategories" selector="meta:">meta: aBoolean	meta := aBoolean</body><body package="PackageCategories" selector="method">method	| cls |	( cls := self myClass ) == nil		ifTrue: [ ^nil ].	^cls compiledMethodAt: selector ifAbsent: [ nil ]</body><body package="PackageCategories" selector="methodSources">methodSources	| mClass |	^[ ( mClass := self myClass ) isNil		ifTrue: [ MethodSourceCollection source: (#NonexistentClass &lt;&lt; #packages &gt;&gt; 'Non-existent class') asString ]		ifFalse: [ mClass methodSourcesAt: selector ]	] on: KeyNotFoundError do:		[ :e | e return: (MethodSourceCollection source: (#SourceUnavailable &lt;&lt; #packages &gt;&gt; 'Source unavailable.') asString) ].</body><body package="PackageCategories" selector="myClass">myClass	| cls |	cls := self fullClassName asStrictReference valueOrDo: [ ^nil ].	^self isMeta ifTrue: [ cls class ] ifFalse: [ cls ].</body><body package="PackageCategories" selector="owner">owner	| cls |	cls := self fullClassName asStrictReference valueOrDo: [ ^nil ].	^self isMeta ifTrue: [ cls class ] ifFalse: [ cls ].</body><body package="PackageCategories" selector="ownerName">ownerName	^fullClassName</body><body package="PackageCategories" selector="protocol">protocol	"Do lazy evaluation of protocol name, since method may not	have been installed in class when a change is registered." 	protocol isNil ifTrue: [self protocol: (self classFromClassName organization categoryOfElement: selector)].	^protocol</body><body package="PackageCategories" selector="protocol:">protocol: aValue	protocol := aValue</body><body package="PackageCategories" selector="protocolName">protocolName	self protocol isNil ifTrue: [^''].	^self protocol asString</body><body package="PackageCategories" selector="selector">selector	^selector</body><body package="PackageCategories" selector="selector:">selector: aValue	selector := aValue</body><body package="PackageCategories" selector="sourceCode">sourceCode	| mClass |	^[ ( mClass := self myClass ) isNil		ifTrue: [ (#NonexistentClass &lt;&lt; #packages &gt;&gt; 'Non-existent class') asString ]		ifFalse: [ ( mClass sourceCodeAt: selector ) ifNil: [ (#SourceUnavailable &lt;&lt; #packages &gt;&gt; 'Source unavailable.') asString ] ]	] on: KeyNotFoundError do:		[ :e | e return: (#SourceUnavailable &lt;&lt; #packages &gt;&gt; 'Source unavailable.') asString ].</body><body package="PackageCategories" selector="stDocumentation">stDocumentation	^self compiledMethod stDocumentation</body></methods><methods><class-id>Store.MethodDescriptor</class-id> <category>testing</category><body package="PackageCategories" selector="hasMethod">hasMethod	^self method notNil</body><body package="PackageCategories" selector="isForMethod">isForMethod			^true</body><body package="PackageCategories" selector="isMeta">isMeta	^meta</body></methods><methods><class-id>Store.MethodDescriptor</class-id> <category>private-testing</category><body package="PackageCategories" selector="existsInImage">existsInImage	"Answer true if the receiver is a valid description of an existing method."	| class prot |	( class := self myClass ) == nil ifTrue: [ ^false ].	prot := class organization categoryOfElement: self selector.	prot isNil ifTrue: [ ^false ].	prot ~= self protocol ifTrue: [ ^false ].	^true</body></methods><methods><class-id>Store.MethodDescriptor</class-id> <category>comparing</category><body package="PackageCategories" selector="=">= aThing	^self sameAs: aThing</body><body package="PackageCategories" selector="comparesTo:">comparesTo: anObject	"Answer true if anObject could be another version of the receiver."	( self objectIsForSelf: anObject ) ifFalse: [ ^false ].	^( anObject selector = selector ) and:		[ anObject classNameWithMeta = self classNameWithMeta ]</body><body package="PackageCategories" selector="hash">hash	^self fullClassName hash + self selector hash</body><body package="PackageCategories" selector="objectIsForSelf:">objectIsForSelf: anObject	"Answer true if anObject represents the same kind of thing as the reciever."	^anObject isForMethod</body><body package="PackageCategories" selector="sameAs:">sameAs: aMethod	"Browsers are only interested in the selector...."	aMethod isSymbol ifTrue: [ ^selector == aMethod ].	aMethod isForData		ifTrue: [ ^false ].	^aMethod sameAsImThing: self</body><body package="PackageCategories" selector="sameAsImThing:">sameAsImThing: aMethod 	aMethod isForData ifTrue: [ ^false ].	^self classNameWithMeta = aMethod classNameWithMeta 		and: [ self selector = aMethod selector ].</body><body package="PackageCategories" selector="sourceMatches:">sourceMatches: aMethod	"Answer wheter the source matches."	^( self protocol = aMethod protocol 		and: [ self sourceCode equalsAcrossPlatforms: aMethod sourceCode ] )</body></methods><methods><class-id>Store.MethodDescriptor</class-id> <category>private</category><body package="PackageCategories" selector="classFromClassName">classFromClassName	"className is either a class name or a class name followed by ' class'.  Answer the class or metaclass it names.  Changed to use meta var- DS" 	| class |	class := fullClassName asStrictReference valueOrDo: 		[ self error: (#CannotFindClass &lt;&lt; #packages &gt;&gt; 'Cannot find class'). ^nil ].	^meta		ifTrue: [ class class ]		ifFalse: [ class ]</body><body package="PackageCategories" selector="compiledMethod">compiledMethod	"Answer the compiled method"	| mclass |	mclass := self myClass.	mclass isNil		ifTrue: 			[self error: (#MethodRefersToBogusClass &lt;&lt; #packages &gt;&gt; 'Method refers to non existing class').			^self].	^mclass compiledMethodAt: self selector.</body><body package="PackageCategories" selector="fileOutOn:">fileOutOn: aSourceCodeStream		| d |	d := Dictionary new.	d at: self protocol put: ( Set with: self ).	aSourceCodeStream fileOutTTMessages: d for: self classNameWithMeta logging: true.</body><body package="PackageCategories" selector="loadAsNew">loadAsNew	"Do nothing since I'm already in the image."	^true</body><body package="PackageCategories" selector="loadSrcIntoPackage:confirm:">loadSrcIntoPackage: imPkg confirm: aBoolean	"Do nothing since I'm already in the image."</body></methods><methods><class-id>Store.MethodDescriptor</class-id> <category>bogus</category><body package="PackageCategories" selector="forDbPackage">forDbPackage	"Answer an array with a first element being a class and second	being a selector. This method is used for the DB package creation."	^Array with: self myClass with: selector</body></methods><methods><class-id>Store.MethodDescriptor</class-id> <category>utils</category><body package="PackageCategories" selector="isMetaclassMethod">isMetaclassMethod	"Answer true if the class is meta class"	^meta</body></methods><methods><class-id>Store.MethodDescriptor class</class-id> <category>instance creation</category><body package="PackageCategories" selector="fromSelector:class:">fromSelector: aSelector class: class 	^self new		selector: aSelector; 		protocol: (class organization categoryOfElement: aSelector); 		fullClassName: class  absoluteName asClassNameOnly;		meta: class isMeta;		yourself.</body><body package="PackageCategories" selector="fromSelector:className:meta:">fromSelector: aSelector className: className meta: boolean  	^self new		selector: aSelector; 		fullClassName: className asClassNameOnly;		meta: boolean;		yourself</body></methods><methods><class-id>Store.ClassDescriptor</class-id> <category>comparing</category><body package="PackageCategories" selector="&lt;=">&lt;= aClassDescriptor	^self absoluteName &lt;= aClassDescriptor absoluteName</body><body package="PackageCategories" selector="=">= aThing	^self sameAs: aThing</body><body package="PackageCategories" selector="comparesTo:">comparesTo: anObject	"Answer true if anObject could be another version of the receiver."	( self objectIsForSelf: anObject ) ifFalse: [ ^false ].	anObject isMeta = self isMeta		ifFalse: [ ^false ].	^anObject absoluteName asClassNameOnly = self absoluteName.</body><body package="PackageCategories" selector="hash">hash	^self fullName hash</body><body package="PackageCategories" selector="objectIsForSelf:">objectIsForSelf: anObject	"Answer true if anObject represents the same kind of thing as the reciever."	^anObject isForClass</body><body package="PackageCategories" selector="sameAsImThing:">sameAsImThing:  aClass	^aClass absoluteName = self absoluteName</body><body package="PackageCategories" selector="sameName:">sameName: aString	"Answer true if aString is the same name as the receiver."	| string |	string := aString namesMetaClass 		ifTrue: 			[ self isMeta ifFalse: [ ^false ].			aString classNameOnly			]		ifFalse: 			[ self isMeta ifTrue: [ ^false ]. 			aString			].	^string = self absoluteName</body></methods><methods><class-id>Store.ClassDescriptor</class-id> <category>accessing</category><body package="PackageCategories" selector="absoluteName">absoluteName	^self fullClassName</body><body package="PackageCategories" selector="absoluteSymbol">absoluteSymbol	^self absoluteName asSymbol</body><body package="PackageCategories" selector="actual">actual	"Answer the class in the image that the reciever represents. nil if none."	^self fullClassName asStrictReference ifDefinedDo: 		[ :cls | self isMeta 					ifTrue: [ cls class ]					ifFalse: [ cls ].		].</body><body package="PackageCategories" selector="classNameWithMeta">classNameWithMeta	^meta		ifTrue: [ self fullClassName fullMetaName ]		ifFalse: [  self fullClassName ].</body><body package="PackageCategories" selector="comment">comment	| cl |	(cl := self myClass) isNil		ifTrue: [ ^'' ]		ifFalse: [ ^cl instanceBehavior comment ]</body><body package="PackageCategories" selector="definition">definition	| cl |	(cl := self myClass) isNil		ifTrue: [^'']		ifFalse: [^cl definition]</body><body package="PackageCategories" selector="environment">environment	^self actual environment</body><body package="PackageCategories" selector="existsInImage">existsInImage	^( self myClass == nil ) not</body><body package="PackageCategories" selector="fullClassName">fullClassName	^self fullName</body><body package="PackageCategories" selector="fullClassName:">fullClassName: aString	aString namesMetaClass 		ifTrue: [ self meta: true ].	fullClassName := aString asClassNameOnly</body><body package="PackageCategories" selector="fullName">fullName		^fullClassName isNil ifTrue: [''] ifFalse: [fullClassName]</body><body package="PackageCategories" selector="meta:">meta: aBoolean	meta := aBoolean</body><body package="PackageCategories" selector="name">name	"Answer the receiver's simple name."	^cachedName isNil		ifTrue: [cachedName := (self fullName tokensBasedOn: $.) last]		ifFalse: [cachedName]</body><body package="PackageCategories" selector="realname">realname	^self fullName</body><body package="PackageCategories" selector="superclass">superclass	"Answer the superclass of the receiver in the image. nil if none."	| cls |	^( cls := self actual ) == nil		ifFalse: [ cls superclass ]</body><body package="PackageCategories" selector="symbol">symbol	^self absoluteSymbol</body><body package="PackageCategories" selector="textRepresentationForTag:">textRepresentationForTag: aTag 	^aTag isClassCommentTag		ifTrue: [ self comment ]		ifFalse: [ self definition ]</body><body package="PackageCategories" selector="xmlDefinition">xmlDefinition	| cl |	(cl := self myClass) isNil		ifTrue: [^'']		ifFalse: [^cl xmlDefinition]</body></methods><methods><class-id>Store.ClassDescriptor</class-id> <category>testing</category><body package="PackageCategories" selector="isForClass">isForClass	^true</body><body package="PackageCategories" selector="isMeta">isMeta	^meta</body></methods><methods><class-id>Store.ClassDescriptor</class-id> <category>browser support</category><body package="PackageCategories" selector="asNameSpace">asNameSpace	^self actual asNameSpace</body><body package="PackageCategories" selector="asString">asString	^self simpleName</body><body package="PackageCategories" selector="binding">binding	"Answer a binding for the class in the system if it exists, otherwise just answer the receiver (which pretends to be a binding)."	| ref |	^( ref := self fullName asStrictReference ) isDefined 		ifTrue: [ ref binding ]		ifFalse: [ self ]."	^self "</body><body package="PackageCategories" selector="classifySymbol:under:">classifySymbol: varName under: protocol	^self value classifySymbol: varName under: protocol</body><body package="PackageCategories" selector="containingPackages">containingPackages	"Answer all the packges that contain the definition for the receiver, 	including overriden."	^Registry allContainingPackagesForClassOrNameSpace: self actual</body><body package="PackageCategories" selector="organization">organization	^self value organization</body><body package="PackageCategories" selector="renameCategory:to:">renameCategory: oldCategory to: newCategory	^self value renameCategory: oldCategory to: newCategory</body><body package="PackageCategories" selector="reorganize">reorganize	self actual reorganize</body><body package="PackageCategories" selector="selectors">selectors	^self actual selectors</body><body package="PackageCategories" selector="simpleName">simpleName	^self name</body><body package="PackageCategories" selector="value">value	"Implemented by any subclass wanting to be displayed in a browser"	^self myClass</body><body package="PackageCategories" selector="valueOrDo:">valueOrDo: aBlock 	"Implemented by any subclass wanting to be displayed in a browser"	^self myClass</body><body package="PackageCategories" selector="withAllSuperclasses">withAllSuperclasses	^self actual withAllSuperclasses</body></methods><methods><class-id>Store.ClassDescriptor</class-id> <category>printing</category><body package="PackageCategories" selector="displayString">displayString		^meta 		ifTrue: [ self name fullMetaName ]		ifFalse: [ self name ]</body><body package="PackageCategories" selector="instanceBehavior">instanceBehavior	"Give a class name answer a class."	^self fullClassName asStrictReference valueOrDo: [ nil ]</body><body package="PackageCategories" selector="printOn:">printOn: aStream	aStream nextPutAll: self class name, '(', 		( SystemUtils convertAbsoluteNameToFull: fullClassName ) , ')'.</body></methods><methods><class-id>Store.ClassDescriptor</class-id> <category>filing out</category><body package="PackageCategories" selector="fileOutSourceOn:">fileOutSourceOn: aStream	"File the receiver out on aSourceFileManager."	self actual == nil		ifFalse: [ self actual fileOutSourceOn: aStream ].</body></methods><methods><class-id>Store.ClassDescriptor class</class-id> <category>instance creation</category><body package="PackageCategories" selector="fromModel:">fromModel: aClassModel	^self fullName: aClassModel absoluteName meta: false "aClassModel isMeta."</body><body package="PackageCategories" selector="fullName:meta:">fullName: aName meta: aBoolean	^self new		fullClassName: aName;		meta: aBoolean;		yourself.</body></methods><methods><class-id>Store.ClassExtensionDescriptor</class-id> <category>testing</category><body package="PackageCategories" selector="isExtension">isExtension	^true</body></methods><methods><class-id>Store.ClassExtensionDescriptor</class-id> <category>accessing</category><body package="PackageCategories" selector="definition">definition		^super definition."	^'This class is not defined in this package'"</body><body package="PackageCategories" selector="xmlDefinition">xmlDefinition		^super xmlDefinition."	^'This class is not defined in this package'"</body></methods><methods><class-id>Store.ClassExtensionDescriptor</class-id> <category>printing</category><body package="PackageCategories" selector="itemString">itemString	^self name</body></methods><methods><class-id>Store.DefClassModel</class-id> <category>testing</category><body package="PackageCategories" selector="existsInImage">existsInImage	^fullClassSymbol asStrictReference isDefined</body><body package="PackageCategories" selector="hasDefinition">hasDefinition	^true</body><body package="PackageCategories" selector="isClassModel">isClassModel	^true</body><body package="PackageCategories" selector="isEmpty">isEmpty	"Is this class model holding onto nothing?"	"We have a definition so we cannot be."	^false</body><body package="PackageCategories" selector="isExtension">isExtension	^false</body><body package="PackageCategories" selector="isForClass">isForClass			^true</body></methods><methods><class-id>Store.DefClassModel</class-id> <category>consistency checking</category><body package="PackageCategories" selector="checkConsistencyOn:">checkConsistencyOn: aStream 	| pcm pkg class |	pcm := self package classModelAtClassSymbol: self fullClassSymbol ifAbsent: [nil].	pcm isNil		ifTrue: 			[aStream nextPutAll: ((#classModelNotInPackage &lt;&lt; #packages &gt;&gt; 'class model "&lt;1s&gt;" not in package "&lt;2p&gt;"  it references: ')				expandMacrosWith: self fullClassSymbol				with: self package).			^aStream cr].	pcm == self		ifFalse: 			[aStream nextPutAll: ((#classModelDifferentThanInPackage &lt;&lt; #packages &gt;&gt; 'class model "&lt;1s&gt;" is not the same as in package "&lt;2p&gt;"  it references: ')				expandMacrosWith: self fullClassSymbol				with: self package).			^aStream cr].	pkg := Registry packageNamed: self package name.	pkg isNil		ifTrue: 			[aStream nextPutAll: ((#classModelRefersToUnloadedPackage &lt;&lt; #packages &gt;&gt; 'class model "&lt;1s&gt;" refers to package "&lt;2p&gt;" which is not loaded')				expandMacrosWith: self fullClassSymbol				with: self package).			^aStream cr].	pkg == self package		ifFalse: 			[aStream nextPutAll: ((#classModelRefersToDifferentPackage &lt;&lt; #packages &gt;&gt; 'class model "&lt;1s&gt;" refers to package "&lt;2p&gt;" which is different from the loaded package')				expandMacrosWith: self fullClassSymbol				with: self package).			^aStream cr].	class := self fullClassSymbol asStrictReference valueOrDo: [nil].	class isNil		ifTrue: 			["class printOn: 	aStream.aStream cr."			aStream nextPutAll: ((#classModelRefersToNonloadedClass &lt;&lt; #packages &gt;&gt; 'class model "&lt;1s&gt;" in package "&lt;2p&gt;" refers to non-loaded class')				expandMacrosWith: self fullClassSymbol				with: self package).			^aStream cr].	self isExtension 		ifTrue: 			[ self classAndSelectorDo: 				[:cls :sel | 				cls compiledMethodAt: sel ifAbsent: 						[aStream nextPutAll: (#classModelRefersToNonloadedSelector &lt;&lt; #packages &gt;&gt; 'class "&lt;1p&gt;" in package "&lt;2p&gt;" refers to non-loaded selector "&lt;3s&gt;"'							expandMacrosWith: cls							with: self package							with: sel).						aStream cr						]				].		 	self dataKeys do:				[ :key |				( class asNameSpace includesDataKey:key )					ifFalse: 						[ aStream nextPutAll: (#namespaceRefersToNonloadedDataKey &lt;&lt; #packages &gt;&gt; 'namespace "&lt;1p&gt;" in package "&lt;2p&gt;" refers to non-loaded datakey "&lt;3s&gt;"'							expandMacrosWith: class							with: self package							with: key).							aStream cr						]				]		].</body></methods><methods><class-id>Store.DefClassModel</class-id> <category>printing</category><body package="PackageCategories" selector="displayString">displayString	^self name</body><body package="PackageCategories" selector="printOn:">printOn: aStream	aStream nextPutAll: 'CM:'.	aStream nextPutAll: self fullName.	aStream nextPutAll: ':'.	aStream nextPutAll: self package name.</body></methods><methods><class-id>Store.DefClassModel</class-id> <category>accessing</category><body package="PackageCategories" selector="asDescription">asDescription	^ClassDescriptor fromModel: self</body><body package="PackageCategories" selector="cloneFrom:">cloneFrom: aClassModel	"Copy all our selectors and data from another class model"	"We don't care about selectors or data"</body><body package="PackageCategories" selector="fileOutObjectType">fileOutObjectType	^#class</body><body package="PackageCategories" selector="name">name	^self fullName asStrictReference simpleName</body><body package="PackageCategories" selector="package">package	^package</body><body package="PackageCategories" selector="package:">package: ourPackage	package := ourPackage</body></methods><methods><class-id>Store.DefClassModel</class-id> <category>private</category><body package="PackageCategories" selector="systemDataKeys">systemDataKeys	^( self actualClassMeta: false ) dataKeys</body><body package="PackageCategories" selector="systemSelectorsMeta:">systemSelectorsMeta: isMeta 	^(self actualClassMeta: isMeta) selectors</body></methods><methods><class-id>Store.DefClassModel</class-id> <category>class accessing</category><body package="PackageCategories" selector="absoluteName">absoluteName	^self fullName</body><body package="PackageCategories" selector="absoluteSymbol">absoluteSymbol	^fullClassSymbol</body><body package="PackageCategories" selector="actual">actual	^self actualClass</body><body package="PackageCategories" selector="actualClass">actualClass	^self actualClassMeta: false</body><body package="PackageCategories" selector="actualClassMeta:">actualClassMeta: isMeta 	| class |	class := fullClassSymbol asStrictReference valueOrDo:			[ ( UnloadedObjectError class: fullClassSymbol ) raiseSignal. ^nil ].	^isMeta		ifTrue: [ class class ]		ifFalse: [ class ]</body><body package="PackageCategories" selector="classNameMeta:">classNameMeta: isMeta	^fullClassSymbol asString, (isMeta ifTrue: [' class'] ifFalse: [''])</body><body package="PackageCategories" selector="fullClassSymbol">fullClassSymbol	^fullClassSymbol</body><body package="PackageCategories" selector="fullClassSymbol:">fullClassSymbol: aSymbol	fullClassSymbol := aSymbol</body><body package="PackageCategories" selector="fullName">fullName	^fullClassSymbol asString</body><body package="PackageCategories" selector="fullName:">fullName: aString	^fullClassSymbol := aString asSymbol</body><body package="PackageCategories" selector="fullSymbol:">fullSymbol: aSymbol	fullClassSymbol := aSymbol</body></methods><methods><class-id>Store.DefClassModel</class-id> <category>data accessing</category><body package="PackageCategories" selector="addDataKey:">addDataKey: aDataKey	"It's not our problem to track data."	"Well.... it is under a very special circumstance. 	When a parcel is loading and my package overrode this class, some of my subdefs 	were put into the original classes' package and we have to reclaim them."	| pkg owner |	owner :=  self actual.	( pkg := Registry containingPackageForDataKey: aDataKey symbol: owner absoluteSymbol ) = self package		ifTrue: [ ^nil ].		"ok, its already ours"	pkg == nil		ifTrue: [ ^nil ].	pkg relinquishDataKey: aDataKey owner: owner.</body><body package="PackageCategories" selector="classAndDataKeyDo:">classAndDataKeyDo: aBlock 	"For each pair of the class and its datakeys, evaluate aBlock."	| actual |	actual := self actualClass.	self dataKeys copy do: 		[ :dataKey | aBlock value: actual value: dataKey].</body><body package="PackageCategories" selector="dataKeys">dataKeys	^self systemDataKeys select: 		[ :selector | self quickIncludesDataKey: selector ]</body><body package="PackageCategories" selector="dataKeysDo:">dataKeysDo: aBlock	self dataKeys do: aBlock</body><body package="PackageCategories" selector="datumDescriptorForDataKey:">datumDescriptorForDataKey: dataKey	 	^DatumDescriptor fromDataKey: dataKey className: self absoluteName."	^( self dataKeys includes: dataKey )		ifTrue: [ DatumDescriptor fromDataKey: dataKey className: self absoluteName ]		ifFalse: [ nil ]"</body><body package="PackageCategories" selector="datumDescriptors">datumDescriptors		| clsname |	clsname := self absoluteName.	^self dataKeys asSortedCollection asOrderedCollection collect: 		[ :dataKey | 		DatumDescriptor fromDataKey: dataKey className: clsname 		]</body><body package="PackageCategories" selector="includesDataKey:">includesDataKey: dataKey	^[ ( ( Registry quickContainingPackageForDataKey: dataKey		symbol: fullClassSymbol	 ) == package ) 	and: [ ( self actualClassMeta: false) includesDataKey: dataKey ]	] on: UnloadedObjectError do: 		[: exp | exp return: false ].</body><body package="PackageCategories" selector="ownerDataKeyPairs">ownerDataKeyPairs	|  pairs |	pairs := OrderedCollection new.	self classAndDataKeyDo: 		[ :cls :dataKey |			pairs add: ( Array with: cls with: dataKey )		].	^pairs</body><body package="PackageCategories" selector="protocols">protocols	^( self datumDescriptors collect: 		[ :d | d protocol ] 	 ) asSet asOrderedCollection.</body><body package="PackageCategories" selector="quickIncludesDataKey:">quickIncludesDataKey: dataKey	"For when you know dataKey is loaded"	^( Registry quickContainingPackageForDataKey: dataKey symbol: fullClassSymbol	) 			== package</body><body package="PackageCategories" selector="removeDataKey:">removeDataKey: dataKey	"It isn't our problem to track this stuff"	"well... maybe if we were overridden"</body></methods><methods><class-id>Store.DefClassModel</class-id> <category>selector accessing</category><body package="PackageCategories" selector="addSelector:meta:">addSelector: aSelector meta: isMeta 	"It's not our problem to track selectors."	"Well.... it is under a very special circumstance. 	When a parcel is loading and my package overrode this class, some of my selectors 	were put into the original classes' package and we have to reclaim them."	| pkg cls |	cls :=  self actualClassMeta: isMeta.	( pkg := Registry containingPackageForSelector: aSelector class: cls ) = self package		ifTrue: [ ^nil ].		"ok, its already ours"	pkg == nil		ifTrue: [ ^nil ].	pkg relinquishSelector: aSelector class: cls.</body><body package="PackageCategories" selector="classAndSelectorDo:">classAndSelectorDo: aBlock 	"For each pair of the class and its selectors and the meta class and its selectors	evaluate aBlock."	| actual |	actual := self actualClassMeta: false.	(self selectorsMeta: false) copy		do: [:selector | aBlock value: actual value: selector].	actual := self actualClassMeta: true.	(self selectorsMeta: true) copy		do: [:selector | aBlock value: actual value: selector]</body><body package="PackageCategories" selector="classNameAndSelectorDo:">classNameAndSelectorDo: aBlock 	"For each pair of the class and its selectors and the meta class and its selectors	evaluate aBlock."	| className |	className := self classNameMeta: false.	(self selectorsMeta: false)		do: [:selector | aBlock value: className value: selector].	className := self classNameMeta: true.	(self selectorsMeta: true)		do: [:selector | aBlock value: className value: selector]</body><body package="PackageCategories" selector="classSelectorPairs">classSelectorPairs	|  pairs |	pairs := OrderedCollection new.	self classAndSelectorDo: [:class :selector|		pairs add: (Array with: class with: selector)].	^pairs</body><body package="PackageCategories" selector="compiledMethods">compiledMethods		| comp |	comp := OrderedCollection new.	self classAndSelectorDo: [:class :selector|		comp add: (class compiledMethodAt: selector)].	^comp</body><body package="PackageCategories" selector="includesSelector:meta:">includesSelector: aSelector meta: isMeta 	^[ ((Registry		quickContainingPackageForSelector: aSelector		classSymbol: fullClassSymbol		meta: isMeta) == package) 	and: [(self actualClassMeta: isMeta) includesSelector: aSelector]	] on: UnloadedObjectError do: 		[: exp | exp return: false ].</body><body package="PackageCategories" selector="methodDescriptorForSelector:meta:">methodDescriptorForSelector: aSelector meta: isMeta	"Answer a method descriptor for aSelector."	"Shouldn't be asking if you don't know it's there."		^MethodDescriptor fromSelector: aSelector className: self absoluteName meta: isMeta</body><body package="PackageCategories" selector="methods">methods	^( self methodsMeta: true ), ( self methodsMeta: false )</body><body package="PackageCategories" selector="methodsForProtocol:meta:">methodsForProtocol: aProtocolName meta: isMeta 	| actual |	actual := self actualClassMeta: isMeta.	^( ( actual organization listAtCategoryNamed: aProtocolName) select: 			[ :selector | self quickIncludesSelector: selector meta: isMeta ]	 ) asSortedCollection asOrderedCollection 		collect: 			[:sel | 			MethodDescriptor 				fromSelector: sel 				className: actual absoluteName 				meta: isMeta 			]</body><body package="PackageCategories" selector="methodsMeta:">methodsMeta: isMeta		| cname |	cname := self classNameMeta: isMeta.	^(self selectorsMeta: isMeta)		asSortedCollection 			asOrderedCollection				collect: [:sel| MethodDescriptor fromSelector: sel className: cname meta: isMeta ]</body><body package="PackageCategories" selector="protocolsMeta:">protocolsMeta: isMeta 	| actual | 	actual := self actualClassMeta: isMeta .	^actual organization categories 		select: [:proto | ((actual organization listAtCategoryNamed: proto)			detect: [:selector | self quickIncludesSelector: selector meta: isMeta] 			ifNone: [nil]) notNil]</body><body package="PackageCategories" selector="quickIncludesSelector:meta:">quickIncludesSelector: aSelector meta: isMeta 	"For when you know 'aSelector' is loaded"	^(Registry		quickContainingPackageForSelector: aSelector		classSymbol: fullClassSymbol		meta: isMeta) == package</body><body package="PackageCategories" selector="removeSelector:meta:">removeSelector: aSelector meta: isMeta	"It isn't our problem to track this stuff"	"well... maybe if we were overridden"</body><body package="PackageCategories" selector="selectorsMeta:">selectorsMeta: isMeta 	^( self systemSelectorsMeta: isMeta ) select: 		[:selector | self quickIncludesSelector: selector meta: isMeta ]</body></methods><methods><class-id>Store.DefClassModel</class-id> <category>browser support</category><body package="PackageCategories" selector="binding">binding	^self"		| ref |	^( ref := self fullName asQualifiedReference ) isDefined 		ifTrue: [ ref binding ]		ifFalse: [ nil ]."</body><body package="PackageCategories" selector="containingPackages">containingPackages	"Answer all the packges that contain the definition for the receiver, 	including overriden."	^Registry allContainingPackagesForClassOrNameSpace: self actual</body><body package="PackageCategories" selector="selectors">selectors	^self actual selectors</body><body package="PackageCategories" selector="value">value	"Implemented by any subclass wanting to be displayed in a browser"	^self actualClass</body></methods><methods><class-id>Store.DefClassModel</class-id> <category>private-unloading</category><body package="PackageCategories" selector="unloadAllDataKeys">unloadAllDataKeys	"Before unloading the receiver- Unload all the receiver's data keys from the system."	| actual |	actual := self actual.	self dataKeys do:		[ :key | 	Override unloadDataKey: key in: actual from: package ].</body><body package="PackageCategories" selector="unloadAllSelectors">unloadAllSelectors	| affectedClasses |	affectedClasses := Set new.	self existsInImage ifFalse: [ ^affectedClasses ].		"validation"	self classSelectorPairs do: 		[ :pair | 		Override unloadSelector: pair last class: pair first from: package.		affectedClasses add: pair first.		].	^affectedClasses</body></methods><methods><class-id>Store.DefClassModel class</class-id> <category>instance creation</category><body package="PackageCategories" selector="package:fullClassSymbol:">package: ourPackage fullClassSymbol: aClassSymbol	^self new package: ourPackage; fullClassSymbol: aClassSymbol.</body><body package="PackageCategories" selector="package:fullSymbol:">package: ourPackage fullSymbol: aClassSymbol	^self new package: ourPackage; fullClassSymbol: aClassSymbol.</body></methods><methods><class-id>Store.ExtensionClassModel</class-id> <category>selector accessing</category><body package="PackageCategories" selector="addSelector:meta:">addSelector: aSelector meta: isMeta	(self privateWritableSelectorsMeta: isMeta) add: aSelector</body><body package="PackageCategories" selector="includesSelector:meta:">includesSelector: aSelector meta: isMeta	^(self selectorsMeta: isMeta) includes: aSelector</body><body package="PackageCategories" selector="quickIncludesSelector:meta:">quickIncludesSelector: aSelector meta: isMeta	^(self selectorsMeta: isMeta) includes: aSelector</body><body package="PackageCategories" selector="removeSelector:meta:">removeSelector: aSelector meta: isMeta	super removeSelector: aSelector meta: isMeta.	(self privateWritableSelectorsMeta: isMeta) remove: aSelector ifAbsent: []</body><body package="PackageCategories" selector="selectorsMeta:">selectorsMeta: isMeta 	^isMeta		ifTrue: [metaSelectors isNil				ifTrue: [#()]				ifFalse: [metaSelectors]]		ifFalse: [selectors isNil				ifTrue: [#()]				ifFalse: [selectors]]</body></methods><methods><class-id>Store.ExtensionClassModel</class-id> <category>data accessing</category><body package="PackageCategories" selector="addDataKey:">addDataKey: aDataKey	self privateData add: aDataKey</body><body package="PackageCategories" selector="dataKeys">dataKeys	^data == nil		ifTrue: [ IdentitySet new ]		ifFalse: [ data ]</body><body package="PackageCategories" selector="includesDataKey:">includesDataKey: dataKey	^self dataKeys includes: dataKey</body><body package="PackageCategories" selector="quickIncludesDataKey:">quickIncludesDataKey: dataKey	^self includesDataKey: dataKey</body><body package="PackageCategories" selector="removeDataKey:">removeDataKey: dataKey	super removeDataKey: dataKey.	data == nil ifTrue: [ ^self ].	self privateData remove: dataKey ifAbsent: [ ]</body></methods><methods><class-id>Store.ExtensionClassModel</class-id> <category>testing</category><body package="PackageCategories" selector="hasDefinition">hasDefinition	^false</body><body package="PackageCategories" selector="isEmpty">isEmpty	"Is this class model holding onto nothing?"	^( selectors size = 0 )  &amp;  ( metaSelectors size = 0 ) &amp;  ( data size = 0 )</body><body package="PackageCategories" selector="isExtension">isExtension	^true</body></methods><methods><class-id>Store.ExtensionClassModel</class-id> <category>printing</category><body package="PackageCategories" selector="printOn:">printOn: aStream	aStream nextPutAll: 'CM-EXT:'.	aStream nextPutAll: self fullName.	aStream nextPutAll: ':'.	aStream nextPutAll: self package name.</body></methods><methods><class-id>Store.ExtensionClassModel</class-id> <category>private</category><body package="PackageCategories" selector="cloneFrom:">cloneFrom: aClassModel	"Copy all our selectors and data from another class model"	| keys |	super cloneFrom: aClassModel.	#( true false ) do: 		[:isMeta | 		( aClassModel selectorsMeta: isMeta ) 			do: [ :sel | self addSelector: sel meta: isMeta ]		].	data := ( keys := aClassModel dataKeys ) isEmpty		ifTrue: [ nil ]		ifFalse: [ keys ].</body><body package="PackageCategories" selector="privateData">privateData	"Answer dataKeys defined by the receiver. Initialize the set if empty."	data isNil ifTrue: [ data := IdentitySet new ].	^data</body><body package="PackageCategories" selector="privateWritableSelectorsMeta:">privateWritableSelectorsMeta: isMeta 	"Return the list of selectors, depending on which subclass this may be 	the list of present or absent selector.  If the list is empty initialize it first"	^isMeta		ifTrue: 			[metaSelectors isNil ifTrue: [metaSelectors := IdentitySet new].			metaSelectors]		ifFalse: 			[selectors isNil ifTrue: [selectors := IdentitySet new].			selectors]</body></methods><methods><class-id>Store.XChangeSet</class-id> <category>changes</category><body package="PackageCategories" selector="addOtherChange:">addOtherChange: aChange	self other add: aChange</body><body package="PackageCategories" selector="addPropertyChange:">addPropertyChange: aSymbol	self properties add: aSymbol</body><body package="PackageCategories" selector="doChange:">doChange: change 	change isRemoveChanges 		ifTrue: [ ^self removeKey: change symbol ifAbsent: [ nil ] ].	( self createAt: change symbol forChange: change) 		doChange: change.	self removeIfEmptySymbol: change symbol</body><body package="PackageCategories" selector="doClassChange:">doClassChange: change 	change isRemoveChanges 		ifTrue: [ ^self removeKey: change classSymbol ifAbsent: [ nil ] ].	( self createForClassAt: change classSymbol ) 		doChange: change.	self removeIfEmptySymbol: change classSymbol</body><body package="PackageCategories" selector="doNameSpaceChange:">doNameSpaceChange: change 	change isRemoveChanges 		ifTrue: [ ^self removeKey: change nameSpaceSymbol ifAbsent: [ nil ] ].	( self createForNameSpaceAt: change nameSpaceSymbol )		doChange: change.	self removeIfEmptySymbol: change nameSpaceSymbol</body><body package="PackageCategories" selector="doSubdefChange:">doSubdefChange: change 	| symbol |	symbol := change classSymbol == nil		ifFalse: [ change classSymbol ]		ifTrue: [ change nameSpaceSymbol ].	(self createAt: symbol forChange: change) doSubdefChange: change.	self removeIfEmptySymbol: symbol</body><body package="PackageCategories" selector="noChanges">noChanges	self become: self class new</body><body package="PackageCategories" selector="overriddenClass:">overriddenClass: aClass	( self createForClassAt: aClass absoluteSymbol )		doChangeType: #override.	self removeIfEmptySymbol: aClass absoluteSymbol</body><body package="PackageCategories" selector="overriddenNameSpace:">overriddenNameSpace: aNameSpace	( self createForNameSpaceAt: aNameSpace absoluteSymbol )		doChangeType: #override.	self removeIfEmptySymbol: aNameSpace absoluteSymbol</body><body package="PackageCategories" selector="overriddenSelector:class:">overriddenSelector: selector class: aClass	| symbol change |	symbol := aClass instanceBehavior absoluteSymbol.	change := 		Change new 			class: aClass; 			selector: selector;			override;			yourself.	( self createAt: symbol forChange: change ) doSubdefChange: change.	self removeIfEmptySymbol: symbol</body><body package="PackageCategories" selector="overriddenStatic:in:">overriddenStatic: dataKey in: anOwner	| symbol change |	symbol := anOwner absoluteSymbol.	change := 		Change new 			actual: anOwner; 			dataKey: dataKey;			override;			yourself.	( self createAt: symbol forChange: change ) doSubdefChange: change.	self removeIfEmptySymbol: symbol</body><body package="PackageCategories" selector="reflection">reflection	"Answer a XChangeSet that is the reflection of the receiver."		| cs |	cs := self class new.	self keysAndValuesDo:		[ :key :changes |		cs at: key put: changes reflection		].	self otherOrNil == nil		ifFalse: 			[ self otherOrNil do:				[ :change | cs addOtherChange: change ].			].	self propertiesOrNil == nil		ifFalse: 			[ self propertiesOrNil do:				[ :change | cs addPropertyChange: change ].			].			^cs.</body></methods><methods><class-id>Store.XChangeSet</class-id> <category>consistency checking</category><body package="PackageCategories" selector="checkConsistencyInPackage:on:">checkConsistencyInPackage: pkg on: aStream 	| printBlock |	printBlock := [ :string  |				   aStream nextPutAll: (#changeSetForPackage &lt;&lt; #packages &gt;&gt; 'change set for package &lt;1p&gt; notes &lt;2s&gt;'						expandMacrosWith: pkg						with: string).				   aStream cr				   ].	self keysAndValuesDo: 		[ :symbol :cc |   	| obj |		obj := symbol asStrictReference valueOrDo: [nil].		cc isNonDestructivelyModified			ifTrue: 				[ obj isNil					ifTrue: [ printBlock value: ((#modificationForSomethingNotInTheSystem &lt;&lt; #packages &gt;&gt; 'a modification for "&lt;1s&gt;" which is not in the system')							expandMacrosWith: symbol) ].				( pkg includesSymbol: symbol )					ifFalse: [ printBlock value: ((#modificationForSomethingNotInThePackage &lt;&lt; #packages &gt;&gt; 'a modification for "&lt;1s&gt;" which is not in the package')						expandMacrosWith: symbol) ]				].			( cc isDefinitionRemoved or: [cc isRemoved and: [cc isAdded not]] ) 				ifTrue: 					[ ( pkg includesSymbol: symbol )						ifTrue: [ printBlock value: ((#removeOperationForSomethingInThePackage &lt;&lt; #packages &gt;&gt; 'a remove/remove definition for class "&lt;1s&gt;" still in the package')								expandMacrosWith: symbol)]					].			cc isForClass				ifTrue:					[ #( false true ) do: 						[ :meta |   | cls |						cls := obj isNil							ifTrue: [ nil ]							ifFalse: [ meta										ifTrue: [ obj class ]										ifFalse: [ obj ]									].					( cc modifiedSelectorsMeta: meta ) do: 						[ :selector | 						( cls isNil or: [ (cls compiledMethodAt: selector ifAbsent: [nil]) isNil] )							ifTrue: 								[ printBlock value:  ((#addChangeForMissingMethod &lt;&lt; #packages &gt;&gt; 'an add/change for method &lt;1s&gt;%&gt;&lt;2s&gt;" which is not in the system')									expandMacrosWith: symbol									with: selector) ].						( pkg							includesSelector: selector							classSymbol: symbol							meta: meta						) ifFalse: [ printBlock value: ((#addChangeForMispackagedMethod &lt;&lt; #packages &gt;&gt; 'an add/change for method &lt;1s&gt;%&gt;&lt;2s&gt;" which is not in the package')									expandMacrosWith: symbol									with: selector) ]						].					( cc removedSelectorsMeta: meta ) do: 						[ :selector | 						( pkg includesSelector: selector classSymbol: symbol meta: meta )							ifTrue: 								[ printBlock value:  ((#removeForMethodStillInPackage &lt;&lt; #packages &gt;&gt; 'a remove for method &lt;1s&gt;%&gt;&lt;2s&gt;" which is still in the package')									expandMacrosWith: symbol									with: selector) ]						]				]			].		cc modifiedDataKeys do: 			[ :dataKey | 			( pkg includesDataKey: dataKey ownerSymbol: symbol )				ifFalse: [ printBlock value:  ((#addChangeForDataNotInPackage &lt;&lt; #packages &gt;&gt; 'an add/change for data &lt;1s&gt;:&lt;2s&gt;" which is not in the package')						expandMacrosWith: symbol						with: dataKey) ]			].		cc removedDataKeys do: 			[ :dataKey | 			( pkg includesDataKey: dataKey ownerSymbol: symbol )					ifTrue: [ printBlock value: ((#removeForDataStillInPackage &lt;&lt; #packages &gt;&gt; ' a remove for data &lt;1s&gt;:&lt;2s&gt;" which is still in the package')							expandMacrosWith: symbol							with: dataKey) ]			]		]</body><body package="PackageCategories" selector="makeConsistentForPackage:">makeConsistentForPackage: pkg	"Resolve references to non-existent things:		- adds are removed altogether		- changes are changed to removes."	self keysAndValuesDo: 		[ :symbol :cc |   | obj |		obj := symbol asStrictReference valueOrDo:			[ cc isAdded ifTrue: [ self removeKey: symbol ].			cc isChanged ifTrue: [ cc remove ].			nil.			].		cc isForClass			ifTrue:				[ #( false true ) do: 					[ :meta |   | cls |					cls := obj isNil						ifTrue: [ nil ]						ifFalse: [ meta ifTrue: [ obj class ] ifFalse: [ obj ] ].					( cc modifiedSelectorsMeta: meta ) do: 						[ :selector | 						( cls isNil or: [ ( cls compiledMethodAt: selector ifAbsent: [ nil ] ) == nil ] )							ifTrue: 								[ | change |								change := Change new class: cls; selector: selector; remove.								self doSubdefChange: change.								].						].					]				]			].</body></methods><methods><class-id>Store.XChangeSet</class-id> <category>public-lists</category><body package="PackageCategories" selector="affectedClassNamesMeta:">affectedClassNamesMeta: meta 	"Answer a collection of class names that ????"	| names |	names := OrderedCollection new.	self keysAndValuesDo: 		[ :classSymbol :changes | 		changes isForClass 			ifTrue: 				[ ( ( changes isClassModifiedMeta: meta ) or: [ meta and: [ changes isAdded ] ] )					ifTrue: [ ( changes isRemoved or: [ changes isDefinitionRemoved ] )							ifFalse: [ names add: classSymbol asString ] 						   ]				]		].	^names</body><body package="PackageCategories" selector="affectedNameSpaceNames">affectedNameSpaceNames 	"Answer a collection of namespace names whose definition is changed,	but not removed."	| names |	names := OrderedCollection new.	self keysAndValuesDo: 		[ :symbol :changes | 		( changes isForNameSpace &amp; changes isDefinitionChanged )				ifTrue: [ (changes isRemoved or: [ changes isDefinitionRemoved ] )					ifFalse: [ names add: symbol asString ] ]		].	^names</body><body package="PackageCategories" selector="changedClasses">changedClasses	"Answer a collection of the changed or edited classes, not including removed classes."	| classes |	classes := OrderedCollection new.	self keysAndValuesDo: 		[:classSymbol :changes |   | class |		changes isForClass ifTrue:			[ class := classSymbol asStrictReference valueOrDo: [ nil ].			class notNil ifTrue: 				[				(changes isModifiedMeta: false) ifTrue: [classes add: class].				(changes isModifiedMeta: true) ifTrue: [classes add: class class]				]			].		].	^classes</body><body package="PackageCategories" selector="changedMessageList">changedMessageList	"Answer an array that identifies the methods that have been changed. 	Each entry is a String containing the class name and method selector."	| messageList | 	messageList := SortedCollection new.	self keysAndValuesDo: 		[ :classSymbol :cc | | className |		cc isForClass ifTrue:			[ className := classSymbol asString, ' '.			( cc modifiedSelectorsMeta: false )				do: [ :selector | messageList add: className , selector ].			className := classSymbol fullMetaName, ' '.			( cc modifiedSelectorsMeta: true )				do: [ :selector | messageList add: className , selector ]			].		].	^messageList asArray</body><body package="PackageCategories" selector="changedNameSpaces">changedNameSpaces	"Answer a collection of the changed or edited namespaces,	not including removed NameSpaces."	| nameSpaces |	nameSpaces := OrderedCollection new.	self keysAndValuesDo: 		[: symbol :changes |   | ns |		changes isForNameSpace ifTrue:			[ ns := symbol asStrictReference valueOrDo: [ nil ].			ns notNil ifTrue: [ nameSpaces add: ns].			].		].	^nameSpaces</body><body package="PackageCategories" selector="modifiedDataKeysFor:">modifiedDataKeysFor: aClassOrNameSpace	"Answer a collection of all methods added or changed for a class." 	| cc |	cc := self at: aClassOrNameSpace absoluteSymbol.	cc isForClass	ifFalse: [ ^#( ) ].	^cc modifiedDataKeys</body><body package="PackageCategories" selector="modifiedDatumDescriptors">modifiedDatumDescriptors	| dataItems |	dataItems := OrderedCollection new.	self keysAndValuesDo: 		[ :symbol :cc | 		cc modifiedDataKeys do: 			[ :dataKey | 			dataItems add: 				( cc isForNameSpace					ifTrue: [ DatumDescriptor fromDataKey: dataKey nameSpaceName: symbol asString ]					ifFalse: [ DatumDescriptor fromDataKey: dataKey className: symbol asString ]				)			].		].	^dataItems</body><body package="PackageCategories" selector="modifiedMethodDescriptors">modifiedMethodDescriptors	"Answer a collection of all methods added or changed." 	| methods |	methods := Set new.	self keysAndValuesDo: 		[:classSymbol :cc |    | className |		cc isForClass			ifTrue:				[				className := classSymbol asString.				(cc modifiedSelectorsMeta: false) do: 					[ :selector | methods add: 						(MethodDescriptor fromSelector: selector className: className meta: false )					].				(cc modifiedSelectorsMeta: true) do: 					[:selector | methods add: 					(MethodDescriptor fromSelector: selector className: className meta: true )					]				]			].	^methods asOrderedCollection</body><body package="PackageCategories" selector="modifiedSelectorsFor:">modifiedSelectorsFor: aClass	"Answer a collection of all methods added or changed for a class." 	| cc |	cc := self at: aClass absoluteSymbol.	cc isForClass	ifFalse: [ ^#( ) ].	^cc modifiedSelectorsMeta: aClass isMeta.</body><body package="PackageCategories" selector="removedClassOrDefinitionNames">removedClassOrDefinitionNames	"Answer a collection of removed class names"	| names |	names := OrderedCollection new.	self keysAndValuesDo: 		[ :classSymbol :cc |		cc isForClass and:			[ ( cc isRemoved or: [ cc isDefinitionRemoved ] ) 				ifTrue: [ names add: classSymbol asString ] 			]		].	^names</body><body package="PackageCategories" selector="removedDatumDescriptors">removedDatumDescriptors	| dataItems |	dataItems := OrderedCollection new.	self keysAndValuesDo: 		[ :symbol :cc | 		cc removedDataKeys do: 			[ :dataKey | 			dataItems add: 				( cc isForNameSpace					ifTrue: [ DatumDescriptor fromDataKey: dataKey nameSpaceName: symbol asString ]					ifFalse: [ DatumDescriptor fromDataKey: dataKey className: symbol asString ]				)			].		].	^dataItems</body><body package="PackageCategories" selector="removedMethodDescriptors">removedMethodDescriptors	| methods |	methods := OrderedCollection new.	self keysAndValuesDo: 		[ :classSymbol :cc |  | className |		cc isForClass ifTrue:			[ className := classSymbol asString.			( cc removedSelectorsMeta: false ) do: 				[ :selector | 	methods add: 					( MethodDescriptor fromSelector: selector className: className meta: false )				].			( cc removedSelectorsMeta: true ) do: 				[ :selector | methods add: 					( MethodDescriptor fromSelector: selector className: className meta: true )				]			]		].	^methods</body><body package="PackageCategories" selector="removedNames">removedNames	"Answer a collection of removed class and namespace names"	| names |	names := OrderedCollection new.	self keysAndValuesDo:		 [ :symbol :cc |		 ( cc isRemoved or: [ cc isDefinitionRemoved ]  ) 			ifTrue: [ names add: symbol ]		].	^names</body><body package="PackageCategories" selector="removedNameSpaceOrDefinitionNames">removedNameSpaceOrDefinitionNames	"Answer a collection of removed class names"	| names |	names := OrderedCollection new.	self keysAndValuesDo: 		[ :symbol :cc |		cc isForNameSpace and:			[ ( cc isRemoved or: [ cc isDefinitionRemoved ] ) 				ifTrue: [ names add: symbol asString ] 			]		].	^names</body><body package="PackageCategories" selector="reorganizedClassNames">reorganizedClassNames	"Answer a collection of reorganized class names"	| names |	names := OrderedCollection new.	self keysAndValuesDo: 		[ :classSymbol :cc | 		cc isForClass ifTrue:			[			( cc isClassReorganizedMeta: false )				ifTrue: [ names add: classSymbol asString ].			( cc isClassReorganizedMeta: true )				ifTrue: [ names add: classSymbol fullMetaName ] 			].		].	^names</body></methods><methods><class-id>Store.XChangeSet</class-id> <category>public-printing</category><body package="PackageCategories" selector="itemCount">itemCount	^self inject: 1 into:		[ :cnt :change | cnt + change itemCount ].</body><body package="PackageCategories" selector="printOn:">printOn: aStream 	"Append to the argument aStream a sequence of characters that 	identifies the receiver."	self putStatsOn: aStream</body></methods><methods><class-id>Store.XChangeSet</class-id> <category>public-testing</category><body package="PackageCategories" selector="forgetDataChange:owner:">forgetDataChange: dataKey owner: owner	| res |	res := ( self at: owner absoluteSymbol ifAbsent: [ ^false ] )		forgetDataChange: dataKey.	self removeIfEmptySymbol: owner absoluteSymbol.	^res</body><body package="PackageCategories" selector="forgetMethodChange:class:">forgetMethodChange: selector class: class	| res sym |	res := ( self at: ( sym := class instanceBehavior absoluteSymbol ) ifAbsent: [ ^false ] )		forgetMethodChange: selector meta: class isMeta.	self removeIfEmptySymbol: sym.	^res</body><body package="PackageCategories" selector="forgetTag:">forgetTag: aTag	"Remove the change represented by aTag."	| cc |	cc := self at: aTag fullClassName ifAbsent: [ ^self ].		"Already forgotten"	cc forgetTag: aTag.	self removeIfEmptySymbol: aTag fullClassName</body><body package="PackageCategories" selector="hasChangeForClassOrNameSpaceSymbol:">hasChangeForClassOrNameSpaceSymbol: aSymbol	^self includesKey: aSymbol asSymbol</body><body package="PackageCategories" selector="hasChangeForClassOrNameSpaceSymbol:defType:">hasChangeForClassOrNameSpaceSymbol: aSymbol defType: defType	^( self at: aSymbol asSymbol ifAbsent: [ ^false ] )		isDefTypeModified: defType</body><body package="PackageCategories" selector="isClassModifiedClassSymbol:meta:">isClassModifiedClassSymbol: classSymbol meta: meta 	^(self at: classSymbol ifAbsent: [^false])		isClassModifiedMeta: meta</body><body package="PackageCategories" selector="isDataKeyModified:ownerSymbol:">isDataKeyModified: dataKey ownerSymbol: ownerSymbol 	^( ( self at: ownerSymbol asSymbol ifAbsent: [ ^false ] )		modifiedDataKeys	) includes: dataKey</body><body package="PackageCategories" selector="isEmpty">isEmpty	^( super isEmpty and: [ self otherOrNil size == 0 ] )		and: [ self propertiesOrNil size == 0 ].</body><body package="PackageCategories" selector="isMainChangeSet">isMainChangeSet	^false</body><body package="PackageCategories" selector="isSelectorModified:classSymbol:meta:">isSelectorModified: selector classSymbol: classSymbol meta: meta 	^( ( self at: classSymbol ifAbsent: [ ^false ] )		modifiedSelectorsMeta: meta 	) includes: selector</body><body package="PackageCategories" selector="notEmpty">notEmpty	^self isEmpty not</body><body package="PackageCategories" selector="otherChangesInclude:">otherChangesInclude: aChange 	^self otherOrNil isNil		ifTrue: [false]		ifFalse: [self other includes: aChange]</body></methods><methods><class-id>Store.XChangeSet</class-id> <category>private</category><body package="PackageCategories" selector="createAt:forChange:">createAt: symbol forChange: change	^self at: symbol ifAbsentPut: 		[ ( change isForClass			ifTrue: [ self class classChangeClass ]			ifFalse: [ self class nameSpaceChangeClass ] 		 ) symbol: symbol ]</body><body package="PackageCategories" selector="createForClassAt:">createForClassAt: classSymbol 	^self at: classSymbol ifAbsentPut: 		[ self class classChangeClass symbol: classSymbol ]</body><body package="PackageCategories" selector="createForClassAt:andMoveTo:">createForClassAt: oldSymbol andMoveTo: newSymbol	"For renaming/relocating classes. Create the change at the original name	and then move it."	| cc |	cc := self createForClassAt: oldSymbol.	cc renameOldSymbol: oldSymbol.	self at: newSymbol put: cc.	self removeKey: oldSymbol.</body><body package="PackageCategories" selector="createForNameSpaceAt:">createForNameSpaceAt: symbol 	^self at: symbol ifAbsentPut: 		[ self class nameSpaceChangeClass symbol: symbol ]</body><body package="PackageCategories" selector="other">other	other isNil ifTrue: [other := IdentitySet new].	^other</body><body package="PackageCategories" selector="otherOrNil">otherOrNil	^other</body><body package="PackageCategories" selector="properties">properties	properties == nil 		ifTrue: [ properties := IdentitySet new ].	^properties</body><body package="PackageCategories" selector="propertiesOrNil">propertiesOrNil	^properties</body><body package="PackageCategories" selector="removeIfEmptySymbol:">removeIfEmptySymbol: symbol 	( self at: symbol ifAbsent: [^self] ) 		isModified ifFalse: [ self removeKey: symbol ]</body></methods><methods><class-id>Store.XChangeSet</class-id> <category>user interface</category><body package="PackageCategories" selector="inspectorClass">inspectorClass	^ChangeSetInspector</body></methods><methods><class-id>Store.XChangeSet</class-id> <category>private-fileIn/Out</category><body package="PackageCategories" selector="statsFor:selector:on:">statsFor: description selector: selector on: stream	"Print out the receivers changes for changes that evaluate a selector true.	Write nothing if not changes, otherwise use description as header."	| coll |	coll := self select: [ :chng | chng perform: selector ].	coll isEmpty 		ifFalse:			[ stream nextPutAll: description; cr.			coll do: [ :chng | stream tab; nextPutAll: chng symbol; cr ].			stream cr.			].</body></methods><methods><class-id>Store.XChangeSet</class-id> <category>public-fileIn/Out</category><body package="PackageCategories" selector="putStatsOn:">putStatsOn: stream 	"Write out all the changes the receiver knows about."	| coll |	self isEmpty 	ifTrue: [^stream nextPutAll: (#anEmptyChangeSet &lt;&lt; #packages &gt;&gt; 'an Empty ChangeSet') asString.].	self statsFor:  (#AddedC &lt;&lt; #packages &gt;&gt; 'Added: ') asString selector: #isAdded on: stream.	( coll := self select: [ :chng | chng isRenamed ] ) isEmpty 		ifFalse:			[ stream cr; nextPutAll: (#RenamedC &lt;&lt; #packages &gt;&gt; 'Renamed: ') asString; cr.			coll do: 					[ :chng | 				stream tab; nextPutAll: ((#x1sBecame2p &lt;&lt; #packages &gt;&gt; '&lt;1s&gt;&lt;t&gt;became&lt;t&gt;&lt;2p&gt;')							expandMacrosWith: chng oldName							with: chng symbol); cr				]			].	self statsFor:  (#RedefinedC &lt;&lt; #packages &gt;&gt; 'Redefined: ') asString selector: #isDefinitionChanged on: stream.	self statsFor:  (#CommentChangedC &lt;&lt; #packages &gt;&gt; 'Comment changed: ') asString selector: #isCommented on: stream.	self statsFor:  (#RemovedDefinitionC &lt;&lt; #packages &gt;&gt; 'Removed Definition:') asString selector: #isDefinitionRemoved on: stream.	self statsFor:  (#RemovedC &lt;&lt; #packages &gt;&gt; 'Removed:') asString selector: #isRemoved on: stream.	self statsFor:  (#ReOrganizedCChangedC &lt;&lt; #packages &gt;&gt; 'ReOrganized: changed: ') asString selector: #isReorganized on: stream.	self statsFor:  (#RemovedDefinitionC &lt;&lt; #packages &gt;&gt; 'Removed Definition:') asString selector: #isDefinitionRemoved on: stream.	stream nextPutAll: (#SubdefChangesC &lt;&lt; #packages &gt;&gt; 'Subdef changes:') asString; cr.	self keysAndValuesDo: 		[:symbol :cc | 		cc isForClass			ifTrue:				[				(cc areMethodsModifiedMeta: false)					ifTrue: 						[stream tab; nextPutAll: symbol; cr.						cc putMethodStatsMeta: false on: stream.						stream cr].				(cc areMethodsModifiedMeta: true)					ifTrue: 						[stream tab; nextPutAll: symbol; nextPutAll: ' class'; cr.						cc putMethodStatsMeta: true on: stream.						stream cr]				].			cc isDataModified 					ifTrue: 					[ stream  tab; nextPutAll: symbol; cr.					cc putDataStatsOn: stream.					stream cr.					].			].	self otherOrNil notNil 		ifTrue: 			[ stream nextPutAll: (#OtherChangesC &lt;&lt; #packages &gt;&gt; 'Other changes: ') asString; cr.			self other do: [:othChg | stream tab; print: othChg; cr]			].	self propertiesOrNil == nil		ifFalse: 			[ stream nextPutAll: (#PropertyChangesC &lt;&lt; #packages &gt;&gt; 'Property changes: ') asString; cr.			self properties do: [:prop | stream tab; print: prop; cr ]			]</body></methods><methods><class-id>Store.XChangeSet class</class-id> <category>accessing</category><body package="PackageCategories" selector="classChangeClass">classChangeClass	^ClassChanges</body><body package="PackageCategories" selector="current">current	"Answer the current change set"	CurrentSet == nil		ifTrue: [ self newChanges: self new ].	^CurrentSet.</body><body package="PackageCategories" selector="nameSpaceChangeClass">nameSpaceChangeClass	^NameSpaceChanges</body><body package="PackageCategories" selector="newChanges:">newChanges: aChangeSet 	"Change the current change set."		ChangeSet removeDependent: CurrentSet.	CurrentSet := aChangeSet.	ChangeSet addDependent: aChangeSet.</body><body package="PackageCategories" selector="noChanges">noChanges	self current noChanges.</body></methods><methods><class-id>Store.XChangeSet class</class-id> <category>initialization/finalization</category><body package="PackageCategories" selector="obsolete">obsolete	super obsolete.	CurrentSet notNil ifTrue: [ ChangeSet removeDependent: CurrentSet ]</body></methods><methods><class-id>Store.XMainChangeSet</class-id> <category>public-method changes</category><body package="PackageCategories" selector="addSelector:class:toPackage:">addSelector: selector class: class toPackage: pkg	"Put a new selector into aPackage."	"Note- trusts that the selector is in fact, new. (Can't really verify it anyway)"	| change |	change := Change new class: class; selector: selector; add.	pkg doSubdefChange: change.	self doSubdefChange: change.</body><body package="PackageCategories" selector="changeSelector:class:toPackage:">changeSelector: selector class: class toPackage: pkg	"Put a modified selector into aPackage." 	| change currPkg |	change := Change new class: class; selector: selector.	currPkg := Registry containingPackageForSelector: selector class: class.	( currPkg ~~ nil and: [ currPkg ~= pkg ] )		ifTrue: [ currPkg doSubdefChange: change remove ].	pkg doSubdefChange: 		( currPkg = pkg				ifTrue: [ change change ]				ifFalse: [ change add ]		).	self doSubdefChange: change change.</body><body package="PackageCategories" selector="correctSelector:class:toPackage:">correctSelector: selector class: class toPackage: pkg	"Used only when converting Parcels. Put a added selector into aPackage where 	it has accidently been appropiated by the original class owner." 	| change currPkg |	change := Change new class: class; selector: selector.	currPkg := Registry containingPackageForSelector: selector class: class.	( currPkg ~~ nil and: [ currPkg ~= pkg ] )		ifTrue: [ currPkg relinquishSelector: selector class: class ].	pkg doSubdefChange: change add.	self doSubdefChange: change add.</body><body package="PackageCategories" selector="removeSelector:class:">removeSelector: selector class: class 	| pkg change |	change := Change new class: class; selector: selector; remove.	pkg := Registry containingPackageForSelector: selector class: class.	pkg isNil ifFalse: [ pkg doSubdefChange: change  ].	self doSubdefChange: change.</body><body package="PackageCategories" selector="removeSelector:class:fromPackage:">removeSelector: selector class: class fromPackage: aPackage	| change |	change := Change new class: class; selector: selector; remove.	aPackage isNil ifFalse: [ aPackage doSubdefChange: change  ].	self doSubdefChange: change.</body><body package="PackageCategories" selector="removeSelectorChanges:class:">removeSelectorChanges: selector class: class 	| pkg change |	change := (Change new) class: class; selector: selector; removeChanges.	pkg := Registry 		quickContainingPackageForSelector: selector 		classSymbol: change symbol 		meta: class isMeta.	pkg isNil ifFalse: [ pkg doSubdefChange: change ].	self doSubdefChange: change</body></methods><methods><class-id>Store.XMainChangeSet</class-id> <category>public-data changes</category><body package="PackageCategories" selector="addDataKey:class:package:">addDataKey: dataKey class: class package: newPkg 	| change |	change := Change new class: class; dataKey: dataKey.	newPkg == nil		 ifFalse: [ newPkg doSubdefChange: change add ].	self doSubdefChange: change add</body><body package="PackageCategories" selector="addDataKey:nameSpace:package:">addDataKey: dataKey nameSpace: namespace package: newPkg 	| change |	change := Change new nameSpace: namespace; dataKey: dataKey.	newPkg == nil 		ifFalse: [ newPkg doSubdefChange: change add ].	self doSubdefChange: change add</body><body package="PackageCategories" selector="changeDataKey:class:">changeDataKey: dataKey class: class 	self changeDataKey: dataKey class: class package: 		( Registry packageForDataKey: dataKey classSymbol: class absoluteSymbol ).</body><body package="PackageCategories" selector="changeDataKey:class:package:">changeDataKey: dataKey class: class package: pkg 	| change currPkg |	( change := Change new ) 		class: class; 		dataKey: dataKey.	currPkg := Registry containingPackageForDataKey: dataKey class: class.	(currPkg notNil and: [currPkg ~= pkg])		ifTrue: [currPkg doSubdefChange: change remove].	pkg doSubdefChange: 		( currPkg = pkg			ifTrue: [change change]			ifFalse: [change add]		).	self doSubdefChange: change change</body><body package="PackageCategories" selector="changeDataKey:nameSpace:">changeDataKey: dataKey nameSpace: namespace 	self changeDataKey: dataKey nameSpace: namespace package: 		( Registry 			packageForDataKey: dataKey 			nameSpaceSymbol: namespace absoluteSymbol 		).</body><body package="PackageCategories" selector="changeDataKey:nameSpace:package:">changeDataKey: dataKey nameSpace: namespace package: pkg	| change currPkg |	( change := Change new ) 		nameSpace: namespace ;		dataKey: dataKey.	currPkg := Registry containingPackageForDataKey: dataKey nameSpace: namespace.	(currPkg notNil and: [currPkg ~= pkg])		ifTrue: [currPkg doSubdefChange: change remove].	pkg doSubdefChange: 		( currPkg = pkg			ifTrue: [change change]			ifFalse: [change add]		).	self doSubdefChange: change change</body><body package="PackageCategories" selector="relocateBinding:from:to:">relocateBinding: binding from: currentOwner to: newOwner 	"Include indication that a variable binding has been moved."	| change pkg |	( change := Change new ) actual: currentOwner;  dataKey: binding key.	pkg := Registry containingPackageForDataKey: binding key symbol: currentOwner absoluteSymbol.	pkg == nil		ifTrue: [ pkg := Registry packageForDataKey: binding key owner: newOwner ]		ifFalse: 			[ ( change := Change new ) 	actual: currentOwner; dataKey: binding key.			pkg doSubdefChange: change remove.			].	pkg == nil ifTrue: [ ^self ].	( change := Change new ) actual: newOwner; dataKey: binding key.	pkg doSubdefChange: change add.	self doSubdefChange: change change.</body><body package="PackageCategories" selector="removeBinding:in:">removeBinding: binding in: owner	owner isBehavior		ifTrue: [ self removeDataKey: binding key class: owner ]		ifFalse: [ self removeDataKey: binding key nameSpace: owner ].</body><body package="PackageCategories" selector="removeChangesDataKey:class:">removeChangesDataKey: dataKey class: class 	| pkg change |	change := (Change new) class: class; dataKey: dataKey; removeChanges.	pkg := Registry containingPackageForDataKey: dataKey symbol: class absoluteSymbol.	pkg isNil ifFalse: [pkg doSubdefChange: change].	self doSubdefChange: change</body><body package="PackageCategories" selector="removeDataKey:class:">removeDataKey: dataKey class: class 	| pkg change |	change := (Change new) class: class; dataKey: dataKey; remove.	pkg := Registry containingPackageForDataKey: dataKey symbol: class absoluteSymbol.	pkg isNil ifFalse: [pkg doSubdefChange: change].	self doSubdefChange: change</body><body package="PackageCategories" selector="removeDataKey:class:from:">removeDataKey: dataKey class: class  from: aPackage	| change |	change := (Change new) class: class; dataKey: dataKey; remove.	aPackage isNil ifFalse: [ aPackage doSubdefChange: change].	self doSubdefChange: change</body><body package="PackageCategories" selector="removeDataKey:nameSpace:">removeDataKey: dataKey nameSpace: namespace	| pkg change |	change := (Change new) 					nameSpace: namespace; 					dataKey: dataKey; 					remove.	pkg := Registry containingPackageForDataKey: dataKey 					symbol: namespace absoluteSymbol.	pkg isNil ifFalse: [ pkg doSubdefChange: change ].	self doSubdefChange: change</body><body package="PackageCategories" selector="removeDataKey:nameSpace:from:">removeDataKey: dataKey nameSpace: namespace  from: aPackage	| change |	change := (Change new) 					nameSpace: namespace; 					dataKey: dataKey; 					remove.	aPackage isNil ifFalse: [ aPackage doSubdefChange: change ].	self doSubdefChange: change</body><body package="PackageCategories" selector="renameBinding:in:as:">renameBinding: binding in: owner as: newName 	"Include indication that a variable binding has been renamed."	| change pkg |	pkg := Registry containingPackageForDataKey: binding key symbol: owner absoluteSymbol.	pkg == nil		ifTrue: [ pkg := Registry packageForDataKey: newName asSymbol owner: owner ]		ifFalse: 			[ 			( change := Change new ) actual: owner;  dataKey: binding key.			pkg doSubdefChange: change remove. 			].	pkg == nil ifTrue: [ ^self ].	( change := Change new ) actual: owner;  dataKey: newName asSymbol.	pkg doSubdefChange: change add.	self doSubdefChange: change change.</body></methods><methods><class-id>Store.XMainChangeSet</class-id> <category>public-fileIn/Out</category><body package="PackageCategories" selector="putStatsOn:">putStatsOn: stream 	"Write out all the changes the receiver knows about."	self isEmpty		ifTrue: [ ^stream nextPutAll: (#anEmptyChangeSet &lt;&lt; #packages &gt;&gt; 'an Empty ChangeSet') asString. ].	self reorganizeSystem isEmpty 		ifFalse: 			[ stream nextPutAll: (#Reorganized &lt;&lt; #packages &gt;&gt; 'Reorganized ...') asString; cr.			self reorganizeSystem asSortedCollection do:				[ :sym | stream tab; nextPutAll: sym; cr ].			stream cr.			].	super putStatsOn: stream</body></methods><methods><class-id>Store.XMainChangeSet</class-id> <category>public-other changes</category><body package="PackageCategories" selector="addDoIt:">addDoIt: smalltalkExpression 	"When filing out changes, append this string to the file."	specialDoIts isNil ifTrue: [specialDoIts := OrderedCollection new].	specialDoIts add: smalltalkExpression.</body><body package="PackageCategories" selector="addPatch:">addPatch: aPatchID	"Record that a system patch has been applied"	self needsMoreWork."	ChangeSet new addPatch: aPatchID  " "duplicated - ds"</body><body package="PackageCategories" selector="removeDoIt:">removeDoIt: smalltalkExpression	"When filing out changes, append this string to the file." 	specialDoIts remove: smalltalkExpression ifAbsent: []</body><body package="PackageCategories" selector="reorganizeClassData:">reorganizeClassData: class 	"Include indication that a class was reorganized (i.e. data protocol change)." 	"At the moment, we don't distinguish between instance, class or data' reorgs."	self reorganizeClass: class.</body><body package="PackageCategories" selector="reorganizeSystem">reorganizeSystem	"Include indication that the system classes were reorganized." 	reorganizeSystem == nil		ifTrue: [ reorganizeSystem := IdentitySet new ].	^reorganizeSystem.</body></methods><methods><class-id>Store.XMainChangeSet</class-id> <category>public-testing</category><body package="PackageCategories" selector="isEmpty">isEmpty	^super isEmpty and: 		[ reorganizeSystem == nil and: [specialDoIts size == 0 ] ]</body><body package="PackageCategories" selector="isMainChangeSet">isMainChangeSet	^true</body></methods><methods><class-id>Store.XMainChangeSet</class-id> <category>public-package movement</category><body package="PackageCategories" selector="moveClassDefinition:from:toPackage:">moveClassDefinition: class from: oldPackage toPackage: newPackage 	"Move just the definition of class from its current package to newPackage."	oldPackage = newPackage		ifFalse: 			[ oldPackage notNil				ifTrue: 					[ oldPackage doClassChange: ( Change new removeDefinition class: class ).					ChangeSet component: oldPackage definition: class change: #removed.					SourceFileManager default component: oldPackage definition: class change: #removed.					].			newPackage doClassChange: ( Change new add class: class ).			newPackage isLoading				ifFalse: 					[ ChangeSet component: newPackage definition: class change: #added.					SourceFileManager default component: newPackage definition: class change: #added.					]			].</body><body package="PackageCategories" selector="moveClassDefinition:toPackage:">moveClassDefinition: class toPackage: newPackage 	"Move just the definition of class from its current package to newPackage."	| pkg |	pkg := Registry containingPackageForClass: class.	self moveClassDefinition: class from: pkg toPackage: newPackage.</body><body package="PackageCategories" selector="moveClassModel:to:">moveClassModel: aModel to: bPackage	"Move what part of a class that is contained in a model to bPackage."	aModel hasDefinition 		ifTrue: [ self moveClassDefinition: aModel actualClass from: aModel package toPackage: bPackage ].	aModel classAndSelectorDo:		[ :cls :selector | 		self moveSelector: selector class: cls toPackage: bPackage 		].	aModel classAndDataKeyDo:		[ :cls :datakey |		self moveDataKey: datakey class: cls toPackage: bPackage 		].</body><body package="PackageCategories" selector="moveClassName:from:to:">moveClassName: aClassName from: aPackage to: bPackage	"Move what part of a class that is contained in aPackage to bPackage."	| model  |	bPackage == aPackage ifTrue: [ ^self ].	model := aPackage classModelAtClassName: aClassName ifAbsent: [ ^self ].	model hasDefinition 		ifTrue: [ self moveClassDefinition: model actualClass toPackage: bPackage ].	model classAndSelectorDo:		[ :cls :selector | 		self moveSelector: selector class: cls toPackage: bPackage 		].	model classAndDataKeyDo: 		[ :cls :dataKey |		self moveDataKey: dataKey class: cls toPackage: bPackage 		]</body><body package="PackageCategories" selector="moveDataKey:class:toPackage:">moveDataKey: dataKey class: class toPackage: newPackage 	| pkg |	pkg := Registry containingPackageForDataKey: dataKey class: class.	pkg = newPackage		ifFalse: 			[ pkg notNil 				ifTrue: 					[ pkg doSubdefChange: ( ( Change new remove ) dataKey: dataKey; class: class ).					ChangeSet component: pkg definition: class static: dataKey change: #removed.					SourceFileManager default component: pkg definition: class static: dataKey change: #removed.					].			newPackage doSubdefChange: ( ( Change new add) dataKey: dataKey; class: class ).			newPackage isLoading				ifFalse: 					[ ChangeSet component: newPackage definition: class static: dataKey change: #added.					SourceFileManager default component: newPackage definition: class static: dataKey change: #added.					]			]</body><body package="PackageCategories" selector="moveDataKey:nameSpace:toPackage:">moveDataKey: dataKey nameSpace: nameSpace toPackage: newPackage 	| pkg |	pkg := Registry containingPackageForDataKey: dataKey nameSpace: nameSpace.	pkg = newPackage		ifFalse: 			[ pkg notNil 				ifTrue: 					[ pkg doSubdefChange: 						( (Change new remove ) dataKey: dataKey; nameSpace: nameSpace ).					ChangeSet component: pkg definition: nameSpace static: dataKey change: #removed.					SourceFileManager default component: pkg definition: nameSpace static: dataKey change: #removed.					].			newPackage doSubdefChange: 				( ( Change new add ) dataKey: dataKey; nameSpace: nameSpace ).			newPackage isLoading				ifFalse: 					[ ChangeSet component: newPackage definition: nameSpace static: dataKey change: #added.					SourceFileManager default component: newPackage definition: nameSpace static: dataKey change: #added.					]		]</body><body package="PackageCategories" selector="moveDataKey:owner:toPackage:">moveDataKey: dataKey owner: anOwner toPackage: newPackage 	anOwner isBehavior		ifTrue: [ ^self moveDataKey: dataKey class: anOwner toPackage: newPackage ].	anOwner isNameSpace		ifTrue: [ ^self  moveDataKey: dataKey nameSpace: anOwner toPackage: newPackage ].	self error: (#UnexpectedOwner &lt;&lt; #packages &gt;&gt; 'Unexpected owner.')</body><body package="PackageCategories" selector="moveDefinition:toPackage:">moveDefinition: classOrNameSpace toPackage: newPackage 	"Move just the definition of class or namespace from its current package to newPackage."	classOrNameSpace isForNameSpace		ifTrue: [ self moveNameSpaceDefinition: classOrNameSpace toPackage: newPackage ]		ifFalse: [ self moveClassDefinition: classOrNameSpace toPackage: newPackage ]</body><body package="PackageCategories" selector="moveNameSpaceDefinition:from:toPackage:">moveNameSpaceDefinition: namespace from: oldPackage toPackage: newPackage 	"Move just the definition of 'namespace' from its oldPackage to newPackage."	oldPackage = newPackage		ifFalse: 			[ oldPackage notNil				ifTrue: 					[ oldPackage doNameSpaceChange: 							( Change new removeDefinition nameSpace: namespace ).					ChangeSet component: oldPackage definition: namespace change: #removed.					SourceFileManager default component: oldPackage definition: namespace change: #removed.					 ].			newPackage doNameSpaceChange: ( Change new add nameSpace: namespace ).			newPackage isLoading				ifFalse: 					[ ChangeSet component: newPackage definition: namespace change: #added.					SourceFileManager default component: newPackage definition: namespace change: #added.					]			]</body><body package="PackageCategories" selector="moveNameSpaceDefinition:toPackage:">moveNameSpaceDefinition: namespace toPackage: newPackage 	"Move just the definition of 'namespace' from its current package to newPackage."	| pkg |	pkg := Registry containingPackageForNameSpace: namespace.	self moveNameSpaceDefinition: namespace from: pkg toPackage: newPackage</body><body package="PackageCategories" selector="moveNameSpaceModel:to:">moveNameSpaceModel: model to: bPackage	"Move the definition and whatever other parts of a namespace that is contained in aModel to bPackage."	model hasDefinition		ifTrue: [ self moveNameSpaceDefinition: model nameSpace from: model package toPackage: bPackage ].	model nameSpaceAndDataKeyDo: 		[ :ns :dataKey |		self moveDataKey: dataKey nameSpace: ns toPackage: bPackage 		]</body><body package="PackageCategories" selector="moveObject:from:to:">moveObject: aDefinedObject from: aPackage to: bPackage	"Move what part of a class/namespace that is contained in aPackage to bPackage."	| model  |	model := aPackage modelAtName: aDefinedObject absoluteName ifAbsent: 		[ aDefinedObject isBehavior 			ifTrue: [ self moveUnpackagedInWholeClass: aDefinedObject toPackage: bPackage ]			ifFalse: [ self moveUnpackagedInWholeNameSpace: aDefinedObject toPackage: bPackage ].		^self 		].	model isClassModel		ifTrue: [ self moveClassModel: model to: bPackage ]		ifFalse: [ self moveNameSpaceModel: model to: bPackage ].</body><body package="PackageCategories" selector="moveSelector:class:fromPackage:">moveSelector: selector class: class fromPackage: oldPackage 	| pkg | 	pkg := Registry containingPackageForSelector: selector class: class.	pkg = oldPackage		ifFalse: [ ^self ].		"already been moved"	self moveSelector: selector class: class toPackage: ( Registry nullPackage ).</body><body package="PackageCategories" selector="moveSelector:class:toPackage:">moveSelector: selector class: class toPackage: newPackage 	| pkg | 	pkg := Registry containingPackageForSelector: selector class: class.	pkg = newPackage		ifFalse: 			[ pkg notNil				ifTrue: 					[ pkg doSubdefChange: (Change new remove selector: selector; class: class ). 					ChangeSet component: pkg definition: class selector: selector change: #removed.					SourceFileManager default component: pkg definition: class selector: selector change: #removed.					].			newPackage doSubdefChange: ( Change new add selector: selector; class: class ).			newPackage isLoading				ifFalse: 					[ ChangeSet component: newPackage definition: class selector: selector change: #added.					SourceFileManager default component: newPackage definition: class selector: selector change: #added.					]			].</body><body package="PackageCategories" selector="moveSelectors:class:toPackage:">moveSelectors: selectors class: class toPackage: newPackage 	| pkg | 	selectors do:		[ :sel |		pkg := Registry containingPackageForSelector: sel class: class.		pkg = newPackage			ifFalse: 			[ pkg notNil				ifTrue: 					[ pkg doSubdefChange: ( Change new remove selector: sel; class: class ).					ChangeSet component: pkg definition: class selector: sel change: #removed.					SourceFileManager default component: pkg definition: class selector: sel change: #removed.					].			newPackage doSubdefChange: ( Change new add selector: sel; class: class ).			newPackage isLoading				ifFalse: 					[ ChangeSet component: pkg definition: class selector: sel change: #added.					SourceFileManager default component: pkg definition: class selector: sel change: #added.					]			]		].</body><body package="PackageCategories" selector="moveUnpackagedClassDefinition:toPackage:">moveUnpackagedClassDefinition: class toPackage: newPackage 	"Move just the definition of 'class' from its current package to 'newPackage'."	| pkg |	pkg := Registry containingPackageForClass: class.	pkg isNil		ifTrue: 			[newPackage doClassChange: (Change new add class: class)]</body><body package="PackageCategories" selector="moveUnpackagedDataKey:nameSpace:toPackage:">moveUnpackagedDataKey: dataKey nameSpace: namespace toPackage: newPackage 	| pkg |	pkg := Registry containingPackageForDataKey: dataKey nameSpace: namespace.	pkg isNil		ifTrue:			[ newPackage doSubdefChange: 				( (Change new add) dataKey: dataKey; nameSpace: namespace )			]</body><body package="PackageCategories" selector="moveUnpackagedInWholeClass:toPackage:">moveUnpackagedInWholeClass: class toPackage: newPackage 	"Move the definition of 'class' and all its methods from its current package to 	'newPackage'."	class selectors do: [:selector | self			moveUnpackagedSelector: selector			class: class			toPackage: newPackage].	class class selectors do: [:selector | self			moveUnpackagedSelector: selector			class: class class			toPackage: newPackage].	self moveUnpackagedClassDefinition: class toPackage: newPackage.</body><body package="PackageCategories" selector="moveUnpackagedInWholeNameSpace:toPackage:">moveUnpackagedInWholeNameSpace: namespace toPackage: newPackage 	"Move the definition of namespace and all its methods from its current package to 	'newPackage'."	namespace bindingsDo: 		[ : binding |		( binding isForGeneral )			ifTrue:				[ self					moveUnpackagedDataKey: binding key					nameSpace: namespace					toPackage: newPackage				]		].	self moveUnpackagedNameSpaceDefinition: namespace toPackage: newPackage.</body><body package="PackageCategories" selector="moveUnpackagedNameSpaceDefinition:toPackage:">moveUnpackagedNameSpaceDefinition: namespace toPackage: newPackage 	"Move just the definition of namespace from its current package to 'newPackage'."	| pkg |	pkg := Registry containingPackageForNameSpace: namespace.	pkg isNil 		ifTrue: 			[ newPackage doNameSpaceChange: 				( Change new add nameSpace: namespace )			]</body><body package="PackageCategories" selector="moveUnpackagedSelector:class:toPackage:">moveUnpackagedSelector: selector class: class toPackage: newPackage 	| pkg | 	pkg := Registry containingPackageForSelector: selector class: class.	pkg isNil 		ifTrue: 			[newPackage doSubdefChange: (Change new add selector: selector; class: class)]</body><body package="PackageCategories" selector="moveWholeClass:toPackage:">moveWholeClass: class toPackage: newPackage 	"Move the definition of 'class' and all its methods from its current package to 	'newPackage'."	| cls |	cls := class instanceBehavior.	cls selectors do: 		[ :selector | 	self moveSelector: selector class: cls toPackage: newPackage ].	cls class selectors do: 		[ :selector | 	self	moveSelector: selector class: cls class toPackage: newPackage ].	cls dataKeys do: 		[ :dataKey | 	self	moveDataKey: dataKey class: cls toPackage: newPackage ].	self moveClassDefinition: cls toPackage: newPackage.</body><body package="PackageCategories" selector="moveWholeNameSpace:toPackage:">moveWholeNameSpace: namespace toPackage: newPackage 	"Move the definition of 'namespace' and all its methods from its current package to 	'newPackage'."	namespace dataBindings do: 		[ :binding | 		self moveDataKey: binding key 			nameSpace: namespace 			toPackage: newPackage		].	self moveNameSpaceDefinition: namespace toPackage: newPackage.</body><body package="PackageCategories" selector="moveWholeObject:toPackage:">moveWholeObject: object toPackage: newPackage 	"Move the definition of a class/namespace and it's contents from its current package to 	newPackage."	object isBehavior 		ifTrue: [ ^self moveWholeClass: object toPackage: newPackage ].	( object isNameSpace )		ifTrue: [ ^self moveWholeNameSpace: object toPackage: newPackage ].</body></methods><methods><class-id>Store.XMainChangeSet</class-id> <category>events</category><body package="PackageCategories" selector="addBinding:in:">addBinding: binding in: anObject	"Event triggered when new static is created."	anObject isBehavior		ifTrue:			[ self addDataKey: binding key 				class: anObject				package: ( Registry packageForNewDataKey: binding key 								classSymbol: anObject absoluteSymbol )			]	ifFalse:		[ self addDataKey: binding key			nameSpace: anObject			package: ( Registry packageForNewDataKey: binding key							nameSpaceSymbol: anObject absoluteSymbol )		].</body><body package="PackageCategories" selector="addBinding:in:attributes:">addBinding: binding in: anObject attributes: attributes	"Event triggered when new static is created with attributes."	| pkg |	pkg := Policies packagePolicy packageIsForced		ifTrue: [ Policies packagePolicy forcedPackage ]		ifFalse: [ self packageFromAttributes: attributes ].	pkg == nil		ifTrue: [ ^self addBinding: binding in: anObject ].	anObject isBehavior		ifTrue: [ self addDataKey: binding key class: anObject package: pkg ]		ifFalse:	[ self addDataKey: binding key nameSpace: anObject package: pkg ].</body><body package="PackageCategories" selector="addClass:">addClass: class 	"Event triggered when new class is created."	| cls |	cls := class instanceBehavior.	self addClass: cls toPackage: 	( Registry packageForClass: cls ).</body><body package="PackageCategories" selector="addClass:attributes:">addClass: class attributes: attributes	"Event triggered when new class is created with attributes."	| pkg cls |	pkg := Policies packagePolicy packageIsForced		ifTrue: [ Policies packagePolicy forcedPackage ]		ifFalse: [ self packageFromAttributes: attributes ].	cls := class instanceBehavior.	pkg == nil		ifTrue: [ 	self addClass: cls ]		ifFalse: [ self addClass: cls toPackage: pkg ]</body><body package="PackageCategories" selector="addNameSpace:">addNameSpace: namespace 	"Event triggered when new namespace is created."	| pkg |	( pkg := Registry packageForNameSpace: namespace ) == nil		ifFalse: [ self addNameSpace: namespace toPackage: pkg ]</body><body package="PackageCategories" selector="addNameSpace:attributes:">addNameSpace: namespace attributes: attributes	"Event triggered when new namespace is created with attributes."	| pkg |	pkg := Policies packagePolicy packageIsForced		ifTrue: [ Policies packagePolicy forcedPackage ]		ifFalse: [ self packageFromAttributes: attributes ].	pkg == nil		ifTrue: [ 	self addNameSpace: namespace ]		ifFalse: [ self addNameSpace: namespace toPackage: pkg ]</body><body package="PackageCategories" selector="addSelector:class:">addSelector: selector class: class 	"Event triggered when a new method is created."	self addSelector: selector class: class toPackage: 		( Registry 			packageForNewSelector: selector				classSymbol: class absoluteName asClassNameOnly asSymbol			meta: class isMeta		).</body><body package="PackageCategories" selector="addSelector:class:attributes:">addSelector: selector class: class attributes: attributes	"Event triggered when new method is created with attributes."	| pkg |	pkg := Policies packagePolicy packageIsForced		ifTrue: [ Policies packagePolicy forcedPackage ]		ifFalse: [ self packageFromAttributes: attributes ].	pkg == nil		ifTrue: [ self addSelector: selector class: class ]		ifFalse: [ self addSelector: selector class: class toPackage: pkg ]</body><body package="PackageCategories" selector="changeBinding:in:">changeBinding: binding in: anObject	"Event triggered when a static definition is changed."	anObject isBehavior		ifTrue: [ self changeDataKey: binding key class: anObject ]		ifFalse: [ self changeDataKey: binding key nameSpace: anObject ].</body><body package="PackageCategories" selector="changeBinding:in:attributes:">changeBinding: binding in: anObject attributes: attributes	"Event triggered when a static definition is changed with attributes."	| pkg |	pkg := Policies packagePolicy packageIsForced		ifTrue: [ Policies packagePolicy forcedPackage ]		ifFalse: [ self packageFromAttributes: attributes ]. 	pkg == nil		ifTrue: [ ^self changeBinding: binding in: anObject ].	anObject isBehavior		ifTrue: [ self changeDataKey: binding key class: anObject package: pkg ]		ifFalse: [ self changeDataKey: binding key nameSpace: anObject package: pkg ].</body><body package="PackageCategories" selector="changeClass:">changeClass: class 	"Event triggered when a class definition is changed."	| cls |	cls := class instanceBehavior.	self changeClass: cls toPackage: ( Registry packageForClass: cls ).</body><body package="PackageCategories" selector="changeClass:attributes:">changeClass: class attributes: attributes	"Event triggered when a class definition is changed with attributes."	| pkg cls |	pkg := Policies packagePolicy packageIsForced		ifTrue: [ Policies packagePolicy forcedPackage ]		ifFalse: [ self packageFromAttributes: attributes ].	cls := class instanceBehavior.	pkg == nil		ifTrue: [ 	self changeClass: cls ]		ifFalse: [ self changeClass: cls toPackage: pkg ]</body><body package="PackageCategories" selector="changeNameSpace:">changeNameSpace: namespace	"Event triggered when a namespace definition is changed."	| pkg |	( pkg := Registry packageForNameSpace: namespace ) == nil		ifFalse: [ self changeNameSpace: namespace toPackage: pkg ].</body><body package="PackageCategories" selector="changeNameSpace:attributes:">changeNameSpace: namespace attributes: attributes	"Event triggered when a namespace definition is changed with attributes."	| pkg |	pkg := Policies packagePolicy packageIsForced		ifTrue: [ Policies packagePolicy forcedPackage ]		ifFalse: [ self packageFromAttributes: attributes ].	pkg == nil		ifTrue: [ 	self changeNameSpace: namespace ]		ifFalse: [ self changeNameSpace: namespace toPackage: pkg ]</body><body package="PackageCategories" selector="changeSelector:class:">changeSelector: selector class: class 	"Event triggered when a method is changed."	self changeSelector: selector class: class toPackage: 		( Registry			packageForSelector: selector			classSymbol: class absoluteName asClassNameOnly asSymbol			meta: class isMeta		)</body><body package="PackageCategories" selector="changeSelector:class:attributes:">changeSelector: selector class: class attributes: attributes	"Event triggered when a method is changed with attributes."	| pkg |	pkg := Policies packagePolicy packageIsForced		ifTrue: [ Policies packagePolicy forcedPackage ]		ifFalse: [ self packageFromAttributes: attributes ].	pkg == nil		ifTrue: [  self changeSelector: selector class: class ]		ifFalse: [ self changeSelector: selector class: class toPackage: pkg ]</body><body package="PackageCategories" selector="changeSelector:class:documentation:">changeSelector: selector class: class  documentation: documentation	self changeSelector: selector class: class</body><body package="PackageCategories" selector="changeSelector:class:protocol:">changeSelector: selector class: class protocol: protocol	self changeSelector: selector class: class</body><body package="PackageCategories" selector="packageFromAttributes:">packageFromAttributes: attributes	"Private- Check attributes for a package and answer it or nil."	| pname |	pname := ( SystemUtils makeAttributesDictionary: attributes )				at: #package ifAbsent: [ ^nil ].	^Registry packageNamedOrCreate: pname.</body><body package="PackageCategories" selector="reorganizeClass:">reorganizeClass: class 	| pkg change |	change := (Change new) class: class; reorganize.	pkg := Registry containingPackageForClassSymbol: class instanceBehavior absoluteSymbol.	pkg isNil ifFalse: [pkg doClassChange: change].	self doClassChange: change.</body><body package="PackageCategories" selector="update:with:from:">update: anAspect with: arguments from: anObject		"ChangeSet changes- reexecute here.""Transcript show: anAspect; tab; show: arguments printString; cr."	anAspect isSymbol ifFalse: [^nil].	^[ self perform: anAspect withArguments: arguments ]		on: MessageNotUnderstood do: 			[ :e | e message selector == anAspect 						ifTrue: [ ^nil ]						ifFalse: [ e pass ]			]</body></methods><methods><class-id>Store.XMainChangeSet</class-id> <category>public-namespace changes</category><body package="PackageCategories" selector="addNameSpace:toPackage:">addNameSpace: nameSpace toPackage: pkg	"Add a newly created namespace to a package."  	"Note, pkg cannot be nil."	| change currPkg |	change := Change new nameSpace: nameSpace .	currPkg := Registry containingPackageForNameSpace: nameSpace.	"currPkg should be nil.  This is just in case code."	( currPkg ~~ nil and: [ currPkg ~= pkg ] )		ifTrue: [ currPkg doNameSpaceChange: change removeDefinition ].	self moveUnpackagedInWholeNameSpace: nameSpace toPackage: pkg.	self doNameSpaceChange: change add.</body><body package="PackageCategories" selector="addNameSpaceDefinition:toPackage:">addNameSpaceDefinition: nameSpace toPackage: pkg	"Add a newly created namespace to a package."  	"Note, pkg cannot be nil."	| change currPkg |	change := Change new nameSpace: nameSpace .	currPkg := Registry containingPackageForNameSpace: nameSpace.	"currPkg should be nil.  This is just in case code."	( currPkg ~~ nil and: [ currPkg ~= pkg ] )		ifTrue: [ currPkg doNameSpaceChange: change removeDefinition ].	pkg doNameSpaceChange: change add.</body><body package="PackageCategories" selector="changeNameSpace:toPackage:">changeNameSpace: namespace toPackage: pkg	"Put a modifed namespace to a package."  	"Note, pkg cannot be nil."	| change currPkg |	change := Change new nameSpace: namespace.	currPkg := Registry containingPackageForNameSpace: namespace.	( currPkg notNil and: [currPkg ~= pkg])		ifTrue: [ currPkg doNameSpaceChange: change removeDefinition ].	pkg doNameSpaceChange: 		( currPkg = pkg			ifTrue: [ change change ]			ifFalse: [ change add ]		).	self doNameSpaceChange: change change.</body><body package="PackageCategories" selector="commentNameSpace:">commentNameSpace: namespace	| pkg change |	change := (Change new) nameSpace: namespace; comment.	pkg := Registry containingPackageForNameSpace: namespace.	pkg isNil ifFalse: [pkg doNameSpaceChange: change].	self doNameSpaceChange: change.</body><body package="PackageCategories" selector="component:property:value:">component: component property: property value: value	component addPropertyChange: property.</body><body package="PackageCategories" selector="component:renamedTo:">component: component renamedTo: aString	component addOtherChange: #name</body><body package="PackageCategories" selector="relocateNameSpace:from:to:">relocateNameSpace: namespace from: parent to: newParent 	"Include indication that a nameSpace has been moved."	self renameNameSpace: namespace asAbsoluteSymbol: 		( BindingReference 			fullNameFrom: newParent absoluteName 			name: namespace name 		) asSymbol.</body><body package="PackageCategories" selector="removeNameSpace:">removeNameSpace: namespace 	"This is subtle, packages need to know about whole namespace removes 	as an atomic act - then they translate to bit by bit remove.  At the main level, 	we do our own bit by bit translation - taking into account that the 	original name may have been different."	| change nameSpaceSymbol cc |	Registry packagesContainingNameSpace: namespace do: 		[ :pkg | pkg doNameSpaceChange: 			( Change new remove nameSpace: namespace ) 		].			nameSpaceSymbol := namespace absoluteSymbol.	cc := self createForNameSpaceAt: nameSpaceSymbol.	cc isRenamed ifTrue: 		[ nameSpaceSymbol := cc oldName.		self at: nameSpaceSymbol put: cc.		self removeKey: namespace absoluteSymbol		].	change := Change new remove nameSpaceSymbol: nameSpaceSymbol.	self doNameSpaceChange: change.	namespace dataBindings do: 		[ :binding | self doSubdefChange: (change dataKey: binding key ) ]</body><body package="PackageCategories" selector="renameNameSpace:as:">renameNameSpace: namespace as: newName 	"Include indication that a nameSpace has been renamed."	self renameNameSpace: namespace asAbsoluteSymbol: 		( BindingReference 			newName: newName 			from: namespace absoluteName 		) asSymbol.</body><body package="PackageCategories" selector="reorganizeNameSpace:">reorganizeNameSpace: namespace	self reorganizeSystem add: namespace absoluteSymbol."	| pkg change |	change := (TT_Change new) nameSpace: namespace; reorganize.	pkg := TT_Registry containingPackageForSymbol: namespace absoluteSymbol.	pkg isNil ifFalse: [pkg doNameSpaceChange: change].	self doNameSpaceChange: change."</body></methods><methods><class-id>Store.XMainChangeSet</class-id> <category>public-class changes</category><body package="PackageCategories" selector="addClass:toPackage:">addClass: class toPackage: pkg	"Add a newly created class to a package."  	"Note, pkg cannot be nil."	| change currPkg |	change := Change new class: class.	"currPkg should be nil.... but we check just in case."	currPkg := Registry containingPackageForClass: class.	( currPkg ~~ nil and: [ currPkg ~= pkg ] )		ifTrue: [ currPkg doClassChange: change removeDefinition ].	self moveUnpackagedInWholeClass: class toPackage: pkg.	self doClassChange: change add.</body><body package="PackageCategories" selector="addClassDefinition:toPackage:">addClassDefinition: class toPackage: pkg	"Add a newly created class to a package."  	"Note, pkg cannot be nil."	| change currPkg |	change := Change new class: class.	"currPkg should be nil.... but we check just in case."	currPkg := Registry containingPackageForClass: class.	( currPkg ~~ nil and: [ currPkg ~= pkg ] )		ifTrue: [ currPkg doClassChange: change removeDefinition ].	pkg doClassChange: change add.</body><body package="PackageCategories" selector="changeClass:toPackage:">changeClass: class  toPackage: pkg	"Put a modifed class to a package."  	"Note, pkg cannot be nil."	| change currPkg |	change := Change new class: class.	currPkg := Registry containingPackageForClass: class.	( currPkg ~~ nil and: [ currPkg ~= pkg ] )		ifTrue: [ currPkg doClassChange: change removeDefinition ].	pkg doClassChange: 		( currPkg = pkg			ifTrue: [ change change ]			ifFalse: [ change add ]		).	self doClassChange: change change.</body><body package="PackageCategories" selector="changeDefinitionClass:">changeDefinitionClass: cls 	"Mark a changed class definition. If it doesn't exist, it's already been changed."	| change currPkg |	change := Change new class: cls.	change change.	currPkg := Registry containingPackageForClass: cls.	currPkg == nil ifTrue: [ ^nil ].	currPkg doClassChange: change.	self doClassChange: change.</body><body package="PackageCategories" selector="commentClass:">commentClass: class 	| pkg change |	change := (Change new) class: class; comment.	pkg := Registry containingPackageForClass: class.	pkg isNil ifFalse: [pkg doClassChange: change].	self doClassChange: change.</body><body package="PackageCategories" selector="relocateClass:from:to:">relocateClass: class from: nameSpace to: newNameSpace	"Since a class may have extensions in various packages 	we must iterate over all packages containing the class."	self renameClass: class 		  asAbsoluteSymbol: 			( BindingReference 				fullNameFrom: newNameSpace absoluteName 				name: class name 			) asSymbol.</body><body package="PackageCategories" selector="removeChangesPropagatingClass:">removeChangesPropagatingClass: class 	| change |	change := (Change new) class: class; removeChanges.	Registry packagesContainingClass: class do: [:pkg | pkg doClassChange: change].	self doClassChange: change</body><body package="PackageCategories" selector="removeClass:">removeClass: class 	"This is subtle, packages need to know about whole 	class removes as an atomic act - then they translate	to bit by bit remove.  At the main level, we do our own	bit by bit translation - taking into account that the 	original name may have been different."	| change classSymbol cc |	Registry packagesContainingClass: class do: [:pkg | pkg doClassChange: (Change new remove class: class)].	classSymbol := class absoluteSymbol.	cc := self createForClassAt: classSymbol.	cc isRenamed		ifTrue: 			[classSymbol := cc oldName.			self at: classSymbol put: cc.			self removeKey: class absoluteSymbol].	change := Change new remove classSymbol: classSymbol.	self doClassChange: change.	class selectors do: 		[:selector | self doSubdefChange: (change selector: selector; meta: false)].	class class selectors do: 		[:selector | self doSubdefChange: (change selector: selector; meta: true)].	class dataKeys do: 		[:dataKey | self doSubdefChange: (change dataKey: dataKey)].</body><body package="PackageCategories" selector="removeClass:from:">removeClass: class from: package	"Remove the class definition from package. Assumes it has/will be moved to another package."	| change classSymbol |	package doClassChange: ( Change new remove class: class ).	classSymbol := class absoluteSymbol.	change := Change new remove classSymbol: classSymbol.	self doClassChange: change.</body><body package="PackageCategories" selector="removeClassChanges:">removeClassChanges: class 	"Remove all memory of changes associated with this class and its metaclass."	self doClassChange: ((Change new) class: class; removeChanges)</body><body package="PackageCategories" selector="renameClass:as:">renameClass: class as: newName 	"Since a class may have extensions in various packages 	we must iterate over all packages containing the class."	self renameClass: class asAbsoluteSymbol: 		( BindingReference 			newName: newName 			from: class absoluteName		) asSymbol.</body></methods><methods><class-id>Store.XMainChangeSet</class-id> <category>private- cascade changes</category><body package="PackageCategories" selector="cascadeRelocateNameSpace:to:">cascadeRelocateNameSpace: namespace to: newEnvironmentSymbol		"Private- newEnvironmentSymbol is the about to be renamed/relocated 		enviornment of namespace. Cascade to all contained namespaces and 		classes models."	| newSymbol |	newSymbol := BindingReference fullNameFrom: newEnvironmentSymbol name: namespace name.	Registry packagesContainingNameSpace: namespace do:			[ :pkg | pkg renameNameSpaceSymbol: namespace absoluteSymbol as: newSymbol ].	namespace classes do:		[ :cls | 		Registry packagesContainingClass: cls do: 			[ :pkg | pkg renameClassSymbol: cls absoluteSymbol as: 						( BindingReference fullNameFrom: newSymbol name: cls name ).			].		cls allSubclasses do: [ :sub | self changeDefinitionClass: sub ]. 		].	namespace nameSpaces do: 		[ :ns | 	self cascadeRelocateNameSpace: ns to: newSymbol ].</body><body package="PackageCategories" selector="renameClass:asAbsoluteSymbol:">renameClass: class asAbsoluteSymbol: newSymbol	"Since a class may have extensions in various packages 	we must iterate over all packages containing the class."	| oldSymbol |	oldSymbol := class absoluteSymbol.	Registry packagesContainingClassSymbol: oldSymbol do: 		[:pkg | pkg renameClassSymbol: oldSymbol as: newSymbol ].	class subclasses do: 		[ :cls | 		( Registry packageForClass: cls ) doClassChange: 			( (Change new) class: cls; change )		].	self createForClassAt: oldSymbol andMoveTo: newSymbol.</body><body package="PackageCategories" selector="renameNameSpace:asAbsoluteSymbol:">renameNameSpace: namespace asAbsoluteSymbol: newSymbol	"Since a NameSpace may have extensions in various packages 	we must iterate over all packages containing the namespace."	| oldSymbol cc |	oldSymbol := namespace absoluteSymbol.	Registry packagesContainingNameSpace: namespace do: 		[:pkg | pkg renameNameSpaceSymbol: oldSymbol as: newSymbol ].	namespace classes do:		[ :cls |  | newClassSym |		newClassSym := ( BindingReference fullNameFrom: newSymbol name: cls name )								asSymbol.		Registry packagesContainingClass: cls do: 			[ :pkg | pkg renameClassSymbol: cls absoluteSymbol as: newClassSym ].		cls allSubclasses do: [ :sub | self changeDefinitionClass: sub ]. 		].	namespace nameSpaces do:		[ :ns | self cascadeRelocateNameSpace: ns to: newSymbol ].	cc := self createForNameSpaceAt: oldSymbol.	cc renameOldSymbol: oldSymbol.	self at: newSymbol put: cc.	self removeKey: oldSymbol.</body></methods><methods><class-id>Store.XMainChangeSet</class-id> <category>private-fileIn/Out</category><body package="PackageCategories" selector="fileOutSpecialOn:">fileOutSpecialOn: fileManager 	"Write out any special changes the receiver knows about."	super fileOutSpecialOn: fileManager.	self reorganizeSystem isEmpty ifFalse:		[self reorganizeSystem do:			[ :envstr | | ns | 			ns := envstr asStrictReference valueOrDo: [ nil ].			ns == nil				ifFalse:					[ fileManager reorganizeNameSpace: ns.					]			]		].	specialDoIts size &gt; 0 ifTrue: [specialDoIts do:		[:expression |		fileManager storeExpression: expression]]</body></methods><methods><class-id>Store.XMainChangeSet</class-id> <category>events-parcels</category><body package="PackageCategories" selector="installedClasses:toPackage:">installedClasses: classList toPackage: aPackage	classList do:		[ :cls |		self addClassDefinition: cls toPackage: aPackage.		].</body><body package="PackageCategories" selector="installedMethods:toPackage:">installedMethods: list toPackage: aPackage	list do:		[ :mir | self changeSelector: mir selector class: mir mclass classObject toPackage: aPackage ]</body><body package="PackageCategories" selector="installedNameSpaces:toPackage:">installedNameSpaces: list toPackage: aPackage	list do:		[ :ns |		self addNameSpaceDefinition: ns toPackage: aPackage.		].</body><body package="PackageCategories" selector="installedOverrideMethods:toPackage:">installedOverrideMethods: list toPackage: aPackage	list do:		[ :mir |		self changeSelector: mir selector class: mir mclass classObject toPackage: aPackage		].</body></methods><methods><class-id>Store.XMainChangeSet</class-id> <category>db phantoms</category><body package="PackageCategories" selector="addRemoveClass:package:">addRemoveClass: className package: aPackage	"Adds a remove class change to aPackage, for the case of an unloadable definition."	aPackage doSubdefChange: 		( Change new removeDefinition 			className: className meta: false		).</body><body package="PackageCategories" selector="addRemoveNameSpace:package:">addRemoveNameSpace: aName package: aPackage	"Adds a remove namespace change to aPackage, for the case of an unloadable definition."	aPackage doSubdefChange: 		( Change new remove 			nameSpaceName: aName 		).</body><body package="PackageCategories" selector="addRemoveSelector:className:meta:package:">addRemoveSelector: selector className: className meta: meta package: aPackage	"Adds a remove selector change to aPackage, for the case of an unloadable definition."	aPackage doSubdefChange: 		( Change new remove 			selector: selector; 			className: className meta: meta		).</body><body package="PackageCategories" selector="addRemoveStatic:ownerName:isInNameSpace:package:">addRemoveStatic: key ownerName: ownerName  isInNameSpace: aBoolean package: aPackage	"Adds a remove static change to aPackage, for the case of an unloadable definition."	| change |	change := Change new remove dataKey: key.	aBoolean		ifTrue: [ change classSymbol: ownerName asSymbol ]		ifFalse:  [ change nameSpaceSymbol: ownerName asSymbol ].	aPackage doSubdefChange: change.</body></methods><methods><class-id>Store.XMainChangeSet class</class-id> <category>utilities</category><body package="PackageCategories" selector="ignoreChangesWhile:">ignoreChangesWhile: aBlock 	"Code changes that occur during the execution of aBlock are not 	recorded in any change set. "	^ChangeSet ignoreChangesWhile: aBlock</body><body package="PackageCategories" selector="ignoreMainChangesWhile:">ignoreMainChangesWhile: aBlock 	"Code changes that occur during the execution of aBlock are not recorded in the 	current change set.  But propagation of changes from the MainChangeSet to 	packages are still carried."	| currentCS |	currentCS := XChangeSet current.		[ XChangeSet newChanges: XMainChangeSet new.	aBlock value	] ensure: [ XChangeSet newChanges: currentCS ]</body></methods><methods><class-id>Store.XMainChangeSet class</class-id> <category>initialize</category><body package="PackageCategories" selector="initialize">initialize	self newChanges: self new.</body></methods><methods><class-id>Store.PackageForParcel</class-id> <category>private</category><body package="PackageCategories" selector="asPundle:">asPundle: relink	"Convert the receiver into a pundle. Called on parcel load. Answer the converted pundle"	| pkg |	pkg := super asPundle: relink.	pkg startLoad.	[ 	contents do:		[ :model | model addToPackage: pkg ].	pkg 		cleanse: false; 		markNotModified.	] ensure: [ pkg endLoad ].	^pkg.</body><body package="PackageCategories" selector="pundleInImage">pundleInImage	"Answer the image version of the receiver. Creates one if it doesn't exist."	^Registry packageNamedOrCreate: name.</body><body package="PackageCategories" selector="updates:fromParcel:relink:">updates: updates fromParcel: aParcel relink: relink	"Update the pundle in the image from a parcel."	"Luckily, removes and overrides are handled outside this."	| pkg |	pkg := super updates: updates fromParcel: aParcel relink: relink.	contents do:		[ :model | model updates: updates package: pkg ].	pkg 		cleanse: false; 		markNotModified.	^pkg.</body></methods><methods><class-id>Store.PackageForParcel</class-id> <category>initialization</category><body package="PackageCategories" selector="from:saveLinks:">from: aPackage saveLinks: saveLinks	super from: aPackage saveLinks: saveLinks.	contents := OrderedCollection new.	aPackage modelsDo:		[ :model |  contents add: ( ModelForParcel from: model ) ].</body></methods><methods><class-id>Store.PackageForParcel</class-id> <category>accessing</category><body package="PackageCategories" selector="definedClasses">definedClasses	"Answer the receiver's defined classes."	^( contents select: 		[ :m | m isForClass &amp; m hasDefinition ]	) collect: [ :m | m object ]</body><body package="PackageCategories" selector="definedNameSpaces">definedNameSpaces	"Answer the receiver's defined namespaces."	^( contents select: 		[ :m | m isForNameSpace &amp; m hasDefinition ]	) collect: [ :m | m object ]</body><body package="PackageCategories" selector="extendedClasses">extendedClasses	"Answer the receiver's extended classes."	^( contents select: 		[ :m | m isForClass &amp; m hasDefinition not ]	) collect: [ :m | m object ]</body></methods><methods><class-id>Store.PackageForParcel</class-id> <category>conversion</category><body package="PackageCategories" selector="installContentsUsing:">installContentsUsing: aCodeReader	"Install the pundle contents through aCodeReader"	aCodeReader installNameSpacesInSystem: self definedNameSpaces.	      aCodeReader installClassesInSystem: self definedClasses.</body></methods><methods><class-id>Store.ComponentDescription</class-id> <category>comparing</category><body package="PackageCategories" selector="=">= anObject	self class == anObject class 		ifFalse: [ ^false ].	^self describesSameAs: anObject</body><body package="PackageCategories" selector="hash">hash	^self isPackage hash bitXor: self componentName hash</body></methods><methods><class-id>Store.ComponentDescription</class-id> <category>testing</category><body package="PackageCategories" selector="describesBundleNamed:">describesBundleNamed: aString	"Answer true if the description refers to a bundle named aString."	^false</body><body package="PackageCategories" selector="describesComponent:">describesComponent: aPundle 	"Answer true if my description matches exactly aPundle"	"NOTE: assumes aPundle is the image version of the receiver."	| info |	aPundle == nil	ifTrue: [ ^false ].	id == nil			ifTrue: [ ^true ].	( info := aPundle databaseInformationFor: dbIdentifier ) == nil		ifTrue: [ ^false ].	^info dbTrace = id</body><body package="PackageCategories" selector="describesPackageNamed:">describesPackageNamed: aString	"Answer true if the description refers to a package named aString."	^false</body><body package="PackageCategories" selector="exactLoadedComponent">exactLoadedComponent	"Find if a bundle with my id is loaded into the image."	self subclassResponsibility</body><body package="PackageCategories" selector="isBundle">isBundle	^false</body><body package="PackageCategories" selector="isPackage">isPackage	^false</body><body package="PackageCategories" selector="loadedComponent">loadedComponent	"Find if a component fulfilling 	my description is loaded into the image.	My subclasses should answer this message"	self subclassResponsibility</body></methods><methods><class-id>Store.ComponentDescription</class-id> <category>printing</category><body package="PackageCategories" selector="printOn:">printOn: aStream 	aStream nextPutAll: self class name asString.	aStream nextPutAll: ' ('.	componentName == nil		ifFalse: [ aStream nextPutAll: componentName ].	aStream nextPut: $ .	id == nil		ifFalse: [ id printOn: aStream ].	dbIdentifier == nil		ifFalse: [ aStream nextPutAll: ':', dbIdentifier ].	aStream nextPut: $).</body></methods><methods><class-id>Store.ComponentDescription</class-id> <category>accessing</category><body package="PackageCategories" selector="component">component	"Find a component named componentName and answer it."	^self subclassResponsibility</body><body package="PackageCategories" selector="component:">component: aLoadedComponent 	"Set the name of the component"		componentName := aLoadedComponent name.	dbIdentifier := aLoadedComponent dbIdentifier.	id := aLoadedComponent isLoaded		ifTrue: [ aLoadedComponent dbTrace ]		ifFalse: [ aLoadedComponent primaryKey ].</body><body package="PackageCategories" selector="componentName">componentName	"Answer a component name"	componentName == nil		ifTrue: [ self setName ].	^componentName</body><body package="PackageCategories" selector="componentName:">componentName: aString	"Set a component name"	componentName := aString</body><body package="PackageCategories" selector="dbComponent">dbComponent	"Find a component named componentName and answer it."	^self subclassResponsibility</body><body package="PackageCategories" selector="dbIdentifier">dbIdentifier	^dbIdentifier</body><body package="PackageCategories" selector="dbIdentifier:">dbIdentifier: aSymbol 	"Set the database identifier."	dbIdentifier := aSymbol == nil		ifFalse: [ aSymbol asSymbol ]</body><body package="PackageCategories" selector="hasSetVersion">hasSetVersion	"A description describes a particular version of a component 	if the id field is set."	^id notNil</body><body package="PackageCategories" selector="id">id	^id</body><body package="PackageCategories" selector="id:">id: aValue	id := aValue</body><body package="PackageCategories" selector="name">name	"Answer a component name"	^self componentName</body></methods><methods><class-id>Store.ComponentDescription</class-id> <category>private</category><body package="PackageCategories" selector="setName">setName	| comp |	comp := self loadedComponent.	comp notNil ifTrue: [self component: comp]</body></methods><methods><class-id>Store.PackageDescription</class-id> <category>testing</category><body package="PackageCategories" selector="describesPackageNamed:">describesPackageNamed: aString	"Answer true if the description referes to a package named aString"	^self componentName = aString</body><body package="PackageCategories" selector="describesSameAs:">describesSameAs:  aComponentDescr	"Answer true if aComponentDescr referes to	a package named the same as my bundle"	^aComponentDescr isPackage		and: [ self describesPackageNamed: aComponentDescr name ].</body><body package="PackageCategories" selector="isPackage">isPackage	^true</body></methods><methods><class-id>Store.PackageDescription</class-id> <category>accessing</category><body package="PackageCategories" selector="component">component	"Find a component named componentName and answer it."	^componentName isNil		ifTrue: [nil]		ifFalse: [Registry packageNamed: componentName]</body><body package="PackageCategories" selector="createComponent">createComponent	"Return the component with my componentName create it if needed."	componentName isNil ifTrue: [ ^nil ].	^Registry packageNamedOrCreate: componentName.</body></methods><methods><class-id>Store.PackageDescription</class-id> <category>private</category><body package="PackageCategories" selector="leafItems">leafItems	"My component is a leaf item."	| comp |	comp := self component.	^comp isNil		ifTrue: [#()]		ifFalse: [Array with: comp]</body></methods><methods><class-id>Store.NameSpaceDescriptor</class-id> <category>accessing</category><body package="PackageCategories" selector="absoluteName">absoluteName		^fullName</body><body package="PackageCategories" selector="absoluteSymbol">absoluteSymbol		^fullName asSymbol</body><body package="PackageCategories" selector="actual">actual	^ self nameSpace</body><body package="PackageCategories" selector="comment">comment	| nspace |	^( nspace := self nameSpace) isNil		ifTrue: [ '']		ifFalse: [ nspace comment ]</body><body package="PackageCategories" selector="definition">definition	| nspace |	^( nspace := self nameSpace) isNil		ifTrue: [ '' ]		ifFalse: [ nspace definition ]</body><body package="PackageCategories" selector="environment">environment	"Answer the environment of the NameSpace. nil if it doesn't exist in the image."	^self fullName asStrictReference ifDefinedDo: [ :ns | ns environment ]</body><body package="PackageCategories" selector="existsInImage">existsInImage	"Answer true if the receiver is a valid description of an existing method."	^self nameSpace isNil not</body><body package="PackageCategories" selector="fullName">fullName		^fullName</body><body package="PackageCategories" selector="fullName:">fullName: aString		fullName := aString</body><body package="PackageCategories" selector="myClass">myClass	"Give a class name answer a class."	self shouldNotImplement</body><body package="PackageCategories" selector="name">name	^( self fullName tokensBasedOn: $. ) last</body><body package="PackageCategories" selector="nameSpace">nameSpace	^self fullName asStrictReference valueOrDo: [ nil ]</body><body package="PackageCategories" selector="symbol">symbol	^self absoluteSymbol</body><body package="PackageCategories" selector="textRepresentationForTag:">textRepresentationForTag: aTag 	^aTag isCommentTag		ifTrue: [ self comment ]		ifFalse: [ self definition ]</body><body package="PackageCategories" selector="xmlDefinition">xmlDefinition	| nspace |	^( nspace := self nameSpace) isNil		ifTrue: [ '' ]		ifFalse: [ nspace xmlDefinition ]</body></methods><methods><class-id>Store.NameSpaceDescriptor</class-id> <category>comparing</category><body package="PackageCategories" selector="&lt;=">&lt;= aNameSpaceDescriptor	^self fullName &lt;= aNameSpaceDescriptor fullName</body><body package="PackageCategories" selector="=">= aThing	^self sameAs: aThing</body><body package="PackageCategories" selector="comparesTo:">comparesTo: anObject	"Answer true if anObject could be another version of the receiver."	( self objectIsForSelf: anObject ) ifFalse: [ ^false ].	^anObject absoluteName = self absoluteName.</body><body package="PackageCategories" selector="hash">hash	^self fullName hash</body><body package="PackageCategories" selector="objectIsForSelf:">objectIsForSelf: anObject	"Answer true if anObject represents the same kind of thing as the reciever."	^anObject isForNameSpace</body><body package="PackageCategories" selector="sameAsImThing:">sameAsImThing:  aNameSpace	^aNameSpace absoluteName = self absoluteName</body></methods><methods><class-id>Store.NameSpaceDescriptor</class-id> <category>browser support</category><body package="PackageCategories" selector="asNameSpace">asNameSpace	^self actual asNameSpace</body><body package="PackageCategories" selector="asString">asString	^self simpleName</body><body package="PackageCategories" selector="binding">binding	^self"		| ref |	^( ref := self fullName asQualifiedReference ) isDefined 		ifTrue: [ ref binding ]		ifFalse: [ nil ]."</body><body package="PackageCategories" selector="classifySymbol:under:">classifySymbol: varName under: protocol	^self value classifySymbol: varName under: protocol</body><body package="PackageCategories" selector="containingPackages">containingPackages	"Answer all the packges that contain the definition for the receiver, 	including overriden."	^Registry allContainingPackagesForClassOrNameSpace: self actual</body><body package="PackageCategories" selector="isDefined">isDefined	"Answer wheter the receiver exists in the image. aka #isDefined for bindings."	self valueOrDo: [ ^false ].	^true.</body><body package="PackageCategories" selector="organization">organization	^self value organization</body><body package="PackageCategories" selector="renameCategory:to:">renameCategory: oldCategory to: newCategory	^self value renameCategory: oldCategory to: newCategory</body><body package="PackageCategories" selector="simpleName">simpleName	^self fullName asStrictReference simpleName</body><body package="PackageCategories" selector="value">value	^self fullName asStrictReference value</body><body package="PackageCategories" selector="valueOrDo:">valueOrDo: aBlock	^self fullName asStrictReference valueOrDo: aBlock</body></methods><methods><class-id>Store.NameSpaceDescriptor</class-id> <category>testing</category><body package="PackageCategories" selector="isForNameSpace">isForNameSpace	^true</body></methods><methods><class-id>Store.NameSpaceDescriptor</class-id> <category>printing</category><body package="PackageCategories" selector="displayString">displayString	^self name</body><body package="PackageCategories" selector="printOn:">printOn: aStream	aStream nextPutAll: self class name, '(', 		( SystemUtils convertAbsoluteNameToFull: fullName ) , ')'.</body></methods><methods><class-id>Store.NameSpaceDescriptor</class-id> <category>filing out</category><body package="PackageCategories" selector="fileOutSourceOn:">fileOutSourceOn: aStream	"File the receiver out on aSourceFileManager."	self actual == nil		ifFalse: [ self actual fileOutSourceOn: aStream ].</body></methods><methods><class-id>Store.NameSpaceDescriptor class</class-id> <category>instance creation</category><body package="PackageCategories" selector="fromModel:">fromModel: aNameSpaceModel	^self fullName: aNameSpaceModel absoluteName</body><body package="PackageCategories" selector="fullName:">fullName: aName 	^self new		fullName: aName;		yourself.</body></methods><methods><class-id>Store.ExtensionNameSpaceModel</class-id> <category>testing</category><body package="PackageCategories" selector="hasDefinition">hasDefinition	^false</body><body package="PackageCategories" selector="isEmpty">isEmpty	"Is this model holding onto nothing?"	^data size = 0</body><body package="PackageCategories" selector="isExtension">isExtension	^true</body></methods><methods><class-id>Store.ExtensionNameSpaceModel</class-id> <category>data accessing</category><body package="PackageCategories" selector="addDataKey:">addDataKey: aDataKey	self privateData add: aDataKey</body><body package="PackageCategories" selector="dataKeys">dataKeys	^data == nil		ifTrue: [ IdentitySet new ]		ifFalse: [ data ]</body><body package="PackageCategories" selector="includesDataKey:">includesDataKey: dataKey	^self dataKeys includes: dataKey</body><body package="PackageCategories" selector="quickIncludesDataKey:">quickIncludesDataKey: dataKey	^self includesDataKey: dataKey</body><body package="PackageCategories" selector="removeDataKey:">removeDataKey: dataKey	super removeDataKey: dataKey.	data == nil ifTrue: [ ^self ].	self privateData remove: dataKey ifAbsent: [ ]</body></methods><methods><class-id>Store.ExtensionNameSpaceModel</class-id> <category>private</category><body package="PackageCategories" selector="privateData">privateData	"Answer dataKeys defined by the receiver. Initialize the set if empty."	data isNil ifTrue: [ data := IdentitySet new ].	^data</body></methods><methods><class-id>Store.Changes</class-id> <category>printing</category><body package="PackageCategories" selector="printOn:">printOn: aStream 	"Append to the argument aStream a sequence of characters that 	identifies the receiver."	self putStatsOn: aStream</body></methods><methods><class-id>Store.Changes</class-id> <category>testing</category><body package="PackageCategories" selector="isAdded">isAdded	^self defChangesIncludes: #add</body><body package="PackageCategories" selector="isChanged">isChanged	^self defChangesIncludes: #change</body><body package="PackageCategories" selector="isDataModified">isDataModified	^( self getDataChangesIfNone: [ ^false ] ) size &gt; 0</body><body package="PackageCategories" selector="isDefinitionChanged">isDefinitionChanged	self subclassResponsibility</body><body package="PackageCategories" selector="isDefinitionRemoved">isDefinitionRemoved	^self defChangesIncludes: #removeDefinition</body><body package="PackageCategories" selector="isForClass">isForClass	^false</body><body package="PackageCategories" selector="isForNameSpace">isForNameSpace	^false</body><body package="PackageCategories" selector="isModified">isModified	^( defChanges size &gt; 0 )  |   ( dataChanges size &gt; 0 )</body><body package="PackageCategories" selector="isOverridden">isOverridden	^self defChangesIncludes: #override</body><body package="PackageCategories" selector="isRelocated">isRelocated	^self defChangesIncludes: #relocate</body><body package="PackageCategories" selector="isRemoved">isRemoved	^self defChangesIncludes: #remove</body><body package="PackageCategories" selector="isRenamed">isRenamed	^self defChangesIncludes: #rename</body></methods><methods><class-id>Store.Changes</class-id> <category>private-access</category><body package="PackageCategories" selector="alterChanges">alterChanges	defChanges isNil ifTrue: [ defChanges := Set new ].	^defChanges</body><body package="PackageCategories" selector="alterDataChanges">alterDataChanges	dataChanges isNil ifTrue: [dataChanges := IdentityDictionary new].	^dataChanges</body><body package="PackageCategories" selector="getDataChangesIfNone:">getDataChangesIfNone: aBlock	dataChanges isNil ifTrue: [ ^aBlock value ].	^dataChanges</body><body package="PackageCategories" selector="getDefChangesIfNone:">getDefChangesIfNone: aBlock	defChanges isNil ifTrue: [ ^aBlock value ].	^defChanges</body></methods><methods><class-id>Store.Changes</class-id> <category>private-queries</category><body package="PackageCategories" selector="defChangesIncludes:">defChangesIncludes: changeType 	^( self getDefChangesIfNone: [ ^false ] )		includes: changeType</body><body package="PackageCategories" selector="modifiedKeysSubdefChanges:">modifiedKeysSubdefChanges: subdefChanges	| mods |	mods := OrderedCollection new.	subdefChanges isNil 		ifFalse: 			[ subdefChanges keysAndValuesDo: 				[ :key :changeType | 				( changeType ~~ #remove ) &amp; ( changeType ~~ #override )					ifTrue: [ mods add: key ]				]			].	^mods</body><body package="PackageCategories" selector="nameSpaceChangeTypes">nameSpaceChangeTypes	^#( #add #removeDefinition #remove #change #rename #reorganize #comment )</body><body package="PackageCategories" selector="removedKeysSubdefChanges:">removedKeysSubdefChanges: subdefChanges	| mods |	mods := OrderedCollection new.	subdefChanges isNil ifFalse: 		[		subdefChanges keysAndValuesDo: 			[ :key :changeType | 			changeType == #remove ifTrue: [ mods add: key ]			]		].	^mods</body></methods><methods><class-id>Store.Changes</class-id> <category>accessing</category><body package="PackageCategories" selector="itemCount">itemCount	^defChanges size + dataChanges size</body><body package="PackageCategories" selector="modifiedDataKeys">modifiedDataKeys	^self modifiedKeysSubdefChanges: ( self getDataChangesIfNone: [ nil ] )</body><body package="PackageCategories" selector="modifiedTags">modifiedTags	"Answer a collection of tags for changed or add definitions,	methods or data, not including removed definitions."	self subclassResponsibility</body><body package="PackageCategories" selector="oldName">oldName 	| name |	name := (self getDefChangesIfNone: [self error: 'class changes empty']) 					detect: [ :x | x isString and: [ 'oldName: *' match: x ] ] 					ifNone: [ ^'ERROR oldName not found' asSymbol ].	^(Compiler preferredParserClass new scanTokens: name) last asSymbol</body><body package="PackageCategories" selector="reflection">reflection	"Answer a reflection of the receiver- the opposite of any change."	| reflection |	reflection := self class symbol: symbol.	( self getDefChangesIfNone: [ #() ] ) do:		[ :type | reflection doChangeType: ( self reverse: type )	].	self dataChanges do:		[ :change | reflection doSubdefChange: ( self subdefReverse: change ) ].	^reflection.</body><body package="PackageCategories" selector="removedDataKeys">removedDataKeys	^self removedKeysSubdefChanges: (self getDataChangesIfNone: [nil])</body><body package="PackageCategories" selector="removedTags">removedTags	"Answer a collection of tags for removed definitions, methods or data."	self subclassResponsibility</body><body package="PackageCategories" selector="symbol">symbol	"class or namespace symbol"	^symbol</body><body package="PackageCategories" selector="symbol:">symbol: aSymbol	"class or namespace symbol"	symbol := aSymbol asSymbol</body></methods><methods><class-id>Store.Changes</class-id> <category>private-changes</category><body package="PackageCategories" selector="commentChanges">commentChanges	^#( #comment #commentMeta )</body><body package="PackageCategories" selector="defChanges">defChanges	^#( #add #removeDefinition #remove #change #rename #changeMeta #commentMeta)</body><body package="PackageCategories" selector="internalError:">internalError: warning"	StoreWarning raiseSignal: 		( 'Proceedable Internal Error&lt;n&gt;&lt;1s&gt;: &lt;2s&gt;'			expandMacrosWith: self class printString			with: warning		)"</body><body package="PackageCategories" selector="modifyAll">modifyAll	"For cases where we don't know what changed, assume everything changed."	self initializeChanges.		#( #change #reorganize #comment ) 		do: [:ct | self alterChanges add: ct].</body><body package="PackageCategories" selector="reverse:">reverse: changeType	"Answer a change that reflects the opposite of changeType 	- for ChangeSet reflections."	changeType == #add		ifTrue: [ ^#remove ].	changeType == #remove		ifTrue: [ ^#add ].	changeType == #removeDefinition		ifTrue: [ ^#add ].	^changeType</body><body package="PackageCategories" selector="subdefChanges:changeType:key:">subdefChanges: subdefChanges changeType: changeType key: key 	"Process the subdef change."	"For overrides, both an override and a remove come through and the net result should be no change."	| oldType |	changeType == #removeChanges 		ifTrue: [ ^subdefChanges removeKey: key ifAbsent: [nil ] ].	oldType := subdefChanges at: key ifAbsent: [ #none ].	changeType == #override		ifTrue:			[ ^oldType == #remove				ifTrue: [ subdefChanges removeKey: key ifAbsent: [nil ] ]				ifFalse: [ subdefChanges at: key put: #override ]			].	( oldType == #override and: [ changeType == #remove ] )		ifTrue: [ ^subdefChanges removeKey: key ifAbsent: [nil ] ].	( changeType == #add ) &amp; ( oldType == #remove ) 		ifTrue: [ ^subdefChanges at: key put: #change ].	( changeType == #remove ) &amp; ( oldType == #add ) 		ifTrue: [ ^subdefChanges removeKey: key ].	( changeType == #change ) &amp; ( oldType == #add )		ifTrue: [ ^self ].	subdefChanges at: key put: changeType.</body><body package="PackageCategories" selector="subdefReverse:">subdefReverse: aChange	"Reverse a change to reflect the opposite of aChange's changeType 	- for ChangeSet reflections."	aChange isAdd		ifTrue: [ ^aChange remove; yourself ].	aChange isRemove		ifTrue: [ ^aChange add; yourself ].	^aChange</body></methods><methods><class-id>Store.Changes</class-id> <category>initialize-release</category><body package="PackageCategories" selector="initialize">initialize	self initializeChanges.	self initializeSubdefChanges</body><body package="PackageCategories" selector="initializeChanges">initializeChanges	defChanges := nil.</body><body package="PackageCategories" selector="initializeSubdefChanges">initializeSubdefChanges	dataChanges := nil.</body></methods><methods><class-id>Store.Changes</class-id> <category>changes</category><body package="PackageCategories" selector="doChangeType:">doChangeType: changeType	"Make change 'changeType' to the receiver.	If the  class/namespace was previously removed		removing again is redundant and may indicate problems		adding (after a remove) is like changing everything - cannot be add because of possible future remove		if overriding, clear the removal, to clear ChangeSet		some other kind of modification should not occur, assume we missed an add	if the class/namespace was previously added		removing clears all changes:  X - X = 0		adding is redundant		other modifications are legitimate but are already covered in the add state	if the class/namespace was not changed or was modified		removing should become removal (only)		adding to an unchanged becomes an add, but to something with changes should not occur		other modifications are included in the set of modifications."	"For overrides, both an override and a remove come through and the net result should be no change."	| nowRemoved nowAdded nowOverridden |	nowRemoved := changeType == #removeDefinition | ( changeType == #remove ).	nowAdded := changeType == #add.	nowOverridden := changeType == #override.	nowOverridden		ifTrue: 			[ ^( self isRemoved or: [ self isDefinitionRemoved ] )				ifTrue: [ self initializeChanges ]	"cancels the removal"				ifFalse: [ self alterChanges add: changeType ].	"save mark for removal"			].	nowRemoved		ifTrue: 			[ self isOverridden 				ifTrue: [ ^self initializeChanges ]	"cancels override"			].	( self isRemoved or: [ self isDefinitionRemoved ] )		ifTrue: 			[ ^nowRemoved				ifTrue: [ self internalError: (#redundantRemove &lt;&lt; #packages &gt;&gt; 'redundant remove') ]				ifFalse: 					[ nowAdded						ifTrue: [ self modifyAll ]						ifFalse:							[ self internalError:  ((#changeAppliedToMissingClassOrNamespace &lt;&lt; #packages &gt;&gt; '&lt;1s&gt; to removed namespace/class')								expandMacrosWith: changeType asString).							self modifyAll							]					]			].	self isAdded		ifTrue: 			[ nowRemoved				ifTrue: [ self initializeChanges ]				ifFalse: [ nowAdded								ifTrue: [ self modifyAll ] 							ifFalse: [ self alterChanges add: changeType ]						]			]		ifFalse: 			[ nowRemoved				ifTrue: 					[ self initializeChanges.					self alterChanges add: changeType					]				ifFalse: 					[ | cha |					cha := self alterChanges.					nowAdded						ifTrue: 							[ cha size = 0								ifTrue: [ cha add: changeType ]								ifFalse: 	[ self modifyAll ]							]						ifFalse: [ cha add: changeType ]					]			]</body><body package="PackageCategories" selector="removeDefChanges:">removeDefChanges: changes	changes do:		[ :sym | self alterChanges remove: sym ifAbsent: nil ].</body><body package="PackageCategories" selector="renameOldSymbol:">renameOldSymbol: oldSymbol 	"Include indication that a namespace/class has been renamed."	"only original name of pre-existing class matters"	( ( self isRenamed ) 	or: [ self isAdded ] )		ifFalse: 			[ self alterChanges add: 'oldName: ' , oldSymbol.			self alterChanges add: #rename			]</body></methods><methods><class-id>Store.Changes</class-id> <category>fileIn/Out</category><body package="PackageCategories" selector="fileOutDataChangesFor:for:within:on:">fileOutDataChangesFor: object for: aPackage within: aBundle on: fileManager 	| removes changes dChanges |	removes := OrderedCollection new.	changes := OrderedCollection new.	dChanges := self getDataChangesIfNone: [ nil ].	dChanges notNil ifTrue: 		[ dChanges keysAndValuesDo: 			[ :key :change | 			change = #remove				ifTrue: [ ( self isRemoved or: [ self isDefinitionRemoved ] ) 						ifFalse: [ removes add: key ] ]				ifFalse: [ changes add: key ]			]		].	changes isEmpty 		ifFalse: 			[ ( aPackage == nil or: [ aPackage isLoaded ] ) 				ifTrue: [ fileManager fileOutData: changes for: object asNameSpace ]				ifFalse: [ aPackage fileOutDataKeys: changes in: object on: fileManager ].			].	removes do:		[ :key |		( ( aBundle ~~ nil ) and: 				[ aBundle includesDataKey: key ownerName: symbol asString ] )			ifFalse: [ fileManager removeObject: object fullName, '.', key type: #variable ]		].</body><body package="PackageCategories" selector="fileOutDataChangesFor:on:within:">fileOutDataChangesFor: object on: fileManager within: aBundle	| removes changes dChanges |	removes := OrderedCollection new.	changes := OrderedCollection new.	dChanges := self getDataChangesIfNone: [ nil ].	dChanges notNil ifTrue: 		[ dChanges keysAndValuesDo: 			[ :key :change | 			change = #remove				ifTrue: [ ( self isRemoved or: [ self isDefinitionRemoved ] ) 						ifFalse: [ removes add: key ] ]				ifFalse: [ changes add: key ]			]		].	changes isEmpty ifFalse: 		[ fileManager fileOutData: changes for: object asNameSpace ].	removes do:		[ :key |		( ( aBundle ~~ nil ) and: 				[ aBundle includesDataKey: key ownerName: symbol asString ] )			ifFalse: [ fileManager removeObject: object fullName, '.', key type: #variable ]		].</body><body package="PackageCategories" selector="fileOutObjectType">fileOutObjectType	"Answer a symbol that represents the type of the receiver."	^self subclassResponsibility</body><body package="PackageCategories" selector="putDataStatsOn:">putDataStatsOn: stream 	| removes changes adds |	removes := OrderedCollection new.	changes := OrderedCollection new.	adds := OrderedCollection new.	(self getDataChangesIfNone: [ ^self] )		keysAndValuesDo: [:mSel :mChange | mChange = #remove				ifTrue: [removes add: mSel]				ifFalse: [mChange = #change						ifTrue: [changes add: mSel]						ifFalse: [adds add: mSel]]].	adds isEmpty		ifFalse: 			[stream tab; tab; nextPutAll: (#AddedDataC &lt;&lt; #packages &gt;&gt; 'Added data:') asString; cr.			adds do: [:dataKey | stream tab; tab; tab; nextPutAll: dataKey; cr]].	changes isEmpty		ifFalse: 			[stream tab; tab; nextPutAll: (#ChangedDataC &lt;&lt; #packages &gt;&gt; 'Changed data:') asString; cr.			changes do: [:dataKey | stream tab; tab; tab; nextPutAll: dataKey; cr]].	removes isEmpty		ifFalse: 			[stream tab; tab; nextPutAll: (#RemovedDataC &lt;&lt; #packages &gt;&gt; 'Removed data:') asString; cr.			removes do: [:dataKey | stream tab; tab; tab; nextPutAll: dataKey; cr]]</body></methods><methods><class-id>Store.Changes</class-id> <category>actions</category><body package="PackageCategories" selector="forgetDataChange:">forgetDataChange: dataKey	"Forget all changes relating to a dataKey"	( self getDataChangesIfNone: [ ^nil ] )		removeKey: dataKey ifAbsent: nil.</body><body package="PackageCategories" selector="forgetTag:">forgetTag: aTag	"Forget changes associated with aTag."	aTag isCommentTag		ifTrue: [ ^self removeDefChanges: self commentChanges ].	aTag isForClass | aTag isForNameSpace		ifTrue: [ ^self removeDefChanges: self defChanges ].	aTag isForData		ifTrue: [ ^self forgetDataChange: aTag dataKey.].	aTag isForMethod		ifTrue: [ ^self forgetMethod: aTag selector meta: aTag isMeta.].</body></methods><methods><class-id>Store.Changes class</class-id> <category>instance creation</category><body package="PackageCategories" selector="symbol:">symbol: aSymbol	^self new		symbol: aSymbol;		yourself.</body></methods><methods><class-id>Store.NameSpaceChanges</class-id> <category>changes</category><body package="PackageCategories" selector="doChange:">doChange: change 	super doChangeType: change type.</body><body package="PackageCategories" selector="doSubdefChange:">doSubdefChange: change 	self subdefChanges: self alterDataChanges 			changeType: change type key: change key</body></methods><methods><class-id>Store.NameSpaceChanges</class-id> <category>testing</category><body package="PackageCategories" selector="isCommented">isCommented	^self defChangesIncludes: #comment</body><body package="PackageCategories" selector="isDefinitionChanged">isDefinitionChanged	^self defChangesIncludes: #change</body><body package="PackageCategories" selector="isForNameSpace">isForNameSpace	^true</body><body package="PackageCategories" selector="isNonDestructivelyModified">isNonDestructivelyModified	( self getDefChangesIfNone: [ ^false ] ) do: 		[ :changeType | 		( #( #add #change #reorganize #comment ) 				includes: changeType )  ifTrue: [ ^true ] 		].	^false</body><body package="PackageCategories" selector="isReorganized">isReorganized	^self defChangesIncludes: #reorganize</body></methods><methods><class-id>Store.ClassChanges</class-id> <category>testing</category><body package="PackageCategories" selector="areMethodsModifiedMeta:">areMethodsModifiedMeta: meta	^(self getMethodChangesMeta: meta ifNone: [^false]) size &gt; 0</body><body package="PackageCategories" selector="isClassChangedMeta:">isClassChangedMeta: meta	^self defChangesIncludes: (meta ifTrue: [#changeMeta] ifFalse: [#change])</body><body package="PackageCategories" selector="isClassCommentedMeta:">isClassCommentedMeta: meta	^self defChangesIncludes: (meta ifTrue: [#commentMeta] ifFalse: [#comment])</body><body package="PackageCategories" selector="isClassModifiedMeta:">isClassModifiedMeta: meta	( self getDefChangesIfNone: [^false] ) do: 		[ :changeType | 		( ( self classChangeTypesMeta: meta ) includes: changeType )			ifTrue: [ ^true ]		].	^false</body><body package="PackageCategories" selector="isClassNonDestructivelyModified">isClassNonDestructivelyModified	(self getDefChangesIfNone: [^false]) do: [:changeType | (#(changeMeta #reorganizeMeta #commentMeta #add #change #reorganize #comment) includes: changeType)				ifTrue: [^true]].	^false</body><body package="PackageCategories" selector="isClassReorganizedMeta:">isClassReorganizedMeta: meta	^self defChangesIncludes: (meta ifTrue: [#reorganizeMeta] ifFalse: [#reorganize])</body><body package="PackageCategories" selector="isCommented">isCommented	^( self isClassCommentedMeta: false )		|  (  self isClassCommentedMeta: true  )</body><body package="PackageCategories" selector="isDefinitionChanged">isDefinitionChanged	^( self isClassChangedMeta: false )  | 			 ( self isClassChangedMeta: true )</body><body package="PackageCategories" selector="isDefTypeModified:">isDefTypeModified: defType	^defType == #data		ifTrue: [ self isDataModified ]		ifFalse: [ self isMetaModified: ( defType == #meta ) ]</body><body package="PackageCategories" selector="isForClass">isForClass	^true</body><body package="PackageCategories" selector="isMetaModified:">isMetaModified: isMeta	^isMeta		ifTrue: [ metaMethodChanges size &gt; 0 ]		ifFalse: [ methodChanges size &gt; 0 ]</body><body package="PackageCategories" selector="isMethodChangedSelector:meta:">isMethodChangedSelector: selector meta: meta	| dict |	dict := self getMethodChangesMeta: meta ifNone: [^false].	^(dict at: selector ifAbsent: [^false]) == #change</body><body package="PackageCategories" selector="isModified">isModified	^super isModified  |		( methodChanges size &gt; 0 )  |		( metaMethodChanges size &gt; 0 )</body><body package="PackageCategories" selector="isModifiedMeta:">isModifiedMeta: meta	(self areMethodsModifiedMeta: meta) ifTrue: [ ^true ].	(self isClassModifiedMeta: meta) ifTrue: [ ^true ].	^false</body><body package="PackageCategories" selector="isNonDestructivelyModified">isNonDestructivelyModified	( self getDefChangesIfNone: [ ^false ] ) do: 		[ :changeType | 		( #( #changeMeta #reorganizeMeta #commentMeta #add #change #reorganize #comment ) 				includes: changeType )  ifTrue: [ ^true ] 		].	^false</body><body package="PackageCategories" selector="isReorganized">isReorganized	^( self isClassReorganizedMeta: true )  |		( self isClassReorganizedMeta: false )</body></methods><methods><class-id>Store.ClassChanges</class-id> <category>changes</category><body package="PackageCategories" selector="doChange:">doChange: change 	super doChangeType: ( change typeWithMeta ).</body><body package="PackageCategories" selector="doSubdefChange:">doSubdefChange: change 	change isDataChange		ifTrue: 			[ self subdefChanges: self alterDataChanges 				changeType: change type key: change key			]		ifFalse:			[ self subdefChanges: ( self alterMethodChangesMeta: change meta ) 				changeType: change type key: change key.			].</body></methods><methods><class-id>Store.ClassChanges</class-id> <category>private-queries</category><body package="PackageCategories" selector="classChangeTypesMeta:">classChangeTypesMeta: meta 	^meta		ifTrue: [#(#changeMeta #reorganizeMeta #commentMeta)]		ifFalse: [#(#add #removeDefinition #remove #change #rename #reorganize #comment)]</body></methods><methods><class-id>Store.ClassChanges</class-id> <category>private-changes</category><body package="PackageCategories" selector="modifyAll">modifyAll	"For cases where we don't know what changed 	for the class, assume everything changed."	super modifyAll.	#( #changeMeta #reorganizeMeta #commentMeta ) 		do: [ :ct | self alterChanges add: ct ]</body></methods><methods><class-id>Store.ClassChanges</class-id> <category>initialize-release</category><body package="PackageCategories" selector="initializeSubdefChanges">initializeSubdefChanges	methodChanges := nil.	metaMethodChanges := nil.	dataChanges := nil.</body></methods><methods><class-id>Store.ClassChanges</class-id> <category>actions</category><body package="PackageCategories" selector="forgetMethod:meta:">forgetMethod: selector meta: isMeta	| selectors |		selectors := self getMethodChangesMeta: isMeta ifNone: [ ^self ].	selectors removeKey: selector ifAbsent: [ nil ]</body><body package="PackageCategories" selector="forgetMethodChange:meta:">forgetMethodChange: selector meta: isMeta	| selectors |		selectors := self getMethodChangesMeta: isMeta ifNone: [ ^self ].	selectors removeKey: selector ifAbsent: nil.</body></methods><methods><class-id>Store.ClassChanges</class-id> <category>accessing</category><body package="PackageCategories" selector="dataChanges">dataChanges	"Answer a collection of Changes for all modified/added/removed statics."	| coll |	dataChanges == nil		ifTrue: [ ^#( ) ].	coll := OrderedCollection new.	dataChanges keysAndValuesDo:		[ :key :type | 		coll add:			( Change new				classSymbol: symbol;				dataKey: key;				perform: type;				yourself				)		].	^coll</body><body package="PackageCategories" selector="itemCount">itemCount	^super itemCount + methodChanges size + metaMethodChanges size</body><body package="PackageCategories" selector="methodChanges">methodChanges	"Answer a collection of Changes for all modified/added/removed statics."	| coll |	coll := OrderedCollection new.	methodChanges == nil		ifFalse:			[ methodChanges keysAndValuesDo:				[ :key :type | 				coll add:					( Change new						classSymbol: symbol;						selector: key;						perform: type;						yourself						)				].			].	metaMethodChanges == nil		ifFalse:				[ metaMethodChanges keysAndValuesDo:				[ :key :type | 				coll add:					( Change new						classSymbol: symbol, ' class';						selector: key;						perform: type;						yourself						)				].			].	^coll</body><body package="PackageCategories" selector="modifiedDatumDescriptors">modifiedDatumDescriptors	^( self getDataChangesIfNone: [ ^#( ) ] ) keys collect:		[ :key  | DatumDescriptor fromDataKey: key className: symbol asString ].</body><body package="PackageCategories" selector="modifiedMethodDescriptorsMeta:">modifiedMethodDescriptorsMeta: isMeta	^( self getMethodChangesMeta: isMeta ifNone: [ ^#( ) ] ) keys collect:		[ :key  | MethodDescriptor fromSelector: key className: symbol asString meta: isMeta ].</body><body package="PackageCategories" selector="modifiedSelectorsMeta:">modifiedSelectorsMeta: meta 	^self modifiedKeysSubdefChanges: (self getMethodChangesMeta: meta ifNone: [nil])</body><body package="PackageCategories" selector="reflection">reflection	"Answer a reflection of the receiver- the opposite of any change."	| reflection |	reflection := super reflection.	self methodChanges do:		[ :change | reflection doSubdefChange: ( self subdefReverse: change ) ].	^reflection.</body><body package="PackageCategories" selector="removedSelectorsMeta:">removedSelectorsMeta: meta 	^self removedKeysSubdefChanges: (self getMethodChangesMeta: meta ifNone: [nil])</body></methods><methods><class-id>Store.ClassChanges</class-id> <category>private-access</category><body package="PackageCategories" selector="alterMethodChangesMeta:">alterMethodChangesMeta: meta 	^meta		ifTrue: 			[ metaMethodChanges == nil 					ifTrue: [ metaMethodChanges := IdentityDictionary new ].			metaMethodChanges			]		ifFalse: 			[ methodChanges == nil 				ifTrue: [ methodChanges := IdentityDictionary new ].			methodChanges			]</body><body package="PackageCategories" selector="getMethodChangesMeta:ifNone:">getMethodChangesMeta: meta ifNone: aBlock	| dict |	dict := meta		ifTrue: [metaMethodChanges]		ifFalse: [methodChanges].	dict isNil ifTrue: [^aBlock value].	^dict</body></methods><methods><class-id>Store.ClassChanges</class-id> <category>fileIn/Out</category><body package="PackageCategories" selector="putDefStatsOn:">putDefStatsOn: stream 	self isAdded ifTrue: [stream nextPutAll: (#ClassAdded &lt;&lt; #packages &gt;&gt; 'Class added.') asString; cr].	self isRenamed ifTrue: [stream nextPutAll: ((#ClassRenamedFrom1s &lt;&lt; #packages &gt;&gt; 'Class renamed from &lt;1s&gt;.')			expandMacrosWith: self oldName); cr].	self isDefinitionRemoved ifTrue: [stream nextPutAll: (#ClassDefinitionRemoved &lt;&lt; #packages &gt;&gt; 'Class definition removed.') asString; cr].	self isRemoved ifTrue: [stream nextPutAll: (#ClassRemoved &lt;&lt; #packages &gt;&gt; 'Class removed.') asString; cr].	(self isClassChangedMeta: false) ifTrue: [stream nextPutAll: (#ClassRedefined &lt;&lt; #packages &gt;&gt; 'Class redefined.') asString; cr].	self isOverridden ifTrue: [ stream nextPutAll: (#ClassOverridden &lt;&lt; #packages &gt;&gt; 'Class overridden.') asString; cr ].	(self isClassChangedMeta: true) ifTrue: [stream nextPutAll: (#MetaclassRedefined &lt;&lt; #packages &gt;&gt; 'Metaclass redefined.') asString; cr].	(self isClassReorganizedMeta: false) ifTrue: [stream nextPutAll: (#ClassReorganized &lt;&lt; #packages &gt;&gt; 'Class reorganized.') asString; cr].	(self isClassReorganizedMeta: true) ifTrue: [stream nextPutAll: (#MetaclassReorganized &lt;&lt; #packages &gt;&gt; 'Metaclass reorganized.') asString; cr].	(self isClassCommentedMeta: false) ifTrue: [stream nextPutAll: (#ClassCommentChanged &lt;&lt; #packages &gt;&gt; 'Class comment changed.') asString; cr].	(self isClassCommentedMeta: true) ifTrue: [stream nextPutAll: (#MetaclassCommentChanged &lt;&lt; #packages &gt;&gt; 'Metaclass comment changed.') asString; cr].</body><body package="PackageCategories" selector="putMethodStatsMeta:on:">putMethodStatsMeta: meta on: stream 	| removes changes adds |	removes := OrderedCollection new.	changes := OrderedCollection new.	adds := OrderedCollection new.	(self getMethodChangesMeta: meta ifNone: [^self])		keysAndValuesDo: [:mSel :mChange | mChange = #remove				ifTrue: [removes add: mSel]				ifFalse: [mChange = #change						ifTrue: [changes add: mSel]						ifFalse: [adds add: mSel]]].	adds isEmpty		ifFalse: 			[stream tab; tab; nextPutAll: (#AddedMethodsC &lt;&lt; #packages &gt;&gt; 'Added methods:') asString; cr.			adds do: [:selector | stream tab; tab; tab; nextPutAll: selector; cr]].	changes isEmpty		ifFalse: 			[stream tab; tab; nextPutAll: (#ChangedMethodsC &lt;&lt; #packages &gt;&gt; 'Changed methods:') asString; cr.			changes do: [:selector | stream tab; tab; tab; nextPutAll: selector; cr]].	removes isEmpty		ifFalse: 			[stream tab; tab; nextPutAll: (#RemovedMethodsC &lt;&lt; #packages &gt;&gt; 'Removed methods:') asString; cr.			removes do: [:selector | stream tab; tab; tab; nextPutAll: selector; cr]]</body><body package="PackageCategories" selector="putStatsOn:">putStatsOn: stream 	self putDefStatsOn: stream.	self putDataStatsOn: stream.	(self areMethodsModifiedMeta: false)		ifTrue: 			[stream nextPutAll: (#InstanceMethodsChanged &lt;&lt; #packages &gt;&gt; 'Instance side methods changed:') asString; cr.			self putMethodStatsMeta: false on: stream].	(self areMethodsModifiedMeta: true)		ifTrue: 			[stream nextPutAll: (#ClassSideMethodsChangedC &lt;&lt; #packages &gt;&gt; 'Class side methods changed:') asString; cr.			self putMethodStatsMeta: true on: stream].	self isDataModified		ifTrue: 			[stream nextPutAll: (#DataChangedC &lt;&lt; #packages &gt;&gt; 'Data changed:') asString; cr.			self putDataStatsOn: stream			].</body></methods><methods><class-id>Store.ClassChanges class</class-id> <category>instance creation</category><body package="PackageCategories" selector="new">new	^super new initialize</body></methods><methods><class-id>Store.BundleDescription</class-id> <category>testing</category><body package="PackageCategories" selector="describesBundleNamed:">describesBundleNamed: aString	"Answer true if the description refers to a bundle named aString"	^self componentName = aString</body><body package="PackageCategories" selector="describesSameAs:">describesSameAs:  aComponentDescr	"Answer true if aComponentDescr refers to	a bundle named the same as my bundle"	^aComponentDescr isBundle		and: [ self describesBundleNamed: aComponentDescr name ].</body><body package="PackageCategories" selector="exactLoadedComponent">exactLoadedComponent	"Find if a bundle with my id is loaded into the image."	id isNil ifTrue: [^nil].	Registry bundlesDo: 		[ :bndl | 		bndl dbTrace = id 			ifTrue: 				[ ^bndl hasBeenModified					ifTrue: [ nil ]					ifFalse: [ bndl ]				]		].	^nil</body><body package="PackageCategories" selector="isBundle">isBundle	^true</body><body package="PackageCategories" selector="loadedComponent">loadedComponent	"Find if a bundle fullfilling my description is loaded into the image."	componentName == nil		ifFalse: [ ^Registry bundleNamed: componentName ].	id isNil ifTrue: [ ^nil ].	Registry bundlesDo: 		[ :bndl | 		bndl dbTrace = id 			ifTrue: 				[ ^bndl hasBeenModified					ifTrue: [ nil ]					ifFalse: [ bndl ]				]		].	^nil</body></methods><methods><class-id>Store.BundleDescription</class-id> <category>accessing</category><body package="PackageCategories" selector="component">component	"Find a component named componentName and answer it."	^componentName == nil		ifTrue: [ nil ]		ifFalse: [ Registry bundleNamed: componentName ]</body><body package="PackageCategories" selector="createComponent">createComponent	"Return the component with my componentName create it if needed."	| bun |	componentName isNil ifTrue: [^nil].	bun := Registry bundleNamed: componentName.	bun notNil ifTrue: [^bun].	^BundleModel named: componentName</body></methods><methods><class-id>Store.BundleDescription</class-id> <category>private</category><body package="PackageCategories" selector="leafItems">leafItems	"Answer a list of packages contianed in my bundle 	and in bundles contained by my bundle."	| comp |	comp := self component.	^comp isNil		ifTrue: [#()]		ifFalse: [comp leafItems]</body></methods><methods><class-id>Store.DatabaseConnectionBundleInformation</class-id> <category>initialization</category><body package="PackageCategories" selector="initialize">initialize	self initializeContents</body><body package="PackageCategories" selector="initializeContents">initializeContents		contentDescriptions := List new.</body><body package="PackageCategories" selector="initializeContentsFrom:">initializeContentsFrom: aBundleConnectionInformation	"Set up the initial contents from  an existing dbconnection."		contentDescriptions := 		aBundleConnectionInformation contentDescriptions collect:			[ :desc | 			desc copy 				dbTrace: nil; 				dbIdentifier: dbIdentifier;				yourself 			].	fileDescriptions :=		aBundleConnectionInformation fileDescriptions collect:			[ :desc | 			desc copy 				dbTrace: nil; 				dbIdentifier: dbIdentifier;				yourself 			].</body></methods><methods><class-id>Store.DatabaseConnectionBundleInformation</class-id> <category>accessing</category><body package="PackageCategories" selector="contentDescriptions">contentDescriptions	"Answer a collection of pundle descriptions."	^contentDescriptions</body><body package="PackageCategories" selector="contentDescriptions:">contentDescriptions: aCollection	contentDescriptions := aCollection asList</body></methods><methods><class-id>Store.DatabaseConnectionBundleInformation</class-id> <category>actions</category><body package="PackageCategories" selector="addComponentDescription:">addComponentDescription: aComponentDescription	"Add aComponentDescription to the contents"	( contentDescriptions includes: aComponentDescription )		ifTrue: [ ^false ].		contentDescriptions add: aComponentDescription.	self shouldTrackChanges 		ifTrue: [ self addOtherChange: pundle structureMark ].	Registry changedBundleStructure: self pundle.	^true</body><body package="PackageCategories" selector="adjustComponents">adjustComponents	"Ensure all components are named."	contentDescriptions do:		[ :desc | desc setName ].</body><body package="PackageCategories" selector="component:beingRenamedTo:">component: aComponent beingRenamedTo: aString	"Called by bunlde from the registry which is about to rename a component contained in the receiver. 	Since it may be owned by other bundles as well, we are only updating internal information."	( contentDescriptions detect: 		[ :d | d name = aComponent name ] 	) componentName: aString.	self shouldTrackChanges 		ifTrue: [  self addOtherChange: pundle structureMark ].</body><body package="PackageCategories" selector="containedItems:">containedItems: aCollectionOfComponents	"Set my contents to be aCollectionOfComponents."	"Note: consolidated, so #addedComponent event registered only once. 	The component is ignored anyway and this it is also used for removals."		| saved mark |	saved := contentDescriptions.	mark := false.	self initializeContents.	aCollectionOfComponents do: 	[ :cmpt |   | desc |	desc := cmpt asDescription.	( contentDescriptions includes: desc )		ifFalse: 			[ contentDescriptions add: desc.			( saved includes: desc )				ifFalse: [ mark := true ].			]	].	saved do:		[ :desc | 		( aCollectionOfComponents contains: 			[ :cmpt | cmpt asDescription = desc ] 		) ifFalse: [  mark := true ]		].		( self shouldTrackChanges and:			 [ mark or: [ ( saved = contentDescriptions ) not ] ] )		ifTrue: [ self addOtherChange: pundle structureMark ].	Registry changedBundleStructure: self pundle.</body><body package="PackageCategories" selector="removeComponentDescription:">removeComponentDescription: aComponentDescription	"Remove aComponentDescription from the receiver's contents"	contentDescriptions remove: aComponentDescription ifAbsent: nil.	self shouldTrackChanges 		ifTrue: [ self addOtherChange: pundle structureMark ].	Registry changedBundleStructure: self pundle.</body><body package="PackageCategories" selector="removeNonexistentComponents">removeNonexistentComponents	contentDescriptions copy do:		[ :descr |		descr == nil			ifFalse: 				[ descr component == nil					ifTrue: [ self removeComponentDescription: descr ]				]		].</body><body package="PackageCategories" selector="removeNonexistentComponentsRecursive">removeNonexistentComponentsRecursive	contentDescriptions copy do:		[ :descr | | comp |		descr == nil			ifFalse: 				[ ( comp := descr component ) == nil					ifTrue: [ self removeComponentDescription: descr ]					ifFalse: 						[ comp isBundle 							ifTrue: [ comp removeNonexistentComponentsRecursive ]						]				]		].</body></methods><methods><class-id>Store.DatabaseConnectionBundleInformation class</class-id> <category>instance creation</category><body package="PackageCategories" selector="new">new	^super new		initialize</body></methods><methods><class-id>Store.BundleModel</class-id> <category>printing</category><body package="PackageCategories" selector="classDescription">classDescription	"Answer a string for describing the class."	^(#Bundle &lt;&lt; #packages &gt;&gt; 'Bundle') asString</body><body package="PackageCategories" selector="describeContents">describeContents	| strm |	strm := WriteStream on: String new.	self describeContentsOn: strm level: 0.	^strm contents</body><body package="PackageCategories" selector="describeContentsOn:level:">describeContentsOn: aStream level: aDepth 	self containedItems		do: 			[:pun | 			aDepth timesRepeat: [aStream tab].			aStream nextPutAll: (pun stringKey: #()).			pun hasBeenModified ifTrue: [aStream nextPut: $*].			aStream cr.			pun isBundle ifTrue: [pun describeContentsOn: aStream level: aDepth + 1]]</body><body package="PackageCategories" selector="displayString">displayString	"Answer the string to be displayed for a bundle in a Bundle list."	| stream |	stream := WriteStream on: ( String new: 32 ).	stream nextPutAll: self name.	self hasBeenModified ifTrue: [ stream nextPutAll: ' *' ].	self hasExtensions ifTrue: [ stream nextPutAll: ' +' ].	^stream contents</body><body package="PackageCategories" selector="printOn:">printOn: aStream 		aStream nextPut: ${;		nextPutAll: (name isNil ifTrue: [(#unnamed &lt;&lt; #packages &gt;&gt; '*unnamed*') asString] ifFalse: [name]);		nextPut: $}.</body><body package="PackageCategories" selector="storeOn:">storeOn: aStream 	name storeOn: aStream.	aStream tab.	aStream cr.	self contentDescriptions do: 		[ :pr |		aStream nextPut: $C; tab.		pr storeOn: aStream.		aStream cr		].	aStream nextPut: $E; cr.</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private-file out</category><body package="PackageCategories" selector="createOrFindExpression">createOrFindExpression	"Answer a string that when evaluated will instantiate the receiver - creating, if neccessary."	^'( Store.Registry bundleNamedOrCreate: ', self name printString, '  ) '.</body><body package="PackageCategories" selector="fileOutOn:">fileOutOn: aFileManager 	"File out the bundle on aFileManager."	aFileManager addComment: ((#Bundle1s &lt;&lt; #packages &gt;&gt; 'Bundle &lt;1s&gt;')			expandMacrosWith: self itemString).	( ( UISettings preferenceFor: #fileoutOption ) == #never )		ifFalse: [ self fileOutPropertiesOn: aFileManager ].	self containedItems do: [ :comp | comp fileOutOn: aFileManager ].	aFileManager bundleStructure: self.</body></methods><methods><class-id>Store.BundleModel</class-id> <category>unloading</category><body package="PackageCategories" selector="preUnloadChecksFromBundle:">preUnloadChecksFromBundle: aBundle 	| bundles bnames bundle components |	bundles := Registry enclosingComponentsFor: self.	aBundle notNil 		ifTrue: 			[ bundles remove: aBundle ifAbsent: nil.			components := aBundle allContainedItems				select: [ :c | c isBundle ].			bundles copy do: 				[ :b | ( components includes: b ) ifTrue: [ bundles remove: b ] ]			].	bnames := bundles collect: [ :b | b name ].	(self unloadProblemsQuery: bnames header: ((#UnloadingPackageWillModifySomeBundles &lt;&lt; #packages &gt;&gt; 'The package to be unloaded, "&lt;1s&gt;", is contained in the bundles&lt;2s&gt;listed below.  Proceeding will modify these bundles.')			expandMacrosWith: self name			with: (String with: Character cr)))		ifFalse: [^false].	bundle := aBundle == nil		ifTrue: [ self ]		ifFalse: [ aBundle ].	self contents reverseDo: 		[ :comp | 		comp notNil 			ifTrue: 				[ ( comp runPreUnloadFrom: bundle )					ifFalse: [ ^false ]				]		].	^true</body><body package="PackageCategories" selector="unloadFromImage">unloadFromImage	"I'm being ask to disappear from the image. 	Run rear guard code for all of my components and if all 	goes well obey the order. 	Answer true if I can fulfill the wish."	ObjectMemory globalGarbageCollect.	#{Store.DbRegistry} ifDefinedDo:		[ :reg |		( self runPreUnloadFrom: nil )			ifFalse: [ ^false ].		].	^self doUnloadFromImage</body><body package="PackageCategories" selector="unloadLogged:">unloadLogged: log	"TEMP- compatiblity"	self unloadFromImage		ifTrue:			[ ChangeSet unloadComponent: self.			SourceFileManager default unloadComponent: self.			].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private-change set access</category><body package="PackageCategories" selector="structureMark">structureMark	"Answer the symbol used to indicate that the bundle structure has been modified."	^self class structureMark</body></methods><methods><class-id>Store.BundleModel</class-id> <category>public-change set access</category><body package="PackageCategories" selector="inspectChangeSet">inspectChangeSet	"Attempt to describe the changes to the bundle at a	high level."	"Could do better."	| stream |	stream := WriteStream on: String new.	self hasBeenModified		ifFalse: [stream nextPutAll: (#BundleHasNotBeenChanged &lt;&lt; #packages &gt;&gt; 'There are no changes to this bundle or its components') asString]		ifTrue: 			[| modPuns |			modPuns := OrderedCollection new.			self contentDescriptions do: 				[ :descrip | descrip hasBeenModified 					ifTrue: [ modPuns add: descrip component ]				].			modPuns size &gt; 0				ifTrue: 					[stream nextPutAll: (#SomeBundleComponentsHaveChanged &lt;&lt; #packages &gt;&gt; 'The following bundle components have been&lt;n&gt;modified (see component for details):') expandMacros; cr.					modPuns do: [:item | stream tab; nextPutAll: item name; cr].					stream cr].			self isChangeSetEmpty ifFalse: [stream nextPutAll: self changeSet printString]].	Dialog warn: stream contents</body></methods><methods><class-id>Store.BundleModel</class-id> <category>accessing-browser</category><body package="PackageCategories" selector="allClasses">allClasses	"Answer a collection of class descriptors. The collection contains 	descriptors for classes that are defined in the package and extention 	descriptors for classes for which only data is defined"	| classes |	classes := Set new.	self leafItems do: [ :pkg | classes addAll: pkg allClasses ].	^classes</body><body package="PackageCategories" selector="allMetaclasses">allMetaclasses	"Answer a collection of class descriptors. The collection contains 	descriptors for classes that are defined in the package and extention 	descriptors for classes for which only data is defined"	| classes |	classes := Set new.	self leafItems do: [ :pkg | classes addAll: pkg allMetaclasses ].	^classes</body><body package="PackageCategories" selector="allNameSpaces">allNameSpaces	"Answer a collection of namespace descriptors. The collection contains 	descriptors for namespaces that are defined in the package and extention 	descriptors for namespaces for which only data is defined"	| namespaces |	namespaces := Set new.	self leafItems do: [ :pkg | namespaces addAll: pkg allNameSpaces ].	^namespaces.</body><body package="PackageCategories" selector="dataForNamed:">dataForNamed: aFullName 	"Answer a collection of datum descriptors."	| set |	set := Set new.	self leafItems do:		[ :pkg |  set addAll: 	( pkg dataForNamed: aFullName ) ].	^set asOrderedCollection</body><body package="PackageCategories" selector="dataForNamed:andProtocol:">dataForNamed: aFullName andProtocol: aSymbol	"Answer a collection of datum descriptors."	| set |	set := Set new.	self leafItems do:		[ :pkg |  set addAll: 	( pkg dataForNamed: aFullName andProtocol: aSymbol) ].	^set asOrderedCollection</body><body package="PackageCategories" selector="includesDataKey:ownerName:">includesDataKey: dataKey ownerName: aName	"Answer wheter the reciver contains aName.dataKey."	self leafItems 		detect: [ :pkg | pkg includesDataKey: dataKey ownerName: aName ] 		ifNone: [ ^false ].	^true</body><body package="PackageCategories" selector="includesDefinitionOf:">includesDefinitionOf: aName  	"Answer wheter the reciver contains something represented by aName."	self leafItems 		detect: [ :pkg | pkg includesDefinitionOf: aName ] ifNone: [ ^false ].	^true</body><body package="PackageCategories" selector="includesMethod:">includesMethod: aMethodDescriptor	^self 		includesSelector: aMethodDescriptor selector 		className: aMethodDescriptor className 		meta: aMethodDescriptor isMeta</body><body package="PackageCategories" selector="includesSelector:class:">includesSelector: selector class: aClass	^self 		includesSelector: selector 		className: aClass instanceBehavior absoluteName 		meta: aClass isMeta</body><body package="PackageCategories" selector="includesSelector:className:meta:">includesSelector: selector className: className meta: isMeta	"Answer wheter the reciver contains className&gt;&gt;aSelector."	self leafItems 		detect: [ :pkg | pkg includesSelector: selector className: className meta: isMeta ]		ifNone: [ ^false ].	^true</body><body package="PackageCategories" selector="methodsForClassNamed:andProtocol:meta:">methodsForClassNamed: cName andProtocol: protocolName meta: isMeta	"Answer a collection of method descriptors."	| set |	set := Set new.	self leafItems do:		[ :pkg |  set addAll: 			( pkg methodsForClassNamed: cName 					andProtocol: protocolName meta: isMeta ) 		].	^set asOrderedCollection</body><body package="PackageCategories" selector="methodsForClassNamed:meta:">methodsForClassNamed: aClassName meta: isMeta	"Answer a collection of methods."	| set |	set := Set new.	self leafItems do: [ :pkg | set addAll: ( pkg methodsForClassNamed: aClassName meta: isMeta ) ].	^set  asSortedCollection: [:x :y | x name &lt; y name]</body><body package="PackageCategories" selector="protocolsForClassNamed:meta:">protocolsForClassNamed: aClassName meta: isMeta	"Answer a collection of protocols."	| set |	set := Set new.	self leafItems do: 		[ :pkg | set addAll: ( pkg protocolsForClassNamed: aClassName meta: isMeta ) ].	^set</body><body package="PackageCategories" selector="protocolsForDataIn:">protocolsForDataIn: anObject	| set |	set := Set new.	self leafItems do:		[ :pkg |  set addAll: ( pkg protocolsForDataIn: anObject ) ].	^set asSortedCollection</body><body package="PackageCategories" selector="toolListIcon">toolListIcon	^self class bundleIcon</body></methods><methods><class-id>Store.BundleModel</class-id> <category>accessing</category><body package="PackageCategories" selector="addItem:">addItem: aPundle 	"Create a bundle or a package description and add it to 	the content of the bundle. Leave the id field not set."	self addComponent: aPundle asDescription</body><body package="PackageCategories" selector="allContainedItems">allContainedItems	"Answer a recursive collection of components."	| coll component |	coll := OrderedCollection new.	self contentDescriptions do:		[ :descr | 		( component := descr component ) notNil			ifTrue: 				[ coll add: component.				component isBundle					ifTrue: [ coll addAll: component allContainedItems ].				]		]. 	^coll</body><body package="PackageCategories" selector="allItems">allItems	"Answer a list of pundles contianed in this bundle and in bundles contained by 	this 	bundle. 	The list preserves the bundle order. Put this bundle as a last item on the list."	| items |	items := OrderedCollection new.	self containedItems do: 		[ :item | 		item isBundle			ifTrue: [ items addAll: item allItems ]			ifFalse: [ items add: item ]		].	items add: self. 	^items</body><body package="PackageCategories" selector="anyContainedItems">anyContainedItems	"Answer a recursive collection of components."	| coll component descs |	coll := OrderedCollection new.	( descs := self contentDescriptions ) isEmpty		ifTrue: [ descs := self anyContentDescriptions ].	descs do:		[ :descr | 		( component := descr component ) notNil			ifTrue: [ coll add: component]		]. 	^coll</body><body package="PackageCategories" selector="databaseInformationClass">databaseInformationClass	^DatabaseConnectionBundleInformation</body><body package="PackageCategories" selector="descriptionsAndLevels">descriptionsAndLevels	"Answer a list of pairs. The first element contains a descriptions the second the 	level on which the description was found."	| coll |	coll := OrderedCollection new.	self contentDescriptions 		do: [:descr | coll addAll: descr descriptionsAndLevels].	^coll</body><body package="PackageCategories" selector="itemCount">itemCount	"Answer a count of work to be done."	^self contents inject: 1 into:		[ :sz :pun | sz + pun itemCount ]</body><body package="PackageCategories" selector="leafDescriptions">leafDescriptions	"Answer the package descriptions at the leaves."	"Answer a list of PackageDescriptions."	^self uniqueDescriptionsAndLevels collect: [:a | a at: 1]</body><body package="PackageCategories" selector="leafItems">leafItems	"Answer a list of packages contianed in this bundle 	and in bundles contained by this bundle."	| items |	items := OrderedCollection new.	self contentDescriptions do: 		[ :descr | items addAll: descr leafItems].	^items</body><body package="PackageCategories" selector="pundleListIconKey">pundleListIconKey	^self		selectIconKeyDefault: #bundle 		modified: #modifiedBundle 		noDBdefault: #bundleNoDB 		modified: #modifiedBundleNoDB</body><body package="PackageCategories" selector="structure">structure	"Answer an array that reflects the receiver's contents in the form:		#( #( #package name ) #( #bundle name ) .... )"		| answer |	answer := OrderedCollection new: self contentDescriptions size.	self contentDescriptions do:		[ :cd | 		cd isPackage			ifTrue: [ answer add: ( Array with: #package with: cd name ) ]			ifFalse: [ answer add: ( Array with: #bundle with: cd name ) ].		].	^answer asArray</body><body package="PackageCategories" selector="structure:">structure: anArray	"Set the receivers contents based on an array in the form:		#( #( #package name ) #( #bundle name ) .... )"		| components |	anArray == nil		ifTrue: [ ^self containedItems: #() ].	components := OrderedCollection new: anArray size.	anArray do:		[ :array | | pundle |		pundle := ( array first == #package )					ifTrue: [ Registry packageNamed: array last ]					ifFalse: [ Registry bundleNamed: array last ].		pundle == nil			ifTrue: 				[ | error |				error := (#CannotAdd1sTo2s &lt;&lt; #packages &gt;&gt; 'Cannot add &lt;1s&gt; to &lt;2s&gt;&lt;ntt&gt;Continue?')					expandMacrosWith: array first with: name.				( Dialog confirm: error )					ifFalse: [ ^self ].				]			ifFalse: [ components add: pundle ].		].	self containedItems: components.</body><body package="PackageCategories" selector="traceBundle">traceBundle		^self parentRecord</body><body package="PackageCategories" selector="uniqueDescriptionsAndLevels">uniqueDescriptionsAndLevels	"Just like description and levels but remove 	components that are present more then one time."	| coll present |	present := IdentitySet new.	coll := self descriptionsAndLevels.	coll := coll select: 					[:pair | 					| descr comp |					descr := pair at: 1.					comp := descr component.					comp isNil 						ifTrue: [false]						ifFalse: 							[| res |							res := present includes: comp.							present add: comp.							res not]].	^coll</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private - db storage</category><body package="PackageCategories" selector="fileContent">fileContent	"Convert my file descriptions into a collection of database components."	^self fileDescriptions collect: 		[ :each | each asDBDescription ]</body><body package="PackageCategories" selector="updateFrom:">updateFrom: aCollectionOfDictionaries	"Replace existing component descriptions from just published pundles."	"For use by the MergeTool."	self contentDescriptions do:		[ :desc |  | pundleData |		pundleData := aCollectionOfDictionaries detect:			[ :dict | | component |			component := dict at: #pundle.			( component name = desc name and: [ component isPackage = desc isPackage ] )			].		desc id: ( pundleData at: #pundle ) dbTrace.		].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>table of contents</category><body package="PackageCategories" selector="tableOfBundleContentsOn:">tableOfBundleContentsOn: aStream 	self tableOfBundleContentsOn: aStream level: 0</body><body package="PackageCategories" selector="tableOfBundleContentsOn:level:">tableOfBundleContentsOn: aStream level: aLevel	aLevel timesRepeat: [aStream tab].	aStream nextPut: $@; nextPutAll: self name; nextPut: $"; cr.	self containedItems		do: 			[:pun | 			pun tableOfBundleContentsOn: aStream level: (aLevel + 1)].	(aLevel + 1) timesRepeat: [aStream tab].	aStream nextPut: $; ; cr</body><body package="PackageCategories" selector="tableOfBundleContentsOnFile:">tableOfBundleContentsOnFile: aString	| strm |	strm := aString asFilename writeStream.	self tableOfBundleContentsOn: strm.	strm close.</body><body package="PackageCategories" selector="tableOfContentsOn:">tableOfContentsOn: aStream 	self leafItems do: 		[ :pkg | pkg tableOfContentsOn: aStream ]</body><body package="PackageCategories" selector="tableOfContentsOnFile:">tableOfContentsOnFile: aString	| strm |	strm := aString asFilename writeStream.	self tableOfContentsOn: strm.	strm close.</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private-validation</category><body package="PackageCategories" selector="removeNonexistentComponents">removeNonexistentComponents	self databaseInformationsDo:		[ :info | info removeNonexistentComponents ].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private</category><body package="PackageCategories" selector="descriptionClass">descriptionClass	^BundleDescription</body><body package="PackageCategories" selector="dialogForException:">dialogForException: ex 	"Ask if a user wants to proceed with loading 	this bundle after an error occurred while loading one of the components."	^Dialog		choose: ((#ProblemOccurredWhatNowQ &lt;&lt; #packages &gt;&gt; 'The following problem occurred while loading &lt;1s&gt;  bundle:&lt;nn&gt;&lt;2s&gt;&lt;nn&gt;You can ignore the problem and continue loading the bundle&lt;n&gt;or you can abort the operation and unload already loaded &lt;n&gt;bundles and packages.&lt;n&gt;')			expandMacrosWith: self name			with: ex errorString)		labels: (Array with: (#Ignore &lt;&lt; #packages &gt;&gt; 'Ignore') with: (#Abort &lt;&lt; #packages &gt;&gt; 'Abort'))		values: #(#ignore #abort)		default: #abort</body><body package="PackageCategories" selector="doUnloadFromImage">doUnloadFromImage	"The difference between unloadFromImage and 	this method is that this method does not run 	the rearguard code and does not ask for rearguard 	of the components."	| components |	components := self contents.	components reverseDo: 		[ :comp | comp notNil ifTrue: [ comp unloadFromGroup: self ] ].	self runPostUnload.	Registry removeBundle: self.	self cleanseRelatedParcel.	^true</body><body package="PackageCategories" selector="manager">manager	^Registry</body><body package="PackageCategories" selector="pundlesNotIn:or:">pundlesNotIn: anImageBundle  or: parentBundle	"Answer a collection of pundles that I contain but that are not in anImageBundle. 	The comparison is done based on names of the items."	| notIn |	notIn := OrderedCollection new.	self contentDescriptions do: 		[ :descr | 		( ( anImageBundle containsDescription: descr ) or: 				[ parentBundle ~~ nil and: [ parentBundle containsDescription: descr ] ] 		) ifFalse: [ notIn add: descr component ] 		].	^notIn</body><body package="PackageCategories" selector="removeComponent:">removeComponent: aComponentDescription 	self databaseInformationsDo:		[ :info | info removeComponentDescription: aComponentDescription ].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>queries</category><body package="PackageCategories" selector="definedBindings">definedBindings	"Answer a dictionary of bindings (NameSpace/Class to datakey) contained in the receiver."	"Note- duplicates Parcel format."	| bindings |	bindings := IdentityDictionary new.	self leafItems do:		[ :pkg | 		pkg definedBindings keysAndValuesDo:			[ :owner :keys |			( bindings at: owner ifAbsentPut: [ Set new ] ) addAll: keys.			].		].	^bindings</body><body package="PackageCategories" selector="definedClasses">definedClasses	"Answer a collection of all Classes whose definition is contained in the receiver."	| list |	list := OrderedCollection new.	self leafItems do:		[ :pkg | list addAll: pkg  definedClasses ].	^list</body><body package="PackageCategories" selector="definedClassesExcludedSelectors">definedClassesExcludedSelectors	"Answer an IdentityDictionary of Class -&gt; &lt;Set of selectors&gt;"	"Parcel compatibility."	| coll |	coll := IdentityDictionary new.	self leafItems do:		[ :pkg | 		pkg definedClassesExcludedSelectors keysAndValuesDo:			[ :cls :selectors | | cname |			cname := cls instanceBehavior absoluteName.			selectors do:				[ :selector |					( self includesSelector: selector className: cname meta: cls isMeta )					ifFalse: [ ( coll at: cls ifAbsentPut: [ Set new ] ) add: selector ].				].			].		].	^coll</body><body package="PackageCategories" selector="definedNameSpaces">definedNameSpaces	"Answer a collection of all NameSpaces whose definition is contained in the receiver."	| list |	list := OrderedCollection new.	self leafItems do:		[ :pkg | list addAll: pkg  definedNameSpaces ].	^list</body><body package="PackageCategories" selector="definedObjects">definedObjects	"Parcel compatibility"	^self definedNameSpaces</body><body package="PackageCategories" selector="extensionMethods">extensionMethods 	"Answer an IdentitySet of CompiledMethods"	"Parcel compatibility."	| list classes |	list := OrderedCollection new.	self leafItems do:		[ :pkg | list addAll: pkg  extensionMethods ].	classes := self definedClasses.	^list reject: [ :cm | classes includes: cm mclass instanceBehavior ].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>parcel support</category><body package="PackageCategories" selector="copyContentsToParcel:">copyContentsToParcel: parcel	self leafItems do: [ :pkg  | pkg copyContentsToParcel: parcel ].</body><body package="PackageCategories" selector="dataNotInParcel:on:">dataNotInParcel: aParcel on: aStream	"Write owner.dataKey contained in the receiver but not in a Parcel."	self leafItems do: [ :pkg |	pkg dataNotInParcel: aParcel on: aStream ].</body><body package="PackageCategories" selector="definedClassesNotInParcel:">definedClassesNotInParcel: aParcel 	"Answer a string listing class names contained in the receiver but not in a Parcel."	| stream |	stream := ( String new: 100 ) writeStream.	self definedClassesNotInParcel: aParcel on: stream.	^stream contents.</body><body package="PackageCategories" selector="definedClassesNotInParcel:on:">definedClassesNotInParcel: aParcel on: aStream	"Write class names contained in the receiver but not in a Parcel."	self leafItems do: [ :pkg |	pkg definedClassesNotInParcel: aParcel on: aStream ].</body><body package="PackageCategories" selector="definedNameSpacesNotInParcel:">definedNameSpacesNotInParcel: aParcel 	"Answer a string listing class names contained in the receiver but not in a Parcel."	| stream |	stream := ( String new: 100 ) writeStream.	self definedNameSpacesNotInParcel: aParcel on: stream.	^stream contents.</body><body package="PackageCategories" selector="definedNameSpacesNotInParcel:on:">definedNameSpacesNotInParcel: aParcel on: aStream	"Write class names contained in the receiver but not in a Parcel."	self leafItems do: [ :pkg |	pkg definedNameSpacesNotInParcel: aParcel on: aStream ].</body><body package="PackageCategories" selector="methodsNotInParcel:on:">methodsNotInParcel: aParcel on: aStream	"Write method&gt;&gt;selectors contained in the receiver but not in a Parcel."	self leafItems do: [ :pkg |	pkg methodsNotInParcel: aParcel on: aStream ].</body><body package="PackageCategories" selector="namedObjects">namedObjects	^Dictionary new.</body><body package="PackageCategories" selector="saveAsParcel:saveStructure:saveLinks:">saveAsParcel: fullPathName saveStructure: saveStructure saveLinks: saveLinks	"Save the receiver as a parcel -without creating the parcel in the image.	fullPathName is a directory/parcelName with no extension.	If saveStructure is true, fill in the bundleStructure property with bundle/package contents.	If saveLinks is true, save the db links for every component."	| dir link pname |	link := saveLinks.	 ( saveLinks &amp; self hasBeenModified )		ifTrue: 			[ ( Dialog confirm: 				( (#UnpublishedModificationsMeanNoDBLinks &lt;&lt; #packages &gt;&gt; '&lt;t&gt;&lt;1s&gt; has unpublished modifications.&lt;n&gt;This means that database links will not be included.&lt;ntttt&gt;Continue?')						 expandMacrosWith: name ) )					ifFalse: [ ^self ].			link := false.			].	pname := fullPathName tail.	dir := fullPathName directory.	dir exists 		ifFalse:			[ ( Dialog confirm: ( (#CreateDirectory1s &lt;&lt; #packages &gt;&gt; 'Create directory &lt;1s&gt;?') expandMacrosWith: dir asString ) )				ifFalse: [ ^self ].			dir makeDirectory.			].	properties 		at: #bundleName put: self name;		at: #parcelName put: pname.	saveStructure		ifTrue: [ properties at: #bundleStructure put: ( PundleForParcel from: self saveLinks: link ) ].	[ self		parcelOutTo: ( dir construct: ( pname, '.pcl' ) ) asString		sourceFileName: ( dir construct: ( pname, '.pst' ) ) asString.	] ensure:		[ properties			removeKey: #bundleStructure ifAbsent: [ ];			removeKey: #bundleName ifAbsent: [ ].		].</body><body package="PackageCategories" selector="saveAsParcel:saveStructure:saveLinks:parcelOptions:">saveAsParcel: fullPathName saveStructure: saveStructure saveLinks: saveLinks parcelOptions: aDictionary	"Save the receiver as a parcel -without creating the parcel in the image.	fullPathName is a directory/parcelName with no extension.	If saveStructure is true, fill in the bundleStructure property with bundle/package contents.	If saveLinks is true, save the db links for every component."	| dir link pname |	link := saveLinks.	 ( saveLinks &amp; self hasBeenModified )		ifTrue: 			[ ( Dialog confirm: 				( (#UnpublishedModificationsMeanNoDBLinks &lt;&lt; #packages &gt;&gt; '&lt;t&gt;&lt;1s&gt; has unpublished modifications.&lt;n&gt;This means that database links will not be included.&lt;ntttt&gt;Continue?')						 expandMacrosWith: name ) )					ifFalse: [ ^self ].			link := false.			].	pname := fullPathName tail.	dir := fullPathName directory.	dir exists 		ifFalse:			[ ( Dialog confirm: ( (#CreateDirectory1s &lt;&lt; #packages &gt;&gt; 'Create directory &lt;1s&gt;?') expandMacrosWith: dir asString ) )				ifFalse: [ ^self ].			dir makeDirectory.			].	properties 		at: #bundleName put: self name;		at: #parcelName put: pname.	saveStructure		ifTrue: [ properties at: #bundleStructure put: ( PundleForParcel from: self saveLinks: link ) ].	[ self		parcelOutTo: ( dir construct: ( pname, '.pcl' ) ) asString		sourceFileName: ( dir construct: ( pname, '.pst' ) ) asString		parcelOptions: aDictionary.	] ensure:		[ properties			removeKey: #bundleStructure ifAbsent: [ ];			removeKey: #bundleName ifAbsent: [ ].		].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>db utilities</category><body package="PackageCategories" selector="cleanUpOverrides">cleanUpOverrides	self allContainedItems do: 		[ :each | each cleanUpOverrides ]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>content management</category><body package="PackageCategories" selector="addComponent:">addComponent: aComponentDescription 	"Add a component to the receiver."	| changed |	changed := false.	self databaseInfomationOrCreate. 		"force there to be at least one"	self databaseInformationsDo:		[ : info |		changed := ( info addComponentDescription: aComponentDescription ) | changed.		].	changed &amp; self shouldTrackChanges		ifTrue: 			[ self addOtherChange: self structureMark.			Registry changedBundleStructure:  self.			].</body><body package="PackageCategories" selector="allContentCollectionsDo:">allContentCollectionsDo: aBlock	"Evaluate aBlock for all of the receiver's contents 	(ie. for all database connections)."	dbInfo values do: 		[ :info | aBlock value: info contentDescriptions ].</body><body package="PackageCategories" selector="anyContentDescriptions">anyContentDescriptions	"Answer a collection of pundle descriptors for any database connection"	dbInfo isEmpty		ifTrue: [ ^#( ) ].	dbInfo size &gt; 1 		ifTrue: [ 	dbInfo removeKey: self noDbSymbol ifAbsent: nil ].	^dbInfo values first contentDescriptions collect:		[ :desc |		desc copy			id: nil; 			dbIdentifier: nil;			yourself		].</body><body package="PackageCategories" selector="component:beingRenamedTo:">component: aComponent beingRenamedTo: aString	"Called by the registry which is about to rename a component contained in the receiver. 	Since it may be owned by other bundles as well, we are only updating internal information."	self databaseInformationsDo:		[ :info | info component: aComponent beingRenamedTo: aString ].</body><body package="PackageCategories" selector="containedItems">containedItems	"Answer a collection of components."	^self contents asList 		reject: [ :c | c == nil ]</body><body package="PackageCategories" selector="containedItems:">containedItems: aCollectionOfComponents	"Set my contents to be aCollectionOfComponents."	dbInfo isEmpty		ifTrue: [ self databaseInfomationForOrCreate: self noDbSymbol ].	self databaseInformationsDo:		[ :info | info containedItems: aCollectionOfComponents ].</body><body package="PackageCategories" selector="contentDescriptions">contentDescriptions	"Answer a collection of pundle descriptors for the current/last database connection"	| dbinfo |	^( dbinfo := self databaseInfomation ) == nil		ifTrue: [ self anyContentDescriptions ]		ifFalse: [ dbinfo contentDescriptions ].</body><body package="PackageCategories" selector="contentDescriptionsFor:">contentDescriptionsFor: aDatabaseId	"Answer a collection of pundle descriptors for the specified database connection"	| dbinfo |	^( dbinfo := self databaseInformationFor: aDatabaseId ) == nil		ifTrue: [ #( ) ]		ifFalse: [ dbinfo contentDescriptions ].</body><body package="PackageCategories" selector="contents">contents	"Answer a collection of sub-components contained in the bundle"	^self contentDescriptions collect: 		[ :desc | desc component ]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>testing</category><body package="PackageCategories" selector="containsDescription:">containsDescription: aDescr 	"Answer true if I or my sub-components contain aDescr ."	self contentDescriptions do: 		[ :descr | 		( ( descr describesSameAs: aDescr )			or: [ descr isBundle and: [ descr component containsDescription: aDescr ] ]		) 			ifTrue: [ ^true ]		].	^false</body><body package="PackageCategories" selector="containsItem:">containsItem: aPundle 	"Answer true if I contain aPundle."	^self contentDescriptions contains: 		[:aDescr | aPundle sameAsDescribedBy: aDescr ].</body><body package="PackageCategories" selector="hasBeenModified">hasBeenModified	"Answer true if the receiver or a subcomponent has been modified."		^self shouldTrackChanges and:		[ self hasItselfBeenModified or:			[ ( self contentDescriptions detect: 				[ :c | c hasBeenModified ] ifNone: [ nil ] ) ~~ nil 			]		].</body><body package="PackageCategories" selector="hasBeenModifiedIn:">hasBeenModifiedIn: aDatabaseId	"Answer true if the receiver or a subcomponent has been modified within a database."			^( super hasBeenModifiedIn: aDatabaseId ) or:		[ ( self containedItems detect: 			[ :c | c hasBeenModifiedIn: aDatabaseId ] ifNone: [ nil ] ) ~~ nil ]</body><body package="PackageCategories" selector="hasCodeOverridden">hasCodeOverridden	"Answer true if the receiver has definitions overriden by other components."	^self leafItems contains: 		[ :pkg | pkg hasCodeOverridden ]</body><body package="PackageCategories" selector="hasExtensions">hasExtensions	"Check if any of my components have been modifed."	^self leafItems contains: [:descr | descr hasExtensions]</body><body package="PackageCategories" selector="isBundle">isBundle	^true</body><body package="PackageCategories" selector="isEmpty">isEmpty	"Answer true if I do not contain any definitions. This method is used	to distinguish newly created bundles from the existing ones."	^dbInfo isEmpty		or: [ dbInfo values first contentDescriptions isEmpty ].</body><body package="PackageCategories" selector="isLeaf">isLeaf	^self isEmpty</body><body package="PackageCategories" selector="overridesSelf">overridesSelf	"Answer true if any of the receiver's contents override another."	| subs |	self hasCodeOverridden		ifFalse: [ ^false ].	( subs := self leafItems ) do:		[ :pundle |		pundle overrides do:			[ :over | 			( ( over getSources: over object )				contains: [ :current | subs includes: current ] )					ifTrue: [ ^true ]			]		].	^false</body></methods><methods><class-id>Store.BundleModel</class-id> <category>initialize-release</category><body package="PackageCategories" selector="initializeForReconcileWith:">initializeForReconcileWith: aDbBundle	"Ensure that the reciever is set up for the current database."		| descs fdescs |	self databaseInfomation == nil		ifFalse: [ ^self ].	descs := self anyContentDescriptions.		"before we create a the  new empty one"	fdescs := self anyFileDescriptions.	self databaseInfomationOrCreate 		contentDescriptions: descs;		fileDescriptions: fdescs;		dbTrace: ( ( aDbBundle == nil ) ifFalse: [ aDbBundle primaryKey ] ).</body><body package="PackageCategories" selector="setContentsFromDB:">setContentsFromDB: aDBBundle		self databaseInfomationOrCreate contentDescriptions: 		( aDBBundle containedItems collect: [ :each | each asComponentDescription ] ).	self databaseInfomation fileDescriptions: 		( aDBBundle files collect: [ :each | each asComponentDescription ] ).		dbInfo removeKey: self noDbSymbol ifAbsent: nil. "now we be connected"</body></methods><methods><class-id>Store.BundleModel class</class-id> <category>constants</category><body package="PackageCategories" selector="bundleIcon">bundleIcon	^BundleIcon ifNil: [BundleIcon := ListIconLibrary visualFor: #bundle]</body><body package="PackageCategories" selector="componentType">componentType	"Answer a symbol representing the class of the receiver."	^#bundle</body><body package="PackageCategories" selector="descriptionString">descriptionString	"Answer a string for error messages."	^(#bundle &lt;&lt; #packages &gt;&gt; 'bundle') asString</body><body package="PackageCategories" selector="fileMark">fileMark	"Answer the symbol used to indicate that an external file has been added/removed/modified."	"Should really be a real Change"	^#externalFile</body><body package="PackageCategories" selector="structureMark">structureMark	"Answer the symbol used to indicate that the bundle structure has been modified."	^#bundleStructure</body></methods><methods><class-id>Store.BundleModel class</class-id> <category>validation</category><body package="PackageCategories" selector="validateLoadOrder:">validateLoadOrder: packages	"Examines NameSpace/Class prereqs to ensure that content list is in a valid order.	Answer a string with errors, an empty string if none."	| errorStream list count |	list := OrderedCollection new: packages size.	packages do: 		[ :pkg | pkg isPackage 			ifTrue: [ list add: pkg ] ifFalse: [ list addAll: pkg leafItems ] 		].	errorStream := ( String new: 200 ) writeStream.	count := 0.	Cursor wait showWhile:		[ 1 to: list size do:			[ :index |  | pkg prereqs |			count &gt;= 25 ifTrue: [ ^errorStream contents, '....more....' ].  "enough is enough"			pkg := list at: index.			prereqs := OrderedCollection new: 100.			pkg definedClasses do: [ :cls | prereqs addAll: cls prerequisitesForLoading ].			pkg definedNameSpaces do: [ :ns | prereqs addAll: ns prerequisitesForLoading ].			prereqs addAll: ( pkg classesExtendedInPackage collect: [ :cm | cm actual ] ).			prereqs addAll: ( pkg nameSpacesExtendedInPackage collect: [ :cm | cm actual ] ).			prereqs := prereqs reject: [ :obj | obj class == ExternalDictionary ].  "can't check for it ...."			1 to: index do: 				[ :j | prereqs := prereqs reject: [ :obj | ( list at: j ) includesDefinitionOf: obj absoluteName ] ].			( index + 1 ) to: list size do:				[ :j | | bpkg |				prereqs detect:  					[ :obj | 					( ( bpkg := list at: j ) includesDefinitionOf: obj absoluteName ) 						ifFalse: [ false ]						ifTrue: 							[ errorStream nextPutAll: pkg  name, ' depends on ',							obj name, ' in ', bpkg name; cr.							count := count + 1.							true							].					] ifNone: [ ].				]			]		].	^errorStream contents.</body></methods><methods><class-id>Store.Change</class-id> <category>change types</category><body package="PackageCategories" selector="add">add	type := #add</body><body package="PackageCategories" selector="change">change	type := #change</body><body package="PackageCategories" selector="comment">comment	type := #comment</body><body package="PackageCategories" selector="override">override	type := #override.</body><body package="PackageCategories" selector="remove">remove	type := #remove</body><body package="PackageCategories" selector="removeChanges">removeChanges	type := #removeChanges</body><body package="PackageCategories" selector="removeDefinition">removeDefinition	type := #removeDefinition.	meta := false.</body><body package="PackageCategories" selector="reorganize">reorganize	type := #reorganize</body></methods><methods><class-id>Store.Change</class-id> <category>testing</category><body package="PackageCategories" selector="isAdd">isAdd	^type == #add</body><body package="PackageCategories" selector="isChange">isChange	^type == #change</body><body package="PackageCategories" selector="isClassChange">isClassChange	^classSymbol notNil  &amp;  subdef isNil</body><body package="PackageCategories" selector="isComment">isComment	^type == #comment</body><body package="PackageCategories" selector="isComponentChange">isComponentChange	^false</body><body package="PackageCategories" selector="isDataChange">isDataChange	^subdef = #dataKey</body><body package="PackageCategories" selector="isForClass">isForClass	^classSymbol notNil</body><body package="PackageCategories" selector="isForNameSpace">isForNameSpace	^nameSpaceSymbol notNil</body><body package="PackageCategories" selector="isMethodChange">isMethodChange	^subdef = #selector</body><body package="PackageCategories" selector="isNameSpaceChange">isNameSpaceChange	^nameSpaceSymbol notNil  &amp;  subdef isNil</body><body package="PackageCategories" selector="isRemove">isRemove	^type == #remove</body><body package="PackageCategories" selector="isRemoveChanges">isRemoveChanges	^type == #removeChanges</body><body package="PackageCategories" selector="isRemoveDefinition">isRemoveDefinition	^type == #removeDefinition</body><body package="PackageCategories" selector="isReorganize">isReorganize	^type == #reorganize</body></methods><methods><class-id>Store.Change</class-id> <category>accessing</category><body package="PackageCategories" selector="actual:">actual: aClassOrNameSpace	"Set the actual object - a class or namespace."	aClassOrNameSpace isBehavior		ifTrue: [ self class: aClassOrNameSpace ]		ifFalse: [ self nameSpace: aClassOrNameSpace ].</body><body package="PackageCategories" selector="class:">class: class	classSymbol := class absoluteName asClassNameOnly asSymbol.	meta := class isMeta</body><body package="PackageCategories" selector="className:meta:">className: aClassName meta: isMeta	classSymbol := aClassName asSymbol.	self meta: isMeta.</body><body package="PackageCategories" selector="classSymbol">classSymbol	^classSymbol</body><body package="PackageCategories" selector="classSymbol:">classSymbol: aClassSymbol	aClassSymbol namesMetaClass		ifTrue: 			[ classSymbol := aClassSymbol classNameOnly asSymbol.			self meta: true 			]		ifFalse: 			[ classSymbol := aClassSymbol asSymbol.			self meta: false. 			]</body><body package="PackageCategories" selector="dataKey">dataKey	subdef == #dataKey ifFalse: [self error: (#wrongRetrivalType &lt;&lt; #packages &gt;&gt; 'wrong retrival type')].	^key asSymbol</body><body package="PackageCategories" selector="dataKey:">dataKey: dataKey	key := dataKey asSymbol.	subdef := #dataKey.	meta := false.</body><body package="PackageCategories" selector="fullClassSymbol">fullClassSymbol	^classSymbol</body><body package="PackageCategories" selector="index">index	^subdef == #selector		ifTrue: [self meta				ifTrue: [2]				ifFalse: [1]]		ifFalse: [subdef == #dataKey				ifTrue: [3]				ifFalse: [0]]</body><body package="PackageCategories" selector="key">key	^key</body><body package="PackageCategories" selector="meta">meta	meta isNil ifTrue: [^false].	^meta</body><body package="PackageCategories" selector="meta:">meta: isMeta	meta := isMeta</body><body package="PackageCategories" selector="nameSpace:">nameSpace: namespace	nameSpaceSymbol := namespace absoluteSymbol.</body><body package="PackageCategories" selector="nameSpaceSymbol">nameSpaceSymbol	^nameSpaceSymbol</body><body package="PackageCategories" selector="nameSpaceSymbol:">nameSpaceSymbol: aNameSpaceSymbol	nameSpaceSymbol := aNameSpaceSymbol asSymbol.</body><body package="PackageCategories" selector="selector">selector	subdef == #selector ifFalse: [self error: (#wrongRetrivalType &lt;&lt; #packages &gt;&gt; 'wrong retrival type')].	^key</body><body package="PackageCategories" selector="selector:">selector: selector	key := selector.	subdef := #selector</body><body package="PackageCategories" selector="symbol">symbol	^classSymbol == nil		ifFalse: [ classSymbol ]		ifTrue: [ nameSpaceSymbol ]</body><body package="PackageCategories" selector="type">type	^type</body><body package="PackageCategories" selector="type:">type: aSymbol	type := aSymbol</body><body package="PackageCategories" selector="typeWithMeta">typeWithMeta	self meta ifFalse: [^type].	type == #comment ifTrue: [^#commentMeta].	type == #reorganize ifTrue: [^#reorganizeMeta].	type == #change ifTrue: [^#changeMeta].	^type</body></methods><methods><class-id>Store.Change</class-id> <category>printing</category><body package="PackageCategories" selector="printOn:">printOn: aStream	aStream nextPutAll: type.	aStream nextPutAll: ' '.	self classSymbol == nil		ifFalse: [ aStream nextPutAll: self classSymbol ].	self nameSpaceSymbol == nil		ifFalse: [ aStream nextPutAll: self nameSpaceSymbol ]. 	self meta ifTrue: [aStream nextPutAll: ' class'].	self isMethodChange ifTrue: [aStream nextPutAll: ' &gt;&gt; ', key].	self isDataChange ifTrue: [aStream nextPutAll: ' : ', key].</body></methods><methods><class-id>Store.ComponentRelatedChange</class-id> <category>accessing</category><body package="PackageCategories" selector="tag:">tag: aTag	tag := aTag</body></methods><methods><class-id>Store.ComponentRelatedChange</class-id> <category>testing</category><body package="PackageCategories" selector="isClassChange">isClassChange	^false</body><body package="PackageCategories" selector="isComponentChange">isComponentChange	^true</body></methods><methods><class-id>Kernel.ChunkSourceFileFormat</class-id> <category>code component support</category><body package="PackageCategories" selector="bundleNamed:structure:on:">bundleNamed: name structure: structure on: aStream	"Add the changing of a bundle structure event on a stream. "	aStream nextChunkPut: 		( '#{Store.Registry} ifDefinedDo:&lt;nt&gt;[ :reg |&lt;n&gt;( reg bundleNamedOrCreate: &lt;1s&gt; ) structure: &lt;2s&gt;]'				expandMacrosWith: name				with: structure storeString printString		); cr.</body></methods><methods><class-id>Core.String</class-id> <category>private-store</category><body package="PackageCategories" selector="classNameOnly">classNameOnly	"Answer a part of receiver that contains the	class name.	Note that this methos assumes that the reciver	holds the metaclass name"	^self copyFrom: 1 to: self  size - 6</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>store data</category><body package="PackageCategories" selector="dataAt:put:">dataAt: aDataKey put: data		"Install a data value. Answer true if ok"	self at: aDataKey put: data.	^true</body></methods><methods><class-id>Kernel.ChangeSet</class-id> <category>component change management</category><body package="PackageCategories" selector="bundleStructure:">bundleStructure: aBundle	"Include indication or the changing of a bundle structure event. "	self addComponentChange:		( Store.BundleStructureChange new			component: aBundle;			yourself		)</body></methods><methods><class-id>Kernel.SourceFileManager</class-id> <category>file out code components support</category><body package="PackageCategories" selector="bundleNamed:structure:">bundleNamed: name structure: structure	"Add the changing of a bundle structure event on a stream. "	self targetFile == nil		ifFalse:			[ self targetFormatter				bundleNamed: name				structure: structure				on: self targetFile.			].</body></methods><methods><class-id>Kernel.OverridenNameSpace</class-id> <category>store</category><body package="PackageCategories" selector="asPsuedoRecord">asPsuedoRecord	"Answer a store psuedo record representing the image version of the 	class/namespace part of the receiver."	 ^Store.PseudoRecord fromModel: self</body></methods><methods><class-id>Kernel.Override</class-id> <category>store</category><body package="PackageCategories" selector="packageName">packageName	^( self sources detect: [ :s | s isPackage ] ifNone: [ ^nil ] ) name</body></methods><methods><class-id>Core.Class</class-id> <category>store data</category><body package="PackageCategories" selector="dataAt:ifAbsent:">dataAt: aDataKey ifAbsent: aBlock	"Look up data value "	^self asNameSpace dataAt: aDataKey ifAbsent: aBlock</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>store utils</category><body package="PackageCategories" selector="absoluteSymbol">absoluteSymbol	"Answer an environment independant 	(and therefore truely unique) symbol"	^self absoluteReference asSymbol</body></methods><methods><class-id>Tools.CategorizedSelectionModule class</class-id> <category>private</category><body package="PackageCategories" selector="classesInPundle:">classesInPundle: aPundleOrNil	^aPundleOrNil isNil		ifTrue: [Array new]		ifFalse: [aPundleOrNil definedClasses asSortedCollection: [:a :b | a name &lt; b name]]</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>store</category><body package="PackageCategories" selector="absoluteName">absoluteName	^self owner absoluteName, '.', self key</body></methods><methods><class-id>Kernel.OverridenMethod</class-id> <category>store</category><body package="PackageCategories" selector="absoluteClassName">absoluteClassName	^self implementingClass absoluteName</body></methods><methods><class-id>Tools.TreeItemHolder class</class-id> <category>instance creation-store</category><body package="PackageCategories" selector="withStorePundleTree">withStorePundleTree	^(self on: Store.Registry)		childrenBlock: [:object | object containedItems];		yourself</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>store</category><body package="PackageCategories" selector="asPsuedoRecord">asPsuedoRecord	"Answer a store psuedo record representing the image version of the 	class/namespace part of the receiver."	| object |	object := self owner.	^object isBehavior		ifTrue: [ Store.ClassExtensionDescriptor fullName: object absoluteName meta: false ]		ifFalse: [  Store.NameSpaceExtensionDescriptor fullName: object absoluteName ]</body></methods><methods><class-id>Core.Class</class-id> <category>store data</category><body package="PackageCategories" selector="dataKeys">dataKeys	"Answer the receiver's data."	^( self classPool isEmpty )		ifTrue: [ #() ]		ifFalse: 	[ self classPool keys ].</body><body package="PackageCategories" selector="unloadDataKey:">unloadDataKey: dataKey 	"unload a data value. Answer nil if unable."	^self asNameSpace unloadDataKey: dataKey</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>store data</category><body package="PackageCategories" selector="dataAt:ifAbsent:">dataAt: aDataKey ifAbsent: aBlock		"look up a data value- "	^self at: aDataKey ifAbsent: aBlock</body></methods><methods><class-id>Kernel.OverridenClass</class-id> <category>accessing</category><body package="PackageCategories" selector="absoluteName">absoluteName	"Answers the overriden object's absouteName."	^self environment absoluteName, '.', self name.</body></methods><methods><class-id>Kernel.SourceFileManager</class-id> <category>file out code components support</category><body package="PackageCategories" selector="bundleStructure:">bundleStructure: aBundle	"Add the changing of a bundle structure event on a stream. "	self targetFile == nil		ifFalse:			[ self targetFormatter				bundleStructure: aBundle				on: self targetFile.			].</body></methods><methods><class-id>Kernel.OverridenNameSpace</class-id> <category>store</category><body package="PackageCategories" selector="absoluteName">absoluteName	"Answers the overriden object's absouteName."	^self environment absoluteName, '.', self name.</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>store data</category><body package="PackageCategories" selector="dataAt:">dataAt: aDataKey		"Answer text for aDataKey"	^self dataAt: aDataKey ifAbsent: [ nil ]</body></methods><methods><class-id>Kernel.AbsentClassImport</class-id> <category>accessing</category><body package="PackageCategories" selector="classNameWithMeta">classNameWithMeta	^self isMeta		ifTrue: [ 	self absoluteName, ' class' ]		ifFalse: [ self absoluteName ].</body></methods><methods><class-id>Tools.EntryWithPasteButtonModule class</class-id> <category>private</category><body package="PackageCategories" selector="selectPackage">selectPackage	^(IncrementalSearchDialog selectPackage: #PackageC &lt;&lt; #labels &gt;&gt; 'Package:')		ifNotNil: [:package | package name]</body></methods><methods><class-id>Kernel.OverridenClass</class-id> <category>testing</category><body package="PackageCategories" selector="isMeta">isMeta	^self name namesMetaClass</body></methods><methods><class-id>Kernel.Override</class-id> <category>store</category><body package="PackageCategories" selector="asPsuedoRecord">asPsuedoRecord	"Answer a store psuedo record representing the image version of the 	class/namespace part of the receiver."	self subclassResponsibility</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>store</category><body package="PackageCategories" selector="isInClass">isInClass	^self owner isBehavior</body></methods><methods><class-id>Tools.IncrementalSearchModule class</class-id> <category>instance creation-predefined</category><body package="PackageCategories" selector="forPackageSelection">forPackageSelection	"Answer a module that allows to select a package with search by a partial name."	"self forPackageSelection open"	^self forPackageSelection: #FindC &lt;&lt; #labels &gt;&gt; 'Find:'</body></methods><methods><class-id>XML.SourceScannerNodeBuilder</class-id> <category>scanning-code components</category><body package="PackageCategories" selector="scan_bundle_structure:">scan_bundle_structure: anElement 	self doChange: 		( Store.BundleStructureChange new			componentName: ( self getString: 'name' from: anElement default: '' );			structureString: ( self getString: 'structure' from: anElement default: '' );			yourself		).</body></methods><methods><class-id>Kernel.ChangeSet class</class-id> <category>component change management</category><body package="PackageCategories" selector="bundleStructure:">bundleStructure: aBundle	"Include indication that aBundle's structure has changed."	self changed: #bundleStructure: with: ( Array with: aBundle )</body></methods><methods><class-id>Kernel.XMLSourceFileFormat</class-id> <category>code component support</category><body package="PackageCategories" selector="bundleNamed:structure:on:">bundleNamed: name structure: structure on: aStream	"Save the bundle structure on a Stream."	self checkForWrite: aStream.	aStream cr; cr.	self on: aStream tag: 'bundle-structure' do:		[:xml :str |		str cr.		xml on: str tag: 'name' value: name.		str space.		xml on: str tag: 'structure' value: structure storeString.		str cr]</body></methods><methods><class-id>Kernel.OverridenMethod</class-id> <category>store</category><body package="PackageCategories" selector="classNameWithMeta">classNameWithMeta	^self absoluteClassName</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>store</category><body package="PackageCategories" selector="absoluteOwnerName">absoluteOwnerName	^self owner absoluteName</body></methods><methods><class-id>Tools.TreeSelectionModule class</class-id> <category>instance creation-predefined</category><body package="PackageCategories" selector="forStoreBundlesAndPackages">forStoreBundlesAndPackages	^TreeSelectionModule new		rootHolder: TreeItemHolder withStorePundleTree;		iconSelector: #toolListIcon;		showRoot: false;		expandableRoots: true;		preExpandTo: 0</body></methods><methods><class-id>Kernel.ChunkSourceFileFormat</class-id> <category>code component support</category><body package="PackageCategories" selector="bundleStructure:on:">bundleStructure:  aBundle on: aStream	"Add the loading of a package/bundle event on a stream. "	self bundleNamed: aBundle name structure: aBundle structure on: aStream</body></methods><methods><class-id>Tools.DefinitionCreationDialog</class-id> <category>validation</category><body package="PackageCategories" selector="validatePackageIfFails:">validatePackageIfFails: aBlock	self isPackageProvided ifFalse:		[aBlock value: #PackageNameIsRequired &lt;&lt; #dialogs &gt;&gt; 'The package name is required'].	(Store.Registry packageNamed: self packageModule value trimBlanks) isNil		ifTrue: [aBlock value: #NoSuchPackage &lt;&lt; #dialogs &gt;&gt; 'There is no such package']</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>store data</category><body package="PackageCategories" selector="unloadDataKey:">unloadDataKey: dataKey		"unload a data value. Answer nil  if unable."	self dataAt: dataKey ifAbsent: [ ^nil ].	self removeKey: dataKey.</body></methods><methods><class-id>Kernel.GeneralBindingReference</class-id> <category>store</category><body package="PackageCategories" selector="finalNameSpaceName">finalNameSpaceName		| list |	( list := self path asOrderedCollection ) removeLast.	^( self class path: list ) asString.</body></methods><methods><class-id>Kernel.OverridenClass</class-id> <category>accessing</category><body package="PackageCategories" selector="superclass">superclass	^( self argumentForKeyWord: 'superclass' ) value</body></methods><methods><class-id>Kernel.Override</class-id> <category>store</category><body package="PackageCategories" selector="package">package	"Answer the overriden package, nil if none."	| name |	^( name := self packageName ) == nil		ifFalse: [ #{Store.Registry} ifDefinedDo: [ :reg | reg packageNamed: name ] ]</body></methods><methods><class-id>Core.Class</class-id> <category>store data</category><body package="PackageCategories" selector="datumDescriptors">datumDescriptors	"Answer a collection of DatumDescriptors for the recievers dataKeys."	^self dataKeys asSortedCollection asOrderedCollection collect: 		[ :dataKey | 		Store.DatumDescriptor fromDataKey: dataKey className: self absoluteName 		]</body></methods><methods><class-id>Kernel.Override</class-id> <category>store</category><body package="PackageCategories" selector="definition">definition	^self text</body></methods><methods><class-id>Kernel.OverridenMethod</class-id> <category>store</category><body package="PackageCategories" selector="sourceCode">sourceCode	^self text</body></methods><methods><class-id>Tools.IncrementalSearchDialog class</class-id> <category>dialog opening-predefined</category><body package="PackageCategories" selector="selectPackage:">selectPackage: aUserMessageOrString	"self selectPackage: 'Find package:' "	| dialog |	dialog := self new module: 		(IncrementalSearchModule forPackageSelection: aUserMessageOrString).	^dialog select</body></methods><methods><class-id>Kernel.NameSpaceOfClass</class-id> <category>store utils</category><body package="PackageCategories" selector="dataBindings">dataBindings	"All class bindings are for data - right?"	^bindings asList</body></methods><methods><class-id>Core.Class</class-id> <category>store data</category><body package="PackageCategories" selector="dataAt:">dataAt: aDataKey	"Answer text for aDataKey"	^self asNameSpace dataAt: aDataKey ifAbsent: [ nil ]</body></methods><methods><class-id>Kernel.Parcel</class-id> <category>store</category><body package="PackageCategories" selector="asPackageNamed:">asPackageNamed: packageNameString	"Answer a package that duplicates the receiver."	"Currently, does not remove from an existing package."	| pkg |	packageNameString isEmpty ifTrue: [ ^nil ].	( ( Store.Registry packageNamed: packageNameString ) == nil ) 		ifFalse:			[ ^self asPackageNamed:				( Dialog request: 					((#PackageAlreadyExists &lt;&lt; #packages &gt;&gt; 'Package &lt;1s&gt; already exists.&lt;n&gt;Confirm. ') expandMacrosWith: packageNameString)					initialAnswer: packageNameString					onCancel: [ ^nil ] )			].	pkg := Store.Registry packageNamedOrCreate: packageNameString.	[ pkg startLoad.	self moveContentsTo: pkg.	pkg copyPropertiesFrom: self properties.	pkg comment: (self commentOrNil == nil 						ifTrue: [((#PackageConvertedFromParcel &lt;&lt; #packages &gt;&gt; 'Converted from parcel: &lt;1s&gt;  &lt;2s&gt;')								expandMacrosWith: self name								with: self versionString)]						ifFalse: [self comment]).	pkg resetUninstalledStateFrom: self.	pkg markNotModified.	( properties includesKey: #dbTrace )			ifFalse: [ pkg addOtherChange: #convertedParcel ].	"not if linked to db"	Override equateComponent: pkg with: self.	] ensure: [ pkg endLoad ].	 ^pkg</body></methods><methods><class-id>Core.String</class-id> <category>private-store</category><body package="PackageCategories" selector="fullMetaName">fullMetaName	"Add ' class' to the receiver"	^self, ' class'</body></methods><methods><class-id>Kernel.Parcel</class-id> <category>store</category><body package="PackageCategories" selector="checkPrerequisiteNamed:withVersion:requiredVersion:">checkPrerequisiteNamed: prerequisiteName withVersion: prerequisiteVersionString requiredVersion: requiredVersionString	"Answer if the version of the prerequisite prerequisiteName is acceptable.	Callback for prerequiste loading"	| blk |	( blk := self versionSelectionBlock  ) == nil		ifTrue: [ ^true ].	^blk		value: prerequisiteName		value: prerequisiteVersionString		value: requiredVersionString</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>store data</category><body package="PackageCategories" selector="dataKeys">dataKeys	| list |	list := List new.	bindings do: 		[ :i | i isForGeneral ifTrue: [ list add: i key ] ].	^list</body></methods><methods><class-id>Kernel.Parcel</class-id> <category>store</category><body package="PackageCategories" selector="asDBRecord">asDBRecord	"Convert receiver into a DBRecord ready for installation into database."	|record|	record := self classOfDbRecord from: self.	self parcelOutToDb: record.	^record</body></methods><methods><class-id>Tools.IncrementalSearchModule class</class-id> <category>instance creation-predefined</category><body package="PackageCategories" selector="forPackageSelection:">forPackageSelection: prompt	"Answer a module that allows to select a package with search by a partial name."	| instance |	instance := self new.	instance 		firstLabel: prompt;		secondLabel: #PackagesC &lt;&lt; #labels &gt;&gt; 'Packages:';		searchBlock: [:string | self findPackagesMatching: string];		objectToStringBlock: [:package | package name];		iconBlock: 			[:package | 			package == Store.Registry nullPackage ifTrue: [nil] ifFalse: [package toolListIcon]].	^instance</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>store utils</category><body package="PackageCategories" selector="dataBindings">dataBindings	| list |	list := List new.	bindings do: 		[ :i | i isForGeneral ifTrue: [ list add: i ] ].	^list</body></methods><methods><class-id>Tools.CategorizedSelectionModule class</class-id> <category>instance creation-predefined</category><body package="PackageCategories" selector="forClassesByPackage">forClassesByPackage	"self forClassesByPackage open"	^self new		categoryModule: TreeSelectionModule forStoreBundlesAndPackages		itemModule: ListSelectionModule forClasses		itemBlock: [:pundle | self classesInPundle: pundle]</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>accessing</category><body package="PackageCategories" selector="protocol">protocol	^self argumentForKeyWord: 'category'</body></methods><methods><class-id>Kernel.SourceFileFormat</class-id> <category>code component support</category><body package="PackageCategories" selector="bundleNamed:structure:on:">bundleNamed: name structure: structure on: aStream	"Add the changing of a bundle structure event on a stream. "	^self subclassResponsibility</body></methods><methods><class-id>Tools.DefinitionCreationDialog</class-id> <category>private-validation</category><body package="PackageCategories" selector="isPackageProvided">isPackageProvided	| name |	name := packageModule value.	^name notNil and: [name trimBlanks notEmpty]</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>accessing</category><body package="PackageCategories" selector="binding">binding	^self object</body></methods><methods><class-id>Kernel.AbsentClassImport</class-id> <category>accessing</category><body package="PackageCategories" selector="absoluteName">absoluteName	"HACK. Since #fullName is relative to Smalltak, we have to force it to be relative to nil for Store."		^( self fullName indexOfSubCollection: 'Root' startingAt: 1 ) == 1		ifTrue: [ self fullName ]		ifFalse: [ 'Root.Smalltalk.', self fullName ].</body></methods><methods><class-id>XML.SourceNodeBuilder</class-id> <category>compiling-code components</category><body package="PackageCategories" selector="compile_bundle_structure:">compile_bundle_structure: anElement	| reg bundle string |	reg := #{Store.Registry} valueOrDo: [ ^nil ].	string :=  self getString: 'name' from: anElement default: ''.	string isEmpty		ifTrue: [ ^nil ].	bundle := reg bundleNamedOrCreate: string.	string := self getString: 'structure' from: anElement default: ''.	bundle structure: ( Compiler evaluate: string ).</body></methods><methods><class-id>Kernel.OverridenClass</class-id> <category>store</category><body package="PackageCategories" selector="asPsuedoRecord">asPsuedoRecord	"Answer a store psuedo record representing the image version of the 	class/namespace part of the receiver."	 ^Store.PseudoRecord fromModel: self</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>store data</category><body package="PackageCategories" selector="datumDescriptors">datumDescriptors		"Answer a collection of DatumDescriptors for the recievers dataKeys."	^self dataKeys asSortedCollection asOrderedCollection collect: 		[ :dataKey | 		Store.DatumDescriptor fromDataKey: dataKey nameSpaceName: self absoluteName 		]</body></methods><methods><class-id>Kernel.Parcel</class-id> <category>store</category><body package="PackageCategories" selector="copyPropertiesTo:">copyPropertiesTo:  pkg	"Move the receiver's properties to pkg. Where possible, use accessors."	"May have to do a little editing."	properties keysAndValuesDo:		[ :key : value |		[ pkg  perform: ( key, ':' ) asSymbol with: value ] on: MessageNotUnderstood 			do: [ :e | pkg propertyAt: key put: value. e return ]		]</body><body package="PackageCategories" selector="asPackage">asPackage	"Answer a package that duplicates the receiver."	^self asPackageNamed: self name.</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>store data</category><body package="PackageCategories" selector="includesDataKey:">includesDataKey: dataKey	"is this one of the data items."	^self includesKey: dataKey</body></methods><methods><class-id>Kernel.XMLSourceFileFormat</class-id> <category>code component support</category><body package="PackageCategories" selector="bundleStructure:on:">bundleStructure: aBundle on: aStream	"Save the bundle structure on a Stream."	self bundleNamed: aBundle name structure: aBundle structure on: aStream</body></methods><methods><class-id>Core.String</class-id> <category>private-store</category><body package="PackageCategories" selector="asClassNameOnly">asClassNameOnly	"Check if the string names meta class and strip 	the postfix class."	^self namesMetaClass		ifTrue: [self classNameOnly]		ifFalse: [self copy]</body></methods><methods><class-id>Core.Metaclass</class-id> <category>team tools</category><body package="PackageCategories" selector="absoluteSymbol">absoluteSymbol	^self absoluteName asSymbol</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>store</category><body package="PackageCategories" selector="dataKey">dataKey	^self key</body></methods><methods><class-id>Kernel.OverridenMethod</class-id> <category>store</category><body package="PackageCategories" selector="asPsuedoRecord">asPsuedoRecord	"Answer a store psuedo record representing the image version of the 	class/namespace part of the receiver."	 ^Store.ClassDescriptor 		fullName: self owner absoluteName 		meta: self isMeta</body></methods><methods><class-id>Kernel.BindingReference class</class-id> <category>tt_utilities</category><body package="PackageCategories" selector="fullNameFrom:name:">fullNameFrom: aPath name: aString	^( aPath == nil or: [ aPath isEmpty ] )		ifTrue: [ aString asString ]		ifFalse: [ ( aPath asQualifiedReference append: aString ) asString ]</body></methods><methods><class-id>Tools.DefinitionCreationDialog</class-id> <category>accessing</category><body package="PackageCategories" selector="packageOrDo:">packageOrDo: aBlock	| name |	name := self packageModule value.	^(Store.Registry packageNamed: name) 			ifNil: [aBlock value]</body></methods><methods><class-id>Core.Class</class-id> <category>store data</category><body package="PackageCategories" selector="includesDataKey:">includesDataKey: dataKey 	"is this one of the data items."	"should check the class vars."	^self asNameSpace includesKey: dataKey</body><body package="PackageCategories" selector="dataAt:put:">dataAt: aDataKey put: data 	"Install a data value. Answer true if ok"	self asNameSpace dataAt: aDataKey put: data.	^true</body></methods><methods><class-id>Core.String</class-id> <category>private-store</category><body package="PackageCategories" selector="namesMetaClass">namesMetaClass	"Answer true if the string contains the word class."	^self size &gt; 6 and: [(self copyFrom: self size - 5 to: self size)			= ' class']</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>store</category><body package="PackageCategories" selector="methodDescriptors">methodDescriptors	^self selectors asSortedCollection asOrderedCollection collect:  		[ :sel | 		Store.MethodDescriptor 			fromSelector: sel 			className: self absoluteName 			meta: self isMeta 		]</body></methods><methods><class-id>Core.Class</class-id> <category>store tools</category><body package="PackageCategories" selector="absoluteSymbol">absoluteSymbol	"Answer an environment independant 	(and therefore truely unique) name"	^(self fullyQualifiedReferenceFrom: nil) asSymbol</body></methods><methods><class-id>Kernel.OverridenMethod</class-id> <category>store</category><body package="PackageCategories" selector="protocolName">protocolName	| p |	^( p := self protocol ) == nil		ifTrue: [ ClassOrganizer defaultProtocol ]		ifFalse: [ p ]</body></methods><methods><class-id>Tools.EntryWithPasteButtonModule class</class-id> <category>instance creation</category><body package="PackageCategories" selector="forPackages">forPackages	^self new 		pasteBlock: [self selectPackage];		yourself</body></methods><methods><class-id>Kernel.BindingReference class</class-id> <category>tt_utilities</category><body package="PackageCategories" selector="newName:from:">newName: newName from: oldQualifiedName	| path |	path := self parseString: oldQualifiedName.	path at: path size put: newName.	^( self path: path ) asString</body></methods><methods><class-id>Tools.IncrementalSearchModule class</class-id> <category>private</category><body package="PackageCategories" selector="findPackagesMatching:">findPackagesMatching: aString	| pattern packages |	pattern := aString trimBlanks, '*'.	packages := Store.Registry allPackages.	packages := packages copyWith: Store.Registry nullPackage.	^(packages select: [:each | pattern match: each name])		asSortedCollection: [:a :b | a name &lt; b name]</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>store</category><body package="PackageCategories" selector="sourceCode">sourceCode	^self text</body></methods><methods><class-id>Store.PublishAsParcelDialog class</class-id> <category>interface specs</category><body package="PackageCategories" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #Publish #defaultString: 'Publish' #catalogID: #packages) 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 489 157 961 637 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 4 0 5 0 -4 1 -39 1 ) 					#label: #(#{Kernel.UserMessage} #key: #ParcelOptions #defaultString: 'Parcel options' #catalogID: #packages) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 11 80 ) 					#name: #parcelWarningMessage 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#ColorValue #red ) ) 					#label: #parcelWarningMessage ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 11 25 ) 					#name: #parcelSave 					#model: #parcelSave 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #parcelSaveChanged ) 					#label: #(#{Kernel.UserMessage} #key: #PublishParcel #defaultString: 'Publish Parcel' #catalogID: #packages) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 3 ) 							#label: #(#{Kernel.UserMessage} #key: #ParcelPathC #defaultString: 'Parcel Path:' #catalogID: #packages) ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 100 0 0 0 0 1 25 0 ) 							#name: #parcelDirectory 							#flags: 40 							#model: #parcelDirectory ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 11 0 50 0 -11 1 75 0 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: #(#{Kernel.UserMessage} #key: #StoreOptions #defaultString: 'Store options' #catalogID: #packages) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0787037 0 0.253333 ) 							#name: #bundleStructure 							#model: #bundleStructure 							#callbacksSpec: 							#(#{UI.UIEventCallbackSubSpec} 								#valueChangeSelector: #bundleStructureChanged ) 							#label: #(#{Kernel.UserMessage} #key: #IncludeBundleStructure #defaultString: 'Include bundle structure' #catalogID: #packages) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.174699 0 0.537634 ) 							#name: #databaseLinks 							#model: #databaseLinks 							#label: #(#{Kernel.UserMessage} #key: #WithDatabaseLinks #defaultString: 'With database links' #catalogID: #packages) ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 15 0 0 0.333333 -5 0.5 75 0.333333 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: #(#{Kernel.UserMessage} #key: #SourceOptions #defaultString: 'Source options' #catalogID: #packages) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0722892 0 0.198276 ) 							#name: #parcelSaveSource 							#model: #parcelSaveSource 							#callbacksSpec: 							#(#{UI.UIEventCallbackSubSpec} 								#valueChangeSelector: #parcelSaveSourceChanged ) 							#label: #(#{Kernel.UserMessage} #key: #SaveSourceFile #defaultString: 'Save source file' #catalogID: #packages) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.174699 0 0.422414 ) 							#name: #parcelHideSource 							#model: #parcelHideSource 							#label: #(#{Kernel.UserMessage} #key: #HideSourceOnLoad #defaultString: 'Hide source on load' #catalogID: #packages) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.174699 0 0.681034 ) 							#name: #parcelPadded 							#model: #parcelPadded 							#label: #(#{Kernel.UserMessage} #key: #PadSource #defaultString: 'Pad source' #catalogID: #packages) ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 15 0 0 0.583333 -5 0.5 80 0.583333 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: #(#{Kernel.UserMessage} #key: #MiscellaeonousOptions #defaultString: 'Miscellaeonous Options' #catalogID: #packages) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0843373 0 0.2 ) 							#name: #parcelRepublish 							#model: #parcelRepublish 							#label: #(#{Kernel.UserMessage} #key: #Republish #defaultString: 'Republish' #catalogID: #packages) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0843373 0 0.448 ) 							#name: #parcelBackup 							#model: #parcelBackup 							#label: #(#{Kernel.UserMessage} #key: #Backup #defaultString: 'Backup' #catalogID: #packages) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0843373 0 0.712 ) 							#name: #parcelOverwrite 							#model: #parcelOverwrite 							#label: #(#{Kernel.UserMessage} #key: #OverwriteExistingFiles #defaultString: 'Overwrite existing files' #catalogID: #packages) ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 5 0.5 0 0.583333 -15 1 80 0.583333 ) ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 -5 1 0 1 ) 					#model: #accept 					#label: #(#{Kernel.UserMessage} #key: #Publish #defaultString: 'Publish' #catalogID: #packages) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 -5 1 0.5 1 ) 					#model: #cancel 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #packages) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} -10 1 -5 1 1 1 ) 					#model: #helpAction 					#label: #(#{Kernel.UserMessage} #key: #Help #defaultString: 'Help' #catalogID: #packages) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Store.PackageChooser class</class-id> <category>interface specs</category><body package="PackageCategories" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{FullSpec} 		#window: 		#(#{WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #ChooseAPackage #defaultString: 'Choose a Package' #catalogID: #packages) 			#min: #(#{Point} 199 275 ) 			#bounds: #(#{Rectangle} 288 163 665 588 ) ) 		#component: 		#(#{SpecCollection} 			#collection: #(				#(#{SequenceViewSpec} 					#layout: #(#{LayoutFrame} 5 0 40 0 -12 1 -52 1 ) 					#flags: 15 					#model: #packageList 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#doubleClickSelector: #dClickAccept ) ) 				#(#{ActionButtonSpec} 					#layout: #(#{LayoutOrigin} 0 0.774536 0 0.898823 ) 					#name: #cancelButton 					#model: #cancel 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #packages) 					#defaultable: true ) 				#(#{ActionButtonSpec} 					#layout: #(#{LayoutOrigin} 5 0 -43 1 ) 					#name: #OKbutton 					#model: #accept 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #packages) 					#isDefault: true 					#defaultable: true ) 				#(#{ActionButtonSpec} 					#layout: #(#{AlignmentOrigin} 0 0.453581 -43 1 0.5 0 ) 					#name: #addButton 					#model: #addNewPackage 					#label: #(#{Kernel.UserMessage} #key: #Add #defaultString: 'Add' #catalogID: #packages) 					#defaultable: true ) 				#(#{LabelSpec} 					#layout: #(#{AlignmentOrigin} 0 0.5 9 0 0.5 0 ) 					#label: #dialogHeader ) ) ) )</body><body package="PackageCategories" selector="windowSpecNoCancel">windowSpecNoCancel	"UIPainter new openOnClass: self andSelector: #windowSpecNoCancel"	&lt;resource: #canvas&gt;	^#(#{FullSpec} 		#window: 		#(#{WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #ChooseAPackage #defaultString: 'Choose a Package' #catalogID: #packages) 			#min: #(#{Point} 199 275 ) 			#bounds: #(#{Rectangle} 373 204 768 625 ) ) 		#component: 		#(#{SpecCollection} 			#collection: #(				#(#{SequenceViewSpec} 					#layout: #(#{LayoutFrame} 5 0 40 0 -5 1 -50 1 ) 					#flags: 15 					#model: #packageList 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#doubleClickSelector: #dClickAccept ) ) 				#(#{ActionButtonSpec} 					#layout: #(#{LayoutOrigin} 25 0 -43 1 ) 					#name: #OKbutton 					#model: #accept 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #packages) 					#isDefault: true 					#defaultable: true ) 				#(#{ActionButtonSpec} 					#layout: #(#{LayoutOrigin} 0 0.728495 0 0.900709 ) 					#name: #addButton 					#model: #addNewPackage 					#label: #(#{Kernel.UserMessage} #key: #Add #defaultString: 'Add' #catalogID: #packages) 					#defaultable: true ) 				#(#{LabelSpec} 					#layout: #(#{AlignmentOrigin} 0 0.5 9 0 0.5 0 ) 					#label: #dialogHeader ) ) ) )</body></methods><methods><class-id>Store.BundleSpecEditor class</class-id> <category>interface specs</category><body package="PackageCategories" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #BundleEditor #defaultString: 'Bundle Editor' #catalogID: #packages) 			#min: #(#{Core.Point} 350 250 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 424 368 1024 768 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 65 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #AvailableC #defaultString: 'Available:' #catalogID: #packages) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 65 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #BundleContentsC #defaultString: 'Bundle contents:' #catalogID: #packages) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 35 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #BundleNameC #defaultString: 'Bundle name: ' #catalogID: #packages) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 125 0 10 0 -85 1 35 0 ) 					#name: #bundleName 					#model: #bundleName 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #bundleNameChanged ) 					#isReadOnly: false ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 65 0 -80 0.5 -45 1 ) 					#name: #availablePundlesView 					#flags: 15 					#model: #availablePundles 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: 						#okSelection: ) 					#multipleSelections: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -75 0.5 65 0 -5 0.5 90 0 ) 					#name: #addButton 					#model: #addToBundleContents 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#label: #(#{Kernel.UserMessage} #key: #AddArrow #defaultString: 'Add &gt;' #catalogID: #packages) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -75 0.5 95 0 -5 0.5 120 0 ) 					#name: #removeButton 					#model: #removeBundleItem 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#label: #(#{Kernel.UserMessage} #key: #Remove #defaultString: '&lt; Remove' #catalogID: #packages) 					#defaultable: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.5 65 0 -85 1 -45 1 ) 					#name: #bundleContentsView 					#flags: 15 					#model: #bundleContents ) 				#(#{UI.ActionButtonSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false ) 					#layout: #(#{Graphics.LayoutFrame} -80 1 95 0 -10 1 120 0 ) 					#name: #downButton 					#model: #moveBundleItemDown 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#tabable: false 					#label: #(#{Kernel.UserMessage} #key: #MoveDown #defaultString: 'Move Down' #catalogID: #packages) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false ) 					#layout: #(#{Graphics.LayoutFrame} -80 1 65 0 -10 1 90 0 ) 					#name: #upButton 					#model: #moveBundleItemUp 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#tabable: false 					#label: #(#{Kernel.UserMessage} #key: #MoveUp #defaultString: 'Move Up' #catalogID: #packages) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -80 1 130 0 -10 1 155 0 ) 					#name: #validateLoadOrder 					#model: #validateLoadOrder 					#label: #(#{Kernel.UserMessage} #key: #Validate #defaultString: 'Validate' #catalogID: #packages) 					#isDefault: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -85 1 -35 1 -10 1 -10 1 ) 					#name: #cancelButton 					#model: #cancel 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #packages) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -165 1 -35 1 -90 1 -10 1 ) 					#name: #acceptButton 					#model: #accept 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #packages) 					#isDefault: true 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Store.BundleSpecEditor class</class-id> <category>resources</category><body package="PackageCategories" selector="downArrow">downArrow	"UIMaskEditor new openOnClass: self andSelector: #downArrow"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 13@8 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 127 240 0 0 63 224 0 0 31 192 0 0 15 128 0 0 7 0 0 0 2 0 0 0 0 0 0 0])</body><body package="PackageCategories" selector="upArrow">upArrow	"UIMaskEditor new openOnClass: self andSelector: #upArrow"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 13@8 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 2 0 0 0 7 0 0 0 15 128 0 0 31 192 0 0 63 224 0 0 127 240 0 0 0 0 0 0])</body></methods><methods><class-id>Tools.SelectClassDialog</class-id> <category>pages</category><body package="PackageCategories" selector="installByPackagePage">installByPackagePage	&lt;page: 2 label: #(#ByPackage #labels 'By Package')&gt;	| module |	module := (CategorizedSelectionModule forClassesByPackage)		showLabels: true;		firstLabel: #PackagesC &lt;&lt; #labels &gt;&gt; 'Packages:';		secondLabel: #ClassesC &lt;&lt; #labels &gt;&gt; 'Classes:';		yourself.	module itemModule when: #doubleClick evaluate: [self accept value: true].	self installPage: module</body></methods><initialize><class-id>Store.Access</class-id></initialize><initialize><class-id>Store.PundleAccess</class-id></initialize><initialize><class-id>Store.PundleModel</class-id></initialize><initialize><class-id>Store.XMainChangeSet</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>GeneralBindingReference</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>path cache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>AbsentClassImport</name><environment>Kernel</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name isMeta format instanceVariables dummyBehavior dummyClassPool </inst-vars><class-inst-vars></class-inst-vars><imports>			Core.Behavior.*			</imports><category>System-Code Storage</category><attributes><package>System-Code Storage</package></attributes></class><class><name>IdentityDictionary</name><environment>Core</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>valueArray </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>SourceNodeBuilder</name><environment>XML</environment><super>XML.XMLNodeBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Source Code</category><attributes><package>XML-source</package></attributes></class><class><name>ComponentChange</name><environment>Kernel</environment><super>Kernel.Change</super><private>false</private><indexed-type>none</indexed-type><inst-vars>componentType componentName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Component Changes</category><attributes><package>System-Code Component Changes</package></attributes></class><class><name>CodeComponent</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Components</category><attributes><package>System-Code Components</package></attributes></class><class><name>ClassDescription</name><environment>Core</environment><super>Core.Behavior</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instanceVariables organization </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Metaclass</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thisClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>SourceFileFormat</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objectProperties methodProperties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>Kernel-Support</package></attributes></class><class><name>ChunkSourceFileFormat</name><environment>Kernel</environment><super>Kernel.SourceFileFormat</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>Kernel-Support</package></attributes></class><class><name>Override</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sources definition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class><class><name>OverridenMethod</name><environment>Kernel</environment><super>Kernel.Override</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector protocol instVarNames </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class><class><name>OverridenStatic</name><environment>Kernel</environment><super>Kernel.Override</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class><class><name>OverridenNameSpace</name><environment>Kernel</environment><super>Kernel.Override</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comment documentation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class><class><name>OverridenClass</name><environment>Kernel</environment><super>Kernel.Override</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>comment documentation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ChangeSet</name><environment>Kernel</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objectChanges objectRemoves componentChanges specialDoIts initializationOrder </inst-vars><class-inst-vars>dependents </class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>System-Changes</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class><class><name>SelectClassDialog</name><environment>Tools</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tabListHolder pageSubCanvas selectionHolder windowLabel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Dialogs</category><attributes><package>Tools-Dialogs</package></attributes></class><class><name>DefinitionCreationDialog</name><environment>Tools</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packageModule categoryModule namespaceModule nameHolder privateHolder importsHolder </inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.Navigator			</imports><category>Tools-Programming</category><attributes><package>Tools-Programming</package></attributes></class><class><name>Warning</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>GeneralNameSpace</name><environment>Kernel</environment><super>Core.KeyedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>organization bindings specificImports generalImports </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>NameSpaceOfClass</name><environment>Kernel</environment><super>Kernel.GeneralNameSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars>owner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>XMLSourceFileFormat</name><environment>Kernel</environment><super>Kernel.SourceFileFormat</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state docName cachedFile cachedParser </inst-vars><class-inst-vars></class-inst-vars><imports>			private XML.*			</imports><category>Kernel-Support</category><attributes><package>XML-source</package></attributes></class><class><name>Parcel</name><environment>Kernel</environment><super>Kernel.CodeComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definedObjects definedClasses definedBindings classSelectors namedObjects dirty loaded </inst-vars><class-inst-vars>parcels classParcelMap parcelFileInfoCache parcelFileDirectoryCache </class-inst-vars><imports></imports><category>System-Code Components</category><attributes><package>System-Code Components</package></attributes></class><class><name>SourceScannerNodeBuilder</name><environment>XML</environment><super>XML.XMLNodeBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectors currentFile currentPosition positions changeBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Source Code</category><attributes><package>XML-source</package></attributes></class><class><name>SourceFileManager</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>files names writableIndices openIndices currentTarget isPadding sourceFormatters sourceToCopy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>Kernel-Support</package></attributes></class></st-source>