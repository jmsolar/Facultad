<?xml version="1.0"?><st-source><!-- Name: HeadlessNotice: Copyright © 2005-1999 Cincom Systems, Inc.  All Rights Reserved.Comment: Contains support code necessary to run VisualWorks images headless, that is, without a GUI. Headless applications are typically used in a server environment.Further information on headless application support can be found in the "Application Developer''s Guide" (located in the /doc subdirectory of the VisualWorks installation).DbIdentifier: bear73DbTrace: 52913DevelopmentPrerequisites: #(#(#any 'Tools-Trippy' '') #(#any 'Tools-Workspace' ''))PackageName: HeadlessParcel: #('Headless')ParcelName: HeadlessPrintStringCache: (7.3.1 - 1.1,bobw)Version: 7.3.1Date: 6:40:39 pm April 10, 2005 --><time-stamp>From VisualWorks®, 7.3.1 of April 10, 2005 on April 10, 2005 at 6:40:39 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ProcessDictionaryInspector</name><environment>Tools</environment><super>Tools.DictionaryInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Headless-Support</category><attributes><package>Headless</package></attributes></class><comment><class-id>Tools.ProcessDictionaryInspector</class-id><body>I am an inspector for a ProcessDictionary.  I allow for inspecting the context stacks and opening debuggers of the suspended processes in this dictionary.</body></comment><class><name>HeadlessScreen</name><environment>Graphics</environment><super>Graphics.Screen</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Headless-Support</category><attributes><package>Headless</package></attributes></class><comment><class-id>Graphics.HeadlessScreen</class-id><body>I am a subclass of Screen for the express purpose of not activating the Screen.</body></comment><class><name>BasicHeadlessSystem</name><environment>Core</environment><super>Graphics.BasicGraphicsSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Headless</category><attributes><package>Headless</package></attributes></class><comment><class-id>Core.BasicHeadlessSystem</class-id><body>This handles early setup of a headless image. If this activates, then BasicHeadfullGraphicsSystem will not.</body></comment><class><name>FileTextCollector</name><environment>UI</environment><super>UI.TextCollector</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Headless-Support</category><attributes><package>Headless</package></attributes></class><comment><class-id>UI.FileTextCollector</class-id><body>I append text to a filestream (my value) using Stream protocol.</body></comment><class><name>HeadlessError</name><environment>Core</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Headless-Support</category><attributes><package>Headless</package></attributes></class><comment><class-id>Core.HeadlessError</class-id><body>The image is running headless, and this process has violated the rules of headlessness. Usually, by atttempting to access the display. </body></comment><class><name>HeadlessImage</name><environment>Core</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isTerminating suspendedProcesses savedTranscript startupFilename transcriptFilename currentlyHeadless shouldSaveHeadless </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Headless-Support</category><attributes><package>Headless</package></attributes></class><comment><class-id>Core.HeadlessImage</class-id><body>The image can run headless, i.e., in a graphic-less environment. This class assists in that endeavor. The default instance keeps a flag indicating whether the current image is headless. Early installation code checks with the default instance to determine if it should hook up to a window system. Window system interface code likewise checks if it can access a window system. When the image is headless it cannot, and the default instance typically raises an exception.Processes that have transgressed either by trying to utilize the display or by raising an unhandled exception will be suspended and retained in 'suspendedProcesses' for possible future debugging. To debug such a process, the headless image must be saved headfull and restarted. Then the processes in 'suspendedProcesses' can be inspected and debugged.The Transcript is handled differently when the image is headless versus headfull. When transitioning from headfull to headless, the normal Transcript is retained (in 'savedTranscript'), but not accessible. In its place, a file-based Transcript receives input and directs it to a file. When transitioning from headless to headful, the normal Transcript is restored.When the image is started headless, it files in a startup file. The file must contain Smalltalk expressions in fileIn format. These expressions are what get the headless application going.Instance Variables:	isHeadless			&lt;Boolean&gt;		indicates whether the image runs headless	suspendedProcesses	&lt;ProcessDictionary&gt;		processes suspended for future inspection and debugging after they tried		to access the non-existent window system, e.g., to open a view.	savedTranscript		&lt;TextCollector&gt; the Transcript is saved until the image is headfull again.	startupFilename		&lt;String | nil&gt;		the name of the startup file. When nil, no startup file is filed in.	transcriptFilename	&lt;String | nil&gt;		the name of the transcript file. When nil, no transcript file is used.ClassVariables:	DefaultHeadlessImage	&lt;HeadlessImage&gt;	The sole instantiation of this class	HeadlessErrorSignal		&lt;Signal&gt;	The signal raised due to violations of headlessness</body></comment><class><name>ProcessDictionary</name><environment>Core</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Headless-Support</category><attributes><package>Headless</package></attributes></class><comment><class-id>Core.ProcessDictionary</class-id><body>My values are suspended processes. My inspector class (ProcessDictionaryInspector) and I allow for inspecting the context stacks and opening debuggers.</body></comment><class><name>NullTextCollector</name><environment>UI</environment><super>UI.TextCollector</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Headless-Support</category><attributes><package>Headless</package></attributes></class><comment><class-id>UI.NullTextCollector</class-id><body>This class exists as a TextCollector that effectively ignores its input.The instance variable 'value' is always an empty string.The instance variable 'entryStream' doesn't hold anything.  Methods that would ordinarily insert into it have been stubbed out.The #appendEntry and #update symbols are not broadcast to dependents.</body></comment><class><name>ProcessDictionaryInspector</name><environment>Tools.Trippy</environment><super>Tools.Trippy.DictionaryInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Headless</package></attributes></class><comment><class-id>Tools.Trippy.ProcessDictionaryInspector</class-id><body>I am an inspector for a ProcessDictionary.  I allow for inspecting the context stacks and opening debuggers of the suspended processes in this dictionary.</body></comment><shared-variable><name>QuitOnHeadlessError</name><environment>Tools.Notifier</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>false</initializer><attributes><package>Headless</package></attributes></shared-variable><methods><class-id>Tools.ProcessDictionaryInspector</class-id> <category>text</category><body package="Headless" selector="text">text	"Answer the text displayed by the receiver."	| suspendedContext |	field == nil ifTrue: [^ Text new].	suspendedContext := self fieldValue suspendedContext.	^nil == suspendedContext		ifTrue: [suspendedContext printString]		ifFalse: [suspendedContext printStack]</body></methods><methods><class-id>Tools.ProcessDictionaryInspector</class-id> <category>field list</category><body package="Headless" selector="fieldMenu">fieldMenu	"DictionaryInspector flushMenus" 	field isNil ifTrue: [^nil].	^Menu			labels: 'debug\remove' withCRs			lines: #()			values: #(debugField removeField)</body></methods><methods><class-id>Tools.ProcessDictionaryInspector</class-id> <category>menu commands</category><body package="Headless" selector="debugField">debugField	"Since we are the old inspector, let's use the old debugger."	Debugger openOnSuspended: self fieldValue</body></methods><methods><class-id>Graphics.HeadlessScreen</class-id> <category>accessing</category><body package="Headless" selector="bounds">bounds	"This message should never be sent when running headless."	HeadlessImage default checkHeadless.</body><body package="Headless" selector="contentsFromUser">contentsFromUser	"From super:	Answer an Image with the contents of a user-specified area on	my screen.  The palette of the returned image may differ from the	receiver's default color palette.  For example, the captured image may	potentially use pixel values that are unallocated in the default color	palette."	"Clients have no business sending this in a headless image."	^HeadlessImage default cannotSend</body><body package="Headless" selector="isOpen">isOpen	"From super:	Answer whether the receiver is open."	"Since we are headless, always answer false."	^false</body></methods><methods><class-id>Graphics.HeadlessScreen</class-id> <category>user interaction</category><body package="Headless" selector="dragShape:offset:gridPhase:gridSpacing:boundedBy:whileButton:isDown:">dragShape: shape offset: offsetPoint gridPhase: gridPhasePoint gridSpacing: gridSpacingPoint boundedBy: boundsRectangleOrNil whileButton: button isDown: isDownBoolean 	"Override the Screen implementation for the purpose of trapping this 	operation when running headless"	^HeadlessImage default cannotSend</body><body package="Headless" selector="flush">flush	^self</body><body package="Headless" selector="platformName">platformName	^'Unknown'.</body></methods><methods><class-id>Graphics.HeadlessScreen</class-id> <category>initializing</category><body package="Headless" selector="initialize">initialize	"Don't call super initialize. Set the resolution, because it's hard-coded anyway"	resolution := 75@75.</body></methods><methods><class-id>Graphics.HeadlessScreen class</class-id> <category>system startup</category><body package="Headless" selector="install">install	"This method should be unnecessary because I assume that the	only place #install is sent to Screen is in Screen&gt;initialize.  Let's	test that assumption..."	HeadlessImage default cannotSend</body><body package="Headless" selector="open:">open: aNameOrNil	"Link up to a display, permitting the creation of windows and pixmaps"	"Only a single screen is currently supported."	^self new.</body><body package="Headless" selector="preSnapshot">preSnapshot	"From super:	Prepare to snapshot"	"When running headless, nothing needs to be done."	^self</body></methods><methods><class-id>Graphics.HeadlessScreen class</class-id> <category>class initialization</category><body package="Headless" selector="initialize">initialize	"Do nothing. Note that Screen sends itself #install in its version	of this method. Since we do not send #install here, we don't need	to override it in this subclass."	"HeadlessScreen initialize"	^self</body></methods><methods><class-id>Core.BasicHeadlessSystem</class-id> <category>testing</category><body package="Headless" selector="canActivate">canActivate	^super canActivate and: [HeadlessImage isHeadless].</body></methods><methods><class-id>Core.BasicHeadlessSystem</class-id> <category>actions</category><body package="Headless" selector="setUp">setUp	"Note that we explicitly don't call super setUp here, because our superclass is going to set up by activating exactly one of its subclasses"	HeadlessImage isHeadless ifTrue: [		HeadlessScreen preInstall.		HeadlessImage current setupTranscript].</body></methods><methods><class-id>UI.FileTextCollector</class-id> <category>entry control</category><body package="Headless" selector="appendEntry">appendEntry	value nextPutAll: self nextEntry; commit</body><body package="Headless" selector="endEntry">endEntry	"If the receiver's WriteStream is not empty, then reinitialize it. "	entryStream isEmpty		ifFalse: 			[self appendEntry.			self beginEntry]</body></methods><methods><class-id>UI.FileTextCollector</class-id> <category>initialize-release</category><body package="Headless" selector="release">release	value close</body></methods><methods><class-id>UI.FileTextCollector</class-id> <category>clearing</category><body package="Headless" selector="clear">clear	"Re-initialize the file to contain no characters."	| filename |	filename := Filename named: value name.	self release.	filename delete.	self setValue: filename readAppendStream</body></methods><methods><class-id>UI.FileTextCollector class</class-id> <category>creating</category><body package="Headless" selector="named:">named: aString 	"Create an instance of myself, directed to the file named by aString."	^self new setValue: (Filename named: aString) readAppendStream</body></methods><methods><class-id>Core.HeadlessError</class-id> <category>defaults</category><body package="Headless" selector="defaultMessageText">defaultMessageText	^(#exceptHeadlessError &lt;&lt; #dialogs &gt;&gt; 'Attempted to access display in headless image').</body></methods><methods><class-id>Core.HeadlessImage</class-id> <category>accessing</category><body package="Headless" selector="isHeadless:">isHeadless: aBoolean	WindowingSystem canActivate: aBoolean not.</body><body package="Headless" selector="isTerminating:">isTerminating: aBoolean	isTerminating := aBoolean</body><body package="Headless" selector="shouldSaveHeadless">shouldSaveHeadless	^shouldSaveHeadless.</body><body package="Headless" selector="shouldSaveHeadless:">shouldSaveHeadless: aBoolean	shouldSaveHeadless := aBoolean.</body><body package="Headless" selector="startupFilename">startupFilename	"Nil means no startup file whatsoever."	^startupFilename</body><body package="Headless" selector="startupFilename:">startupFilename: aStringOrNil 	"Nil means no startup file whatsoever."	startupFilename := aStringOrNil</body><body package="Headless" selector="suspendedProcesses">suspendedProcesses	^suspendedProcesses</body><body package="Headless" selector="transcriptFilename">transcriptFilename	"Nil means no transcript file whatsoever."	^transcriptFilename</body><body package="Headless" selector="transcriptFilename:">transcriptFilename: aStringOrNil 	"Nil means no transcript file whatsoever."	transcriptFilename := aStringOrNil</body></methods><methods><class-id>Core.HeadlessImage</class-id> <category>testing</category><body package="Headless" selector="isActivationInProcess">isActivationInProcess	"Answer true if the system is running as a ``Smalltalk server'' within	 some process.  Answer false if the system is running as a stand-alone	 Smalltalk environment.  This will depend on whether the system was	 loaded as a DLL or shared library by some process, or not.  If the	 primitive fails then presumably the engine does not support being	 used as a DLL or shared library, so in this case return false."	&lt;primitive: 1059&gt;	^false</body><body package="Headless" selector="isHeadless">isHeadless	^WindowingSystem canActivate not.</body><body package="Headless" selector="isTerminating">isTerminating	^isTerminating</body></methods><methods><class-id>Core.HeadlessImage</class-id> <category>checking head</category><body package="Headless" selector="cannotSend">cannotSend	"The image is running headless, and this process has violated the	rules of headlessness. Raise the exception indicating a violation	of headlessness. If the exception is not caught, suspend and save	this process for later debugging. Optionally, save the image so it	can be debugged."	| now |	[HeadlessError raise] on: Signal noHandlerSignal		do: [:ex | ex return].	now := Time dateAndTimeNow.	suspendedProcesses at: now put: Processor activeProcess.	Transcript 		cr;		show: '-------------------';		print: now;		show: '------';		cr;		show: thisContext printStack;		show: '---------------------------------------------------';		cr;		endEntry.	"Optionally save the image right now so it can be debugged."	isTerminating 		ifTrue: 			[			[| justSnapped |			justSnapped := self saveHeadfull: self defaultDebugImageName.			justSnapped ifTrue: [ObjectMemory quit]] 					fork].	Processor activeProcess suspend</body><body package="Headless" selector="checkHeadless">checkHeadless	"This method is intended to be sent from those methods that should not be 	executed in a headless environment. If the image is not running headless, 	return without side-effect; otherwise, trigger the exception mechanism."	self isHeadless ifTrue: [self cannotSend]</body><body package="Headless" selector="dumpStackToTranscript:">dumpStackToTranscript: aContext	"Dump a stack trace to the Transcript starting at aContext."	Transcript 		cr;		nextPutAll: '---------------------------------------------------'; cr;		nextPutAll: aContext printStack;		nextPutAll: '---------------------------------------------------'; cr;		endEntry</body></methods><methods><class-id>Core.HeadlessImage</class-id> <category>private</category><body package="Headless" selector="defaultDebugImageName">defaultDebugImageName	^ 'headless-debug'.</body><body package="Headless" selector="defaultStartupFilename">defaultStartupFilename	^ 'headless-startup.st'</body><body package="Headless" selector="defaultTranscriptFilename">defaultTranscriptFilename	^ 'headless-transcript.log'</body><body package="Headless" selector="msgMissingStartupFileNamed:">msgMissingStartupFileNamed: aString	^(#msgMissingStartupFile &lt;&lt; #dialogs 		&gt;&gt; 'Startup file [&lt;1s&gt;] is unreadable or does not exist.')				expandMacrosWith: aString.</body></methods><methods><class-id>Core.HeadlessImage</class-id> <category>debugging</category><body package="Headless" selector="becomeHeadfull">becomeHeadfull	"WARNING: May cause stability problems.	This changes an image from headless to headful mode, manually running the things that need to be run in order to do this. Because we are running these things manually this is fragile code, and it won't take into account any possible user actions. However, it can be very useful in debugging, so we include it. See also ObjectMemory&gt;&gt;installSystemWithPriority:"	| workspace |	self isHeadless ifFalse: [^self].	WindowingSystem canActivate: true.	"We must explicitly activate the basic graphics, because the things that prereq them have already activated successfully"	BasicHeadfullGraphicsSystem activate.	DevelopmentSystem activate.	self setupTranscript.	workspace := (#{Tools.Workspace} ifDefinedDo: [:workspaceClass| workspaceClass] elseDo: [SimpleWorkspace])		with: #headlessWarning &lt;&lt; #headless &gt;&gt; 'WARNING: This image has been switched out of headless mode. It may be unstable. We recommend not saving this image and using it only for debugging. See HeadlessImage&gt;&gt;becomeHeadfull'		labeled: #WARNING &lt;&lt; #headless &gt;&gt; 'WARNING'.	workspace open.</body><body package="Headless" selector="debug:">debug: text	"Display the text on the Transcript, doing the right thing if it happens	to be file based. This method is provided purely as a courtesy for	debugging, and is not essential for headless operation."	Transcript cr; show: text.	(Transcript isKindOf: FileTextCollector) ifTrue: [Transcript value flush]</body></methods><methods><class-id>Core.HeadlessImage</class-id> <category>initializing</category><body package="Headless" selector="initialize">initialize	super initialize.	isTerminating := true.	suspendedProcesses := ProcessDictionary new.	self transcriptFilename: self defaultTranscriptFilename.	self startupFilename: self defaultStartupFilename.	currentlyHeadless := true.	shouldSaveHeadless := false.</body><body package="Headless" selector="setupTranscript">setupTranscript	"The Transcript is handled differently when the image is headless versus 	headful. When transitioning from headful to headless, the normal Transcript 	is retained (in 'savedTranscript'), but not accessible. A file-based 	Transcript is installed in its place. When transitioning from headless to 	headful, the normal Transcript is restored."	self isHeadless		ifTrue:			[| transi |			transi := #{TranscriptImplementation} 						ifDefinedDo: [:implementation| implementation] 						elseDo: [Transcript].			(transi isMemberOf: TextCollector)				ifTrue: [savedTranscript := transi].			transi := self transcriptFilename isNil				ifTrue: [NullTextCollector new]				ifFalse: [[(FileTextCollector named: self transcriptFilename)]						on: Error						do: [:ex | ex return: NullTextCollector new]].			TextCollector newTranscript: transi]		ifFalse:			[savedTranscript notNil				ifTrue: 					[TextCollector newTranscript: savedTranscript.					savedTranscript := nil]]</body></methods><methods><class-id>Core.HeadlessImage</class-id> <category>actions</category><body package="Headless" selector="pauseAction">pauseAction	super pauseAction.	currentlyHeadless := self isHeadless.	WindowingSystem canActivate: shouldSaveHeadless not.</body><body package="Headless" selector="readStartupFile">readStartupFile	| rcFile |	startupFilename isNil ifTrue: [^self].	ImageConfigurationSystem allowFilein ifFalse: [^self].	rcFile := Filename named: startupFilename.	(rcFile exists and: [rcFile isReadable])		ifTrue: [[rcFile fileIn] fork]		ifFalse: 			[Transcript				cr;				show: (self msgMissingStartupFileNamed: rcFile)].</body><body package="Headless" selector="resumeAction">resumeAction	super resumeAction.	WindowingSystem canActivate: currentlyHeadless not.	shouldSaveHeadless := currentlyHeadless.</body><body package="Headless" selector="setUp">setUp	super setUp.	shouldSaveHeadless := false.	self isHeadless ifTrue: [		self readStartupFile].</body></methods><methods><class-id>Core.HeadlessImage</class-id> <category>saving</category><body package="Headless" selector="saveHeadfull:">saveHeadfull: prefix	"Returns true if we just did the snapshot, false if we are restarting the image."	self shouldSaveHeadless: false.	^Snapshot new saveAs: prefix thenQuit: false.</body><body package="Headless" selector="saveHeadless:">saveHeadless: prefix	"Returns true if we just did the snapshot, false if we are restarting the image. Don't change our image prefix"	| oldImagePrefix snapshotResult |	oldImagePrefix := ObjectMemory imagePrefix.	self shouldSaveHeadless: true.	snapshotResult := Snapshot new saveAs: prefix thenQuit: false.	ObjectMemory.ImagePrefix := oldImagePrefix.	^snapshotResult.</body></methods><methods><class-id>Core.HeadlessImage</class-id> <category>prerequisites</category><body package="Headless" selector="prerequisiteSystems">prerequisiteSystems	"Note that BasicGraphicsSystem is an abstract superclass. This is specifically designed to accomodate us. Either the BasicHeadfullGraphicsSystem (normal windowing) will start up, or our BasicHeadlessGraphicsSystem will start up. Either way, the BasicGraphicsSystem counts as having started, so later subsystems can run."	^Array with: BasicGraphicsSystem.</body></methods><methods><class-id>Core.HeadlessImage class</class-id> <category>testing</category><body package="Headless" selector="isHeadless">isHeadless	^self current isHeadless.</body></methods><methods><class-id>Core.HeadlessImage class</class-id> <category>accessing</category><body package="Headless" selector="default">default	^self current.</body></methods><methods><class-id>Core.ProcessDictionary</class-id> <category>user interface</category><body package="Headless" selector="inspectorClass">inspectorClass	^ProcessDictionaryInspector</body><body package="Headless" selector="inspectorClasses">inspectorClasses	^Array		with: Tools.Trippy.ProcessDictionaryInspector		with: Tools.Trippy.BasicInspector</body></methods><methods><class-id>UI.NullTextCollector</class-id> <category>entry control</category><body package="Headless" selector="appendEntry">appendEntry	"Do nothing."	^self</body><body package="Headless" selector="endEntry">endEntry	"Do nothing."	^self</body></methods><methods><class-id>UI.NullTextCollector</class-id> <category>clearing</category><body package="Headless" selector="clear">clear	"Do nothing."	^self</body></methods><methods><class-id>UI.NullTextCollector</class-id> <category>character writing</category><body package="Headless" selector="cr">cr	"Do nothing."	^self</body><body package="Headless" selector="crtab">crtab	"Do nothing."	^self</body><body package="Headless" selector="crtab:">crtab: anInteger 	"Do nothing."	^self</body><body package="Headless" selector="space">space	"Do nothing."	^self</body><body package="Headless" selector="tab">tab	"Do nothing."	^self</body></methods><methods><class-id>UI.NullTextCollector</class-id> <category>private</category><body package="Headless" selector="characterLimit">characterLimit	^100</body></methods><methods><class-id>UI.NullTextCollector</class-id> <category>accessing</category><body package="Headless" selector="next:put:">next: anInteger put: aCharacter 	"Do nothing."	^self</body><body package="Headless" selector="nextPut:">nextPut: aCharacter 	"Do nothing."	^self</body><body package="Headless" selector="nextPutAll:">nextPutAll: aCollection 	"Do nothing."	^self</body></methods><methods><class-id>Tools.Trippy.ProcessDictionaryInspector</class-id> <category>private</category><body package="Headless" selector="addProcessItemsTo:">addProcessItemsTo: aMenu	aMenu		addItem: ((MenuItem labeled: 'Debug...')			nameKey: #debugProcess;			value: [self selection value debug];			enabled: [self hasSingleSelection])</body><body package="Headless" selector="augmentEditMenu:">augmentEditMenu: aMenu	aMenu addLine.	self addProcessItemsTo: aMenu</body><body package="Headless" selector="buildFieldListMenu">buildFieldListMenu	| menu |	menu := super buildFieldListMenu.	menu addLine.	self addProcessItemsTo: menu.	^menu</body></methods><methods><class-id>Tools.Trippy.ProcessDictionaryInspector class</class-id> <category>accessing</category><body package="Headless" selector="tabLabel">tabLabel	^'&amp;Processes'</body></methods><methods><class-id>Kernel.ObjectMemory class</class-id> <category>deprecated</category><body package="Headless" selector="saveHeadless:to:">saveHeadless: beHeadless to: imageFilePrefix 	^Snapshot new saveHeadless: beHeadless to: imageFilePrefix</body></methods><methods><class-id>UI.Dialog class</class-id> <category>multiple choice dialogs</category><body package="Headless" selector="confirm:initialAnswer:for:">confirm: messageString initialAnswer: aBoolean for: aVisualOrNil	"Ask the user a question, with a true/false answer. Return the response."	"aVisualOrNil, if not nil, may be either a VisualPart or a	ScheduledWindow.  It controls the look and feel and color choices	used by the dialog, and supplies the dialog's master window, which	is used by some window systems to create a visual connection between	the dialog and the window that created it."	"Dialog confirm: 'Are you tired yet?' initialAnswer: false		for: ScheduledControllers activeController view.	Dialog confirm: 'Are you completely sure?' initialAnswer: true		for: Dialog defaultParentWindow"	HeadlessImage default isHeadless ifTrue: [		Transcript cr; show: messageString.		^true].	^self		choose: messageString		labels: self confirmButtonLabels		values: self confirmAnswerResults		default: aBoolean		for: aVisualOrNil.</body></methods><methods><class-id>Core.SystemNotification</class-id> <category>private - actions</category><body package="Headless" selector="defaultAction">defaultAction	HeadlessImage default isHeadless ifTrue: [		^Transcript cr; show: messageText].	self aboutToDebug.	^Notifier openException: self.</body></methods><methods><class-id>Kernel.Process</class-id> <category>changing process state</category><body package="Headless" selector="terminateWithExtremePrejudice">terminateWithExtremePrejudice	"Terminate the receiver process, by sending the Process terminateSignal.	 Handle and discard any errors encountered running unwind blocks."	"If the receiver is the active process then raise the terminateSignal	 which should be caught by the handler in Process class&gt;&gt;forBlock:priority:.	 The handler will return, causing all unwind blocks to run, and then will	 invoke primTerminate, actually terminating the receiver."	Processor activeProcess == self ifTrue:		[[Process terminateSignal raise]			on: Object errorSignal,  Signal noHandlerSignal			do:				[:ex| | unwindingContext |				unwindingContext := thisContext findNextUnwindUpTo: nil.				(unwindingContext notNil				and: [unwindingContext sender notNil])					ifTrue: [thisContext terminateTo: unwindingContext sender]					ifFalse: [ex return]].		^self primTerminate].	"If the receiver is not the active process and its suspendedContext is nil then	 it is already suspended."	suspendedContext == nil ifTrue: [^self].	"Suspend the receiver, then place a block atop the receiver's stack to	 invoke this method as the active process, and resume the receiver."	interruptProtect critical:		[| savedContext interruptContext |		myList == nil ifFalse: [self suspend].		savedContext := suspendedContext.		interruptContext := [self terminateWithExtremePrejudice] newContext.		interruptContext sender: savedContext.		suspendedContext := interruptContext.		self resume]</body></methods><methods><class-id>Core.Locale class</class-id> <category>private</category><body package="Headless" selector="internalSet:">internalSet: aSymbol	"Set the current locale to aSymbol's locale."	CurrentLocale := self getLocale: aSymbol.	CurrentLocale == nil ifTrue: [		CurrentLocale := self getLocale: #C.		Dialog warn: ((#LocaleNotFound &lt;&lt; #dialogs &gt;&gt; 'Could not find locale: &lt;1s&gt;.  Using C locale instead.')			expandMacrosWith: aSymbol)].	"update dependents that there is a new locale (not font dependents)"	ByteArray purgeCaches.	self changed: #locale_early with: false.	self changed: #locale with: false.	"Next line needed under JWindows because:		a) default font must use appropriate encoding		b) font names with international characters must be correctly converted to Unicode"	HeadlessImage default isHeadless ifFalse:		[Screen default installFontPolicy].	"update font dependents that fonts may have been updated"	self changed: #localeFonts with: false.	HeadlessImage default isHeadless ifFalse:		[TextAttributes resetViews.		InputManager setDefault]</body></methods><methods><class-id>Graphics.Window class</class-id> <category>instance creation</category><body package="Headless" selector="new">new	"This message should never be sent when running headless."	HeadlessImage default checkHeadless.	^self basicNew initialize</body></methods><methods><class-id>UI.UIBuilder class</class-id> <category>private</category><body package="Headless" selector="install">install	"The image should not be sending this message when running headless. 	 Treat this as a harmless violation rather than triggering an exception."	HeadlessImage default isHeadless ifTrue: [^self].	self defaultPolicySelector value: self defaultPolicySelector value</body></methods><methods><class-id>UI.InputSensor class</class-id> <category>utilities</category><body package="Headless" selector="cursorPoint">cursorPoint	"This message should never be sent when running headless."	HeadlessImage default checkHeadless.	^InputState default mousePoint</body></methods><methods><class-id>UI.SimpleDialog</class-id> <category>interface opening</category><body package="Headless" selector="openFrom:">openFrom: aSpec 	"Open a dialog based on aSpec"	HeadlessImage isHeadless ifTrue: [^accept value].	self allButOpenFrom: aSpec.	builder openDialog.	^accept value</body></methods><methods><class-id>Core.ImageConfigurationSystem</class-id> <category>prerequisites</category><body package="Headless" selector="ensurePrerequisitesAreActive">ensurePrerequisitesAreActive	"This method is a bit of a cheat. We want to become active after windowing is activated in a headfull image, but in a headless we still want to run. So we cheat on the test as to whether all our prerequisites are active or not"	super ensurePrerequisitesAreActive ifTrue: [^true].	^HeadlessImage isActive.</body><body package="Headless" selector="ensurePrerequisitesAreResumed">ensurePrerequisitesAreResumed	"This method is a bit of a cheat. We want to become active after windowing is activated in a headfull image, but in a headless we still want to run. So we cheat on the test as to whether all our prerequisites are active or not"	super ensurePrerequisitesAreResumed ifTrue: [^true].	^HeadlessImage isActive.</body></methods><methods><class-id>Graphics.Image</class-id> <category>converting</category><body package="Headless" selector="convertForGraphicsDevice:">convertForGraphicsDevice: graphicsDevice	"Answer an image (possibly myself) representing my contents that	can be directly displayed on the specified graphics device (e.g.,	a Screen)."	| imageRenderer |	HeadlessScreen default == graphicsDevice ifTrue:[^self].	self paintBasis = ColorValue		ifTrue: [imageRenderer := graphicsDevice defaultColorPolicy imageRenderer]		ifFalse: [imageRenderer := graphicsDevice defaultCoveragePolicy imageRenderer].	^self convertForGraphicsDevice: graphicsDevice renderedBy: imageRenderer</body><body package="Headless" selector="convertForGraphicsDevice:renderedBy:paintTransfer:">convertForGraphicsDevice: graphicsDevice renderedBy: anImageRenderer paintTransfer: paintTransferBlockOrNil	"Answer an image (possibly myself) representing my contents that	can be directly displayed on the specified graphics device	(e.g., a Screen).  Use anImageRenderer to render the new	image. If paintTransferBlockOrNil is non-nil, it should be a	single-argument block used to transform each source paint in	my image before applying the rendering algorithm."	| newImage destPalette destDepth destBitsPerPixel |	HeadlessScreen default == graphicsDevice ifTrue:[^self].	self paintBasis = ColorValue		ifTrue:			[destPalette := graphicsDevice colorPalette.			destDepth := graphicsDevice colorDepth.			destBitsPerPixel := graphicsDevice colorBitsPerPixel]		ifFalse:			[destPalette := graphicsDevice coveragePalette.			destDepth := graphicsDevice coverageDepth.			destBitsPerPixel := graphicsDevice coverageBitsPerPixel].	destPalette == self palette ifTrue: [^self].	(self depth = destDepth and: [self bitsPerPixel = destBitsPerPixel and: [destPalette = self palette]]) ifTrue:		[^self palette: destPalette		"change palette so that == tests will work in future"].	newImage := Image extent: self extent depth: destDepth bitsPerPixel: destBitsPerPixel palette: destPalette.	anImageRenderer representImage: self as: newImage paintTransfer: paintTransferBlockOrNil.	^newImage</body></methods><methods><class-id>UI.WindowManager</class-id> <category>displaying</category><body package="Headless" selector="basicRestore">basicRestore	"Redisplay all of the scheduled views on the display screen."	| aPoint displayBox |	HeadlessImage default isHeadless ifTrue: [^self].	displayBox := Screen default bounds.	aPoint := displayBox origin.	windows		reverseDo: 			[:win | 			win refresh.			((win displayBox) intersects: displayBox)				ifFalse:					[(displayBox containsPoint: (aPoint := aPoint + (10@10)))						ifFalse: [aPoint := displayBox origin + 10 asPoint].					win moveTo: aPoint]].	self repairDamages.</body></methods><methods><class-id>Tools.Notifier class</class-id> <category>private</category><body package="Headless" selector="checkDump:label:">checkDump: aContext label: labelText	"Check if we should dump a stack trace to a file."	UHEFilename isNil ifTrue: [^self].	[| file |	 [file := UHEFilename asFilename newReadWriteStream.	  file cr; nextPutAll: 'DUMP:'; cr; nextPutAll: labelText; cr; cr.	  file nextPutAll: aContext printStack]			ensure: [file close]]		on: Object errorSignal		do: [:ex| ex return].	"UHEFilename := 'uhedump.txt'.	self checkDump: thisContext label: 'thisContext'.	UHEFilename := nil"</body></methods><methods><class-id>Tools.Notifier class</class-id> <category>instance creation</category><body package="Headless" selector="openContext:label:proceedable:">openContext: haltContext label: aString proceedable: aBoolean	"Forward the exception to the appropriate class."	| headlessImage |	headlessImage := HeadlessImage default.	^headlessImage isHeadless		ifTrue:			[headlessImage dumpStackToTranscript: haltContext.			self quitOnHeadlessError				ifTrue: [ObjectMemory quit]				ifFalse: [Processor activeProcess terminateWithExtremePrejudice]]		ifFalse:			[headlessImage isActivationInProcess ifTrue:				[self checkDump: haltContext label: aString].			current openContext: haltContext label: aString proceedable: aBoolean]</body><body package="Headless" selector="openException:">openException: anException	"Forward the exception to the appropriate class."	| headlessImage |	headlessImage := HeadlessImage default.	^headlessImage isHeadless		ifTrue:			[headlessImage dumpStackToTranscript: thisContext.			self quitOnHeadlessError				ifTrue: [ObjectMemory quit]				ifFalse: [Processor activeProcess terminateWithExtremePrejudice]]		ifFalse:			[headlessImage isActivationInProcess ifTrue:				[self checkDump: anException parameter label: anException errorString].			current openException: anException]</body></methods><methods><class-id>Tools.Notifier class</class-id> <category>accessing</category><body package="Headless" selector="quitOnHeadlessError">quitOnHeadlessError	^QuitOnHeadlessError</body><body package="Headless" selector="quitOnHeadlessError:">quitOnHeadlessError: aBoolean	QuitOnHeadlessError := aBoolean</body></methods><methods><class-id>Core.HeadlessImage</class-id> <category>command-line options</category><body package="Headless" selector="noStartupFile">noStartupFile	&lt;option: '-nohlstrc'&gt;	startupFilename := nil.</body><body package="Headless" selector="noTerminateOnErrorOption">noTerminateOnErrorOption	&lt;option: '-no-terminate-on-error'&gt;	self isTerminating: false.</body><body package="Headless" selector="terminateOnErrorOption">terminateOnErrorOption	&lt;option: '-terminate-on-error'&gt;	self isTerminating: true.</body></methods><methods><class-id>Graphics.BasicGraphicsSystem</class-id> <category>command-line options</category><body package="Headless" selector="headfull">headfull	"Allow setting headless/headfull from a command-line option, but only on real startup. If we're later setting up one of these systems, ignore the option."	&lt;option: '-headfull'&gt;	CacheFlushingSystem isActive ifFalse: [		HeadlessImage default isHeadless: false].</body><body package="Headless" selector="headless">headless	"Allow setting headless/headfull from a command-line option, but only on real startup. If we're later setting up one of these systems, ignore the option."	&lt;option: '-headless'&gt;	CacheFlushingSystem isActive ifFalse: [		HeadlessImage default isHeadless: true].</body></methods><methods><class-id>Graphics.WindowingSystem</class-id> <category>prerequisites</category><body package="Headless" selector="headlessPrerequisite">headlessPrerequisite	&lt;prerequisites&gt;	^Array with: HeadlessImage.</body></methods><methods><class-id>Core.ImageConfigurationSystem</class-id> <category>prerequisites</category><body package="Headless" selector="headlessPrerequisite">headlessPrerequisite	"Ensure that headless is activated"	&lt;prerequisites&gt;	^Array with: HeadlessImage.</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>actions</category><body package="Headless" selector="imageSaveHeadlessAs">imageSaveHeadlessAs	"Save a headless image under the name supplied by the user."	&lt;menuItem: #(#SaveHeadlessAsDot #menus 'Save Headless As...')		nameKey: nil		menu: #(#menuBar #file)		position: 10.015&gt;	| prefix |	prefix := Snapshot new getImagePrefix.	prefix isEmpty ifTrue: [^self].	HeadlessImage current saveHeadless: prefix.</body></methods><initialize><class-id>Graphics.HeadlessScreen</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Screen</name><environment>Graphics</environment><super>Graphics.HostGraphicsDevice</super><private>false</private><indexed-type>none</indexed-type><inst-vars>boundingBox subRegions resolution rendererName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>OS-Window System</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class><class><name>DictionaryInspector</name><environment>Tools.Trippy</environment><super>Tools.Trippy.PartListAbstractInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars>linearizedParts valueOrKeyHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><class><name>Image</name><environment>Graphics</environment><super>Graphics.PixelArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bits width height depth bitsPerPixel palette maxPixelValue rowByteSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Images</category><attributes><package>Graphics-Images</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector toolDock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>DictionaryInspector</name><environment>Tools</environment><super>Tools.Inspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Inspector</category><attributes><package>Tools-Inspector</package></attributes></class><class><name>Subsystem</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state canActivate </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>System-Subsystems</category><attributes><package>System-Subsystems</package></attributes></class><class><name>WindowingSystem</name><environment>Graphics</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>OS-Window System</package></attributes></class><class><name>ImageConfigurationSystem</name><environment>Core</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stdout </inst-vars><class-inst-vars>allowParcelLoading allowFilein allowSettings allowExpressions useDefaultConfigFile </class-inst-vars><imports></imports><category>System-Subsystems</category><attributes><package>System-Subsystems</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Process</name><environment>Kernel</environment><super>Core.Link</super><private>false</private><indexed-type>none</indexed-type><inst-vars>suspendedContext priority myList depth hostThreadKey interruptProtect environment isSystem name inDebug </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Processes</category><attributes><package>Kernel-Processes</package></attributes></class><class><name>TextCollector</name><environment>UI</environment><super>UI.ValueHolder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>entryStream characterLimit writeSequencer nextEntry autoFlush </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Support</category><attributes><package>Interface-Support</package></attributes></class><class><name>BasicGraphicsSystem</name><environment>Graphics</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>OS-Window System</package></attributes></class><class><name>SystemNotification</name><environment>Core</environment><super>Core.ControlInterrupt</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>WindowManager</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>windows activeController interruptLock outstandingMetaOrDamage openInProgress eventQueue baseProcess dontFilterEvents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class></st-source>