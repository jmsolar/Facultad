<?xml version="1.0"?><st-source><!-- Name: PNGImageReaderNotice: Copyright © 2004-1999 Cincom Systems, Inc.  All Rights Reserved.Comment: This parcel adds PNG Image Reading support for VisualWorksDbIdentifier: bear73DbTrace: 49788DevelopmentPrerequisites: #(#(#any 'Compression' ''))PackageName: PNGImageReaderParcel: #('PNGImageReader')PrerequisiteParcels: #(#('Compression' ''))PrintStringCache: (7.3 - 1.0,bobw)Version: 7.3Date: 3:12:00 pm November 22, 2004 --><time-stamp>From VisualWorks®, 7.3 of November 22, 2004 on November 22, 2004 at 3:12:00 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>PNGImageReader</name><environment>Graphics</environment><super>Graphics.ImageReader</super><private>false</private><indexed-type>none</indexed-type><inst-vars>chunk depth bitsPerChannel colorType interlaceMethod bytesPerScanline thisScanline prevScanline rowSize globalDataChunk unknownChunks transparentPixelValue filtersSeen </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Images</category><attributes><package>PNGImageReader</package></attributes></class><comment><class-id>Graphics.PNGImageReader</class-id><body>I am a subclass of ImageReader that decodes Portable Network Graphics (PNG) images.This image reader properly reads (or properly fails to read) 148 of the 158 images in the PNG Image suite (avalable at: ftp://swrinde.nde.swri.edu/pub/png/images/suite/PngSuite.zip)The images it fails on are as follows:Image Name			Description											Failure=========			========											=======x00n0g01.png 		0x0 image 											We seem to think a 0x0 image is ok, 																				but the PNG suite says we should reject itpp0n0g08.png		six-cube palette-chunk in grayscale image		Fails to display (VW thinks it is an invalid display format)pp0n2c16.png		six-cube palette-chunk in true-color image		Fails to display (VW thinks it is an invalid display format)tbbn1g04.png		transparent, black background chunk			Wrong background colors01i3p01.png		1x1 paletted file, interlaced						Unable to display 1x1 images02i3p01.png		2x2 paletted file, interlaced						Unable to display 2x2 images01n3p01.png		1x1 paletted file, interlaced						Unable to display 1x1 images02n3p01.png		2x2 paletted file, interlaced						Unable to display 2x2 imageInstance Variables:	bitsPerChannel			&lt;Integer&gt;	 The number of bits used in each color channel	bytesPerScanline		&lt;Integer&gt;	The number of bytes in a packedRow scan line	chunk						&lt;SequenceableCollection&gt;	The current working piece of the stream from the image	colorType				&lt;Integer&gt;	PNG code for color type	depth						&lt;SmallInteger&gt;	Bit depth of the image	filtersSeen				&lt;Collection&gt;	Helpful debugging variable that notes which PNG filters were seen in the image.	globalDataChunk		&lt;SequenceableCollection&gt;	When finally getting to the body of the image, this holds the whole untranslated image bytes.	interlaceMethod			&lt;1 | 0&gt;	If 0, then non interlaced, otherwise, interlaced	prevScanline				&lt;(ByteArray of: (Integer))&gt;	When looking up above and above left colors for certain filters, we need to keep around the previous scan line.	rowSize					&lt;Integer&gt;	 Calculated scanline row size	thisScanline				&lt;(ByteArray of: Integer)&gt;	The uncompressed byte array representing the an image scan line.	transparentPixelValue	&lt;Integer&gt;	When using transparancy, this holds the value of the transparency color value.	unknownChunks			&lt;Collection&gt;	We ignore some chunks... after reading, they are held onto here.Below is a set of do-its for testing the image reader with the PNG Image Suite.(ImageReader fromFile: 'png\basn0g01.png') image inspect.(ImageReader fromFile: 'png\basn0g02.png') image inspect.(ImageReader fromFile: 'png\basn0g04.png') image inspect.(ImageReader fromFile: 'png\basn0g08.png') image inspect.(ImageReader fromFile: 'png\basn0g16.png') image inspect.(ImageReader fromFile: 'png\basn2c08.png') image inspect.(ImageReader fromFile: 'png\basn2c16.png') image inspect.(ImageReader fromFile: 'png\basn3p01.png') image inspect.(ImageReader fromFile: 'png\basn3p02.png') image inspect.(ImageReader fromFile: 'png\basn3p04.png') image inspect.(ImageReader fromFile: 'png\basn3p08.png') image inspect.(ImageReader fromFile: 'png\basn4a08.png') image inspect.(ImageReader fromFile: 'png\basn4a16.png') image inspect.(ImageReader fromFile: 'png\basn6a08.png') image inspect.(ImageReader fromFile: 'png\basn6a16.png') image inspect.(ImageReader fromFile: 'png\basi0g01.png') image inspect.(ImageReader fromFile: 'png\basi0g02.png') image inspect.(ImageReader fromFile: 'png\basi0g04.png') image inspect.(ImageReader fromFile: 'png\basi0g08.png') image inspect.(ImageReader fromFile: 'png\basi0g16.png') image inspect.(ImageReader fromFile: 'png\basi2c08.png') image inspect.(ImageReader fromFile: 'png\basi2c16.png') image inspect.(ImageReader fromFile: 'png\basi3p01.png') image inspect.(ImageReader fromFile: 'png\basi3p02.png') image inspect.(ImageReader fromFile: 'png\basi3p04.png') image inspect.(ImageReader fromFile: 'png\basi3p08.png') image inspect.(ImageReader fromFile: 'png\basi4a08.png') image inspect.(ImageReader fromFile: 'png\basi4a16.png') image inspect.(ImageReader fromFile: 'png\basi6a08.png') image inspect.(ImageReader fromFile: 'png\basi6a16.png') image inspect.(ImageReader fromFile: 'png\s01n3p01.png') image inspect. "Unable to display"(ImageReader fromFile: 'png\s02n3p01.png') image inspect. "Unable to display"(ImageReader fromFile: 'png\s03n3p01.png') image inspect.(ImageReader fromFile: 'png\s04n3p01.png') image inspect.(ImageReader fromFile: 'png\s05n3p02.png') image inspect.(ImageReader fromFile: 'png\s06n3p02.png') image inspect.(ImageReader fromFile: 'png\s07n3p02.png') image inspect.(ImageReader fromFile: 'png\s08n3p02.png') image inspect.(ImageReader fromFile: 'png\s09n3p02.png') image inspect.(ImageReader fromFile: 'png\s32n3p04.png') image inspect.(ImageReader fromFile: 'png\s33n3p04.png') image inspect.(ImageReader fromFile: 'png\s34n3p04.png') image inspect.(ImageReader fromFile: 'png\s35n3p04.png') image inspect.(ImageReader fromFile: 'png\s36n3p04.png') image inspect.(ImageReader fromFile: 'png\s37n3p04.png') image inspect.(ImageReader fromFile: 'png\s38n3p04.png') image inspect.(ImageReader fromFile: 'png\s39n3p04.png') image inspect.(ImageReader fromFile: 'png\s40n3p04.png') image inspect.(ImageReader fromFile: 'png\s01i3p01.png') image inspect. "Unable to display"(ImageReader fromFile: 'png\s02i3p01.png') image inspect. "Unable to display"(ImageReader fromFile: 'png\s03i3p01.png') image inspect.(ImageReader fromFile: 'png\s04i3p01.png') image inspect.(ImageReader fromFile: 'png\s05i3p02.png') image inspect.(ImageReader fromFile: 'png\s06i3p02.png') image inspect.(ImageReader fromFile: 'png\s07i3p02.png') image inspect.(ImageReader fromFile: 'png\s08i3p02.png') image inspect.(ImageReader fromFile: 'png\s09i3p02.png') image inspect.(ImageReader fromFile: 'png\s32i3p04.png') image inspect.(ImageReader fromFile: 'png\s33i3p04.png') image inspect.(ImageReader fromFile: 'png\s34i3p04.png') image inspect.(ImageReader fromFile: 'png\s35i3p04.png') image inspect.(ImageReader fromFile: 'png\s36i3p04.png') image inspect.(ImageReader fromFile: 'png\s37i3p04.png') image inspect.(ImageReader fromFile: 'png\s38i3p04.png') image inspect.(ImageReader fromFile: 'png\s39i3p04.png') image inspect.(ImageReader fromFile: 'png\s40i3p04.png') image inspect.(ImageReader fromFile: 'png\bgai4a08.png') image inspect.(ImageReader fromFile: 'png\bgai4a16.png') image inspect.(ImageReader fromFile: 'png\bgan6a08.png') image inspect.(ImageReader fromFile: 'png\bgan6a16.png') image inspect.(ImageReader fromFile: 'png\bgbn4a08.png') image inspect.(ImageReader fromFile: 'png\bggn4a16.png') image inspect.(ImageReader fromFile: 'png\bgwn6a08.png') image inspect.(ImageReader fromFile: 'png\bgyn6a16.png') image inspect.(ImageReader fromFile: 'png\tp0n1g08.png') image inspect.(ImageReader fromFile: 'png\tbbn1g04.png') image inspect. "(Poorly-Background incorrect)"(ImageReader fromFile: 'png\tbwn1g16.png') image inspect.(ImageReader fromFile: 'png\tp0n2c08.png') image inspect.(ImageReader fromFile: 'png\tbrn2c08.png') image inspect.(ImageReader fromFile: 'png\tbgn2c16.png') image inspect.(ImageReader fromFile: 'png\tbbn2c16.png') image inspect.(ImageReader fromFile: 'png\tp0n3p08.png') image inspect.(ImageReader fromFile: 'png\tp1n3p08.png') image inspect.(ImageReader fromFile: 'png\tbbn3p08.png') image inspect.(ImageReader fromFile: 'png\tbgn3p08.png') image inspect.(ImageReader fromFile: 'png\tbwn3p08.png') image inspect.(ImageReader fromFile: 'png\tbyn3p08.png') image inspect.(ImageReader fromFile: 'png\g03n0g16.png') image inspect.(ImageReader fromFile: 'png\g04n0g16.png') image inspect.(ImageReader fromFile: 'png\g05n0g16.png') image inspect.(ImageReader fromFile: 'png\g07n0g16.png') image inspect.(ImageReader fromFile: 'png\g10n0g16.png') image inspect.(ImageReader fromFile: 'png\g25n0g16.png') image inspect.(ImageReader fromFile: 'png\g03n2c08.png') image inspect.(ImageReader fromFile: 'png\g04n2c08.png') image inspect.(ImageReader fromFile: 'png\g05n2c08.png') image inspect.(ImageReader fromFile: 'png\g07n2c08.png') image inspect.(ImageReader fromFile: 'png\g10n2c08.png') image inspect.(ImageReader fromFile: 'png\g25n2c08.png') image inspect.(ImageReader fromFile: 'png\g03n3p04.png') image inspect.(ImageReader fromFile: 'png\g04n3p04.png') image inspect.(ImageReader fromFile: 'png\g05n3p04.png') image inspect.(ImageReader fromFile: 'png\g07n3p04.png') image inspect.(ImageReader fromFile: 'png\g10n3p04.png') image inspect.(ImageReader fromFile: 'png\g25n3p04.png') image inspect.(ImageReader fromFile: 'png\f00n0g08.png') image inspect.(ImageReader fromFile: 'png\f01n0g08.png') image inspect.(ImageReader fromFile: 'png\f02n0g08.png') image inspect.(ImageReader fromFile: 'png\f03n0g08.png') image inspect.(ImageReader fromFile: 'png\f04n0g08.png') image inspect.(ImageReader fromFile: 'png\f00n2c08.png') image inspect.(ImageReader fromFile: 'png\f01n2c08.png') image inspect.(ImageReader fromFile: 'png\f02n2c08.png') image inspect.(ImageReader fromFile: 'png\f03n2c08.png') image inspect.(ImageReader fromFile: 'png\f04n2c08.png') image inspect.(ImageReader fromFile: 'png\pp0n0g08.png') image inspect. "fail"(ImageReader fromFile: 'png\pp0n2c16.png') image inspect. "fail"(ImageReader fromFile: 'png\ps1n0g08.png') image inspect.(ImageReader fromFile: 'png\ps1n2c16.png') image inspect.(ImageReader fromFile: 'png\ps2n0g08.png') image inspect.(ImageReader fromFile: 'png\ps2n2c16.png') image inspect.(ImageReader fromFile: 'png\cs5n2c08.png') image inspect.(ImageReader fromFile: 'png\cs8n2c08.png') image inspect.(ImageReader fromFile: 'png\cs3n2c16.png') image inspect.(ImageReader fromFile: 'png\cs3n3p08.png') image inspect.(ImageReader fromFile: 'png\cs5n3p08.png') image inspect.(ImageReader fromFile: 'png\cs8n3p08.png') image inspect.(ImageReader fromFile: 'png\cdfn2c08.png') image inspect.(ImageReader fromFile: 'png\cdhn2c08.png') image inspect.(ImageReader fromFile: 'png\cdsn2c08.png') image inspect.(ImageReader fromFile: 'png\cdun2c08.png') image inspect.(ImageReader fromFile: 'png\ccwn2c08.png') image inspect.(ImageReader fromFile: 'png\ccwn3p08.png') image inspect.(ImageReader fromFile: 'png\ch1n3p04.png') image inspect.(ImageReader fromFile: 'png\ch2n3p08.png') image inspect.(ImageReader fromFile: 'png\cm7n0g04.png') image inspect.(ImageReader fromFile: 'png\cm9n0g04.png') image inspect.(ImageReader fromFile: 'png\cm0n0g04.png') image inspect.(ImageReader fromFile: 'png\ct0n0g04.png') image inspect.(ImageReader fromFile: 'png\ct1n0g04.png') image inspect.(ImageReader fromFile: 'png\ctzn0g04.png') image inspect.(ImageReader fromFile: 'png\oi1n0g16.png') image inspect.(ImageReader fromFile: 'png\oi2n0g16.png') image inspect.(ImageReader fromFile: 'png\oi4n0g16.png') image inspect.(ImageReader fromFile: 'png\oi9n0g16.png') image inspect.(ImageReader fromFile: 'png\oi1n2c16.png') image inspect.(ImageReader fromFile: 'png\oi2n2c16.png') image inspect.(ImageReader fromFile: 'png\oi4n2c16.png') image inspect.(ImageReader fromFile: 'png\oi9n2c16.png') image inspect.(ImageReader fromFile: 'png\z00n2c08.png') image inspect.(ImageReader fromFile: 'png\z03n2c08.png') image inspect.(ImageReader fromFile: 'png\z06n2c08.png') image inspect.(ImageReader fromFile: 'png\z09n2c08.png') image inspect.(ImageReader fromFile: 'png\x00n0g01.png') image inspect. "Doesn't fail, but should"(ImageReader fromFile: 'png\xcrn0g04.png') image inspect. "Properly Fails"(ImageReader fromFile: 'png\xlfn0g04.png') image inspect. "Properly Fails"</body></comment><shared-variable><name>BlockHeight</name><environment>Graphics.PNGImageReader</environment><private>false</private><constant>false</constant><category>PNGImageReader</category><attributes><package>PNGImageReader</package></attributes></shared-variable><shared-variable><name>BPP</name><environment>Graphics.PNGImageReader</environment><private>false</private><constant>false</constant><category>PNGImageReader</category><attributes><package>PNGImageReader</package></attributes></shared-variable><shared-variable><name>BlockWidth</name><environment>Graphics.PNGImageReader</environment><private>false</private><constant>false</constant><category>PNGImageReader</category><attributes><package>PNGImageReader</package></attributes></shared-variable><methods><class-id>Graphics.PNGImageReader</class-id> <category>pixel copies</category><body package="PNGImageReader" selector="copyPixels:">copyPixels: y 	"Handle non-interlaced pixels of supported colorTypes"	| selector |	selector := #(#copyPixelsGray: nil 			#copyPixelsRGB: 			#copyPixelsIndexed: 			#copyPixelsGrayAlpha: nil 			#copyPixelsRGBA:) at: colorType + 1.	self perform: selector asSymbol with: y</body><body package="PNGImageReader" selector="copyPixels:at:by:">copyPixels: y at: startX by: incX 	"Handle interlaced pixels of supported colorTypes"	| selector |	selector := #(#copyPixelsGray:at:by: nil 				#copyPixelsRGB:at:by: 				#copyPixelsIndexed:at:by: 				#copyPixelsGrayAlpha:at:by: nil 				#copyPixelsRGBA:at:by:) at: colorType + 1.	self 		perform: selector asSymbol		with: y		with: startX		with: incX</body><body package="PNGImageReader" selector="copyPixelsGray:">copyPixelsGray: y 	"Handle non-interlaced grayscale color mode (colorType = 0)"	| tempImage pixPerByte mask shifts pixelNumber rawByte pixel transparentIndex |	tempImage := Image extent: width @ 1 depth: depth palette: palette.	transparentIndex := palette colors size - 1.	bitsPerChannel = 16 ifTrue: [0 to: width - 1 do: [:x | tempImage atPoint: x @ 0 put: (thisScanline at: (x &lt;&lt; 1) + 1)]].	bitsPerChannel = 8 ifTrue: [1 to: width do: [:x | tempImage atPoint: (x - 1) @ 0 put: (thisScanline at: x)]].	bitsPerChannel &lt; 8 ifTrue: 		[bitsPerChannel = 1 ifTrue: 			[pixPerByte := 8.			mask := 1.			shifts := #(7 6 5 4 3 2 1 0)].		bitsPerChannel = 2 ifTrue: 			[pixPerByte := 4.			mask := 3.			shifts := #(6 4 2 0)].		bitsPerChannel = 4 ifTrue: 			[pixPerByte := 2.			mask := 15.			shifts := #(4 0)].		pixelNumber := 0.		0 to: width - 1 do: 			[:index | 			rawByte := thisScanline at: pixelNumber // pixPerByte + 1.			pixel := rawByte &gt;&gt; (shifts at: pixelNumber \\ pixPerByte + 1) bitAnd: mask.			pixel = transparentPixelValue ifTrue: [pixel := transparentIndex].			tempImage atPoint: index @ 0 put: pixel.			pixelNumber := pixelNumber + 1]].	image 		copy: (0 @ y extent: width @ 1)		from: 0 @ 0		in: tempImage		rule: RasterOp over</body><body package="PNGImageReader" selector="copyPixelsGray:at:by:">copyPixelsGray: y at: startX by: incX 	"Handle interlaced grayscale color mode (colorType = 0)"	| pixel mask pixelNumber pixPerByte rawByte shifts tempImage |	tempImage := Image extent: width @ 1 depth: depth palette: palette.	bitsPerChannel = 16 ifTrue: 		[startX to: width - 1 by: incX do: 			[:index | 			tempImage atPoint: index @ 0 put: (thisScanline at: (index // incX &lt;&lt; 1) + 1)]].	bitsPerChannel = 8 ifTrue: 		[startX to: width - 1 by: incX do: 			[:index | 			tempImage atPoint: index @ 0 put: (thisScanline at: index // incX + 1)]].	bitsPerChannel &lt; 8 ifTrue: 			[bitsPerChannel = 1 ifTrue: 			[pixPerByte := 8.			mask := 1.			shifts := #(7 6 5 4 3 2 1 0)].		bitsPerChannel = 2 ifTrue: 			[pixPerByte := 4.			mask := 3.			shifts := #(6 4 2 0)].		bitsPerChannel = 4 ifTrue: 			[pixPerByte := 2.			mask := 15.			shifts := #(4 0)].		pixelNumber := 0.		startX to: width - 1 by: incX do: 			[:x | 			rawByte := thisScanline at: pixelNumber // pixPerByte + 1.			pixel := rawByte &gt;&gt; (shifts at: pixelNumber \\ pixPerByte + 1) bitAnd: mask.			tempImage atPoint: x @ 0 put: pixel.			pixelNumber := pixelNumber + 1]].	image 		copy: (0 @ y extent: width @ 1)		from: 0 @ 0		in: tempImage		rule: RasterOp paint</body><body package="PNGImageReader" selector="copyPixelsGrayAlpha:">copyPixelsGrayAlpha: y 	"Handle non-interlaced grayscale with alpha color mode (colorType = 4)"	| scanlineIndex pixel gray tempImage |	tempImage := Image extent: width @ 1 depth: depth palette: palette.	bitsPerChannel = 8 		ifTrue: 			[0 to: width - 1 do: 				[:index | 				scanlineIndex := (index &lt;&lt; 1) + 1.				gray := thisScanline at: scanlineIndex.				pixel := ((thisScanline at: scanlineIndex + 1) &lt;&lt; 24) + (gray &lt;&lt; 16) + (gray &lt;&lt; 8) + gray.				tempImage atPoint: index @ 0 put: pixel]]		ifFalse: 			[0 to: width - 1 do: 				[:index | 				scanlineIndex := (index &lt;&lt; 2) + 1.				gray := thisScanline at: scanlineIndex.				pixel := ((thisScanline at: scanlineIndex + 2) &lt;&lt; 24) + (gray &lt;&lt; 16) + (gray &lt;&lt; 8) + gray.				tempImage atPoint: index @ 0 put: pixel]].	image 		copy: (0 @ y extent: width @ 1)		from: 0 @ 0		in: tempImage		rule: RasterOp over</body><body package="PNGImageReader" selector="copyPixelsGrayAlpha:at:by:">copyPixelsGrayAlpha: y at: startX by: incX 	"Handle interlaced grayscale with alpha color mode (colorType = 4)"	| scanlineIndex pixel gray tempImage |	tempImage := Image extent: width @ 1 depth: depth palette: palette.	bitsPerChannel = 8 		ifTrue: 			[startX to: width - 1 by: incX do: 				[:index | 				scanlineIndex := (index // incX &lt;&lt; 1) + 1.				gray := thisScanline at: scanlineIndex.				pixel := ((thisScanline at: scanlineIndex + 1) &lt;&lt; 24) + (gray &lt;&lt; 16) + (gray &lt;&lt; 8) + gray.				tempImage atPoint: index @ 0 put: pixel]]		ifFalse: 			[startX to: width - 1 by: incX do: 				[:index | 				scanlineIndex := (index // incX &lt;&lt; 2) + 1.				gray := thisScanline at: scanlineIndex.				pixel := ((thisScanline at: scanlineIndex + 2) &lt;&lt; 24) + (gray &lt;&lt; 16) + (gray &lt;&lt; 8) + gray.				tempImage atPoint: index @ 0 put: pixel]].	image 		copy: (0 @ y extent: width @ 1)		from: 0 @ 0		in: tempImage		rule: RasterOp paint</body><body package="PNGImageReader" selector="copyPixelsIndexed:">copyPixelsIndexed: y 	"Handle non-interlaced indexed color mode (colorType = 3)"	| tempImage pixPerByte mask shifts pixelNumber rawByte pixel |	tempImage := Image extent: width @ 1 depth: depth palette: palette.	bitsPerChannel = 8 ifTrue: 		[1 to: width do: [:index | tempImage atPoint: (index - 1) @ 0 put: (thisScanline at: index)]].	bitsPerChannel = 1 ifTrue: 		[pixPerByte := 8.		mask := 1.		shifts := #(7 6 5 4 3 2 1 0)].	bitsPerChannel = 2 ifTrue: 		[pixPerByte := 4.		mask := 3.		shifts := #(6 4 2 0)].	bitsPerChannel = 4 ifTrue: 		[pixPerByte := 2.		mask := 15.		shifts := #(4 0)].	bitsPerChannel = 8 ifFalse: 		[pixelNumber := 0.		0 to: width - 1 do: 			[:index | 			rawByte := thisScanline at: pixelNumber // pixPerByte + 1.			pixel := rawByte &gt;&gt; (shifts at: pixelNumber \\ pixPerByte + 1) bitAnd: mask.			tempImage atPoint: index @ 0 put: pixel.			pixelNumber := pixelNumber + 1]].	image 		copy: (0 @ y extent: width @ 1)		from: 0 @ 0		in: tempImage		rule: RasterOp over</body><body package="PNGImageReader" selector="copyPixelsIndexed:at:by:">copyPixelsIndexed: y at: startX by: incX 	"Handle interlaced indexed color mode (colorType = 3)"	| pixPerByte shifts tempImage mask |	tempImage := Image extent: width @ 1 depth: depth palette: palette.	bitsPerChannel = 8 ifTrue: 		[startX to: width - 1 by: incX do: 			[:index | 			tempImage atPoint: index @ 0 put: (thisScanline at: index // incX + 1)]].	bitsPerChannel = 1 ifTrue: 			[pixPerByte := 8.			mask := 1.			shifts := #(7 6 5 4 3 2 1 0)].	bitsPerChannel = 2 ifTrue: 			[pixPerByte := 4.			mask := 3.			shifts := #(6 4 2 0)].	bitsPerChannel = 4 ifTrue: 			[pixPerByte := 2.			mask := 15.			shifts := #(4 0)].	bitsPerChannel = 8 ifFalse: 			[ | pixelNumber |			pixelNumber := 0.			startX to: width - 1 by: incX				do: 					[:index | | rawByte pixel  |					rawByte := thisScanline at: pixelNumber // pixPerByte + 1.					pixel := rawByte &gt;&gt; (shifts at: pixelNumber \\ pixPerByte + 1) bitAnd: mask.					tempImage atPoint: index @ 0 put: pixel.					pixelNumber := pixelNumber + 1]].	image 		copy: (0 @ y extent: width @ 1)		from: 0 @ 0		in: tempImage		rule: RasterOp paint</body><body package="PNGImageReader" selector="copyPixelsRGB:">copyPixelsRGB: y 	"Handle non-interlaced RGB color mode (colorType = 2)"	| tempImage translatedScan scanIndex |	translatedScan := ByteArray new: image packedRowSize.	tempImage := Image extent: width @ 1 depth: 32 palette: palette.	scanIndex := 1.	bitsPerChannel = 8 		ifTrue: 			[1 to: image packedRowSize by: 4 do: 				[:index | 				translatedScan at: index + 0 put: 0.				translatedScan at: index + 1 put: (thisScanline at: scanIndex + 2).				translatedScan at: index + 2 put: (thisScanline at: scanIndex + 1).				translatedScan at: index + 3 put: (thisScanline at: scanIndex + 0).				scanIndex := scanIndex + 3]]		ifFalse: 			[1 to: image packedRowSize by: 4 do: 				[:index | 				translatedScan at: index + 0 put: 0.				translatedScan at: index + 1 put: (thisScanline at: scanIndex + 4).				translatedScan at: index + 2 put: (thisScanline at: scanIndex + 2).				translatedScan at: index + 3 put: (thisScanline at: scanIndex + 0).				scanIndex := scanIndex + 6]].	tempImage packedRowAt: 0 putAll: translatedScan.	image 		copy: (0 @ y extent: width @ 1)		from: 0 @ 0		in: tempImage		rule: RasterOp over</body><body package="PNGImageReader" selector="copyPixelsRGB:at:by:">copyPixelsRGB: y at: startX by: incX 	"Handle interlaced RGB color mode (colorType = 2)"	| translatedScan loopsToDo scanlineIndex translatedIndex tempImage |	translatedScan := ByteArray new: image packedRowSize.	tempImage := Image extent: width @ 1 depth: 32 palette: palette.	loopsToDo := width - startX + incX - 1 // incX.	bitsPerChannel = 8 ifTrue: [		scanlineIndex := 1.		translatedIndex := 1.		loopsToDo timesRepeat: 			[incX timesRepeat:				[translatedIndex &gt; translatedScan size ifFalse: 					[translatedScan at: translatedIndex + 0 put: 0.					translatedScan at: translatedIndex + 1 put: (thisScanline at: scanlineIndex + 2).					translatedScan at: translatedIndex + 2 put: (thisScanline at: scanlineIndex + 1).					translatedScan at: translatedIndex + 3 put: (thisScanline at: scanlineIndex + 0)].					translatedIndex := translatedIndex + 4].				scanlineIndex := scanlineIndex + 3]].	bitsPerChannel = 8 ifFalse: [		scanlineIndex := 1.		translatedIndex := 1.		loopsToDo timesRepeat: 			[incX timesRepeat:				[translatedIndex &gt; translatedScan size ifFalse: 					[translatedScan at: translatedIndex + 0 put: 0.					translatedScan at: translatedIndex + 1 put: (thisScanline at: scanlineIndex + 4).					translatedScan at: translatedIndex + 2 put: (thisScanline at: scanlineIndex + 2).					translatedScan at: translatedIndex + 3 put: (thisScanline at: scanlineIndex + 0)].					translatedIndex := translatedIndex + 4].				scanlineIndex := scanlineIndex + 6]].	tempImage packedRowAt: 0 putAll: translatedScan.	image 		copy: (0 @ y extent: width @ 1)		from: 0 @ 0		in: tempImage		rule: RasterOp paint</body><body package="PNGImageReader" selector="copyPixelsRGBA:">copyPixelsRGBA: y 	"Handle non-interlaced RGBA color modes (colorType = 6)"	| tempImage translatedScan |	translatedScan := ByteArray new: thisScanline size.	tempImage := Image extent: width @ 1 depth: 32 palette: self class defaultPalette.	bitsPerChannel = 8 		ifTrue: 			[1 to: thisScanline size by: 4 do: 				[:index | 				translatedScan at: index + 0 put: (thisScanline at: index + 3).				translatedScan at: index + 1 put: (thisScanline at: index + 2).				translatedScan at: index + 2 put: (thisScanline at: index + 1).				translatedScan at: index + 3 put: (thisScanline at: index + 0)]]		ifFalse:			[ | scanlineIndex |			scanlineIndex := 1.			1 to: thisScanline size // 2 by: 4 do: 				[:index | 				translatedScan at: index + 0 put: (thisScanline at: scanlineIndex + 6).				translatedScan at: index + 1 put: (thisScanline at: scanlineIndex + 4).				translatedScan at: index + 2 put: (thisScanline at: scanlineIndex + 2).				translatedScan at: index + 3 put: (thisScanline at: scanlineIndex + 0).				scanlineIndex := scanlineIndex + 8]] .	tempImage packedRowAt: 0 putAll: translatedScan.	image 		copy: (0 @ y extent: width @ 1)		from: 0 @ 0		in: tempImage		rule: RasterOp over</body><body package="PNGImageReader" selector="copyPixelsRGBA:at:by:">copyPixelsRGBA: y at: startX by: incX 	"Handle interlaced RGBA color modes (colorType = 6)"	| tempImage translatedScan loopsToDo scanlineIndex translatedIndex |	translatedScan := ByteArray new: image packedRowSize.	tempImage := Image extent: width @ 1 depth: 32 palette: self class defaultPalette.	loopsToDo := width - startX + incX - 1 // incX.	scanlineIndex := translatedIndex := 1.	bitsPerChannel = 8 ifTrue: [		loopsToDo timesRepeat: 			[incX timesRepeat:				[translatedIndex &gt; translatedScan size ifFalse: 					[translatedScan at: translatedIndex + 0 put: (thisScanline at: scanlineIndex + 3).					translatedScan at: translatedIndex + 1 put: (thisScanline at: scanlineIndex + 2).					translatedScan at: translatedIndex + 2 put: (thisScanline at: scanlineIndex + 1).					translatedScan at: translatedIndex + 3 put: (thisScanline at: scanlineIndex + 0)].					translatedIndex := translatedIndex + 4].				scanlineIndex := scanlineIndex + 4]].	bitsPerChannel = 8 ifFalse: [		loopsToDo timesRepeat: 			[incX timesRepeat:				[translatedIndex &gt; translatedScan size ifFalse: 					[translatedScan at: translatedIndex + 0 put: (thisScanline at: scanlineIndex + 6).					translatedScan at: translatedIndex + 1 put: (thisScanline at: scanlineIndex + 4).					translatedScan at: translatedIndex + 2 put: (thisScanline at: scanlineIndex + 2).					translatedScan at: translatedIndex + 3 put: (thisScanline at: scanlineIndex + 0)].					translatedIndex := translatedIndex + 4].				scanlineIndex := scanlineIndex + 8]].	tempImage packedRowAt: 0 putAll: translatedScan.	image 		copy: (0 @ y extent: width @ 1)		from: 0 @ 0		in: tempImage		rule: RasterOp paint</body></methods><methods><class-id>Graphics.PNGImageReader</class-id> <category>miscellaneous</category><body package="PNGImageReader" selector="doPass:">doPass: pass 	"Certain interlace passes are skipped with certain small image dimensions"	pass = 1 ifTrue: [^true].	(width = 1 and: [height = 1]) ifTrue: [^false].	pass = 2 ifTrue: [^width &gt;= 5].	pass = 3 ifTrue: [^height &gt;= 5].	pass = 4 ifTrue: [^width &gt;= 3 or: [height &gt;= 5]].	pass = 5 ifTrue: [^height &gt;= 3].	pass = 6 ifTrue: [^width &gt;= 2].	pass = 7 ifTrue: [^height &gt;= 2].	^false</body><body package="PNGImageReader" selector="grayColorsFor:">grayColorsFor: monoDepth 	"return a color palette for a gray image"	| colorArray |	colorArray := Array new: 1 &lt;&lt; monoDepth.	monoDepth = 1 ifTrue: 		[colorArray at: 1 put: ColorValue black.		colorArray at: 2 put: ColorValue white].	monoDepth = 2 ifTrue: 		[colorArray at: 1 put: ColorValue black.		colorArray at: 2 put: (ColorValue brightness: 0.3333).		colorArray at: 3 put: (ColorValue brightness: 0.6667).		colorArray at: 4 put: ColorValue white].	monoDepth = 4 ifTrue: 		[0 to: 15 do: 			[:index | 			colorArray at: index + 1 put: (ColorValue brightness: (index / 15) asFloat)]].	monoDepth = 8 ifTrue: 		[0 to: 255 do: 			[:index | 			colorArray at: index + 1 put: (ColorValue brightness: (index / 255) asFloat)]].	^palette := MappedPalette withColors: colorArray</body><body package="PNGImageReader" selector="nextLong">nextLong	"Read a 32-bit quantity from the input stream."	^(ioStream next bitShift: 24) + (ioStream next bitShift: 16) + (ioStream next bitShift: 8) + ioStream next</body></methods><methods><class-id>Graphics.PNGImageReader</class-id> <category>filtering</category><body package="PNGImageReader" selector="filterAverage:">filterAverage: count 	"Use the average of the pixel to the left and the pixel above as a predictor"	| delta |	delta := bitsPerPixel // 8 max: 1.	1 to: delta do: 		[:index | 		thisScanline at: index put: ((thisScanline at: index) + ((prevScanline at: index) // 2) bitAnd: 255)].	delta + 1 to: count do: 		[:index | 		thisScanline at: index put: ((thisScanline at: index) + (((prevScanline at: index) + (thisScanline at: index - delta)) // 2) bitAnd: 255)]</body><body package="PNGImageReader" selector="filterHorizontal:">filterHorizontal: count 	"Use the pixel to the left as a predictor"	| delta |	delta := bitsPerPixel // 8 max: 1.	delta + 1 to: count do: 		[:index | 		thisScanline at: index put: ((thisScanline at: index) + (thisScanline at: index - delta) bitAnd: 255)]</body><body package="PNGImageReader" selector="filterNone:">filterNone: count</body><body package="PNGImageReader" selector="filterPaeth:">filterPaeth: count 	"Select one of (the pixel to the left, the pixel above and the pixel to above left) to	predict the value of this pixel"	| delta |	delta := bitsPerPixel // 8 max: 1.	1 to: delta do: 		[:index | 		thisScanline at: index put: ((thisScanline at: index) + (prevScanline at: index) bitAnd: 255)].	delta + 1 to: count do: 		[:index | 		thisScanline 			at: index			put: ((thisScanline at: index) + 				(self paethPredictLeft: (thisScanline at: index - delta) above: (prevScanline at: index) aboveLeft: (prevScanline at: index - delta)) bitAnd: 255)]</body><body package="PNGImageReader" selector="filterScanline:count:">filterScanline: filterType count: count 	self 		perform: (#(#filterNone: #filterHorizontal: #filterVertical: #filterAverage: #filterPaeth:) at: filterType + 1) 		with: count</body><body package="PNGImageReader" selector="filterVertical:">filterVertical: count 	"Use the pixel above as a predictor"	1 to: count do: 		[:index | 		thisScanline at: index put: ((thisScanline at: index) + (prevScanline at: index) bitAnd: 255)]</body><body package="PNGImageReader" selector="paethPredictLeft:above:aboveLeft:">paethPredictLeft: leftValue above: aboveValue aboveLeft: aboveLeftValue 	"Predicts the value of a pixel based on nearby pixels, based on Paeth (GG II, 1991)"	| predictedLeft predictedAbove predictedAboveLeft |	predictedLeft := aboveValue &gt; aboveLeftValue ifTrue: [aboveValue - aboveLeftValue] ifFalse: [aboveLeftValue - aboveValue].	predictedAbove := leftValue &gt; aboveLeftValue ifTrue: [leftValue - aboveLeftValue] ifFalse: [aboveLeftValue - leftValue].	predictedAboveLeft := leftValue + aboveValue - aboveLeftValue - aboveLeftValue.	predictedAboveLeft &lt; 0 ifTrue: [predictedAboveLeft := predictedAboveLeft * -1].	(predictedLeft &lt;= predictedAbove and: [predictedLeft &lt;= predictedAboveLeft]) ifTrue: [^leftValue].	predictedAbove &lt;= predictedAboveLeft ifTrue: [^aboveValue].	^aboveLeftValue</body></methods><methods><class-id>Graphics.PNGImageReader</class-id> <category>accessing</category><body package="PNGImageReader" selector="format">format	^'Portable Network Graphics (PNG)'</body><body package="PNGImageReader" selector="mask">mask	"Answer a 1-bit image defining the opaque area of the current image."	| mask point |	mask := Image extent: image extent depth: 1 palette: CoveragePalette monoMaskPalette.	point := 0@0.	image pixelsDo:		[:x :y |		point x: x; y: y.		mask			atPoint: point			put: ((image atPoint: point) = transparentPixelValue				ifTrue: [0]				ifFalse: [1])].	^mask</body><body package="PNGImageReader" selector="readImage">readImage	filtersSeen := Bag new.	globalDataChunk := nil.	transparentPixelValue := nil.	unknownChunks := Set new.	ioStream reset.	(ioStream respondsTo: #binary) ifTrue: [ioStream binary].	ioStream skip: 8.	[ioStream atEnd] whileFalse: [self processNextChunk].	chunk := globalDataChunk.	chunk notNil ifTrue: [self processIDATChunk].</body><body package="PNGImageReader" selector="transparentPixelValue">transparentPixelValue	^transparentPixelValue</body></methods><methods><class-id>Graphics.PNGImageReader</class-id> <category>chunks</category><body package="PNGImageReader" selector="processBackgroundChunk">processBackgroundChunk	| val red green blue max worker colorValue | 	colorType = 3 ifTrue: [colorValue := palette at: chunk first].	max := (2 raisedTo: bitsPerChannel) - 1.	(colorType = 0 or: [colorType = 4]) ifTrue: 		[val := (UninterpretedBytes from: chunk) unsignedShortAt: 1 bigEndian: true.		colorValue := ColorValue brightness: val / max].	(colorType = 2 or: [colorType = 6]) ifTrue: 		[red := (UninterpretedBytes from: chunk) unsignedShortAt: 1 bigEndian: true.		green := (UninterpretedBytes from: chunk) unsignedShortAt: 3 bigEndian: true.		blue := (UninterpretedBytes from: chunk) unsignedShortAt: 5 bigEndian: true.		colorValue := ColorValue red: red green: green blue: blue range: max].	worker := Image		extent: 1@1		depth: image depth		bitsPerPixel: image bitsPerPixel		palette: image palette.	worker atPoint: 0@0 put: (palette indexOfPaintNearest: colorValue).	image tile: image preferredBounds from: 0@0 in: worker rule: RasterOp paint.</body><body package="PNGImageReader" selector="processIDATChunk">processIDATChunk	interlaceMethod = 0 		ifTrue: [self processNonInterlaced] 		ifFalse: [self processInterlaced]</body><body package="PNGImageReader" selector="processIHDRChunk">processIHDRChunk	| translatedBytes |	translatedBytes := UninterpretedBytes from: chunk.	width := translatedBytes longAt: 1 bigEndian: true.	height := translatedBytes longAt: 5 bigEndian: true.	bitsPerChannel := chunk at: 9.	colorType := chunk at: 10.	interlaceMethod := chunk at: 13.	(#(2 4 6) includes: colorType) ifTrue: 		[depth := 32.		palette := self class defaultPalette.		image := Image extent: width @ height depth: depth palette: palette].	(#(0 3) includes: colorType) ifTrue: 			[depth := bitsPerChannel min: 8.			image := Image extent: width @ height				depth: depth				palette: (colorType = 0 					ifTrue: [self grayColorsFor: depth] 					ifFalse: [palette := self class defaultPalette])].	bitsPerPixel := (BPP at: colorType + 1) at: bitsPerChannel highBit.	bytesPerScanline := (width * bitsPerPixel + 7) // 8.	rowSize := image width * image depth + 31 &gt;&gt; 5</body><body package="PNGImageReader" selector="processInterlaced">processInterlaced	| zlibReader filter bytesPerPass startingColumns columnIncrements rowIncrements startingRows currentColumnIncrement currentStartingColumn temp |	startingColumns := #(0 4 0 2 0 1 0).	columnIncrements := #(8 8 4 4 2 2 1).	rowIncrements := #(8 8 8 4 4 2 2).	startingRows := #(0 0 4 0 2 0 1).	zlibReader := Net.ZLibReadStream on: chunk from: 1 to: chunk size.	1 to: 7 do: 		[:pass | 		(self doPass: pass) ifTrue: 			[currentColumnIncrement := columnIncrements at: pass.			currentStartingColumn := startingColumns at: pass.			bytesPerPass := ((width - currentStartingColumn + currentColumnIncrement - 1) 								// currentColumnIncrement * bitsPerPixel + 7) // 8.			prevScanline := ByteArray new: bytesPerPass.			thisScanline := ByteArray new: bytesPerScanline.			(startingRows at: pass) to: height - 1 by: (rowIncrements at: pass) do: 				[:index | 				filter := zlibReader next.				filtersSeen add: filter.				(filter isNil or: [(filter between: 0 and: 4) not]) ifTrue: [^self].				thisScanline := zlibReader next: bytesPerPass into: thisScanline startingAt: 1.				self filterScanline: filter count: bytesPerPass.				self copyPixels: index at: currentStartingColumn by: currentColumnIncrement.				temp := prevScanline.				prevScanline := thisScanline.				thisScanline := temp]]]</body><body package="PNGImageReader" selector="processNextChunk">processNextChunk	| length asciiType |	length := self nextLong.	asciiType := (ioStream next: 4) asString.	chunk := ioStream next: length.	self nextLong.	"crc"	asciiType = 'IEND' ifTrue: [^[ioStream atEnd] whileFalse: [ioStream next]].	(#('sBIT' 'gAMA') includes: asciiType) ifTrue: [^self].	asciiType = 'bKGD' ifTrue: [^self processBackgroundChunk].	asciiType = 'pHYs' ifTrue: [^self processPhysicalPixelChunk].	asciiType = 'tRNS' ifTrue: [^self processTransparencyChunk].	asciiType = 'IHDR' ifTrue: [^self processIHDRChunk].	asciiType = 'PLTE' ifTrue: [^self processPLTEChunk].	asciiType = 'IDAT' ifTrue: [^globalDataChunk := globalDataChunk isNil ifTrue: [chunk] ifFalse: [globalDataChunk , chunk]].	unknownChunks add: asciiType</body><body package="PNGImageReader" selector="processNonInterlaced">processNonInterlaced	| zlibReader filter temp |	zlibReader := Net.ZLibReadStream on: chunk from: 1 to: chunk size.	prevScanline := ByteArray new: bytesPerScanline.	thisScanline := ByteArray new: bytesPerScanline.	0 to: height - 1 do: 		[:index | 		filter := (zlibReader next: 1) first.		filtersSeen add: filter.		(filter isNil or: [(filter between: 0 and: 4) not]) ifTrue: [^self].		thisScanline := zlibReader next: bytesPerScanline into: thisScanline startingAt: 1.		self filterScanline: filter count: bytesPerScanline.		self copyPixels: index.		temp := prevScanline.		prevScanline := thisScanline.		thisScanline := temp]</body><body package="PNGImageReader" selector="processPhysicalPixelChunk">processPhysicalPixelChunk	"Currently we do nothing"</body><body package="PNGImageReader" selector="processPLTEChunk">processPLTEChunk	| colorCount chunkIndex colorArray |	colorCount := chunk size // 3.	colorArray := Array new: colorCount.	0 to: colorCount - 1 do: 		[:index | 		chunkIndex := index * 3 + 1.		colorArray 			at: index + 1			put: (ColorValue 				red: (chunk at: chunkIndex)				green: (chunk at: chunkIndex + 1)				blue: (chunk at: chunkIndex + 2)				range: 255)].	palette := MappedPalette withColors: colorArray.	image := Image extent: width @ height depth: depth palette: palette</body><body package="PNGImageReader" selector="processTransparencyChunk">processTransparencyChunk	| red green blue colors |	colorType = 0 ifTrue: 			[transparentPixelValue := (UninterpretedBytes from: chunk) unsignedShortAt: 1 bigEndian: true.			^self].	colorType = 2 ifTrue: 			[red := (UninterpretedBytes from: chunk) unsignedShortAt: 1 bigEndian: true.			green := (UninterpretedBytes from: chunk) unsignedShortAt: 3 bigEndian: true.			blue := (UninterpretedBytes from: chunk) unsignedShortAt: 5 bigEndian: true.			transparentPixelValue := ((65280 + red &lt;&lt; 8) + green &lt;&lt; 8) + blue.			^self].	colorType = 3 ifTrue: 			[chunk keysAndValuesDo: 					[:index :alpha | 					colors := palette colors.					colors at: index put: ((palette at: index) blendWith: (palette at: index) weight: alpha / 255).					palette setColors: colors].			^self]</body></methods><methods><class-id>Graphics.PNGImageReader class</class-id> <category>defaults</category><body package="PNGImageReader" selector="defaultPalette">defaultPalette	^FixedPalette						redShift: 0						redMask: 16rFF						greenShift: 8						greenMask: 16rFF						blueShift: 16						blueMask: 16rFF</body></methods><methods><class-id>Graphics.PNGImageReader class</class-id> <category>initialize</category><body package="PNGImageReader" selector="initialize">initialize	"PNGImageReader initialize"	BPP := Array new: 8.	BPP 		at: 1 put: #(1 2 4 8 16);		at: 2 put: #(0 0 0 0 0);		at: 3 put: #(0 0 0 24 48);		at: 4 put: #(1 2 4 8 0);		at: 5 put: #(0 0 0 16 32);		at: 6 put: #(0 0 0 0 0);		at: 7 put: #(0 0 0 32 64);		at: 8 put: #(0 0 0 0 0).	BlockHeight := #(8 8 4 4 2 2 1).	BlockWidth := #(8 4 4 2 2 1 1)</body></methods><methods><class-id>Graphics.PNGImageReader class</class-id> <category>private</category><body package="PNGImageReader" selector="canRead:">canRead: imageStream	imageStream reset.	^#(137 80 78 71 13 10 26 10) allSatisfy: [:byte | imageStream next asInteger = byte].</body></methods><initialize><class-id>Graphics.PNGImageReader</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>ImageReader</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ioStream image palette imageData width height bitsPerPixel bytesPerRow rowEndOffset </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Images</category><attributes><package>Graphics-Images</package></attributes></class></st-source>