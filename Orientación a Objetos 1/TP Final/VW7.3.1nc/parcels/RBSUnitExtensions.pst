<?xml version="1.0"?><st-source><!-- Name: RBSUnitExtensionsNotice: Copyright © 2004-1999 Cincom Systems, Inc.  All Rights Reserved.Comment: This package adds an extension to the Source code tool. Whenever a test case is selected, it allows you to run that test case from the browser.DbIdentifier: bear73DbTrace: 50582DevelopmentPrerequisites: #(#(#any 'Browser-BrowserUI' '') #(#any 'SUnit' ''))PackageName: RBSUnitExtensionsParcel: #('RBSUnitExtensions')ParcelName: RBSUnitExtensionsPrerequisiteParcels: #(#('Browser-BrowserUI' '') #('SUnit' ''))PrintStringCache: (1.35,bobw)Version: 7.3Date: 3:55:53 pm November 22, 2004 --><time-stamp>From VisualWorks®, 7.3 of November 22, 2004 on November 22, 2004 at 3:55:53 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SUnitCodeToolSelectionPolicy</name><environment>Refactory.Browser</environment><super>Refactory.Browser.CodeToolSelectionPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourceSelectionPolicy </inst-vars><class-inst-vars></class-inst-vars><imports>			private XProgramming.SUnit.*			</imports><category>Browser-Code Tool Selection Policies</category><attributes><package>RBSUnitExtensions</package></attributes></class><comment><class-id>Refactory.Browser.SUnitCodeToolSelectionPolicy</class-id><body>See superclass.Determines what CodeTool should be installed whenever a selection is made in the navigator.Instance Variables:	sourceSelectionPolicy	&lt;CodeToolSelectionPolicy&gt;	the sourceSelectionPolicy</body></comment><class><name>SUnitCodeTool</name><environment>Refactory.Browser</environment><super>Refactory.Browser.CodeTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>codeTool selectionPolicy testCount defects </inst-vars><class-inst-vars></class-inst-vars><imports>			private XProgramming.SUnit.*			</imports><category>Browser-Code Tools</category><attributes><package>RBSUnitExtensions</package></attributes></class><comment><class-id>Refactory.Browser.SUnitCodeTool</class-id><body>An addition to the Browser's set of CodeTools.The tool allows Run, Debug, or Profile of concrete subclasses of TestCase, by single or multi-select of individual test selectors, classes, protocols, packages, parcels or categories.  The tool obeys the #isAbstract and #shouldInheritSelectors directives on individual classes, allowing a concrete class to inherit either all or none of the test selectors in its superclass hierarchy (up to, but not including TestCase).Note that the test selector inheritance feature of the TestCase class is, contrary to standard Smalltalk expectations, NOT automatic.  A class must explicitly specify that it is to be considered an abstract test case (#isAbstract) or that, as a concrete class, it wishes to inherit tests from its superclasses (#shouldInheritSelectors).  The directive #shouldInheritSelectors is meaningless (and ignored) for abstract test cases, since their test selectors cannot be run directly from the abstract class.Instance Variables:	codeTool		&lt;CodeTool&gt;					the tool	selectionPolicy	&lt;CodeToolSelectionPolicy&gt;	the corresponding selectionPolicy</body></comment><shared-variable><name>DefaultSourceSelectionPolicy</name><environment>Refactory.Browser.SUnitCodeTool</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RBSUnitExtensions</package></attributes></shared-variable><methods><class-id>Refactory.Browser.SUnitCodeToolSelectionPolicy</class-id> <category>initialize-release</category><body package="RBSUnitExtensions" selector="for:">for: aCodeModel 	super for: aCodeModel.	sourceSelectionPolicy for: aCodeModel</body><body package="RBSUnitExtensions" selector="on:">on: aSelectionPolicy 	sourceSelectionPolicy := aSelectionPolicy</body></methods><methods><class-id>Refactory.Browser.SUnitCodeToolSelectionPolicy</class-id> <category>copying</category><body package="RBSUnitExtensions" selector="postCopy">postCopy	super postCopy.	sourceSelectionPolicy := sourceSelectionPolicy copy</body></methods><methods><class-id>Refactory.Browser.SUnitCodeToolSelectionPolicy</class-id> <category>accessing</category><body package="RBSUnitExtensions" selector="categoryIncludesTest:">categoryIncludesTest: aCategory 	^TestCase allSubclasses anySatisfy: [:each | aCategory = each category]</body><body package="RBSUnitExtensions" selector="codeComponentIncludesTest:">codeComponentIncludesTest: aCodeComponent 	^aCodeComponent definedClasses anySatisfy: [:each | each inheritsFrom: TestCase]</body><body package="RBSUnitExtensions" selector="hasTestsSelected">hasTestsSelected	(codeModel selectedClasses 		anySatisfy: [:each | each inheritsFrom: TestCase]) ifTrue: [^true].	codeModel objectNames notEmpty ifTrue: [^false].	(codeModel categories 		anySatisfy: [:each | self categoryIncludesTest: each]) ifTrue: [^true].	(codeModel parcels 		anySatisfy: [:each | self codeComponentIncludesTest: each]) ifTrue: [^true].	^codeModel pundles 		anySatisfy: [:each | self codeComponentIncludesTest: each]</body><body package="RBSUnitExtensions" selector="name">name	^(#Source &lt;&lt; #browser &gt;&gt; 'Source') asString</body><body package="RBSUnitExtensions" selector="toolClass">toolClass	^self hasTestsSelected 		ifTrue: [SUnitCodeTool]		ifFalse: [sourceSelectionPolicy toolClass]</body></methods><methods><class-id>Refactory.Browser.SUnitCodeToolSelectionPolicy class</class-id> <category>instance creation</category><body package="RBSUnitExtensions" selector="on:">on: aCodeToolSelectionPolicy 	^(self new)		on: aCodeToolSelectionPolicy;		yourself</body></methods><methods><class-id>Refactory.Browser.SUnitCodeTool</class-id> <category>accessing</category><body package="RBSUnitExtensions" selector="activeTool">activeTool	^codeTool activeTool</body><body package="RBSUnitExtensions" selector="codeTool">codeTool	^codeTool</body><body package="RBSUnitExtensions" selector="menu">menu	^codeTool menu</body></methods><methods><class-id>Refactory.Browser.SUnitCodeTool</class-id> <category>initialize-release</category><body package="RBSUnitExtensions" selector="codeModel:">codeModel: aCodeModel 	super codeModel: aCodeModel.	selectionPolicy := (DefaultSourceSelectionPolicy copy)				for: codeModel;				yourself.	self updateContents</body><body package="RBSUnitExtensions" selector="release">release	selectionPolicy := nil.	codeTool release.	codeTool := nil.	super release</body></methods><methods><class-id>Refactory.Browser.SUnitCodeTool</class-id> <category>updating</category><body package="RBSUnitExtensions" selector="codeModelClass">codeModelClass	^selectionPolicy toolClass</body><body package="RBSUnitExtensions" selector="installCodeTool:">installCodeTool: aClass 	| newTool |	newTool := aClass codeModel: codeModel.	self installSubcanvasIn: #subcanvas using: newTool.	codeTool release.	codeTool := newTool.	codeTool updateContents</body><body package="RBSUnitExtensions" selector="setTestLabel:">setTestLabel: label 	| widget |	self builder isNil ifTrue: [^self].	widget := self builder componentAt: #label.	widget isNil ifTrue: [^self].	widget widget labelString: label.	widget repairDamage</body><body package="RBSUnitExtensions" selector="update:with:from:">update: aspectSymbol with: parameter from: sender	(testCount notNil and: [testCount &gt; 0]) ifTrue:		[testCount := testCount - 1.		self setTestLabel: ((#TestsRemaining1p &lt;&lt; #browser &gt;&gt; 'Tests Remaining : &lt;1p&gt;') expandMacrosWith: testCount)].</body><body package="RBSUnitExtensions" selector="updateButtons">updateButtons	builder isNil ifTrue: [^self].	self		updateRunButtons;		updateDefectButtons</body><body package="RBSUnitExtensions" selector="updateContents">updateContents	| class |	class := self codeModelClass.	class == codeTool class ifFalse: [self installCodeTool: class].	codeTool updateContents.	self		updateTestLabel;		updateButtons</body><body package="RBSUnitExtensions" selector="updateDefectButtons">updateDefectButtons	| enable |	enable := self defectsExist.	#(listDefects runDefects) do:		[:each | 	(self wrapperAt: each) isEnabled: enable]</body><body package="RBSUnitExtensions" selector="updateDisplay">updateDisplay	super updateDisplay.	self		updateTestLabel;		updateButtons</body><body package="RBSUnitExtensions" selector="updateRunButtons">updateRunButtons	| canRun |	canRun := self canRunTests.	#(runTests debugTests profileTests) do:		[:each | 		(self wrapperAt: each) isEnabled: canRun].	(self wrapperAt: #profileTests) isEnabled: canRun &amp; self isProfilerLoaded</body><body package="RBSUnitExtensions" selector="updateTestLabel">updateTestLabel	| label |	self isAbstractClassSelected		ifTrue: [ 			self updateForAbstract.			label := (#NotRunAbstractTest &lt;&lt; #browser &gt;&gt; 'Abstract test class, cannot run') ] 		ifFalse: [			self updateForNotRun.			label := (#NotRunC1pTests &lt;&lt; #browser &gt;&gt; 'Not run: &lt;1p&gt; tests') 							expandMacrosWith: self testCases size ].	self setTestLabel: label</body></methods><methods><class-id>Refactory.Browser.SUnitCodeTool</class-id> <category>interface opening</category><body package="RBSUnitExtensions" selector="preBuildWith:">preBuildWith: aBuilder 	aBuilder 		subCanvasAt: #subcanvas		at: #windowSpec		put: codeTool class windowSpec.	^super preBuildWith: aBuilder</body></methods><methods><class-id>Refactory.Browser.SUnitCodeTool</class-id> <category>private</category><body package="RBSUnitExtensions" selector="categoryTestCases">categoryTestCases	"Answer all runnable test cases for all classes in		the selected category or categories."	^self testCasesFor: (TestCase allSubclasses 				select: [:each | self categories includes: each category])</body><body package="RBSUnitExtensions" selector="categoryTestCasesExist">categoryTestCasesExist	"Answer if there are runnable test cases in classes in the selected category or categories."	^self testCasesExistInAny:		(TestCase allSubclasses 			select: [:each | self categories includes: each category])</body><body package="RBSUnitExtensions" selector="classTestCases">classTestCases	"Answer all runnable test cases for the selected class or classes."	^self testCasesFor: self selectedClasses.</body><body package="RBSUnitExtensions" selector="parcelTestCases">parcelTestCases	"Answer all runnable test cases for all classes in			the selected parcel or parcels."	^ self parcels inject: Set new		into: 			[ :sum :eachPundle | 			sum				addAll: (self testCasesFor: (eachPundle definedClasses));				yourself ].</body><body package="RBSUnitExtensions" selector="parcelTestCasesExist">parcelTestCasesExist	"Answer if runnable test cases exist in any classes in the selected parcel or parcels."	^self parcels anySatisfy:		[:any |		self testCasesExistInAny: any definedClasses]</body><body package="RBSUnitExtensions" selector="protocolTestCases">protocolTestCases	"Answer all runnable test cases for the selected protocol or protocols."	^self protocols inject: Set new		into: 			[ :sum :each | 			sum				addAll: (self testCasesForSelectors: 							(self testSelectorsForClass: self selectedClass protocol: each));				yourself ].</body><body package="RBSUnitExtensions" selector="pundleTestCases">pundleTestCases	"Answer all runnable test cases for all classes in			the selected pundle or pundles."	^ self pundles inject: Set new		into: 			[:sum :eachPundle | 			sum				addAll: (self testCasesFor: (eachPundle definedClasses));				yourself ].</body><body package="RBSUnitExtensions" selector="pundleTestCasesExist">pundleTestCasesExist	"Answer if runnable test cases exist in classes in the selected pundle or pundles."	^self pundles anySatisfy:		[:any |		self testCasesExistInAny: any definedClasses]</body><body package="RBSUnitExtensions" selector="selectorTestCases">selectorTestCases	"Answer all runnable test cases for the selected selectors."	^self testCasesForSelectors: self selectors</body><body package="RBSUnitExtensions" selector="setFailedLabel">setFailedLabel	self setTestLabel: (#Failed &lt;&lt; #browser &gt;&gt; 'Failed').	self updateForFailed</body><body package="RBSUnitExtensions" selector="setLabelColor:">setLabelColor: color 	| label |	self builder isNil ifTrue: [^self].	label := self builder componentAt: #label.	label isNil ifTrue: [^self].	label lookPreferences: (label lookPreferences backgroundColor: color)</body><body package="RBSUnitExtensions" selector="setPassedLabel">setPassedLabel	self setTestLabel: (#Passed &lt;&lt; #browser &gt;&gt; 'Passed').	self updateForPassed</body><body package="RBSUnitExtensions" selector="subcanvases">subcanvases	^(OrderedCollection withAll: super subcanvases)		add: codeTool;		yourself</body><body package="RBSUnitExtensions" selector="testCases">testCases	self selector notNil ifTrue: [^self selectorTestCases].	self protocol notNil ifTrue: [^self protocolTestCases].	self selectedClass notNil ifTrue: [^self classTestCases].	self category notNil ifTrue: [^self categoryTestCases].	self parcel notNil ifTrue: [^self parcelTestCases].	self pundle notNil ifTrue: [^self pundleTestCases].	^#()</body><body package="RBSUnitExtensions" selector="testCasesExistInAny:">testCasesExistInAny: classesCollection	"Answer if there are any test cases in the classes listed in the argument."	^classesCollection anySatisfy:		[:any | (self testSelectorsForClass: any) notEmpty]</body><body package="RBSUnitExtensions" selector="testCasesFor:">testCasesFor: classesCollection	"Answer all runnable test cases for the collection of classes."	^classesCollection 		inject: Set new		into: 			[:sum :each | 			sum				addAll: ((self testSelectorsForClass: each) collect: [:sel | each selector: sel]);				yourself]</body><body package="RBSUnitExtensions" selector="testCasesForSelectors:">testCasesForSelectors: selectors 	| testSelectors |	testSelectors := self testSelectorsForClass: self selectedClass.	^(selectors select: [:each | testSelectors includes: each]) 		collect: [:each | self selectedClass selector: each]</body><body package="RBSUnitExtensions" selector="testSelectorsForClass:">testSelectorsForClass: aClass	"Answer an OrderedCollection of runnable test selectors for aClass,		obeying the #isAbstract and #shouldInheritSelectors designation,		provided it is a subclass of TestCase."	^ ((aClass inheritsFrom: TestCase) not or: [ aClass isAbstract ])			ifTrue: [ OrderedCollection new ]			ifFalse: [ aClass shouldInheritSelectors				ifTrue: [aClass allTestSelectors]				ifFalse: [aClass testSelectors] ].</body><body package="RBSUnitExtensions" selector="testSelectorsForClass:protocol:">testSelectorsForClass: aClass protocol: aProtocol	"Answer an OrderedCollection of runnable test selectors in aProtocol for aClass,		obeying the #isAbstract and #shouldInheritSelectors designation,		provided it is a subclass of TestCase."	^ ((aClass inheritsFrom: TestCase) not or: [ aClass isAbstract ])			ifTrue: [ OrderedCollection new ]			ifFalse: [ aClass shouldInheritSelectors				ifTrue: [ (aClass withAllSuperclasses)							removeAll: TestCase withAllSuperclasses;							inject: Set new into: [ :sum :each | 									sum addAll: (self environment selectorsFor: aProtocol in: each);									yourself ] ]				ifFalse: [ self environment selectorsFor: aProtocol in: aClass ] ].</body><body package="RBSUnitExtensions" selector="updateForAbstract">updateForAbstract	self setLabelColor: nil</body><body package="RBSUnitExtensions" selector="updateForFailed">updateForFailed	self setLabelColor: ColorValue red</body><body package="RBSUnitExtensions" selector="updateForNotRun">updateForNotRun	self setLabelColor: nil</body><body package="RBSUnitExtensions" selector="updateForPassed">updateForPassed	self setLabelColor: ColorValue green.	defects := nil</body></methods><methods><class-id>Refactory.Browser.SUnitCodeTool</class-id> <category>actions</category><body package="RBSUnitExtensions" selector="debugTests">debugTests	| failed |	self shouldNotRunTests ifTrue: [^self].	self updateForNotRun.	self setTestLabel: (#Debugging &lt;&lt; #browser &gt;&gt; 'Debugging').	failed := false.	testCount := self testCases size.	[[self testCases do: 		[:each | 		each debug.			(testCount notNil and: [testCount &gt; 0]) ifTrue:			[testCount := testCount - 1.			self setTestLabel: ((#TestsRemaining1p &lt;&lt; #browser&gt;&gt; 'Tests Remaining : &lt;1p&gt;') expandMacrosWith: testCount)]]] 		on: TestResult failure , TestResult error		do: 			[:ex | 			failed := true.			ex pass]] 			ifCurtailed: [self setFailedLabel].	failed ifTrue: [self setFailedLabel] ifFalse: [self setPassedLabel]</body><body package="RBSUnitExtensions" selector="listDefects">listDefects	| testToDebug |	(defects isNil or: [defects isEmpty]) ifTrue: [^self].	testToDebug := Dialog 		choose: (#ChooseATestToDebug &lt;&lt; #browser &gt;&gt; 'Choose A Test To Debug')		fromList: (defects collect: [:each | each printString])		values: defects		lines: 8 		cancel: []		for: Dialog defaultParentWindow.	testToDebug ifNotNil: [:value | value debug]</body><body package="RBSUnitExtensions" selector="profileTests">profileTests	| profiler |	profiler := #{TimeProfiler} valueOrDo: [nil].	profiler isNil 		ifTrue: [^self warn: (#ProfilerNotLoadedLoad &lt;&lt; #browser &gt;&gt; 'Profiler not loaded. Load the "AT Profiling" parcel.')].	profiler profile: [self runTests]</body><body package="RBSUnitExtensions" selector="runDefects">runDefects	| suite result |	(defects isNil or: [defects isEmpty]) ifTrue: [^self].	suite := TestSuite new.	defects do: [:each | suite addTest: each].	testCount := defects size.	suite addDependent: self.	result := [suite run] ifCurtailed: [self setTestLabel: (#Failed &lt;&lt; #browser &gt;&gt; 'Failed')].	self 		setTestLabel: (#x1QPassedORFailed2pRun3pFailed4pErrors &lt;&lt; #browser &gt;&gt; '&lt;1?Passed:Failed&gt;: &lt;2p&gt; run, &lt;3p&gt; failed, &lt;4p&gt; errors'				expandMacrosWith: result hasPassed				with: result runCount				with: result failureCount				with: result errorCount).	codeModel navigate.	result hasPassed 		ifTrue: [self updateForPassed]		ifFalse: 			[defects := result defects.			self updateForFailed].	self updateDefectButtons</body><body package="RBSUnitExtensions" selector="runTests">runTests	| suite result |	self shouldNotRunTests ifTrue: [^self].	self updateForNotRun.	self setTestLabel: (#Running &lt;&lt; #browser &gt;&gt; 'Running').	suite := TestSuite new.	self testCases do: [:each | suite addTest: each].	testCount := self testCases size.	suite addDependent: self.	result := [suite run] ifCurtailed: 		[self setTestLabel: (#Failed &lt;&lt; #browser &gt;&gt; 'Failed')].	self 		setTestLabel: (#x1QPassedORFailed2pRun3pFailed4pErrors &lt;&lt; #browser &gt;&gt; '&lt;1?Passed:Failed&gt;: &lt;2p&gt; run, &lt;3p&gt; failed, &lt;4p&gt; errors'				expandMacrosWith: result hasPassed				with: result runCount				with: result failureCount				with: result errorCount).	codeModel navigate.	result hasPassed 		ifTrue: [self updateForPassed]		ifFalse: 			[defects := result defects.			self updateForFailed].	self updateDefectButtons</body></methods><methods><class-id>Refactory.Browser.SUnitCodeTool</class-id> <category>testing</category><body package="RBSUnitExtensions" selector="canRunTests">canRunTests	^self isAbstractClassSelected not and: [self testCasesExist]</body><body package="RBSUnitExtensions" selector="defectsExist">defectsExist	^defects notNil and: [defects notEmpty]</body><body package="RBSUnitExtensions" selector="isAbstractClassSelected">isAbstractClassSelected	^self selectedClass notNil		and: [(self selectedClass respondsTo: #isAbstract) 		and: [self selectedClass isAbstract]]</body><body package="RBSUnitExtensions" selector="isProfilerLoaded">isProfilerLoaded	#{TimeProfiler} valueOrDo: [^false].	^true</body><body package="RBSUnitExtensions" selector="shouldNotRunTests">shouldNotRunTests	^self canRunTests not</body><body package="RBSUnitExtensions" selector="testCasesExist">testCasesExist	self selector notNil ifTrue: [^self selectorTestCases notEmpty].	self protocol notNil ifTrue: [^self protocolTestCases notEmpty].	self selectedClass notNil ifTrue: [^self classTestCases notEmpty].	self category notNil ifTrue: [^self categoryTestCasesExist].	self parcel notNil ifTrue: [^self parcelTestCasesExist].	self pundle notNil ifTrue: [^self pundleTestCasesExist].	^#()</body></methods><methods><class-id>Refactory.Browser.SUnitCodeTool class</class-id> <category>accessing</category><body package="RBSUnitExtensions" selector="sourceSelectionPolicy">sourceSelectionPolicy	^DefaultSourceSelectionPolicy</body><body package="RBSUnitExtensions" selector="sourceSelectionPolicy:">sourceSelectionPolicy: aCodeToolSelectionPolicy 	DefaultSourceSelectionPolicy := aCodeToolSelectionPolicy</body></methods><methods><class-id>Refactory.Browser.SUnitCodeTool class</class-id> <category>updating</category><body package="RBSUnitExtensions" selector="update:with:from:">update: anAspectSymbol with: aParameter from: aSender 	(aSender = CodeModel and: [anAspectSymbol = #selectionPolicies]) 		ifTrue: [^self addSelectionPolicy].	^super 		update: anAspectSymbol		with: aParameter		from: aSender</body></methods><methods><class-id>Refactory.Browser.SUnitCodeTool class</class-id> <category>class initialization</category><body package="RBSUnitExtensions" selector="addSelectionPolicy">addSelectionPolicy	| newPolicies |	newPolicies := CodeModel defaultSelectionPolicies collect: 					[:each | 					(each name asString = (#Source &lt;&lt; #browser &gt;&gt; 'Source') asString and: [each class ~= SUnitCodeToolSelectionPolicy]) 						ifTrue: 							[self sourceSelectionPolicy: each.							SUnitCodeToolSelectionPolicy on: each]						ifFalse: [each]].	CodeModel defaultSelectionPolicies: newPolicies</body><body package="RBSUnitExtensions" selector="initialize">initialize	(CodeModel dependents includes: self) 		ifFalse: [CodeModel addDependent: self].	self addSelectionPolicy</body><body package="RBSUnitExtensions" selector="obsolete">obsolete	CodeModel removeDependent: self.	self removeSelectionPolicy.	super obsolete</body><body package="RBSUnitExtensions" selector="removeSelectionPolicy">removeSelectionPolicy	| newPolicies |	self sourceSelectionPolicy isNil ifTrue: [^self].	newPolicies := CodeModel defaultSelectionPolicies collect: 					[:each | 					each name asString = (#Source &lt;&lt; #browser &gt;&gt; 'Source') asString ifTrue: [self sourceSelectionPolicy] ifFalse: [each]].	CodeModel defaultSelectionPolicies: newPolicies</body></methods><methods><class-id>Refactory.Browser.SUnitCodeTool class</class-id> <category>private-interface building</category><body package="RBSUnitExtensions" selector="markedAsSystemClass">markedAsSystemClass	"This class not to be shown when browsing user classes."</body></methods><methods><class-id>Refactory.Browser.SUnitCodeTool class</class-id> <category>interface specs</category><body package="RBSUnitExtensions" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #UnlabeledCanvas 				#defaultString: 'Unlabeled Canvas' 				#catalogID: #browser ) 			#bounds: #(#{Graphics.Rectangle} 456 370 1024 768 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 -33 1 ) 					#name: #subcanvas 					#flags: 0 					#majorKey: #subcanvas 					#minorKey: #windowSpec 					#clientKey: #codeTool ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} -2 0 -33 1 -350 1 0 1 ) 					#name: #label 					#style: #large ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -65 1 -30 1 -2 1 -2 1 ) 					#name: #runTests 					#flags: 40 					#model: #runTests 					#label: 					#(#{Kernel.UserMessage} 						#key: #Run 						#defaultString: 'Run' 						#catalogID: #browser ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -130 1 -30 1 -67 1 -2 1 ) 					#name: #debugTests 					#flags: 40 					#model: #debugTests 					#label: 					#(#{Kernel.UserMessage} 						#key: #Debug 						#defaultString: 'Debug' 						#catalogID: #browser ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -195 1 -30 1 -132 1 -2 1 ) 					#name: #profileTests 					#flags: 40 					#model: #profileTests 					#label: 					#(#{Kernel.UserMessage} 						#key: #Profile 						#defaultString: 'Profile' 						#catalogID: #browser ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -270 1 -30 1 -197 1 -2 1 ) 					#name: #listDefects 					#flags: 40 					#model: #listDefects 					#label: 					#(#{Kernel.UserMessage} 						#key: #listDefects 						#defaultString: 'List Defects' 						#catalogID: #browser ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -350 1 -30 1 -272 1 -2 1 ) 					#name: #runDefects 					#flags: 40 					#model: #runDefects 					#label: 					#(#{Kernel.UserMessage} 						#key: #runDefects 						#defaultString: 'Run Defects' 						#catalogID: #browser ) 					#defaultable: true ) ) ) )</body></methods><initialize><class-id>Refactory.Browser.SUnitCodeTool</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>CodeTool</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>codeModel menu </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Code Tools</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>CodeToolSelectionPolicy</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>codeModel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Code Tool Selection Policies</category><attributes><package>Browser-BrowserUI</package></attributes></class></st-source>