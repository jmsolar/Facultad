<?xml version="1.0"?><st-source><!-- Name: Arbor Help System CoreNotice: Copyright © 2002 Cincom Systems, Inc.  All Rights Reserved.Comment: Provides code needed by Outline and Widget Help DbIdentifier: bear73DbTrace: 22546DevelopmentPrerequisites: #(#(#any 'Arbor Help System Widget Help Core' ''))PackageName: Arbor Help System CoreParcel: #('Arbor Help System Core')ParcelName: Arbor Help System CorePrerequisiteParcels: #(#('Arbor Help System Widget Help Core' ''))PrintStringCache: (5i.4 - 1.2,bobw)Version: 7.2Date: 1:27:03 pm October 20, 2003 --><time-stamp>From VisualWorks®, 7.2 of October 20, 2003 on October 20, 2003 at 1:27:03 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>AHSPersistentDictionary</name><environment>VWHelp</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Core</category><attributes><package>Arbor Help System Core</package></attributes></class><comment><class-id>VWHelp.AHSPersistentDictionary</class-id><body>Copyright Ó 1994 Arbor Intelligent Systems, Inc.This class allows a dictionary to have persistence properties when used in conjunction with a database.Instance Variables: *Indexed*</body></comment><class><name>AHSTextBinder</name><environment>VWHelp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fullText condensedText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Core</category><attributes><package>Arbor Help System Core</package></attributes></class><comment><class-id>VWHelp.AHSTextBinder</class-id><body>AHSTextBinderStores text in up to two forms - a long ("full") form and a short ("condensed") form, suitable for displaying in the real-time help area and in a help bubble, respectively.Instance VariablesfullText	&lt;Text&gt;condensedText	&lt;Text&gt;</body></comment><class><name>AHSHelpInfo</name><environment>VWHelp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>languages data </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Core</category><attributes><package>Arbor Help System Core</package></attributes></class><comment><class-id>VWHelp.AHSHelpInfo</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:languages	&lt;ClassOfVariable&gt;	description of variable's functiondata	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>AHSTranslationTextBinder</name><environment>VWHelp</environment><super>VWHelp.AHSTextBinder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Core</category><attributes><package>Arbor Help System Core</package></attributes></class><comment><class-id>VWHelp.AHSTranslationTextBinder</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:</body></comment><class><name>AHSCacheHelpInfo</name><environment>VWHelp</environment><super>VWHelp.AHSHelpInfo</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Core</category><attributes><package>Arbor Help System Core</package></attributes></class><comment><class-id>VWHelp.AHSCacheHelpInfo</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:</body></comment><class><name>ArborTextAttributes</name><environment>VWHelp</environment><super>Graphics.VariableSizeTextAttributes</super><private>false</private><indexed-type>none</indexed-type><inst-vars>truePixelSize platform </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Core</category><attributes><package>Arbor Help System Core</package></attributes></class><comment><class-id>VWHelp.ArborTextAttributes</class-id><body>Copyright 1996 Arbor Intelligent Systems, Inc.ArborTextAttributes instances do their best to guarantee the presented pixel height of a string of characters.  Normally, if a given TextAttributes is used on different platforms (even if the same FontDescription is used), the actual fonts returned may differ significantly in size.  Traditionally, this has been the biggest problem when moving from Window or UNIX to a Macintosh, but even between Win and UNIX there can be problems.  This has to do with how each platform OS implements font calculations - for example, when a font of size 12 is requested on one platform the platform includes extra leading above/below the font glyphs as part of the 12, while another platform will only use the highest ascent to the lowest descent in the font for the 12, omitting the leading.  This will result in the presented fonts having different sizes.When a font of some size is requested using an ArborTextAttributes, the OS is queried for a font of that size.  Then a calculation is performed to see if the font returned is actually the correct size.  If not, ArborTextAttributes will continue requesting fonts of greater or lesser size (as appropriate) to come as close as possible to returning a font of the requested size.  ArborTextAttributes does this work by printing a set of characters onto an off-screen pixmap and then checks the pixmap to see the actual printed height, from the highest ascent to the lowest descent.When initialized, this class automatically creates a number of new TextAttributes instances and places them in the TextStyles dictionary, making them available for general use, including when using the Properties Tool when painting a canvas.Instance Variables:	truePixelSize	&lt;SmallInteger&gt;	platform 	&lt;String&gt;</body></comment><class><name>AHSTranslationText</name><environment>VWHelp</environment><super>Core.Text</super><private>false</private><indexed-type>none</indexed-type><inst-vars>translated </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Core</category><attributes><package>Arbor Help System Core</package></attributes></class><comment><class-id>VWHelp.AHSTranslationText</class-id><body>Copyright Ó 1995 Arbor Intelligent Systems, Inc.Used to keep track of whether a text has been translated or notInstance Variables:	translated &lt;Boolean&gt;</body></comment><class><name>AHSPreferences</name><environment>VWHelp</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>triggerChannel saveHelpAsMethod expandOutlines bookmarkDirectory specifiedDirectory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Core</category><attributes><package>Arbor Help System Core</package></attributes></class><comment><class-id>VWHelp.AHSPreferences</class-id><body>Copyright Ó 1994 Arbor Intelligent Systems, Inc.This class holds some preferences for the help system, which can be (de)activated from the help launcher, preferences button.Instance Variables:triggerChannel	&lt;ClassOfVariable&gt;	description of variable's functionsaveHelpAsMethod	&lt;ClassOfVariable&gt;	description of variable's functionexpandOutlines	&lt;ClassOfVariable&gt;	description of variable's functionbookmarkDirectory	&lt;ClassOfVariable&gt;	description of variable's functionspecifiedDirectory	&lt;ClassOfVariable&gt;	description of variable's functionClass Variables:Preferences	&lt;ClassOfVariable&gt;	description of variable''s function</body></comment><class><name>AHSHelpClassData</name><environment>VWHelp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>languages widgetData </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Core</category><attributes><package>Arbor Help System Core</package></attributes></class><comment><class-id>VWHelp.AHSHelpClassData</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:languages	&lt;ClassOfVariable&gt;	description of variable's functionwidgetData	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>AHSStorageManager</name><environment>VWHelp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>segStack </class-inst-vars><imports></imports><category>Help-Core</category><attributes><package>Arbor Help System Core</package></attributes></class><comment><class-id>VWHelp.AHSStorageManager</class-id><body>Copyright © 1994, 1995 Arbor Intelligent Systems, Inc.Controls all access to help, from sourcesInstance Variables:Class Variables:AllowEditingModel	&lt;ClassOfVariable&gt;	description of variable''s functionCurrentLanguage	&lt;ClassOfVariable&gt;	description of variable''s functionGemStoneHelpOutlines	&lt;ClassOfVariable&gt;	description of variable''s functionHelpDictionaries	&lt;ClassOfVariable&gt;	description of variable''s functionOutlineSource	&lt;ClassOfVariable&gt;	description of variable''s functionWidgetSource	&lt;ClassOfVariable&gt;	description of variable''s function</body></comment><class><name>AHSPreferencesModel</name><environment>VWHelp</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>triggerChannel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Core</category><attributes><package>Arbor Help System Core</package></attributes></class><comment><class-id>VWHelp.AHSPreferencesModel</class-id><body>The abstract superclass of the models used to construct the AHSPreferences dialog.Instance Variables:triggerChannel	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>AHSCorePreferencesModel</name><environment>VWHelp</environment><super>VWHelp.AHSPreferencesModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Core</category><attributes><package>Arbor Help System Core</package></attributes></class><comment><class-id>VWHelp.AHSCorePreferencesModel</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:</body></comment><class><name>AHSBalloonHelpPreferencesModel</name><environment>VWHelp</environment><super>VWHelp.AHSPreferencesModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>balloonDelayValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Core</category><attributes><package>Arbor Help System Core</package></attributes></class><comment><class-id>VWHelp.AHSBalloonHelpPreferencesModel</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:balloonDelayValue	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>AHSHelpData</name><environment>VWHelp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>texts outlineLinks </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Core</category><attributes><package>Arbor Help System Core</package></attributes></class><comment><class-id>VWHelp.AHSHelpData</class-id><body>AHSHelpDataInstance Variables:	texts &lt;nil | (Array of: Text)&gt;	outlineLinks &lt;nil | (Array with: String with: (nil | Integer))&gt; TO DO: Store a message selector as an outline link instead of the current use of a separate state. The format could be (Array with: String with: nil), using the String with a # in front to specify the selector, and it would maintain the same type as described above</body></comment><class><name>AHSPreferencesSetup</name><environment>VWHelp</environment><super>VWHelp.AHSPreferencesModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Core</category><attributes><package>Arbor Help System Core</package></attributes></class><comment><class-id>VWHelp.AHSPreferencesSetup</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:</body></comment><shared-variable><name>Preferences</name><environment>VWHelp.AHSPreferences</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Arbor Help System Core</package></attributes></shared-variable><shared-variable><name>AllowEditingModel</name><environment>VWHelp.AHSStorageManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Arbor Help System Core</package></attributes></shared-variable><shared-variable><name>WidgetSource</name><environment>VWHelp.AHSStorageManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Arbor Help System Core</package></attributes></shared-variable><shared-variable><name>HelpDictionaries</name><environment>VWHelp.AHSStorageManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Arbor Help System Core</package></attributes></shared-variable><shared-variable><name>CurrentLanguage</name><environment>VWHelp.AHSStorageManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Arbor Help System Core</package></attributes></shared-variable><shared-variable><name>GemStoneHelpOutlines</name><environment>VWHelp.AHSStorageManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Arbor Help System Core</package></attributes></shared-variable><shared-variable><name>OutlineSource</name><environment>VWHelp.AHSStorageManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Arbor Help System Core</package></attributes></shared-variable><methods><class-id>VWHelp.AHSPersistentDictionary</class-id> <category>adding</category><body package="Arbor Help System Core">add: anAssociation		"Include anAssociation as one of the receiver's elements. Answer		anAssociation."		| index element key |		(key := anAssociation key) == nil ifTrue: [^self subscriptBoundsError: key].		index := self findKeyOrNil: key.		element := self basicAt: index.		element == nil				ifTrue: [self atNewIndex: index put: anAssociation]				ifFalse: [element odbDirty. element value: anAssociation value].		^anAssociation</body></methods><methods><class-id>VWHelp.AHSPersistentDictionary</class-id> <category>accessing</category><body package="Arbor Help System Core">at: key put: anObject		"Set the value at key to be anObject.  If key is not found, create a 	new entry for key and set is value to anObject. Answer anObject."		| index element |		key == nil ifTrue: [^self subscriptBoundsError: key].		index := self findKeyOrNil: key.		element := self basicAt: index.		element == nil				ifTrue: [self atNewIndex: index put: (Association key: key value: anObject)]				ifFalse: [element odbDirty. element value: anObject].		^anObject</body></methods><methods><class-id>VWHelp.AHSPersistentDictionary</class-id> <category>private</category><body package="Arbor Help System Core">atNewIndex: index put: anObject 	self odbDirty.	^super atNewIndex: index put: anObject</body><body package="Arbor Help System Core">changeCapacityTo: newCapacity	"Change the size of the receiver to newCapacity.  The receiver will be regrown if necessary to fit its contents."	"Note that #rehash uses this -- don't optimize the case where the receiver doesn't change in size."	| newSelf |	newSelf := self copyEmpty: newCapacity.	self associationsDo: [:each | newSelf noCheckAdd: each].	self odbDirty.	self become: newSelf.</body><body package="Arbor Help System Core">fixCollisionsFrom: index 	self odbDirty.	^super fixCollisionsFrom: index</body><body package="Arbor Help System Core">rehash	"Do the same thing as changeCapacityTo: except don't do the become.  Instead, copy all of the elements from the new set to the old"	| newSelf |	newSelf := self copyEmpty: self capacity.	self associationsDo: [:each | newSelf noCheckAdd: each].	1 to: self basicSize do: [:index |							self basicAt: index put: (newSelf basicAt: index)].</body><body package="Arbor Help System Core">swap: oneElement with: otherElement 	self odbDirty.	^super swap: oneElement with: otherElement</body></methods><methods><class-id>VWHelp.AHSPersistentDictionary</class-id> <category>odb support</category><body package="Arbor Help System Core">odbDeepRefresh	self odbRefreshIfNotDirty.	self associationsDo: [:assoc| assoc odbRefreshIfNotDirty].</body></methods><methods><class-id>VWHelp.AHSPersistentDictionary</class-id> <category>dictionary removing</category><body package="Arbor Help System Core">removeKey: anObject ifAbsent: aBlock	"Unwind protection isn't needed since if it unwinds then that means the dictionary wasn't modified."	| removed reply |	removed := true.	reply := super				removeKey: anObject				ifAbsent: [					removed := false.					aBlock value].	removed ifTrue: [self odbDirty].	^reply</body></methods><methods><class-id>VWHelp.AHSPersistentDictionary</class-id> <category>printing</category><body package="Arbor Help System Core">storeOn: aStream	"Append to the argument aStream a sequence of characters that is an expression 	whose evaluation creates an collection similar to the receiver. The general format	for a Dictionary is		((class-name new) add: association; add: association; ... ; yourself)"	| noneYet |	aStream nextPutAll: '(('.	aStream store: self class.	aStream nextPutAll: ' new)';		crtab.	noneYet := true.	self associationsDo: 			[:each | 			noneYet				ifTrue: [noneYet := false]				ifFalse: [aStream nextPut: $;;							crtab].			aStream nextPutAll: ' add: '.			aStream store: each].	noneYet ifFalse: [aStream nextPutAll: '; yourself'].	aStream nextPut: $)</body></methods><methods><class-id>VWHelp.AHSTextBinder</class-id> <category>comparing</category><body package="Arbor Help System Core">= anAHSTextBinder	| testBinder |	testBinder := anAHSTextBinder asAHSTextBinder.	^ self fullText = testBinder fullText and: [self condensedText = testBinder condensedText].</body></methods><methods><class-id>VWHelp.AHSTextBinder</class-id> <category>copying</category><body package="Arbor Help System Core">ahsDeepCopyOfText	^ self class 		fullText: (fullText isNil					ifTrue: [nil]					ifFalse: [fullText ahsDeepCopyOfText])		condensedText: (condensedText isNil							ifTrue: [nil]							ifFalse: [condensedText ahsDeepCopyOfText])</body></methods><methods><class-id>VWHelp.AHSTextBinder</class-id> <category>converting</category><body package="Arbor Help System Core">asAHSTextBinder	^ self</body><body package="Arbor Help System Core">asTranslationText	^ AHSTranslationTextBinder		fullText: fullText		condensedText: condensedText</body></methods><methods><class-id>VWHelp.AHSTextBinder</class-id> <category>accessing</category><body package="Arbor Help System Core">condensedText	"Answer the condensed help text (generally displayed in the balloon/bubble pane)."		^ self hasCondensedText		ifTrue: [condensedText]		ifFalse: [self fullText].</body><body package="Arbor Help System Core">fullText	"Answer the full help text (generally displayed in the status pane)."		^fullText isNil		ifTrue: [#{Smalltalk.Text} value new]		ifFalse: [fullText]</body><body package="Arbor Help System Core">translated	^ true</body></methods><methods><class-id>VWHelp.AHSTextBinder</class-id> <category>testing</category><body package="Arbor Help System Core">hasCondensedText	^ condensedText notNil</body><body package="Arbor Help System Core">isEmpty	^ self fullText isEmpty and: [self condensedText isEmpty]</body></methods><methods><class-id>VWHelp.AHSTextBinder</class-id> <category>private-accessing</category><body package="Arbor Help System Core">setCondensedText: condensedHelpText	condensedText := condensedHelpText isNil							ifTrue: [nil]							ifFalse: [condensedHelpText asText]</body><body package="Arbor Help System Core">setFullText: fullHelpText	fullText := fullHelpText isNil				ifTrue: [nil]				ifFalse: [fullHelpText asText]</body></methods><methods><class-id>VWHelp.AHSTextBinder</class-id> <category>printing</category><body package="Arbor Help System Core">storeOn: aStream 	"Store the receiver in the most economical way possible"	condensedText isNil ifTrue: [^ fullText storeOn: aStream].	aStream 		nextPut: $(;		nextPutAll: self class name;		nextPutAll: ' fullText: ';		store: fullText;		nextPutAll: ' condensedText: ';		store: condensedText;		nextPut: $)</body></methods><methods><class-id>VWHelp.AHSTextBinder class</class-id> <category>instance-creation</category><body package="Arbor Help System Core">fullText: statusText  condensedText: balloonText	^self new		setFullText: statusText;		setCondensedText: balloonText</body><body package="Arbor Help System Core">helpText: aText	"Answer a new instance of the receiver.  Set the status pane text and the balloon text to the same value."	^self 		fullText: aText 		condensedText: nil</body></methods><methods><class-id>VWHelp.AHSHelpInfo</class-id> <category>enumerating</category><body package="Arbor Help System Core">allHelpDataDo: aBlock	"Visit each AHSHelpData"	self data do:  [:widgetDict |		widgetDict do: [:stateDict |			stateDict do: [:helpData |				aBlock value: helpData]]]</body></methods><methods><class-id>VWHelp.AHSHelpInfo</class-id> <category>accessing-reading</category><body package="Arbor Help System Core">classNames	"Answer the class names for all languages"	^self data keys</body><body package="Arbor Help System Core">helpTextForID: id state: state className: className	^self		helpTextForID: id		state: state		className: className		language: AHSStorageManager currentLanguage</body><body package="Arbor Help System Core">helpTextForID: id state: state className: className language: lang 	^self		helpTextForID: id		state: state		className: className		language: lang		mayDefault: true</body><body package="Arbor Help System Core">helpTextForID: id state: state className: className language: lang mayDefault: aBoolean 	"If aBoolean is true, then may look for help in default if any"		^(self helpDataForClassName: className		widgetID: id		state: state		ifAbsent: [^nil]) textAt: (self indexForLanguage: lang)</body><body package="Arbor Help System Core">outlineLinkForID: id state: state className: className 	^self		outlineLinkForID: id		state: state		className: className		language: AHSStorageManager currentLanguage</body><body package="Arbor Help System Core">outlineLinkForID: idSymbol state: stateSymbol className: className language: languageSymbol	^self		outlineLinkForID: idSymbol		state: stateSymbol		className: className		language: languageSymbol		mayDefault: true</body><body package="Arbor Help System Core">outlineLinkForID: id state: state className: className language: lang mayDefault: aBoolean	^(self helpDataForClassName: className		widgetID: id		state: state		ifAbsent: [^nil]) outlineLinkAt: (self indexForLanguage: lang)</body></methods><methods><class-id>VWHelp.AHSHelpInfo</class-id> <category>protected</category><body package="Arbor Help System Core">data	^data</body></methods><methods><class-id>VWHelp.AHSHelpInfo</class-id> <category>private</category><body package="Arbor Help System Core">data: dict	data := dict</body><body package="Arbor Help System Core">helpDataForClassName: className widgetID: id state: state ifAbsent: aBlock 	^((self data at: className ifAbsent: [^aBlock value])				at: id ifAbsent: [^aBlock value])					at: state ifAbsent: [^aBlock value]</body><body package="Arbor Help System Core">helpDataForClassName: className widgetID: id state: state lang: aSymbol ifAbsent: aBlock 	| hd langIndex |	hd := ((self data 			at: className 			ifAbsent: [^aBlock value]) 				at: id 				ifAbsent: [^aBlock value])					at: state 					ifAbsent: [^aBlock value].	langIndex := self indexForLanguage: aSymbol.	^ AHSHelpData		texts: (hd textAt: langIndex)		outlineLinks: (hd outlineLinkAt: langIndex)</body><body package="Arbor Help System Core">includesClass: aClassName	"Private - Answer true if we have information pertaining to aClassName in our database."	^ self data		includesKey: aClassName</body><body package="Arbor Help System Core">languages: langs	languages := langs</body></methods><methods><class-id>VWHelp.AHSHelpInfo</class-id> <category>testing</category><body package="Arbor Help System Core">haveClass: className widgetID: id state: state	^ (self helpDataForClassName: className		widgetID: id		state: state		ifAbsent: [nil]) notNil</body></methods><methods><class-id>VWHelp.AHSHelpInfo</class-id> <category>languages</category><body package="Arbor Help System Core">indexForLanguage: lang	^self languages indexOf: lang</body><body package="Arbor Help System Core">languages	^languages</body></methods><methods><class-id>VWHelp.AHSHelpInfo</class-id> <category>initialize-release</category><body package="Arbor Help System Core">initialize	languages := Array with: AHSStorageManager currentLanguage.	data := AHSPersistentDictionary new</body></methods><methods><class-id>VWHelp.AHSHelpInfo class</class-id> <category>instance creation</category><body package="Arbor Help System Core">languages: langs data: dict	^self basicNew		languages: langs;		data: dict</body><body package="Arbor Help System Core">new	^super new initialize</body></methods><methods><class-id>VWHelp.AHSTranslationTextBinder</class-id> <category>comparing</category><body package="Arbor Help System Core">= textOrTextBinder	"Compare the receiver to textOrTextBinder.  A textOrTextBinder can be a regular text binder, a translation text binder, a regular text or a translation text."	| testBinder |	textOrTextBinder isNil ifTrue: [^ false].	testBinder := textOrTextBinder asAHSTextBinder asTranslationText.	^ self fullText = testBinder fullText and: [self condensedText = testBinder condensedText].</body></methods><methods><class-id>VWHelp.AHSTranslationTextBinder</class-id> <category>converting</category><body package="Arbor Help System Core">asTranslationText	^ self</body></methods><methods><class-id>VWHelp.AHSTranslationTextBinder</class-id> <category>private-accessing</category><body package="Arbor Help System Core">setCondensedText: condensedHelpText	condensedText := condensedHelpText isNil							ifTrue: [nil]							ifFalse: [condensedHelpText asTranslationText]</body><body package="Arbor Help System Core">setFullText: fullHelpText	fullText := fullHelpText isNil				ifTrue: [nil]				ifFalse: [fullHelpText asTranslationText]</body></methods><methods><class-id>VWHelp.AHSTranslationTextBinder</class-id> <category>accessing</category><body package="Arbor Help System Core">translated	| result |	result := fullText isNil				ifTrue: [true]				ifFalse: [fullText translated].	^ result and: [condensedText isNil					ifTrue: [true]					ifFalse: [condensedText translated]].</body><body package="Arbor Help System Core">translated: aBoolean	fullText isNil ifFalse: [fullText translated: aBoolean].	condensedText isNil ifFalse: [condensedText translated: aBoolean]</body></methods><methods><class-id>VWHelp.AHSCacheHelpInfo</class-id> <category>enumerating</category><body package="Arbor Help System Core">allHelpDataDo: aBlock	"Visit each AHSHelpData"	self fillCache.	super allHelpDataDo: aBlock</body></methods><methods><class-id>VWHelp.AHSCacheHelpInfo</class-id> <category>accessing-reading</category><body package="Arbor Help System Core">classNames	"Answer all known class names with help data"	| classNames envyKeys |	classNames := super classNames.	AHSStorageManager widgetSource == #Envy ifTrue: [		envyKeys := (AHSStorageManager envyRepositoryApp editionRecord							inheritedUserFields asDictionary keys reject: [:ky |								(ky asString findString: self class envyWidgetPrefix startingAt: 1) = 0])	 								collect: [:ky | ky copyFrom: self class envyWidgetPrefix size + 1 to: ky size].		classNames addAll: envyKeys].	classNames addAll: ((ApplicationModel allSubclasses select: [:cls|							(cls class includesSelector: self class helpDataSelector)								or: [cls ahsProcessorClass notNil]]) collect: [:cls | cls fullName]).	classNames add: #AHSStorageManager.	^classNames</body><body package="Arbor Help System Core">helpTextForID: idSymbol state: stateSymbol className: className language: languageSymbol mayDefault: aBoolean 	| text |	text := super				helpTextForID: idSymbol				state: stateSymbol				className: className				language: languageSymbol				mayDefault: aBoolean.	(aBoolean and: [text isNil and: [className ~~ #AHSStorageManager]])		ifTrue: ["use AHSStorageManager as a default"			text := self						helpTextForID: idSymbol						state: stateSymbol						className: #AHSStorageManager						language: languageSymbol						mayDefault: false].	^text</body><body package="Arbor Help System Core">outlineLinkForID: idSymbol state: stateSymbol className: className language: languageSymbol mayDefault: aBoolean 	| outlineLink |	outlineLink := super				outlineLinkForID: idSymbol				state: stateSymbol				className: className				language: languageSymbol				mayDefault: aBoolean.	(aBoolean and: [outlineLink isNil and: [className ~~ #AHSStorageManager]])		ifTrue: ["use AHSStorageManager as a default"			outlineLink := self						outlineLinkForID: idSymbol						state: stateSymbol						className: #AHSStorageManager						language: languageSymbol						mayDefault: false].	^outlineLink</body></methods><methods><class-id>VWHelp.AHSCacheHelpInfo</class-id> <category>private</category><body package="Arbor Help System Core">collectInstalledLanguages	^(AHSStorageManager perform: self class helpDataSelector) languages</body><body package="Arbor Help System Core">fillCache	"If there is any data not in the cache, fill it now"	self classNames do: [:className |		self fillCacheFor: className]</body><body package="Arbor Help System Core">fillCacheFor: className	(self data keys includes: className) ifTrue: [^ self].	AHSStorageManager widgetSource == #Envy ifTrue: 		[self installFromEnvy: className.		(self data keys includes: className) ifTrue: [^ self]].	self installFromClassMethod: className.</body><body package="Arbor Help System Core">helpDataForClassName: className widgetID: id state: state ifAbsent: aBlock 	self fillCacheFor: className.	^ super		helpDataForClassName: className		widgetID: id		state: state		ifAbsent: aBlock</body></methods><methods><class-id>VWHelp.AHSCacheHelpInfo</class-id> <category>flushing</category><body package="Arbor Help System Core">flush	data := AHSPersistentDictionary new</body><body package="Arbor Help System Core">flushClassName: aClassName	self data removeKey: aClassName ifAbsent: []</body></methods><methods><class-id>VWHelp.AHSCacheHelpInfo</class-id> <category>initialize-release</category><body package="Arbor Help System Core">initialize	super initialize.	languages := self collectInstalledLanguages asSet asSortedCollection asArray</body></methods><methods><class-id>VWHelp.AHSCacheHelpInfo</class-id> <category>database</category><body package="Arbor Help System Core">installFromClassMethod: className	"Answer the help data loaded from the method or nil if not available"	|classData |	classData := self loadFromClassMethod: className.	classData notNil ifTrue: 		[classData 			installInto: self 			className: className].	^classData</body><body package="Arbor Help System Core">loadFromClassMethod: className	"Answer the help data loaded from the method or nil if not available"	|cls classData |	cls := className asQualifiedReference valueOrDo: [^nil].	classData := (cls respondsTo: self class helpDataSelector)		ifTrue: [cls perform: self class helpDataSelector].	^classData notNil		ifTrue: [classData convertToLanguages: self languages]</body></methods><methods><class-id>VWHelp.AHSCacheHelpInfo class</class-id> <category>class constants</category><body package="Arbor Help System Core">envyWidgetKey: className	^self envyWidgetPrefix , className</body><body package="Arbor Help System Core">envyWidgetPrefix	^'ahs30.'</body><body package="Arbor Help System Core">helpDataSelector	^#ahsHelpData</body></methods><methods><class-id>VWHelp.ArborTextAttributes</class-id> <category>private</category><body package="Arbor Help System Core">actualTextHeightFor: aFontDescription	"Answer the actual text height for the font fetched.  This may or may not be equal to the requested 'pixelSize'.  Some platforms include whitespace above and below font glyphs as part of the pixelSize (MSWindows) while others do not (X-Windows).  The actual size is calculated by displaying the font on an off-screen pixmap, then scanning the result to find the highest ascent and lowest descent and subtracting the difference.  As a result, this calculation may take several seconds for large fonts."	| pix gc image topRowIndex bottomRowIndex font testString blackValue |	font := Screen default defaultFontPolicy				findFont: aFontDescription copy.		"Use a copy or strange stuff happens."	"First, get the actual color of 'black' (usually zero, but you never know...')"	pix := Pixmap extent: 1@1.	pix graphicsContext		paint: ColorValue black;		displayRectangle: pix bounds.	image := (pix contentsOfArea: pix bounds) first.	blackValue := image atPoint: 0@0.	"Display the string on a pixmap, then scan the image to find the actual height of the text."	testString := 'gjplX'.	pix := Pixmap			extent: ((testString inject: 0 into: [:sum :ch | sum + (font widthOf: ch)]) max: 1)						@ (font ascent + font descent).	gc := pix graphicsContext.	gc		paint: ColorValue white;		displayRectangle: pix bounds;		paint: ColorValue black;		font: font;		displayString: testString at: 0 @ gc font ascent.	image := (pix contentsOfArea: pix bounds) first.	topRowIndex := 0.	[	((image rowAt: topRowIndex) detect: [:i | i = blackValue] ifNone: [nil]) isNil			and: [(topRowIndex := topRowIndex + 1) &lt; image height]]  whileTrue.	bottomRowIndex := image height - 1.	[	((image rowAt: bottomRowIndex) detect: [:i | i = blackValue] ifNone: [nil]) isNil			and: [(bottomRowIndex := bottomRowIndex - 1) &gt;= 0]]  whileTrue.	^(bottomRowIndex - topRowIndex + 1) max: 0</body></methods><methods><class-id>VWHelp.ArborTextAttributes</class-id> <category>system startup</category><body package="Arbor Help System Core">flushGridding	"Instead of the laissez faire style that VW 2.5 uses by default, coerce the font to do a lookup now.  This is done primarily to be sure that the instances stored in the TextStyles have had their FontDescriptions properly regenerated so that a recalculation is not necessary every time the image is started as it can be quite slow."	self updateLineGridding.</body><body package="Arbor Help System Core">install	"This is generally sent when some attribute has been changed and recomputation must take place.  Nil out the platform so that the #updateBasedOn: method will not be short-circuited."	self platform: nil.	super install.</body><body package="Arbor Help System Core">updateLineGridding	"VW 2.5 &amp; 3.0"	self updateLineGridding: (fontPolicySource isNil								ifTrue: [Screen default defaultFontPolicy]								ifFalse: [fontPolicySource]).</body><body package="Arbor Help System Core">updateLineGridding: aFontPolicy	"Update the text attributes so that the fetched font matches (in reality) the requested pixel size.  Do not update the font if the platform has not changed.  The font update is a relatively slow process, so this will make image startup time significantly less.  The down side is that if the platform is the same but does not have the same fonts installed, then a re-lookup may be necessary and will not occur."	| font fontD size failures |	self platform = OSHandle currentPlatformID ifTrue: [^self].	self platform: OSHandle currentPlatformID.	fontD := self defaultFontFor: aFontPolicy.	fontD pixelSize: self truePixelSize.	characterAttributes		setDefaultQuery: fontD for: aFontPolicy;		invalidateQueryCache.	size := self actualTextHeightFor: fontD.	failures := 0.	[size &lt; self truePixelSize and: [(failures := failures + 1) &lt; 10]] whileTrue: [		fontD pixelSize: fontD pixelSize + 1.		characterAttributes			setDefaultQuery: fontD for: aFontPolicy;			invalidateQueryCache.		size := self actualTextHeightFor: fontD].	failures := 0.	[size &gt; self truePixelSize and: [(failures := failures + 1) &lt; 10]] whileTrue: [		(fontD pixelSize &gt; 1)		ifTrue:		[fontD pixelSize: fontD pixelSize - 1.		characterAttributes			setDefaultQuery: fontD for: aFontPolicy;			invalidateQueryCache.		size := self actualTextHeightFor: fontD]].	font := aFontPolicy findFont: (self fontAt: fontAttributeForLeading for: aFontPolicy) copy.	baseline := font ascent + topLeading.	lineGrid := font height + bottomLeading + topLeading.</body></methods><methods><class-id>VWHelp.ArborTextAttributes</class-id> <category>initialize-release</category><body package="Arbor Help System Core">initialize	super initialize.	self truePixelSize: 12.	"Will be overridden later."</body></methods><methods><class-id>VWHelp.ArborTextAttributes</class-id> <category>accessing</category><body package="Arbor Help System Core">platform	^platform</body><body package="Arbor Help System Core">platform: aPlatformString	platform := aPlatformString.</body><body package="Arbor Help System Core">scalingFactor: aNumber 	"Set the scaling factor. This controls how large the default font will be, relative 	to the system default font size."	aNumber = 1		ifTrue: [super scalingFactor: aNumber]		ifFalse: [self error: self class name, ' does not scale.'].</body><body package="Arbor Help System Core">truePixelSize	^truePixelSize</body><body package="Arbor Help System Core">truePixelSize: aSmallInteger	truePixelSize := aSmallInteger.</body></methods><methods><class-id>VWHelp.ArborTextAttributes class</class-id> <category>class initialization</category><body package="Arbor Help System Core">addAttributeOfSize: aSmallInteger named: aSymbol	"Create a new instance of ArborTextAttributes whose font size is aSmallInteger.  Add the new instance into the TextStyles dictionary, registered under the name aSymbol."	| style cStyle |	cStyle := CharacterAttributes newWithDefaultAttributes.	cStyle setDefaultQuery: (FontDescription new								family: #('helv' 'helvetica' 'arial' '*');								manufacturer: #('adobe' '*');								fixedWidth: false;								serif: false;								italic: false;								boldness: 0.5;								pixelSize: aSmallInteger "The actual value will be set later").	(style := self characterAttributes: cStyle)		truePixelSize: aSmallInteger;		install.	self styleNamed: aSymbol put: style.</body><body package="Arbor Help System Core">initialize	"ArborTextAttributes initialize."	Cursor wait showWhile: [| squish |		#(8 9 10 12 14 16 18 20) do: [:pixelSize || sizeString |			(sizeString := pixelSize printString) size = 1				ifTrue: [sizeString := '0', sizeString].			self				addAttributeOfSize: pixelSize				named: ('Arbor-', sizeString) asSymbol].		"Add extra 12- and 14-pixel fonts whose line grid is based on #normal instead of #large (good for lists, etc.)."		squish := (self styleNamed: #'Arbor-12')							fontAttributeForLeading: #normal;							topLeading: 0;							bottomLeading: 0.		squish install.		self styleNamed: #'Arbor-12-Squeeze' put: squish.		squish := (self styleNamed: #'Arbor-14')							fontAttributeForLeading: #normal;							topLeading: 0;							bottomLeading: 0.		squish install.		self styleNamed: #'Arbor-14-Squeeze' put: squish].</body><body package="Arbor Help System Core">obsolete	self removeStyles.	super obsolete.</body><body package="Arbor Help System Core">removeStyles	"Remove all styles based on ArborTextAttributes.  Also flush the font cache to get rid of references that are held through cached font references."	"ArborTextAttributes removeStyles"	TextStyles copy keysAndValuesDo: [:styleName :style |		style class = self ifTrue: [self removeStyleNamed: styleName ifAbsent: []]].	Screen default defaultFontPolicy flushFonts.</body></methods><methods><class-id>VWHelp.ArborTextAttributes class</class-id> <category>utility</category><body package="Arbor Help System Core">refreshInstances	"Coerce an immediate refresh of all instances to rebind them to local fonts."	"self refreshInstances"	self allInstancesDo: [:inst | inst platform: nil].	self allSubInstancesDo: [:inst | inst platform: nil].	super flushGridding.</body></methods><methods><class-id>VWHelp.AHSTranslationText</class-id> <category>comparing</category><body package="Arbor Help System Core">= aText	"Can't use AHSUtils&gt;&gt;text:equals: because that checks the species."	^(aText isKindOf: #{Smalltalk.Text} value)		and: [self translated = aText translated		and: [self string = aText string		and: [AHSUtils runArray: self runs equals: aText runs]]]</body></methods><methods><class-id>VWHelp.AHSTranslationText</class-id> <category>converting</category><body package="Arbor Help System Core">asAHSTextBinder	"Answer an AHSTranslationTextBinder object initialized from the receiver."	^AHSTranslationTextBinder helpText: self</body><body package="Arbor Help System Core">asTranslationText	^self</body></methods><methods><class-id>VWHelp.AHSTranslationText</class-id> <category>printing</category><body package="Arbor Help System Core">storeOn: aStream 	"Append to the argument aStream a sequence of characters that is an expression 	whose evaluation creates text similar to the receiver."		"Handle degenerate case economically"	self translated		ifTrue: [^super storeOn: aStream].	(self runs hasChange not and: [self runs first isNil])		ifTrue: [aStream nextPutAll: '(';					store: self string;					nextPutAll: ' asTranslationText translated: false)']		ifFalse: [aStream nextPutAll: '((AHSTranslationText string: ';					store: string;					nextPutAll: ' runs: ';					store: runs;					nextPut: $);					nextPutAll: ' translated: false)']</body></methods><methods><class-id>VWHelp.AHSTranslationText</class-id> <category>accessing</category><body package="Arbor Help System Core">translated	^translated isNil ifTrue: [true] ifFalse: [translated]</body><body package="Arbor Help System Core">translated: aBoolean	translated := aBoolean.	self odbDirty</body></methods><methods><class-id>VWHelp.AHSPreferences</class-id> <category>private</category><body package="Arbor Help System Core">closeAccept	self triggerChannel value: true.	^super closeAccept</body></methods><methods><class-id>VWHelp.AHSPreferences</class-id> <category>initialize-release</category><body package="Arbor Help System Core">initialize	super initialize.	self triggerChannel: nil asValue.</body></methods><methods><class-id>VWHelp.AHSPreferences</class-id> <category>interface opening</category><body package="Arbor Help System Core">postBuildWith: aBuilder	| canvas diff |	aBuilder window model ~= self ifTrue: [^self].	"Make the components do a layout, then adjust the window size so it's juuuuust right."	aBuilder composite bounds: (0@0 extent: aBuilder windowSpec bounds extent).	canvas := aBuilder componentAt: #dynamicallyGeneratedSubcanvas.	diff := canvas preferredBounds height - canvas bounds height.	aBuilder window changeExtent: (aBuilder windowSpec bounds extent + (0@diff)).</body></methods><methods><class-id>VWHelp.AHSPreferences</class-id> <category>binding</category><body package="Arbor Help System Core">specificationFor: aSymbol	^aSymbol = #dynamicallyGeneratedSpec		ifTrue: [self class dynamicallyGeneratedSpecForTrigger: self triggerChannel]		ifFalse: [super specificationFor: aSymbol]</body></methods><methods><class-id>VWHelp.AHSPreferences</class-id> <category>accessing</category><body package="Arbor Help System Core">triggerChannel	^triggerChannel</body><body package="Arbor Help System Core">triggerChannel: aValueModel	triggerChannel := aValueModel.</body></methods><methods><class-id>VWHelp.AHSPreferences class</class-id> <category>help info (AHS)</category><body package="Arbor Help System Core">arborHelpEnabled	^true</body></methods><methods><class-id>VWHelp.AHSPreferences class</class-id> <category>interface specs</category><body package="Arbor Help System Core">dynamicallyGeneratedSpecForTrigger: aTrigger	"Dynamically build a subCanvas spec from the list of available configuration specs."	| fullSpec windowSpec top subs |	fullSpec := FullSpec new.	windowSpec := WindowSpec label: 'Dynamic spec'.	fullSpec		window: windowSpec;		component: SpecCollection new.	top := 0.	subs := OrderedCollection new.	(self preferenceAt: #preferenceSpecs) do: [:assoc || spec subCanvasSpec layout |		spec := assoc key asQualifiedReference value interfaceSpecFor: assoc value.		spec notNil ifTrue: [			layout := spec window bounds asLayout.			layout				leftFraction: 0 offset: 0;				rightFraction: 1 offset: 0;				topFraction: 0 offset: top;				bottomFraction: 0 offset: (top := top + spec window bounds height).			subCanvasSpec := SubCanvasSpec new.			subCanvasSpec				hasBorder: false;				clientKey: (assoc key asQualifiedReference value newWithTrigger: aTrigger);				majorKey: assoc key;				minorKey: assoc value;				layout: layout.			subs add: subCanvasSpec]].	fullSpec component collection: subs asArray.	^fullSpec</body></methods><methods><class-id>VWHelp.AHSPreferences class</class-id> <category>class initialization</category><body package="Arbor Help System Core">initialize	"self initialize"	Preferences isNil ifTrue: [self initializePreferences].	"Set up UISettings"	UISettings addPreferenceSection: #addAHSSectionTo:development:runtime:.</body><body package="Arbor Help System Core">initializePreferences	Preferences := Dictionary new.	self		preferenceAt: #preferenceSpecs		put: (SortedCollection sortBlock: [:a1 :a2 | a1 value &lt; a2 value or: [a1 value = a2 value and: [a1 key &lt; a2 key]]]).</body><body package="Arbor Help System Core">obsolete	UISettings removePreferenceSection: #addAHSSectionTo:development:runtime:.	super obsolete.</body></methods><methods><class-id>VWHelp.AHSPreferences class</class-id> <category>accessing</category><body package="Arbor Help System Core">preferenceAt: aSymbol	^self preferences at: aSymbol</body><body package="Arbor Help System Core">preferenceAt: aSymbol ifAbsent: aBlock	^self preferences at: aSymbol ifAbsent: aBlock</body><body package="Arbor Help System Core">preferenceAt: aSymbol put: aValue	^self preferences at: aSymbol put: aValue</body></methods><methods><class-id>VWHelp.AHSPreferences class</class-id> <category>protected</category><body package="Arbor Help System Core">preferences	"In general, the #preferenceAt: and #preferenceAt:put: methods should be used by 'outsiders'."	Preferences isNil ifTrue: [self initializePreferences].	^Preferences</body></methods><methods><class-id>VWHelp.AHSHelpClassData</class-id> <category>comparing</category><body package="Arbor Help System Core">= anAHSHelpClassData	self languages ~= anAHSHelpClassData languages		ifTrue: [^false].	self widgetData keys asSortedCollection			~= anAHSHelpClassData widgetData keys asSortedCollection		ifTrue: [^false].	self widgetData keysAndValuesDo: [:id :stateDict |		|stateDict2|		stateDict2 := anAHSHelpClassData widgetData at: id.		stateDict keys asSortedCollection ~= stateDict2 keys asSortedCollection			ifTrue: [^false].		stateDict keysAndValuesDo: [:state :helpData |			|helpData2|			helpData2 := stateDict2 at: state.			helpData ~= helpData2				ifTrue: [^false]]].	^true</body></methods><methods><class-id>VWHelp.AHSHelpClassData</class-id> <category>private</category><body package="Arbor Help System Core">addWidgetData: assocArray	"This method is invoked when the help is stored as multiple methods (due to the Smalltalk Compiler's 256 literal limit) and is being rebuilt."	self widgetData addAll: assocArray.</body><body package="Arbor Help System Core">widgetData: anAHSPersistentDictionary	widgetData := anAHSPersistentDictionary</body></methods><methods><class-id>VWHelp.AHSHelpClassData</class-id> <category>installing</category><body package="Arbor Help System Core">convertToLanguages: langArray	"Convert data to match langArray"	| copy |	self languages = langArray		ifTrue: [^self].	copy := self copy.	copy languages: langArray copy.	self widgetData keysAndValuesDo: [:widgetID :stateDict |			stateDict keysAndValuesDo: [:state :helpData |				|copyHelpData|				copyHelpData := (copy widgetData at: widgetID) at: state.				copyHelpData setTexts: nil outlineLinks: nil.				copy languages do: [:lang |					(langArray includes: lang)						ifTrue: [copyHelpData textAt:										(copy indexForLanguage: lang)									put: (helpData textAt:											(self indexForLanguage: lang)).								copyHelpData outlineLinkAt:										(copy indexForLanguage: lang)									put: (helpData outlineLinkAt:											(self indexForLanguage: lang))]]]].	^copy</body><body package="Arbor Help System Core">installInto: aHelpInfo className: className	"Make sure the languages match at this point"	self languages = aHelpInfo languages		ifFalse: [^(self convertToLanguages: aHelpInfo languages)						installInto: aHelpInfo						className: className].	aHelpInfo data at: className put: self widgetData</body></methods><methods><class-id>VWHelp.AHSHelpClassData</class-id> <category>accessing</category><body package="Arbor Help System Core">indexForLanguage: lang	^self languages indexOf: lang</body><body package="Arbor Help System Core">languages	^languages</body><body package="Arbor Help System Core">widgetData	^widgetData</body></methods><methods><class-id>VWHelp.AHSHelpClassData</class-id> <category>initialize-release</category><body package="Arbor Help System Core">initialize	languages := Array new.	widgetData := AHSPersistentDictionary new</body><body package="Arbor Help System Core">languages: anArray	languages := anArray</body><body package="Arbor Help System Core">setLanguages: anArray widgetData: anAHSPersistentDictionary	self 		languages: anArray;		widgetData: anAHSPersistentDictionary</body></methods><methods><class-id>VWHelp.AHSHelpClassData</class-id> <category>copying</category><body package="Arbor Help System Core">postCopy	languages := languages copy.	widgetData := AHSPersistentDictionary withAll:					(widgetData associations						collect: [:assn |							assn key "widgetID"-&gt;(AHSPersistentDictionary withAll:								(assn value associations collect: [:assn2 |									assn2 key "state"-&gt;assn2 value copy]))])</body></methods><methods><class-id>VWHelp.AHSHelpClassData</class-id> <category>printing</category><body package="Arbor Help System Core">storeOn: aStream	aStream nextPutAll: '(AHSHelpClassData languages: ';		store: self languages;		nextPutAll: ' widgetData: ';		store: self widgetData;		nextPut: $)</body></methods><methods><class-id>VWHelp.AHSHelpClassData class</class-id> <category>instance creation</category><body package="Arbor Help System Core">languages: anArray widgetData: anAHSPersistentDictionary	^self new		setLanguages: anArray		widgetData: anAHSPersistentDictionary</body></methods><methods><class-id>VWHelp.AHSStorageManager class</class-id> <category>help info (AHS)</category><body package="Arbor Help System Core">ahsHelpData	^(AHSHelpClassData languages: #(#English) widgetData: ((AHSPersistentDictionary new)	 add: (#accept -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Accept all changes and close the window' runs: (RunArray runs: #(39) values: #(nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#cancel -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Discard all changes and close this window' runs: (RunArray runs: #(41) values: #(nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#ahsFlag -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Use this check box to toggle help info on and off.' runs: (RunArray runs: #(50) values: #(nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#ahsNoHelpFor -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'No Help For %s' runs: (RunArray runs: #(14) values: #(nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#ahsBackground -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Move cursor over an item for help information' runs: (RunArray runs: #(45) values: #(nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#HELPOFF -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Help is currently disabled.' runs: (RunArray runs: #(27) values: #(nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#ahsText -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Move the cursor over another item to see help info about that item appear in this area.' runs: (RunArray runs: #(87) values: #(nil))); yourself) outlineLinks: #(nil))); yourself)); yourself))</body></methods><methods><class-id>VWHelp.AHSStorageManager class</class-id> <category>class accessing</category><body package="Arbor Help System Core">allowEditing	^self allowEditingModel value</body><body package="Arbor Help System Core">allowEditingModel	^AllowEditingModel</body><body package="Arbor Help System Core">envyRepositoryApp	^#{ArborHelpRepositoryApp} valueOrDo: [nil]</body><body package="Arbor Help System Core">widgetSource	^WidgetSource value</body><body package="Arbor Help System Core">widgetSource: aBoolean	WidgetSource value: aBoolean</body><body package="Arbor Help System Core">widgetSourceModel	^WidgetSource</body></methods><methods><class-id>VWHelp.AHSStorageManager class</class-id> <category>class initialization</category><body package="Arbor Help System Core">cleanUp	"Private - Reset the class to a 'clean' state.  A clean state means that the class is not holding onto any residual objects.  This method would typically be called from ENVY just before the class is unloaded."	self currentHelpCache: nil.	AllowEditingModel := ValueHolder with: false.	CurrentLanguage := ValueHolder with: self currentLanguage.	WidgetSource := ValueHolder with: #Memory.	OutlineSource := ValueHolder with: #File.</body><body package="Arbor Help System Core">initialize	"self initialize"	| cls |	CurrentLanguage := (AHSWHCWeakValueHolder with: #English).	self currentHelpCache: AHSCacheHelpInfo new.	OutlineSource := AHSWHCWeakValueHolder with: #File.	WidgetSource := AHSWHCWeakValueHolder with: #Image.	segStack := OrderedCollection new.	cls := AHSWHCProcessor outlinerClass.	AllowEditingModel := AHSWHCWeakValueHolder with: (cls notNil and: [cls classForEditing notNil])</body></methods><methods><class-id>VWHelp.AHSStorageManager class</class-id> <category>widget help</category><body package="Arbor Help System Core">currentHelpCache	^ HelpDictionaries</body><body package="Arbor Help System Core">currentHelpCache: anAHSHelpInfo	anAHSHelpInfo class == AHSHelpInfo		ifTrue: 			[HelpDictionaries := AHSCacheHelpInfo									languages: anAHSHelpInfo languages									data: anAHSHelpInfo data]		ifFalse: [HelpDictionaries := anAHSHelpInfo]</body><body package="Arbor Help System Core">flushAllHelp	"flush the help dictionaries class variable"	"self flushAllHelp"	self currentHelpCache flush</body><body package="Arbor Help System Core">flushHelpForLanguage: aLanguage	"flush the help dictionary for aLanguage	on the HelpDictionaries class variable."	"self flushHelpForLanguage: #English"	self currentHelpCache		flushLanguage: aLanguage</body><body package="Arbor Help System Core">flushHelpForLanguage: aLanguage onClass: aClass	"flush the help dictionary for aLanguage for aClass"	self currentHelpCache			flushClassName: aClass fullName			language: aLanguage</body></methods><methods><class-id>VWHelp.AHSStorageManager class</class-id> <category>languages</category><body package="Arbor Help System Core">currentLanguage	^CurrentLanguage value</body><body package="Arbor Help System Core">currentLanguage: lang	CurrentLanguage value: lang</body><body package="Arbor Help System Core">currentLanguageModel	^CurrentLanguage</body><body package="Arbor Help System Core">installedLanguages	^self currentHelpCache languages</body><body package="Arbor Help System Core">otherAvailableLanguages	| current |	current := self currentLanguage.	^ self installedLanguages reject: [:each | each = current].</body></methods><methods><class-id>VWHelp.AHSStorageManager class</class-id> <category>testing</category><body package="Arbor Help System Core">envyAvailable	^self hasEnvy		and: [(#{SubApplication} value respondsTo: #objectNamed:)		and: [self envyRepositoryApp notNil]]</body><body package="Arbor Help System Core">gemStoneAvailable	"Answer whether GemStone is installed and in a session"	^(#{GSI} valueOrDo: [^false]) isLoggedIn</body><body package="Arbor Help System Core">hasEnvy	"Make a best guess as to whether or not we are using Envy"	^AHSUtils hasEnvy</body><body package="Arbor Help System Core">isSourceAvailable: aSource	"Checks whether aSource is available for use in this system.	Image and files are assumed to be always available."	aSource == #Image ifTrue: [^true].	aSource == #File ifTrue: [^true].	aSource == #GemStone ifTrue: [^self gemStoneAvailable].	aSource == #Versant ifTrue: [^self versantAvailable].	aSource == #Envy ifTrue: [^self envyAvailable].	^false</body><body package="Arbor Help System Core">versantAvailable	"Answer whether Versant is installed and in a session"	^(#{ODBInterface} valueOrDo: [^false]) inSession</body></methods><methods><class-id>VWHelp.AHSStorageManager class</class-id> <category>private</category><body package="Arbor Help System Core">segStack	^segStack</body></methods><methods><class-id>VWHelp.AHSPreferencesModel</class-id> <category>private</category><body package="Arbor Help System Core">adapt: anAspect for: aSubject	^self bufferForSubject: ((AspectAdaptor forAspect: anAspect) subject: aSubject)</body><body package="Arbor Help System Core">adaptPreference: aPrefKey	"Ensure the key exists by getting and setting the value."	AHSPreferences		perform: (aPrefKey, ':') asSymbol		with: (AHSPreferences perform: aPrefKey).	^self bufferForSubject: ((IndexedAdaptor subject: AHSPreferences preferences) forIndex: aPrefKey)</body><body package="Arbor Help System Core">bufferForSubject: aSubject	^BufferedValueHolder		subject: aSubject		triggerChannel: self triggerChannel</body></methods><methods><class-id>VWHelp.AHSPreferencesModel</class-id> <category>accessing</category><body package="Arbor Help System Core">triggerChannel	triggerChannel isNil ifTrue: [^self error: 'Trigger is undefined!'].	^triggerChannel</body><body package="Arbor Help System Core">triggerChannel: aValueHolder	triggerChannel := aValueHolder.</body></methods><methods><class-id>VWHelp.AHSPreferencesModel class</class-id> <category>utility</category><body package="Arbor Help System Core">addPreferenceSpec: aSpecName	self removePreferenceSpec: aSpecName.	(AHSPreferences preferenceAt: #preferenceSpecs)		add: self name -&gt; aSpecName.</body><body package="Arbor Help System Core">preferenceSpecs	"Get the specs if possible.  Fetching the specs will fail when the class is being removed and AHSPreferences has already been removed, so the roundabout &amp; safe approach is used here."	^#{AHSPreferences} isDefined		ifTrue: [AHSPreferences preferenceAt: #preferenceSpecs]		ifFalse: [#()]</body><body package="Arbor Help System Core">removeAllPreferenceSpecs	"Clean out all specs defined in AHSPreferences for myself."	| prefs |	prefs := self preferenceSpecs.	(prefs select: [:assoc | assoc key = self name])		do: [:assoc | prefs remove: assoc].</body><body package="Arbor Help System Core">removePreferenceSpec: aSpecName	self preferenceSpecs asOrderedCollection remove: self name -&gt; aSpecName ifAbsent: [].</body></methods><methods><class-id>VWHelp.AHSPreferencesModel class</class-id> <category>binding</category><body package="Arbor Help System Core">interfaceSpecFor: aSymbol 	"Return an actual specification object based on the named resource 	method."	| spec |	^(spec := self application specificationFor: aSymbol) isNil		ifTrue: [nil]		ifFalse: [UISpecification from: spec]</body></methods><methods><class-id>VWHelp.AHSPreferencesModel class</class-id> <category>instance creation</category><body package="Arbor Help System Core">newWithTrigger: aTrigger	^self new triggerChannel: aTrigger</body></methods><methods><class-id>VWHelp.AHSPreferencesModel class</class-id> <category>class initialization</category><body package="Arbor Help System Core">obsolete	self removeAllPreferenceSpecs.	super obsolete.</body></methods><methods><class-id>VWHelp.AHSCorePreferencesModel</class-id> <category>interface opening</category><body package="Arbor Help System Core">preBuildWith: aBuilder	super preBuildWith: aBuilder.	aBuilder		aspectAt: #showHelp			put: (self adapt: #helpEnabled for: AHSWHCProcessor);		aspectAt: #useWidgetHelp			put: (self adapt: #widgetHelpEnabled for: AHSWHCProcessor);		aspectAt: #useBalloonHelp			put: (self adapt: #balloonHelpEnabled for: AHSWHCProcessor).</body></methods><methods><class-id>VWHelp.AHSCorePreferencesModel class</class-id> <category>help info (AHS)</category><body package="Arbor Help System Core">ahsHelpData	^(AHSHelpClassData languages: #(#English) widgetData: ((AHSPersistentDictionary new)	 add: (#useWidgetHelp -&gt; ((AHSPersistentDictionary new)	 add: (#on -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Widget help display is active.  Uncheck this box to globally disable widget help display.' runs: (RunArray runs: #(89) values: #(nil))); yourself) outlineLinks: nil));	 add: (#disabled -&gt; (AHSHelpData texts: nil outlineLinks: nil));	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Widget help display is inactive.  Check this box to globally enable widget help display.' runs: (RunArray runs: #(88) values: #(nil))); yourself) outlineLinks: nil)); yourself));	 add: (#widgetHelpConfigGroupBox -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Adjust the settings for widget help in this section.' runs: (RunArray runs: #(52) values: #(nil))); yourself) outlineLinks: nil)); yourself));	 add: (#showHelp -&gt; ((AHSPersistentDictionary new)	 add: (#on -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Help lookup and dispatching is currently active.  Uncheck this box to globally disable all widget help lookup and processing.' runs: (RunArray runs: #(125) values: #(nil))); yourself) outlineLinks: nil));	 add: (#disabled -&gt; (AHSHelpData texts: nil outlineLinks: nil));	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Help lookup and dispatching is now inactive.  Check this box to globally enable all widget help lookup and processing.' runs: (RunArray runs: #(118) values: #(nil))); yourself) outlineLinks: nil)); yourself));	 add: (#useBalloonHelp -&gt; ((AHSPersistentDictionary new)	 add: (#on -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Balloon help display is active.  Uncheck this box to globally disable balloon help display.' runs: (RunArray runs: #(91) values: #(nil))); yourself) outlineLinks: nil));	 add: (#disabled -&gt; (AHSHelpData texts: nil outlineLinks: nil));	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Balloon help display is inactive.  Check this box to globally enable balloon help display.' runs: (RunArray runs: #(90) values: #(nil))); yourself) outlineLinks: nil)); yourself)); yourself))</body></methods><methods><class-id>VWHelp.AHSCorePreferencesModel class</class-id> <category>class initialization</category><body package="Arbor Help System Core">initialize	"self initialize"	self addPreferenceSpec: #coreConfigSpec.</body></methods><methods><class-id>VWHelp.AHSBalloonHelpPreferencesModel</class-id> <category>builder accessing</category><body package="Arbor Help System Core">balloonDisplayDelay	^ self builder aspectAt: #balloonDisplayDelay</body><body package="Arbor Help System Core">balloonKillDelay	^ self builder aspectAt: #balloonKillDelay</body></methods><methods><class-id>VWHelp.AHSBalloonHelpPreferencesModel</class-id> <category>interface opening</category><body package="Arbor Help System Core">preBuildWith: aBuilder	super preBuildWith: aBuilder.	aBuilder		aspectAt: #balloonDisplayDelay			put: (self adapt: #balloonDisplayDelay for: AHSWHCProcessor);		aspectAt: #balloonKillDelay			put: (self adapt: #balloonKillDelay for: AHSWHCProcessor);		aspectAt: #restrictBalloonToCondensedText			put: (self adapt: #restrictBalloonToCondensedText for: AHSWHCProcessor).</body></methods><methods><class-id>VWHelp.AHSBalloonHelpPreferencesModel class</class-id> <category>help info (AHS)</category><body package="Arbor Help System Core">ahsHelpData	^(AHSHelpClassData languages: #(#English) widgetData: ((AHSPersistentDictionary new)	 add: (#balloonKillValueField -&gt; ((AHSPersistentDictionary new)	 add: (#disabled -&gt; (AHSHelpData texts: nil outlineLinks: nil));	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'The number of milliseconds to wait before automatically closing an open balloon.' runs: (RunArray runs: #(80) values: #(nil))); yourself) outlineLinks: nil)); yourself));	 add: (#balloonHelpConfigGroupBox -&gt; ((AHSPersistentDictionary new)	 add: (#disabled -&gt; (AHSHelpData texts: nil outlineLinks: nil));	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Configure the settings for Ballon Help (sometimes referred to as "Bubble Help") in this section.' runs: (RunArray runs: #(96) values: #(nil))); yourself) outlineLinks: nil)); yourself));	 add: (#restrictBalloonToCondensedTextCB -&gt; ((AHSPersistentDictionary new)	 add: (#on -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Uncheck this box to show full help text in balloons.  If no specific condensed help then full help text will be used.' runs: (RunArray runs: #(117) values: #(nil))); yourself) outlineLinks: nil));	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Check this box to show only condensed help text in balloons.  If no condensed help, no balloon will open.' runs: (RunArray runs: #(105) values: #(nil))); yourself) outlineLinks: nil)); yourself));	 add: (#balloonDelayValueField -&gt; ((AHSPersistentDictionary new)	 add: (#disabled -&gt; (AHSHelpData texts: nil outlineLinks: nil));	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'The number of milliseconds that will elapse between when a widget is entered and the balloon pops up.' runs: (RunArray runs: #(101) values: #(nil))); yourself) outlineLinks: nil)); yourself)); yourself))</body></methods><methods><class-id>VWHelp.AHSBalloonHelpPreferencesModel class</class-id> <category>class initialization</category><body package="Arbor Help System Core">initialize	"self initialize"	self addPreferenceSpec: #balloonHelpConfigSpec.</body></methods><methods><class-id>VWHelp.AHSHelpData</class-id> <category>comparing</category><body package="Arbor Help System Core">= anAHSHelpData	^self class == anAHSHelpData class		and: [outlineLinks = anAHSHelpData outlineLinks				and: [texts notNil						ifTrue: [(texts collect: [:t |										t notNil											ifTrue: [t asTranslationText asAHSTextBinder]])									= (anAHSHelpData texts											collect: [:t |												t notNil													ifTrue: [t asTranslationText asAHSTextBinder]])]						ifFalse: [true]]]</body><body package="Arbor Help System Core">hash	^ (Array 			with: texts 			with: outlineLinks) hash</body></methods><methods><class-id>VWHelp.AHSHelpData</class-id> <category>private</category><body package="Arbor Help System Core">adjustCollection: aCollection minSize: anInteger	"Private - Answer a collection which can contain at least anInteger elements.	  Initialize the new collection with data from aCollection.  If aCollection is large	  enough, simply answer aCollection."	aCollection isNil ifTrue: [^ Array new: anInteger].	aCollection size &gt;= anInteger ifTrue: [^ aCollection].	^ (Array new: anInteger)		replaceFrom: 1		to: aCollection size		with: aCollection</body><body package="Arbor Help System Core">collection: aCollection at: anIndex put: aText assignMethod: settingMethodName	"Private - Put aText at anIndex.  Adjust aCollection as necessary before adding the	 element.  If a new collection is created. assign it to the proper instance variable by 	 using the given settingMethodName."	| theCollection |	theCollection := self 							adjustCollection: aCollection 							minSize: anIndex.	self 		perform: settingMethodName		with: theCollection.	theCollection 		at: anIndex 		put: aText.	theCollection odbDirty</body><body package="Arbor Help System Core">indexOutOfRange: anInteger for: aCollection	"Private - Answer true if anInteger is not a valid index in aCollection.  This method	covers the case where the collection is nil because nil answer 0 to size."	^ anInteger &lt;= 0 or: [anInteger &gt; aCollection size]</body><body package="Arbor Help System Core">outlineLinks	^outlineLinks</body><body package="Arbor Help System Core">setTexts: textsArray outlineLinks: outlineLinksArray	texts := textsArray.	outlineLinks := outlineLinksArray</body><body package="Arbor Help System Core">texts	^texts</body></methods><methods><class-id>VWHelp.AHSHelpData</class-id> <category>removing</category><body package="Arbor Help System Core">clearIndex: anIndex	"Nil out the slot"	self 		clearTextSlot: anIndex;		clearOutlineLinkSlot: anIndex.</body><body package="Arbor Help System Core">removeIndex: anIndex	"Remove the slot entirely"	self 		removeTextSlot: anIndex;		removeOutlineLinkSlot: anIndex.</body></methods><methods><class-id>VWHelp.AHSHelpData</class-id> <category>removing - private</category><body package="Arbor Help System Core">clearOutlineLinkSlot: anIndex	"Private - Clear the position indicated by anIndex in the outline links collection."	self outlineLinks: (self							clearSlot: anIndex							in: outlineLinks).</body><body package="Arbor Help System Core">clearSlot: anIndex in: aCollection	"Private - Answer a new collection with the given location cleared.  If an invalid	  index was given, or if the aCollection is nil, answer aCollection."	| newCollection |	(self 		indexOutOfRange: anIndex 		for: aCollection) ifTrue: [^ aCollection].	newCollection := aCollection copy.	newCollection		at: anIndex 		put: nil.	^ newCollection</body><body package="Arbor Help System Core">clearTextSlot: anIndex	"Private - Clear the position indicated by anIndex in the texts collection."	self texts: (self					clearSlot: anIndex					in: texts).</body><body package="Arbor Help System Core">removeOutlineLinkSlot: anInteger	"Private - Remove the slot in outline links indicated by anInteger."	self outlineLinks: (self							removeSlot: anInteger							in: outlineLinks).</body><body package="Arbor Help System Core">removeSlot: anInteger in: aCollection	"Private - Answer a new collection which represents aCollection with the slot	 identified by anInteger removed.  If the slot isn't removable, answer aCollection."	(self 		indexOutOfRange: anInteger 		for: aCollection) ifTrue: [^ aCollection].	^ (aCollection copyFrom: 1 to: anInteger - 1) ,		(aCollection size &gt; anInteger			ifTrue: 				[aCollection 					copyFrom: anInteger + 1					to: aCollection size]			ifFalse: [#()]).</body><body package="Arbor Help System Core">removeTextSlot: anInteger	"Private - Remove the slot in texts indicated by anInteger."	self texts: (self					removeSlot: anInteger					in: texts).</body></methods><methods><class-id>VWHelp.AHSHelpData</class-id> <category>adding</category><body package="Arbor Help System Core">insertIndex: anIndex	self 		insertTextSlot: anIndex;		insertOutlineLinkSlot: anIndex.	self odbDirty</body></methods><methods><class-id>VWHelp.AHSHelpData</class-id> <category>adding - private</category><body package="Arbor Help System Core">insertOutlineLinkSlot: anIndex	"Private - Insert a new position indicated by anIndex in the outline links collection."	outlineLinks := self insertSlot: anIndex in: outlineLinks.</body><body package="Arbor Help System Core">insertSlot: anIndex in: aCollection	"Private - Answer a new collection containing a new slot inserted at anIndex."	aCollection isNil ifTrue: [^ Array new: anIndex].	^ aCollection size &lt; anIndex		ifTrue: 			[(Array new: anIndex)				replaceFrom: 1 				to: aCollection size 				with: aCollection]		ifFalse: 			[(aCollection 				copyFrom: 1				to: anIndex - 1) ,			#(nil) ,			(aCollection 				copyFrom: anIndex				to: aCollection size)].</body><body package="Arbor Help System Core">insertTextSlot: anIndex	"Private - Insert a new position indicated by anIndex in the texts collection."	texts := self insertSlot: anIndex in: texts.</body></methods><methods><class-id>VWHelp.AHSHelpData</class-id> <category>accessing</category><body package="Arbor Help System Core">outlineLinkAt: anIndex	"Answer the value found at anIndex in outlineLinks.  If outlineLinks is nil, or	  if anIndex is invalid, nil is returned."	^ self valueAt: anIndex in: outlineLinks.</body><body package="Arbor Help System Core">outlineLinkAt: anIndex put: aText	self 		collection: outlineLinks		at: anIndex		put: aText		assignMethod: #outlineLinks:</body><body package="Arbor Help System Core">outlineLinks: aCollection	"Set outlineLinks to be aCollection.  If the collection has changed,	  mark the system as dirty for the benefit of OODBMS's"	outlineLinks == aCollection ifTrue: [^ self].	outlineLinks := aCollection.	self odbDirty</body><body package="Arbor Help System Core">textAt: anIndex	"Answer the value found at anIndex in texts.  If texts is nil, or	  if anIndex is invalid, nil is returned."	^ self valueAt: anIndex in: texts.</body><body package="Arbor Help System Core">textAt: anIndex put: aText	self 		collection: texts		at: anIndex		put: aText		assignMethod: #texts:</body><body package="Arbor Help System Core">texts: aCollection	"Set texts to be aCollection.  If the collection has changed,	  mark the system as dirty for the benefit of OODBMS's"	texts == aCollection ifTrue: [^ self].	texts := aCollection.	self odbDirty</body></methods><methods><class-id>VWHelp.AHSHelpData</class-id> <category>copying</category><body package="Arbor Help System Core">postCopy	texts notNil		ifTrue: [texts := texts collect: [:txt | txt notNil ifTrue: [txt ahsDeepCopyOfText]]].	outlineLinks notNil		ifTrue: 			[outlineLinks := outlineLinks collect: [:each | each notNil ifTrue: [each collect: [:elm | elm copy]]]]				"elm is &lt;String | nil | Integer&gt;"</body></methods><methods><class-id>VWHelp.AHSHelpData</class-id> <category>printing</category><body package="Arbor Help System Core">storeOn: aStream	aStream 		nextPut: $(;		store: self class;		nextPutAll: ' texts: ';		store: texts;		nextPutAll: ' outlineLinks: ';		store: outlineLinks;		nextPut: $)</body></methods><methods><class-id>VWHelp.AHSHelpData</class-id> <category>accessing - private</category><body package="Arbor Help System Core">valueAt: anIndex in: aCollection	"Private - Answer the value found at anIndex in aCollection.  The collection	  is checked for existence and the index is checked for validity before the item	 is accessed.  If the index is invalid, nil is returned."	(self 		indexOutOfRange: anIndex 		for: aCollection) ifTrue: [^ nil].	^ aCollection at: anIndex</body></methods><methods><class-id>VWHelp.AHSHelpData class</class-id> <category>instance creation</category><body package="Arbor Help System Core">texts: textsArray outlineLinks: outlineLinksArray	^ self new 		setTexts: textsArray 		outlineLinks: outlineLinksArray</body></methods><methods><class-id>VWHelp.AHSPreferencesSetup</class-id> <category>private</category><body package="Arbor Help System Core">checkDisturbed	"Only sent when my window's model is a UISettings."	self triggerChannel dependents do: [:dep |		((dep isKindOf: BufferedValueHolder) and: [dep isBuffering])			ifTrue: [^self builder window model disturb]].	self builder window model undisturb.</body></methods><methods><class-id>VWHelp.AHSPreferencesSetup</class-id> <category>interface opening</category><body package="Arbor Help System Core">postBuildWith: aBuilder	"If the window that contains me doesn't have help enabled, enable it!  This pretty much only applies when using the UISettings tool."	| model |	((model := aBuilder window model) isKindOf: UISettings) not ifTrue: [^self].	model class ahsProcessorClass postOpenEnableHelpFor: model.	model ahsSubBuilder aspectAt: #ahsTrigger put: self triggerChannel.	"Here we must assume that we are the last one built (build is alphabetical order by spec name."	self triggerChannel dependents do: [:dep |		(dep isKindOf: BufferedValueHolder)			ifTrue: [dep onChangeSend: #checkDisturbed to: self]].</body><body package="Arbor Help System Core">preBuildWith: aBuilder	"When using the UISettings tool, set up that window to have help."	| model bld win |	model := aBuilder window model.	(model isKindOf: UISettings) ifTrue: [		bld := model builder.		model builder: model ahsSubBuilder.		win := model builder window.		model builder setWindow: nil.		model class ahsProcessorClass preBuildEnableHelpFor: model.		model builder setWindow: win.		model builder: bld].</body></methods><methods><class-id>VWHelp.AHSPreferencesSetup class</class-id> <category>class initialization</category><body package="Arbor Help System Core">initialize	self addPreferenceSpec: #zzzPreferencesSetupSpec.</body></methods><methods><class-id>VWHelp.AHSPreferencesSetup class</class-id> <category>interface specs</category><body package="Arbor Help System Core">zzzPreferencesSetupSpec	"The funky name just about assures that this spec will be the last built - build is in order of spec name."	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Unlabeled Canvas' 			#bounds: #(#Rectangle 0 0 0 0 ) ) 		#component: 		#(#SpecCollection 			#collection: #() ) )</body></methods><methods><class-id>UI.UISettings class</class-id> <category>AHS Core adds</category><body package="Arbor Help System Core">addAHSSectionTo: aDictionary development: devSpecs runtime: runtimeSpecs	"Add the Lens set of preferences and settings slices to the arguments."	devSpecs		addLast: 'AHS'-&gt;#(#ahsSettingsSpec #ahsHelp)</body><body package="Arbor Help System Core">ahsDynamicallyGeneratedSpec	^#{VWHelp.AHSPreferences} value dynamicallyGeneratedSpecForTrigger: nil asValue</body><body package="Arbor Help System Core">ahsHelpData	^(#{VWHelp.AHSHelpClassData} value languages: #(#English) widgetData: ((#{VWHelp.AHSPersistentDictionary} value new)		add: (#ahsBackground -&gt; ((#{VWHelp.AHSPersistentDictionary} value new)		add: (#default -&gt; (#{VWHelp.AHSHelpData}value texts: ((Array new: 1) at: 1 put: ''; yourself) outlineLinks: nil)); yourself)); yourself))</body><body package="Arbor Help System Core">arborHelpEnabled	"Answer true if the Arbor Help System is to be enabled for this application.  The default is false."	^true</body></methods><methods><class-id>UI.UISettings</class-id> <category>AHS Core adds</category><body package="Arbor Help System Core">ahsAccept	(self ahsSubBuilder aspectAt: #ahsTrigger) value: true.</body><body package="Arbor Help System Core">ahsHelp	^'Settings for the Arbor Help System'</body><body package="Arbor Help System Core">ahsReset	(self ahsSubBuilder aspectAt: #ahsTrigger) value: false.</body><body package="Arbor Help System Core">ahsSubBuilder	^subBuilder</body></methods><methods><class-id>Graphics.ColorValue</class-id> <category>AHS Core adds-printing</category><body package="Arbor Help System Core">htmlColorCode	"Answer a string representation of the color value in a format acceptable to HTML."	| output |	output := WriteStream on: ''.	^ output		nextPutAll: '"#';		nextPutAll: ((self red * 255) truncated printStringRadix: 16);		nextPutAll: ((self green * 255) truncated printStringRadix: 16);		nextPutAll: ((self blue * 255) truncated printStringRadix: 16);		nextPutAll: '"';		contents</body><body package="Arbor Help System Core">rtfColorCode	"Answer a string representation of the color value in a format acceptable to RTF."	| output |	output := WriteStream on: ''.	^ output		nextPutAll: '\red';		nextPutAll: (self red * 255) truncated printString;		nextPutAll: '\green';		nextPutAll: (self green * 255) truncated printString;		nextPutAll: '\blue';		nextPutAll: (self blue * 255) truncated printString;		nextPutAll: ';';		contents</body></methods><methods><class-id>Core.Stream</class-id> <category>AHS Core adds</category><body package="Arbor Help System Core">ahsNextPutAllText: aText	"Copied out of TextStream as this should be polymorphic to all writeable streams."	"Append aText to the receiver, preserving emphasis.	Answer aText."	| i inStream end span oldEmphasis |	aText isEmpty ifTrue: [^aText].	oldEmphasis := self emphasis.	i := 1.	inStream := aText string readStream.	end := aText size.	[i &lt;= end] whileTrue: [		self emphasis: (aText emphasisAt: i).		span := aText runLengthFor: i.		self nextPutAll: (inStream next: span).		i := i + span].	self emphasis: oldEmphasis.	^aText</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>AHS Core adds</category><body package="Arbor Help System Core">asArrayOfLines	"Answer an array of items derived from the receiver where each item represents a portion of	 the receiver delimited by a 'cr'."	| stream result |	stream := ReadStream on: self.	result := OrderedCollection new.	[stream atEnd] whileFalse: [result add: (stream upTo: Character cr)].	^ result asArray</body><body package="Arbor Help System Core">asTranslationText	^ self asText asTranslationText</body></methods><methods><class-id>Core.Text</class-id> <category>AHS Core adds - copying</category><body package="Arbor Help System Core">ahsDeepCopyOfText	^#{VWHelp.AHSUtils} value deepCopyOfText: self</body></methods><methods><class-id>Core.Text</class-id> <category>AHS Core adds</category><body package="Arbor Help System Core">asAHSTextBinder	"Answer an AHSTextBinder object initialized from the receiver."	^#{VWHelp.AHSTextBinder} value helpText: self</body><body package="Arbor Help System Core">asTranslationText	^#{VWHelp.AHSTranslationText} value string: self string runs: self runs</body><body package="Arbor Help System Core">translated	"For polymorphism with AHSTranslationText"	^true</body></methods><methods><class-id>Core.MessageSend</class-id> <category>Arbor Core adds</category><body package="Arbor Help System Core">storeOn: aStream  	"Append to the argument aStream a sequence of characters that is 	an expression whose evaluation creates a message similar 	to the receiver. The general format for messages is		( Message selector: selector arguments: args)"	aStream nextPut: $(.	aStream nextPutAll: 'MessageSend receiver: '.	self receiver storeOn: aStream.	aStream nextPutAll: ' selector: '.	selector storeOn: aStream.	aStream nextPutAll: ' arguments: '.	args storeOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>Core.String</class-id> <category>AHS Core adds</category><body package="Arbor Help System Core">ahsContainsString: aString	"Answer true if the receiver contains aString within itself."	^ (self 		indexOfSubCollection: aString		startingAt: 1) &gt; 0</body><body package="Arbor Help System Core">asAHSTextBinder	"Answer an AHSTextBinder object initialized from the receiver."	^#{VWHelp.AHSTextBinder} value helpText: self</body></methods><methods><class-id>Core.Object</class-id> <category>AHS Core adds</category><body package="Arbor Help System Core">odbDeepRefresh	"Default to simply do an undirty refresh."	self odbRefreshIfNotDirty</body><body package="Arbor Help System Core">odbDirty	"If using GemStone, send markDirty.	If using Versant, send vDirty"	#{GSSessionManager} isDefined		ifTrue: [self markDirty].	#{ODBInterface} isDefined		ifTrue: [self vDirty]</body><body package="Arbor Help System Core">odbReadLock	"If Versant is in the system, obtain a read lock on myself."	(#{ODBInterface} isDefined and: [self isPersistent])		ifTrue: [| verr |				verr := #{VError} value.				^verr errorSignal					handle: [:ex |							(verr errorSymbol == #'SM_LOCK_WOULDBLOCK' or: [verr errorSymbol == #'SM_LOCK_DEADLOCK'])								ifTrue:[ex returnWith: false]								ifFalse:[ex reject]]					do: [self upgradeLockTo: #RLOCK withOption: #'O_LK_NOWAIT']].	^true</body><body package="Arbor Help System Core">odbRefresh	"If in Versant, refresh self from the ODB."	#{ODBInterface} isDefined		ifTrue: [self refresh].</body><body package="Arbor Help System Core">odbRefreshIfNotDirty	"If in Versant, refresh self from the ODB if self hasn't been changed locally."	#{ODBInterface} isDefined		ifTrue: [self proxy isDirty not					ifTrue: [self odbRefresh]].</body><body package="Arbor Help System Core">odbRelease	"If using GemStone, send stubYourself."	#{GemSessionManager} isDefined		ifTrue: [self stubYourself].</body><body package="Arbor Help System Core">odbReleaseLock	"If Versant is in the system, release any locks on myself by downgrading to a #NOLOCK."	(#{ODBInterface} isDefined and: [self isPersistent])		ifTrue: [^self downgradeLockTo: #NOLOCK].	^true</body><body package="Arbor Help System Core">odbReleaseUnDirtyLock	"If in Versant, release the lock on self if undirty."	#{ODBInterface} isDefined		ifTrue: [self proxy isDirty not					ifTrue: [self odbReleaseLock]].</body><body package="Arbor Help System Core">odbWriteLock	"If Versant is in the system, obtain a write lock on myself."	(#{ODBInterface} isDefined and: [self isPersistent])		ifTrue: [| verr |				verr := #{VError} value.				^verr errorSignal					handle: [:ex |							(verr errorSymbol == #'SM_LOCK_WOULDBLOCK' or: [verr errorSymbol == #'SM_LOCK_DEADLOCK'])								ifTrue:[ex returnWith: false]								ifFalse:[ex reject]]					do: [self upgradeLockTo: #WLOCK withOption: #'O_LK_NOWAIT']].	^true</body></methods><methods><class-id>VWHelp.AHSWHCGlobalHelp class</class-id> <category>AHS Core adds-help info (AHS)</category><body package="Arbor Help System Core">ahsHelpData	^(AHSHelpClassData languages: #(#English) widgetData: ((AHSPersistentDictionary new)	 add: (#ahsText -&gt; ((AHSPersistentDictionary new)	 add: (#disabled -&gt; (AHSHelpData texts: nil outlineLinks: nil));	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (AHSTextBinder fullText: (#{Smalltalk.Text} value string: 'This window shows help text for the widgets in the active window.  If no help shows here then there is either no help for that widget or the window does not serve help text.' runs: (RunArray runs: #(173) values: #(nil))) condensedText: '' asText); yourself) outlineLinks: nil)); yourself));	 add: (#ahsFlag -&gt; ((AHSPersistentDictionary new)	 add: (#on -&gt; (AHSHelpData texts: nil outlineLinks: nil));	 add: (#disabled -&gt; (AHSHelpData texts: nil outlineLinks: nil));	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (AHSTextBinder fullText: (#{Smalltalk.Text} value string: 'This check box will toggle both widget and bubble help enablement on and off for the entire system.  Windows with their own check box will normally only toggle widget help for that particular window.' runs: (RunArray runs: #(199) values: #(nil))) condensedText: '' asText); yourself) outlineLinks: nil)); yourself));	 add: (#ahsBackground -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'This window shows help text for the widgets in the active window.  If no help shows here then there is either no help for that widget or the window does not serve help text.' runs: (RunArray runs: #(173) values: #(nil))); yourself) outlineLinks: nil)); yourself)); yourself))</body></methods><methods><class-id>VWHelp.AHSPreferences class</class-id> <category>interface specs</category><body package="Arbor Help System Core">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Help System Preferences' 			#min: #(#Point 431 260 ) 			#max: #(#Point 431 418 ) 			#bounds: #(#Rectangle 708 323 1139 741 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#SubCanvasSpec 					#layout: #(#LayoutFrame 2 0 -48 1 -2 1 -2 1 ) 					#flags: 0 					#minorKey: #ahsSpec ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -136 1 -85 1 -76 1 -52 1 ) 					#name: #accept 					#model: #accept 					#label: 'OK' 					#isDefault: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -67 1 -85 1 -6 1 -52 1 ) 					#name: #cancel 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) 				#(#SubCanvasSpec 					#layout: #(#LayoutFrame 0 0 0 0 0 1 -90 1 ) 					#name: #dynamicallyGeneratedSubcanvas 					#flags: 0 					#minorKey: #dynamicallyGeneratedSpec ) ) ) )</body></methods><methods><class-id>VWHelp.AHSCorePreferencesModel class</class-id> <category>interface specs</category><body package="Arbor Help System Core">coreConfigSpec	"UIPainter new openOnClass: self andSelector: #coreConfigSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Help System Preferences' 			#min: #(#Point 280 55 ) 			#max: #(#Point 440 358 ) 			#bounds: #(#Rectangle 359 485 639 575 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 3 0 1 0 -3 1 -1 1 ) 					#name: #widgetHelpConfigGroupBox 					#label: 'Widget Help Configuration' 					#style: #'Arbor-12-Squeeze' ) 				#(#CheckBoxSpec 					#layout: #(#Point 20 24 ) 					#name: #showHelp 					#model: #showHelp 					#label: 'Show Help' 					#style: #'Arbor-12-Squeeze' ) 				#(#CheckBoxSpec 					#layout: #(#Point 20 44 ) 					#name: #useWidgetHelp 					#model: #useWidgetHelp 					#label: 'Use Widget Help' 					#style: #'Arbor-12-Squeeze' ) 				#(#CheckBoxSpec 					#layout: #(#Point 20 64 ) 					#name: #useBalloonHelp 					#model: #useBalloonHelp 					#label: 'Use Balloon Help (F3)' 					#style: #'Arbor-12-Squeeze' ) ) ) )</body></methods><methods><class-id>VWHelp.AHSBalloonHelpPreferencesModel class</class-id> <category>interface specs</category><body package="Arbor Help System Core">balloonHelpConfigSpec	"UIPainter new openOnClass: self andSelector: #balloonHelpConfigSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Help System Preferences' 			#min: #(#Point 417 55 ) 			#max: #(#Point 440 358 ) 			#bounds: #(#Rectangle 612 474 1029 577 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 3 0 1 0 -3 1 -1 1 ) 					#name: #balloonHelpConfigGroupBox 					#label: 'Balloon Help Display Configuration' 					#style: #'Arbor-12-Squeeze' ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 20 0 35 0 0 0.5 ) 					#name: #balloonDelayLabel 					#label: 'Balloon Display Delay:' 					#style: #'Arbor-12-Squeeze' ) 				#(#InputFieldSpec 					#layout: #(#Rectangle 178 24 221 47 ) 					#name: #balloonDelayValueField 					#model: #balloonDisplayDelay 					#alignment: #right 					#style: #'Arbor-12-Squeeze' 					#type: #number 					#formatString: '0' ) 				#(#LabelSpec 					#layout: #(#Point 223 25 ) 					#name: #msecsLabel 					#label: 'ms' 					#style: #'Arbor-12-Squeeze' ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 20 0 62 0 0 0.5 ) 					#name: #balloonKillLabel 					#label: 'Balloon Kill Delay:' 					#style: #'Arbor-12-Squeeze' ) 				#(#InputFieldSpec 					#layout: #(#Rectangle 178 50 221 74 ) 					#name: #balloonKillValueField 					#model: #balloonKillDelay 					#alignment: #right 					#style: #'Arbor-12-Squeeze' 					#type: #number 					#formatString: '0' ) 				#(#LabelSpec 					#layout: #(#Point 223 52 ) 					#name: #msecsLabel 					#label: 'ms' 					#style: #'Arbor-12-Squeeze' ) 				#(#CheckBoxSpec 					#layout: #(#AlignmentOrigin 21 0 87 0 0 0.5 ) 					#name: #restrictBalloonToCondensedTextCB 					#model: #restrictBalloonToCondensedText 					#label: 'Restrict Balloon to Condensed Text' 					#style: #'Arbor-12-Squeeze' ) ) ) )</body></methods><methods><class-id>UI.UISettings class</class-id> <category>AHS Core adds</category><body package="Arbor Help System Core">ahsSettingsSpec	"UIPainter new openOnClass: self andSelector: #ahsSettingsSpec"	&lt;resource: #canvas&gt;	^#(#{FullSpec} 		#window: 		#(#{WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Rectangle} 591 417 893 718 ) ) 		#component: 		#(#{SpecCollection} 			#collection: #(				#(#{SubCanvasSpec} 					#layout: #(#{LayoutFrame} 2 0 2 0 -2 1 -86 1 ) 					#name: #ahsSettings 					#flags: 9 					#minorKey: #ahsDynamicallyGeneratedSpec ) 				#(#{SubCanvasSpec} 					#layout: #(#{LayoutFrame} 0 0 -48 1 0 1 0 1 ) 					#flags: 0 					#minorKey: #ahsSpec ) 				#(#{ActionButtonSpec} 					#layout: #(#{LayoutFrame} 4 0 -80 1 73 0 -53 1 ) 					#name: #acceptButton 					#flags: 40 					#model: #ahsAccept 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: 'Accept' 					#style: #'Arbor-12-Squeeze' ) 				#(#{ActionButtonSpec} 					#layout: #(#{LayoutFrame} -34 0.5 -80 1 35 0.5 -53 1 ) 					#name: #resetButton 					#flags: 40 					#model: #ahsReset 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: 'Reset' 					#style: #'Arbor-12-Squeeze' ) 				#(#{ActionButtonSpec} 					#layout: #(#{LayoutFrame} -73 1 -80 1 -4 1 -53 1 ) 					#name: #helpButton 					#model: #helpAction 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: 'Help' 					#style: #'Arbor-12-Squeeze' ) ) ) )</body></methods><initialize><class-id>VWHelp.ArborTextAttributes</class-id></initialize><initialize><class-id>VWHelp.AHSPreferences</class-id></initialize><initialize><class-id>VWHelp.AHSStorageManager</class-id></initialize><initialize><class-id>VWHelp.AHSCorePreferencesModel</class-id></initialize><initialize><class-id>VWHelp.AHSBalloonHelpPreferencesModel</class-id></initialize><initialize><class-id>VWHelp.AHSPreferencesSetup</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>MessageSend</name><environment>Core</environment><super>Core.Message</super><private>false</private><indexed-type>none</indexed-type><inst-vars>receiver </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Stream</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>ColorValue</name><environment>Graphics</environment><super>Graphics.SimplePaint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>red green blue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Support</category><attributes><package>Graphics-Support</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>VariableSizeTextAttributes</name><environment>Graphics</environment><super>Graphics.TextAttributes</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scale bottomLeading topLeading fontAttributeForLeading fontPolicySource lastFontPolicy </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>Graphics-Fonts</category><attributes><package>Graphics-Fonts</package></attributes></class><class><name>Text</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string runs </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class><class><name>UISettings</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>list disturbed subBuilder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Support</category><attributes><package>Interface-Support</package></attributes></class></st-source>