<?xml version="1.0"?><st-source><!-- Name: Debugger-SupportComment: PDP Support for VW 7DbIdentifier: bear73DbTrace: 53636DevelopmentPrerequisites: #(#(#any 'Debugger-Probes' ''))PackageName: Debugger-SupportParcel: #('Debugger-Support')PrerequisiteParcels: #(#('Debugger-Probes' ''))PrintStringCache: (7.3 - 1.17,bobw)Version: 7.3.1Post-Load Block: 	[ :pkg |  SyntaxError flushMenus.UI.Icon initializeWatchIcon.Processor initializePausedCollection.]Date: 5:54:15 pm April 10, 2005 --><time-stamp>From VisualWorksÂ®, 7.3.1 of April 10, 2005 on April 10, 2005 at 5:54:15 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>DebuggerService</name><environment>CraftedSmalltalk</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>processHandle oldCursor receiverInspector contextInspector stackInspector sourceMap currentContext pendingEvents continueInDebuggerCtx finishBlock selector tags stepProbes label serviceProcess selectionRange contextStackPolicy dontUpdateInspectors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>Debugger-Support</package></attributes></class><shared-variable><name>DcopyDict</name><environment>CraftedSmalltalk</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Debugger-Support</package></attributes></shared-variable><shared-variable><name>EventFaithfulDebugging</name><environment>CraftedSmalltalk.DebuggerService</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Debugger-Support</package></attributes></shared-variable><shared-variable><name>TempMethods</name><environment>CraftedSmalltalk.DebuggerService</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Debugger-Support</package></attributes></shared-variable><shared-variable><name>DefaultToPermanentProbe</name><environment>CraftedSmalltalk.DebuggerService</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Debugger-Support</package></attributes></shared-variable><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>private-stack manipulation</category><body package="Debugger-Support" selector="byteStep">byteStep	"Steps the context one instruction.	Returns true if the context did not change, otherwise	it returns false."	| currContext |	currContext := currentContext pdpCompleteCallee: currentContext step.	currContext == currentContext		ifTrue: [^true].	self resetContext: currContext.	^false</body><body package="Debugger-Support" selector="cutbackTo:finishWith:">cutbackTo: aContext finishWith: aBlock	| resumeContext unwindContext |	resumeContext := processHandle topContext.	(resumeContext == aContext or: [(resumeContext hasSender: aContext) not])		ifTrue: [^aBlock value.].		"Don't do unwind."	processHandle prepareForSimulation.	unwindContext := [self unwind: resumeContext to: aContext] newContext.	unwindContext stepUntilVisibleEffect.	unwindContext sender: resumeContext.	self performDebugOperation:		[self forceResetContext: unwindContext.		"Do the unwind.  We use simulation because if a non-local return		is done by an unwind the sending chain is terminated, whereas		when done by simulation it is not terminated."		self privateSimulateStepIntoBlock.		(currentContext hasSender: aContext)			ifTrue: [finishBlock := aBlock.].		nil].</body><body package="Debugger-Support" selector="finishStep">finishStep	"Step until reaching the next map entry.  Update code highlight and	inspectors."		| stopPC |	stopPC := self stopPC.	[stopPC == currentContext pc		ifTrue: [true]		ifFalse:			[currentContext pdpStepUntilPC: stopPC.			stopPC == currentContext pc]]		whileFalse:			[self byteStep.			stopPC := self stopPC].	self schedulePCUpdate.	self scheduleInspectorUpdate</body><body package="Debugger-Support" selector="forceResetContext:">forceResetContext: aContext 	"Makes aContext the top context.  This differs from #resetContext: because	it forces the source code to be reaquired and it forces the context list to	be regenerated.  This is necessary if the aContext was already the top	context but it was changed in some important aspect."	processHandle topContext: aContext.	self context: aContext.	self scheduleContextListUpdate.</body><body package="Debugger-Support" selector="getContinueInDebugCtx">getContinueInDebugCtx	| ctx |	ctx := continueInDebuggerCtx at: 1.	(ctx isNil | (ctx == 0) or: [(processHandle topContext hasSender: ctx) not])		ifTrue: [continueInDebuggerCtx at: 1 put: (ctx := currentContext)].	^ctx</body><body package="Debugger-Support" selector="homeContext">homeContext	| ctx |	(ctx := currentContext supposedHome) == nil		ifFalse: [^ctx].	self error: (#BlockHomeNotOnStack &lt;&lt; #pdp &gt;&gt; 'Block''s home context is not on the current process''s stack.').	^currentContext</body><body package="Debugger-Support" selector="homeContextForCutback">homeContextForCutback	^self homeContextForCutbackOf: currentContext</body><body package="Debugger-Support" selector="homeContextForCutbackOf:">homeContextForCutbackOf: aContext	| ctx |	((ctx := aContext supposedHome) notNil and: [ctx == aContext or: [aContext hasSender: ctx]])		ifTrue: [^ctx].	self error: (#UnableToRestartHomeNotOnStack &lt;&lt; #pdp &gt;&gt; 'Unable to restart: block''s home context not on the current process''s stack.').	^aContext</body><body package="Debugger-Support" selector="makeContextProceedable">makeContextProceedable	currentContext := currentContext stepUntilProceedable.</body><body package="Debugger-Support" selector="resetContext:">resetContext: aContext 	"Used when a new context becomes top-of-stack, for instance when the	method of the selected context is re-compiled, or the simulator steps or	returns to a new method."	processHandle topContext == aContext		ifTrue: [^self].	processHandle topContext: aContext.	currentContext == aContext 		ifFalse: [self context: aContext].	self scheduleContextListUpdate.</body><body package="Debugger-Support" selector="resumeProcess">resumeProcess	oldCursor show.	processHandle topContext: currentContext.	processHandle resumeProcess.</body><body package="Debugger-Support" selector="revertBlock">revertBlock	"If the selected context is a block, then restart from beginning of the block or its home."	| index |	currentContext isBlockContext		ifFalse: [^true].	index := Dialog		choose: (#IWillRestartFromTheBeginningOf &lt;&lt; #pdp &gt;&gt; 'I will restart from the beginning of')		labels: (Array with: (#TheBlock &lt;&lt; #pdp &gt;&gt; 'The Block') with: (#TheMethod &lt;&lt; #pdp &gt;&gt; 'The Method') with: (#Cancel &lt;&lt; #pdp &gt;&gt; 'Cancel'))		values: #(#method #block #cancel)		default: #method		for: self interfaceWindow.	index = #method		ifTrue: [^true].	index = #block		ifTrue: 			[self context: self homeContextForCutback.			 ^true].	^false</body><body package="Debugger-Support" selector="selectContext:">selectContext: aContext 	currentContext == aContext		ifTrue: [^self].	(aContext isNil or: [self isTerminated or: [processHandle topContext == aContext or:		[processHandle topContext hasSender: aContext]]])		ifFalse:			[^tags remove: aContext ifAbsent: []].	self context: aContext.</body><body package="Debugger-Support" selector="unwind:to:">unwind: resumeContext to: aContext	[resumeContext unwindUpTo: aContext] ensure:			[resumeContext terminateTo: aContext]</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>private</category><body package="Debugger-Support" selector="findOldestContextUsing:">findOldestContextUsing: oldMethods	| ctx oldestContext origOldMethods |	origOldMethods := oldMethods collect: [:meth | meth originalMethod].	ctx := processHandle topContext.	[ctx == nil]		whileFalse:			[ctx isBlockContext				ifFalse:					[(origOldMethods includes: ctx method originalMethod)						ifTrue: [oldestContext := ctx]].			ctx := ctx sender].	^oldestContext</body><body package="Debugger-Support" selector="finishRequest">finishRequest	self processEvents.	self requestComplete.	serviceProcess := nil.</body><body package="Debugger-Support" selector="performDebugOperation:">performDebugOperation: operationBlock	| exp debugBlock finBlock |	"Handle recursive calls, this can get us into trouble if we are not careful."	Processor activeProcess isUnderDebug		ifTrue: [^operationBlock value].	[currentContext == nil		ifTrue: [^self].	debugBlock :=		[	[	[operationBlock value.]					on: ControlInterrupt , ContextEmergencyError , UserInterrupt					do: [:ex | self emergencyRestart: ex].			]				on: Error				do: [:ex | exp := ex. "	(Dialog confirm: 'Simulation error -- shall I restart the method?'			for: nil)		ifTrue: [currentContext restart.]"false		ifFalse: [self class openOnException: exp].].		].	(processHandle performDebugOperation: debugBlock)		ifFalse: [^self scheduleCloseAction].	finishBlock notNil		ifTrue:			[finBlock := finishBlock.			finishBlock := nil.	"Prevent looping in case block resends this method"			finBlock value].	exp isNil		ifTrue: [^self].	(Dialog confirm: (#SimulationErrorRestartQ &lt;&lt; #pdp &gt;&gt; 'Simulation error. Restart the method?')			for: nil)		ifTrue: [currentContext restart.]		ifFalse: [self class openOnException: exp].	exp := nil.	] repeat.</body><body package="Debugger-Support" selector="performDebugRequest:">performDebugRequest: aSym	self isTerminated		ifTrue: [^self finishRequest].	serviceProcess :=		[Processor activeProcess environmentAt: #debugger put: self.		self perform: aSym.		self finishRequest] fork.</body><body package="Debugger-Support" selector="performDebugRequest:withArguments:">performDebugRequest: aSym withArguments: anArray	self isTerminated		ifTrue: [^self finishRequest].	serviceProcess :=		[Processor activeProcess environmentAt: #debugger put: self.		self perform: aSym withArguments: anArray.		self finishRequest] fork.</body><body package="Debugger-Support" selector="resetOnMethodChange:in:context:">resetOnMethodChange: newSelector in: classOfMethod context: aContext	"Get a new compiled method for aContext and cut the execution	stack back to aContext."	| newMethod newContext oldHomeContext savContext |	newMethod := classOfMethod compiledMethodAt: newSelector.	oldHomeContext := self homeContextForCutbackOf: aContext.	self		cutbackTo: oldHomeContext		finishWith:			[self performDebugOperation:				[newContext := oldHomeContext resizedWith: newMethod.				savContext := currentContext.				processHandle interrupted: true.				self forceResetContext: newContext.				(newContext hasSender: savContext)					ifTrue: [self context: savContext].	"restore selected context"				self scheduleTextUpdate.				self resetPCSelection.]].</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>probes</category><body package="Debugger-Support" selector="addBreakpointAt:">addBreakpointAt: anInterval	| status |	selectionRange := anInterval.	status := self		basicAddProbe: (ProbeCreationSpec							type: #Breakpoint							conditional: false							permanent: self selectedMethod isPartiallyBound &amp; DefaultToPermanentProbe)		using: nil.	status key		ifTrue:			[PDPManager				changedMethodFrom: self selectedMethod				to: self selectedMethod				by: self.			self removePCUpdate]		ifFalse:			[status value notNil				ifTrue: [self scheduleMessage: status value]].	self processEvents.</body><body package="Debugger-Support" selector="addProbeAt:">addProbeAt: anInterval	| status |	selectionRange := anInterval.	status := self basicAddProbe: nil using: nil.	status key		ifTrue:			[PDPManager				changedMethodFrom: self selectedMethod				to: self selectedMethod				by: self.			self removePCUpdate]		ifFalse:			[status value notNil				ifTrue: [self scheduleMessage: status value]].	self processEvents.</body><body package="Debugger-Support" selector="addStepProbe:with:">addStepProbe: aProbe with: aContext	stepProbes add: aProbe -&gt; aContext</body><body package="Debugger-Support" selector="basicAddProbe:using:">basicAddProbe: aProbeSpec using: aProbeRecord	^DebugProbeInserter addProbe: aProbeSpec using: aProbeRecord for: self</body><body package="Debugger-Support" selector="findSelectedProbeEmphasisIn:">findSelectedProbeEmphasisIn: aText	^PDPManager findSelectedProbeEmphasisIn: (aText copyFrom: selectionRange first to: selectionRange last + 1)</body><body package="Debugger-Support" selector="modifyProbeAt:from:">modifyProbeAt: anInterval from: aText	| emphasis probedMethod |	selectionRange := anInterval.	probedMethod := self selectedMethod.	probedMethod isProbed		ifFalse: [^self].	emphasis := self findSelectedProbeEmphasisIn: aText.	emphasis isNil		ifTrue: [^self scheduleMessage: (#ReselectBreakpointAndReissue &lt;&lt; #pdp &gt;&gt; 'Reselect breakpoint and reissue command.')].	emphasis value modifyIn: probedMethod.</body><body package="Debugger-Support" selector="removeAllProbes">removeAllProbes	"Removes all the probes from the selected method."	| probedMethod allProbes oldOriginal |	probedMethod := self selectedMethod.	probedMethod isProbed		ifFalse: [^self].	allProbes := OrderedCollection new.	probedMethod allProbesDo: [:p | allProbes add: p].	(DebugProbeInserter for: self) removeAllProbes: allProbes from: currentContext.	oldOriginal := (self selectedClass compiledMethodAt: selector) originalMethod.	self selectedClass addSelector: selector withMethod: oldOriginal.	PDPManager		changedMethodFrom: probedMethod		to: oldOriginal		by: self.	self processEvents.</body><body package="Debugger-Support" selector="removeProbeAt:from:">removeProbeAt: anInterval from: aText	| emphasis probedMethod |	selectionRange := anInterval.	probedMethod := self selectedMethod.	probedMethod isProbed		ifFalse: [^self].	emphasis := self findSelectedProbeEmphasisIn: aText.	emphasis isNil		ifTrue: [^self scheduleMessage: (#ReselectBreakpointAndReissue &lt;&lt; #pdp &gt;&gt; 'Reselect breakpoint and reissue command.')].	(DebugProbeInserter for: self) basicRemoveProbe: emphasis value.	"The following is necessary because apparently the method cache is not completely flushed."	ObjectMemory quickGC.	PDPManager			changedMethodFrom: probedMethod			to: probedMethod			by: self.	self resetPCSelection.	self removePCUpdate.	self processEvents.</body><body package="Debugger-Support" selector="removeStepProbes">removeStepProbes	(DebugProbeInserter for: self) removeStepProbes: stepProbes.	stepProbes := OrderedCollection new.</body><body package="Debugger-Support" selector="tempMethods">tempMethods	^TempMethods</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>testing</category><body package="Debugger-Support" selector="areTextProbeCommandsLegal">areTextProbeCommandsLegal	^selector notNil</body><body package="Debugger-Support" selector="contextHasHome">contextHasHome	^currentContext home notNil</body><body package="Debugger-Support" selector="doesContextHaveInterimValues">doesContextHaveInterimValues	^currentContext hasInterimValues</body><body package="Debugger-Support" selector="hasHomeContextStepped">hasHomeContextStepped	^currentContext home ~~ currentContext or: [(sourceMap at: 1) key &lt; currentContext pc]</body><body package="Debugger-Support" selector="hasLoopControlContext">hasLoopControlContext	| ctx |	ctx := continueInDebuggerCtx at: 1.	^ctx notNil and: 		[ctx ~~ 0 and: 		[processHandle topContext == ctx or:			[processHandle topContext hasSender: ctx]]]</body><body package="Debugger-Support" selector="hasSuspendedOperations">hasSuspendedOperations	| context receiverClass |	context := processHandle topContext.	[context isNil]		whileFalse:			[receiverClass := self _objectClass: context homeReceiver.			((receiverClass includesBehavior: DebuggerService) and: [processHandle isInDebugSession])				ifTrue: [^true].			context := context sender].	^false</body><body package="Debugger-Support" selector="isFullStack">isFullStack	^contextStackPolicy isFullStack</body><body package="Debugger-Support" selector="isInstalledMethodSourceOutOfSync">isInstalledMethodSourceOutOfSync	| meth inMeth |	meth := self selectedMethod.	inMeth := meth mclass compiledMethodAt: selector ifAbsent: [^false].	^inMeth getSource ~= meth getSource</body><body package="Debugger-Support" selector="isMethodContextSelected">isMethodContextSelected	^currentContext home == currentContext</body><body package="Debugger-Support" selector="isProbedMethod">isProbedMethod	^currentContext method isProbed</body><body package="Debugger-Support" selector="isStoreLoaded">isStoreLoaded	^#{Store.DbRegistry} isDefined</body><body package="Debugger-Support" selector="isTerminated">isTerminated	^processHandle isTerminated</body><body package="Debugger-Support" selector="isTopContextSelected">isTopContextSelected	^currentContext == self interruptedContext</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>debug commands</category><body package="Debugger-Support" selector="abortDebuggingFor:">abortDebuggingFor: aProcess	processHandle process == aProcess		ifFalse: [^self].	self ctrlyAbort.</body><body package="Debugger-Support" selector="abortDebugOperation">abortDebugOperation	serviceProcess isNil		ifTrue: [^self].	processHandle abortDebugOperation.</body><body package="Debugger-Support" selector="abortDebugOperationInProcess:">abortDebugOperationInProcess: proc	self abortDebugOperation.</body><body package="Debugger-Support" selector="continue">continue	self performDebugRequest: #basicContinue.</body><body package="Debugger-Support" selector="ctrlyAbort">ctrlyAbort	serviceProcess isNil		ifTrue: [^self].	processHandle abortDebugOperation.</body><body package="Debugger-Support" selector="firstLoop">firstLoop	self performDebugRequest: #basicFirstLoop.</body><body package="Debugger-Support" selector="jumpToCaretAt:">jumpToCaretAt: selectionInterval	selectionRange := selectionInterval.	self performDebugRequest: #basicJumpToCaret</body><body package="Debugger-Support" selector="makeFullMethod">makeFullMethod	self performDebugRequest: #basicMakeFullMethod.</body><body package="Debugger-Support" selector="moreStack">moreStack	self performDebugRequest: #basicMoreStack.</body><body package="Debugger-Support" selector="nextLoop">nextLoop	self performDebugRequest: #basicNextLoop.</body><body package="Debugger-Support" selector="pause">pause	self performDebugRequest: #basicPause.</body><body package="Debugger-Support" selector="proceed">proceed	self performDebugRequest: #basicProceed.</body><body package="Debugger-Support" selector="reenter">reenter	self performDebugRequest: #basicReenter.</body><body package="Debugger-Support" selector="restart">restart	self performDebugRequest: #basicRestart.</body><body package="Debugger-Support" selector="return">return	self performDebugRequest: #basicReturn.</body><body package="Debugger-Support" selector="selectHomeContext">selectHomeContext	self performDebugRequest: #basicSelectHomeContext.</body><body package="Debugger-Support" selector="send">send	self performDebugRequest: #basicSend.</body><body package="Debugger-Support" selector="skipToCaretAt:">skipToCaretAt: selectionInterval	selectionRange := selectionInterval.	self performDebugRequest: #basicSkipToCaret.</body><body package="Debugger-Support" selector="step">step	self performDebugRequest: #basicStep.</body><body package="Debugger-Support" selector="stepIntoBlock">stepIntoBlock	self performDebugRequest: #basicStepIntoBlock.</body><body package="Debugger-Support" selector="terminate">terminate	processHandle terminate</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>context list</category><body package="Debugger-Support" selector="context:">context: aContext 	"Set aContext to be the currently viewed context.  	This involves resetting all the inspectors, the viewed 	source code, and the exception handling signals."	| oldContext |	oldContext := currentContext.	currentContext := aContext.	currentContext == nil		ifTrue:			[self refreshInspectorsFromCurrentContext.			self scheduleTextUpdate.			selector := nil.			^self].	selector := currentContext method isProbed		ifTrue: [currentContext method homeMethod selector]		ifFalse: [currentContext selector].	[(oldContext == nil or: [oldContext method ~~ currentContext method])		ifTrue: [sourceMap := [currentContext sourceMap. "will compute tempNames"]						on: Error						do: [:x | x return: SortedCollection new]].	]		on: Metaclass obsoleteSignal 		do: [:ex | ].	dontUpdateInspectors		ifFalse: [self refreshInspectorsFromCurrentContext].	self scheduleTextUpdate.	self schedulePCUpdate.	currentContext == processHandle topContext		ifFalse: [^self].	currentContext atEnd		ifTrue: [^self].	"The following only has an effect when the context is entered.	It positions the pc just before the first/next executable statement."	currentContext pc = self stopPC		ifTrue: [^self].	self performDebugOperation: [self privateStep].</body><body package="Debugger-Support" selector="refreshInspectorsFromCurrentContext">refreshInspectorsFromCurrentContext	| receiver |	receiver := currentContext isNil		ifTrue: [nil]		ifFalse: [currentContext intendedReceiver].	(self _object: receiver eqeq: nil)		ifTrue:			[receiverInspector setObject: nil.			receiverInspector empty]		ifFalse: [receiverInspector setObject: receiver].	contextInspector inspect: currentContext.	stackInspector context: currentContext isTop: currentContext == processHandle topContext.	self scheduleResetInspectorFields</body><body package="Debugger-Support" selector="selectContextAt:">selectContextAt: anIndex	self selectContext: (contextStackPolicy contextSelectedAt: anIndex).	self processEvents.</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>tags</category><body package="Debugger-Support" selector="addTag">addTag	(tags includes: currentContext)		ifTrue: [^self].	tags add: currentContext.</body><body package="Debugger-Support" selector="hasTags">hasTags	^tags size &gt; 0</body><body package="Debugger-Support" selector="isCurrentContextTagged">isCurrentContextTagged	^tags includes: currentContext</body><body package="Debugger-Support" selector="isTagged:">isTagged: aString	tags detect: [:c | c printString = aString] ifNone: [^false].	^true</body><body package="Debugger-Support" selector="removeTag">removeTag	tags remove: currentContext ifAbsent: []</body><body package="Debugger-Support" selector="selectTag:">selectTag: aString	| ctx |	ctx := tags detect: [:c | c printString = aString] ifNone: [^self].	self selectContext: ctx.	self scheduleContextListSelectionUpdate.	self processEvents.</body><body package="Debugger-Support" selector="tagMenuList">tagMenuList	| col |	col := tags asSortedCollection: [:a :b | a hasSender: b].	col := col reject: [:ctx | ctx hasExited].	tags := PDPWeakCollection withAll: col.	^col collect: [:ctx | ctx printString].</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>accessing</category><body package="Debugger-Support" selector="context">context	"Answer the currently viewed context."	^currentContext</body><body package="Debugger-Support" selector="contextInspector">contextInspector	^contextInspector</body><body package="Debugger-Support" selector="contextList">contextList		^contextStackPolicy contextList</body><body package="Debugger-Support" selector="contextListForUI">contextListForUI	^contextStackPolicy filteredStack</body><body package="Debugger-Support" selector="indexOfCurrentContext">indexOfCurrentContext	^contextStackPolicy indexOfCurrentContext</body><body package="Debugger-Support" selector="interfaceWindow">interfaceWindow	^nil</body><body package="Debugger-Support" selector="interruptedContext">interruptedContext	"Answer the suspended context of the interrupted process."	^processHandle topContext</body><body package="Debugger-Support" selector="label">label	self isTerminated		ifTrue: [^(#TerminatedProcess &lt;&lt; #pdp &gt;&gt; 'Terminated Process') asString].	^label</body><body package="Debugger-Support" selector="label:">label: aString	label := aString</body><body package="Debugger-Support" selector="mayProceed">mayProceed	^true</body><body package="Debugger-Support" selector="pcRange">pcRange	^CompiledCode nPCMapErrorSignal		handle: [:ex | false -&gt; ex errorString]		do: [true -&gt; self privatePcRange].</body><body package="Debugger-Support" selector="receiverInspector">receiverInspector	^receiverInspector</body><body package="Debugger-Support" selector="selectedClass">selectedClass	"Answer the class object that is currently selected."	^ currentContext == nil		ifTrue: [nil]		ifFalse: [currentContext mclass]</body><body package="Debugger-Support" selector="selectedMethod">selectedMethod	| ctx |	currentContext isNil		ifTrue: [^nil].	ctx := currentContext supposedHome.	ctx isNil		ifTrue: [^currentContext method homeMethod].	^ctx method</body><body package="Debugger-Support" selector="selectionRange">selectionRange	^selectionRange</body><body package="Debugger-Support" selector="selector">selector	^selector</body><body package="Debugger-Support" selector="stackFilterPatterns:convertSelector:matchSelector:displayAllLimit:">stackFilterPatterns: patternArrays convertSelector: convertSym matchSelector: matchSym displayAllLimit: aNumber	contextStackPolicy patterns: patternArrays.	contextStackPolicy conversionSymbol: convertSym.	contextStackPolicy matchSymbol: matchSym.	contextStackPolicy displayAllLimit: aNumber.</body><body package="Debugger-Support" selector="stackInspector">stackInspector	^stackInspector</body><body package="Debugger-Support" selector="text">text	| theText meth |	currentContext isNil		ifTrue: [^Text new].	^[theText := currentContext sourceCode asText.	currentContext method homeMethod usuallyHasSelector		ifTrue: [theText makeSelectorBoldIn: currentContext mclass].	(meth := self selectedMethod) isProbed		ifTrue: [meth highlightProbesIn: theText].	theText] 		on: MethodDictionary keyNotFoundSignal		do:  [:ex |			((#noSourceCodeFor1s &lt;&lt; #pdp &gt;&gt; 'no source code for &lt;1s&gt;')			expandMacrosWith: currentContext printString) asText emphasizeAllWith: #italic;				yourself].</body><body package="Debugger-Support" selector="topContext">topContext	^processHandle topContext</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>return commands</category><body package="Debugger-Support" selector="evaluateExpressionInReceiver:">evaluateExpressionInReceiver: string	| status object |	status := true.	object := currentContext receiver class evaluatorClass new				evaluate: string				in: currentContext				receiver: currentContext receiver				notifying: nil				ifFail: [status := false].	^status -&gt; object</body><body package="Debugger-Support" selector="returnLastDoIt:">returnLastDoIt: rtnMsg	self completeReturn: rtnMsg with: processHandle proceedValue</body><body package="Debugger-Support" selector="returnNewExpr:with:">returnNewExpr: rtnMsg with: object	self completeReturn: rtnMsg with: object</body><body package="Debugger-Support" selector="returnSelf:">returnSelf: rtnMsg	self completeReturn: rtnMsg with: currentContext receiver</body><body package="Debugger-Support" selector="returnTOS:">returnTOS: rtnMsg	self completeReturn: rtnMsg with: currentContext top</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>private-reflection protocol</category><body package="Debugger-Support" selector="_object:eqeq:">_object: anObject eqeq: anOtherObject	"Answer true if the arguments are actually the same object."	&lt;primitive: 210&gt;	^self primitiveFailed</body><body package="Debugger-Support" selector="_objectClass:">_objectClass: anObject	"Answer the object which is the argument's class.."	&lt;primitive: 211&gt;	^self primitiveFailed</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>private-event processing</category><body package="Debugger-Support" selector="changedLabel">changedLabel	self changed: #windowLabel with: label</body><body package="Debugger-Support" selector="changedPC">changedPC	| range |	range := self pcRange.	range key		ifFalse: [^self changed: #showMessage with: range value].	self changed: #pcRange with: range.</body><body package="Debugger-Support" selector="closeDebugger">closeDebugger	self changed: #closeDebugger</body><body package="Debugger-Support" selector="eventOrder">eventOrder	^#(#changedLabel #updateContextList #updateContextListSelection #updateText #changedPC #resetInspectorFields #updateInspectors #closeDebugger)</body><body package="Debugger-Support" selector="processEvents">processEvents	self eventOrder do:		[:event |		(pendingEvents remove: event ifAbsent: [nil]) == nil			ifFalse: [self perform: event]].	pendingEvents do: [:ar | self perform: (ar at: 1) with: (ar at:2)].	"Presently, this is for #showMessage only."	pendingEvents := Set new.</body><body package="Debugger-Support" selector="removePCUpdate">removePCUpdate	pendingEvents remove: #changedPC ifAbsent: []</body><body package="Debugger-Support" selector="requestComplete">requestComplete	self changed: #requestComplete</body><body package="Debugger-Support" selector="scheduleCloseAction">scheduleCloseAction	pendingEvents add: #closeDebugger</body><body package="Debugger-Support" selector="scheduleContextListSelectionUpdate">scheduleContextListSelectionUpdate	pendingEvents add: #updateContextListSelection.</body><body package="Debugger-Support" selector="scheduleContextListUpdate">scheduleContextListUpdate	pendingEvents add: #updateContextList.</body><body package="Debugger-Support" selector="scheduleInspectorUpdate">scheduleInspectorUpdate	pendingEvents add: #updateInspectors</body><body package="Debugger-Support" selector="scheduleLabelUpdate">scheduleLabelUpdate	pendingEvents add: #changedLabel.</body><body package="Debugger-Support" selector="scheduleMessage:">scheduleMessage: aString	pendingEvents add: (Array with: #showMessage: with: aString asString).</body><body package="Debugger-Support" selector="schedulePCUpdate">schedulePCUpdate	pendingEvents add: #changedPC</body><body package="Debugger-Support" selector="scheduleResetInspectorFields">scheduleResetInspectorFields	pendingEvents add: #resetInspectorFields</body><body package="Debugger-Support" selector="scheduleTextUpdate">scheduleTextUpdate	pendingEvents add: #updateText.	pendingEvents add: #changedPC</body><body package="Debugger-Support" selector="showMessage:">showMessage: aString	self changed: #showMessage with: aString.</body><body package="Debugger-Support" selector="updateContextList">updateContextList	contextStackPolicy computeContextList.	self changed: #contextList with: self indexOfCurrentContext</body><body package="Debugger-Support" selector="updateContextListSelection">updateContextListSelection	self changed: #contextSelection with: self indexOfCurrentContext</body><body package="Debugger-Support" selector="updateText">updateText	self changed: #text</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>private-menu messages</category><body package="Debugger-Support" selector="basicContinue">basicContinue	"Continue execution from the interrupted state of the top context."	currentContext := processHandle topContext.	processHandle interrupted not		ifTrue:			[currentContext pc.			currentContext push: processHandle proceedValue].	self performDebugOperation: [self makeContextProceedable].	self resumeProcess.</body><body package="Debugger-Support" selector="basicFirstLoop">basicFirstLoop	self performDebugOperation: [self privateFirstLoop].</body><body package="Debugger-Support" selector="basicJumpToCaret">basicJumpToCaret	"Finds the closest proper point before the caret and causes the context to jump to it,	then completely pops the context stack.  Proper jump points cannot be inside a loop,	or cannot be after loop preperation, and must have a stack depth of 0.  Also, jumps	into or out of blocks are not permitted."	| probeRecord theContext |	self checkContextSelection.	currentContext sourceInfo:		[:nodeHolder :i |		probeRecord := nodeHolder node							jumpRecordFor: selectionRange							blkIndex: currentContext method blockMethodIndex].	probeRecord isNil		ifTrue: [^self scheduleMessage:(#JumpPointIsNotInBlock &lt;&lt; #pdp &gt;&gt; 'Jump point is not in the same block. Try again.')].	currentContext == processHandle topContext		ifFalse:			[(Dialog				confirm: (#TopSendNotSelected &lt;&lt; #pdp &gt;&gt; 'You do not have the top message send selected.Abandon the message sends from the selection up to the top message sendand proceed with the jump operation?')				initialAnswer: false)				ifFalse: [^self]].	currentContext == processHandle topContext		ifTrue: [self performDebugOperation: [self finishJumpToCaretUsing: probeRecord]]		ifFalse:			["Simulate a return from context that has 'context' as its			immediate sender, and unwind all child active sends."			theContext := currentContext.			self				cutbackTo: theContext				finishWith:					[self performDebugOperation:						[theContext push: nil.		"simulate a return value"						processHandle interrupted: true.						self resetContext: theContext.						self finishStep.						self finishJumpToCaretUsing: probeRecord]]].	self schedulePCUpdate.	self scheduleInspectorUpdate.</body><body package="Debugger-Support" selector="basicMakeFullMethod">basicMakeFullMethod	self performDebugOperation: [self privateMakeFullMethod].</body><body package="Debugger-Support" selector="basicMoreStack">basicMoreStack	contextStackPolicy moreStack		ifFalse: [^self].	self scheduleContextListUpdate.</body><body package="Debugger-Support" selector="basicNextLoop">basicNextLoop	self performDebugOperation: [self privateNextLoop].</body><body package="Debugger-Support" selector="basicPause">basicPause	"Continue execution from the interrupted state of the top context."	currentContext := processHandle topContext.	processHandle interrupted not		ifTrue:			[currentContext pc.			currentContext push: processHandle proceedValue].	self performDebugOperation: [self makeContextProceedable].	processHandle topContext: currentContext.	processHandle pauseProcess.	self scheduleCloseAction.</body><body package="Debugger-Support" selector="basicProceed">basicProceed	"Proceed from the interrupted state of the currently selected context.	Instructions pending execution in methods entered after the selected	context are not executed."	| pushValue theContext |	self checkContextSelection.	pushValue := (currentContext ~= processHandle topContext) | (processHandle interrupted not).	theContext := currentContext.	self		cutbackTo: theContext		finishWith:			[pushValue				ifTrue:					[theContext pc.					theContext push: processHandle proceedValue].			processHandle topContext: theContext.			currentContext := theContext.			self performDebugOperation: [self makeContextProceedable. nil].			self resumeProcess].</body><body package="Debugger-Support" selector="basicReenter">basicReenter	"Reset to the initial state of the currently selected context, i.e. as if the	context had just been entered."	| theContext |	self checkContextSelection.	self revertBlock ifFalse: [^self].	theContext := currentContext.	self		cutbackTo: theContext		finishWith:			[self performDebugOperation:				[theContext restart.				processHandle interrupted: true.				self forceResetContext: theContext.				theContext pdpStepUntilPC: self stopPC.				self schedulePCUpdate.				nil]].</body><body package="Debugger-Support" selector="basicRestart">basicRestart	"Proceed from the initial state of the currently selected context.	The argument is a controller on a view of the receiver.  That view	is closed."	| theContext |	self checkContextSelection.	self revertBlock ifFalse: [^self].	theContext := currentContext.	self		cutbackTo: theContext		finishWith:			[theContext restart.			processHandle interrupted: true.			processHandle topContext: theContext.			currentContext := theContext.			self performDebugOperation:				[self makeContextProceedable.				nil].			processHandle topContext: currentContext.			self resumeProcess].</body><body package="Debugger-Support" selector="basicSelectHomeContext">basicSelectHomeContext	| ctx |	ctx := currentContext supposedHome.	ctx isNil		ifTrue: [^self scheduleMessage: (#TheHomeContextIsNotOnTheStack &lt;&lt; #pdp &gt;&gt; 'The home context is not on the stack.')].	self context: ctx.	self scheduleContextListSelectionUpdate.	self processEvents.</body><body package="Debugger-Support" selector="basicSend">basicSend	self performDebugOperation: [self privateSend].</body><body package="Debugger-Support" selector="basicSkipToCaret">basicSkipToCaret	self performDebugOperation: [self privateSkipToCaret].</body><body package="Debugger-Support" selector="basicStep">basicStep	self performDebugOperation: [self privateStep].</body><body package="Debugger-Support" selector="basicStepIntoBlock">basicStepIntoBlock	self performDebugOperation: [self privateStepIntoBlock].</body><body package="Debugger-Support" selector="finishJumpToCaretUsing:">finishJumpToCaretUsing: probeRecord	| targetPC |	processHandle prepareForSimulation.	currentContext pc = 1		ifTrue: [self resetContext: currentContext. "In case of restart, set the context to be the top."].	currentContext clearStack.  "This statement must preceed the 'AuxCode...' depth test stmt."	targetPC := probeRecord insertionPC.	"On the surface the following looks incomplete.  However, the obtained targetPC is always	at the beginning of a statement.  The only way the stack depth at the beginning of a statement	cannot be 0 is if it was preceeded by a popPush code."	(targetPC &gt; 1 and: [currentContext isPopPushAt: targetPC - 1])		ifTrue:			[((AuxCodeInfoExtractor on: currentContext method) depthAt: targetPC) ~= currentContext stackP				ifTrue:					[currentContext push: nil.	"push dummy onto stack"					targetPC := targetPC - 1]].	currentContext jump: targetPC - currentContext pc.	currentContext pc = self stopPC		ifFalse: [self privateStep].</body><body package="Debugger-Support" selector="privateFirstLoop">privateFirstLoop	"Sets the controlling context to the selected context and executes continually in the	debugger until an break occurs or the method returns."	self checkContextSelection.	self setLoopControlContext.	self privateNextLoop.</body><body package="Debugger-Support" selector="privateMakeFullMethod">privateMakeFullMethod	"This method assumes the selected context is a method context.	It cuts back the context stack to the context and replaces	the context's method with a temporary new full probed method."	| tempMethod newMethod newContext theContext |	tempMethod := TempMethods at: currentContext ifAbsent: [].	newMethod := (currentContext method mclass compiledMethodAt: selector) newTempFullProbedMethod.	tempMethod notNil		ifTrue:			[tempMethod allProbesDo:				[:aProbe |				aProbe isTemporary 					ifTrue: [aProbe reinsertInto: newMethod]]].	theContext := currentContext.	self		cutbackTo: theContext		finishWith:			[self performDebugOperation:				[newContext := theContext resizedWith: newMethod.				TempMethods at: newContext put: newMethod.				sourceMap := newContext visibleSourceMap.				processHandle interrupted: true.				self forceResetContext: newContext.				nil]].</body><body package="Debugger-Support" selector="privateNextLoop">privateNextLoop	"Executes continually in the debugger until an break occurs or the method returns."	| currContext parentContext |	self checkContextSelection.	processHandle prepareForSimulation.	currentContext pc = 1		ifTrue: [self resetContext: currentContext. "In case of restart, set the context to be the top."].	currContext := parentContext := self getContinueInDebugCtx.	currContext == processHandle topContext		ifFalse: [currContext := currContext pdpCompleteCallee: processHandle topContext].	currContext == parentContext		ifTrue: [currContext := currContext stepForever].	currContext == processHandle topContext		ifTrue: [self context: currContext]		ifFalse: [self resetContext: currContext].	self scheduleInspectorUpdate.</body><body package="Debugger-Support" selector="privateRunTillBreak">privateRunTillBreak	| currContext homeContext |	homeContext := currentContext supposedHome.	currContext := currentContext.	[	currentContext == processHandle topContext		ifFalse: [currContext :=currentContext pdpCompleteCallee: processHandle topContext].	currContext == currentContext		ifTrue:			[[currContext := currContext stepForever.			((currContext supposedHome == homeContext) and: [currContext willExitMethod]) not					and: [currContext hasSender: homeContext]]				whileTrue: [currContext := currContext pdpCompleteCallee: currContext step]].	self removeStepProbes.	]		on: ControlInterrupt , ContextEmergencyError , UserInterrupt		do:			[:ex |			ex restartDo:				[self emergencyRestart: ex.				self removeStepProbes.				self scheduleTextUpdate.				^true.				]			].	^false</body><body package="Debugger-Support" selector="privateSend">privateSend	"The top context on the stack must be selected.  This being so, either some message	is about to be sent in that context, or that context is about to return.  Send is only	effective in the former case.  It will cause the next message to be sent.  The send is	actually simulated, so that the debugger will regain control at the beginning of the	method which is invoked (unless it is a primitive).  In this way, you can step your	way deeper into a computation" 	| newCtx  |	self checkContextSelection.	currentContext ~~ processHandle topContext		ifTrue: [^self].	processHandle prepareForSimulation.	newCtx :=  currentContext pdpStepUntilVisibleEffect.	newCtx := newCtx == currentContext		ifTrue: [currentContext send]		ifFalse: [currentContext pdpCompleteCallee: newCtx].	newCtx == currentContext		ifTrue: [^self finishStep].	self resetContext: newCtx.	currentContext pdpStepUntilPC: self stopPC.	self schedulePCUpdate.</body><body package="Debugger-Support" selector="privateSimulateStepIntoBlock">privateSimulateStepIntoBlock	"The top context on the stack must be selected.  Keep sending until a	child block of the selected context's home method is entered." 	| newCtx  |	newCtx := currentContext sendIntoBlockStartingWithCallee: processHandle topContext pdpStepUntilVisibleEffect.	self forceResetContext: newCtx.	self finishStep</body><body package="Debugger-Support" selector="privateSkipToCaret">privateSkipToCaret	"Executes and stops at the beginning of a statement that the user 	indicates by a caret. The breakPC is one after the last executed pc."	| currContext probeRecord breakMethod probe stopPC status |	self checkContextSelection.	processHandle prepareForSimulation.	currentContext pc = 1		ifTrue: [self resetContext: currentContext. "In case of restart, set the context to be the top."].	probeRecord := currentContext sourceInfo: [:nodeHolder :i | nodeHolder node probeRecordFor: selectionRange].	breakMethod := currentContext method homeMethod blockAt: probeRecord blockMethodIndex.	breakMethod == currentContext method		ifTrue:			[currContext := currentContext.			currentContext == processHandle topContext				ifFalse: [currContext := currentContext pdpCompleteCallee: processHandle topContext].			stopPC := probeRecord insertionPC.			currContext == currentContext				ifTrue: [currContext := currContext stepUntilSkipPC: stopPC]]		ifFalse:			[breakMethod homeMethod isProbeable				ifFalse:					[^self scheduleMessage: (#CannotInsertProbeIntoThisMethodType &lt;&lt; #pdp &gt;&gt; 'Sorry, probes cannot be inserted into this method type.')].			status := self				basicAddProbe: (ProbeCreationSpec									type: #Breakpoint									conditional: false									permanent: false) setIsAutoProbe				using: probeRecord.			status key				ifFalse: [^self scheduleMessage: status value].			probe := status value.			self addStepProbe: probe with: currentContext supposedHome.			self privateRunTillBreak				ifTrue: [^self]].	currContext == processHandle topContext		ifTrue: [self context: currContext]		ifFalse: [self resetContext: currContext].	self scheduleInspectorUpdate</body><body package="Debugger-Support" selector="privateStep">privateStep	"Step will cause the next message to be sent, or the expression to be 	assigned, or the return to be executed.  In either case, the debugger 	regains control so that you can step your way down through a method, 	and out to the caller when it returns."	self checkContextSelection.	processHandle prepareForSimulation.	currentContext pc = 1		ifTrue:			["In case of restart, set the context to be the top."			self resetContext: currentContext].	currentContext == processHandle topContext		ifTrue: [self byteStep] 		ifFalse: [self resetContext: (currentContext pdpCompleteCallee: processHandle topContext)].	self finishStep.</body><body package="Debugger-Support" selector="privateStepIntoBlock">privateStepIntoBlock	| closures origMethod |	self checkContextSelection.	processHandle prepareForSimulation.	currentContext pc = 1		ifTrue: [self resetContext: currentContext. "In case of restart, set the context to be the top."].	(currentContext ~~ processHandle topContext or: [currentContext supposedHome isNil])		ifTrue: [^self privateSimulateStepIntoBlock].	origMethod := currentContext method homeMethod originalMethod.	closures := currentContext messageObjects select:		[:obj | (obj isKindOf: BlockClosure) and: [obj method homeMethod originalMethod == origMethod]].	closures do: [:cl | cl changeClassTo: DebugStepIntoBlockClosure].	[ | startContext currContext |	processHandle process environment at: #_dbg_step_into_block put: true.	dontUpdateInspectors := true.	startContext := currentContext.	self byteStep.	self finishStep.	currContext := startContext stepToCtxtWithSameParentAs: currentContext.	currContext == currentContext		ifFalse: [self resetContext: currContext].	dontUpdateInspectors := false.	self refreshInspectorsFromCurrentContext.	]		on: ControlInterrupt , ContextEmergencyError , UserInterrupt		do:			[:ex |			ex restartDo:				[				closures do: [:cl | cl changeClassTo: BlockClosure].				processHandle process environment at: #_dbg_step_into_block put: false.				self emergencyRestart: ex.				dontUpdateInspectors := false.				self refreshInspectorsFromCurrentContext.				self scheduleTextUpdate.				]			].	processHandle process environment at: #_dbg_step_into_block put: false.	closures do: [:cl | cl changeClassTo: BlockClosure]."Smalltalk Professional Debug Package Version 3.1 (c) 2002 Crafted Smalltalk"</body><body package="Debugger-Support" selector="setLoopControlContext">setLoopControlContext	^continueInDebuggerCtx at: 1 put: currentContext</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>doIt/accept/explain</category><body package="Debugger-Support" selector="acceptTextFrom:">acceptTextFrom: textController	| result |	result := self compileText: textController text from: textController.	result isNil		ifTrue: [^nil].	self methodChanged: result key selector: result value.	^true</body><body package="Debugger-Support" selector="browseMethod">browseMethod	self spawnBrowserOnMethod: self selectedMethod</body><body package="Debugger-Support" selector="compileText:from:">compileText: theText from: textController	| oldMethod classOfMethod newSelector newMethod |	oldMethod := self selectedMethod.	classOfMethod := oldMethod mclass.	newSelector := classOfMethod			compile: theText			classified: ClassOrganizer defaultProtocol			notifying: textController.	newSelector == nil		ifTrue: [^nil].	"must fix this, nothing happens"	newMethod := classOfMethod compiledMethodAt: newSelector.	newSelector ~~ selector		ifTrue:			[self spawnBrowserOnMethod: newMethod.			self context: currentContext.	"Reselect current context and refresh display" 			self processEvents.			^nil].	oldMethod isProbed		ifTrue: [newMethod := PDPManager reinsertProbesAfterMethod: newMethod recompileFor: theText].	PDPManager		changedMethodFrom: oldMethod		to: newMethod		by: self.	^newMethod -&gt; newSelector</body><body package="Debugger-Support" selector="doItContext">doItContext	"Answer the context in which a text selection can be evaluated."	^currentContext</body><body package="Debugger-Support" selector="doItEnvironment">doItEnvironment	"Answer the object that should be informed of the result of evaluating a	text selection."	currentContext == nil ifTrue: [^ nil].	^currentContext method environment</body><body package="Debugger-Support" selector="doItReceiver">doItReceiver	"Answer the object that should be informed of the result of evaluating a	text selection."	currentContext == nil ifTrue: [^ nil].	^currentContext homeReceiver</body><body package="Debugger-Support" selector="doItValue:">doItValue: anObject 	"Set the value to be returned when the interrupted process proceeds."	processHandle proceedValue: anObject</body><body package="Debugger-Support" selector="explainFor:">explainFor: aController	"Try to shed some light on what kind of entity the controller's current selection is.	The selection must be a single token or construct."	Explainer		explain: aController selection string		class: self selectedClass		selector: selector		methodText: self text		for: self</body><body package="Debugger-Support" selector="explainSpecial:for:">explainSpecial: string for: explainer	"Answer with a string explaining the code view selection if it is 	displaying one of the special edit functions."	^nil</body><body package="Debugger-Support" selector="formatFor:">formatFor: aController 	| theText |	theText := (Refactory.Browser.RBParser parseMethod: aController text				onError: 					[:aString :position | 					^aController 						insertAndSelect: (#x1s &lt;&lt; #pdp &gt;&gt; '&lt;1s&gt; -%&gt;' expandMacrosWith: aString)						at: position]) 					formattedCode.	theText isNil ifTrue: [^nil].	theText := theText asText makeSelectorBoldIn: currentContext mclass.	aController		selectFrom: 1 to: aController text size;		deselect;		replaceSelectionWith: theText asText;		selectAt: 1.	aController view selectionStopIndex: aController text size + 1.	aController view invalidate</body><body package="Debugger-Support" selector="methodChanged:selector:">methodChanged: newMethod selector: aSelector	| classOfMethod newContext |	classOfMethod := currentContext mclass.	newContext := self homeContextForCutback.	self		cutbackTo: newContext		finishWith:			[self performDebugOperation:				[newContext := newContext resizedWith: newMethod.				(classOfMethod compiledMethodAt: aSelector) == newMethod					ifFalse: [TempMethods at: newContext put: newMethod].				sourceMap := newContext visibleSourceMap.				processHandle interrupted: true.				self forceResetContext: newContext]].	self scheduleTextUpdate.	self processEvents.	^true</body><body package="Debugger-Support" selector="spawnBrowserOnMethod:">spawnBrowserOnMethod: aMethod 	Refactory.Browser.RefactoringBrowser 		openOnEnvironment: (Refactory.Browser.SelectorEnvironment 				onMethods: (Array 						with: (Refactory.Browser.RBMethodDefinition class: aMethod mclass								selector: aMethod selector)))</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>must fix</category><body package="Debugger-Support" selector="changedMethodFrom:to:by:">changedMethodFrom: oldMethod to: newMethod by: aBrowser 	"This message notifies the receiver that the method text for	some method has changed and should be updated."	| oldestContext message answer aSelector aClass |	self isTerminated		ifTrue: [^self].	serviceProcess notNil	"If not nil then we are executing a debug operation."		ifTrue: [^self].	(oldMethod isNil or: [processHandle isInDebugSession not])		ifTrue: [^self].	aSelector := newMethod selector.	aClass := newMethod mclass.	(aBrowser == self and:		[aClass == self selectedClass and:			[aSelector  == self selector]])				ifTrue:					[self scheduleTextUpdate.					^self resetPCSelection].	(oldestContext := self findOldestContextUsing: (Array with: oldMethod originalMethod)) == nil		ifTrue: [^self].	message := (#Method1sInClass2sChangedWhatToDo &lt;&lt; #pdp &gt;&gt; 'The method &lt;1s&gt; in class &lt;2s&gt; has changed, and is in the debugger sender chain.&lt;n&gt;What do you want to do?')		expandMacrosWith: aSelector		with: aClass shortName.	answer := Dialog				choose:  message asParagraph centered				labels: (Array with: (#ExitDebugger &lt;&lt; #pdp &gt;&gt; 'Exit Debugger') with: (#IgnoreChange &lt;&lt; #pdp &gt;&gt; 'Ignore Change') with: (#ResendMessage &lt;&lt; #pdp &gt;&gt; 'Resend Message'))				values: #(0 1 2)				default: 0.	answer = 0		ifTrue: [^self closeDebugger].	self scheduleContextListUpdate.	answer = 2		ifTrue: [self resetOnMethodChange: aSelector in: aClass context: oldestContext].	self processEvents</body><body package="Debugger-Support" selector="makeProbeTyped:using:at:method:">makeProbeTyped: probeType using: aProbeRecord at: anInterval method: probedMethod	"Prompts the user to select a probe and returns an Association where the key is the probe	and the value is the conditional flag."	| probe probeRecord |	probeRecord := aProbeRecord isNil		ifTrue: [probedMethod probeRecordFor: anInterval]		ifFalse: [aProbeRecord].	probeType == #Breakpoint		ifTrue: [probe := CodeProbe new].	probeType == #Variable		ifTrue:			[probe := self				promptForProbeVariableClass: self selectedClass				method: probedMethod				record: probeRecord.			probe isNil				ifTrue: [^nil]].	probeType == #Expression		ifTrue: [probe := DisplayActionProbe new].	probe record: probeRecord.	^probe</body><body package="Debugger-Support" selector="promptForProbeVariableClass:method:record:">promptForProbeVariableClass: aClass method: probedMethod record: probeRecord	"Prompts the user to select a probe and returns an Association where the key is the probe	and the value is the conditional flag."	| legalTempNames legalTemps ivarNames dialog aBuilder ivar tmpVar windoe wVar varType |	windoe := self interfaceWindow.	wVar := ValueHolder newString.	legalTemps := OrderedCollection new.	(probedMethod variableMapAt: probeRecord blockMethodIndex) temps do:		[:var |		(var key first == $. or: [legalTemps contains: [:lvar | lvar key = var key]])			ifFalse: [legalTemps add: var]].	legalTempNames := legalTemps collect: [:ac | ac key].	ivarNames := aClass allInstVarNames.	dialog := SimpleDialog new.	dialog initializeBuilderFor: windoe.	aBuilder := dialog builder.	aBuilder		aspectAt: #TOS		put: [varType := #tos.			wVar value: 'Top of Stack'].	aBuilder		aspectAt: #iVar		put: [ivar := (Menu				labelArray: ivarNames				values: ivarNames) startUp.			ivar ~~ 0				ifTrue:					[wVar value: ivar.					varType := #inst]].	aBuilder		aspectAt: #tVar		put: [tmpVar := (Menu				labelArray: legalTempNames				values: legalTemps) startUp.			tmpVar ~~ 0				ifTrue:					[wVar value: tmpVar key.					varType := #tmp]].	aBuilder		aspectAt: #wVar		put: wVar.	dialog builder add: (UISpecification from: self class watchVarSpec).	dialog initializeWindowFor: windoe.	ivarNames isEmpty		ifTrue: [(aBuilder componentAt: #IvarSwitch) disable].	legalTemps isEmpty		ifTrue: [(aBuilder componentAt: #TempSwitch) disable].	dialog preOpen.	dialog builder openDialogWithExtent: dialog builder window displayBox extent.	dialog accept value		ifFalse: [^nil].	varType == nil		ifTrue: [^nil].	varType == #tos		ifTrue: [^DisplayTOSProbe new].	varType == #inst		ifTrue: [^DisplayInstanceVarProbe name: ivar index: (ivarNames indexOf: ivar)].	^DisplayMethodVarProbe slot: tmpVar</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>spelling correction</category><body package="Debugger-Support" selector="basicDefineMethod">basicDefineMethod	self compileTemplate: self dnuSelector inClass: processHandle topContext receiver class.	self selectContext: self contextFirstSendingDNU.	self basicStep.</body><body package="Debugger-Support" selector="canCorrectSpelling">canCorrectSpelling	"Spelling can be corrected if the context above the selected context is	#doesNotUnderstand and selected context is not sending a special messge and	the selected context is also not #doesNotUnderstand."	| ctx sel |	ctx := self contextFirstSendingDNU.	ctx == self topContext		ifTrue: [^false].	sel := self getSentSelectorFor: ctx.	^(#(#doesNotUnderstand: #perform: #perform:with: #perform:with:with: #perform:with:with:with: #perform:withArguments: #_object:perform:withArguments:)		includes:  sel) not</body><body package="Debugger-Support" selector="canDefineMethod">canDefineMethod	^self topContext selector == #doesNotUnderstand:</body><body package="Debugger-Support" selector="compileTemplate:inClass:">compileTemplate: aSelector inClass: aClass	| keyWords strm nArg |	keyWords := aSelector keywords.	strm := WriteStream on: (String new: 64).	nArg := 1.	keyWords		do: [:str |			strm nextPutAll: str.			str last = $:				ifTrue:					[strm space.					strm nextPutAll: 'arg'.					nArg printOn: strm].			nArg := nArg + 1]		separatedBy: [strm space].	strm nextPutAll: '	"Dummy method template.  This was installed by the debugger	define method command."	^self halt'.	aClass		compile: strm contents		classified: ClassOrganizer defaultProtocol		notifying: nil.</body><body package="Debugger-Support" selector="contextFirstSendingDNU">contextFirstSendingDNU	^contextStackPolicy contextList detect: [:ctx | ctx selector ~~ #doesNotUnderstand: ] ifNone: [nil].</body><body package="Debugger-Support" selector="correctDNUWith:">correctDNUWith: guess 	self performDebugRequest: #privateCorrectDNUWith: withArguments: (Array with:guess)</body><body package="Debugger-Support" selector="correctTextWith:">correctTextWith: guess	| text msgRange nuSelectorStream offset positions tStream start partStart |	text := self text.	msgRange := self pcRange value.	nuSelectorStream := ReadStream on: guess keywords.	offset := msgRange first.	positions := Parser new keywordPositionsIn: (text copyFrom: offset to: msgRange last).	offset := offset - 1.	"because positions are based on 1 we must adjust offset"	tStream := TextStream on: (String new: text size).	start := 1.	positions isNil		ifTrue: [positions := Array with: 1 -&gt; msgRange size].	positions do:		[:ac |		partStart := ac key + offset.		tStream nextPutAllText: (text copyFrom: start to: partStart - 1).		tStream nextPutAllText: nuSelectorStream next asText.		start := partStart + ac value].			" a probe in the selector will get lost."	tStream nextPutAllText: (text copyFrom: start to: text size).	^tStream contents.</body><body package="Debugger-Support" selector="defineMethod">defineMethod	self performDebugRequest: #basicDefineMethod.</body><body package="Debugger-Support" selector="dnuSelector">dnuSelector	^(processHandle topContext localAt: 1) selector</body><body package="Debugger-Support" selector="getSentSelectorFor:">getSentSelectorFor: aContext	"We get the selector this way instead of getting from the message	held by the dnu context because we want the actual message sent.	In the case of a #perform: we want the #perform:, not its argument."	| presendPC pc sel |	presendPC := self presendPCFor: aContext.	pc := aContext pc.	aContext jump: presendPC - pc.	sel := aContext peekForSelector.	aContext jump: pc - presendPC.	^sel</body><body package="Debugger-Support" selector="possibleDNUCorrections">possibleDNUCorrections	| oldSelector oldFirst oldArgs selectors |	oldSelector := self dnuSelector.	oldFirst := oldSelector first.	oldArgs := oldSelector numArgs.	selectors := (self _objectClass: processHandle topContext receiver) allSelectors select: 		[:sel |		sel first = oldFirst and:			[sel numArgs = oldArgs and: 				[(sel spellAgainst: oldSelector) &gt; 10]]].	^selectors</body><body package="Debugger-Support" selector="prepareDNUForResend">prepareDNUForResend	| theContext |	theContext := self contextFirstSendingDNU.	theContext restackMessage: (processHandle topContext localAt: 1) to: processHandle topContext receiver.	theContext jump: (self presendPCFor: theContext) - theContext pc.	self forceResetContext: theContext.	processHandle interrupted: true.	^theContext.</body><body package="Debugger-Support" selector="presendPCFor:">presendPCFor: aContext	"Find the pc before the message send."	| pc i size map |	map := currentContext == aContext		ifTrue: [sourceMap]		ifFalse: [aContext sourceMap].	pc:= aContext pc.	 "When selecting a context in middle of the stack,	the pc points to the byte code after the send."	i := 1. 	size := map size.	[i &lt;= size and: [(map at: i) key &lt; pc]] 		whileTrue: [i := i + 1].	i &gt; 1		ifTrue: [pc := (map at: i - 1) key].	pc := pc - 1.	i := map indexForInserting: (Association key: pc value: nil).	i &lt; 1		ifTrue: [^0].	i &gt; map size		ifTrue: [^0].	^(map at: i) key</body><body package="Debugger-Support" selector="privateCorrectDNUWith:">privateCorrectDNUWith: guess 	| newText methodAndSelector oldMethod blockIndex method |	self selectContext: self contextFirstSendingDNU.	newText := self correctTextWith: guess.	methodAndSelector := self compileText: newText from: nil.	methodAndSelector isNil ifTrue: [^false].	method := currentContext method.	oldMethod := method homeMethod.	self prepareDNUForResend.	blockIndex := method blockMethodIndex.	(DebugProbeInserter for: self) 		adjustDynamicsReplacing: oldMethod		with: methodAndSelector key		from: blockIndex		atPC: currentContext pc		addProbe: false		originalPCMap: (oldMethod sourceMapAt: blockIndex).</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>stack manipulation</category><body package="Debugger-Support" selector="checkContextSelection">checkContextSelection  	"Determine whether the currently selected context has been set, 	and if not, set it."	currentContext == nil ifTrue: [currentContext := processHandle topContext]</body><body package="Debugger-Support" selector="emergencyRestart:">emergencyRestart: exp	"Respond to an Context&gt;&gt;emergencySignal arising during simulation."	| aContext anException sender cMClass |	anException := exp.	exp creator == ContextEmergencyError		ifTrue: [anException := exp parameter].	(ControlInterrupt handles: anException)		ifTrue:			[(aContext := anException parameter) isNil ifTrue:				[aContext := anException initialContext].			label := anException errorString]		ifFalse:			[aContext := anException initialContext.			label := ((#UnhandledExceptionC1s &lt;&lt; #pdp &gt;&gt; 'Unhandled exception: &lt;1s&gt;')			expandMacrosWith: anException errorString)].	(StepIntoBlockNotification handles: anException)		ifTrue:			[sender := aContext sender.			cMClass := sender mclass.			[sender mclass == cMClass] whileTrue: [sender := sender sender].			aContext sender: sender].	"undo all grabs for event driven"	InputState default ungrabBecauseOfError.	self scheduleLabelUpdate.	processHandle topContext: aContext.	processHandle interrupted: (UserInterrupt handles: anException).	self context: aContext.	self scheduleContextListUpdate.	(StepIntoBlockNotification handles: anException)		ifFalse:			[anException initialContext == aContext				ifFalse: [anException initialContext unwindUpTo: aContext]].	currentContext pc = self stopPC		ifTrue: [^self].	self step.</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>actions</category><body package="Debugger-Support" selector="browseClass">browseClass	| rcvr |	((rcvr := currentContext homeReceiver) notNil or: [rcvr class == currentContext mclass])		ifTrue: [rcvr browse]		ifFalse: [currentContext mclass instanceBehavior browse]</body><body package="Debugger-Support" selector="correctSpelling">correctSpelling	"Attempt to correct the spelling of the not-understood message and resend."	| oldSelector oldFirst oldArgs selectors guess   msg |	processHandle topContext selector == #doesNotUnderstand:		ifFalse: [^self].	msg := processHandle topContext localAt: 1.	oldSelector := msg selector.	oldFirst := oldSelector first.	oldArgs := oldSelector numArgs.	selectors := (self _objectClass: processHandle topContext receiver) allSelectors select: 		[:sel | sel first = oldFirst and: [sel numArgs = oldArgs and: 				[(sel spellAgainst: oldSelector) &gt; 10]]].	selectors isEmpty ifTrue: [^Dialog warn: (#CouldntCorrect &lt;&lt; #pdp &gt;&gt; 'Couldn''t correct')].	selectors := selectors asArray.	guess := Dialog				choose: (#CorrectToDots &lt;&lt; #pdp &gt;&gt; 'Correct to...')				fromList: selectors				values: selectors				lines: 8				cancel: [^'']				for: nil.	(Dialog confirm: ((#RetryWithSelectorCnt1s &lt;&lt; #pdp &gt;&gt; 'Retry with Selector:&lt;nt&gt;&lt;1s&gt;')			expandMacrosWith: guess) for: nil)		ifFalse: [^self].	msg setSelector: guess arguments: msg arguments.	^self basicProceed</body><body package="Debugger-Support" selector="inspectCurrentContext">inspectCurrentContext	currentContext inspect</body><body package="Debugger-Support" selector="revert">revert	| mclass oldMethod newMethod |	mclass := self selectedClass.	selector isNil | mclass isNil		ifTrue: [^false].	Store.DbRegistry doIfOnlineImage:		[oldMethod := self selectedMethod.		(Store.XChangeSet current revertSelector: selector class: mclass)			ifFalse: [^false].		newMethod := mclass compiledMethodAt: selector.		PDPManager			changedMethodFrom: oldMethod			to: newMethod			by: self.		self methodChanged: newMethod selector: selector].	^true</body><body package="Debugger-Support" selector="stackForCopy">stackForCopy	| cp |	cp := ContextDumpPolicy new.	cp stack: contextStackPolicy contextList	.	cp errorMessage: label.	^cp copyStackString</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>private-inspectors</category><body package="Debugger-Support" selector="openInspectors">openInspectors	"Further initialization when opening notify view to debug view"	receiverInspector := PrimitiveObjectInspector inspect: nil.	contextInspector := ContextInspector inspect: nil.	stackInspector := StackInspector inspect: nil.</body><body package="Debugger-Support" selector="resetInspectorFields">resetInspectorFields	receiverInspector resetFieldsForDebugger.	contextInspector resetFields.	stackInspector resetFields.</body><body package="Debugger-Support" selector="updateInspectors">updateInspectors	receiverInspector update.	contextInspector update.	stackInspector updateAsTop: currentContext == processHandle topContext.</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>private-pc selection</category><body package="Debugger-Support" selector="privatePcRange">privatePcRange	"Answer the indices in the source code for the method corresponding	to the selected context's program counter value."	| pc i size end |	self context == nil		ifTrue: [^1 to: 0].	(sourceMap == nil or: [sourceMap size = 0])		 ifTrue: [^1 to: 0].	pc:= self context pc.	(self context == processHandle topContext and: [processHandle interrupted])		ifFalse: "When selecting a context in middle of the stack or the context 'halt',				the pc points to the byte code after the send."			[i := 1. 			size := sourceMap size.			[i &lt;= size and: [(sourceMap at: i) key &lt; pc]] 				whileTrue: [i := i + 1].			i &gt; 1 ifTrue: [pc := (sourceMap at: i - 1) key]].	pc := pc - 1.	i := sourceMap indexForInserting: (Association key: pc value: nil).	i &lt; 1 ifTrue: [^1 to: 0].	i &gt; sourceMap size		ifTrue:			[end := sourceMap inject: 0 into:				[:prev :this | prev max: this value last].			^ end+1 to: end].	^(sourceMap at: i) value</body><body package="Debugger-Support" selector="resetPCSelection">resetPCSelection	sourceMap := currentContext visibleSourceMap.	self schedulePCUpdate.</body><body package="Debugger-Support" selector="stopPC">stopPC	"Returns the next pc in the map."	| i |	i := sourceMap indexForInserting: (currentContext pc - 1) -&gt; nil.	^(i &gt; sourceMap size		ifTrue: [currentContext method bytesSize]		ifFalse: [(sourceMap at: i) key])</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>initialize-release</category><body package="Debugger-Support" selector="initialize">initialize	pendingEvents := Set new.	continueInDebuggerCtx := WeakArray new: 1.	tags := PDPWeakCollection new.	stepProbes := OrderedCollection new.	dontUpdateInspectors := false.	contextStackPolicy := ContextListPolicy debugger: self.	self openInspectors.	PDPManager notifyOnMethodChanged: self.</body><body package="Debugger-Support" selector="onHandle:">onHandle: aProcessHandle	processHandle := aProcessHandle.	oldCursor := Cursor currentCursor.	contextStackPolicy computeContextList.	self selectContextAt: 1.</body><body package="Debugger-Support" selector="prepareForErrorCondition">prepareForErrorCondition	processHandle prepareForErrorCondition</body><body package="Debugger-Support" selector="process:context:interrupted:">process: aProcess context: aContext interrupted: aBoolean	self onHandle: (ProcessHandle on: aProcess at: aContext interrupted: aBoolean)</body><body package="Debugger-Support" selector="process:context:interrupted:proceedable:">process: aProcess context: aContext interrupted: aBoolean proceedable: proceedBoolean	self onHandle: (ProcessHandle on: aProcess at: aContext interrupted: aBoolean)</body><body package="Debugger-Support" selector="removeAllDependents">removeAllDependents	dependents := nil.</body><body package="Debugger-Support" selector="removeDependent:">removeDependent: aDependent 	super removeDependent: aDependent.	self dependents isEmpty ifTrue: [processHandle terminate]</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>private-return</category><body package="Debugger-Support" selector="basicCompleteReturn:with:">basicCompleteReturn: rtnMsg with: rtnValue	| theContext currContext |	theContext := currentContext.	self		cutbackTo: theContext		finishWith:			[self performDebugOperation:				[processHandle interrupted: true.				currContext := theContext pdpCompleteCallee: (theContext perform: rtnMsg with: rtnValue).				self forceResetContext: currContext.				self finishStep.				nil]].</body><body package="Debugger-Support" selector="completeReturn:with:">completeReturn: rtnMsg with: rtnValue	self performDebugRequest: #basicCompleteReturn:with: withArguments: (Array with: rtnMsg with: rtnValue)</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService class</class-id> <category>instance creation</category><body package="Debugger-Support" selector="breakOn:">breakOn: anException	"NOTICE:	This method assumes that the process is cut back and will require	a return object to be pushed on the stack."	self openOn: anException parameter exception: anException interrupted: false."Smalltalk Professional Debug Package Version 3.0 (c) 2001 Crafted Smalltalk"</body><body package="Debugger-Support" selector="context:proceedable:interrupted:">context: aContext proceedable: aBoolean interrupted: interrupted	| aDebugger |	aDebugger := self new.	aDebugger		process: Processor activeProcess		context: aContext		interrupted: interrupted.	^aDebugger</body><body package="Debugger-Support" selector="interruptOn:">interruptOn: anException	"NOTICE:	This method assumes that the process is NOT cut back and will	NOT require a return object to be pushed on the stack."	self openOn: anException parameter exception: anException interrupted: true"Smalltalk Professional Debug Package Version 3.0 (c) 2001 Crafted Smalltalk"</body><body package="Debugger-Support" selector="new">new	^super new initialize"Smalltalk Professional Debug Package Version 3.0 (c) 2001 Crafted Smalltalk"</body><body package="Debugger-Support" selector="openOnProcess:interrupted:label:">openOnProcess: aProcess interrupted: aBoolean label: aString	^self		openOnHandle:			(ProcessHandle				on: aProcess				interrupted: aBoolean)		label: aString"Smalltalk Professional Debug Package Version 3.0 (c) 2001 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService class</class-id> <category>private</category><body package="Debugger-Support" selector="enableWindowsIfNotEventFaithfulFor:">enableWindowsIfNotEventFaithfulFor: aProcess	EventFaithfulDebugging ifTrue: [^self].	aProcess windowManager ifNotNil: [:value | value launchBaseProcess].</body><body package="Debugger-Support" selector="resyncEvents">resyncEvents	EventQueue allInstancesDo: [:each | each restoreReadSynchSignals].</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService class</class-id> <category>class initialization</category><body package="Debugger-Support" selector="initialize">initialize	TempMethods := PDPWeakDictionary weakKeys.	EventFaithfulDebugging := false.	DefaultToPermanentProbe := true.</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService class</class-id> <category>instance creation - compatibility</category><body package="Debugger-Support" selector="getDisplayPoint">getDisplayPoint	| windowManager |	windowManager:= Processor activeProcess environmentAt: #WindowManager.	^[(windowManager isNil or: [windowManager activeController isNil])		ifTrue: [Screen default bounds center]		ifFalse: [windowManager activeController view displayBox center]]			on: Error			do: [:exception | exception return: Screen default bounds center]</body><body package="Debugger-Support" selector="openContext:label:proceedable:">openContext: haltContext label: aString proceedable: aBoolean	"Create and schedule an instance of me viewing a Debugger on haltContext.	The view will be labeled with aString, and will show a short sender stack."	self openContext: haltContext label: aString proceedable: aBoolean interrupted: false</body><body package="Debugger-Support" selector="openContext:label:proceedable:interrupted:">openContext: haltContext label: aString proceedable: aBoolean interrupted: interrupted	"Create and schedule an instance of me viewing a Debugger on haltContext.	The view will be labeled with aString, and will show a short sender stack."	| displayPoint contentsString dbr |	self prepareForDebugging.	contentsString := self shortStackFor: haltContext ofSize: 5.	displayPoint := self getDisplayPoint.	thisContext unwindUpTo: haltContext.	dbr := self context: haltContext proceedable: aBoolean interrupted: interrupted.	Processor activeProcess		suspendResumable: false		do: [:proc |			self openDebugger: dbr				contents: contentsString				label: aString				proceed: aBoolean				displayAt: displayPoint.			self enableWindowsIfNotEventFaithfulFor: proc].</body><body package="Debugger-Support" selector="openDebugger:contents:label:proceed:displayAt:">openDebugger: aDebugger contents: aString1 label: aString2 proceed: mayProceed displayAt: aPoint	| box text y builder label actions specs width height copyStack correctIt baseFraction |	self prepareForDebugging.	Processor activeProcess priority: Processor userSchedulingPriority.	self logErrorFor: aDebugger label: aString2.	aDebugger prepareForErrorCondition.	builder := UIBuilder new.	builder windowOn: aDebugger label: (#Exception &lt;&lt; #pdp &gt;&gt; 'Exception').	aDebugger label: aString2.	text := (self limitString: aString2 lengthTo: 200 andLinesTo: 5) asText.	text emphasizeFrom: 1 to: text size with:			(Screen default colorDepth &lt; 4				ifTrue: [#bold]				ifFalse: [Array with: #bold with: #color-&gt;(ColorValue red: 0.8 green: 0 blue: 0)]).	text := ComposedText withText: text style: nil compositionWidth: 250.	y := text bounds height // 2 max: 16.	label := LabelSpec new hasCharacterOrientedLabel: false.	label setLabel: builder policy alertIcon.	label layout: (AlignmentOrigin new				leftOffset: 48; topOffset: y+16;				leftAlignmentFraction: 1;				topAlignmentFraction: 0.5).	builder add: label.	label := LabelSpec new hasCharacterOrientedLabel: false.	label setLabel: text.	label layout: (AlignmentOrigin new				leftOffset: 56; topOffset: y+16;				leftAlignmentFraction: 0;				topAlignmentFraction: 0.5).	y := y * 2 + 32.	builder add: label.	actions := OrderedCollection			with: (#Debug &lt;&lt; #pdp &gt;&gt; 'Debug') -&gt;					[self clientClass						openFullViewOn: aDebugger						label: aString2.					builder window model: nil.					builder window controller close]			with: (#Proceed &lt;&lt; #pdp &gt;&gt; 'Proceed') -&gt;	[aDebugger basicProceed.								builder window controller close.								self resyncEvents]			with: (#Terminate &lt;&lt; #pdp &gt;&gt; 'Terminate') -&gt;	[aDebugger terminate.								builder window controller close.								self resyncEvents].	specs := OrderedCollection new.	1 to: actions size do:		[:i | | action |		action := actions at: i.		specs add: (ActionButtonSpec				model: action value				label: action key				layout: (LayoutFrame new					leftFraction: i-1/actions size;					rightFraction: i / actions size;					topOffset: y;					bottomOffset: y)).		specs last defaultable: true.		action key = (#Debug &lt;&lt; #pdp &gt;&gt; 'Debug')			ifTrue:				[specs last isDefault: true.				builder add: specs last.				builder keyboardProcessor setActive: builder wrapper widget controller]			ifFalse: [builder add: specs last].		(action key = (#Proceed &lt;&lt; #pdp &gt;&gt; 'Proceed') and: [mayProceed not])			ifTrue: [builder wrapper disable]].	y := y + builder wrapper preferredBounds height.	specs do:		[:spec |		spec layout bottomOffset: y].	baseFraction := actions size - 1 / 2 / actions size.	copyStack := (ActionButtonSpec				model: [ParagraphEditor currentSelection: aDebugger stackForCopy asText]				label: (#CopyStack &lt;&lt; #pdp &gt;&gt; 'Copy Stack')				layout: (LayoutFrame new					leftFraction: baseFraction;					rightFraction: baseFraction + (1/actions size);					topOffset: y;					bottomOffset: y + builder wrapper preferredBounds height)).	copyStack defaultable: true.	builder add: copyStack.	(aDebugger interruptedContext ~~ nil	and: [aDebugger interruptedContext selector == #doesNotUnderstand:])		ifTrue:			[correctIt := (ActionButtonSpec					model:	[aDebugger correctSpelling.							builder window controller close.							self resyncEvents]					label: (#CorrectItDots &lt;&lt; #pdp &gt;&gt; 'Correct it...')					layout: (LayoutFrame new						leftFraction: baseFraction + (1/actions size);						rightFraction: baseFraction + (2/actions size);						topOffset: y;						bottomOffset: y + builder wrapper preferredBounds height)).			correctIt defaultable: true.			builder add: correctIt].	y := y + builder wrapper preferredBounds height.	label := LabelSpec new hasCharacterOrientedLabel: false.	label setLabel: aString1 asComposedText.	label layout: (AlignmentOrigin new				leftFraction: 0.5 offset: 0;				topFraction: 0.5 offset: y // 2;				leftAlignmentFraction: 0.5;				topAlignmentFraction: 0.5).	builder add: label.	width := 320 max: label getLabel bounds width+12.	height := y + label getLabel bounds height + 6.	box := 0@0 corner: width@height.	box := box align: box center with: aPoint.	builder openIn: box.</body><body package="Debugger-Support" selector="openException:">openException: exception	exception ifUnhandledOpenDebugger		ifTrue: [self openOnException: exception]		ifFalse: [self			openContext: exception parameter			label: exception errorString			proceedable: exception willProceed			interrupted: exception isInterrupt]</body><body package="Debugger-Support" selector="openNoModificationErrorNotifierForContext:error:label:proceedable:">openNoModificationErrorNotifierForContext: haltContext error: noModificationError label: aString proceedable: aBoolean 	"Create and schedule an instance of me viewing a Debugger on haltContext.	The view will be labeled with aString, and will show a short sender stack.	Include information that informs the user as to the NoModificationError	default werror treatments available and allows one to change them."	| displayPoint contentsString dbr |	self prepareForDebugging.	contentsString := self shortStackFor: haltContext ofSize: 5.	displayPoint := self getDisplayPoint.	thisContext unwindUpTo: haltContext.	dbr := self context: haltContext proceedable: aBoolean interrupted: false.	Processor activeProcess		suspendResumable: false		do: [:proc |			self 				openNoModificationNotifier: dbr				error: noModificationError				contents: contentsString				label: aString				displayAt: displayPoint.			self enableWindowsIfNotEventFaithfulFor: proc]</body><body package="Debugger-Support" selector="openNoModificationNotifier:error:contents:label:displayAt:">openNoModificationNotifier: aDebugger error: theNoModificationError contents: aString1 label: aString2 displayAt: aPoint	| box text helpText y builder label actions specs width height copyStack baseFraction radio errorModeRadioModel left radioButtonTop groupBox |	self prepareForDebugging.	Processor activeProcess priority: Processor userSchedulingPriority.	self logErrorFor: aDebugger label: aString2.	errorModeRadioModel := NoModificationError errorMode asValue.	aDebugger prepareForErrorCondition.	builder := UIBuilder new.	builder windowOn: aDebugger label: (#Exception &lt;&lt; #pdp &gt;&gt; 'Exception').	aDebugger label: aString2.	text := (self limitString: aString2 lengthTo: 200 andLinesTo: 5) asText.	text 		emphasizeFrom: 1 		to: text size 		with: (Screen default colorDepth &lt; 4			ifTrue: [#bold]			ifFalse: [Array with: #bold with: #color-&gt;(ColorValue red: 0.8 green: 0 blue: 0)]).	text := ComposedText withText: text style: nil compositionWidth: 250.	y := 10.	label := LabelSpec new hasCharacterOrientedLabel: false.	label setLabel: builder policy alertIcon.	label layout: (AlignmentOrigin new					leftOffset: 48;					topOffset: y + (text bounds height - builder policy alertIcon bounds height // 2 max: 0);					leftAlignmentFraction: 1).	builder add: label.	label := LabelSpec new hasCharacterOrientedLabel: false.	label setLabel: text.	label layout: (AlignmentOrigin new					leftOffset: 56;					topOffset: y;					leftAlignmentFraction: 0).	y := y  + text bounds height + 8.	builder add: label.		helpText := ComposedText 		withText: (#ItIsAnErrorToModifyImmutables &lt;&lt; #pdp &gt;&gt; 'It is an error in VW7 to modify immutable objects such as literals.For backward compatibility, you can disable these errorsby selecting a different immutability policy below and proceeding.This policy can also be changed using Settings&gt;Immutability.') asText		style: nil.	label := LabelSpec new hasCharacterOrientedLabel: false.	label setLabel: helpText.	label layout: (AlignmentOrigin new					leftOffset: 20;					topOffset: y;					leftAlignmentFraction: 0).	y := y + helpText bounds height + 8.	builder add: label.	radioButtonTop := y.	y := y + 24.	left := 40.	text := ComposedText withText: (#SignalAnError &lt;&lt; #pdp &gt;&gt; 'Signal an error') asText style: nil.	radio := RadioButtonSpec model: errorModeRadioModel label: text select: #error.	radio layout: (AlignmentOrigin new		leftOffset: left;		topOffset: y).	builder add: radio.	y := y + text bounds height.	text := ComposedText withText: (#PrintAWarningMakeMutable &lt;&lt; #pdp &gt;&gt; 'Print a warning and make the object mutable') asText style: nil.	radio := RadioButtonSpec model: errorModeRadioModel label: text select: #warn .	radio layout: (AlignmentOrigin new		leftOffset: left;		topOffset: y).	builder add: radio.	y := y + text bounds height.	text := ComposedText withText: (#SilentlyMakeTheObjectMutable &lt;&lt; #pdp &gt;&gt; 'Silently make the object mutable') asText style: nil.	radio := RadioButtonSpec model: errorModeRadioModel label: text select: #ignore .	radio layout: (AlignmentOrigin new		leftOffset: left;		topOffset: y).	builder add: radio.	y := y + builder wrapper preferredBounds height + 16.	text := ComposedText withText: (#OnAttemptToModifyImmutable &lt;&lt; #pdp &gt;&gt; 'On an attempt to modify an immutable object') asText style: nil.	groupBox := GroupBoxSpec label: text.	groupBox layout: (LayoutFrame		leftFraction: 0 offset: 20		rightFraction: 1 offset: -20		topFraction: 0 offset: radioButtonTop		bottomFraction: 0 offset: y).	builder add: groupBox.	y := y + 16.	actions := Array		with: (#Debug &lt;&lt; #pdp &gt;&gt; 'Debug') -&gt;			[NoModificationError errorMode: errorModeRadioModel value.			self clientClass				openFullViewOn: aDebugger				label: aString2.			builder window model: nil.			builder window controller close]		with: (#Proceed &lt;&lt; #pdp &gt;&gt; 'Proceed') -&gt;				["Sigh; exceptions don't really proceed correctly, instead we resume				 execution in the context that raised the error.  Better would be to proceed				 from the noHandler method.  Because this doesn't happen we have to				 retry here explicitly."				#error ~~ errorModeRadioModel value ifTrue:					[NoModificationError errorMode: errorModeRadioModel value.					 aDebugger doItValue: theNoModificationError makeObjectsMutableAndRetry].				aDebugger basicProceed.				builder window controller close]		with: (#Terminate &lt;&lt; #pdp &gt;&gt; 'Terminate') -&gt;				[NoModificationError errorMode: errorModeRadioModel value.				aDebugger terminate.				builder window controller close].	specs := OrderedCollection new.	1 to: actions size do:		[:index | | action |		action := actions at: index.		specs add: (ActionButtonSpec			model: action value			label: action key			layout: (LayoutFrame new				leftFraction: index - 1 / actions size;				leftOffset: (index = 1 ifTrue: [20] ifFalse: [0]);				rightFraction: index / actions size;				rightOffset: (index = actions size ifTrue: [-20] ifFalse: [0]);				topOffset: y;				bottomOffset: y)).		specs last defaultable: true.		action key = (#Debug &lt;&lt; #pdp &gt;&gt; 'Debug') 			ifTrue:				[specs last isDefault: true.				 builder add: specs last.				 builder keyboardProcessor setActive: builder wrapper widget controller]			ifFalse: [builder add: specs last].		(action key = (#Proceed &lt;&lt; #pdp &gt;&gt; 'Proceed') and: [aDebugger mayProceed not])			ifTrue: [builder wrapper disable]].	y := y + builder wrapper preferredBounds height.	specs do: [:spec | spec layout bottomOffset: y].	baseFraction := actions size - 1 / 2 / actions size.	copyStack := (ActionButtonSpec		model: [ParagraphEditor currentSelection: aDebugger stackForCopy asText]		label: (#CopyStack &lt;&lt; #pdp &gt;&gt; 'Copy Stack')		layout: (LayoutFrame new					leftFraction: baseFraction;					rightFraction: baseFraction + (1 / actions size);					topOffset: y;					bottomOffset: y + builder wrapper preferredBounds height)).	copyStack defaultable: true.	builder add: copyStack.	y := y + builder wrapper preferredBounds height + 8.	label := LabelSpec new hasCharacterOrientedLabel: false.	label setLabel: aString1 asComposedText.	label layout: (AlignmentOrigin new		leftFraction: 0.5 offset: 0;		topOffset: y;		leftAlignmentFraction: 0.5).	builder add: label.	y := y + builder wrapper preferredBounds height .	width := (420 max: label getLabel bounds width + 12)				max: helpText bounds width + 20.	height := y + 10.	box := 0 @ 0 corner: width @ height.	box := box align: box center with: aPoint.	builder openIn: box.</body><body package="Debugger-Support" selector="prepareForDebugging">prepareForDebugging	"undo all grabs for event driven and	Make sure that controllers without views are removed"	| manager |	InputState default ungrabBecauseOfError.	manager := self activeWindowManager.	manager ifNotNil: [manager purgeInvalidWindows].</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService class</class-id> <category>private - instance creation</category><body package="Debugger-Support" selector="debugException:">debugException: anException	self openOnException: anException</body><body package="Debugger-Support" selector="onHandle:">onHandle: aProcessHandle	^self new onHandle: aProcessHandle"Smalltalk Professional Debug Package Version 1.6 (c) 1998 Crafted Smalltalk"</body><body package="Debugger-Support" selector="openOn:exception:interrupted:">openOn: aContext exception: anException interrupted: aBoolean	| service |	self prepareForDebugging.	thisContext unwindUpTo: aContext.	service := self context: aContext proceedable: true interrupted: aBoolean.	service prepareForErrorCondition.	service label: anException description.	Processor activeProcess		suspendResumable: false		do: [:proc |			self clientClass openFullViewOn: service label: anException description.			self enableWindowsIfNotEventFaithfulFor: proc]</body><body package="Debugger-Support" selector="openOnException:">openOnException: anException	self openOn: anException topOfContextStack		exception: anException		interrupted: anException isInterrupt</body><body package="Debugger-Support" selector="openOnHandle:label:">openOnHandle: aProcessHandle label: aString	| service |	self prepareForDebugging.	service := self onHandle: aProcessHandle.	service label: aString.	service prepareForErrorCondition.	^self clientClass openFullViewOn: service label: aString</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService class</class-id> <category>utility</category><body package="Debugger-Support" selector="abortAllDebugging">abortAllDebugging	Process allInstances do:		[:p | | deb |		(deb := p environmentAt: #debugger) notNil			ifTrue: [deb abortDebugging]].</body><body package="Debugger-Support" selector="abortDebuggingFor:">abortDebuggingFor: aProcess	DebuggerService allInstances do: [:deb | deb abortDebuggingFor: aProcess]</body><body package="Debugger-Support" selector="activeWindowManager">activeWindowManager	^Processor activeProcess environment at: #WindowManager ifAbsent: [nil]</body><body package="Debugger-Support" selector="getActiveUserProcess">getActiveUserProcess	"Returns the highest priority user process waiting to run."	Processor runableProcesses do:		[:p |		p isSystemProcess not			ifTrue: [^p]].	^nil</body><body package="Debugger-Support" selector="getCurrentWindowProcess">getCurrentWindowProcess	Window currentWindow isNil		ifTrue: [^nil].	^Window currentWindow windowProcess</body><body package="Debugger-Support" selector="interruptActiveUserProcess">interruptActiveUserProcess	| proc deb |	proc := self getActiveUserProcess.	proc isNil		ifTrue: [proc := self getCurrentWindowProcess].	proc isNil		ifTrue: [^self interruptAllUserProcesses].	(deb := proc environmentAt: #debugger) notNil		ifTrue: [^deb abortDebugOperationInProcess: proc].	proc isUnderDebug		ifTrue: [^self abortDebuggingFor: proc].	proc interruptWith:		[Object userInterruptSignal			interruptWith: thisContext sender sender			errorString: (#UserInterrupt &lt;&lt; #pdp &gt;&gt; 'User Interrupt')]</body><body package="Debugger-Support" selector="interruptAllUserProcesses">interruptAllUserProcesses	| interruptor |	interruptor :=		[Processor pauseUserProcesses.		[InputState default ungrabBecauseOfError.		WindowManager beEffectivelyModeless.		ProcessMonitorService open] forkAt: Processor userSchedulingPriority.]		newProcess.	interruptor setIsSystemProcess.	interruptor resume</body><body package="Debugger-Support" selector="interruptAllUserProcessesSuchThat:with:">interruptAllUserProcessesSuchThat: aBlock with: aStringUserMessage	| interruptor |	interruptor :=		[Processor pauseUserProcessesSuchThat: aBlock.			[| procMonitor |			InputState default ungrabBecauseOfError.			WindowManager beEffectivelyModeless.			procMonitor := ProcessMonitorService open window.			procMonitor label: procMonitor label asString, ' ', aStringUserMessage asString]				forkAt: Processor userSchedulingPriority]		newProcess.	interruptor setIsSystemProcess.	interruptor resume	"self interruptAllUserProcessesWith: 'yo!'"</body><body package="Debugger-Support" selector="limitString:lengthTo:andLinesTo:">limitString: string lengthTo: maxLen andLinesTo: maxLines	| outStr inStr done lineCnt charCnt char |	outStr := WriteStream on: (String new: string size).	inStr := ReadStream on: string.	done := false.	lineCnt := charCnt := 0.	[done or: [inStr atEnd]]		whileFalse:			[char := inStr next.			char = Character cr				ifTrue:					[lineCnt := lineCnt + 1.					done := lineCnt = maxLines].			done				ifFalse:					[outStr nextPut: char.					charCnt := charCnt + 1.					done := charCnt = maxLen]].	done		ifTrue: [outStr nextPutAll: '...'].	^outStr contents</body><body package="Debugger-Support" selector="logErrorFor:label:">logErrorFor: aDebugger label: label	"Log the error to a file in case the notifier can't come up."	"If you want to enable logging of notifiers, change the first 'false'	to 'true', which will cause logging to be enabled.  Then edit the	file name (the default is 'visual.err') to whatever file you want to	write the logs to.  Make sure that the file is writable, and that	there is enough disk space.  If there is any error writing the log	file, the error will be silently ignored--otherwise the system would	go into infinite recursion and run out of memory."	| end printSymbol |	false		ifFalse: [^self].	end := 10.	"Number of stack items to be dumped.  Set to nil to dump full stack.""	printSymbol := #printSimple."	printSymbol := #printVerbose. 	[| file cp |	file := 'visual.err' asFilename appendStream.	[file cr; cr.	cp := ContextDumpPolicy new initialize.	cp stream: file.	cp errorMessage: label.	cp stack: aDebugger contextList	.	cp numberToDump: end.	cp perform: printSymbol.	file cr]		ensure: [file close]	]		on: Object errorSignal		do: [:ex | ex inspect. ex return].</body><body package="Debugger-Support" selector="shortStackFor:ofSize:">shortStackFor: aContext ofSize: anInteger	"Answer a string with the simple descriptions of anInteger number of	non-nil stackframes starting with aContext"	| shortStackStream ctx |	shortStackStream := WriteStream on: (String new: 400).	ctx := aContext.	anInteger timesRepeat: 		[ctx isNil ifFalse:			[shortStackStream nextPutAll: (ctx printString contractTo: 50); cr.			ctx := ctx sender]].	shortStackStream position &gt; 0 ifTrue: [shortStackStream skip: -1].	^shortStackStream contents</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService class</class-id> <category>gemstone private</category><body package="Debugger-Support" selector="clientClass">clientClass	"Instances of this class are the application models created	when the service receives a request to open a debugger.	DebuggerClient is the default debugger application.	Subclasses may redefine this to substitute their applications."	^DebuggerClient</body></methods><methods><class-id>Kernel.MethodContext</class-id> <category>accessing-debugger</category><body package="Debugger-Support" selector="intendedReceiver">intendedReceiver	"Answer the receiver to which the home method was sent."	^receiver</body></methods><methods><class-id>Kernel.MethodContext</class-id> <category>private</category><body package="Debugger-Support" selector="nestingAt:do:">nestingAt: level do: aBlock	level &gt; 0		ifTrue: [^self error: (#LevelCountingError &lt;&lt; #pdp &gt;&gt; 'Level counting error')].	^aBlock value: self</body></methods><methods><class-id>Kernel.MethodContext</class-id> <category>simulation-control</category><body package="Debugger-Support" selector="stepToCtxtWithSameParentAs:">stepToCtxtWithSameParentAs: ctxt	^ctxt</body></methods><methods><class-id>Kernel.MethodContext</class-id> <category>accessing-debugger</category><body package="Debugger-Support" selector="supposedHome">supposedHome	^self</body></methods><methods><class-id>Kernel.MethodContext</class-id> <category>testing</category><body package="Debugger-Support" selector="willExitMethod">willExitMethod	"Answer whether the next bytecode will cause an exit from the method."	^self willReturn</body></methods><methods><class-id>Kernel.CompiledBlock</class-id> <category>accessing</category><body package="Debugger-Support" selector="blockMethodIndex">blockMethodIndex	"Returns the block method index of the receiver."	| index |	index := 1.	self homeMethod withAllBlockMethodsDo:		[:meth |		meth = self ifTrue: [^index].		index := index + 1]</body></methods><methods><class-id>Kernel.CompiledBlock</class-id> <category>testing</category><body package="Debugger-Support" selector="isFullBlock">isFullBlock	"Returns true if the receiver is used in a full closure."	^outerMethod createsFullBlockFor: self</body><body package="Debugger-Support" selector="isFullBlockChain">isFullBlockChain	"Returns true if all the blocks from the receiver to the compiled method	are used in full block closures."	^self isFullBlock and: [outerMethod isFullBlockChain]</body></methods><methods><class-id>Kernel.CompiledBlock</class-id> <category>accessing</category><body package="Debugger-Support" selector="nesting">nesting	^outerMethod nesting + 1</body></methods><methods><class-id>Kernel.Process</class-id> <category>debugging</category><body package="Debugger-Support" selector="debug">debug	self isUnderDebug ifFalse: [self privateDebug]</body><body package="Debugger-Support" selector="debugDebugger">debugDebugger	self debug</body></methods><methods><class-id>Kernel.Process</class-id> <category>printing</category><body package="Debugger-Support" selector="dumpStackToFileNamed:">dumpStackToFileNamed: aString	| strm |	strm := aString asFilename writeStream.	[self printStackOn: strm]		ensure: [strm close]</body><body package="Debugger-Support" selector="printStackOn:">printStackOn: aStream	suspendedContext isNil		ifTrue: [suspendedContext printOn: aStream]		ifFalse: [suspendedContext printSenderStackOn: aStream max: 200].</body></methods><methods><class-id>Kernel.Process</class-id> <category>debugging</category><body package="Debugger-Support" selector="privateDebug">privateDebug	Processor activeProcess == self		ifTrue:			[self				suspendResumable: false				do: [:proc | proc privateDebug].			^self		"We should never reach this."].	suspendedContext isNil		ifTrue: [^self].	"nothing to debug"	Processor removePausedProcess: self.	[myList isNil		ifTrue: [self resume].	self uninterruptablyDo: [self suspend]] valueUnpreemptively.	[DebuggerService		openOnHandle: (ProcessHandle			on: self			at: suspendedContext			interrupted: true)		label: (#DebugProcess &lt;&lt; #pdp &gt;&gt; 'Debug process').] forkAt: Processor userSchedulingPriority</body></methods><methods><class-id>Kernel.Process</class-id> <category>changing process state</category><body package="Debugger-Support" selector="proceed">proceed	^Processor resumePausedProcess: self</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>menus - pdp</category><body package="Debugger-Support" selector="toggleDebuggingLabel">toggleDebuggingLabel	^PDPManager getEnableProbeDebuggingLabel</body></methods><methods><class-id>Core.RunArray</class-id> <category>accessing</category><body package="Debugger-Support" selector="remove:">remove: aValue	| index val end |	cacheRun := cacheRunStart := 1.  "Clear cache"	index := 1.	end := values size.	[index &gt; end or: [(val := values at: index) = aValue]]		whileFalse:			[val class == Array				ifTrue:					[(val indexOf: aValue) = 0						ifFalse:							[val size = 1								ifTrue:									[values at: index put: aValue.									index := index -1]								ifFalse: [^values at: index put: (val copyWithout: aValue)]]].			index := index + 1].	(values at: index) == aValue		ifFalse: [^self].	values at: index put: nil.</body></methods><methods><class-id>Kernel.Parser</class-id> <category>private</category><body package="Debugger-Support" selector="keywordPositions">keywordPositions	"This method expects the first token to be the first part of a keyword message.	It also expects the last part to be followed by a variable or expression."	| keywordPositions |	tokenType == #keyword		ifFalse: [^nil].	keywordPositions := Array with: mark -&gt; token size.	[self scanToken.	self primaryExpression		ifFalse: [^nil].	"this could return keywordPositions, but nil may catch errors"	self messagePart: 2 repeat: true.	tokenType == #keyword]		whileTrue:			[keywordPositions := keywordPositions copyWith: mark -&gt; token size].	^keywordPositions</body></methods><methods><class-id>Kernel.Parser</class-id> <category>public access</category><body package="Debugger-Support" selector="keywordPositionsIn:">keywordPositionsIn: aString	| failure |	failure := [^self error: (#UnexpectedError &lt;&lt; #pdp &gt;&gt; 'Unexpected error')].	self		init: aString readStream		notifying: (SilentCompilerErrorHandler new failBlock: failure)		saveComments: false		failBlock: failure.	builder := ProgramNodeBuilder new.	^self keywordPositions</body><body package="Debugger-Support" selector="parseSelector:notifying:">parseSelector: aString notifying: aController	"Answer with the selector for this method string"	| handler |	handler := InteractiveCompilerErrorHandler new.	^handler		forClass: Object		on: (ReadStream on: aString asString)		for: aController		onFailDo: [^nil]		do: [:src |			self				initPattern: src contents				notifying: handler				saveComments: false				return: [:pattern | pattern at: 1]]</body></methods><methods><class-id>Core.Object</class-id> <category>copying</category><body package="Debugger-Support" selector="basicDcopy">basicDcopy	"Basic deep copy operation."	^DcopyDict		at: self		ifAbsent:			[|nuMe|			nuMe := self shallowCopy.			DcopyDict at: self put: nuMe.			nuMe postDcopy.			nuMe]</body><body package="Debugger-Support" selector="basicMethodDcopy">basicMethodDcopy	"Ignore."	^self</body></methods><methods><class-id>Core.Object</class-id> <category>error handling</category><body package="Debugger-Support" selector="breakOn:label:">breakOn: aContext label: aString	"This is a simple message to use for inserting breakpoints during debugging.	The debugger is opened by raising a signal."	BreakInterrupt		raiseRequestWith: aContext		errorString: aString</body></methods><methods><class-id>Core.Object</class-id> <category>copying</category><body package="Debugger-Support" selector="dcopy">dcopy	"Return a smart deep copy of the receiver.  References to a single	object are maintained instead of being broken."	| nuMe |	Smalltalk.CraftedSmalltalk at: #DcopyDict put: IdentityDictionary new.	nuMe := self basicDcopy.	Smalltalk.CraftedSmalltalk at: #DcopyDict put: nil.	^nuMe</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="Debugger-Support" selector="debugString">debugString	^self printString</body><body package="Debugger-Support" selector="forStackDumpPrintUsing:">forStackDumpPrintUsing: aPolicy	^aPolicy printObject: self</body><body package="Debugger-Support" selector="inspectString">inspectString	^self debugString</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Debugger-Support" selector="isBlockContext">isBlockContext	^false</body><body package="Debugger-Support" selector="isCharStyleCacheable">isCharStyleCacheable	^true</body></methods><methods><class-id>Core.Object</class-id> <category>copying</category><body package="Debugger-Support" selector="postDcopy">postDcopy	"Complete the deep copy operation."	| class |	class := self class.	class isVariable		ifTrue: [1 to: self basicSize do: [ :i | self basicAt: i put: (self basicAt: i) basicDcopy]].	1 to: class instSize do: [ :i | self instVarAt: i put: (self instVarAt: i) basicDcopy]</body></methods><methods><class-id>Kernel.Context</class-id> <category>private-debugger</category><body package="Debugger-Support" selector="clearStack">clearStack	stackp :=  self initialStackDepthForProbes.</body></methods><methods><class-id>Kernel.Context</class-id> <category>accessing</category><body package="Debugger-Support" selector="contextStackDepth">contextStackDepth	| i ctx |	i := 1.	ctx := self.	[ctx := ctx sender.	ctx == nil]		whileFalse: [i := i + 1].	^i</body></methods><methods><class-id>Kernel.Context</class-id> <category>accessing-debugger</category><body package="Debugger-Support" selector="findParentContextWithHomeMethod:">findParentContextWithHomeMethod: aMethod	| ctx |	ctx := self.	[ctx == nil]		whileFalse: 			[ctx method homeMethod originalMethod == aMethod ifTrue: [^ctx].			ctx := ctx sender].	^nil</body><body package="Debugger-Support" selector="getTempVar:">getTempVar: aVar 	"Answer the argument or temporary value of the variable."	self nestingAt: self nesting - aVar nesting do: [:ctx | ^ctx slotAt: aVar debuggerIndex].	self error: (#IndexIsOutOfRange &lt;&lt; #pdp &gt;&gt; 'Index is out of range')</body><body package="Debugger-Support" selector="growBy:">growBy: aNumber	| newStk |	newStk := Array new: aNumber abs + self localSize.	1 to: self localSize do: [:i | newStk at: i put: (self localAt: i)].	self		instVarAt: 6		put: newStk.</body></methods><methods><class-id>Kernel.Context</class-id> <category>testing</category><body package="Debugger-Support" selector="hasExited">hasExited	^sender isNil and: [self atEnd]</body><body package="Debugger-Support" selector="hasInterimValues">hasInterimValues	^stackp &gt; method numLocals</body></methods><methods><class-id>Kernel.Context</class-id> <category>private-debugger</category><body package="Debugger-Support" selector="initialStackDepthForProbes">initialStackDepthForProbes	^method numTemps.</body></methods><methods><class-id>Kernel.Context</class-id> <category>accessing-debugger</category><body package="Debugger-Support" selector="intendedReceiver">intendedReceiver	"Answer the receiver to which the home method was sent."	^self subclassResponsibility</body></methods><methods><class-id>Kernel.Context</class-id> <category>private-simulation</category><body package="Debugger-Support" selector="isSendLoop">isSendLoop	^Processor activeProcess environment		at: #_dbg_send_loop		ifAbsent: [false]</body></methods><methods><class-id>Kernel.Context</class-id> <category>accessing-debugger</category><body package="Debugger-Support" selector="messageObjects">messageObjects	| count objects |	objects := OrderedCollection new.	self pdpWillSend		ifFalse: [^objects].	count := self peekForSelector numArgs.	self sendsAdd1		ifTrue: [count := count - 1].	self hasReceiverOnStackForSend		ifFalse:			[objects add: receiver.			count := count - 1].	"no receiver on stack"	0 to: count do: [:i | objects add: (self localAt: stackp - i)].	^objects</body><body package="Debugger-Support" selector="nesting">nesting	^method nesting</body></methods><methods><class-id>Kernel.Context</class-id> <category>simulation-debugger</category><body package="Debugger-Support" selector="pdpCompleteCallee:">pdpCompleteCallee: aContext	"Simulate the execution of bytecodes until a return to the receiver,	or until a return to a non-context in case of block up arrow return."	| ctxt current |	self == aContext		ifTrue: [^self].	ctxt := aContext.	current := nil.	[[ctxt == current or: [(ctxt isKindOf: Context) and: [ctxt hasSender: self]]]			whileTrue: 				[current := ctxt.				ctxt := ctxt step]]		on: GetBaseContextForException		do: [:ex | ex proceedWith: self].	"check for handler context"	(ctxt isMemberOf: Array)		ifTrue: [ctxt := ctxt at: 1].	^ctxt</body></methods><methods><class-id>Kernel.Context</class-id> <category>accessing-debugger</category><body package="Debugger-Support" selector="pdpSlotAccessors">pdpSlotAccessors	"Answer an OrderedCollection of the name strings of the temporary 	variables for this context and all its enclosing scopes. Note that this 	does not include compiler-generated temporary variables."	| slots |	slots := OrderedCollection new.	self localScope temps do:		[:var | | name |		(var key first = $.)			ifFalse:				[name := var key.				var value class == LocalVariable					ifTrue: [name := '.' , name].				slots add: (Array with: name with: var value)]].	^slots</body></methods><methods><class-id>Kernel.Context</class-id> <category>simulation-debugger</category><body package="Debugger-Support" selector="pdpStepUntilPC:">pdpStepUntilPC: stopPC	"Simulate the execution of bytecodes until pc is equal to stopPC"	[| ctx |	ctx := self.	[ctx == self and: [self pc &lt; stopPC and: [self willReturn not and: [(self isJump: pc) not]]]]			whileTrue: [ctx := self pdpCompleteCallee: self step].	^ctx]		on: Error		do: [:ex | CodeSimulationError signalWith: self]</body><body package="Debugger-Support" selector="pdpStepUntilVisibleEffect">pdpStepUntilVisibleEffect	"Simulate the execution of bytecodes until either sending a message 	or assigning a expression or returning a value to the receiver or calling 	a primitive (that is, until reaching a point that has meaning at the source	level)."	^[[self pdpWillSend or: [self willAssign or: [self willReturn or: [self willDoPrimitive or: [self willJump]]]]]		whileFalse:			[| c |			c := self step.			c == self ifFalse: [^c]].	self]		on: Core.Error		do: [:ex | CodeSimulationError signalWith: self]</body></methods><methods><class-id>Kernel.Context</class-id> <category>printing</category><body package="Debugger-Support" selector="printSenderStackOn:max:">printSenderStackOn: aStream max: num	| totalDepth topCnt bottomCnt dropCnt ctx |	totalDepth := self contextStackDepth.	totalDepth &lt;= num		ifTrue: [topCnt := totalDepth]		ifFalse:			[topCnt := (num / 4) truncated.			bottomCnt := num - topCnt.			dropCnt := totalDepth - num].	ctx := self.	1 to: topCnt do: [:i | ctx printOn: aStream. aStream cr. ctx := ctx sender].	topCnt = totalDepth		ifTrue: [^self].	aStream nextPutAll: '	*	*	*'.	1 to: dropCnt do: [:i | ctx := ctx sender].	1 to: bottomCnt do: [:i | ctx printOn: aStream. aStream cr. ctx := ctx sender].</body></methods><methods><class-id>Kernel.Context</class-id> <category>private-debugger</category><body package="Debugger-Support" selector="probeMethod:">probeMethod: aMethod	self changeToVPC.	method := aMethod.</body></methods><methods><class-id>Kernel.Context</class-id> <category>accessing-debugger</category><body package="Debugger-Support" selector="put:intoTempVar:">put: obj intoTempVar: aVar 	"Answer the argument or temporary value of the variable."	self nestingAt: self nesting - aVar nesting do: [:ctx | ^ctx slotAt: aVar debuggerIndex put: obj].	self error: (#IndexIsOutOfRange &lt;&lt; #pdp &gt;&gt; 'Index is out of range')</body></methods><methods><class-id>Kernel.Context</class-id> <category>private-debugger</category><body package="Debugger-Support" selector="restackMessage:to:"> restackMessage: aMessage to: obj	self push: obj.	aMessage arguments do: [:arg | self push: arg]</body></methods><methods><class-id>Kernel.Context</class-id> <category>private-simulation</category><body package="Debugger-Support" selector="return:">return: value 	| caller |	caller := sender.	caller isNil		ifTrue: [^self cannotReturn: value]		ifFalse: 			[self terminate.			^caller push: value]</body></methods><methods><class-id>Kernel.Context</class-id> <category>simulation-debugger</category><body package="Debugger-Support" selector="safelyInterpretNextInstructionFor:">safelyInterpretNextInstructionFor: aContext 	| interrupted ctx |	interrupted := false.	[ctx := self interpretNextInstructionFor: aContext]		on: UserInterrupt		do:	[:ex | 			interrupted := true.			ex resume].	interrupted		ifTrue: [UserInterrupt signalWith: ctx].	^ctx</body></methods><methods><class-id>Kernel.Context</class-id> <category>private-simulation</category><body package="Debugger-Support" selector="send:receiver:class:super:numArgs:">send: selector receiver: rcvr class: rclass super: flag numArgs: na	"Don't simulate calls on error:."	(flag | self class doSend or: [selector == #primTerminate or: [(rclass includesBehavior: GenericException) and: [selector ~~ #aboutToDebug]]])		ifFalse: [^self sendFast: selector receiver: rcvr numArgs: na].	(self isSendLoop and: [(rclass includesBehavior: GenericException) and: [selector == #aboutToDebug]])		ifTrue: [^ContextEmergencyError signalWith: rcvr].	self findMethod: selector		class: rclass		ifFound:			[:meth :mclass |			flag ifTrue: [self pop].  "remove class for super"			^self runMethod: meth numArgs: na contextClass: MethodContext].	self findMethod: #doesNotUnderstand:		class:  (self _objectClass: rcvr)		ifFound:			[:meth :mclass |			| args |			flag ifTrue: [self pop].  "remove class for super"			args := Array new: na.			na to: 1 by: -1 do: [:i | args at: i put: self topPop].			self push: (Message selector: selector arguments: args).			^self runMethod: meth numArgs: 1 contextClass: MethodContext].	self error: ((#MessageNotFoundC1s &lt;&lt; #pdp &gt;&gt; 'Message not found: &lt;1s&gt;')			expandMacrosWith: selector printString).	"To continue, just return the receiver of the message."	flag ifTrue: [self pop].  "remove class for super"	stackp := stackp - na.	self localAt: stackp put: rcvr</body></methods><methods><class-id>Kernel.Context</class-id> <category>private-debugger</category><body package="Debugger-Support" selector="sendFast:receiver:numArgs:">sendFast: selector receiver: rcvr numArgs: na	"Execute a send by using perform to invoke VM. Before doing perform, insert extra contexts 	between the receiver and the perform context. The extra contexts holds an exception handling 	block and an unwind block. The exception handling block is used to repropagate the signal 	through the  client process contexts chain. The unwind block is used to catch control flow after 	an uparrow block return occurs in executing the send."	| args context interrupted excpt rtnCtx |	args := Array new: na.	1 to: na do: [ :i | args at: i put: ( self localAt: stackp - na + i ) ].	stackp := stackp - na - 1.	(self checkHandlerBlock: rcvr value: selector) ifTrue: 		[selector == #aboutToDebug			ifTrue: ["emergency handler"					self class emergencySignal raiseWith: rcvr]			ifFalse: [context := self class baseContextSignal raiseRequest.					((args at: 1) handlerContext hasSender: context)						ifTrue: [^self blockContextFrom: rcvr args: args]						ifFalse: [^Array with: (self blockContextFrom: rcvr args: args)]]].	interrupted := false.	[ | savedSender invisibleContext stubCtx ctx |	invisibleContext := thisContext.	savedSender := thisContext sender.	[		[invisibleContext sender: self.			[stubCtx := thisContext.			context := self push: (self _object: rcvr perform: selector withArguments: args)]				on: Signal genericSignal 				do: [:ex |					ex checkInitialContextIf: stubCtx with: self.					self removeContextsTo: stubCtx.					excpt := ex.					rtnCtx := thisContext sender sender.					thisContext sender: invisibleContext].		] 			ifCurtailed: 				[ctx := thisContext unwindRequestorContext home.				ctx method == ( BlockContext compiledMethodAt: #nonlocalReturn:through:)					ifTrue:						[context := ctx uparrowReturn].				thisContext sender: invisibleContext].	]		on: UserInterrupt		do: [:ex | interrupted := true. ex resume].	invisibleContext sender: savedSender.	] value.	excpt notNil		ifTrue: [context := excpt rePropagateReturnTo: rtnCtx].				interrupted		ifTrue: [UserInterrupt signalWith: context].	^context</body></methods><methods><class-id>Kernel.Context</class-id> <category>simulation-debugger</category><body package="Debugger-Support" selector="sendIntoBlockStartingWithCallee:">sendIntoBlockStartingWithCallee: aContext 	"Simulate the execution of bytecodes until we encounter a context 	whose home method is the same as my homeMethod, or until a 	return to a non-context in case of block up arrow return."	| ctxt guardMethod |	guardMethod := self method homeMethod originalMethod.	Processor activeProcess environment at: #_dbg_send put: true.	Processor activeProcess environment at: #_dbg_send_loop put: true.	ctxt := aContext == self				ifTrue: [self step]				ifFalse: [aContext].	[(ctxt isKindOf: Context) and:		[(ctxt hasSender: self) and:				[guardMethod ~~ ctxt method homeMethod originalMethod]]]		whileTrue: [ctxt := ctxt step].	Processor activeProcess environment localRemoveKey: #_dbg_send.	Processor activeProcess environment localRemoveKey: #_dbg_send_loop.	"check for handler context"	(ctxt isMemberOf: Array)		ifTrue: [ctxt := ctxt at: 1].	^ctxt</body></methods><methods><class-id>Kernel.Context</class-id> <category>accessing-debugger</category><body package="Debugger-Support" selector="sourceMap">sourceMap	"Answer a sourceMap for PC selection in the current code."		^self visibleSourceMap.</body></methods><methods><class-id>Kernel.Context</class-id> <category>simulation-debugger</category><body package="Debugger-Support" selector="step">step	"Simulate the execution of the receiver's next bytecode.	Answer the context that would be the active context	after this bytecode."	^[self safelyInterpretNextInstructionFor: self]		on:Object errorSignal		do: [:ex | Context codeSimulationErrorSignal raiseFrom: self]</body><body package="Debugger-Support" selector="stepForever">stepForever	"Simulate the execution of the receiver's next bytecode 	until a return or an exception is raised, a break occurs. 	Answer the context that would be the active context 	after this bytecode."	^[| ctx |	ctx := self.	[ctx ~~ self or: [self willReturn]]		whileFalse: [ctx := self pdpCompleteCallee: (self safelyInterpretNextInstructionFor: self)].	ctx]		on: Core.Error		do: [:ex | CodeSimulationError signalWith: self]</body><body package="Debugger-Support" selector="stepUntilSkipPC:">stepUntilSkipPC: stopPC	"Simulate the execution of bytecodes until pc is equal to stopPC"	^[| ctx |	ctx := self.	[ctx == self and: [self pc &lt; stopPC and: [self willReturn not]]]			whileTrue: [ctx := self pdpCompleteCallee: self step].	ctx]		on: Core.Error		do: [:ex | CodeSimulationError signalWith: self]</body></methods><methods><class-id>Kernel.Context</class-id> <category>private-debugger</category><body package="Debugger-Support" selector="storeTop:">storeTop: anObject	^self localAt: stackp put: anObject</body></methods><methods><class-id>Kernel.Context</class-id> <category>accessing-debugger</category><body package="Debugger-Support" selector="supposedHome">supposedHome	^self subclassResponsibility</body></methods><methods><class-id>Kernel.Context</class-id> <category>simulation-primitive support</category><body package="Debugger-Support" selector="tryPrimitive:receiver:numArgs:boundByMethod:">tryPrimitive: index receiver: rcvr numArgs: numArgs boundByMethod: primMethod	"Evaluate the primitive with the given index. Return new context if successful, nil if failed"	(index &gt;= 86 and: [index &lt;= 89]) ifTrue:		[index = 86 ifTrue: ["^self primWait: rcvr"].		index = 88 ifTrue: ["^self primSuspend: rcvr"].		index = 89 ifTrue: [^self primFlushVMmethodCache: rcvr]].	index = 184 ifTrue: "Context _object:perform:withArguments:"		[^self primObjectPerform: (self localAt: stackp - 2) selector: (self localAt: stackp - 1) arguments: self top].	((index between: 394 and: 395)	 and: [(primMethod isLinkedFor: rcvr class) not]) ifTrue:		["unlinked fast DLLCC call invokes unboundMethod:with:"		^self primUnlinkedCallCExternalMethod: primMethod receiver: rcvr numArgs: numArgs].	(index &gt;= 500 and: [index &lt;= 523]) ifTrue:		[index = 500 ifTrue: "BlockClosure valueWithArguments:"			[^self primBlockValue: rcvr arguments: self top].		index &lt; 510 ifTrue: "BlockClosure value:*"			[^self primBlockValue: rcvr numArgs: numArgs].		index = 510 ifTrue: "Object perform:withArguments:"			[^self primPerform: rcvr selector: (self localAt: stackp - 1) arguments: self top].		index &lt; 520 ifTrue: "Object perform:with:*"			[^self primPerform: rcvr selector: (self localAt: stackp - numArgs + 1) numArgs: numArgs - 1].		index = 522 ifTrue: "Behavior flushVMmethodCacheEntriesFor:"			[^self primFlushVMmethodCacheEntries: rcvr].		index = 523 ifTrue: "CompiledMethod valueWithReceiver:arguments:"			[^self primPerformMethod: rcvr]].	index = 312		ifTrue:			[ProcessTerminatedDuringSimulation signalWith: [self													doPrimitive: index													receiver: rcvr													numArgs: numArgs													boundByMethod: primMethod]].	^self doPrimitive: index receiver: rcvr numArgs: numArgs boundByMethod: primMethod</body></methods><methods><class-id>Kernel.Context</class-id> <category>accessing-debugger</category><body package="Debugger-Support" selector="visibleSourceMap">visibleSourceMap	"Answer a sourceMap for PC selection in the current code."		self sourceInfo: [:methodHolder :index | 			^(methodHolder visibleSourceMap at: index) asSortedCollection]</body></methods><methods><class-id>UI.Icon class</class-id> <category>private-icon-creation</category><body package="Debugger-Support" selector="createWatchIcon">createWatchIcon	^self createVisualIcon: #[  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 60 0 30 0 108 0 54 0 198 0 99 1 134 0 195 3 12 1 134 6 0 3 0 12 0 6 0 24 0 12 0 63 15 152 0 63 159 240 0 96 240 112 0 192 96 48 0 192 96 48 0 192 96 48 0 204 102 48 0 254 127 48 0 254 127 48 0 124 254 96 0 63 159 192 0 31 15 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>UI.Icon class</class-id> <category>class initialization</category><body package="Debugger-Support" selector="initializeWatchIcon">initializeWatchIcon	"Icon initializeWatchIcon"	self installMask: self createWatchIcon forIconNamed: #watchWindow."Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>copying</category><body package="Debugger-Support" selector="basicDcopy">basicDcopy	"Don't copy"	^self</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>printing</category><body package="Debugger-Support" selector="forStackDumpPrintUsing:">forStackDumpPrintUsing: aPolicy	aPolicy printString: self</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>accessing</category><body package="Debugger-Support" selector="blockMethodIndex">blockMethodIndex	"Returns the block method index of the receiver.	Which is 1 in the case of a CompiledMethod."	^1</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>testing</category><body package="Debugger-Support" selector="isBound">isBound	mclass selectorAtMethod: self ifAbsent: [^false].	^true</body><body package="Debugger-Support" selector="isFullBlockChain">isFullBlockChain	"Returns true if all the blocks from the receiver to the compiled method	are used in full block closures.  For a CompiledMethod return true."	^true</body><body package="Debugger-Support" selector="isPartiallyBound">isPartiallyBound	mclass selectorAtMethod: self ifAbsent: [^false].	^true</body><body package="Debugger-Support" selector="isProbeable">isProbeable	"Return true if the receiver can be converted to a probed method."	^true</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>accessing</category><body package="Debugger-Support" selector="newFullProbedMethod">newFullProbedMethod	^self probedMethodClass from: self full: true</body><body package="Debugger-Support" selector="newNormalProbedMethod">newNormalProbedMethod	^self probedMethodClass from: self full: false</body><body package="Debugger-Support" selector="newTempFullProbedMethod">newTempFullProbedMethod	^self newFullProbedMethod</body><body package="Debugger-Support" selector="newTempProbedMethod">newTempProbedMethod	^self newNormalProbedMethod</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>printing</category><body package="Debugger-Support" selector="printNameOn:inClass:">printNameOn: aStream inClass: aClass	| selector class |	aClass isNil		ifTrue:			[| who |			mclass isNil				ifTrue:					[aStream nextPutAll: (#ParenUnboundMethodParen &lt;&lt; #pdp &gt;&gt; '(Unbound method)') asString.					^self].			who := self who.			who isNil				ifTrue:					[class := mclass.					selector := class defaultSelectorForMethod: self]				ifFalse:					[class := who first.					selector := who at: 2]]		ifFalse:			[class := aClass.			selector := class					selectorAtMethod: self					setClass: [:mc | ]].	aStream print: class.	mclass == class 		ifFalse: 			[aStream nextPut: $(.			aStream print: mclass.			aStream nextPut: $)].	aStream nextPutAll: '&gt;&gt;'.	aStream nextPutAll: selector</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>accessing</category><body package="Debugger-Support" selector="probedMethodClass">probedMethodClass	^ProbedCompiledMethod</body><body package="Debugger-Support" selector="revert">revert	"Ignore, this is overriden by ProbedCompiledMethod."	^self</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>private-load/unload</category><body package="Debugger-Support" selector="prepareCodeWriter:">prepareCodeWriter: aCodeWriter	"Load aCodeWriter with the objects necessary to write-out the contents of the receiver."	self cleanse.	self definedClasses do: [:cl | cl revertAllProbedMethods].	self extensionMethods do: [:meth | meth revert].	self runPreSave.	self storePropertiesOn: aCodeWriter.	"Store the definitions."	aCodeWriter storeDefinedObjects: self definedObjects.	aCodeWriter		storeClasses: self definedClasses		extensions: self extensionMethods		excluding: self definedClassesExcludedSelectors.	aCodeWriter storeDefinedBindings: self definedBindings.	self namedObjects keysAndValuesDo: [:key :value | aCodeWriter addObject: value named: key].	^aCodeWriter</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>copying</category><body package="Debugger-Support" selector="basicDcopy">basicDcopy</body></methods><methods><class-id>Kernel.SyntaxError</class-id> <category>text</category><body package="Debugger-Support" selector="debug">debug	"Open a debugger on the stack"	self changeRequest		ifFalse: [^self].	DebuggerService openOnHandle: processHandle label: (#SyntaxError &lt;&lt; #pdp &gt;&gt; 'Syntax Error')</body><body package="Debugger-Support" selector="textMenu">textMenu	"Answer a Menu of operations on the text that is to be 	displayed when the operate menu button is pressed."	"SyntaxError flushMenus"	TextMenu == nil ifTrue:		[TextMenu := Menu			labelList: ParagraphEditor editGroupLabels, (Array with: (Array with: (#DoIt &lt;&lt; #pdp &gt;&gt; 'Do it') with: (#PrintIt &lt;&lt; #pdp &gt;&gt; 'Print it') with: (#InspectIt &lt;&lt; #pdp &gt;&gt; 'Inspect it')) with: (Array with: (#Accept &lt;&lt; #pdp &gt;&gt; 'Accept') with: (#Cancel &lt;&lt; #pdp &gt;&gt; 'Cancel')) with: (Array with: (#Proceed &lt;&lt; #pdp &gt;&gt; 'Proceed') with: (#Debug &lt;&lt; #pdp &gt;&gt; 'Debug')) with: (Array with: (#Hardcopy &lt;&lt; #pdp &gt;&gt; 'Hardcopy')))			values: ParagraphEditor editGroupSelectors,#(doIt printIt inspectIt accept cancel proceed debug hardcopy)].	^ TextMenu</body></methods><methods><class-id>Kernel.AnnotatedMethod</class-id> <category>accessing</category><body package="Debugger-Support" selector="probedMethodClass">probedMethodClass	^ProbedAnnotatedMethod</body></methods><methods><class-id>Kernel.CompiledCode</class-id> <category>accessing</category><body package="Debugger-Support" selector="blockAt:">blockAt: anIndex 	| i |	i := 1.	self		withAllBlockMethodsDo: 			[:aBlock | 			i = anIndex				ifTrue: [^aBlock].			i := i + 1]</body></methods><methods><class-id>Kernel.CompiledCode</class-id> <category>testing</category><body package="Debugger-Support" selector="createsFullBlockFor:">createsFullBlockFor: aBlock	| scanner |	scanner := InstructionStream on: self.	^scanner scanFor: 		[:byte | 		(byte = OpFullBlock or: [byte = OpFullCopyingBlock]) and:			[aBlock = (self literalAt: (self byteAt: scanner pc + 1) + 1)]]</body><body package="Debugger-Support" selector="isProbed">isProbed	^false</body></methods><methods><class-id>Kernel.CompiledCode</class-id> <category>copying</category><body package="Debugger-Support" selector="postCopy">postCopy	"Finish doing whatever is required, 	beyond a shallowCopy, to implement 'copy'. 	Answer the receiver. 	Subclasses may add functionality, 	but they should always do super postCopy first."	super postCopy.	1 to: self numLiterals do: 		[:i | | lit cl |		lit := self literalAt: i.		cl := lit class.		((lit isKindOf: CompiledBlock) or: [cl == BlockClosure])			ifTrue: 				[self literalAt: i put: (lit := lit copy).				cl = BlockClosure					ifTrue: [lit method outerMethod: self]					ifFalse: [lit outerMethod: self]]			ifFalse: [self literalAt: i put: lit]].	^self</body></methods><methods><class-id>Kernel.CompiledCode</class-id> <category>testing</category><body package="Debugger-Support" selector="readsField:">readsField: instVarIndex	^InstanceVariableSearch new		method: self;		searchFor: instVarIndex-1 type: #read</body></methods><methods><class-id>Kernel.CompiledCode</class-id> <category>accessing</category><body package="Debugger-Support" selector="sourceInfo:">sourceInfo: aBlock	"Invoke aBlock with the methodNodeHolder and the index."	| homeMethod methodHolder index |	homeMethod := self homeMethod.	methodHolder := homeMethod sourceInfoIfCached. 	methodHolder == nil ifTrue:		[methodHolder := self compilerClass new			parse: self getSource			in: self mclass			environment: self environment			allowReceiver: homeMethod usuallyAllowsReceiver			noPattern: homeMethod usuallyHasSelector not			notifying: nil.		methodHolder == nil ifTrue:			[methodHolder := self compilerClass new				parse: self getSource				in: self mclass				environment: self environment				allowReceiver: homeMethod usuallyAllowsReceiver				noPattern: true				notifying: nil].		homeMethod cacheSourceInfo: methodHolder].	index := homeMethod withAllBlockMethods identityIndexOf: self.	^aBlock value: methodHolder value: index</body><body package="Debugger-Support" selector="sourceMapAt:">sourceMapAt: index	^self sourceInfo: [:methodHolder :x | 			^(methodHolder sourceMap at: index) asSortedCollection]</body></methods><methods><class-id>Kernel.CompiledCode</class-id> <category>enumerating</category><body package="Debugger-Support" selector="withAllBlockMethodsDo:">withAllBlockMethodsDo: aBlock	"Recursively enumerate the collection of methods	(including block methods) that are included in	this method."	aBlock value: self.	self literalsDo:		[:lit | | cl |		cl := lit class.		(lit isKindOf: CompiledBlock)			ifTrue: [lit withAllBlockMethodsDo: aBlock]			ifFalse:				[cl == BlockClosure					ifTrue: [lit method withAllBlockMethodsDo: aBlock]]]</body><body package="Debugger-Support" selector="withAllProbedBlockMethodsDo:">withAllProbedBlockMethodsDo: aBlock	"Recursively enumerate the collection of methods	(including block methods) that are included in	this method."	self isProbed ifFalse: [^self].	aBlock value: self.	self literalsDo:		[:lit | | cl |		cl := lit class.		(lit isKindOf: CompiledBlock)			ifTrue: [lit withAllProbedBlockMethodsDo: aBlock]			ifFalse:				[cl == BlockClosure					ifTrue: [lit method withAllProbedBlockMethodsDo: aBlock]]]</body></methods><methods><class-id>Kernel.CompiledCode</class-id> <category>testing</category><body package="Debugger-Support" selector="writesField:">writesField: instVarIndex	^InstanceVariableSearch new		method: self;		searchFor: instVarIndex-1 type: #write</body></methods><methods><class-id>Core.Behavior</class-id> <category>accessing</category><body package="Debugger-Support" selector="methodDictionary">methodDictionary	^methodDict</body></methods><methods><class-id>Core.Behavior</class-id> <category>creating method dictionary</category><body package="Debugger-Support" selector="replaceMethodAt:withMethod:">replaceMethodAt: selector withMethod: compiledMethod 	"The purpose of this method is to replace a method with an	instrumented verson.  It should not be used when the source	code is changed."	methodDict		at: selector		put: (self validateMethod: compiledMethod forSelector: selector).	self flushVMmethodCacheEntriesFor: selector.</body></methods><methods><class-id>Core.Behavior</class-id> <category>probes</category><body package="Debugger-Support" selector="revertAllProbedMethods">revertAllProbedMethods	"Make sure all original methods in the class have been restored.	This must be done before changing the class structure, i.e. adding	an instance variable."	| pcms |	pcms := OrderedCollection new.	2 to: methodDict basicSize by: 2 do:		[:i | | cm |		cm := methodDict basicAt: i.		cm isProbed			ifTrue:				[methodDict basicAt: i put: cm originalMethod.				pcms add: cm.				PDPManager					changedMethodFrom: cm					to: cm originalMethod					by: nil]].	^pcms</body><body package="Debugger-Support" selector="revertAllProbedMethodsInTree">revertAllProbedMethodsInTree	"Make sure all original methods in the class tree have been restored.	This must be done before changing the class structure, i.e. adding	an instance variable."	| pcms |	pcms := OrderedCollection new.	pcms addAll: self revertAllProbedMethods.	self allSubclassesDo: [:cl | pcms addAll: cl revertAllProbedMethods].	^pcms</body></methods><methods><class-id>Kernel.MarkedMethod</class-id> <category>testing</category><body package="Debugger-Support" selector="isProbeable">isProbeable	"Return false.  The receiver cannot be converted to a probed method."	^false</body></methods><methods><class-id>Kernel.MarkedMethod</class-id> <category>accessing</category><body package="Debugger-Support" selector="newFullProbedMethod">newFullProbedMethod	^nil</body></methods><methods><class-id>Kernel.InstructionStream</class-id> <category>testing</category><body package="Debugger-Support" selector="atEnd">atEnd	"Answer true iff there are no more	bytecodes in the stream."	self changeToVPC.	^pc &gt; method bytesSize</body><body package="Debugger-Support" selector="hasReceiverOnStackForSend">hasReceiverOnStackForSend	| byte |	self changeToVPC.	byte := method byteAt: pc.	(byte between: OpSendSelf0 and: OpSendSelf0+MaxSendSelf0)		ifTrue: [^false].	(byte = OpXSuper or: [byte = OpXXSuper])		ifTrue: [^false].	^true</body><body package="Debugger-Support" selector="isPopPushAt:">isPopPushAt: nextPC	"This is almost the same as isPopFirst:"	| byte |	byte := method byteAt: nextPC.	byte &lt; OpPopLoadTemp			ifTrue: [^byte = OpPopLoadReceiver].	^byte &lt;= (OpPopLoadTemp + MaxPopLoadTemp)</body><body package="Debugger-Support" selector="pdpWillSend">pdpWillSend	"Answer whether the next bytecode is a message-send."	| byte |	self changeToVPC.	byte := method byteAt: pc.	byte &lt; FirstShortSend 			ifTrue: [^false].	(byte between: FirstShortSend and:  LastShortSend) 			ifTrue: [^true].		"special send or short send"	byte = OpSendAdd1 ifTrue: [^true].	(byte between: OpXNoCheckSend and: OpXNonImmediateSpecialSend) 			ifTrue: [^true].		"long sends"	byte = OpXNoCheckSpecialSend 			ifTrue: [^true].	(byte between: OpXSpecialSend and: OpXXNoCheckSend) 			ifTrue: [^true].	(byte between: OpXXSend and: OpXXSuper) 			ifTrue: [^true].	^false</body><body package="Debugger-Support" selector="sendsAdd1">sendsAdd1	"Answer whether the next bytecode sends an add1"	self changeToVPC.	^(method byteAt: pc) = OpSendAdd1</body><body package="Debugger-Support" selector="willJump">willJump	"Answer whether the next bytecode is a junp."	^self isJump: self pc</body></methods><methods><class-id>Core.Symbol</class-id> <category>copying</category><body package="Debugger-Support" selector="basicDcopy">basicDcopy</body></methods><methods><class-id>Core.Boolean</class-id> <category>copying</category><body package="Debugger-Support" selector="basicDcopy">basicDcopy</body></methods><methods><class-id>Kernel.ProcessorScheduler</class-id> <category>debugging</category><body package="Debugger-Support" selector="interruptActiveUserProcess">interruptActiveUserProcess	| proc deb |	proc := self runableProcesses			detect: [:p | p isSystemProcess not]			ifNone: [nil].	(proc isNil and: [Window currentWindow notNil])		ifTrue: [proc := Window currentWindow windowProcess].	proc isNil		ifTrue: [^self interruptAllUserProcesses].	(deb := proc environmentAt: #debugger) notNil		ifTrue: [^deb abortDebugOperationInProcess: proc].	proc isUnderDebug		ifTrue: [^DebuggerService abortDebuggingFor: proc].	proc interruptWith: 			[Object userInterruptSignal 				interruptWith: thisContext sender sender				errorString: (#exceptUserInterrupt &lt;&lt; #dialogs &gt;&gt; 'User Interrupt')]</body></methods><methods><class-id>Kernel.ProcessorScheduler</class-id> <category>accessing</category><body package="Debugger-Support" selector="isPaused:">isPaused: aProcess	^pausedProcesses includes: aProcess</body><body package="Debugger-Support" selector="isRunable:">isRunable: aProcess	^(quiescentProcessLists at: aProcess priority) includes: aProcess</body></methods><methods><class-id>Kernel.ProcessorScheduler</class-id> <category>process state change</category><body package="Debugger-Support" selector="pauseUserProcesses">pauseUserProcesses	| proc procs |	procs := OrderedCollection new.	"First, abort any debugging."	Process allInstances do:		[:p | | deb |		(deb := p environmentAt: #debugger) notNil			ifTrue: [deb ctrlyAbort]			ifFalse: [procs add: p]].	procs := procs reject: [:p | p isSystemProcess].	"Next, pause all runable processes, in priority order"	[(proc := self nextProcessForPausing) notNil]		whileTrue:			[procs remove: proc ifAbsent: [].			self pauseProcess: proc].	"These remaining processes should be blocked or suspended."	procs do: [:p | self pauseProcess: p]</body><body package="Debugger-Support" selector="proceedUserProcesses">proceedUserProcesses	pausedProcesses shallowCopy do: [:p | p proceed].</body><body package="Debugger-Support" selector="removePausedProcess:">removePausedProcess: aProcess	pausedProcesses remove: aProcess ifAbsent: [].</body><body package="Debugger-Support" selector="resumePausedProcess:">resumePausedProcess: aProcess	pausedProcesses remove: aProcess ifAbsent: [].	^aProcess resume.</body></methods><methods><class-id>UI.ComposedTextView</class-id> <category>updating</category><body package="Debugger-Support" selector="updateTheDisplay">updateTheDisplay	"This is used by the browsers only."	| text changedString |	text := self getContents asText.	changedString := displayContents text string ~= text string.	(changedString or: [displayContents text runs ~= text runs])		ifFalse: [self controller. "Make sure we have a controller"				self resetController.				^self]. 	"If nothing changed, exit"	self isOpen		ifTrue:			[displayContents setCompositionWidth: self wrappingBox width.			displayContents text: text asText copy]		ifFalse:			[displayContents setCompositionWidth: ComposedText defaultCompositionWidth.			displayContents setText: text asText copy].	changedString		ifTrue: [self setToTop].	startBlock := stopBlock := nil.	selectionShowing := true.	self controller. "Make sure we have a controller"	self resetController.	"redisplay now so selection updates will display correctly"	self		invalidateRectangle: self bounds		repairNow: true.</body></methods><methods><class-id>Graphics.CharacterAttributes</class-id> <category>private</category><body package="Debugger-Support" selector="queryCacheAt:for:put:">queryCacheAt: aStyle for: aFontPolicy put: query	"Store the cached query for aStyle."	aStyle isCharStyleCacheable		ifFalse: [^self].	queryCache size &gt;= QueryCacheLimit		ifTrue: [self invalidateOnlyQueryCache].	policyCache at: 1 put: aFontPolicy.	queryCache at: aStyle put: query</body></methods><methods><class-id>Kernel.ClassBuilder</class-id> <category>accessing</category><body package="Debugger-Support" selector="revertProbedMethods">revertProbedMethods	| removed |	removed := OrderedCollection new.	records do:		[:rec | rec targetClass ifNotNil: [removed addAll: rec targetClass revertAllProbedMethodsInTree]].	^removed"Smalltalk Professional Debug Package Version 3.1 (c) 2002 Crafted Smalltalk".</body><body package="Debugger-Support" selector="reviseSystemSilently">reviseSystemSilently	| queue map next removedMethods |	^SystemUtils modifySystem:		[self validateRecords.		removedMethods := self revertProbedMethods.		queue := OrderedCollection withAll: records.		queue removeAllSuchThat: [:rec | rec isTrivial].		map := Dictionary new.		[queue isEmpty]			whileFalse:				[next := queue removeFirst.				(map includesKey: next fullName)					ifFalse:						[map at: next fullName put: next.						queue addAll: next neededRecords]].		map do: [:record |			record				reviseFromMap: map;				alertSuperclass].		map do: [:record | record verify].		Cursor read showWhile:			[map do: [:record | record constructCopy].			 map do: [:record | record constructCopy2].			 map do: [:record | record constructCopy3]].		Cursor write showWhile:			[map do: [:record | record doBecome].			 map do: [:record | record cleanup]].		records do: [:r | r doExtraWork].		NameScope initialize.		BlockAnalyzer initialize.		ProbedCompiledMethod recompileAndInsertProbesFrom: removedMethods.		records first result]</body></methods><methods><class-id>Kernel.GeneralBindingReference</class-id> <category>copying</category><body package="Debugger-Support" selector="basicDcopy">basicDcopy	"Don't copy"	^self</body></methods><methods><class-id>Kernel.ProgramNode</class-id> <category>copying</category><body package="Debugger-Support" selector="postDcopy">postDcopy	"Complete the deep copy operation."	| class |	sourcePosition := sourcePosition basicDcopy.	class := self class.	4 to: class instSize do: [ :i | self instVarAt: i put: (self instVarAt: i) basicDcopy]</body></methods><methods><class-id>UI.ParagraphEditor</class-id> <category>accessing</category><body package="Debugger-Support" selector="selectionRange">selectionRange	^self selectionStartIndex to: self selectionStopIndex</body></methods><methods><class-id>Core.Collection</class-id> <category>printing</category><body package="Debugger-Support" selector="forStackDumpPrintUsing:">forStackDumpPrintUsing: aPolicy	aPolicy printCollection: self.</body></methods><methods><class-id>Tools.ProcessHandle</class-id> <category>control</category><body package="Debugger-Support" selector="abortDebugOperation">abortDebugOperation	process isNil		ifTrue: [^self].	[process interruptWith:			[Object userInterruptSignal 					interruptWith: thisContext sender sender					errorString: (#OperationAborted &lt;&lt; #pdp &gt;&gt; 'Operation aborted') asString]]		on: Error		do: [:ex | ]	"Ignore error"</body><body package="Debugger-Support" selector="destroyProcess">destroyProcess	process := nil.</body></methods><methods><class-id>Tools.ProcessHandle</class-id> <category>testing</category><body package="Debugger-Support" selector="isInDebugSession">isInDebugSession	^process notNil</body><body package="Debugger-Support" selector="isTerminated">isTerminated	^process isNil or: [process isTerminated]</body></methods><methods><class-id>Tools.ProcessHandle</class-id> <category>control</category><body package="Debugger-Support" selector="pauseProcess">pauseProcess	"Continue the process--start it up again from the point of interrupt.  	If there was a controller associated with the interrupted process, 	make it be the active controller."	process suspendedContext: resumeContext.	process disableDebug.	resumeContext method == (Process compiledMethodAt: #terminate)		ifFalse:			[controller == nil				ifFalse: [controller restartAfterError.]].	Processor pauseProcess: process.	process := nil.  "So that the process doesn't get terminated"</body></methods><methods><class-id>Tools.ProcessHandle</class-id> <category>access</category><body package="Debugger-Support" selector="prepareForErrorCondition">prepareForErrorCondition	controller ifNotNil: [controller shutdownBecauseOfError].	modalWindowChain := WindowManager modalWindowChain reverse.	WindowManager beEffectivelyModeless.</body><body package="Debugger-Support" selector="prepareForSimulation">prepareForSimulation	interrupted		ifTrue: [^self].	resumeContext push: proceedValue.	interrupted := true. "simulation leaves same state as interrupting"</body></methods><methods><class-id>Tools.ProcessHandle</class-id> <category>private</category><body package="Debugger-Support" selector="process:controller:interrupted:resumeContext:">process: aProcess controller: aController interrupted: aBoolean resumeContext: aContext	process := aProcess.	process enableDebug.	controller := aController.	interrupted := aBoolean.	resumeContext := aContext.	proceedValue := nil</body></methods><methods><class-id>Tools.ProcessHandle</class-id> <category>control</category><body package="Debugger-Support" selector="resumeProcess">resumeProcess	"Continue the process--start it up again from the point of interrupt.  	If there was a controller associated with the interrupted process, 	make it be the active controller."	| p |	process suspendedContext: resumeContext.	process disableDebug.	resumeContext method == (Process compiledMethodAt: #terminate)		ifFalse:			[controller notNil				ifTrue:					[controller restartAfterError.					controller controlInitialize]].	p := process.	process := nil.  "So that the process doesn't get terminated"	p resume.</body><body package="Debugger-Support" selector="terminate">terminate	"Halt the evaluate of the process forever."	controller notNil		ifTrue:			[[controller resetAfterError]				on: Error				do: [:ex |nil]].	process isNil		ifTrue: [^self].	process suspendedContext: resumeContext.	process disableDebug.	[process terminate]		on: GenericException		do: [:ex |			process				suspendUnconditionally;				suspendedContext: nil].	process := nil</body></methods><methods><class-id>Tools.ProcessHandle</class-id> <category>access</category><body package="Debugger-Support" selector="topContext:">topContext: aContext	"Set aContext to be the context in which to continue the process, if possible."	resumeContext := aContext.	process suspendedContext: aContext.</body></methods><methods><class-id>Core.Text</class-id> <category>emphasis</category><body package="Debugger-Support" selector="allItalic">allItalic	"Set the emphasis for all characters in the receiver to be italic."	self emphasizeAllWith: #italic</body></methods><methods><class-id>Core.Character</class-id> <category>copying</category><body package="Debugger-Support" selector="basicDcopy">basicDcopy</body></methods><methods><class-id>Kernel.SystemUtils class</class-id> <category>accessing</category><body package="Debugger-Support" selector="rebindEntireSystem">rebindEntireSystem	self allClassesDo: 		[:class |		Transcript show: class printString; cr.		class revertAllProbedMethods.		class rebindAllMethods]"Smalltalk Professional Debug Package Version 2.5 (c) 1999 Crafted Smalltalk"</body></methods><methods><class-id>Core.SmallInteger</class-id> <category>copying</category><body package="Debugger-Support" selector="basicDcopy">basicDcopy</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>copying</category><body package="Debugger-Support" selector="basicMethodDcopy">basicMethodDcopy	^self basicDcopy</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>testing</category><body package="Debugger-Support" selector="isClean">isClean	^outerContext isNil and: [method numCopiedValues = 0]</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>private</category><body package="Debugger-Support" selector="method:">method: aMethod	method := aMethod</body></methods><methods><class-id>Kernel.CompiledMainBlock</class-id> <category>accessing</category><body package="Debugger-Support" selector="nesting">nesting	^0</body><body package="Debugger-Support" selector="originalMethod">originalMethod	^self</body></methods><methods><class-id>Kernel.BlockContext</class-id> <category>accessing-debugger</category><body package="Debugger-Support" selector="findHomeContextByMatchingHomeMethod">findHomeContextByMatchingHomeMethod	| meth ctx |	meth := self method homeMethod originalMethod.	ctx := self sender.	[ctx == nil]		whileFalse: 			[ctx isBlockContext				ifFalse: [ctx method originalMethod == meth ifTrue: [^ctx]].			ctx := ctx sender].	^nil</body></methods><methods><class-id>Kernel.BlockContext</class-id> <category>private-debugger</category><body package="Debugger-Support" selector="initialStackDepthForProbes">initialStackDepthForProbes	^super initialStackDepthForProbes + method numCopiedValues</body></methods><methods><class-id>Kernel.BlockContext</class-id> <category>accessing-debugger</category><body package="Debugger-Support" selector="intendedReceiver">intendedReceiver	"Answer the receiver to which the home method was sent."	| ctxt selfVar |	(ctxt := self home) == nil		ifFalse: [^ctxt receiver].	"No home receiver, look for a compiler generated temp."	selfVar := self localScope temps detect: [:var | var key = 'self'] ifNone: [^nil].	^self getTempVar: selfVar value</body></methods><methods><class-id>Kernel.BlockContext</class-id> <category>private</category><body package="Debugger-Support" selector="nestingAt:do:">nestingAt: level do: aBlock 	| outer |	level = 0		ifTrue: [^aBlock value: self].	(outer := self outerContext) == nil		ifTrue: [^self error: (#LevelCountingError &lt;&lt; #pdp &gt;&gt; 'Level counting error')].	^outer nestingAt: level - 1 do: aBlock</body></methods><methods><class-id>Kernel.BlockContext</class-id> <category>simulation-control</category><body package="Debugger-Support" selector="stepToCtxtWithSameParentAs:">stepToCtxtWithSameParentAs: ctxt	"Step to a context with the same original method as ctxt,	or until ctxt has exited."	| parentCtxt |	self hasExited		ifFalse: [^ctxt].	parentCtxt := ctxt findParentContextWithHomeMethod: self method homeMethod originalMethod.	parentCtxt isNil		ifTrue: [^ctxt].	"No parent."	^parentCtxt sendIntoBlockStartingWithCallee: ctxt."Smalltalk Professional Debug Package Version 3.1 (c) 2003 Crafted Smalltalk"</body></methods><methods><class-id>Kernel.BlockContext</class-id> <category>accessing-debugger</category><body package="Debugger-Support" selector="supposedHome">supposedHome	| ctx |	(ctx := self home) == nil		ifFalse: [^ctx].	^self findHomeContextByMatchingHomeMethod</body></methods><methods><class-id>Kernel.BlockContext</class-id> <category>testing</category><body package="Debugger-Support" selector="willExitMethod">willExitMethod	"Answer whether the next bytecode will cause an exit from the method."	self changeToVPC.	^(method byteAt: pc) = Kernel.OpcodePool.OpHomeReturn</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService class</class-id> <category>interface specs</category><body package="Debugger-Support" selector="watchVarSpec">watchVarSpec	"UIPainter new openOnClass: self andSelector: #watchVarSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #pdp) 			#bounds: #(#Rectangle 466 311 979 522 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#LayoutOrigin -103 0.5 15 0 ) 					#label: #(#{Kernel.UserMessage} #key: #SelectWatchVariable #defaultString: 'Select Watch Variable' #catalogID: #pdp) ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 121 166 210 196 ) 					#model: #accept 					#tabable: false 					#label: #(#{Kernel.UserMessage} #key: #Done #defaultString: 'Done' #catalogID: #pdp) 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 304 168 389 198 ) 					#model: #cancel 					#tabable: false 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #pdp) 					#defaultable: true ) 				#(#DividerSpec 					#layout: #(#LayoutFrame 0 0 150 0 0 1.0 154 0 ) ) 				#(#InputFieldSpec 					#layout: #(#Rectangle 131 98 385 130 ) 					#model: #wVar 					#tabable: false 					#isReadOnly: true ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 9 51 132 80 ) 					#model: #TOS 					#tabable: false 					#label: #(#{Kernel.UserMessage} #key: #TopOfStack #defaultString: 'Top of Stack' #catalogID: #pdp) 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 143 50 332 80 ) 					#name: #IvarSwitch 					#model: #iVar 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #InstanceVariableDots #defaultString: 'Instance Variable...' #catalogID: #pdp) 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 342 50 503 81 ) 					#name: #TempSwitch 					#model: #tVar 					#tabable: false 					#label: #(#{Kernel.UserMessage} #key: #TempVariableDots #defaultString: 'Temp Variable...' #catalogID: #pdp) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>menus - pdp</category><body package="Debugger-Support" selector="browseAllProbedMethods">browseAllProbedMethods	&lt;menuItem: #(#_BrowseProbes #pdp '&amp;Browse Probes')		icon: nil		nameKey: nil		menu: #(#menuBar #probes)		position: 30.1&gt;	PDPManager browseAllProbedMethods</body><body package="Debugger-Support" selector="clearTestExpressionLibrary">clearTestExpressionLibrary	&lt;menuItem: #(#_ClearDot #pdp '&amp;Clear...')		icon: nil		nameKey: nil		menu: #(#menuBar #probes #testLibrary)		position: 20.2&gt;	ProbeTestExpressionEditor clearLibrary</body><body package="Debugger-Support" selector="clearWatchExpressionLibrary">clearWatchExpressionLibrary	&lt;menuItem: #(#_ClearDot #pdp '&amp;Clear...')		icon: nil		nameKey: nil		menu: #(#menuBar #probes #watchLibrary)		position: 20.2&gt;	ProbeActionExpressionEditor clearLibrary</body><body package="Debugger-Support" selector="inspectDebugVars">inspectDebugVars	&lt;menuItem: #(#_InspectDebugVariables #pdp '&amp;Inspect Debug Variables') 		icon: nil		nameKey: nil		menu: #(#menuBar #probes)		position: 30.2&gt;	PDPManager debugVariables inspect</body><body package="Debugger-Support" selector="inspectTestExpressionLibrary">inspectTestExpressionLibrary	&lt;menuItem: #(#_Inspect #pdp '&amp;Inspect')		icon: nil		nameKey: nil		menu: #(#menuBar #probes #testLibrary)		position: 20.1&gt;	ProbeTestExpressionEditor inspectLibrary</body><body package="Debugger-Support" selector="inspectWatchExpressionLibrary">inspectWatchExpressionLibrary	&lt;menuItem: #(#_Inspect #pdp '&amp;Inspect')		icon: nil		nameKey: nil		menu: #(#menuBar #probes #watchLibrary)		position: 20.1&gt;	ProbeActionExpressionEditor inspectLibrary</body><body package="Debugger-Support" selector="loadTestExpressionLibrary">loadTestExpressionLibrary	&lt;menuItem: #(#_LoadDot #pdp '&amp;Load...')		icon: nil		nameKey: nil		menu: #(#menuBar #probes #testLibrary)		position: 10.1&gt;	ProbeTestExpressionEditor readLibrary</body><body package="Debugger-Support" selector="loadWatchExpressionLibrary">loadWatchExpressionLibrary	&lt;menuItem: #(#_LoadDot #pdp '&amp;Load...')		icon: nil		nameKey: nil		menu: #(#menuBar #probes #watchLibrary)		position: 10.1&gt;	ProbeActionExpressionEditor readLibrary</body><body package="Debugger-Support" selector="probeLibraryMenu">probeLibraryMenu	&lt;submenu: #(#Probe_Library #pdp 'Probe &amp;Library')		nameKey: #probeLibrary		menu: #(#menuBar #probes)		position: 50.1&gt;</body><body package="Debugger-Support" selector="probes">probes	&lt;submenu: #(#_Debug #menus '&amp;Debug')		nameKey: #probes		menu: #(#menuBar)		position: 10.031&gt;</body><body package="Debugger-Support" selector="purgeUnusedVars">purgeUnusedVars	&lt;menuItem: #(#RemoveUnusedDebug_VariablesDots #pdp 'Remove Unused Debug &amp;Variables...') 		icon: nil		nameKey: nil		menu: #(#menuBar #probes)		position: 20.3&gt;	(Dialog confirm: (#PurgeUnusedDebugVariables &lt;&lt; #pdp &gt;&gt; 'Purge unused debug variables?'))			ifTrue: [PDPManager purgeUnusedDebugVariables]</body><body package="Debugger-Support" selector="purgeUnusedWatches">purgeUnusedWatches	&lt;menuItem: #(#RemoveUnused_WatchWindowsDots #pdp 'Remove Unused &amp;Watch Windows...') 		icon: nil		nameKey: nil		menu: #(#menuBar #probes)		position: 20.2&gt;	(Dialog confirm: (#PurgeUnusedWatches &lt;&lt; #pdp &gt;&gt; 'Purge unused watches?'))			ifTrue: [PDPManager purgeUnusedWatchWindows]</body><body package="Debugger-Support" selector="readProbeLibrary">readProbeLibrary	&lt;menuItem: #(#_LoadDot #pdp '&amp;Load...')		icon: nil		nameKey: nil		menu: #(#menuBar probes #probeLibrary)		position: 10.1&gt;	ProbedCompiledMethod readProbesFromFile</body><body package="Debugger-Support" selector="removeAllProbes">removeAllProbes	&lt;menuItem: #(#_RemoveAllProbesDots #pdp '&amp;Remove All Probes...') 		icon: nil		nameKey: nil		menu: #(#menuBar #probes)		position: 20.1&gt;	(Dialog confirm: (#RemoveAllProbesFromSystem &lt;&lt; #pdp &gt;&gt; 'Remove all probes from system?'))		ifTrue: [ProbedCompiledMethod revertAllProbedMethodsInSystem]</body><body package="Debugger-Support" selector="saveProbeLibrary">saveProbeLibrary	&lt;menuItem: #(#_SaveDot #pdp '&amp;Save...')		icon: nil		nameKey: nil		menu: #(#menuBar #probes #probeLibrary)		position: 10.2&gt;	ProbedCompiledMethod saveProbesToFile</body><body package="Debugger-Support" selector="saveTestExpressionLibrary">saveTestExpressionLibrary	&lt;menuItem: #(#_SaveDot #pdp '&amp;Save...')		icon: nil		nameKey: nil		menu: #(#menuBar #probes #testLibrary)		position: 10.2&gt;	ProbeTestExpressionEditor saveLibrary</body><body package="Debugger-Support" selector="saveWatchExpressionLibrary">saveWatchExpressionLibrary	&lt;menuItem: #(#_SaveDot #pdp '&amp;Save...')		icon: nil		nameKey: nil		menu: #(#menuBar #probes #watchLibrary)		position: 10.2&gt;	ProbeActionExpressionEditor saveLibrary</body><body package="Debugger-Support" selector="testLibraryMenu">testLibraryMenu	&lt;submenu: #(#_TestLibrary #pdp '&amp;Test Library')		nameKey: #testLibrary		menu: #(#menuBar #probes)		position: 50.3&gt;</body><body package="Debugger-Support" selector="toggleDebugging">toggleDebugging	&lt;menuItem: #toggleDebuggingLabel		icon: nil		nameKey: nil		menu: #(#menuBar #probes)		position: 10.1&gt;	PDPManager toggleDebugging</body><body package="Debugger-Support" selector="watchLibraryMenu">watchLibraryMenu	&lt;submenu: #(#_WatchLibrary #pdp '&amp;Watch Library')		nameKey: #watchLibrary		menu: #(#menuBar #probes)		position: 50.2&gt;</body></methods><methods><class-id>Graphics.CharacterAttributes class</class-id> <category>class initialization</category><body package="Debugger-Support" selector="pdpAttributesFor:">pdpAttributesFor: aDictionary	&lt;stylesWithOrder: 2&gt;	aDictionary at: #probe put: [:query :family | query underline: true; color: ColorValue red].	aDictionary at: #tempProbe put: [:query :family | query underline: true; color: ColorValue yellow].</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-debugger</category><body package="Debugger-Support" selector="debugger10EditContextListPolicy">debugger10EditContextListPolicy	&lt;setting: #(tools debugger editContextListPolicy)&gt;	^ExternalSetting new		label: #EditContextListPresentation &lt;&lt; #labels &gt;&gt; 'Context list presentation';		editorClass: CraftedSmalltalk.ContextListPolicyEditor;		helpText: #EditContextListPresentationHelpText &lt;&lt; #dialogs &gt;&gt; 'Opens an editor that allows to define special highlighting of contexts in the context list of the debugger. This setting is not saved together with the settings of the image.'</body><body package="Debugger-Support" selector="debugger40usePermanentProbes">debugger40usePermanentProbes	&lt;setting: #(tools debugger usePermanentProbes)&gt;	^(BooleanSetting on: CraftedSmalltalk.PDPManager aspect: #permanentProbeIsDefault)		label: #UsePermanentProbesByDefault &lt;&lt; #labels &gt;&gt; 'Use permanent probes by default';		default: true;		helpText: #UsePermanentProbesHelpText &lt;&lt; #dialogs &gt;&gt; 'Determines the default type of probes, and breakpoints created by the Insert Breakpoint command.'</body><body package="Debugger-Support" selector="debugger50showToolbarBelowContexts">debugger50showToolbarBelowContexts	&lt;setting: #(tools debugger showToolbarBelowContexts)&gt;	^(BooleanSetting on: #{CraftedSmalltalk.DebuggerClient.PlaceToolbarBelowContexts})		label: #ShowToolbarBelowContexts &lt;&lt; #labels &gt;&gt; 'Show toolbar below the context list';		default: false;		helpText: #ShowToolbarBelowContextsHelpText &lt;&lt; #dialogs &gt;&gt; 'Determines whether the toolbar is located in the standard place below the menu, or between the context list and the method text view.'</body><body package="Debugger-Support" selector="debugger70EventFaithfulDebugging">debugger70EventFaithfulDebugging	&lt;setting: #(tools debugger useEventFaithfulDebugging)&gt;	^(BooleanSetting on: #{CraftedSmalltalk.DebuggerService.EventFaithfulDebugging})		default: false;		label: #UseEventFaithfulDebugging &lt;&lt; #labels &gt;&gt; 'Use event faithful debugging';		helpText: #UseEventFaithfulDebuggingHelpText &lt;&lt; #dialogs &gt;&gt; 'Event faithful debugging insures that events are processed properly while debugging, but causes windows to freeze.  If you are not concerned with debugging widgets, dialogs, or display code, then you may want this to be turned off.  Additionally, if you are concerned about debugging THAPI you should have this enabled.'</body><body package="Debugger-Support" selector="debuggerPage">debuggerPage	&lt;settingsPage: #(tools debugger)&gt;	^ModularSettingsPage new		label: #Debugger &lt;&lt; #labels &gt;&gt; 'Debugger';		icon: (ListIconLibrary visualFor: #bug);		settings: (self settingsWithPrefix: #(tools debugger))</body></methods><initialize><class-id>CraftedSmalltalk.DebuggerService</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>GeneralBindingReference</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>path cache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Boolean</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>CodeComponent</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Components</category><attributes><package>System-Code Components</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>RunArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>runs values cacheRun cacheRunStart </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>ParagraphEditor</name><environment>UI</environment><super>UI.ControllerWithMenu</super><private>false</private><indexed-type>none</indexed-type><inst-vars>beginTypeInIndex anchorIndex emphasisHere dispatchTable charComposer textHasChanged feelPolicy supportCodeEditingFeels localMenuItems extendingDown </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>Parser</name><environment>Kernel</environment><super>Kernel.Scanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder requestor oldLanguage newLanguage extendedLanguage parseNode failBlock endTemps targetClass environment topEnvironment bindingRefs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Public Access</category><attributes><package>System-Compiler-Public Access</package></attributes></class><class><name>ClassBuilder</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>records </inst-vars><class-inst-vars></class-inst-vars><imports>			Behavior.*			</imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>ProcessorScheduler</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>quiescentProcessLists activeProcess pausedProcesses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Processes</category><attributes><package>Kernel-Processes</package></attributes></class><class><name>ProgramNode</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourcePosition comment compilerHints blockIndex mapEntry returnMapEntry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>Process</name><environment>Kernel</environment><super>Core.Link</super><private>false</private><indexed-type>none</indexed-type><inst-vars>suspendedContext priority myList depth hostThreadKey interruptProtect environment isSystem name inDebug </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Processes</category><attributes><package>Kernel-Processes</package></attributes></class><class><name>Text</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string runs </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>CompiledCode</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>bytes </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>ProcessHandle</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>process controller interrupted resumeContext proceedValue modalWindowChain </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>Tools-Programming</package></attributes></class><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>SyntaxError</name><environment>Kernel</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>class badText processHandle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>Tools-Programming</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector toolDock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Symbol</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>CompiledBlock</name><environment>Kernel</environment><super>Kernel.CompiledCode</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>outerMethod </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>GeneralNameSpace</name><environment>Kernel</environment><super>Core.KeyedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>organization bindings specificImports generalImports </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>CharacterAttributes</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>attributes sharedAttributes defaultQuery queryCache policyCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>Graphics-Fonts</package></attributes></class><class><name>CompiledMainBlock</name><environment>Kernel</environment><super>Kernel.CompiledCode</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>CompiledMethod</name><environment>Kernel</environment><super>Kernel.CompiledMainBlock</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>mclass sourceCode </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>AnnotatedMethod</name><environment>Kernel</environment><super>Kernel.CompiledMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>attributes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>MarkedMethod</name><environment>Kernel</environment><super>Kernel.AnnotatedMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>markType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>ComposedTextView</name><environment>UI</environment><super>UI.AutoScrollingView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>displayContents startBlock stopBlock selectionShowing displaySelection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>SmallInteger</name><environment>Core</environment><super>Core.Integer</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars>minVal maxVal maxBits maxBytes </class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>InstructionStream</name><environment>Kernel</environment><super>Kernel.InstructionClient</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method pc </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Context</name><environment>Kernel</environment><super>Kernel.InstructionStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sender receiver stackp stack </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>MethodContext</name><environment>Kernel</environment><super>Kernel.Context</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>BlockContext</name><environment>Kernel</environment><super>Kernel.Context</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class></st-source>