<?xml version="1.0"?><st-source><!-- Name: Tools-TrippyNotice: Copyright © 1999-2005 Cincom Systems, Inc.  All Rights Reserved.Comment: Tools-Trippy provides a greatly enhanced inspector/object-exploration tool, called Trippy. In addition to the traditional inspector functionality, Trippy includes the following features.• Presents an inspected object from multiple perspectives, such as the "logical" view of an OrderedCollection as a sequence of elements, versus the "physical" view of it as a Smalltalk object with all its named and indexed variables;• Provides a view showing all of the object’s methods, with selective inclusion of inherited methods. This allows to easily see all messages an object understands. In this view you can also edit and add methods, much like in any browser.• Navigation through the "neigborhood" of an object being inspected, such as other elements of a collection containing the object, or the hierarchy of visual components including the object.• Navigation paths through objects are remembered. "Next" and "previous" web browser-like buttons and a hierarchical visit history are available to quickly travel to any of the already visited objects.• Drag-and-drop copying and moving, to copy objects between variables, add objects to collections, rearrange elements in collections, and add objects to workspaces as local variables.• Most objects manipulations are undoable, with a multi-level undo.• The inspector includes a separate evaluation pane, the content of which is independent of the selection in the inspector and can be shared by all inspectors.• Multiple selection is available to easily view or change many fields or elements of an object at once.You can learn by exploring the inspector options, or read the Trippy Walkthrough on the Cincom Smalltalk Wiki. The original Inspector remains in the image. If, for some reason, you want to revert to using it as the default inspector, evaluate the expression:	Tools.Trippy.Inspector useSimpleInspector: trueDbIdentifier: bear73DbTrace: 52936PackageName: Tools-TrippyParcel: #('Tools-Trippy')ParcelName: Tools-TrippyPrintStringCache: (7.3 - 1.11,bobw)Version: 7.3.1Date: 5:52:36 pm April 10, 2005 --><time-stamp>From VisualWorks®, 7.3.1 of April 10, 2005 on April 10, 2005 at 5:52:36 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Trippy</name><environment>Tools</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></name-space><class><name>PageDriver</name><environment>Tools.Trippy</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>page </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.PageDriver</class-id><body>Instances of this class are plug-ins that work in concert with LinearInspectorPages to support two apperances of those pages: unsegemented and segmented. A driver encapsulates the differences that exist between those appearance modes.This class provides the behaviour of unsegmented pages, i.e. those that present all keys in a single list, assuming there are not too many of them.Instance Variables:	page	&lt;LinearInspectorPage&gt;  The page we are helping.</body></comment><class><name>ObjectSegment</name><environment>Tools.Trippy</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>firstIndex lastIndex firstPart lastPart </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.ObjectSegment</class-id><body>When an object is broken into groups of parts to keep the list of parts of a reasonable size, instances of this class represent those groups.Instance Variables:	firstIndex	&lt;Integer&gt; Index of the first element of this segment within the page's sequence of keys.	lastIndex	&lt;Integer&gt;  Ditto of the last element.	firstKey	&lt;Integer&gt; Key of the first element, cached here to allow printing.	lastKey	&lt;Integer&gt;  Ditto of the last element.</body></comment><class><name>SegmentedPageDriver</name><environment>Tools.Trippy</environment><super>Tools.Trippy.PageDriver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>segmentSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.SegmentedPageDriver</class-id><body>This is a page driver (see explanation in the superclass) that provides the behaviour of segmented pages, i.e. those that break keys into segments, or pages, and only show the keys of the currently selected page(s).Instance Variables:	segmentSize	&lt;Integer&gt;  The number of keys per segment. Last segment typically contains fewer keys, of course.</body></comment><class><name>VisualComponentProxy</name><environment>Tools.Trippy</environment><super>Graphics.VisualPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>actualComponent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.VisualComponentProxy</class-id><body>This is a helper class for the VisualComponentInspectorPage. It allows displaying a preview of any visual component without ripping it out of the hierarchy it normally belongs to, by pretending to be a visual component itself and delegating the important messages to the real visual component.Instance Variables:	actualComponent	&lt;VisualComponent&gt;  The VisualComponent being previewed.</body></comment><class><name>Navigator</name><environment>Tools.Trippy</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>visit shell inspector inspectorClasses inspectorCache inspectorHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.Navigator</class-id><body>A navigator is a container interface for an inspector. An inspector displays an individual object, while a navigator provides a wider context of objects to be displayed, as well as manages the choice of inspectors that can display a given object. For example, a hierarchy navigator displays a hierarchy of objects. When a hierarchy element is selected, the navigator determines what inspectors can be used to display it, updates the view selection tabs accordingly, and installs one of those inspectors to actually display the object.Instance Variables:	visit	&lt;Visit&gt;	The current object's visit. As the user changes objects within the navigator, visits are updated to reflect the travel.	shell	&lt;InspectorShell&gt;	The parent inspector shell.	inspector	&lt;Inspector&gt;	The currently installed inspector.	inspectorClasses	&lt;Array of: Class&gt;	Classes of inspectors that can present the current object.	inspectorHolder	&lt;SelectionInList&gt;	The model of the view selection tab control.</body></comment><class><name>OwnerNavigator</name><environment>Tools.Trippy</environment><super>Tools.Trippy.Navigator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ownerInspector fieldListHolder vicinity </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.OwnerNavigator</class-id><body>This one's navigation context is the owner object, that is parts of the object we were inspecting before diving into the current object.  This navigator is what takes care of Explore&gt;Forward and Explore&gt;Backward menu settings.Instance Variables:	ownerInspector	&lt;PartListAbstractInspector&gt;	The owner inspector (see above) that supplies us with the list of parts of the owner object. These parts are the context for navigation.	fieldListHolder	&lt;SelectionInList&gt;	The model of the field list.	vicinity	&lt;#owner | #self&gt;	#owner if this navigator does "Explore&gt;Backward", or #self if it does "Explore&gt;Forward". This affects the menu check marks, and also what happens when we zoom into a part.</body></comment><class><name>Inspector</name><environment>Tools.Trippy</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>object container </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.Inspector</class-id><body>This is an abstract superclass of inspectors. An inspector is a module that plugs into a Navigator to present a view of a single object.  The navigator creates it and tells what object to inspect.Subclasses should implement the following methods:	copyStateTo:	refresh	selectAllInstance Variables:	object	&lt;Object&gt;  The object being inspected.</body></comment><class><name>Part</name><environment>Tools.Trippy</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>object </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.Part</class-id><body>Instances of Part are used by PartListAbstractInspector and subclasses to represent elements of the left hand side list in the inspector. A part knows its object and is responsible for obtaining its value (if it has a value as some parts don't), setting it (if the part is not read-only), supplying the text to be displayed in the inspector's right hand side pane.Instance Variables:	object	&lt;Object&gt;	The Whole.</body></comment><class><name>TextAttribute</name><environment>Tools.Trippy</environment><super>Tools.Trippy.Part</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label text textBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.TextAttribute</class-id><body>This is a part that does not have a value that can be copied or set. It only provides a text that can be displayed in the inspector's right hand side pane, but cannot be dove into.Instance Variables:	label	&lt;String | UserMessage&gt;	The text used to identify the part in the UI.	text	&lt;Text | nil&gt;	The part text, unless generated dynamically.	textBlock	&lt;BlockClosure | nil&gt;	The block that generates the part text. If nil, the text is static and is stored in the 'text' instance variable.</body></comment><class><name>PartSnapshot</name><environment>Tools.Trippy</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>part value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.PartSnapshot</class-id><body>This is a snapshot of a part state. A regular part does not store its current value and instead gets it from the object each time it is needed. A snapshot is there for cases when it is necessary to remember the current part value because it may change in future.Instance Variables:	part	&lt;Part&gt;	The original part.	value	&lt;Object&gt;	The remembered part value.</body></comment><class><name>DerivedAttribute</name><environment>Tools.Trippy</environment><super>Tools.Trippy.Part</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label value valueBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.DerivedAttribute</class-id><body>An instance can be returned by any object as an element of a collection of extra attributes (see #inspectorExtraAttributes message). It identifies a part of the object which is not a physical attribute (not a named or indexed variable) but can be calculated and is important enough to show it together with "real" attributes.Instance Variables:	label	&lt;String | UserMessage&gt;	The text used by the UI to identify this attribute.	value	&lt;Object | nil&gt;	The value of the attribute if not calculated dynamically.	valueBlock	&lt;BlockClosure | nil&gt;	The block to calculate the value of the attribute. If nil, the value is static and is stored in the 'value' instance variable.</body></comment><class><name>HierarchyNavigator</name><environment>Tools.Trippy</environment><super>Tools.Trippy.Navigator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hierarchy originalVisit hierarchyHolder root </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.HierarchyNavigator</class-id><body>This navigator displays a hierarchy of objects, such as a hierarchy of visual components or a class hierarchy. One of the objects is the "original"; that is the one that was the entry point into the hierarchy.  For example, you find a CompositePart and select "Explore&gt;Component Hierarchy". The hierarchy will include the full component tree with the root in the ScheduledWindow, but the CompositePart is the entry point. The inspector area always shows the currently selected hierarchy member, and the visit tree is updated as selections are made.  New visits into the hierarchy members are registered as children of the original element's visit.Instance Variables:	hierarchy	&lt;Hierarchy&gt;	The Hierarchy (see the class) representing the hierarchy we navigate.	originalVisit	&lt;Visit&gt;	Visit of the object which was the entry point of the hierarchy (see above).	hierarchyHolder	&lt;IndentedTreeSelectionInList&gt;	The model of the hierarchy view.	root	&lt;Object&gt;	The root object of the hierarchy.</body></comment><class><name>OverriddenMethodDefinition</name><environment>Tools.Trippy</environment><super>Tools.MethodDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.OverriddenMethodDefinition</class-id><body>These method definitions represent superclass methods in a method list of a behavior inspector that have been overriden by other methods deeper down the inheritance chain of the class we are looking at.</body></comment><class><name>Visit</name><environment>Tools.Trippy</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>object owner children </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.Visit</class-id><body>This is a record of visiting an object. Typically when we visit an object, we get there from some other object--that is, some other visit.  This is the owner visit.  The owner visit may be nil in some cases--for example, when the current visit is the root of the visit hierarchy, that is, the object we originally opened the inspector on. Starting from an object, we may go visit some other related objects.  Those would be child visits.Instance Variables:	object	&lt;Object&gt;	The object we are visiting.	owner	&lt;Visit | nil&gt;	The owner visit or nil.	children	&lt;OrderedCollection of: Visit&gt;	Visits that this object is the owner of.</body></comment><class><name>SetElement</name><environment>Tools.Trippy</environment><super>Tools.Trippy.Part</super><private>false</private><indexed-type>none</indexed-type><inst-vars>element </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.SetElement</class-id><body>This part represents an element of a set, or some other unkeyed collection where the only thing that is known is whether an object is in the collection or not.Instance Variables:	element	&lt;Object&gt;</body></comment><class><name>KeyedElement</name><environment>Tools.Trippy</environment><super>Tools.Trippy.Part</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.KeyedElement</class-id><body>A part of an object accessible by sending messages #at: and #at:put:. Elements of both Dictionaries and Arrays are keyed elements.Instance Variables:	key	&lt;Object&gt;	The #at: argument used to retrieve the part value.</body></comment><class><name>Action</name><environment>Tools.Trippy</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label actionBlock enablementBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.Action</class-id><body>A sequence of Actions can be returned by any object in response to the #inspectorActions message. Each Action represents a user-level action this object can perform, and is presented by the inspector as menu choices.Instance Variables:	label	&lt;String | UserMessage&gt;	Used by the UI to describe this action.	actionBlock	&lt;BlockClosure&gt;	A 0-argument block evaluated when the user invokes the action.	enablementBlock	&lt;BlockClosure&gt;	A 0-argument block evaluated by the inspector to determine if the action is available.</body></comment><class><name>UndoAction</name><environment>Tools.Trippy</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>savedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.UndoAction</class-id><body>This is an abstract superclass of a group of subclasses representing undo editing actions in inspector pages. Whenever a change is done on a page, the page creates an undo action and sticks it in the undo history of that page.  This is how undo works.Subclasses must implement the following messages:	accessing		explanation		undoIn:Instance Variables:	savedValues	&lt;ExportBundle&gt;  The page typically has to save information about objects removed from the page, or values replaced in the page.  The information is saved as an ExportBundle for now.  When we roll OrderedDictionaries in, we can fix everything to use OrderedDictionary instead.</body></comment><class><name>InsertionUndo</name><environment>Tools.Trippy</environment><super>Tools.Trippy.UndoAction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>newKeys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.InsertionUndo</class-id><body>InsertionUndo saves the information necessary to undo insertion of new elements into an object.Instance Variables:	newKeys	&lt;Collection of: Object&gt;	A collection of objects identifying the inserted parts. The kind of the keys depends on the inspector that creates the undo, since it is the inspector that will later execute the undo is necessary. The receiver is only responsible to preserving the collection, which is treated as an opaque handle.</body></comment><class><name>InspectorHolder</name><environment>Tools.Trippy</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inspector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.InspectorHolder</class-id><body>InspectorHolder is used when a single inspector has to be embedded within another interface, without any fancy things like diving or navigation. In that case, InspectorHolder is embedded, and the inspector is placed inside the holder. The holder provides the interface an inspector expects from its container application, thus not requiring anything special from the actual application that embeds the inspection.Instance Variables:	inspector	&lt;Inspector&gt;</body></comment><class><name>UndoActionGroup</name><environment>Tools.Trippy</environment><super>Tools.Trippy.UndoAction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>actions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.UndoActionGroup</class-id><body>A sequence of other UndoActions that will all be applied on order if this action is applied.Instance Variables:	actions	&lt;SequenceableCollection of: UndoAction&gt;	Grouped actions.</body></comment><class><name>VisitTreeNavigator</name><environment>Tools.Trippy</environment><super>Tools.Trippy.HierarchyNavigator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>startingVisit </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.VisitTreeNavigator</class-id><body>The visit tree navigator displays the tree of Visits of the container inspector shell, thus showing all objects visited in this inspector session.  While this is essentially a hierarchy navigator, there are two important differences between it and the stock hierarchy navigator:1. The objects displayed in the hierarchy list are Visits, yet objects inspected are objects of those Visits rather than Visits themselves.2. Selecting a hierarchy element does not change the Visit tree, since navigation through the visit tree is "meta-navigation" we don't want to keep track of.3. (so it's three important differences) Zooming in (double-clicking) on a hierarchy element does not change the visit tree but changes the trail of objects used by the shell for backward/forward movement.Instance Variables:	startingVisit	&lt;Visit&gt;	The visit and originalVisit inherited from the parent are ignored and are dummy objects not hooked up to the actual visit tree of the inspector shell. This variable keeps onto the visit of the object we started to review the history from, so that we can still make the right initial selection when first opening the navigator.</body></comment><class><name>NamedVariable</name><environment>Tools.Trippy</environment><super>Tools.Trippy.Part</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name class index protected </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.NamedVariable</class-id><body>This part represents a named instance variable of an object.Instance Variables:	name	&lt;String&gt;	The name of the variable	class	&lt;ClassDescription&gt;	The class where the variable is defined (or a subclass of one)	index	&lt;Integer&gt;	The index of the variable in the index (future argument to #instVarAt:).</body></comment><class><name>PartVisit</name><environment>Tools.Trippy</environment><super>Tools.Trippy.Visit</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ownerInspector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.PartVisit</class-id><body>This is a special (and the most common) case of visiting an object, when the object we visit is a part (an instance variable or a collection element) of some other object. In this case, what we remember as the 'object' is really the part of the owner we are visiting rather than the object itself.  The object is supplied by the part on demand, thus avoiding any unwanted caching. This is important since the value of a part may change behind the scenes at any time.To allow inspecting siblings, we also need to remember the owner inspector, that is the inspector which was displaying the part we are visiting.  It can supply us with the full list that the currently visited part was a member of.Instance Variables:	ownerInspector	&lt;Inspector&gt;</body></comment><class><name>Hierarchy</name><environment>Tools.Trippy</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id label root parentBlock childrenBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.Hierarchy</class-id><body>Instances of this class can be returned by any object from the #inspectorHierarchies message to identify hierarchies the object is a member of.Instance Variables:	id	&lt;Symbol&gt;	Identifier of a hierarchy, used internally by the inspector to tell hierarchies apart. The only requirement is that hierarchies returned together by a single object all have different ids.	label	&lt;String | UserMessage&gt;	The text used by the UI to describe this hierarchy, such as 'Component'.	root	&lt;Object | nil&gt;	The root of the hierarchy. If the root is nil, the inspector will try to discover the root by chasing parent pointers from the initial object.	parentBlock	&lt;BlockClosure&gt;	A block which, given an object, returns a parent of that object in the hierarchy, or nil if the object has no parent or the parent could not be determined.	childrenBlock	&lt;BlockClosure&gt;	A block which, given an object, returns a collection of children of that object in the hierarchy. If the object has no children, either an empty collection or a nil are acceptable.</body></comment><class><name>TextEditorInspector</name><environment>Tools.Trippy</environment><super>Tools.Trippy.Inspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars>textHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.TextEditorInspector</class-id><body>The inspector for Text and String subclasses, with a single text editor window. Accepted text is coerced to the original class of the inspected object and then becomes the inspected object.Instance Variables:	textHolder	&lt;ValueHolder with: String&gt;	The model for the text editor</body></comment><class><name>Collaborator</name><environment>Tools.Trippy</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label object objectBlock varName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.Collaborator</class-id><body>A sequence of Collaborators can be returned by any object in response to the #inspectorCollaborators message. It lists objects that are likely to be interesting to the user inspecting the receiver.  For example, a View might return its Model and Controller as collaborators. Collaborators are added to the "Go" menu of the inspector.Instance Variables:	label	&lt;String | UserMessage&gt;	Description of the collaborator, used in the UI--for example, as a menu item label.	object	&lt;Object | nil&gt;	The collaborator object, if not determined dynamically by 'objectBlock'.	objectBlock	&lt;BlockClosure | nil&gt;	The block returning the collaborator object when evaluated. If nil, the collaborator is assigned statically and stored in the 'object' variable.	varName	&lt;String | nil&gt;	If the collaborator is stored in one of the instance variables of the receiver, this holds the name of the variable to help the inspector better keep track of where we are.</body></comment><class><name>DragController</name><environment>Tools.Trippy</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>page view viewState </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.DragController</class-id><body>Drag controllers are things attached to inspector pages to take care of drag-and-drop related operations. This way drag and drop behaviour is pluggable and is not tied to the page inheritance hierarchy structure. This is an abstract superclass of a group of actual drag controllers.In the idea world this things would not be necessary and list views and other widgets could control drag and drop in a flexibly enough way.Subclasses must implement the following messages:	private		doDrop:		showDropFeedbackFor:Instance Variables:	page	&lt;InspectorPage&gt;  The page for which drag and drop is controlled.	view	&lt;SelectionView&gt;  The list view on the page where the drag/drop is happening.	viewState	&lt;Object&gt;  Just anything a controller needs to store to save the state of the view before we started providing visual drag-and-drop feedback in it.</body></comment><class><name>InsertReplaceDragController</name><environment>Tools.Trippy</environment><super>Tools.Trippy.DragController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.InsertReplaceDragController</class-id><body>InsertReplaceDragController implements drag policy for the lists where it makes sense to both drop objects on top of elements and between elements.</body></comment><class><name>ReplaceOnlyDragController</name><environment>Tools.Trippy</environment><super>Tools.Trippy.DragController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.ReplaceOnlyDragController</class-id><body>This is a drag-and-drop controller for inspectors that support dropping things on top of part but not inserting new things between parts. For example, a basic inspector.</body></comment><class><name>BehaviorInspector</name><environment>Tools.Trippy</environment><super>Tools.Trippy.Inspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars>textHolder sideHolder protocolListHolder methodListHolder inheritanceStop </inst-vars><class-inst-vars></class-inst-vars><imports>			Refactory.Browser.SelectorProtocolNavigatorPart			Refactory.Browser.ProtocolItemNavigatorPart			</imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.BehaviorInspector</class-id><body>This is an unusual inspector, which is actually a browser on the class of the inspected object. It is here both as an example of a custom Inspector pluggable into the framework, and as a stand-in for an embedded browser until we have a browser that can actually be reused inside other interfaces.There is an important difference between how this inspector treats classes vs other objects.  For non-class objects, the inspector shows instance-side and class-side methods. Instance methods are initially displayed, and "self" is bound to the inspected object if the instance/class switch is on the instance side, and to the class of the inspected object if the switch is on the class side.For class objects, the inspector preserves the typical browser perspective.  That is, the straighforward approach would place methods for messages that can be sent to the inspected object (a class) on the instance side, and methods for messages that can be sent to the class of the object (a metaclass) on the class side. This would be confusing because methods visible in that case on the instance side would be the methods we see in regular browsers on the class side.  For example, if we inspected "Model", the inspector would show methods of the Model class on the instance side and instance methods of Metaclass on the class side.  Instead, the inspector retains the browser perspective and shows instance and class methods of the Model class, with class side pre-selected. "self" in that case is bound to the inspected object (a class) if the class swith is selected, and to nil if the instance side is selected.</body></comment><class><name>RemovalUndo</name><environment>Tools.Trippy</environment><super>Tools.Trippy.UndoAction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.RemovalUndo</class-id><body>This action undoes removal of object parts. It remembers the removed parts and inserts them back if applied.</body></comment><class><name>NullNavigator</name><environment>Tools.Trippy</environment><super>Tools.Trippy.Navigator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.NullNavigator</class-id><body>This is a navigator focused on a single object and not actually providing any navigation options. It does take care of view switches. Or in other words, it as a couch potato with a remote control.  This is what sits between an inspector shell and an inspector when the "Explore" menu is set to "Off".</body></comment><class><name>Clipboard</name><environment>Tools.Trippy</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parts values zeroStandIn </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.Clipboard</class-id><body>Clipboard implements a clipboard that can hold collections of objects copied from inspector pages. Objects are associated with their keys so they can be properly inserted when pasted as a group into another object. The clipboard normally holds onto the objects weakly so they can "fall off" the clipboard if nothing else holds onto them. However, it is possible to "lock" the clipboard so it creates an additional set of strong links to its contents.Instance Variables:	parts	&lt;OrderedCollection of: Part&gt;  Collection of the most recently pasted parts.	values	&lt;WeakArray of: Object&gt;  Values of the most recently pasted parts (since parts normally fetch values from their objects, captured values have to be stored separately).	zeroStandIn	&lt;Object&gt;  A unique object that replaces zeros when they are pasted , to distinguish "real" pasted zeros from those that result from objects getting GCed.Shared Variables:	Default	&lt;Clipboard&gt;  The clipboard instance shared by all inspectors.</body></comment><class><name>PartListAbstractInspector</name><environment>Tools.Trippy</environment><super>Tools.Trippy.Inspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars>driver segmentListHolder fieldListHolder textHolder dragController undoHistory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.PartListAbstractInspector</class-id><body>A part list inspector presents an object as a collection of parts, one or more of them selectable at a time. As the number of parts can be very large, an inspector can support two interface styles. One has a single list of parts, the other uses two lists to break parts into smaller selectable segments. The behavior that depends on the type of the currently attached interface is outsourced to a separate object called a 'driver'. The driver for a single-list interface is an instance of PageDriver; the driver for a two-list interface is a SegmentedPageDriver. A driver may register itself as a dependent of some aspects of its inspector.This is an abstract class that implements some behavior reusable by subclasses and leaves parts of it up to subclasses to implement.  An object is treated as a sequence of parts.  A part is an instance of a subclass of Part. An inspector is responsible for generating the list of parts of the object it is open on. Becase the list can potentially be very long, the protocol for decomposing the object includes three messages that together don't require the complete list to be built.  The methods are in the 'decomposing' protocol:	partCount	partAt: anInteger	partsAtAll: integerCollectionIndividual parts are responsible for retrieving their values from the object, formatting values for display, etc.The following messages are used to determined whether and what parts are currently selected in the part list.	hasSingleSelection -- True if exactly one part is selected.	hasMultiSelection -- True if more than one part is selected.	hasSelection -- True if at least one part is selected = hasSingleSelection OR hasMultiSelection.	selections -- Answer a sequence of selected parts, potentially empty.	selection -- If a single part is selected, answer it. Fail otherwise.These messages are used to change the selection:	select: aPart	selectAll: partCollection</body></comment><class><name>DictionaryInspector</name><environment>Tools.Trippy</environment><super>Tools.Trippy.PartListAbstractInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars>linearizedParts valueOrKeyHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.DictionaryInspector</class-id><body>An inspector for objects that support the following interface:	size -- Answering the number of elements the object contains.	keys -- Answering a collection of &lt;size&gt; elements.	at: -- Taking one of the elements of &lt;keys&gt; collection and returning an object.	at:put: -- Taking one of the elements of &lt;keys&gt; collection and any object.Typical clients are Dictionaries and KeyedCollections.Instance Variables:	linearizedParts	&lt;Array of: KeyedElement&gt;	Parts representing the key-value pairs of the object, arranged in the keys' displayString lexicographic order.	valueOrKeyHolder	&lt;ValueHolder with: &lt;#key | #value&gt;&gt;	Whether the inspector should display the value or the key of the selected element.</body></comment><class><name>PoolDictionaryInspector</name><environment>Tools.Trippy</environment><super>Tools.Trippy.DictionaryInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.PoolDictionaryInspector</class-id><body>This is essentially a dictionary inspector with NameSpace-specific menu actions like 'browse references'.</body></comment><class><name>SetInspector</name><environment>Tools.Trippy</environment><super>Tools.Trippy.PartListAbstractInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars>linearized </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.SetInspector</class-id><body>An inspector for objects supporting the set interface, that is messages	size	collect:	remove:	add:Instance Variables:	linearized	&lt;Array of: SetElements&gt;	Elements of the set, arranged in their displayStrings' increasing lexicographic order.</body></comment><class><name>BasicInspector</name><environment>Tools.Trippy</environment><super>Tools.Trippy.PartListAbstractInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fixedFields </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.BasicInspector</class-id><body>An inspector showing an object's instance variables, named and indexed. And object can add "extra attributes" to the list, such as 'source' and 'bytecode' of CompiledCode or 'comment' of a class.Instance Variables:	fixedFields	&lt;Array of: Part&gt;	Parts representing extra attributes and named instance variables. Parts for indexed variables are cheap to create and therefore created on demand.</body></comment><class><name>PreviewingInspector</name><environment>Tools.Trippy</environment><super>Tools.Trippy.BasicInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.PreviewingInspector</class-id><body>This inspector page can present any object that understands #displayOn: and #preferredBounds messages. The inspector page includes a preview area showing the object.</body></comment><class><name>InstVarRemovalUndo</name><environment>Tools.Trippy</environment><super>Tools.Trippy.RemovalUndo</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definingClasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.InstVarRemovalUndo</class-id><body>This removal undo action remember defining classes of instance variables removed from an instance, so they can be put back into the right places.Instance Variables:	definingClasses	&lt;Array of: Class&gt;	An array "parallel" to the part collection stored by the superclass, remembering the defining class of a respective part in the part array.</body></comment><class><name>SequenceInspector</name><environment>Tools.Trippy</environment><super>Tools.Trippy.PartListAbstractInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.SequenceInspector</class-id><body>An inspector for collections that support the resizeable sequence interface:	size -- Answers the number of element in the sequence. The order of elements is preserved.	at: -- Takes an Integer in the 1..&lt;size&gt; range and answers an element at that position.	at:put: -- Takes an Integer in the 1..&lt;size&gt; range and an object and places the object at that position.	add: -- Appends the argument object at the end, increasing the size by one.	add:beforeIndex: -- Inserts the argument object at the specified position so that all other objects are "pushed back" in the collection.	removeAtIndex: -- Removes the element at the specified index, reducing the collection size by one.</body></comment><class><name>ArrayInspector</name><environment>Tools.Trippy</environment><super>Tools.Trippy.SequenceInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.ArrayInspector</class-id><body>An inspector for unresizeable sequences, that is collections that allow all messages listed in the SequenceInspector's comment except:	add:	add:beforeIndex:	removeAtIndex:The inspector "cheats" to make these unresizeable sequences appear resizeable.</body></comment><class><name>InspectorShell</name><environment>Tools.Trippy</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>origin trail current installedNavigator menuBarHolder evaluationPaneVisible textHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.InspectorShell</class-id><body>This is the top-level window of the inspector. Beneath the surface, an inspector is composed of three collaborating applications: 1) A Shell, an instance of InspectorShell, provides the top-level interface elements such as the menu bar and the tool bar, and also represents the object exploration session by keeping track of the history of object visits. 2) A Navigator is a subapplication of the shell which defines the current navigation context--that is, objects we can easily choose for inspection.  It also manages the possible inspectors that can be used for a given object 3) An Inspector is a subapplication of Navigator which takes care of showing the details of a particular *single* object, in a particular way.For example, imagine we looks at a hierarchy of visual parts making up a window.  In this case, the top-level InspectorShell contains a HierarchyNavigator that shows all the members of a hierarchy. When a member is selected, the navigator updates the tab control to list all the inspectors (subclasses of Inspector, to be precise) that can be used to display the selected member. When an inspector class is selected, the navigators creates an instance of the selected class and installs it as the current Inspector.Instance Variables:	origin	&lt;Visit&gt;	The root of the object visit tree for this inspector session. In other words, this is the visit of the object this inspector has been opened on first.	trail		&lt;OrderedCollection of: Navigator&gt;	The navigators we go through with Back/Forward buttons.	current	&lt;Integer&gt; The index of the current visit of the trail.	installedNavigator	&lt;Navigator&gt; The navigator currently used.	menuBarHolder	&lt;ValueHolder with: Menu&gt;  The model of the menu bar of the inspector window.	evaluationPaneVisible	&lt;Boolean&gt;  Whether the evaluation pane is currently visible; affects widget layout.	textHolder	&lt;ValueHolder with: Text&gt;  Evaluation pane's modelShared Variables:	SharedTextHolder	&lt;ValueHolder with: Text&gt;  The holder on text that all evaluation panes share as their model so the code may be persistent within the image.</body></comment><class><name>ReplacementUndo</name><environment>Tools.Trippy</environment><super>Tools.Trippy.UndoAction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.ReplacementUndo</class-id><body>This action undoes assignment of new values to parts. It remembers the parts assigned to and their old values and restores them if applied.</body></comment><class><name>IndexedVariable</name><environment>Tools.Trippy</environment><super>Tools.Trippy.Part</super><private>false</private><indexed-type>none</indexed-type><inst-vars>index </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><comment><class-id>Tools.Trippy.IndexedVariable</class-id><body>This part represents a part of an object that can be accessed by sending the object #basicAt: and #basicAt:put: messages.Instance Variables:	index	&lt;Integer&gt;	The part index</body></comment><shared-variable><name>UseSimpleInspector</name><environment>Tools.Trippy.Inspector</environment><private>false</private><constant>false</constant><category>preferences</category><initializer>false</initializer><attributes><package>Tools-Trippy</package></attributes></shared-variable><shared-variable><name>MaxSelectorSubMenuEntries</name><environment>Tools.Trippy.BehaviorInspector</environment><private>false</private><constant>false</constant><category>Menus</category><initializer>20</initializer><attributes><package>Tools-Trippy</package></attributes></shared-variable><shared-variable><name>MaxMenuEntryWidth</name><environment>Tools.Trippy.BehaviorInspector</environment><private>false</private><constant>false</constant><category>Menus</category><initializer>60</initializer><attributes><package>Tools-Trippy</package></attributes></shared-variable><shared-variable><name>Default</name><environment>Tools.Trippy.Clipboard</environment><private>false</private><constant>false</constant><category>singleton</category><initializer>nil</initializer><attributes><package>Tools-Trippy</package></attributes></shared-variable><shared-variable><name>EvaluationPaneWasLastShown</name><environment>Tools.Trippy.InspectorShell</environment><private>false</private><constant>false</constant><category>evaluation</category><initializer>false</initializer><attributes><package>Tools-Trippy</package></attributes></shared-variable><shared-variable><name>SharedTextHolder</name><environment>Tools.Trippy.InspectorShell</environment><private>false</private><constant>false</constant><category>evaluation</category><initializer>String new asValue</initializer><attributes><package>Tools-Trippy</package></attributes></shared-variable><shared-variable><name>PageSize</name><environment>Tools.Trippy</environment><private>false</private><constant>false</constant><category>Defaults</category><initializer>200</initializer><attributes><package>Tools-Trippy</package></attributes></shared-variable><methods><class-id>Tools.Trippy.PageDriver</class-id> <category>notifications</category><body package="Tools-Trippy" selector="fieldSelectionChanged">fieldSelectionChanged	page textHolder value: page computeText</body></methods><methods><class-id>Tools.Trippy.PageDriver</class-id> <category>private</category><body package="Tools-Trippy" selector="hookup">hookup	page fieldListHolder selectionIndexHolder		onChangeSend: #fieldSelectionChanged to: self</body></methods><methods><class-id>Tools.Trippy.PageDriver</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="initializePage:">initializePage: anInspectorPage	page := anInspectorPage.	self hookup</body></methods><methods><class-id>Tools.Trippy.PageDriver</class-id> <category>accessing</category><body package="Tools-Trippy" selector="refresh">refresh	page fieldListHolder		list: (page partsAtAll: (1 to: page partCount)) asList</body></methods><methods><class-id>Tools.Trippy.PageDriver class</class-id> <category>instance creation</category><body package="Tools-Trippy" selector="for:">for: anInspectorPage	^self new initializePage: anInspectorPage</body></methods><methods><class-id>Tools.Trippy.ObjectSegment</class-id> <category>comparing</category><body package="Tools-Trippy" selector="&lt;">&lt; another	^firstIndex &lt; another firstIndex</body><body package="Tools-Trippy" selector="=">= another	^firstIndex = another firstIndex</body><body package="Tools-Trippy" selector="hash">hash	^firstIndex hash</body></methods><methods><class-id>Tools.Trippy.ObjectSegment</class-id> <category>accessing</category><body package="Tools-Trippy" selector="firstIndex">firstIndex	^firstIndex</body><body package="Tools-Trippy" selector="lastIndex">lastIndex	^lastIndex</body><body package="Tools-Trippy" selector="range">range	^self firstIndex to: self lastIndex</body></methods><methods><class-id>Tools.Trippy.ObjectSegment</class-id> <category>displaying</category><body package="Tools-Trippy" selector="displayString">displayString	^(Inspector safeDisplayStringOf: firstPart)		, ' ... '		, (Inspector safeDisplayStringOf: lastPart)</body></methods><methods><class-id>Tools.Trippy.ObjectSegment</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="from:part:to:part:">from: anInteger part: aPart to: anotherInteger part: anotherPart	firstIndex := anInteger.	firstPart := aPart.	lastIndex := anotherInteger.	lastPart := anotherPart</body></methods><methods><class-id>Tools.Trippy.SegmentedPageDriver</class-id> <category>private</category><body package="Tools-Trippy" selector="computeFieldList">computeFieldList	| segments fields |	segments := page segmentListHolder selections asSortedCollection.	segments isEmpty ifTrue: [^Array new].	fields := OrderedCollection new: segmentSize * segments size.	segments do: [:each |		fields addAll: (page partsAtAll: each range)].	^fields asList</body><body package="Tools-Trippy" selector="computeSegmentList">computeSegmentList	"Answer a sequence consisting of everything to show in the segement list."	| segments totalSize |	segments := OrderedCollection new.	totalSize := page partCount.	1 to: totalSize by: segmentSize do:		[:base |		| end |		end := base + segmentSize - 1 min: totalSize.		segments add: (ObjectSegment new			from: base			part: (page partAt: base)			to: end			part: (page partAt: end))].	^segments</body><body package="Tools-Trippy" selector="hookup">hookup	super hookup.	page segmentListHolder selectionIndexHolder		onChangeSend: #segmentSelectionChanged to: self</body></methods><methods><class-id>Tools.Trippy.SegmentedPageDriver</class-id> <category>accessing</category><body package="Tools-Trippy" selector="refresh">refresh	page segmentListHolder		list: self computeSegmentList;		selectionIndexes: (Set with: 1)</body></methods><methods><class-id>Tools.Trippy.SegmentedPageDriver</class-id> <category>notifications</category><body package="Tools-Trippy" selector="segmentSelectionChanged">segmentSelectionChanged	page fieldListHolder list: self computeFieldList</body></methods><methods><class-id>Tools.Trippy.SegmentedPageDriver</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="initializePage:">initializePage: anInspectorPage	"Pick a reasonable segment size. The reasonable size is typically the default page limit size. However, for a very large object this may lead to the list of segments that is too long. In that case, we pick something that will lead lists of about the same length."	| defaultSize |	defaultSize := PartListAbstractInspector pageSizeLimit.	segmentSize := anInspectorPage partCount // defaultSize &gt; defaultSize		ifTrue: [anInspectorPage partCount sqrtRounded // defaultSize * defaultSize]		ifFalse: [defaultSize].	super initializePage: anInspectorPage</body></methods><methods><class-id>Tools.Trippy.VisualComponentProxy</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="actualComponent:">actualComponent: aVisualComponent	actualComponent := aVisualComponent</body></methods><methods><class-id>Tools.Trippy.VisualComponentProxy</class-id> <category>proxying</category><body package="Tools-Trippy" selector="displayOn:">displayOn: aGraphicsContext	^[actualComponent displayOn: aGraphicsContext]		on: Error		do: [:ex |			aGraphicsContext displayString: (#ErrorDisplayingTheObject &lt;&lt; #dialogs &gt;&gt; 'Error displaying the object') asString at: 40@40.			ex return]</body><body package="Tools-Trippy" selector="preferredBounds">preferredBounds	^[actualComponent preferredBounds]		on: Error		do: [:ex | ex return: (0@0 extent: 0@0)]</body></methods><methods><class-id>Tools.Trippy.VisualComponentProxy class</class-id> <category>instance creation</category><body package="Tools-Trippy" selector="on:">on: aVisualComponent	^self new actualComponent: aVisualComponent</body></methods><methods><class-id>Tools.Trippy.Navigator</class-id> <category>accessing</category><body package="Tools-Trippy" selector="inspector">inspector	^inspector</body><body package="Tools-Trippy" selector="inspector:">inspector: anInspector	inspector := anInspector</body><body package="Tools-Trippy" selector="object">object	^visit object</body><body package="Tools-Trippy" selector="vicinity">vicinity	"Identify the group of objects the navigator presents.	This is used by things like the menu code to indicate the current vicinity."	self subclassResponsibility</body><body package="Tools-Trippy" selector="visit">visit	^visit</body></methods><methods><class-id>Tools.Trippy.Navigator</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="initialize:shell:inspector:">initialize: aVisit shell: aShell inspector: anInspector	visit := aVisit.	shell := aShell.	inspector := anInspector.	inspector container: self.	self inspectorHolder selectionIndexHolder		onChangeSend: #inspectorSelectionChanged		to: self.	self refreshInspectorClasses</body><body package="Tools-Trippy" selector="installedWith:">installedWith: aBuilder</body></methods><methods><class-id>Tools.Trippy.Navigator</class-id> <category>aspects</category><body package="Tools-Trippy" selector="inspectorHolder">inspectorHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^inspectorHolder isNil		ifTrue:			[inspectorHolder := SelectionInList new]		ifFalse:			[inspectorHolder]</body></methods><methods><class-id>Tools.Trippy.Navigator</class-id> <category>private</category><body package="Tools-Trippy" selector="ignoringInspectorSelectionChange:">ignoringInspectorSelectionChange: aBlock	| channel |	channel := self inspectorHolder selectionIndexHolder.	channel retractInterestsFor: self.	aBlock ensure: 		[channel onChangeSend: #inspectorSelectionChanged to: self]</body><body package="Tools-Trippy" selector="objectInspectorClasses">objectInspectorClasses	^self object inspectorClasses copyWith: BehaviorInspector</body><body package="Tools-Trippy" selector="refreshInspectorClasses">refreshInspectorClasses	| selectionIndex |	self ignoringInspectorSelectionChange:		[inspectorClasses := self objectInspectorClasses.		self inspectorHolder list: 			(inspectorClasses collect: [:each | each tabLabel asString copyWithout: $&amp;]) asList.		selectionIndex := inspectorClasses indexOf: inspector class.		self inspectorHolder selectionIndex: selectionIndex.		inspectorCache := Array new: inspectorClasses size.		inspectorCache at: selectionIndex put: inspector]</body><body package="Tools-Trippy" selector="reinstallInspector">reinstallInspector	| newBuilder tabControl |	inspector builder: nil.	tabControl := (builder componentAt: #inspector) widget.	tabControl		client: inspector		spec: inspector specName		builder: (newBuilder := builder newSubBuilder).	inspector installedWith: newBuilder</body><body package="Tools-Trippy" selector="replaceInspectorWithOneOn:">replaceInspectorWithOneOn: anObject	| newClass newInspector index |	inspectorClasses := self objectInspectorClasses.	newClass := (inspectorClasses includes: inspector class)		ifTrue: [inspector class]		ifFalse: [inspectorClasses first].	newInspector := newClass on: anObject.	inspector copyStateTo: newInspector.	inspector := newInspector.	builder notNil ifTrue: [self reinstallInspector].	shell focusObjectChanged.	self ignoringInspectorSelectionChange:		[self inspectorHolder list: 			(inspectorClasses collect: [:each | each tabLabel asString copyWithout: $&amp;]).		inspectorCache := Array new: inspectorClasses size.		index := inspectorClasses indexOf: inspector class.		self inspectorHolder selectionIndex: index.		inspectorCache at: index put: inspector]</body></methods><methods><class-id>Tools.Trippy.Navigator</class-id> <category>inspector container</category><body package="Tools-Trippy" selector="back">back	"Sent by the contained inspector to go back in the visit trail."	^shell back</body><body package="Tools-Trippy" selector="canGoBack">canGoBack	"Sent by the contained inspector to see if it's possible to go back in the visit trail."	^shell canGoBack</body><body package="Tools-Trippy" selector="diveInto:">diveInto: aPart	"Sent by the contained inspector to dive into its part."	^shell diveInto: aPart</body><body package="Tools-Trippy" selector="partValueChanged:">partValueChanged: aPart	^shell partValueChanged: aPart</body></methods><methods><class-id>Tools.Trippy.Navigator</class-id> <category>notifications</category><body package="Tools-Trippy" selector="changeRequest">changeRequest	^self inspector changeRequest</body><body package="Tools-Trippy" selector="inspectorSelectionChanged">inspectorSelectionChanged	| index newBuilder |	index := self inspectorHolder selectionIndex.	inspector := (inspectorCache at: index) isNil		ifTrue: 			[inspectorCache				at: index				put: ((inspectorClasses at: index) on: self object)]		ifFalse: 			[inspectorCache at: index].	inspector builder: nil.	(builder componentAt: #inspector) widget		client: inspector		spec: inspector specName		builder: (newBuilder := builder newSubBuilder).	inspector installedWith: newBuilder.	shell focusObjectChanged "it didn't but the UI update may be needed anyway"</body></methods><methods><class-id>Tools.Trippy.Navigator</class-id> <category>privileged</category><body package="Tools-Trippy" selector="doWithOwnersToIgnore:">doWithOwnersToIgnore: aBlock	"See the comment to Inspector&gt;&gt;doWithOwnersToIgnore: for a detailed explanation.	Passing the buck to the real top component."	shell doWithOwnersToIgnore: aBlock</body><body package="Tools-Trippy" selector="enumerateOwnersToIgnore:">enumerateOwnersToIgnore: aBlock	aBlock value: self.	aBlock value: visit.	inspector enumerateOwnersToIgnore: aBlock</body></methods><methods><class-id>Tools.Trippy.Navigator class</class-id> <category>instance creation</category><body package="Tools-Trippy" selector="visit:shell:">visit: aVisit shell: aShell	^self new		initialize: aVisit		shell: aShell		inspector: (aVisit object inspectorClasses first on: aVisit object)</body><body package="Tools-Trippy" selector="visit:shell:inspector:">visit: aVisit shell: aShell inspector: anInspector	^self new initialize: aVisit shell: aShell inspector: anInspector</body></methods><methods><class-id>Tools.Trippy.OwnerNavigator</class-id> <category>aspects</category><body package="Tools-Trippy" selector="fieldListHolder">fieldListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^fieldListHolder isNil		ifTrue:			[fieldListHolder := SelectionInList new]		ifFalse:			[fieldListHolder]</body></methods><methods><class-id>Tools.Trippy.OwnerNavigator</class-id> <category>accessing</category><body package="Tools-Trippy" selector="vicinity">vicinity	^vicinity</body></methods><methods><class-id>Tools.Trippy.OwnerNavigator</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="bePartsNavigator">bePartsNavigator	vicinity := #self</body><body package="Tools-Trippy" selector="initialize:shell:inspector:">initialize: aVisit shell: aShell inspector: anInspector	super initialize: aVisit shell: aShell inspector: anInspector.	vicinity := #owner.	ownerInspector := aVisit ownerInspector.	self fieldListHolder list: ownerInspector fieldListHolder list.	self fieldListHolder selectionIndexHolder		onChangeSend: #fieldSelected		to: self.	self fieldListHolder selection: aVisit ownerPart</body><body package="Tools-Trippy" selector="installedWith:">installedWith: aBuilder	(aBuilder componentAt: #fieldList) widget		makeVisible: self fieldListHolder selectionIndex</body><body package="Tools-Trippy" selector="postBuildWith:">postBuildWith: aBuilder	self reinstallInspector</body></methods><methods><class-id>Tools.Trippy.OwnerNavigator</class-id> <category>notification</category><body package="Tools-Trippy" selector="fieldDoubleClicked">fieldDoubleClicked	shell exploreFocus</body><body package="Tools-Trippy" selector="fieldSelected">fieldSelected	| selection newObject |	selection := self fieldListHolder selection.	(selection isNil or: [selection hasValue not]) ifTrue: [^self].	newObject := selection value.	visit := visit owner 		visitOfPart: selection		ifNone: [PartVisit part: selection owner: visit owner inspector: ownerInspector].	self replaceInspectorWithOneOn: newObject.	self refreshInspectorClasses</body></methods><methods><class-id>Tools.Trippy.Inspector</class-id> <category>actions</category><body package="Tools-Trippy" selector="browseClass">browseClass	"Open a browser on the inspector object."	self selectedObjectOrInspectedObject browse</body><body package="Tools-Trippy" selector="changeRequest">changeRequest	"Sent by the container application, just before destroying this inspector	(by switching to another object, closing the window, etc).	Answer a boolean indicating whether it is OK to do so.  Do something	to preserve unsaved changes if there are any."	^true</body><body package="Tools-Trippy" selector="copyStateTo:">copyStateTo: anInspector	"A subclass should implement this by sending an appropriate	#copyStateFrom...: message to the argument inspector."	self subclassResponsibility</body><body package="Tools-Trippy" selector="inspectOwners">inspectOwners	| owners |	owners := self selectedObjectOrInspectedObject allOwnersWeakly: true.	self nukeBogusReferencesIn: owners referentContext: thisContext.	ObjectMemory globalGarbageCollect.	(owners reject: [:each | owners tombstone == each]) inspect</body><body package="Tools-Trippy" selector="inspectReferencePath">inspectReferencePath	"Inspect the shortest path."		#{ReferencePathCollector} ifDefinedDo:		[:collectorClass |		Cursor execute showWhile:			[| collector allPaths |			ObjectMemory globalGarbageCollect.			collector := collectorClass new.			self doWithOwnersToIgnore:				[:junkReference | collector ignore: junkReference].			allPaths := collector allReferencePathsTo: self selectedObjectOrInspectedObject.			allPaths inspect]]</body><body package="Tools-Trippy" selector="selectAll">selectAll	"Subclasses should implement this to select 'all fields', whatever	is their idea of what those fields are."	self subclassResponsibility</body><body package="Tools-Trippy" selector="spawn">spawn	"Spawn another top-level inspector window."	self selectedObjectOrInspectedObject inspect</body></methods><methods><class-id>Tools.Trippy.Inspector</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="container:">container: anApplication	container := anApplication</body><body package="Tools-Trippy" selector="copyStateFromBehavior:">copyStateFromBehavior: anInspector	"An inspector receives this just after it becomes the current, with the one that used	to be the current passed as the argument. This is the chance to copy appropriate	selections, etc. from the old inspector."</body><body package="Tools-Trippy" selector="copyStateFromPartList:">copyStateFromPartList: anInspector	"An inspector receives this just after it becomes the current, with the one that used	to be the current passed as the argument. This is the chance to copy appropriate	selections, etc. from the old inspector."</body><body package="Tools-Trippy" selector="initialize:">initialize: anObject	object := anObject.	self refresh</body><body package="Tools-Trippy" selector="initialize:container:">initialize: anObject container: anApplication	object := anObject.	container := anApplication.	self refresh</body><body package="Tools-Trippy" selector="installedWith:">installedWith: aBuilder	"Sent by the container after installation of the inspector interface is finished. 	This gives a chance to perform actions that depend on bounds of components	being available, most notably #makeVisible:. It is also a very good idea to remember the	builder because in the inspector framework models outlive interfaces and builders	come and go."	self builder: aBuilder</body></methods><methods><class-id>Tools.Trippy.Inspector</class-id> <category>accessing</category><body package="Tools-Trippy" selector="object">object	"Answer the object being inspected."	^object</body><body package="Tools-Trippy" selector="selectedObjectOrInspectedObject">selectedObjectOrInspectedObject	^self object</body><body package="Tools-Trippy" selector="undoExplanation">undoExplanation	"Answer a string with an explanation of the possible undo action,	or an empty string if no explanation is available."	^''</body></methods><methods><class-id>Tools.Trippy.Inspector</class-id> <category>properties</category><body package="Tools-Trippy" selector="specName">specName	"Answer the name of the interface spec to use; some pages select the	interface at runtime based on the properties of the object they inspect."	^#windowSpec</body></methods><methods><class-id>Tools.Trippy.Inspector</class-id> <category>testing</category><body package="Tools-Trippy" selector="canDive">canDive	"A generic page has no idea of a selection that we can dive into."	^false</body><body package="Tools-Trippy" selector="canUndo">canUndo	"Answer whether the current inspector can undo the previous editing action.	A generic page keeps no undo history and cannot undo anything."	^false</body><body package="Tools-Trippy" selector="isPartList">isPartList	"Answer true if the inspector presents a logical view on an object	as a collection of selectable parts. In general, this is not true."	^false</body></methods><methods><class-id>Tools.Trippy.Inspector</class-id> <category>private</category><body package="Tools-Trippy" selector="container">container	"Answer the higher-level application I belong to. It is typically either	a Navigator if I am part of a full-blown inspector, or an InspectorHolder	if I am an inspector embedded inside some other application and focused	on a specific object, with no view switches or navigation possibilities."	^container isNil		ifTrue: [builder window model]		ifFalse: [container]</body><body package="Tools-Trippy" selector="doWithOwnersToIgnore:">doWithOwnersToIgnore: aBlock	"This is the entry point of the mechanism that allows filtering unnecessary objects	for operations like inspecting all owners or finding a reference path. This message	bubbles up to the top component of the inspector--either an InspectorShell or an	InspectorHolder; possible by way of a Navigator. From there, the message	#enumerateOwnersToIgnore: is downcast to all parts of the inspector. That message	is what really does enumerate the junk owners."	self container doWithOwnersToIgnore: aBlock</body><body package="Tools-Trippy" selector="enumerateOwnersToIgnore:">enumerateOwnersToIgnore: aBlock	aBlock value: self</body><body package="Tools-Trippy" selector="makeSelfPerformerOf:">makeSelfPerformerOf: aMenu	"The current menu implementation routes messages generated by	a menu item to the menu item's menu bar performer. It is a complete	brain damage. This utility method hacks the menu so the messages are	routed to this page instead. Ugly but less so than the alternatives."	aMenu menuItems do:		[:each | | itemValue |		itemValue := each value.		itemValue isSymbol ifTrue:			[each value: [self perform: itemValue]]]</body><body package="Tools-Trippy" selector="nukeBogusReferencesIn:referentContext:">nukeBogusReferencesIn: aWeakArray referentContext: aContext	| ignoreThese |	ignoreThese := IdentitySet new: 10.	self doWithOwnersToIgnore: [:each | ignoreThese add: each].	1 to: aWeakArray size do:		[:index | | element |		element := aWeakArray at: index.		((ignoreThese includes: element) or: [element == aContext])			ifTrue: [aWeakArray at: index put: aWeakArray tombstone]]</body><body package="Tools-Trippy" selector="refresh">refresh	"Sent by self after the 'object' instance variable has been changed.	Implementations should update all secondary data structures and	widgets as needed."	self subclassResponsibility</body></methods><methods><class-id>Tools.Trippy.Inspector</class-id> <category>menu management</category><body package="Tools-Trippy" selector="addObject:actionsTo:">addObject: anObject actionsTo: aMenu	"Object actions are actions published by the object using #inspectorActions method."	| actions |	actions := [anObject inspectorActions]		on: Error		do: [:ex | ex return: #()].	actions isEmpty ifTrue: [^self].	aMenu addLine.	actions do:		[:each | | item |		item := MenuItem labeled: each label.		item enablement: each enablement.		item value: [each perform].		aMenu addItem: item]</body><body package="Tools-Trippy" selector="addObjectActionsTo:">addObjectActionsTo: aMenu	"Object actions are actions published by the object using #inspectorActions method."	self addObject: self object actionsTo: aMenu</body><body package="Tools-Trippy" selector="addObjectSubmenuTo:">addObjectSubmenuTo: aMenu 	| objectItem objectSubmenu |	objectItem := MenuItem labeled: (#_Object &lt;&lt; #dialogs &gt;&gt; '&amp;Object').	objectItem nameKey: #objectMenu.	objectSubmenu := self class baseObjectSubmenu.	self		makeSelfPerformerOf: objectSubmenu;		addObjectActionsTo: objectSubmenu.	objectItem submenu: objectSubmenu.	aMenu addItem: objectItem atPosition: 10.001.	(aMenu atNameKey: #objectReferencePath) 		enabled: [#{ReferencePathCollector} isDefined]</body><body package="Tools-Trippy" selector="augmentMenuBar:">augmentMenuBar: aMenu 	"The containter gives us a chance to add things to the	main window menu bar."	self addObjectSubmenuTo: aMenu</body></methods><methods><class-id>Tools.Trippy.Inspector class</class-id> <category>instance creation</category><body package="Tools-Trippy" selector="on:">on: anObject	^self new initialize: anObject</body><body package="Tools-Trippy" selector="on:in:">on: anObject in: anApplication	^self new initialize: anObject container: anApplication</body></methods><methods><class-id>Tools.Trippy.Inspector class</class-id> <category>accessing</category><body package="Tools-Trippy" selector="tabLabel">tabLabel	"Answer a String to use as a tab label of a page containing this inspector."	self subclassResponsibility</body><body package="Tools-Trippy" selector="useSimpleInspector">useSimpleInspector	^UseSimpleInspector</body><body package="Tools-Trippy" selector="useSimpleInspector:">useSimpleInspector: aBoolean	"When set to true, Object&gt;&gt;inspect opens the old (classic) inspector.	The default value is false, to open Trippy."	"self useSimpleInspector: true"	"self useSimpleInspector: false"	UseSimpleInspector := aBoolean</body></methods><methods><class-id>Tools.Trippy.Inspector class</class-id> <category>utilities-opening</category><body package="Tools-Trippy" selector="forEmbeddingOn:">forEmbeddingOn: anObject	"Create and answer a subapplication inspecting the argument as	a standalone (i.e. old-style non-diving or navigating) inspector."	^InspectorHolder withInspectorOn: anObject</body><body package="Tools-Trippy" selector="openOn:">openOn: anObject	"Open a new top-level window to inspect the argument."	^InspectorShell openOn: anObject</body></methods><methods><class-id>Tools.Trippy.Inspector class</class-id> <category>utilities-printing</category><body package="Tools-Trippy" selector="safeBasicPrint:on:">safeBasicPrint: anObject on: aStream	^[anObject basicPrintOn: aStream]		on: Error		do: [:ex |			aStream nextPutAll: ((#ErrorPrintingObject &lt;&lt; #dialogs &gt;&gt; '[Error printing the object: &lt;1s&gt;]')			expandMacrosWith: ex messageText).			ex return]</body><body package="Tools-Trippy" selector="safeBasicPrintStringOf:">safeBasicPrintStringOf: anObject	^[anObject basicPrintString]		on: Error		do: [:ex | ex return: ((#ErrorPrintingObject &lt;&lt; #dialogs &gt;&gt; '[Error printing the object: &lt;1s&gt;]')			expandMacrosWith: ex messageText)]</body><body package="Tools-Trippy" selector="safeDisplayStringOf:">safeDisplayStringOf: anObject	^[anObject displayString]		on: Error		do: [:ex | ex return: ((#ErrorPrintingObject &lt;&lt; #dialogs &gt;&gt; '[Error printing the object: &lt;1s&gt;]')			expandMacrosWith: ex messageText)]</body><body package="Tools-Trippy" selector="safePrint:on:">safePrint: anObject on: aStream	^[anObject printOn: aStream]		on: Error		do: [:ex |			aStream nextPutAll: ((#ErrorPrintingObject &lt;&lt; #dialogs &gt;&gt; '[Error printing the object: &lt;1s&gt;]')			expandMacrosWith: ex messageText).			ex return]</body><body package="Tools-Trippy" selector="safePrintStringOf:">safePrintStringOf: anObject	^[anObject printString]		on: Error		do: [:ex | ex return: ((#ErrorPrintingObject &lt;&lt; #dialogs &gt;&gt; '[Error printing the object: &lt;1s&gt;]')			expandMacrosWith: ex messageText)]</body></methods><methods><class-id>Tools.Trippy.Part</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="object:">object: anObject	object := anObject</body></methods><methods><class-id>Tools.Trippy.Part</class-id> <category>accessing</category><body package="Tools-Trippy" selector="asVariableName">asVariableName	"Answer a string that can be used as a variable name of this part when it is	copied to a context where a variable name is needed; for example,	dropped into a workspace to become a workspace local. By default, the	name is based on the class of the value, for example aString."	| className |	className := self value class name copyWithout: Character space.	^(className first isVowel ifTrue: ['an'] ifFalse: ['a']), className</body><body package="Tools-Trippy" selector="key">key	self subclassResponsibility</body><body package="Tools-Trippy" selector="partName">partName	"Answer a string that identifies the current part in the owner. For example,	for a named variable this would be its name, for an indexed variable its index."	self subclassResponsibility</body><body package="Tools-Trippy" selector="text">text	^Inspector safePrintStringOf: self value</body><body package="Tools-Trippy" selector="value">value	self subclassResponsibility</body></methods><methods><class-id>Tools.Trippy.Part</class-id> <category>testing</category><body package="Tools-Trippy" selector="hasValue">hasValue	"Answer whether this part can meaningfully respond to the #value message	answering an object which is the part's value.  Some parts do not have to	have value and only have #text that they show in the inspector's text view.	For example, a bytecode disassembly of a compiled method is a TextAttribute	that has no value that could be meaningfully copied elsewhere."	^true</body><body package="Tools-Trippy" selector="isNamedVariable">isNamedVariable	^false</body><body package="Tools-Trippy" selector="isProtected">isProtected	"Protected parts are parts assignment to which, even if physically possible	(as reported by #isReadOnly) is potentially dangerous and should be done 	with extreme caution, after explicitly warning the user."	^false</body><body package="Tools-Trippy" selector="isReadOnly">isReadOnly	"Answer whether it is legal to send the #value: message to this part.	Sending #value: to a read-only part may result in an exception."	^false</body><body package="Tools-Trippy" selector="isRemovable">isRemovable	^true</body></methods><methods><class-id>Tools.Trippy.TextAttribute</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="label:text:">label: aString text: aText	label := aString.	text := aText</body><body package="Tools-Trippy" selector="label:textBlock:">label: aString textBlock: aBlock	label := aString.	textBlock := aBlock</body></methods><methods><class-id>Tools.Trippy.TextAttribute</class-id> <category>accessing</category><body package="Tools-Trippy" selector="asVariableName">asVariableName	^label</body><body package="Tools-Trippy" selector="displayString">displayString	^'-', label asString</body><body package="Tools-Trippy" selector="key">key	^label</body><body package="Tools-Trippy" selector="label">label	^label</body><body package="Tools-Trippy" selector="partName">partName	^label asString</body><body package="Tools-Trippy" selector="text">text	^textBlock isNil		ifTrue: [text]		ifFalse: 			[[textBlock value]				on: Error				do: [:ex | ((#ErrorRetrievingTextC1s &lt;&lt; #dialogs &gt;&gt; '[Error retrieving text: &lt;1s&gt;]')					expandMacrosWith: ex messageText)]]</body><body package="Tools-Trippy" selector="value">value	^self text</body></methods><methods><class-id>Tools.Trippy.TextAttribute</class-id> <category>comparing</category><body package="Tools-Trippy" selector="=">= anObject	^anObject class = self class and: [label = anObject label]</body><body package="Tools-Trippy" selector="hash">hash	^label hash</body></methods><methods><class-id>Tools.Trippy.TextAttribute</class-id> <category>testing</category><body package="Tools-Trippy" selector="hasValue">hasValue	^true</body><body package="Tools-Trippy" selector="isReadOnly">isReadOnly	^true</body><body package="Tools-Trippy" selector="isRemovable">isRemovable	^false</body></methods><methods><class-id>Tools.Trippy.TextAttribute class</class-id> <category>instance creation</category><body package="Tools-Trippy" selector="label:text:">label: aString text: aText	^self new label: aString text: aText</body><body package="Tools-Trippy" selector="label:textBlock:">label: aString textBlock: aBlock	^self new label: aString textBlock: aBlock</body></methods><methods><class-id>Tools.Trippy.PartSnapshot</class-id> <category>accessing</category><body package="Tools-Trippy" selector="asVariableName">asVariableName	^part asVariableName</body><body package="Tools-Trippy" selector="displayString">displayString	^part displayString</body><body package="Tools-Trippy" selector="key">key	^part key</body><body package="Tools-Trippy" selector="part">part	^part</body><body package="Tools-Trippy" selector="partName">partName	^part partName</body><body package="Tools-Trippy" selector="restore">restore	part value: value</body><body package="Tools-Trippy" selector="text">text	^part text</body><body package="Tools-Trippy" selector="value">value	^value</body></methods><methods><class-id>Tools.Trippy.PartSnapshot</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="initialize:">initialize: aPart	part := aPart.	value := aPart value</body><body package="Tools-Trippy" selector="part:value:">part: aPart value: anObject	part := aPart.	value := anObject</body></methods><methods><class-id>Tools.Trippy.PartSnapshot class</class-id> <category>instance creation</category><body package="Tools-Trippy" selector="on:">on: aPart	^self new initialize: aPart</body></methods><methods><class-id>Tools.Trippy.DerivedAttribute</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="initialize:value:">initialize: aString value: anObject	label := aString.	value := anObject</body><body package="Tools-Trippy" selector="initialize:valueBlock:">initialize: aString valueBlock: aBlock	label := aString.	valueBlock := aBlock</body></methods><methods><class-id>Tools.Trippy.DerivedAttribute</class-id> <category>accessing</category><body package="Tools-Trippy" selector="asVariableName">asVariableName	^label</body><body package="Tools-Trippy" selector="displayString">displayString	^'-', label asString</body><body package="Tools-Trippy" selector="key">key	^label</body><body package="Tools-Trippy" selector="label">label	^label</body><body package="Tools-Trippy" selector="partName">partName	^label asString</body><body package="Tools-Trippy" selector="value">value	^self isComputed		ifTrue: [valueBlock value]		ifFalse: [value]</body><body package="Tools-Trippy" selector="valueIn:">valueIn: anObject	^self value</body><body package="Tools-Trippy" selector="valueIn:put:">valueIn: anObject put: anObject2</body></methods><methods><class-id>Tools.Trippy.DerivedAttribute</class-id> <category>testing</category><body package="Tools-Trippy" selector="isComputed">isComputed	^valueBlock notNil</body><body package="Tools-Trippy" selector="isReadOnly">isReadOnly	^true</body><body package="Tools-Trippy" selector="isRemovable">isRemovable	^false</body></methods><methods><class-id>Tools.Trippy.DerivedAttribute</class-id> <category>comparing</category><body package="Tools-Trippy" selector="=">= anObject	^anObject class = self class and: [label = anObject label]</body><body package="Tools-Trippy" selector="hash">hash	^label hash</body></methods><methods><class-id>Tools.Trippy.DerivedAttribute class</class-id> <category>instance creation</category><body package="Tools-Trippy" selector="label:value:">label: aString value: anObject	^self new initialize: aString value: anObject</body><body package="Tools-Trippy" selector="label:valueBlock:">label: aString valueBlock: aBlock	^self new initialize: aString valueBlock: aBlock</body></methods><methods><class-id>Tools.Trippy.HierarchyNavigator</class-id> <category>aspects</category><body package="Tools-Trippy" selector="hierarchyHolder">hierarchyHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^hierarchyHolder isNil		ifTrue:			[hierarchyHolder := IndentedTreeSelectionInList new]		ifFalse:			[hierarchyHolder]</body></methods><methods><class-id>Tools.Trippy.HierarchyNavigator</class-id> <category>accessing</category><body package="Tools-Trippy" selector="contractAll">contractAll	self hierarchyHolder		selectionIndex: 1;		deepCloseCurrent;		deepOpenCurrentTo: 1</body><body package="Tools-Trippy" selector="contractBranch">contractBranch	self hierarchyHolder deepCloseCurrent</body><body package="Tools-Trippy" selector="expandAll">expandAll	self hierarchyHolder		selectionIndex: 1;		deepOpenCurrent</body><body package="Tools-Trippy" selector="expandBranch">expandBranch	self hierarchyHolder deepOpenCurrent</body><body package="Tools-Trippy" selector="vicinity">vicinity	^hierarchy id</body></methods><methods><class-id>Tools.Trippy.HierarchyNavigator</class-id> <category>private</category><body package="Tools-Trippy" selector="expandToObject">expandToObject	| path this parent |	path := OrderedCollection new.	this := self object.	[path add: this.	(parent := hierarchy parentOf: this) notNil] 		whileTrue: [this := parent].	path reverse do: [:nextObject | hierarchyHolder open: nextObject]</body><body package="Tools-Trippy" selector="initialHierarchySelection">initialHierarchySelection	^self object</body><body package="Tools-Trippy" selector="nameOf:">nameOf: anObject	| string |	string := Inspector safeDisplayStringOf: anObject.	^anObject == self object		ifTrue: [string asText allBold]		ifFalse: [string]</body></methods><methods><class-id>Tools.Trippy.HierarchyNavigator</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="initialize:hierarchy:shell:inspector:">initialize: aVisit hierarchy: aHierarchy shell: aShell inspector: anInspector	super initialize: aVisit shell: aShell inspector: anInspector.	originalVisit := aVisit.	hierarchy := aHierarchy.	root := aHierarchy rootOf: self object.	hierarchyHolder := IndentedTreeSelectionInList		listObjectHierarchy: #root		childBlock: [:thing | #root == thing			ifTrue: [Array with: root]			ifFalse: [hierarchy childrenOf: thing]]		childNameBlock: [:thing | self nameOf: thing].	hierarchyHolder expandedEmphasis: #().	self expandToObject</body><body package="Tools-Trippy" selector="installedWith:">installedWith: aBuilder	(aBuilder componentAt: #hierarchyList) widget		makeVisible: self hierarchyHolder selectionIndex</body><body package="Tools-Trippy" selector="postBuildWith:">postBuildWith: aBuilder	"Some ugliness was needed to work around a problem with subcanvases being built	inside other subcanvases on postBuildWith: event."	self reinstallInspector.	self hierarchyHolder selection: self initialHierarchySelection.	hierarchyHolder selectionIndexHolder		onChangeSend: #hierarchyElementSelected to: self</body></methods><methods><class-id>Tools.Trippy.HierarchyNavigator</class-id> <category>notification</category><body package="Tools-Trippy" selector="hierarchyDoubleClicked">hierarchyDoubleClicked	shell exploreFocus</body><body package="Tools-Trippy" selector="hierarchyElementSelected">hierarchyElementSelected	"A new member of the hierarchy is selected. Update the subordinate	page to display the newly selected object, if there is indeed an object selected."	| selection |	selection := self hierarchyHolder selection.	selection isNil ifTrue: [^self].	inspector object == selection ifTrue: [^self].	visit := originalVisit object == selection		ifTrue: [originalVisit]		ifFalse: [originalVisit visitOf: selection ifNone:			[Visit object: selection owner: originalVisit]].	self replaceInspectorWithOneOn: self object</body></methods><methods><class-id>Tools.Trippy.HierarchyNavigator class</class-id> <category>instance creation</category><body package="Tools-Trippy" selector="visit:hierarchy:shell:inspector:">visit: aVisit hierarchy: aHierarchy shell: aShell inspector: anInspector	^self new		initialize: aVisit		hierarchy: aHierarchy		shell: aShell		inspector: anInspector</body></methods><methods><class-id>Tools.Trippy.OverriddenMethodDefinition</class-id> <category>printing</category><body package="Tools-Trippy" selector="simpleReverseDisplayString">simpleReverseDisplayString	^super simpleReverseDisplayString asText emphasizeAllWith: #italic</body></methods><methods><class-id>Tools.Trippy.Visit</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="initialize">initialize	children := OrderedCollection new</body><body package="Tools-Trippy" selector="object:owner:">object: anObject owner: aVisitOrNil	object := anObject.	owner := aVisitOrNil.	owner notNil ifTrue: [owner addChild: self]</body></methods><methods><class-id>Tools.Trippy.Visit</class-id> <category>testing</category><body package="Tools-Trippy" selector="hasOwner">hasOwner	^owner notNil</body></methods><methods><class-id>Tools.Trippy.Visit</class-id> <category>accessing</category><body package="Tools-Trippy" selector="addChild:">addChild: aVisit	children add: aVisit</body><body package="Tools-Trippy" selector="children">children	^children</body><body package="Tools-Trippy" selector="forgetVisitOf:">forgetVisitOf: anObject	children remove: (self visitOf: anObject ifNone: [^self])</body><body package="Tools-Trippy" selector="forgetVisitOfPart:">forgetVisitOfPart: aPart	children remove: (self visitOfPart: aPart ifNone: [^self])</body><body package="Tools-Trippy" selector="object">object	^object</body><body package="Tools-Trippy" selector="owner">owner	^owner</body><body package="Tools-Trippy" selector="visitOf:ifNone:">visitOf: anObject ifNone: aBlock	^children detect: [:some | some object == anObject] ifNone: aBlock</body><body package="Tools-Trippy" selector="visitOfPart:ifNone:">visitOfPart: aPart ifNone: aBlock	^children 		detect: [:some | (some respondsTo: #ownerPart) and: [some ownerPart = aPart]] 		ifNone: aBlock</body></methods><methods><class-id>Tools.Trippy.Visit</class-id> <category>printing</category><body package="Tools-Trippy" selector="displayString">displayString	| printString |	printString := Inspector safeBasicPrintStringOf: self object.	^self object isImmutable		ifTrue: [printString, ' (', (#immutable &lt;&lt; #dialogs &gt;&gt; 'immutable') asString, ')']		ifFalse: [printString]</body><body package="Tools-Trippy" selector="printOn:">printOn: aStream	aStream 		nextPut: $&lt;;		print: self class;		nextPutAll: ' object: ';		print: self object;		nextPut: $&gt;</body></methods><methods><class-id>Tools.Trippy.Visit</class-id> <category>privileged</category><body package="Tools-Trippy" selector="enumerateOwnersToIgnore:">enumerateOwnersToIgnore: aBlock	aBlock value: self.	children do: [:each | each enumerateOwnersToIgnore: aBlock]</body></methods><methods><class-id>Tools.Trippy.Visit class</class-id> <category>instance creation</category><body package="Tools-Trippy" selector="new">new	^super new initialize</body><body package="Tools-Trippy" selector="object:">object: anObject	^self new object: anObject owner: nil</body><body package="Tools-Trippy" selector="object:owner:">object: anObject owner: aVisit	^self new		object: anObject owner: aVisit</body></methods><methods><class-id>Tools.Trippy.SetElement</class-id> <category>accessing</category><body package="Tools-Trippy" selector="displayString">displayString	^Inspector safeDisplayStringOf: element</body><body package="Tools-Trippy" selector="element">element	^element</body><body package="Tools-Trippy" selector="key">key	^element</body><body package="Tools-Trippy" selector="partName">partName	^(#element &lt;&lt; #dialogs &gt;&gt; 'element') asString</body><body package="Tools-Trippy" selector="value">value	^element</body><body package="Tools-Trippy" selector="value:">value: anObject	object 		remove: element;		add: anObject.	element := anObject</body></methods><methods><class-id>Tools.Trippy.SetElement</class-id> <category>comparing</category><body package="Tools-Trippy" selector="=">= anObject	^anObject class = self class and: [element = anObject element]</body><body package="Tools-Trippy" selector="hash">hash	^element hash</body></methods><methods><class-id>Tools.Trippy.SetElement</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="element:">element: anObject	element := anObject</body></methods><methods><class-id>Tools.Trippy.SetElement class</class-id> <category>instance creation</category><body package="Tools-Trippy" selector="of:element:">of: aSet element: anObject	^self new		object: aSet;		element: anObject</body></methods><methods><class-id>Tools.Trippy.KeyedElement</class-id> <category>comparing</category><body package="Tools-Trippy" selector="=">= anObject	^self class = anObject class and: [self key = anObject key]</body><body package="Tools-Trippy" selector="hash">hash	^key hash</body></methods><methods><class-id>Tools.Trippy.KeyedElement</class-id> <category>accessing</category><body package="Tools-Trippy" selector="asVariableName">asVariableName	^key isString		ifTrue: [key]		ifFalse: [key isSymbol			ifTrue: [key asString]			ifFalse: [key isInteger				ifTrue: ['at', key printString]				ifFalse: [(Inspector safeDisplayStringOf: key) copyWithout: Character space]]]</body><body package="Tools-Trippy" selector="displayString">displayString	^Inspector safeDisplayStringOf: key</body><body package="Tools-Trippy" selector="key">key	^key</body><body package="Tools-Trippy" selector="partName">partName	^key printString</body><body package="Tools-Trippy" selector="value">value	^object at: key</body><body package="Tools-Trippy" selector="value:">value: anObject	^object at: key put: anObject</body></methods><methods><class-id>Tools.Trippy.KeyedElement</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="key:">key: anObject	key := anObject</body></methods><methods><class-id>Tools.Trippy.KeyedElement class</class-id> <category>instance creation</category><body package="Tools-Trippy" selector="of:at:">of: anObject at: anObject2	^self new		object: anObject;		key: anObject2</body></methods><methods><class-id>Tools.Trippy.Action</class-id> <category>accessing</category><body package="Tools-Trippy" selector="enablement">enablement	^enablementBlock value</body><body package="Tools-Trippy" selector="isEnabled">isEnabled	^enablementBlock value</body><body package="Tools-Trippy" selector="label">label	^label</body><body package="Tools-Trippy" selector="perform">perform	^actionBlock value</body></methods><methods><class-id>Tools.Trippy.Action</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="label:actionBlock:">label: aString actionBlock: aBlock	self label: aString actionBlock: aBlock enablementBlock: [true]</body><body package="Tools-Trippy" selector="label:actionBlock:enablementBlock:">label: aString actionBlock: aBlock enablementBlock: aBlock2	label := aString.	actionBlock := aBlock.	enablementBlock := aBlock2</body></methods><methods><class-id>Tools.Trippy.Action class</class-id> <category>instance creation</category><body package="Tools-Trippy" selector="label:block:">label: aString block: aBlock	^self new label: aString actionBlock: aBlock</body><body package="Tools-Trippy" selector="label:block:enablement:">label: aString block: aBlock enablement: aBlock2	^self new label: aString actionBlock: aBlock enablementBlock: aBlock2</body></methods><methods><class-id>Tools.Trippy.UndoAction</class-id> <category>accessing</category><body package="Tools-Trippy" selector="explanation">explanation	"Answer a string that will be appended to 'Undo' to form a nicer undo menu item label."	self subclassResponsibility</body><body package="Tools-Trippy" selector="parts">parts	^savedValues collect: [:each | each part]</body><body package="Tools-Trippy" selector="savedValues">savedValues	^savedValues</body><body package="Tools-Trippy" selector="undoIn:">undoIn: aPage	self subclassResponsibility</body><body package="Tools-Trippy" selector="values">values	^savedValues collect: [:each | each value]</body></methods><methods><class-id>Tools.Trippy.UndoAction</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="savedValues:">savedValues: partCollection	savedValues := partCollection collect: [:each | PartSnapshot on: each]</body></methods><methods><class-id>Tools.Trippy.InsertionUndo</class-id> <category>accessing</category><body package="Tools-Trippy" selector="explanation">explanation	^(#Addition &lt;&lt; #dialogs &gt;&gt; 'Addition')</body><body package="Tools-Trippy" selector="newKeys">newKeys	^newKeys</body><body package="Tools-Trippy" selector="undoIn:">undoIn: aPage	aPage undoInsertion: self</body></methods><methods><class-id>Tools.Trippy.InsertionUndo</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="newKeys:">newKeys: aCollection	newKeys := aCollection</body></methods><methods><class-id>Tools.Trippy.InspectorHolder</class-id> <category>inspector container</category><body package="Tools-Trippy" selector="back">back	self shouldNotImplement</body><body package="Tools-Trippy" selector="canGoBack">canGoBack	^false</body><body package="Tools-Trippy" selector="diveInto:">diveInto: aPart	aPart value inspect</body><body package="Tools-Trippy" selector="doWithOwnersToIgnore:">doWithOwnersToIgnore: aBlock	"See the comment to Inspector&gt;&gt;doWithOwnersToIgnore: for a detailed explanation.	This class is the top component, therefore here we start trickling down enumerating	junk owners on our way."	self enumerateOwnersToIgnore: aBlock</body><body package="Tools-Trippy" selector="enumerateOwnersToIgnore:">enumerateOwnersToIgnore: aBlock	aBlock		value: self;		value: builder window;		value: builder window component.	inspector enumerateOwnersToIgnore: aBlock</body><body package="Tools-Trippy" selector="inspector">inspector	^inspector</body><body package="Tools-Trippy" selector="partValueChanged:">partValueChanged: aPart	"We don't keep track of any object visits."</body></methods><methods><class-id>Tools.Trippy.InspectorHolder</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="initialize:">initialize: anInspector	inspector := anInspector.	inspector container: self</body><body package="Tools-Trippy" selector="postBuildWith:">postBuildWith: aBuilder	| subBuilder |	(aBuilder componentAt: #inspector) widget		client: inspector		spec: inspector specName		builder: (subBuilder := aBuilder newSubBuilder).	inspector installedWith: subBuilder</body></methods><methods><class-id>Tools.Trippy.InspectorHolder class</class-id> <category>instance creation</category><body package="Tools-Trippy" selector="with:">with: anInspector	^self new initialize: anInspector</body><body package="Tools-Trippy" selector="withInspectorOn:">withInspectorOn: anObject	| inspector |	inspector := anObject inspectorClasses first on: anObject.	^self new initialize: inspector</body></methods><methods><class-id>Tools.Trippy.UndoActionGroup</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="initialize:">initialize: actionCollection	actions := actionCollection</body></methods><methods><class-id>Tools.Trippy.UndoActionGroup</class-id> <category>accessing</category><body package="Tools-Trippy" selector="undoIn:">undoIn: anInspector	actions do: [:each | each undoIn: anInspector]</body></methods><methods><class-id>Tools.Trippy.UndoActionGroup class</class-id> <category>instance creation</category><body package="Tools-Trippy" selector="with:with:">with: action1 with: action2	^self new initialize:		(Array with: action1 with: action2)</body><body package="Tools-Trippy" selector="with:with:with:">with: action1 with: action2 with: action3	^self new initialize:		(Array with: action1 with: action2 with: action3)</body></methods><methods><class-id>Tools.Trippy.VisitTreeNavigator</class-id> <category>accessing</category><body package="Tools-Trippy" selector="object">object	^self visit object</body><body package="Tools-Trippy" selector="vicinity">vicinity	^#visited</body><body package="Tools-Trippy" selector="visit">visit	^self hierarchyHolder selection</body></methods><methods><class-id>Tools.Trippy.VisitTreeNavigator</class-id> <category>notification</category><body package="Tools-Trippy" selector="hierarchyDoubleClicked">hierarchyDoubleClicked	shell revisit: self hierarchyHolder selection</body></methods><methods><class-id>Tools.Trippy.VisitTreeNavigator</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="initialize:shell:initialVisit:inspector:">initialize: aVisit shell: anInspectorShell initialVisit: aVisit2 inspector: anInspector	root := aVisit.	visit := originalVisit := Visit object: aVisit object.	shell := anInspectorShell.	inspector := anInspector.	startingVisit := aVisit2.	hierarchyHolder := IndentedTreeSelectionInList		listObjectHierarchy: #root		childBlock: [:thing | #root == thing			ifTrue: [Array with: root]			ifFalse: [thing children]]		childNameBlock: [:thing | thing displayString].	hierarchyHolder 		expandedEmphasis: #();		selection: startingVisit.	self refreshInspectorClasses</body><body package="Tools-Trippy" selector="postBuildWith:">postBuildWith: aBuilder	self hierarchyHolder		selectionIndex: 1;		deepOpenCurrent.	super postBuildWith: aBuilder.</body></methods><methods><class-id>Tools.Trippy.VisitTreeNavigator</class-id> <category>private</category><body package="Tools-Trippy" selector="initialHierarchySelection">initialHierarchySelection	^startingVisit</body></methods><methods><class-id>Tools.Trippy.NamedVariable</class-id> <category>accessing</category><body package="Tools-Trippy" selector="asVariableName">asVariableName	^name</body><body package="Tools-Trippy" selector="displayString">displayString	^self isProtected		ifTrue: [name, ' #']		ifFalse: [name]</body><body package="Tools-Trippy" selector="key">key	^name</body><body package="Tools-Trippy" selector="name">name	^name</body><body package="Tools-Trippy" selector="partName">partName	^name</body><body package="Tools-Trippy" selector="value">value	^object instVarAt: index</body><body package="Tools-Trippy" selector="value:">value: anObject	^object instVarAt: index put: anObject</body></methods><methods><class-id>Tools.Trippy.NamedVariable</class-id> <category>comparing</category><body package="Tools-Trippy" selector="=">= anObject	^self class = anObject class and: [self name = anObject name]</body><body package="Tools-Trippy" selector="hash">hash	^object hash</body></methods><methods><class-id>Tools.Trippy.NamedVariable</class-id> <category>testing</category><body package="Tools-Trippy" selector="isNamedVariable">isNamedVariable	^true</body><body package="Tools-Trippy" selector="isProtected">isProtected	^protected</body></methods><methods><class-id>Tools.Trippy.NamedVariable</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="beProtected">beProtected	protected := true</body><body package="Tools-Trippy" selector="name:class:">name: aString class: aClass	name := aString.	class := aClass.	protected := false.	index := aClass allInstVarNames indexOf: name.	index isZero ifTrue: [self error: (#variableNotInTheClass &lt;&lt; #dialogs &gt;&gt; 'variable not in the class')]</body><body package="Tools-Trippy" selector="refreshIndex">refreshIndex	index := class allInstVarNames indexOf: name.	index isZero ifTrue: [self error: (#variableNotInTheClass &lt;&lt; #dialogs &gt;&gt; 'variable not in the class')]</body></methods><methods><class-id>Tools.Trippy.NamedVariable class</class-id> <category>instance creation</category><body package="Tools-Trippy" selector="of:named:">of: anObject named: aString	^self new		object: anObject;		name: aString class: anObject class</body></methods><methods><class-id>Tools.Trippy.PartVisit</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="part:inspector:">part: aPart inspector: anInspector	object := aPart.	ownerInspector := anInspector</body></methods><methods><class-id>Tools.Trippy.PartVisit</class-id> <category>accessing</category><body package="Tools-Trippy" selector="object">object	^object value</body><body package="Tools-Trippy" selector="ownerInspector">ownerInspector	^ownerInspector</body><body package="Tools-Trippy" selector="ownerPart">ownerPart	^object</body></methods><methods><class-id>Tools.Trippy.PartVisit</class-id> <category>printing</category><body package="Tools-Trippy" selector="displayString">displayString	| result |	result := WriteStream on: (String new: 20).	self ownerPart notNil ifTrue:		[result nextPutAll: self ownerPart partName.		result nextPutAll: ': '].	Inspector safeBasicPrint: self object on: result.	^result contents</body><body package="Tools-Trippy" selector="printOn:">printOn: aStream	aStream 		nextPut: $&lt;;		print: self class;		nextPutAll: ' object: ';		print: self object;		nextPutAll: ' part: ';		print: self ownerPart;		nextPut: $&gt;</body></methods><methods><class-id>Tools.Trippy.PartVisit</class-id> <category>privileged</category><body package="Tools-Trippy" selector="enumerateOwnersToIgnore:">enumerateOwnersToIgnore: aBlock	super enumerateOwnersToIgnore: aBlock.	ownerInspector enumerateOwnersToIgnore: aBlock</body></methods><methods><class-id>Tools.Trippy.PartVisit class</class-id> <category>instance creation</category><body package="Tools-Trippy" selector="part:owner:inspector:">part: aPart owner: aVisit inspector: anInspector	^self new 		object: nil owner: aVisit;		part: aPart inspector: anInspector;		yourself</body></methods><methods><class-id>Tools.Trippy.Hierarchy</class-id> <category>accessing</category><body package="Tools-Trippy" selector="childrenOf:">childrenOf: anObject	| result |	result := [childrenBlock value: anObject]		on: Error		do: [:ex | ex return].	^result isNil ifTrue: [Array new] ifFalse: [result]</body><body package="Tools-Trippy" selector="id">id	^id</body><body package="Tools-Trippy" selector="label">label	^label</body><body package="Tools-Trippy" selector="parentOf:">parentOf: anObject	^[parentBlock value: anObject]		on: Error		do: [:ex | ex return]</body><body package="Tools-Trippy" selector="root">root	^root</body><body package="Tools-Trippy" selector="rootOf:">rootOf: anObject	| this parent |	self hasRoot ifTrue: [^root].	this := anObject.	[parent := self parentOf: this.	parent notNil] 		whileTrue: [this := parent].	^this</body></methods><methods><class-id>Tools.Trippy.Hierarchy</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="initialize:label:parentBlock:childrenBlock:">initialize: aSymbol label: aString parentBlock: aBlock childrenBlock: aBlock2	id := aSymbol.	label := aString.	parentBlock := aBlock.	childrenBlock := aBlock2</body><body package="Tools-Trippy" selector="initialize:label:root:childrenBlock:">initialize: aSymbol label: aString root: anObject childrenBlock: aBlock	id := aSymbol.	label := aString.	root := anObject.	childrenBlock := aBlock</body></methods><methods><class-id>Tools.Trippy.Hierarchy</class-id> <category>testing</category><body package="Tools-Trippy" selector="hasRoot">hasRoot	^parentBlock isNil</body></methods><methods><class-id>Tools.Trippy.Hierarchy class</class-id> <category>instance creation</category><body package="Tools-Trippy" selector="id:label:parentBlock:childrenBlock:">id: aSymbol label: aString parentBlock: aBlock childrenBlock: aBlock2	^self new initialize: aSymbol label: aString parentBlock: aBlock childrenBlock: aBlock2</body><body package="Tools-Trippy" selector="id:label:root:childrenBlock:">id: aSymbol label: aString root: anObject childrenBlock: aBlock	^self new initialize: aSymbol label: aString root: anObject childrenBlock: aBlock</body></methods><methods><class-id>Tools.Trippy.TextEditorInspector</class-id> <category>actions</category><body package="Tools-Trippy" selector="changeRequest">changeRequest	| choice textEditor |	textEditor := (self builder componentAt: #text) widget controller.	textEditor accepted ifTrue: [^true].	choice := Dialog 		choose: (#AcceptUnsavedChanges &lt;&lt; #dialogs &gt;&gt; 'Accept unsaved changes?')		labels: (Array with: (#Yes &lt;&lt; #dialogs &gt;&gt; 'Yes') with: (#No &lt;&lt; #dialogs &gt;&gt; 'No') with: (#Cancel &lt;&lt; #dialogs &gt;&gt; 'Cancel'))		values: #(yes no cancel)		default: #yes.	choice = #cancel ifTrue: [^false].	choice = #yes ifTrue: [textEditor accept].	^true</body><body package="Tools-Trippy" selector="copyStateTo:">copyStateTo: anInspector	"There is no state to talk of."</body><body package="Tools-Trippy" selector="refresh">refresh	self textHolder value: self object</body><body package="Tools-Trippy" selector="selectAll">selectAll	| editor |	editor := (self builder componentAt: #text) widget controller.	editor selectFrom: 1 to: editor text size</body><body package="Tools-Trippy" selector="textAccepted:">textAccepted: aController	| newObject |	newObject := self coerceText: aController text.	newObject become: self object.	self refresh</body></methods><methods><class-id>Tools.Trippy.TextEditorInspector</class-id> <category>private</category><body package="Tools-Trippy" selector="coerceText:">coerceText: aTextOrString	"Answer the argument as a new instance of a class compatible with that	of the current object. We currently assume that can only be one of String	subclasses or Text."	^(self object isKindOf: Text)		ifTrue: [aTextOrString asText copy]		ifFalse: [self object class fromString: aTextOrString asString]</body><body package="Tools-Trippy" selector="enumerateOwnersToIgnore:">enumerateOwnersToIgnore: aBlock	super enumerateOwnersToIgnore: aBlock.	aBlock value: textHolder</body><body package="Tools-Trippy" selector="nukeBogusReferencesIn:referentContext:">nukeBogusReferencesIn: aWeakArray referentContext: aContext	super nukeBogusReferencesIn: aWeakArray referentContext: aContext.	[(aWeakArray 		indexOf: self textHolder 		replaceWith: aWeakArray tombstone 		startingAt: 1 		stoppingAt: aWeakArray size) = 0] whileFalse</body></methods><methods><class-id>Tools.Trippy.TextEditorInspector</class-id> <category>aspects</category><body package="Tools-Trippy" selector="textHolder">textHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^textHolder isNil		ifTrue:			[textHolder := String new asValue]		ifFalse:			[textHolder]</body></methods><methods><class-id>Tools.Trippy.TextEditorInspector</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="postBuildWith:">postBuildWith: aBuilder	super postBuildWith: aBuilder.	(aBuilder componentAt: #text) widget controller		autoAccept: false</body></methods><methods><class-id>Tools.Trippy.TextEditorInspector class</class-id> <category>accessing</category><body package="Tools-Trippy" selector="tabLabel">tabLabel	^(#Text &lt;&lt; #labels &gt;&gt; 'Text')</body></methods><methods><class-id>Tools.Trippy.Collaborator</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="initialize:object:">initialize: aString object: anObject	label := aString.	object := anObject</body><body package="Tools-Trippy" selector="initialize:objectBlock:">initialize: aString objectBlock: aBlock	label := aString.	objectBlock := aBlock</body><body package="Tools-Trippy" selector="variableName:">variableName: aString	varName := aString</body></methods><methods><class-id>Tools.Trippy.Collaborator</class-id> <category>accessing</category><body package="Tools-Trippy" selector="asPartOf:">asPartOf: anObject	^self isVariable		ifTrue: [NamedVariable of: anObject named: self variableName]		ifFalse: [DerivedAttribute label: self label value: self object]</body><body package="Tools-Trippy" selector="label">label	^label</body><body package="Tools-Trippy" selector="object">object	^objectBlock isNil		ifTrue: [object]		ifFalse: [objectBlock value]</body><body package="Tools-Trippy" selector="variableName">variableName	^varName</body></methods><methods><class-id>Tools.Trippy.Collaborator</class-id> <category>testing</category><body package="Tools-Trippy" selector="isVariable">isVariable	"True if collaborator is one of the object's instance variables; false otherwise."	^varName notNil</body></methods><methods><class-id>Tools.Trippy.Collaborator class</class-id> <category>instance creation</category><body package="Tools-Trippy" selector="label:block:">label: aString block: aBlock	^self new initialize: aString objectBlock: aBlock</body><body package="Tools-Trippy" selector="label:object:">label: aString object: anObject	^self new initialize: aString object: anObject</body><body package="Tools-Trippy" selector="label:variable:object:">label: aString variable: aString2 object: anObject	^(self new initialize: aString object: anObject)		variableName: aString2</body></methods><methods><class-id>Tools.Trippy.DragController</class-id> <category>private</category><body package="Tools-Trippy" selector="currentViewIndex">currentViewIndex	"The answered index may lie outside the valid range of view items."	^view elementIndexFor: view controller sensor cursorPoint</body><body package="Tools-Trippy" selector="doDrop:">doDrop: aDragContext	self subclassResponsibility</body><body package="Tools-Trippy" selector="dropEffect:">dropEffect: aDragContext	"This is a hack to make the cursor give a hint of whether multiple 	objects are copied or not. We always copy the dragged objects."	^(self isMultiObjectDrag: aDragContext)		ifTrue: [#dropEffectCopy]		ifFalse: [#dropEffectMove]</body><body package="Tools-Trippy" selector="isMultiObjectDrag:">isMultiObjectDrag: aDragContext	^aDragContext data clientData size &gt; 1</body><body package="Tools-Trippy" selector="isObjectDrag:">isObjectDrag: aDragContext	^aDragContext key == #inspectorObject</body><body package="Tools-Trippy" selector="restoreViewState">restoreViewState	viewState notNil ifTrue:		[view			targetIndex: (viewState at: 1);			hasFocus: (viewState at: 2)]</body><body package="Tools-Trippy" selector="saveViewState">saveViewState	viewState := Array		with: view targetIndex		with: view hasFocus</body><body package="Tools-Trippy" selector="showDropFeedbackFor:">showDropFeedbackFor: aDragContext	self subclassResponsibility.</body></methods><methods><class-id>Tools.Trippy.DragController</class-id> <category>tracking</category><body package="Tools-Trippy" selector="dragEntry:">dragEntry: aDragContext	^(self isObjectDrag: aDragContext)		ifTrue:			[self saveViewState.			view hasFocus: true.			self dropEffect: aDragContext]		ifFalse:			[#dropEffectNone]</body><body package="Tools-Trippy" selector="dragExit:">dragExit: aDragContext	(self isObjectDrag: aDragContext)		ifTrue: [self restoreViewState].	^#dropEffectNone</body><body package="Tools-Trippy" selector="dragOver:">dragOver: aDragContext	(self isObjectDrag: aDragContext) ifTrue:		[^self showDropFeedbackFor: aDragContext].	^#dropEffectNone</body><body package="Tools-Trippy" selector="drop:">drop: aDragContext	(self isObjectDrag: aDragContext) ifTrue:		[self			restoreViewState;			doDrop: aDragContext.		^#dropEffectCopy].	^#dropEffectNone</body></methods><methods><class-id>Tools.Trippy.DragController</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="initializePage:view:">initializePage: anInspectorPage view: aView	page := anInspectorPage.	view := aView</body></methods><methods><class-id>Tools.Trippy.DragController class</class-id> <category>instance creation</category><body package="Tools-Trippy" selector="for:view:">for: aPage view: aView	^self new initializePage: aPage view: aView</body></methods><methods><class-id>Tools.Trippy.InsertReplaceDragController</class-id> <category>private</category><body package="Tools-Trippy" selector="doDrop:">doDrop: aDragContext	| parts |	parts := aDragContext data clientData.	self		insertUsing: [:part |			aDragContext sourceData contextApplication == page				ifTrue: [page dropFromSame: parts before: part]				ifFalse: [page drop: parts before: part]]		orReplaceUsing: [:part |			aDragContext sourceData contextApplication == page				ifTrue: [page dropFromSame: parts at: part]				ifFalse: [page drop: parts at: part]]</body><body package="Tools-Trippy" selector="insertUsing:orReplaceUsing:">insertUsing: insertionBlock orReplaceUsing: replacementBlock	| index part |	index := view insertionOrReplacementIndexFor: view controller sensor cursorPoint.	^index isInteger		ifTrue: "over an element"			[part := page fieldListHolder list at: index.			replacementBlock value: part]		ifFalse: "between elements"			[ | listIndex |			listIndex := index ceiling.			part := listIndex &gt; page fieldListHolder list size				ifTrue: [nil]				ifFalse: [page fieldListHolder list at: listIndex].			insertionBlock value: part]</body><body package="Tools-Trippy" selector="showDropFeedbackFor:">showDropFeedbackFor: aDragContext	view showInsertReplaceDropFeedbackIn: aDragContext allowScrolling: true.	^self		insertUsing:			[:part |			(page isInsertableBefore: part)				ifTrue: [self dropEffect: aDragContext]				ifFalse: [#dropEffectNone]]		orReplaceUsing:			[:part |			part isReadOnly				ifFalse: [self dropEffect: aDragContext]				ifTrue: [#dropEffectNone]]</body></methods><methods><class-id>Tools.Trippy.ReplaceOnlyDragController</class-id> <category>private</category><body package="Tools-Trippy" selector="currentPart">currentPart	^page fieldListHolder list at: 		(1 max: (view replacementIndexFor: view controller sensor cursorPoint))</body><body package="Tools-Trippy" selector="doDrop:">doDrop: aDragContext	| parts thisPart |	parts := aDragContext data clientData.	thisPart := self currentPart.	thisPart isReadOnly ifTrue: [^self].	aDragContext sourceData contextApplication == page		ifTrue:			[page dropFromSame: parts at: thisPart]		ifFalse:			[page drop: parts at: thisPart]</body><body package="Tools-Trippy" selector="showDropFeedbackFor:">showDropFeedbackFor: aDragContext	view showReplaceDropFeedbackIn: aDragContext allowScrolling: true.	^self currentPart isReadOnly		ifTrue: [#dropEffectNone]		ifFalse: [self dropEffect: aDragContext]</body></methods><methods><class-id>Tools.Trippy.BehaviorInspector</class-id> <category>testing</category><body package="Tools-Trippy" selector="hasSingleSelection">hasSingleSelection	^self methodListHolder selectionIndexes size = 1</body><body package="Tools-Trippy" selector="isAtInstanceSide">isAtInstanceSide	^self sideHolder value = #instance</body></methods><methods><class-id>Tools.Trippy.BehaviorInspector</class-id> <category>aspects</category><body package="Tools-Trippy" selector="methodListHolder">methodListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^methodListHolder isNil		ifTrue:			[methodListHolder := MultiSelectionInList new]		ifFalse:			[methodListHolder]</body><body package="Tools-Trippy" selector="protocolListHolder">protocolListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^protocolListHolder isNil		ifTrue:			[protocolListHolder := MultiSelectionInList new]		ifFalse:			[protocolListHolder]</body><body package="Tools-Trippy" selector="sideHolder">sideHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^sideHolder isNil		ifTrue:			[sideHolder := nil asValue]		ifFalse:			[sideHolder]</body><body package="Tools-Trippy" selector="textHolder">textHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^textHolder isNil		ifTrue:			[textHolder := String new asValue]		ifFalse:			[textHolder]</body></methods><methods><class-id>Tools.Trippy.BehaviorInspector</class-id> <category>actions</category><body package="Tools-Trippy" selector="copyStateFromBehavior:">copyStateFromBehavior: aBehaviorInspector	self sideHolder value ~= aBehaviorInspector sideHolder value		ifTrue: [self sideHolder value: aBehaviorInspector sideHolder value].	self protocolListHolder selections: aBehaviorInspector protocolListHolder selections.	self methodListHolder selections: aBehaviorInspector methodListHolder selections</body><body package="Tools-Trippy" selector="copyStateTo:">copyStateTo: aPage	aPage notNil ifTrue: [aPage copyStateFromBehavior: self]</body><body package="Tools-Trippy" selector="findMethod">findMethod	| selector matchingMethods chosenMethod |	selector := '*'.	[selector := Dialog request: (#FindSelectorC &lt;&lt; #dialogs &gt;&gt; 'Find selector:') initialAnswer: selector.	selector isEmpty ifTrue: [^self].	selector := '*' , selector , '*'.	matchingMethods := (self interestingMethods			select: [:each | selector match: each selector]) asSortedCollection.	matchingMethods isEmpty 		and: [Dialog confirm: (#NoSelectorFound &lt;&lt; #dialogs &gt;&gt; 'No selectors found.&lt;n&gt;Search again?') expandMacros]] 			whileTrue.	matchingMethods isEmpty ifTrue: [^self].	chosenMethod := matchingMethods 		detect: [:each | each selector asString = selector]		ifNone: 			[matchingMethods detect: [:each | each selector asString = selector asLowercase]				ifNone: 					[matchingMethods size == 1 						ifTrue: [matchingMethods first]						ifFalse: 							[Dialog 								choose: (#MatchingMethodsC &lt;&lt; #dialogs &gt;&gt; 'Matching methods:')								fromList: (matchingMethods collect: [:each | each simpleReverseDisplayString])								values: matchingMethods								lines: 20								cancel: [^self]]]].	self		selectProtocol: chosenMethod protocol;		selectMethod: chosenMethod</body><body package="Tools-Trippy" selector="selectAll">selectAll	| holder |	holder := self protocolListHolder.	holder list size = holder selections size		ifTrue: [holder selectionIndexes: Set new]		ifFalse: [holder selectAll]</body><body package="Tools-Trippy" selector="selectorDoubleClicked">selectorDoubleClicked	"Not sure yet about the proper action here."</body><body package="Tools-Trippy" selector="sendAndDive">sendAndDive	"Send the message and dive into the result."	| selector result |	selector := self selectedMethod selector.	selector numArgs ~= 0 ifTrue: [^self].	result := self doItReceiver perform: selector.	self container diveInto: 		(DerivedAttribute 			label: ((#x1sCSent2s &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt;: sent &lt;2s&gt;')				expandMacrosWith: Time now printString				with: selector printString)			value: result)</body><body package="Tools-Trippy" selector="sendIt">sendIt	^self doItReceiver perform: self selectedMethod selector</body></methods><methods><class-id>Tools.Trippy.BehaviorInspector</class-id> <category>private-updating</category><body package="Tools-Trippy" selector="methodSelectionChanged">methodSelectionChanged	self updateText</body><body package="Tools-Trippy" selector="protocolSelectionChanged">protocolSelectionChanged	self updateMethodList</body><body package="Tools-Trippy" selector="refresh">refresh	| selectedProtocols selectedMethods |	selectedProtocols := self protocolListHolder selections.	selectedMethods := self methodListHolder selections.	self updateProtocolList.	self protocolListHolder selections: selectedProtocols.	self methodListHolder selections: selectedMethods</body><body package="Tools-Trippy" selector="sideSelectionChanged">sideSelectionChanged	inheritanceStop := self isAtInstanceSide		ifTrue: [inheritanceStop soleInstance]		ifFalse: [inheritanceStop class].	self updateProtocolList</body><body package="Tools-Trippy" selector="updateMethodList">updateMethodList	self methodListHolder list: self computeMethodList</body><body package="Tools-Trippy" selector="updateProtocolList">updateProtocolList	self protocolListHolder list: self computeProtocolList</body><body package="Tools-Trippy" selector="updateText">updateText	self textHolder value: self computeText</body></methods><methods><class-id>Tools.Trippy.BehaviorInspector</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="configureCodeViewController:">configureCodeViewController: aController	| menu |	aController		initializeMenuForCode;		autoAccept: false;		doNotHandleLocally: #formatSelection.	"The menu must be copied before chaging items, or else the shared menu in the class would be changed."	menu := aController menu copy.	aController menuHolder value: menu. 	(menu menuItemWithValue: #formatSelection)		label: (#Format &lt;&lt; #menus &gt;&gt; 'Format') asString</body><body package="Tools-Trippy" selector="initialize">initialize	super initialize.	self protocolListHolder selectionIndexHolder		onChangeSend: #protocolSelectionChanged to: self.	self sideHolder		value: #instance;		onChangeSend: #sideSelectionChanged to: self.	self methodListHolder selectionIndexHolder		onChangeSend: #methodSelectionChanged to: self</body><body package="Tools-Trippy" selector="initialize:">initialize: anObject	object := anObject.	inheritanceStop := self noInheritanceInheritanceStop.	self objectIsClass ifTrue: [self sideHolder value: #class].	super initialize: anObject</body><body package="Tools-Trippy" selector="postBuildWith:">postBuildWith: aBuilder	super postBuildWith: aBuilder.	(aBuilder componentAt: #methodList) widget		displayStringSelector: #simpleReverseDisplayString.	self configureCodeViewController: (aBuilder componentAt: #text) widget controller</body></methods><methods><class-id>Tools.Trippy.BehaviorInspector</class-id> <category>private</category><body package="Tools-Trippy" selector="changeRequest">changeRequest	^self updateRequest</body><body package="Tools-Trippy" selector="classObject">classObject	"Answer the class object we are to extract methods and other	information from. Behaviors don't need a meta-jump because for them 	we simply flip the instance/class switch, to keeping everything	relative to the non-metaobject base."	^self objectIsClass		ifTrue: [self isAtInstanceSide			ifTrue: [object]			ifFalse: [object class]]		ifFalse:			[self isAtInstanceSide				ifTrue: [object class]				ifFalse: [object class class]]</body><body package="Tools-Trippy" selector="definitionClassOf:from:for:">definitionClassOf: aSelector from: implementingClass for: inheritingClass	"Answer which of the classes for method definitions, regular MethodDefinition	or OverriddenMethodDefinition is correct to represent a method with aSelector	defined in implementingClass when presenting messages understood by	inheritingClass."	| thisClass |	thisClass := inheritingClass.	[thisClass ~~ implementingClass and: [thisClass notNil]] whileTrue:		[(thisClass includesSelector: aSelector)			ifTrue: [^OverriddenMethodDefinition].		thisClass := thisClass superclass].	^MethodDefinition</body><body package="Tools-Trippy" selector="hasUnacceptedChanges">hasUnacceptedChanges	self builder isNil ifTrue: [^false].	^(self controllerAt: #text) textHasChanged</body><body package="Tools-Trippy" selector="inheritanceStop:">inheritanceStop: aClass	"Set the last class up the superclass chain whose methods	are included into what is displayed."	| originalSelections |	inheritanceStop := aClass.	self isAtInstanceSide ifFalse: [inheritanceStop := inheritanceStop class].	originalSelections := self protocolListHolder selections.	self updateProtocolList.	self protocolListHolder selections: originalSelections</body><body package="Tools-Trippy" selector="interestingClasses">interestingClasses	"Answer a collection of classes we are to collect methods from, in the order	from the inspected class towards superclasses. They depend on the inheritance	visibility setting."	| answer this |	answer := OrderedCollection new.	this := self classObject.	[this notNil ifTrue: [answer add: this].	this == inheritanceStop or: [this isNil]]		whileFalse: [this := this superclass].	^answer</body><body package="Tools-Trippy" selector="interestingMethods">interestingMethods	| theClass methods |	theClass := self classObject.	methods := OrderedCollection new: 10.	self interestingClasses do: 		[:eachClass | 		eachClass selectors do:			[:eachSelector | | defClass |			defClass := self definitionClassOf: eachSelector from: eachClass for: theClass.			methods add: (defClass class: theClass implementor: eachClass selector: eachSelector)]].	^methods</body><body package="Tools-Trippy" selector="noInheritanceInheritanceStop">noInheritanceInheritanceStop	^self nonMetaClassObject</body><body package="Tools-Trippy" selector="nonMetaClassObject">nonMetaClassObject	"Answer the object suitable to get things such as the class definition from."	^self classObject instanceBehavior</body><body package="Tools-Trippy" selector="objectIsClass">objectIsClass	^object isBehavior and: [object isMeta not]</body><body package="Tools-Trippy" selector="okToUpdate">okToUpdate	| choice |	choice := Dialog 				choose: (#AcceptUnsavedTextChanges &lt;&lt; #dialogs &gt;&gt; 'Accept unsaved text changes?')				labels: (Array with: (#Yes &lt;&lt; #dialogs &gt;&gt; 'Yes') with: (#No &lt;&lt; #dialogs &gt;&gt; 'No') with: (#Cancel &lt;&lt; #dialogs &gt;&gt; 'Cancel'))				values: #(#yes #no #cancel)				default: #yes.	choice = #cancel ifTrue: [^false].	choice = #yes ifTrue: [self acceptText].	^true</body><body package="Tools-Trippy" selector="rootMinusOneInheritanceStop">rootMinusOneInheritanceStop	"Answer a class one step before Object in the argument object	class inheritance chain."	| last superclass |	last := self nonMetaClassObject.	[(superclass := last superclass) == Object or: [superclass isNil]]		whileFalse: [last := superclass].	^last</body><body package="Tools-Trippy" selector="updateRequest">updateRequest	^super updateRequest and: 		[self hasUnacceptedChanges not or: [self okToUpdate]]</body></methods><methods><class-id>Tools.Trippy.BehaviorInspector</class-id> <category>accessing</category><body package="Tools-Trippy" selector="selectedObject">selectedObject	^self methodListHolder selections asArray first</body></methods><methods><class-id>Tools.Trippy.BehaviorInspector</class-id> <category>private-menus</category><body package="Tools-Trippy" selector="augmentMenu:forMethod:">augmentMenu: aMenu forMethod: aMethodDefinition	| selector selectors |	selector := aMethodDefinition selector.	selectors := aMethodDefinition method allSymbolLiterals.	selectors remove: selector ifAbsent: [].	selectors := selectors asSortedCollection.	#(senders implementors localSenders localImplementors)		with: #(browseAllSenders: browseAllImplementors: 				browseLocalSenders: browseLocalImplementors:)		do: [:menuKey :browseSelector |			(aMenu atNameKey: menuKey) 				submenu: (self 					buildSelectorSubmenuFor: selector 					with: selectors					performing: browseSelector)].	(aMenu atNameKey: #referencedClasses)		submenu: (self buildReferencesSubmenuFor: aMethodDefinition);		value: nil</body><body package="Tools-Trippy" selector="augmentMenuBar:">augmentMenuBar: aMenu	"This is a chance to add our own items to the main window menu bar.	Add the Inheritance dropdown to it."	| visibilitySubmenu |	super augmentMenuBar: aMenu.	visibilitySubmenu := MenuItem labeled: (#Inheritance &lt;&lt; #menus &gt;&gt; '&amp;Inheritance').	visibilitySubmenu submenu: [self buildInheritanceSubmenu].	aMenu addItem: visibilitySubmenu atPosition: 10.005</body><body package="Tools-Trippy" selector="buildInheritanceSubmenu">buildInheritanceSubmenu	| menu nonMetaStop |	menu := Menu new.	nonMetaStop := inheritanceStop instanceBehavior.	self nonMetaClassObject withAllSuperclasses reverseDo:		[:each | | item |		item := MenuItem labeled: each name.		each == nonMetaStop ifTrue: [item beOn].		item value: [self inheritanceStop: each].		menu addItem: item].	^menu</body><body package="Tools-Trippy" selector="buildMethodListMenu">buildMethodListMenu	| menu |	menu := self class methodListMenu.	self singleMethodIsSelected		ifTrue: [self augmentMenu: menu forMethod: self selectedMethod]		ifFalse: [self disableCrossReferenceItemsIn: menu].	menu		augmentFrom: self class		to: BehaviorInspector		menuName: #methodList		for: self.	^menu</body><body package="Tools-Trippy" selector="buildProtocolListMenu">buildProtocolListMenu	| menu |	menu := self class protocolListMenu.	menu		augmentFrom: self class		to: BehaviorInspector		menuName: #protocolList		for: self.	^menu</body><body package="Tools-Trippy" selector="buildReferencesSubmenuFor:">buildReferencesSubmenuFor: aMethodDefinition	| menu item classes |	menu := Menu new.	classes := self classesReferencedFrom: aMethodDefinition.	classes isEmpty ifTrue:		[item := MenuItem labeled: (#none &lt;&lt; #dialogs &gt;&gt; '(none)').		item disable.		menu addItem: item.		^menu].	(classes copyFrom: 1 to: (classes size min: MaxSelectorSubMenuEntries)) do:		[:each |		item := MenuItem labeled: (each name asString contractTo: MaxMenuEntryWidth).		item value: [self browseReferencedClass: each].		menu addItem: item].	classes size &gt; MaxSelectorSubMenuEntries ifTrue:		[item := MenuItem labeled: (#MoreClassesDot &lt;&lt; #menus &gt;&gt; 'more classes...').		item labelText: (Text string: item rawLabel asString emphasis: #(#bold)).		item value: [self browseReferencedClass: nil].		menu addLine; addItem: item].	^menu</body><body package="Tools-Trippy" selector="buildSelectorSubmenuFor:with:performing:">buildSelectorSubmenuFor: aSelector with: selectorCollection performing: browseSelector	| menu item |	menu := Menu new.	item := MenuItem labeled: (aSelector contractTo: MaxMenuEntryWidth).	item value: [self perform: browseSelector with: aSelector].	menu addItem: item; addLine.	selectorCollection isEmpty ifFalse:		[menu addLine.		(selectorCollection copyFrom: 1 to: (selectorCollection size min: MaxSelectorSubMenuEntries)) do: 			[:each | 			item := MenuItem labeled: (each contractTo: MaxMenuEntryWidth).			item value: [self perform: browseSelector with: each].			menu addItem: item].		selectorCollection size &gt; MaxSelectorSubMenuEntries ifTrue:			[item := MenuItem labeled: (#MoreSelectorsDot &lt;&lt; #menus &gt;&gt; 'more selectors...').			item labelText: (Text string: item rawLabel asString emphasis: #(#bold)).			item value: [self perform: browseSelector with: nil].			menu addLine; addItem: item]].	^menu</body><body package="Tools-Trippy" selector="disableCrossReferenceItemsIn:">disableCrossReferenceItemsIn: aMenu	#(senders implementors localSenders localImplementors referencedClasses)		do: [:menuKey | (aMenu atNameKey: menuKey) disable]</body><body package="Tools-Trippy" selector="methodListMenu">methodListMenu	^[self buildMethodListMenu]</body><body package="Tools-Trippy" selector="protocolListMenu">protocolListMenu	^[self buildProtocolListMenu]</body></methods><methods><class-id>Tools.Trippy.BehaviorInspector</class-id> <category>private-method list</category><body package="Tools-Trippy" selector="browseAllImplementors:">browseAllImplementors: aSymbol	| methodCollector |	methodCollector := MethodCollector new.	methodCollector browseSelect: 		(methodCollector implementorsOf: (self pickOneSelector: aSymbol ifCancelled: [^self]))</body><body package="Tools-Trippy" selector="browseAllSenders:">browseAllSenders: aSymbol	| methodCollector |	methodCollector := MethodCollector new.	methodCollector browseSelect: 		(methodCollector referencesTo: (self pickOneSelector: aSymbol ifCancelled: [^self]))</body><body package="Tools-Trippy" selector="browseLocalImplementors:">browseLocalImplementors: aSymbol	| methodCollector |	methodCollector := MethodCollector new.	methodCollector browseSelect: 		(methodCollector searchClassHierarchy: self classObject)		&amp; (methodCollector implementorsOf: (self pickOneSelector: aSymbol ifCancelled: [^self]))</body><body package="Tools-Trippy" selector="browseLocalSenders:">browseLocalSenders: aSymbol	| methodCollector |	methodCollector := MethodCollector new.	methodCollector browseSelect: 		(methodCollector searchClassHierarchy: self classObject)		&amp; (methodCollector referencesTo: (self pickOneSelector: aSymbol ifCancelled: [^self]))</body><body package="Tools-Trippy" selector="browseReferencedClass:">browseReferencedClass: aClass	| realClass classes |	realClass := aClass notNil		ifTrue: [aClass]		ifFalse: 			[classes := self classesReferencedFrom: self selectedMethod.			Dialog 				choose: (#BrowseWhichClass &lt;&lt; #dialogs &gt;&gt; 'Browse which class?')				fromList: classes				values: classes				lines: 20				cancel: [^self]				for: self mainWindow].	SmalltalkWorkbench browseClass: realClass</body><body package="Tools-Trippy" selector="canRemoveMethods">canRemoveMethods	^self methodListHolder selectionIndexes size &gt; 0</body><body package="Tools-Trippy" selector="chooseSelector:from:">chooseSelector: aSymbol from: aMethodDefinition	| messages |	messages := aMethodDefinition method allSymbolLiterals asSortedCollection.	^Dialog		choose: aSymbol expandMacros		fromList: messages		values: messages		lines: 20		cancel: []</body><body package="Tools-Trippy" selector="classesReferencedFrom:">classesReferencedFrom: aMethodDefinition	| classes |	classes := Set new.	aMethodDefinition method allLiterals do: 		[:each | 		(each isVariableBinding and: [each value isBehavior])			ifTrue: [classes add: each value]].	^classes asSortedCollection: [:a :b | a name &lt; b name]</body><body package="Tools-Trippy" selector="computeMethodList">computeMethodList	| protocols includeUnclassified methods classOrder theClass |	protocols := self protocolListHolder selections.	(protocols isEmpty and: [ProtocolItemNavigatorPart showAllItemsWhenNothingSelected])		ifTrue: [^self listAllMethods].	(protocols includes: self unclassifiedProtocol)		ifTrue:			[protocols := protocols copyWithout: self unclassifiedProtocol.			includeUnclassified := true]		ifFalse: [includeUnclassified := false].	methods := OrderedCollection new.	classOrder := self interestingClasses asArray.	theClass := self classObject.	self interestingClasses do:		[:eachClass | | selectors |		selectors := eachClass organization listAtCategoriesNamed: protocols.		includeUnclassified ifTrue:			[selectors addAll: (eachClass selectors				reject: [:some | eachClass organization includesElement: some])].		methods addAll: (selectors collect:			[:eachSelector | | defClass |			defClass := self definitionClassOf: eachSelector from: eachClass for: theClass.			defClass class: theClass implementor: eachClass selector: eachSelector])].	methods := methods asSortedCollection:		[:a :b |		a selector = b selector			ifFalse: [a selector &lt;= b selector]			ifTrue:				[(classOrder indexOf: a implementingClass)					&lt;= (classOrder indexOf: b implementingClass)]].	^methods asList</body><body package="Tools-Trippy" selector="listAllMethods">listAllMethods	| methods classOrder theClass |	methods := OrderedCollection new.	classOrder := self interestingClasses asArray.	theClass := self classObject.	self interestingClasses do:		[:eachClass |		methods addAll: (eachClass selectors collect:			[:eachSelector | | defClass |			defClass := self definitionClassOf: eachSelector from: eachClass for: theClass.			defClass class: theClass implementor: eachClass selector: eachSelector])].	methods := methods asSortedCollection:		[:a :b |		a selector = b selector			ifFalse: [a selector &lt;= b selector]			ifTrue:				[(classOrder indexOf: a implementingClass)					&lt;= (classOrder indexOf: b implementingClass)]].	^methods asList</body><body package="Tools-Trippy" selector="makeMethodSelectionVisible">makeMethodSelectionVisible	| selectedIndex |	selectedIndex := self methodListHolder selectionIndexes		detect: [:any | true] ifNone: [^self].	(self widgetAt: #methodList) makeVisible: selectedIndex</body><body package="Tools-Trippy" selector="pickOneSelector:ifCancelled:">pickOneSelector: aSymbolOrNil ifCancelled: aBlock	| selector |	selector := aSymbolOrNil isNil		ifTrue: 			[self 				chooseSelector: (#BrowseAllImplementors &lt;&lt; #dialogs &gt;&gt; 'View all implementors&lt;n&gt;of which selector?') 				from: self selectedMethod]		ifFalse: [aSymbolOrNil].	selector isNil ifTrue: [^aBlock value].	^selector</body><body package="Tools-Trippy" selector="removeMethods">removeMethods	| removableMethods thisClass |	thisClass := self classObject.	removableMethods := self methodListHolder selections select:		[:some | some implementingClass == thisClass].	removableMethods size = 0 ifTrue: [^self].	(Dialog confirm: 		(removableMethods size = 1			ifTrue: [(#ReallyRemoveThisMethod &lt;&lt; #dialogs &gt;&gt; 'Really remove this method?')]			ifFalse: [(#ReallyRemoveTheseMethods &lt;&lt; #dialogs &gt;&gt; 'Really remove these methods?')]))				ifFalse: [^self].	removableMethods do:		[:each | thisClass removeSelector: each selector].	self updateMethodList</body><body package="Tools-Trippy" selector="selectedMethod">selectedMethod	^self methodListHolder selections asArray first</body><body package="Tools-Trippy" selector="selectMethod:">selectMethod: aMethodDefinition	self methodListHolder selections: (Set with: aMethodDefinition).	self makeMethodSelectionVisible</body><body package="Tools-Trippy" selector="selectSelector:">selectSelector: aSymbol	| definition |	definition := self methodListHolder list 		detect: [:some | some selector = aSymbol]		ifNone: [nil].	self methodListHolder selections: (Set with: definition).	self makeMethodSelectionVisible</body><body package="Tools-Trippy" selector="singleMethodIsSelected">singleMethodIsSelected	^self methodListHolder selectionIndexes size = 1</body><body package="Tools-Trippy" selector="singleUnaryMethodIsSelected">singleUnaryMethodIsSelected	^self singleMethodIsSelected and:		[self selectedMethod selector numArgs = 0]</body></methods><methods><class-id>Tools.Trippy.BehaviorInspector</class-id> <category>private-protocol list</category><body package="Tools-Trippy" selector="addProtocol">addProtocol	| newProtocol selections selection |	self changeRequest ifFalse: [^self].	newProtocol := Dialog request: (#EnterNewProtocolName &lt;&lt; #dialogs &gt;&gt; 'Enter new protocol name') initialAnswer: (#protocolName &lt;&lt; #dialogs &gt;&gt; 'protocol name').	newProtocol isEmpty ifTrue: [^self].	newProtocol := newProtocol asSymbol.	selections := self protocolListHolder selections.	selection := selections size = 1 		ifTrue: [selections asArray first]		ifFalse: [nil].	self classObject organization		addCategory: newProtocol before: selection.	SourceFileManager default logChange:				('&lt;1p&gt; organization addCategory: &lt;2p&gt; before: &lt;3p&gt;'					expandMacrosWith: self classObject					with: newProtocol					with: selection).	self classObject reorganize.	self 		updateProtocolList;		selectProtocol: newProtocol</body><body package="Tools-Trippy" selector="canRemoveProtocol">canRemoveProtocol	^self protocolListHolder selectionIndexes size &gt; 0</body><body package="Tools-Trippy" selector="canRenameProtocol">canRenameProtocol	^self protocolListHolder selectionIndexes size = 1</body><body package="Tools-Trippy" selector="computeProtocolList">computeProtocolList	"Make sure to include a protocol for selectors not included	in any protocols as it may happen occasionally."	| protocols sortedProtocols |	protocols := Set new.	self interestingClasses do: [:each |		protocols addAll: each organization categories.		each organization elements size &lt; each selectors size			ifTrue: [protocols add: self unclassifiedProtocol]].	sortedProtocols := SelectorProtocolNavigatorPart protocolOrder		ifNil: [protocols asSortedCollection]		ifNotNil: [:order | protocols asSortedCollection: [:a :b | order is: a before: b]].	^sortedProtocols asList</body><body package="Tools-Trippy" selector="makeProtocolSelectionVisible">makeProtocolSelectionVisible	| selectedIndex |	selectedIndex := self protocolListHolder selectionIndexes 		detect: [:any | true] ifNone: [^self].	(self widgetAt: #protocolList) makeVisible: selectedIndex</body><body package="Tools-Trippy" selector="removeProtocol">removeProtocol	| target ownProtocols selectors |	self changeRequest ifFalse: [ ^false ].	target := self classObject.	ownProtocols := Set new.	selectors := Set new.	self protocolListHolder selections do: 		[:protocol |		(target organization categories includes: protocol) ifTrue: 			[ownProtocols add: protocol.			selectors addAll: (target organization listAtCategoryNamed: protocol)]].	ownProtocols isEmpty ifTrue: [^self].	selectors isEmpty ifFalse:		[(Dialog confirm: (#ConfirmRemoveingMethodsInProtocols &lt;&lt; #dialogs &gt;&gt; 'Are you certain that you want to&lt;n&gt;remove all methods in these protocols?')							expandMacros)			ifFalse: [^false]].	selectors do: [:each | target removeSelector: each].	ownProtocols do: 		[ :protocol |		target organization removeCategory: protocol.		SourceFileManager default logChange: 			('&lt;1p&gt; organization removeCategory: &lt;2p&gt;'					expandMacrosWith: target					with: protocol)].	target reorganize.	self updateProtocolList</body><body package="Tools-Trippy" selector="renameProtocol">renameProtocol	| oldName newName target |	self changeRequest ifFalse: [^self].	target := self classObject.	oldName := self protocolListHolder selections asArray first.	newName := Dialog request: (#EnterNewProtocolName &lt;&lt; #dialogs &gt;&gt; 'Enter new protocol name') initialAnswer: oldName.	newName isEmpty ifTrue: [^self].	newName := newName asSymbol.	(target renameCategory: oldName to: newName) ifTrue:		[SourceFileManager default logChange:			('&lt;1p&gt; organization renameCategory: &lt;2p&gt; to: &lt;3p&gt;'					expandMacrosWith: target					with: oldName					with: newName).		self 			updateProtocolList;			selectProtocol: newName]</body><body package="Tools-Trippy" selector="selectProtocol:">selectProtocol: aSymbol 	self protocolListHolder selections: (Set with: aSymbol).	self makeProtocolSelectionVisible</body><body package="Tools-Trippy" selector="unclassifiedProtocol">unclassifiedProtocol	"Answer the name of a protocol to use for selectors	not included into other protocols."	^#'as yet unclassified'</body></methods><methods><class-id>Tools.Trippy.BehaviorInspector</class-id> <category>private-text</category><body package="Tools-Trippy" selector="acceptClassDefinition:from:">acceptClassDefinition: aText from: aController	Compiler new		evaluate: aText string		in: nil		allowReceiver: false		receiver: nil		environment: self classObject environment		notifying: aController		ifFail: [^false].	SourceFileManager default logChange: aText string.	^true</body><body package="Tools-Trippy" selector="acceptMethodDefinition:from:">acceptMethodDefinition: aText from: aController	| protocols protocol selector methods |	protocols := self protocolListHolder selections.	protocols size = 0 ifTrue: 		[methods := self methodListHolder selections.		protocol := methods isEmpty			ifTrue:				[Dialog choose: (#ChooseProtocolForMethod &lt;&lt; #dialogs &gt;&gt; 'Put this method into which protocol?')					fromList: self protocolListHolder list					values: self protocolListHolder list					lines: 10					cancel: [^false]]			ifFalse:				[methods first protocol]].	protocols size = 1 ifTrue: [protocol := protocols asArray first].	protocols size &gt; 1 ifTrue:		[protocol := Dialog choose: (#ChooseProtocolForMethod &lt;&lt; #dialogs &gt;&gt; 'Put this method into which protocol?')			fromList: protocols asSortedCollection			values: protocols asSortedCollection			lines: 10			cancel: [^false]].	selector := self classObject		compile: aText		classified: protocol		notifying: aController.	selector isNil 		ifTrue: [^false]		ifFalse:			[self				updateMethodList;				selectSelector: selector.			^true]</body><body package="Tools-Trippy" selector="acceptText">acceptText	self textAcceptAllowed: (self controllerAt: #text)</body><body package="Tools-Trippy" selector="computeMethodSourceText">computeMethodSourceText	| textStream |	textStream := TextStream on: (String new: 100).	self methodListHolder selections		do: [:each | textStream nextPutAllText: each formattedSourceCode]		separatedBy: [textStream cr; cr].	^textStream contents</body><body package="Tools-Trippy" selector="computeText">computeText	^self methodListHolder selections isEmpty		ifTrue:			[self protocolListHolder selections isEmpty				ifTrue:					[self nonMetaClassObject definition]									ifFalse: 					[self classObject sourceCodeTemplate]]		ifFalse: 			[self computeMethodSourceText]</body><body package="Tools-Trippy" selector="doItReceiver">doItReceiver	^self objectIsClass		ifTrue: 			[self isAtInstanceSide				ifTrue: [nil]				ifFalse: [self object]]		ifFalse:			[self isAtInstanceSide				ifTrue: [self object]				ifFalse: [self object class]]</body><body package="Tools-Trippy" selector="formatSelection">formatSelection	| editor |	editor := self controllerAt: #text.	self textIsClassDefinition		ifTrue: [editor formatAllAsExpression]		ifFalse: [editor formatAllAsMethod]</body><body package="Tools-Trippy" selector="textAcceptAllowed:">textAcceptAllowed: aController	"Compile here rather in #textAccepted: so that errors prevent	the controller text from being stored in the model."	^self textIsClassDefinition		ifTrue: [self acceptClassDefinition: aController text from: aController]		ifFalse: [self acceptMethodDefinition: aController text from: aController]</body><body package="Tools-Trippy" selector="textAccepted:">textAccepted: aController	^self</body><body package="Tools-Trippy" selector="textIsClassDefinition">textIsClassDefinition	^self protocolListHolder selectionIndexes isEmpty and: [self methodListHolder selectionIndexes isEmpty]</body></methods><methods><class-id>Tools.Trippy.BehaviorInspector class</class-id> <category>accessing</category><body package="Tools-Trippy" selector="tabLabel">tabLabel	^(#_Methods &lt;&lt; #dialogs &gt;&gt; '&amp;Methods')</body></methods><methods><class-id>Tools.Trippy.RemovalUndo</class-id> <category>accessing</category><body package="Tools-Trippy" selector="explanation">explanation	^(#Removal &lt;&lt; #dialogs &gt;&gt; 'Removal')</body><body package="Tools-Trippy" selector="undoIn:">undoIn: aPage	aPage undoRemoval: self</body></methods><methods><class-id>Tools.Trippy.NullNavigator</class-id> <category>accessing</category><body package="Tools-Trippy" selector="vicinity">vicinity	^#none</body></methods><methods><class-id>Tools.Trippy.NullNavigator</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="postBuildWith:">postBuildWith: aBuilder	self reinstallInspector</body></methods><methods><class-id>Tools.Trippy.Clipboard</class-id> <category>private</category><body package="Tools-Trippy" selector="fromLocal:">fromLocal: anObject	^anObject == zeroStandIn		ifTrue: [0]		ifFalse: [anObject]</body><body package="Tools-Trippy" selector="toLocal:">toLocal: anObject	"If a 0 is stored on the clipboard, it has to be replaced with a different	object to distinguish it from dead values."	^0 == anObject		ifTrue: [zeroStandIn]		ifFalse: [anObject]</body></methods><methods><class-id>Tools.Trippy.Clipboard</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="initialize">initialize	zeroStandIn := '0' copy. "unique object to stand in for 0 value"	self empty</body></methods><methods><class-id>Tools.Trippy.Clipboard</class-id> <category>testing</category><body package="Tools-Trippy" selector="isEmpty">isEmpty	^values size = 0 or:		[values detect: [:some | some ~~ 0] ifNone: [^true].		^false]</body><body package="Tools-Trippy" selector="notEmpty">notEmpty	^self isEmpty not</body></methods><methods><class-id>Tools.Trippy.Clipboard</class-id> <category>accessing</category><body package="Tools-Trippy" selector="empty">empty	parts := Array new.	values := Array new</body><body package="Tools-Trippy" selector="get">get	"Answer PartSnapshots of parts with not yet dead values."	| result |	result := OrderedCollection new: parts size.	parts with: values do:		[:part :value |		0 ~~ value ifTrue:			[result add: (PartSnapshot new part: part value: (self fromLocal: value))]].	^result</body><body package="Tools-Trippy" selector="put:">put: aPartCollection	parts := aPartCollection select: [:each | each hasValue].	values := WeakArray new: parts size.	parts keysAndValuesDo:		[:index :part |		values at: index put: (self toLocal: part value)]</body></methods><methods><class-id>Tools.Trippy.Clipboard class</class-id> <category>accessing</category><body package="Tools-Trippy" selector="default">default	Default isNil ifTrue:		[Default := self new].	^Default</body></methods><methods><class-id>Tools.Trippy.Clipboard class</class-id> <category>instance creation</category><body package="Tools-Trippy" selector="new">new	^super new initialize</body></methods><methods><class-id>Tools.Trippy.PartListAbstractInspector</class-id> <category>properties</category><body package="Tools-Trippy" selector="dragControllerClass">dragControllerClass	self subclassResponsibility</body><body package="Tools-Trippy" selector="driverClass">driverClass	^self isSegmented		ifTrue: [SegmentedPageDriver]		ifFalse: [PageDriver]</body><body package="Tools-Trippy" selector="isSegmented">isSegmented	^self partCount &gt; self class pageSizeLimit</body><body package="Tools-Trippy" selector="specName">specName	^self isSegmented		ifTrue: [#segmentedSpec]		ifFalse: [#unsegmentedSpec]</body><body package="Tools-Trippy" selector="undoLimit">undoLimit	"How many undo levels a page allows."	^10</body></methods><methods><class-id>Tools.Trippy.PartListAbstractInspector</class-id> <category>private</category><body package="Tools-Trippy" selector="checkProtectionOf:ifCancelled:">checkProtectionOf: partCollection ifCancelled: aBlock	| protected |	protected := partCollection select: [:each | each isProtected].	protected isEmpty not ifTrue:		[(Dialog confirm: (#ConfirmSaveIntoProtectedSlot &lt;&lt; #dialogs &gt;&gt; 'Changing the value of a protected part may have catastrophic consequences.Are you sure you want to continue?'))			ifFalse: [^aBlock value]].</body><body package="Tools-Trippy" selector="computeMultiSelectionText">computeMultiSelectionText	| stream |	stream := TextStream on: (String new: 200).	self selections do:		[:each |		stream			nextPutAllText: each displayString copy asText allBold;			nextPutAll: ':  ';			nextPutAll: each text.		stream cr].	^stream contents</body><body package="Tools-Trippy" selector="computeNoSelectionText">computeNoSelectionText	^String new</body><body package="Tools-Trippy" selector="computeSingleSelectionText">computeSingleSelectionText	^self selection text</body><body package="Tools-Trippy" selector="computeText">computeText	self hasMultiSelection		ifTrue: [^self computeMultiSelectionText].	self hasSingleSelection		ifTrue: [^self computeSingleSelectionText].	^self computeNoSelectionText</body><body package="Tools-Trippy" selector="createInsertionUndo:before:">createInsertionUndo: partCollection before: anIndex	self subclassResponsibility</body><body package="Tools-Trippy" selector="createRemovalUndo">createRemovalUndo	^RemovalUndo new savedValues: self selections</body><body package="Tools-Trippy" selector="createReplacementUndo:">createReplacementUndo: partCollection	^ReplacementUndo new savedValues: partCollection</body><body package="Tools-Trippy" selector="createReplacementUndoOf:">createReplacementUndoOf: aPart	^ReplacementUndo new savedValues: (Array with: aPart)</body><body package="Tools-Trippy" selector="doItContext">doItContext	"Answer the context in which a text selection can be evaluated."	^nil</body><body package="Tools-Trippy" selector="doItReceiver">doItReceiver	"Answer the object that should be informed of the result of evaluating a	text selection."	^object</body><body package="Tools-Trippy" selector="enumerateOwnersToIgnore:">enumerateOwnersToIgnore: aBlock	super enumerateOwnersToIgnore: aBlock.	fieldListHolder list do: aBlock</body><body package="Tools-Trippy" selector="evaluateText:from:ifFail:">evaluateText: aText from: aController ifFail: failBlock	"The user wishes to evaluate expressions in the value part of an inspector.	Do so in the context of the inspector's variables.  Evaluate failBlock	if the evaluation does not work."		^Cursor execute showWhile:		[self doItReceiver class evaluatorClass new			evaluate: aText			in: nil			allowReceiver: true			receiver: self doItReceiver			environment: self doItReceiver class environment			notifying: aController			ifFail: failBlock]</body><body package="Tools-Trippy" selector="pickSingleObjectIn:ifCancelled:">pickSingleObjectIn: partCollection ifCancelled: aBlock	| labels objects objectsCopy |	partCollection size = 1 ifTrue: [^partCollection first value].	labels := OrderedCollection new.	objects := OrderedCollection new.	partCollection do:		[:part |		labels add: ('&lt;1s&gt;: &lt;2s&gt;'			expandMacrosWith: part displayString			with: part value displayString).		objects add: part value].	objectsCopy := objects copy.	labels add: ((#All1pAsAnArray &lt;&lt; #dialogs &gt;&gt; 'All &lt;1p&gt; as an Array') expandMacrosWith: partCollection size).	objects add: objectsCopy asArray.	labels add: ((#All1pAsAnOC &lt;&lt; #dialogs &gt;&gt; 'All &lt;1p&gt; as an OrderedCollection') expandMacrosWith: partCollection size).	objects add: objectsCopy asOrderedCollection.	labels add: ((#All1pAsASet &lt;&lt; #dialogs &gt;&gt; 'All &lt;1p&gt; as a Set') expandMacrosWith: partCollection size).	objects add: objectsCopy asSet.	^Dialog		choose: (#UseWhichOfTheseObjectsQ &lt;&lt; #dialogs &gt;&gt; 'Use which of these objects?')		fromList: labels		values: objects		lines: 8		cancel: aBlock</body><body package="Tools-Trippy" selector="refresh">refresh	| originalSelections |	originalSelections := self selections.	driver := self driverClass for: self.	driver refresh.	self selectAll: originalSelections</body><body package="Tools-Trippy" selector="rememberUndo:">rememberUndo: anUndoAction	undoHistory addLast: anUndoAction.	undoHistory size &gt; self undoLimit ifTrue:		[undoHistory removeFirst]</body><body package="Tools-Trippy" selector="replaceSelectionsWith:">replaceSelectionsWith: newValue	| selections |	selections := self selections reject: [:some | some isReadOnly].	selections isEmpty ifTrue: [^self].	self checkProtectionOf: selections ifCancelled: [^self].	self rememberUndo: (self createReplacementUndo: selections).	selections do: 		[:each | 		each value: newValue.		self container partValueChanged: each].	self textHolder value: self computeText</body><body package="Tools-Trippy" selector="textAcceptAllowed:">textAcceptAllowed: aController	(self hasSelection and: [(self selections contains: [:some | some isReadOnly]) not]) ifFalse:		[aController view flash.		^false].	self checkProtectionOf: self selections ifCancelled:		[aController view flash.		^false].	^true</body><body package="Tools-Trippy" selector="textAccepted:">textAccepted: aController	| newValue |	newValue := self		evaluateText: aController text		from: aController		ifFail: [^false].	self replaceSelectionsWith: newValue.	^true</body></methods><methods><class-id>Tools.Trippy.PartListAbstractInspector</class-id> <category>aspects</category><body package="Tools-Trippy" selector="fieldListHolder">fieldListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^fieldListHolder isNil		ifTrue:			[fieldListHolder := MultiSelectionInList new]		ifFalse:			[fieldListHolder]</body><body package="Tools-Trippy" selector="segmentListHolder">segmentListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^segmentListHolder isNil		ifTrue:			[segmentListHolder := MultiSelectionInList new]		ifFalse:			[segmentListHolder]</body><body package="Tools-Trippy" selector="textHolder">textHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^textHolder isNil		ifTrue:			[textHolder := String new asValue]		ifFalse:			[textHolder]</body></methods><methods><class-id>Tools.Trippy.PartListAbstractInspector</class-id> <category>actions-editing</category><body package="Tools-Trippy" selector="copySelection">copySelection	Clipboard default put: self selections</body><body package="Tools-Trippy" selector="paste">paste	| parts |	parts := Clipboard default get.	parts isEmpty ifFalse:		[self hasSelection			ifTrue: [self pasteIntoSelected: parts]			ifFalse: [self pasteIntoSelf: parts]].</body><body package="Tools-Trippy" selector="pasteIntoSelected:">pasteIntoSelected: partCollection	| value |	value := self pickSingleObjectIn: partCollection ifCancelled: [^self].	self replaceSelectionsWith: value</body><body package="Tools-Trippy" selector="pasteIntoSelf:">pasteIntoSelf: aBundle	Dialog warn: (#CannotAddElementsToObject &lt;&lt; #dialogs &gt;&gt; 'Cannot add elements to this object.')</body><body package="Tools-Trippy" selector="undo">undo	| undo |	undoHistory notEmpty ifTrue:		[undo := undoHistory removeLast.		undo undoIn: self]</body><body package="Tools-Trippy" selector="undoReplacement:">undoReplacement: aReplacementUndo	aReplacementUndo savedValues do:		[:each | each restore].	self refresh; selectAll: aReplacementUndo parts</body></methods><methods><class-id>Tools.Trippy.PartListAbstractInspector</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="copyStateFromPartList:">copyStateFromPartList: anInspector	self selectAll: anInspector selections</body><body package="Tools-Trippy" selector="initialize:">initialize: anObject	undoHistory := OrderedCollection new.	super initialize: anObject</body><body package="Tools-Trippy" selector="installedWith:">installedWith: aBuilder	super installedWith: aBuilder.	self refresh</body><body package="Tools-Trippy" selector="postBuildWith:">postBuildWith: aBuilder	(aBuilder componentAt: #text) widget controller		initializeMenuForCode;		autoAccept: false</body></methods><methods><class-id>Tools.Trippy.PartListAbstractInspector</class-id> <category>actions</category><body package="Tools-Trippy" selector="back">back	self container back</body><body package="Tools-Trippy" selector="changeRequest">changeRequest	| textEditor choice |	textEditor := (builder componentAt: #text) widget controller.	(textEditor accepted or: [self hasSelection not]) ifTrue: [^true].	choice := Dialog 		choose: (#AcceptUnsavedChanges &lt;&lt; #dialogs &gt;&gt; 'Accept unsaved changes?')		labels: (Array with: (#Yes &lt;&lt; #dialogs &gt;&gt; 'Yes') with: (#No &lt;&lt; #dialogs &gt;&gt; 'No') with: (#Cancel &lt;&lt; #dialogs &gt;&gt; 'Cancel'))		values: #(yes no cancel)		default: #yes.	choice = #cancel ifTrue: [^false].	choice = #yes ifTrue: [textEditor accept].	^true</body><body package="Tools-Trippy" selector="dive">dive	(self hasSingleSelection and: [self selection hasValue])		ifTrue: [self container diveInto: self selection]</body><body package="Tools-Trippy" selector="flushUndoHistory">flushUndoHistory	undoHistory := OrderedCollection new</body><body package="Tools-Trippy" selector="selectAll">selectAll	"If all are already selected, unselect all instead."	self fieldListHolder selections size = self fieldListHolder list size		ifTrue: [self fieldListHolder selectionIndexes: Set new]		ifFalse: [self fieldListHolder selectAll]</body><body package="Tools-Trippy" selector="spawn">spawn	self hasSingleSelection		ifTrue: [self selection value inspect]		ifFalse: [self hasMultiSelection			ifTrue: [(self selections collect: [:each | each value]) inspect]			ifFalse: [self object inspect]]</body></methods><methods><class-id>Tools.Trippy.PartListAbstractInspector</class-id> <category>accessing</category><body package="Tools-Trippy" selector="copyStateTo:">copyStateTo: aPage	aPage notNil ifTrue: [aPage copyStateFromPartList: self]</body><body package="Tools-Trippy" selector="select:">select: aPart	^self fieldListHolder selections: (Set with: aPart)</body><body package="Tools-Trippy" selector="selectAll:">selectAll: partCollection	^self fieldListHolder selections: partCollection asSet</body><body package="Tools-Trippy" selector="selectedObjectOrInspectedObject">selectedObjectOrInspectedObject	| selection |	^self hasSingleSelection		ifTrue: 			[selection := self selection.			selection hasValue ifTrue: [selection value] ifFalse: [self object]]		ifFalse: [self object]</body><body package="Tools-Trippy" selector="selection">selection	self hasSingleSelection ifFalse:		[self error: (#errSingleSelectionRequired &lt;&lt; #dialogs &gt;&gt; 'single selection required')].	^self fieldListHolder selections asArray first</body><body package="Tools-Trippy" selector="selections">selections	"Simply '^self fieldListHolder selections' will not do because we want a	sequence of selections with their order preserved, not a Set.	This is actually MultiSelectionInList brain damage but oh well."	| indices list |	indices := self fieldListHolder selectionIndexes asSortedCollection.	list := self fieldListHolder list.	^(indices collect: [:each | list at: each]) asArray</body><body package="Tools-Trippy" selector="undoExplanation">undoExplanation	"Answer a string with an explanation of the possible undo action, or an empty string."	^self canUndo		ifTrue: [undoHistory last explanation]		ifFalse: [String new]</body></methods><methods><class-id>Tools.Trippy.PartListAbstractInspector</class-id> <category>testing</category><body package="Tools-Trippy" selector="canAddPart">canAddPart	^true</body><body package="Tools-Trippy" selector="canCopy">canCopy	"Copy is only meaningful if at least one of the selected parts has value."	^self selections contains: [:some | some hasValue]</body><body package="Tools-Trippy" selector="canDive">canDive	^self hasSingleSelection and: [self selection hasValue]</body><body package="Tools-Trippy" selector="canRemoveParts">canRemoveParts	^self hasSelection</body><body package="Tools-Trippy" selector="canUndo">canUndo	^undoHistory notEmpty</body><body package="Tools-Trippy" selector="hasMultiSelection">hasMultiSelection	^self fieldListHolder selectionIndexes size &gt; 1</body><body package="Tools-Trippy" selector="hasSelection">hasSelection	"Answer whether at least one field is selected."	^self fieldListHolder selectionIndexes size &gt; 0</body><body package="Tools-Trippy" selector="hasSingleSelection">hasSingleSelection	"Answer whether these is exactly one field selected on the list."	^self fieldListHolder selectionIndexes size = 1</body><body package="Tools-Trippy" selector="isInsertableBefore:">isInsertableBefore: aPartOrNil	"Answer whether it is possible to insert elements before the given part	(or at the end of part list if the argument is nil).	Most pages allow insertions. Those that don't, such as the basic page,	should redefine this."	^true</body><body package="Tools-Trippy" selector="isPartList">isPartList	^true</body></methods><methods><class-id>Tools.Trippy.PartListAbstractInspector</class-id> <category>decomposing</category><body package="Tools-Trippy" selector="partAt:">partAt: anInteger	"Answer the part of an object at the given index. The index must be	in the 1..partCount range."	self subclassResponsibility</body><body package="Tools-Trippy" selector="partCount">partCount	"Answer the number of parts of the object inspected by the receiver."	self subclassResponsibility</body><body package="Tools-Trippy" selector="partsAtAll:">partsAtAll: aCollection	"Subclasses are encouraged to override this to recognize the special	case of the full range of indices (1..partCount) being requested if there	is performance gain in building the complete list all at once."	^aCollection collect: [:eachIndex | self partAt: eachIndex]</body></methods><methods><class-id>Tools.Trippy.PartListAbstractInspector</class-id> <category>actions-drag/drop</category><body package="Tools-Trippy" selector="doDrag:">doDrag: aController	| data selections |	(data := DragDropData new)		contextWindow: builder window;		contextWidget: aController;		contextApplication: self.	selections := self selections select: [:part | part hasValue].	selections isEmpty ifTrue: [^self].	data		key: #inspectorObject;		clientData: selections.	(DragDropManager		withDropSource: DropSource new		withData: data)			doDragDrop</body><body package="Tools-Trippy" selector="dragEntry:">dragEntry: aDragContext	dragController := self dragControllerClass		for: self		view: (self builder componentAt: #fieldList) widget.	^dragController dragEntry: aDragContext</body><body package="Tools-Trippy" selector="dragExit:">dragExit: aDragContext	| result |	result := dragController notNil		ifTrue: [dragController dragExit: aDragContext]		ifFalse: [#dropEffectNone].	dragController := nil.	^result</body><body package="Tools-Trippy" selector="dragOver:">dragOver: aDragContext	^dragController notNil		ifTrue: [dragController dragOver: aDragContext]		ifFalse: [#dropEffectNone]</body><body package="Tools-Trippy" selector="drop:">drop: aDragContext	| result |	result := dragController notNil		ifTrue: [dragController drop: aDragContext]		ifFalse: [#dropEffectNone].	dragController := nil.	^result</body><body package="Tools-Trippy" selector="drop:at:">drop: partCollection at: aPart	self checkProtectionOf: (Array with: aPart) ifCancelled: [^self].	self rememberUndo: (self createReplacementUndoOf: aPart).	aPart value: (self pickSingleObjectIn: partCollection ifCancelled: [^self]).	self select: aPart</body><body package="Tools-Trippy" selector="drop:before:">drop: partCollection before: aPart	"Inserting a bunch of objects between elements does not do anything by default."</body><body package="Tools-Trippy" selector="dropFromSame:at:">dropFromSame: partCollection at: aPart	"By default, there is no difference between dropping elements from	the same object or from a different one."	self drop: partCollection at: aPart</body><body package="Tools-Trippy" selector="dropFromSame:before:">dropFromSame: partCollection before: aPart	"By default, there is no difference between dropping elements from	the same object or from a different one."	self drop: partCollection before: aPart</body><body package="Tools-Trippy" selector="wantToDrag:">wantToDrag: aController	^true</body></methods><methods><class-id>Tools.Trippy.PartListAbstractInspector</class-id> <category>menu management</category><body package="Tools-Trippy" selector="addAddAndRemoveItemsTo:">addAddAndRemoveItemsTo: aMenu	"Add appropriate things to the Edit dropdown menu	of the shell inspector menu bar. "	aMenu		addItem: ((MenuItem labeled: (#AddDot &lt;&lt; #menus &gt;&gt; '&amp;Add...'))			nameKey: #editAdd;			value: [self add];			enabled: [self canAddPart]);		addItem: ((MenuItem labeled: (#_Remove &lt;&lt; #menus &gt;&gt; '&amp;Remove'))			nameKey: #editRemove;			value: [self removeSelected];			enabled: [self canRemoveParts])</body><body package="Tools-Trippy" selector="adjustMenuBarEnablement:">adjustMenuBarEnablement: aMenu	"Now that this class has introduced the concept of selection,	some menu items need adjustment to take selection into account."	#(objectBrowse objectSpawn objectInspectOwners) do:		[:each |		(aMenu atNameKey: each)			enabled: [self hasSelection not or: [self canDive]]]</body><body package="Tools-Trippy" selector="augmentEditMenu:">augmentEditMenu: aMenu	"Subclasses may redefine this to have extra items on the edit menu."</body><body package="Tools-Trippy" selector="augmentMenuBar:">augmentMenuBar: aMenu	"The top-level window gives us a chance to modify its menu bar."	| editItem editMenu |	super augmentMenuBar: aMenu.	self adjustMenuBarEnablement: aMenu.	editItem := MenuItem labeled: (#_Edit &lt;&lt; #menus &gt;&gt; '&amp;Edit').	editItem nameKey: #editMenu.	editMenu := self class baseEditSubmenu.	(editMenu atNameKey: #editUndo) enabled: [self canUndo].	(editMenu atNameKey: #editCopy) enabled: [self canCopy].	self		makeSelfPerformerOf: editMenu;		augmentEditMenu: editMenu.	editItem submenu: editMenu.	aMenu addItem: editItem atPosition: 10.002</body><body package="Tools-Trippy" selector="buildFieldListMenu">buildFieldListMenu	"Build the popup menu for the field list. Besides the usual things,	it should include items for actions published by the currently selected	object, if there is one."	| menu |	menu := self class fieldListMenu.	(menu atNameKey: #dive) enabled: [self canDive].	(menu atNameKey: #spawn) enabled: [self canDive].	(menu atNameKey: #paste) enabled: [Clipboard default notEmpty].	(menu atNameKey: #back) enabled: [self container canGoBack].	(self hasSingleSelection and: [self selection hasValue]) ifTrue:		[self addObject: self selection value actionsTo: menu].	menu		augmentFrom: self class		to: PartListAbstractInspector		menuName: #fieldList		for: self.	^menu</body><body package="Tools-Trippy" selector="fieldListMenu">fieldListMenu	^[self buildFieldListMenu]</body></methods><methods><class-id>Tools.Trippy.PartListAbstractInspector class</class-id> <category>accessing</category><body package="Tools-Trippy" selector="pageSizeLimit">pageSizeLimit	"The maximum number of fields an inspector shows in an unsegmented view. If the number of fields is equal to or exceeds the value returned by this method, the segmented view is used."	^200</body></methods><methods><class-id>Tools.Trippy.DictionaryInspector</class-id> <category>private</category><body package="Tools-Trippy" selector="augmentEditMenu:">augmentEditMenu: aMenu	"Add appropriate things to the Edit dropdown menu of the shell inspector menu bar. "	aMenu addLine.	self addAddAndRemoveItemsTo: aMenu</body><body package="Tools-Trippy" selector="buildFieldListMenu">buildFieldListMenu	| menu |	menu := super buildFieldListMenu.	menu addLine.	self addAddAndRemoveItemsTo: menu.	^menu</body><body package="Tools-Trippy" selector="enumerateOwnersToIgnore:">enumerateOwnersToIgnore: aBlock	super enumerateOwnersToIgnore: aBlock.	linearizedParts do: aBlock</body><body package="Tools-Trippy" selector="partWithKey:">partWithKey: anObject	^linearizedParts detect: [:some | some key == anObject]</body><body package="Tools-Trippy" selector="refresh">refresh	"Keys in a dictionary are unordered, but for presentation arrange them	in the increasing order of their displayStrings. Do not use #collect: to collect	pairs, because #collect: coalesces equal elements, which we need to avoid."	| pairs |	pairs := OrderedCollection new: object size.	object keys do: 		[:each | pairs add: (Inspector safeDisplayStringOf: each) -&gt; each].	pairs := pairs asSortedCollection: [:a :b | a key &lt;= b key].	linearizedParts := pairs collect: [:each | KeyedElement of: object at: each value].	super refresh</body><body package="Tools-Trippy" selector="requestNewKey">requestNewKey	"Answer a new key to add to the dictionary.  nil is	a 'no answer' value since it is not a valid dictionary key."	| expression |	expression := Dialog request: (#AddNewKeyC &lt;&lt; #dialogs &gt;&gt; 'Add new key:') .	expression isEmpty ifTrue: [^nil].	^Compiler evaluate: expression</body></methods><methods><class-id>Tools.Trippy.DictionaryInspector</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="initialize">initialize	super initialize.	self valueOrKeyHolder		value: #value;		onChangeSend: #valueOrKeySelectionChanged to: self</body></methods><methods><class-id>Tools.Trippy.DictionaryInspector</class-id> <category>aspects</category><body package="Tools-Trippy" selector="valueOrKeyHolder">valueOrKeyHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^valueOrKeyHolder isNil		ifTrue:			[valueOrKeyHolder := nil asValue]		ifFalse:			[valueOrKeyHolder]</body></methods><methods><class-id>Tools.Trippy.DictionaryInspector</class-id> <category>properties</category><body package="Tools-Trippy" selector="dragControllerClass">dragControllerClass	^InsertReplaceDragController</body></methods><methods><class-id>Tools.Trippy.DictionaryInspector</class-id> <category>actions</category><body package="Tools-Trippy" selector="add">add	| newKey newPart |	newKey := self requestNewKey.	newKey isNil ifTrue: [^self].	object at: newKey put: nil.	self refresh.	newPart := self partWithKey: newKey.	self 		rememberUndo: (InsertionUndo new savedValues: (Array with: newPart));		select: newPart</body><body package="Tools-Trippy" selector="dive">dive	self container diveInto: self selection</body><body package="Tools-Trippy" selector="drop:before:">drop: partCollection before: aPart	self pasteIntoSelf: partCollection</body><body package="Tools-Trippy" selector="dropFromSame:before:">dropFromSame: aBundle before: keyObject	"Moving items within a dictionary does not mean much so we ignore it."</body><body package="Tools-Trippy" selector="pasteIntoSelf:">pasteIntoSelf: partCollection	| additions |	additions := OrderedCollection new.	partCollection do: 		[:each | 		object at: each key put: each value.		additions add: (KeyedElement of: object at: each key)].	self rememberUndo: (InsertionUndo new savedValues: additions).	self		refresh;		selectAll: additions</body><body package="Tools-Trippy" selector="removeSelected">removeSelected	"Remove the selected elements."	self rememberUndo: self createRemovalUndo.	self selections do: [:each | object removeKey: each key].	self refresh</body><body package="Tools-Trippy" selector="undoInsertion:">undoInsertion: anInsertionUndo	anInsertionUndo savedValues do:		[:each | object removeKey: each key ifAbsent: []].	self refresh</body><body package="Tools-Trippy" selector="undoRemoval:">undoRemoval: aRemovalUndo	aRemovalUndo savedValues do:		[:each | object at: each part key put: each value].	self 		refresh; 		selectAll: aRemovalUndo parts</body><body package="Tools-Trippy" selector="valueOrKeySelectionChanged">valueOrKeySelectionChanged	self textHolder value: self computeText</body></methods><methods><class-id>Tools.Trippy.DictionaryInspector</class-id> <category>decomposing</category><body package="Tools-Trippy" selector="partAt:">partAt: anIndex	^linearizedParts at: anIndex</body><body package="Tools-Trippy" selector="partCount">partCount	^linearizedParts size</body></methods><methods><class-id>Tools.Trippy.DictionaryInspector</class-id> <category>accessing</category><body package="Tools-Trippy" selector="selection">selection	| selection |	selection := super selection.	^self valueOrKeyHolder value = #value		ifTrue: [selection]		ifFalse: [DerivedAttribute 			label: ((#key1s &lt;&lt; #dialogs &gt;&gt; 'key &lt;1s&gt;')			expandMacrosWith: selection key displayString)			value: selection key]</body><body package="Tools-Trippy" selector="selections">selections	| selections |	selections := super selections.	^self valueOrKeyHolder value = #value		ifTrue: [selections]		ifFalse: [selections collect:			[:each |			DerivedAttribute 				label: ((#key1s &lt;&lt; #dialogs &gt;&gt; 'key &lt;1s&gt;')					expandMacrosWith: each key displayString)				value: each key]]</body></methods><methods><class-id>Tools.Trippy.DictionaryInspector class</class-id> <category>accessing</category><body package="Tools-Trippy" selector="tabLabel">tabLabel	^(#_Elements &lt;&lt; #dialogs &gt;&gt; '&amp;Elements')</body></methods><methods><class-id>Tools.Trippy.PoolDictionaryInspector</class-id> <category>private</category><body package="Tools-Trippy" selector="addPoolItemsTo:">addPoolItemsTo: aMenu	aMenu addItem: 		((MenuItem labeled: (#References &lt;&lt; #menus &gt;&gt; 'Re&amp;ferences'))			nameKey: #poolReferences;			value: [self browseReferences];			enabled: [self hasSingleSelection]).	object == Undeclared ifTrue:		[aMenu addItem: 			((MenuItem labeled: (#PurgeUnusedBindings &lt;&lt; #menus &gt;&gt; 'Purge &amp;Unused Bindings'))				nameKey: #poolPurgeUnused;				value: [self purgeUnusedBindings])]</body><body package="Tools-Trippy" selector="augmentEditMenu:">augmentEditMenu: aMenu	aMenu addLine.	self addPoolItemsTo: aMenu</body><body package="Tools-Trippy" selector="buildFieldListMenu">buildFieldListMenu	| menu |	menu := super buildFieldListMenu.	menu addLine.	self addPoolItemsTo: menu.	^menu</body><body package="Tools-Trippy" selector="requestNewKey">requestNewKey	"Answer a new key to add to the dictionary.  nil is	a 'no answer' value since it is not a valid dictionary key.	Keys of pools should be valid variable names. "	| newKey |	newKey := Dialog request: (#AddNewVariableColon &lt;&lt; #dialogs &gt;&gt; 'Add new variable:') .	newKey isEmpty ifTrue: [^nil].	^SystemUtils validateName: newKey</body></methods><methods><class-id>Tools.Trippy.PoolDictionaryInspector</class-id> <category>actions</category><body package="Tools-Trippy" selector="browseReferences">browseReferences	"Browse references to the selected binding. If the 	 inspected object is Undeclared then restrict the set 	 to just references to the binding, excluding 	 references to the binding's key, etc."	| mc binding list |	mc := MethodCollector new.	binding := object bindingFor: self selection key.	list := mc referencesTo: binding.	object == Undeclared ifTrue:		[list := list &amp; (mc methodsSelect:				[:cm | | found |				found := false.				[:exit|				cm withAllBlockMethodsDo:					[:m|					(m literals anySatisfy:							[:ea |							(ea isVariableBinding and: [ea binding == binding])							or: [ea isBindingReference and: [ea bindingOrNil == binding]]])						ifTrue: [found := true. exit value]]] valueWithExit.				found])].	mc browseSelect: list</body><body package="Tools-Trippy" selector="pasteIntoSelf:">pasteIntoSelf: partCollection	"Unlike the superclass, I cannot use just anything as the variable name."	| additions |	additions := OrderedCollection new.	partCollection do: 		[:each | | name |		name := each asVariableName asSymbol.		object at: name put: each value.		additions add: (KeyedElement of: object at: name)].	self rememberUndo: (InsertionUndo new savedValues: additions).	self		refresh;		selectAll: additions</body><body package="Tools-Trippy" selector="purgeUnusedBindings">purgeUnusedBindings	Cursor execute showWhile: [object purgeUnusedBindings].	self refresh</body></methods><methods><class-id>Tools.Trippy.SetInspector</class-id> <category>private</category><body package="Tools-Trippy" selector="augmentEditMenu:">augmentEditMenu: aMenu	"Add appropriate things to the Edit dropdown menu of the shell inspector menu bar. "	aMenu addLine.	self addAddAndRemoveItemsTo: aMenu</body><body package="Tools-Trippy" selector="buildFieldListMenu">buildFieldListMenu	| menu |	menu := super buildFieldListMenu.	menu addLine.	self addAddAndRemoveItemsTo: menu.	^menu</body><body package="Tools-Trippy" selector="createInsertionUndo:before:">createInsertionUndo: aCollection before: ignoredPart	| actuallyAdded |	actuallyAdded := OrderedCollection new.	aCollection do:		[:value |		(object includes: value) ifFalse: [actuallyAdded add: value]].	^InsertionUndo new		newKeys: actuallyAdded</body><body package="Tools-Trippy" selector="enumerateOwnersToIgnore:">enumerateOwnersToIgnore: aBlock	super enumerateOwnersToIgnore: aBlock.	linearized do: aBlock</body><body package="Tools-Trippy" selector="refresh">refresh	"Arrange the elements in the increasing order of their displayStrings.	Cannot use #collect: to create the pairs collections because #collect:	coalesces equal identity set elements."	| pairs |	pairs := OrderedCollection new: object size.	object do: [:each | pairs add: (Inspector safeDisplayStringOf: each) -&gt; each].	pairs := pairs asSortedCollection: [:a :b | a key &lt;= b key].	linearized := pairs collect: [:each | SetElement of: object element: each value].	super refresh</body><body package="Tools-Trippy" selector="replaceAllSelections:with:">replaceAllSelections: partCollection with: newValue	| newPart |	(Dialog confirm: (#ReplaceAllSelectedWithNewValue &lt;&lt; #dialogs &gt;&gt; 'Remove all these set elementsreplacing them with the single new value?'))		ifFalse: [^self].	newPart := SetElement of: object element: newValue.	self rememberUndo: 		(UndoActionGroup			with: (InsertionUndo new newKeys: (Array with: newValue))			with: self createRemovalUndo).	partCollection do: [:each | object remove: each element].	object add: newValue.	self		refresh;		select: newPart</body><body package="Tools-Trippy" selector="replaceSelectionsWith:">replaceSelectionsWith: newValue	| selections |	selections := self selections.	selections := selections reject: [:some | some isReadOnly].	selections isEmpty ifTrue: [^self].	selections size = 1		ifTrue: [self replaceSingleSelection: selections first with: newValue]		ifFalse: [self replaceAllSelections: selections with: newValue]</body><body package="Tools-Trippy" selector="replaceSingleSelection:with:">replaceSingleSelection: aPart with: newValue	self rememberUndo: (self createReplacementUndo: (Array with: aPart)).	aPart value: newValue.	self refresh; select: aPart</body></methods><methods><class-id>Tools.Trippy.SetInspector</class-id> <category>actions</category><body package="Tools-Trippy" selector="add">add	| expression newValue |	expression := Dialog request: (#AddNewElementColon &lt;&lt; #dialogs &gt;&gt; 'Add new element:').	expression isEmpty ifTrue: [^self].	newValue := Compiler evaluate: expression.	(object includes: newValue) ifFalse:		[self rememberUndo:			(InsertionUndo new newKeys: (Array with: newValue))].	object add: newValue.	self		refresh;		select: (SetElement new element: newValue)</body><body package="Tools-Trippy" selector="drop:at:">drop: partCollection at: aPart	"Dropping onto an element removes that element and replaces it with the one dropped."	| replacement |	replacement := self		pickSingleObjectIn: partCollection		ifCancelled: [^self].	self rememberUndo: 		(ReplacementUndo new savedValues: (Array with: aPart)).	object		remove: aPart element;		add: replacement.	aPart element: replacement.	self		refresh;		select: aPart</body><body package="Tools-Trippy" selector="drop:before:">drop: partCollection before: aPart	"Dropping things adds to a set; where the objects were dropped does not matter."	| added |	added := OrderedCollection new: partCollection size.	partCollection do: 		[:each | | element |		element := each value.		object add: element.		added add: (SetElement of: object element: element)].	self		refresh;		selectAll: added</body><body package="Tools-Trippy" selector="dropFromSame:at:">dropFromSame: aBundle at: anIndex	"Dropping an element onto another element within a set does not mean anything."</body><body package="Tools-Trippy" selector="dropFromSame:before:">dropFromSame: aBundle before: anIndex	"Dragging an element of a set to another location does not mean anything."</body><body package="Tools-Trippy" selector="pasteIntoSelf:">pasteIntoSelf: snapCollection	| added |	added := snapCollection collect: [:each | each value].	self rememberUndo: (self createInsertionUndo: added before: 0).	object addAll: added.	self		refresh;		selectAll: (snapCollection collect: [:each | each part])</body><body package="Tools-Trippy" selector="removeSelected">removeSelected	self rememberUndo: self createRemovalUndo.	object removeAll: (self selections collect: [:each | each element]).	self refresh</body><body package="Tools-Trippy" selector="undoInsertion:">undoInsertion: anInsertionUndo	object removeAll: anInsertionUndo newKeys.	self refresh</body><body package="Tools-Trippy" selector="undoRemoval:">undoRemoval: aRemovalUndo	aRemovalUndo savedValues do:		[:each | object add: each value].	self 		refresh; 		selectAll: aRemovalUndo parts</body><body package="Tools-Trippy" selector="undoReplacement:">undoReplacement: aReplacementUndo	| reinstated |	reinstated := OrderedCollection new.	aReplacementUndo savedValues do:		[:each | | oldElement |		object remove: each part value.		object add: (oldElement := each value).		reinstated add: (SetElement of: object element: oldElement)].	self 		refresh;		selectAll: reinstated</body></methods><methods><class-id>Tools.Trippy.SetInspector</class-id> <category>properties</category><body package="Tools-Trippy" selector="dragControllerClass">dragControllerClass	^InsertReplaceDragController</body></methods><methods><class-id>Tools.Trippy.SetInspector</class-id> <category>accessing</category><body package="Tools-Trippy" selector="partAt:">partAt: anInteger	^linearized at: anInteger</body><body package="Tools-Trippy" selector="partCount">partCount	^linearized size</body></methods><methods><class-id>Tools.Trippy.SetInspector class</class-id> <category>accessing</category><body package="Tools-Trippy" selector="tabLabel">tabLabel	^(#_Elements &lt;&lt; #dialogs &gt;&gt; '&amp;Elements')</body></methods><methods><class-id>Tools.Trippy.BasicInspector</class-id> <category>properties</category><body package="Tools-Trippy" selector="dragControllerClass">dragControllerClass	^ReplaceOnlyDragController</body></methods><methods><class-id>Tools.Trippy.BasicInspector</class-id> <category>private</category><body package="Tools-Trippy" selector="augmentEditMenu:">augmentEditMenu: aMenu	"Add appropriate things to the Edit dropdown menu of the shell inspector menu bar. "	aMenu addLine.	self addAddAndRemoveItemsTo: aMenu</body><body package="Tools-Trippy" selector="buildFieldListMenu">buildFieldListMenu	| menu |	menu := super buildFieldListMenu.	menu addLine.	self addAddAndRemoveItemsTo: menu.	^menu</body><body package="Tools-Trippy" selector="classDefining:for:">classDefining: aString for: aClass	"The instance variable might be defined by either the argument class	or one of its superclasses."	^aClass withAllSuperclasses		detect: [:some | some instVarNames includes: aString]</body><body package="Tools-Trippy" selector="confirmInstVarRemoval:">confirmInstVarRemoval: stringCollection	| message |	message := (String new: 100) writeStream.	stringCollection size = 1 		ifTrue: [message nextPutAll: (#RemoveInstanceVariable &lt;&lt; #dialogs &gt;&gt; 'Remove instance variable ') asString]		ifFalse: [message nextPutAll: (#ConfirmRemoveInstVar &lt;&lt; #dialogs &gt;&gt; 'Remove the following instance variables:') asString; cr].	stringCollection 		do: [:each | message nextPut: $"; nextPutAll: each; nextPut: $"]		separatedBy: [message nextPutAll: ', '].	message nextPutAll: '?'.	^Dialog confirm: message contents</body><body package="Tools-Trippy" selector="createRemovalUndo:">createRemovalUndo: partCollection	| classes |	classes := partCollection collect:		[:each | self classDefining: each name for: self object class].	^InstVarRemovalUndo new		savedValues: partCollection;		definingClasses: classes;		yourself</body><body package="Tools-Trippy" selector="derivedFields">derivedFields	^[object inspectorExtraAttributes]		on: MessageNotUnderstood		do: [:ex | ex return: Array new]</body><body package="Tools-Trippy" selector="isValidInstVarName:">isValidInstVarName: aString	^aString isEmpty not 		and: [aString first isLetter 			and: [(aString contains: [:some | (some isLetter or: [some isDigit]) not]) not]]</body><body package="Tools-Trippy" selector="namedFields">namedFields	| protected |	protected := self protectedVariableNames.	^object class allInstVarNames collect: 		[:each | | part |		part := NamedVariable of: object named: each.		(protected includes: each) ifTrue: [part beProtected].		part]</body><body package="Tools-Trippy" selector="partWithKey:">partWithKey: aString	^fixedFields detect: [:some | some key = aString]</body><body package="Tools-Trippy" selector="promptForValidInstVarName">promptForValidInstVarName	| name |	name := String new.	[name := (Dialog request: (#AddInstanceVariableNamedC &lt;&lt; #dialogs &gt;&gt; 'Add instance variable named:') initialAnswer: name) trimBlanks.	name isEmpty ifTrue: [^nil].	(self isValidInstVarName: name)		ifFalse: [(Dialog confirm: (#InvalidVariableName &lt;&lt; #dialogs &gt;&gt; 'Invalid variable name. Try again?')) ifFalse: [^nil]]		ifTrue:			[(self object class allInstVarNames includes: name)				ifTrue:					[(Dialog confirm: (#InstVarAlreadyExistsRetry &lt;&lt; #dialogs &gt;&gt; 'An instance variable by this name already exists. Try again?'))						ifFalse: [^nil]]				ifFalse: [^name]]	] repeat</body><body package="Tools-Trippy" selector="protectedVariableNames">protectedVariableNames	"Answer a collection with names of all variables declared as protected	by the class of the inspected object and its superclasses."	^object class withAllSuperclasses		inject: Set new		into: [:all :each | 			all 				addAll: each protectedInstVarNames; 				yourself]</body><body package="Tools-Trippy" selector="refresh">refresh	fixedFields := 		(Array with: self selfAttribute), 		self derivedFields,		self namedFields.	super refresh</body><body package="Tools-Trippy" selector="removeInstVarName:from:">removeInstVarName: aString from: aClass	"The instance variable might be defined by either the argument class	or one of its superclasses."	(self classDefining: aString for: aClass)		removeInstVarName: aString</body><body package="Tools-Trippy" selector="selfAttribute">selfAttribute	| label |	label := object isImmutable		ifTrue: ['self #']		ifFalse: ['self'].	^DerivedAttribute label: label value: object</body></methods><methods><class-id>Tools.Trippy.BasicInspector</class-id> <category>decomposing</category><body package="Tools-Trippy" selector="partAt:">partAt: anInteger	"The order of the parts is: derived fields, named ivars, indexed ivars."	anInteger &lt;= fixedFields size ifTrue: [^fixedFields at: anInteger].	^IndexedVariable of: object at: anInteger - fixedFields size</body><body package="Tools-Trippy" selector="partCount">partCount	^fixedFields size + object basicSize</body></methods><methods><class-id>Tools.Trippy.BasicInspector</class-id> <category>testing</category><body package="Tools-Trippy" selector="canDive">canDive	^self hasSingleSelection and: [self selection hasValue]</body><body package="Tools-Trippy" selector="canRemoveParts">canRemoveParts	^(self selections contains: [:some | some isNamedVariable not]) not</body></methods><methods><class-id>Tools.Trippy.BasicInspector</class-id> <category>actions</category><body package="Tools-Trippy" selector="add">add	| name newPart |	name := self promptForValidInstVarName.	name isNil ifTrue: [^self].	(self object class allInstVarNames includes: name) ifTrue:		[Dialog warn: (#InstVarAlreadyExists &lt;&lt; #dialogs &gt;&gt; 'An instance variable by this name already exists.').		^self].	self object class addInstVarName: name.	self refresh.	newPart := self partWithKey: name.	self 		rememberUndo: (InsertionUndo new savedValues: (Array with: newPart));		select: newPart</body><body package="Tools-Trippy" selector="removeSelected">removeSelected	| toRemove namesToRemove |	toRemove := self selections select: [:each | each isNamedVariable].	namesToRemove := toRemove collect: [:each | each name].	toRemove isEmpty ifTrue: [^self].	(self confirmInstVarRemoval: namesToRemove) ifTrue:		[self rememberUndo: (self createRemovalUndo: toRemove).		namesToRemove do: 			[:each | 			self removeInstVarName: each from: self object class].		self refresh]</body><body package="Tools-Trippy" selector="undoInsertion:">undoInsertion: anInsertionUndo	"Undo adding instance variables."	anInsertionUndo savedValues do:		[:each | self removeInstVarName: each key from: self object class].	self refresh</body><body package="Tools-Trippy" selector="undoRemoval:">undoRemoval: aRemovalUndo	"Put instance variables back into their classes and restore their values in this instance.	The tricky parts are:		- instance variables should be restored to the right classes		- parts saved in the undo action should be told to refresh their cached variable 			index because the order of the variables might have changed."	aRemovalUndo definingClasses with: aRemovalUndo savedValues do:		[:class :partSnapshot | class addInstVarName: partSnapshot part name].	aRemovalUndo savedValues do:		[:each |		each part 			refreshIndex;			value: each value].	self 		refresh;		selectAll: aRemovalUndo parts</body></methods><methods><class-id>Tools.Trippy.BasicInspector class</class-id> <category>accessing</category><body package="Tools-Trippy" selector="tabLabel">tabLabel	"Answer a String to use as the label of the tab of this page."	^(#_Basic &lt;&lt; #dialogs &gt;&gt; '&amp;Basic')</body></methods><methods><class-id>Tools.Trippy.PreviewingInspector</class-id> <category>accessing</category><body package="Tools-Trippy" selector="preview">preview	^VisualComponentProxy on:		((self object isKindOf: ScheduledWindow)			ifTrue: [self object component]			ifFalse: [self object])</body></methods><methods><class-id>Tools.Trippy.PreviewingInspector class</class-id> <category>accessing</category><body package="Tools-Trippy" selector="tabLabel">tabLabel	^(#_Preview &lt;&lt; #dialogs &gt;&gt; '&amp;Preview')</body></methods><methods><class-id>Tools.Trippy.InstVarRemovalUndo</class-id> <category>accessing</category><body package="Tools-Trippy" selector="definingClasses">definingClasses	^definingClasses</body><body package="Tools-Trippy" selector="definingClasses:">definingClasses: aCollection	aCollection size ~= savedValues size		ifTrue: [self error: (#InvalidDefiningClasses &lt;&lt; #dialogs &gt;&gt; 'invalid defining class collection')].	definingClasses := aCollection</body></methods><methods><class-id>Tools.Trippy.SequenceInspector</class-id> <category>private</category><body package="Tools-Trippy" selector="augmentEditMenu:">augmentEditMenu: aMenu	"Add appropriate things to the Edit dropdown menu of the shell inspector menu bar. "	aMenu addLine.	self addAddAndRemoveItemsTo: aMenu</body><body package="Tools-Trippy" selector="buildFieldListMenu">buildFieldListMenu	| menu |	menu := super buildFieldListMenu.	menu addLine.	self addAddAndRemoveItemsTo: menu.	^menu</body><body package="Tools-Trippy" selector="createAppendInsertionUndo">createAppendInsertionUndo	"Create an undo object that undoes appening of one element at the end."	^InsertionUndo new		newKeys: (object size + 1 to: object size + 1)</body><body package="Tools-Trippy" selector="createInsertionUndo:before:">createInsertionUndo: indexCollection before: aPartOrNil	^InsertionUndo new newKeys: indexCollection</body><body package="Tools-Trippy" selector="keyAtIndex:">keyAtIndex: anIndex	^anIndex</body><body package="Tools-Trippy" selector="partWithKey:">partWithKey: anInteger	^KeyedElement new key: anInteger</body><body package="Tools-Trippy" selector="privateAdd:">privateAdd: anObject	"Add the argument to the object being inspected. Subclasses may override this if the notion of adding they support is different. For example, an Array inspector page would have to mutate the array to increase its size. Answer an index (key, in page terminology) of object just added. That index is used for selecting it."	object addLast: anObject.	^object size</body><body package="Tools-Trippy" selector="privateInsertAll:beforeIndex:">privateInsertAll: aCollection beforeIndex: anIndex	"Insert elements of the argument collection into the object being inspected. Subclasses may override this if the notion of insertion they support is different. Answer indices (keys, in page terminology) of objects just added."	aCollection reverseDo:		[:each | object add: each beforeIndex: anIndex].	^anIndex to: anIndex + aCollection size - 1</body><body package="Tools-Trippy" selector="privateMoveAllAtIndices:beforeIndex:">privateMoveAllAtIndices: aCollection beforeIndex: anIndex	"Reposition elements at indices listed in aCollection so that they are all located at indices {anIndex, anIndex+1, ...}. The size of the resulting collection is the same as that of the original."	| scratch mobile insertionPoint |	scratch := object copy.	aCollection asSortedCollection reverseDo: [:each | scratch removeAtIndex: each].	mobile := aCollection collect: [:each | object at: each].	insertionPoint := aCollection		inject: anIndex		into: [:result :index | index &lt; anIndex ifTrue: [result - 1] ifFalse: [result]].	mobile reverseDo:		[:each | scratch add: each beforeIndex: insertionPoint].	object replaceFrom: 1 to: object size with: scratch startingAt: 1.	^insertionPoint to: insertionPoint + aCollection size - 1</body><body package="Tools-Trippy" selector="privateRemoveAtIndices:">privateRemoveAtIndices: anIntegerCollection	"Remove elements of the object being inspected with indices listed in the argument array."	anIntegerCollection asSortedCollection reverseDo:		[:anIndex | object removeAtIndex: anIndex]</body><body package="Tools-Trippy" selector="selectIndices:">selectIndices: indexCollection	self selectAll: (indexCollection collect: [:each | KeyedElement of: object at: each])</body></methods><methods><class-id>Tools.Trippy.SequenceInspector</class-id> <category>properties</category><body package="Tools-Trippy" selector="dragControllerClass">dragControllerClass	^InsertReplaceDragController</body></methods><methods><class-id>Tools.Trippy.SequenceInspector</class-id> <category>actions</category><body package="Tools-Trippy" selector="add">add	| expression newValue newKey |	expression := Dialog request: (#AddNewElementColon &lt;&lt; #dialogs &gt;&gt; 'Add new element:').	expression isEmpty ifTrue: [^self].	newValue := Compiler evaluate: expression.	self rememberUndo: self createAppendInsertionUndo.	newKey := self privateAdd: newValue.	self		refresh;		select: (self partWithKey: newKey)</body><body package="Tools-Trippy" selector="drop:before:">drop: partCollection before: aPart	"Parts dropped from another object should be inserted."	| toInsert newIndices insertionIndex |	toInsert := partCollection collect: [:each | each value].	insertionIndex := aPart isNil		ifTrue: [self partCount + 1]		ifFalse: [aPart key].	newIndices := self		privateInsertAll: toInsert		beforeIndex: insertionIndex.	self rememberUndo: (self createInsertionUndo: newIndices before: aPart).	self		refresh;		selectIndices: newIndices</body><body package="Tools-Trippy" selector="dropFromSame:before:">dropFromSame: partCollection before: aPart	"A drop from same object reorders the collection."	| toMove newRange |	"won't handle undo for now"	toMove := partCollection collect: [:each | each key].	newRange := self 		privateMoveAllAtIndices: toMove 		beforeIndex: (aPart isNil 			ifTrue: [self partCount + 1] 			ifFalse: [aPart key]).	self		refresh;		selectIndices: newRange</body><body package="Tools-Trippy" selector="pasteIntoSelf:">pasteIntoSelf: partCollection	"A paste with no target selected ('self') means append."	| toInsert inserted |	toInsert := partCollection collect: [:each | each value].	inserted := self privateInsertAll: toInsert beforeIndex: self partCount + 1.	self rememberUndo:		(self createInsertionUndo: inserted before: nil).	self		refresh;		selectIndices: inserted</body><body package="Tools-Trippy" selector="removeSelected">removeSelected	"Remove the selected elements."	self rememberUndo: self createRemovalUndo.	self privateRemoveAtIndices: (self selections collect: [:each | each key]).	self refresh</body><body package="Tools-Trippy" selector="replaceWith:">replaceWith: newValue	| selections |	selections := self selections.	selections isEmpty ifTrue: [^self].	self rememberUndo: self createReplacementUndo.	selections do: [:each | each value: newValue].	self		refresh;		selectAll: selections</body><body package="Tools-Trippy" selector="undoInsertion:">undoInsertion: anInsertionUndo	self privateRemoveAtIndices: anInsertionUndo newKeys.	self refresh</body><body package="Tools-Trippy" selector="undoRemoval:">undoRemoval: aRemovalUndo	aRemovalUndo savedValues do:		[:each |		self			privateInsertAll: (Array with: each value)			beforeIndex: each part key].	self 		refresh; 		selectAll: aRemovalUndo parts</body></methods><methods><class-id>Tools.Trippy.SequenceInspector</class-id> <category>decomposing</category><body package="Tools-Trippy" selector="partAt:">partAt: anIndex	^KeyedElement of: object at: anIndex</body><body package="Tools-Trippy" selector="partCount">partCount	^object size</body></methods><methods><class-id>Tools.Trippy.SequenceInspector class</class-id> <category>accessing</category><body package="Tools-Trippy" selector="tabLabel">tabLabel	^(#_Elements &lt;&lt; #dialogs &gt;&gt; '&amp;Elements')</body></methods><methods><class-id>Tools.Trippy.ArrayInspector</class-id> <category>private</category><body package="Tools-Trippy" selector="privateAdd:">privateAdd: anObject	"Yes we can resize arrays in the inspector. It can be handy so why not?"	| newObject |	newObject := object copyWith: anObject.	newObject become: object.	^object size</body><body package="Tools-Trippy" selector="privateInsertAll:beforeIndex:">privateInsertAll: aCollection beforeIndex: anIndex	"Insert elements of the argument collection into the array being inspected."	| newObject |	newObject := object class new: object size + aCollection size.	newObject		replaceFrom: 1 to: anIndex - 1 with: object startingAt: 1;		replaceFrom: anIndex to: anIndex + aCollection size - 1 with: aCollection startingAt: 1;		replaceFrom: anIndex + aCollection size to: newObject size with: object startingAt: anIndex.	newObject become: object.	^anIndex to: anIndex + aCollection size - 1</body><body package="Tools-Trippy" selector="privateMoveAllAtIndices:beforeIndex:">privateMoveAllAtIndices: aCollection beforeIndex: anIndex	"Reposition elements at indices listed in aCollection so that they are all 	located at indices {anIndex, anIndex+1, ...}. The size of the resulting collection 	is the same as that of the original."	| static mobile insertionPoint newObject |	static := object copy asOrderedCollection.	aCollection asSortedCollection reverseDo: [:each | static removeAtIndex: each].	mobile := aCollection collect: [:each | object at: each].	insertionPoint := aCollection		inject: anIndex		into: [:result :index | index &lt; anIndex ifTrue: [result - 1] ifFalse: [result]].	newObject := object class new: object size.	newObject		replaceFrom: 1 to: insertionPoint - 1 with: static startingAt: 1;		replaceFrom: insertionPoint to: insertionPoint + mobile size - 1 with: mobile startingAt: 1;		replaceFrom: insertionPoint + mobile size to: newObject size with: static startingAt: insertionPoint.	newObject become: object.	^insertionPoint to: insertionPoint + aCollection size - 1</body><body package="Tools-Trippy" selector="privateRemoveAtIndices:">privateRemoveAtIndices: anIntegerCollection	"Remove elements of the object being inspected with indices	listed in the argument array."	| newObject toRemove targetIndex |	toRemove := anIntegerCollection asSet.	newObject := object class new: object size - toRemove size.	targetIndex := 1.	1 to: object size do:		[:sourceIndex |		(toRemove includes: sourceIndex) ifFalse:			[newObject at: targetIndex put: (object at: sourceIndex).			targetIndex := targetIndex + 1]].	newObject become: object</body></methods><methods><class-id>Tools.Trippy.ArrayInspector class</class-id> <category>accessing</category><body package="Tools-Trippy" selector="tabLabel">tabLabel	^(#_Elements &lt;&lt; #dialogs &gt;&gt; '&amp;Elements')</body></methods><methods><class-id>Tools.Trippy.InspectorShell</class-id> <category>testing</category><body package="Tools-Trippy" selector="canDive">canDive	^self hasCurrentInspector and: [self inspector canDive]</body><body package="Tools-Trippy" selector="canExploreParts">canExploreParts	^installedNavigator vicinity ~~ #parts		and: [self inspector isPartList]</body><body package="Tools-Trippy" selector="canExploreSiblings">canExploreSiblings	^self visit hasOwner and: [installedNavigator vicinity ~~ #owner]</body><body package="Tools-Trippy" selector="canFocus">canFocus	^installedNavigator vicinity ~~ #none</body><body package="Tools-Trippy" selector="canGoBack">canGoBack	^current &gt; 1</body><body package="Tools-Trippy" selector="canGoForward">canGoForward	^current &lt; trail size</body><body package="Tools-Trippy" selector="clipboardNotEmpty">clipboardNotEmpty	^Clipboard default notEmpty</body><body package="Tools-Trippy" selector="hasCurrentInspector">hasCurrentInspector	^current &gt; 0</body><body package="Tools-Trippy" selector="notExploringVisited">notExploringVisited	^installedNavigator vicinity ~~ #visited</body></methods><methods><class-id>Tools.Trippy.InspectorShell</class-id> <category>private-evaluation</category><body package="Tools-Trippy" selector="doItContext">doItContext	"Answer the context in which a text selection can be evaluated."	^nil</body><body package="Tools-Trippy" selector="doItReceiver">doItReceiver	"Answer the object in which context the text selection is evaluated."	^self object</body><body package="Tools-Trippy" selector="evaluatorEditor">evaluatorEditor	^(builder componentAt: #evaluator) widget controller</body></methods><methods><class-id>Tools.Trippy.InspectorShell</class-id> <category>aspects</category><body package="Tools-Trippy" selector="menuBarHolder">menuBarHolder	^menuBarHolder</body><body package="Tools-Trippy" selector="textHolder">textHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^textHolder isNil		ifTrue:			[textHolder := String new asValue]		ifFalse:			[textHolder]</body></methods><methods><class-id>Tools.Trippy.InspectorShell</class-id> <category>actions</category><body package="Tools-Trippy" selector="back">back	"Go back to the previously visited page, if any."	self inspector changeRequest ifFalse: [^self].	current := 1 max: current - 1.	self refresh</body><body package="Tools-Trippy" selector="compareObjectToClipboard">compareObjectToClipboard	| clipboardObjects report |	clipboardObjects := Clipboard default get.	clipboardObjects isEmpty ifTrue:		[^Dialog warn: (#TheClipboardIsEmpty &lt;&lt; #dialogs &gt;&gt; 'The clipboard is empty.')].	report := clipboardObjects size = 1		ifTrue: [self compareObjectToOne: clipboardObjects first]		ifFalse: [self compareObjectToMany: clipboardObjects ifCancelled: [^self]].	Dialog warn: report</body><body package="Tools-Trippy" selector="dive">dive	"The inspector should take care of diving since it	knows what it wants to dive into."	self inspector dive</body><body package="Tools-Trippy" selector="diveIntoClass">diveIntoClass	"Dive into the class of the current object."	self diveInto: (DerivedAttribute label: 'class' value: self object class)</body><body package="Tools-Trippy" selector="emptyClipboard">emptyClipboard	Clipboard default empty</body><body package="Tools-Trippy" selector="forward">forward	"Go forward to the following visited page, if any."	self inspector changeRequest ifFalse: [^self].	current := trail size min: current + 1.	self refresh</body><body package="Tools-Trippy" selector="goTo:">goTo: anIndex	"Switch to the page at the specific index on the visit history list."	current := 1 max: (anIndex min: trail size).	self refresh</body><body package="Tools-Trippy" selector="helpAbout">helpAbout	AboutVisualWorksDialog open</body><body package="Tools-Trippy" selector="helpInspectingObjects">helpInspectingObjects	SmalltalkWorkbench		openHelpBook: 'Development with VisualWorks' 		topic: 'Inspecting Objects'</body><body package="Tools-Trippy" selector="helpInspector">helpInspector	SmalltalkWorkbench		openHelpBook: 'VisualWorks Tools' 		topic: 'Inspector'</body><body package="Tools-Trippy" selector="inspectClipboard">inspectClipboard	| parts object |	parts := Clipboard default get.	parts size = 0  ifTrue:		[^Dialog warn: (#TheClipboardIsEmpty &lt;&lt; #dialogs &gt;&gt; 'The clipboard is empty.')].	object := parts size = 1		ifTrue: [parts first value]		ifFalse: [parts collect: [:each | each value]].	object inspect</body><body package="Tools-Trippy" selector="selectAll">selectAll	self inspector selectAll</body><body package="Tools-Trippy" selector="toggleEvaluationPane">toggleEvaluationPane 	evaluationPaneVisible := evaluationPaneVisible not.	EvaluationPaneWasLastShown := evaluationPaneVisible.	self setEvaluatorLayout.	builder window refresh.	evaluationPaneVisible ifTrue:		[(builder componentAt: #evaluator) takeKeyboardFocus]</body><body package="Tools-Trippy" selector="toggleToolbar">toggleToolbar	self builder window toolbarVisible:		self builder window toolbarVisible not</body></methods><methods><class-id>Tools.Trippy.InspectorShell</class-id> <category>private</category><body package="Tools-Trippy" selector="addToTrail:">addToTrail: aNavigator	trail := trail copyFrom: 1 to: current.	trail addLast: aNavigator.	current := current + 1</body><body package="Tools-Trippy" selector="compareObjectToMany:ifCancelled:">compareObjectToMany: partCollection ifCancelled: aBlock	| part |	part := Dialog		choose: (#InspectorClipboardHasMultipleObjects &lt;&lt; #dialogs &gt;&gt; 'The clipboard contains multiple objects. Select one:')		fromList: (partCollection collect: [:each | each value displayString])		values: partCollection		lines: 10		cancel: aBlock		for: self builder window.	^self compareObjectToOne: part</body><body package="Tools-Trippy" selector="compareObjectToOne:">compareObjectToOne: partSnapshot	| thisObject clipboardObject report |	thisObject := self inspector selectedObjectOrInspectedObject.	clipboardObject := partSnapshot value.	report := TextStream on: (String new: 100).	report		nextPutAllText: 'Comparing object: ';		nextPutAllText: thisObject basicPrintString asText allBold; cr;		nextPutAllText: ' to clipboardObject: ';		nextPutAllText: clipboardObject basicPrintString asText allBold; cr; cr;		nextPutAllText: 'object == clipboardObject: ';		nextPutAllText: (self formattedResultOf: [thisObject == clipboardObject]); cr;		nextPutAllText: 'object = clipboardObject: ';		nextPutAllText: (self formattedResultOf: [thisObject = clipboardObject]); cr;		nextPutAllText: 'clipboardObject = object: ';		nextPutAllText: (self formattedResultOf: [clipboardObject = thisObject]).	^report contents</body><body package="Tools-Trippy" selector="diveIntoCollaborator:">diveIntoCollaborator: aCollaborator	self diveInto: (aCollaborator asPartOf: self object)</body><body package="Tools-Trippy" selector="dividerFraction">dividerFraction	^evaluationPaneVisible		ifTrue: [0.6]		ifFalse: [1]</body><body package="Tools-Trippy" selector="dividerOffset">dividerOffset	^evaluationPaneVisible		ifTrue: [-2]		ifFalse: [0]</body><body package="Tools-Trippy" selector="formattedResultOf:">formattedResultOf: aBlock	| result |	result := aBlock		on: Error		do: [:ex | ^(#errorC1s &lt;&lt; #dialogs &gt;&gt; '[error: &lt;1s&gt;]') expandMacrosWith: ex description].	^result printString asText allBold</body><body package="Tools-Trippy" selector="install:">install: aNavigator	| subBuilder |	aNavigator builder: nil.	installedNavigator := aNavigator.	(self builder componentAt: #navigator) widget		client: aNavigator		spec: #windowSpec		builder: (subBuilder := builder newSubBuilder).	aNavigator installedWith: subBuilder</body><body package="Tools-Trippy" selector="privateChangeRequest">privateChangeRequest	| choice |	self inspector changeRequest ifFalse: [^false].	self evaluatorEditor accepted ifTrue: [^true].	choice := Dialog 		choose: (#CodeHasBeenChanged &lt;&lt; #dialogs &gt;&gt; 'The code in the evaluation pane has been changed.Remember it for future use?') 		labels: (Array with: (#Yes &lt;&lt; #dialogs &gt;&gt; 'Yes') with: (#No &lt;&lt; #dialogs &gt;&gt; 'No') with: (#Cancel &lt;&lt; #dialogs &gt;&gt; 'Cancel')) 		values: #(yes no cancel) 		default: #yes.	choice = #cancel ifTrue: [^false].	choice = #yes ifTrue: [self evaluatorEditor accept].	^true</body><body package="Tools-Trippy" selector="refresh">refresh	"Completely rebuild the UI."	self		install: (trail at: current);		refreshMenuBar;		refreshToolbar;		refreshWindowLabel</body><body package="Tools-Trippy" selector="refreshToolbar">refreshToolbar	| toolbar |	toolbar := builder componentAt: #toolbar.	(toolbar componentAt: #back) isEnabled: self canGoBack.	(toolbar componentAt: #forward) isEnabled: self canGoForward.	(toolbar componentAt: #focus) isEnabled: self canFocus.	(toolbar componentAt: #exploreSiblings) isEnabled: self canExploreSiblings.	(toolbar componentAt: #exploreVisited) isEnabled: self notExploringVisited</body><body package="Tools-Trippy" selector="refreshWindowLabel">refreshWindowLabel	builder window label: self visit displayString</body><body package="Tools-Trippy" selector="resetTrailFor:">resetTrailFor: aVisit	| result thisVisit |	(trail includes: [:some | some visit == aVisit]) ifTrue:		[^self].	result := OrderedCollection new.	thisVisit := aVisit.	[thisVisit notNil] whileTrue:		[result add: (NullNavigator visit: thisVisit shell: self).		thisVisit := thisVisit owner].	trail := result reverse.	current := trail size</body><body package="Tools-Trippy" selector="resetTrailForNew:">resetTrailForNew: aVisit	| result thisVisit |	trail last visit = aVisit owner ifTrue: [^self].	result := OrderedCollection new.	thisVisit := aVisit owner.	[thisVisit notNil] whileTrue:		[result add: (NullNavigator visit: thisVisit shell: self).		thisVisit := thisVisit owner].	trail := result reverse.	current := trail size</body><body package="Tools-Trippy" selector="setEvaluatorLayout">setEvaluatorLayout	| fraction offset |	fraction := self dividerFraction.	offset := self dividerOffset.	(builder componentAt: #navigator) component layout		bottomFraction: fraction;		bottomOffset: offset.	(builder componentAt: #splitter) component layout		topFraction: fraction;		topOffset: offset;		bottomFraction: fraction;		bottomOffset: offset negated.	(builder componentAt: #evaluatorPane) component layout		topFraction: fraction;		topOffset: offset negated</body></methods><methods><class-id>Tools.Trippy.InspectorShell</class-id> <category>privileged</category><body package="Tools-Trippy" selector="diveInto:">diveInto: aPart	"Sent by the current inspector to dive into the part of the	currently selected object. Because this affects the navigation environment,	it is the shell's responsibility."	| visit navigator |	visit := self visit 		visitOfPart: aPart		ifNone: [PartVisit part: aPart owner: self visit inspector: self inspector].	navigator := NullNavigator visit: visit shell: self.	self resetTrailForNew: visit.	self addToTrail: navigator.	self refresh</body><body package="Tools-Trippy" selector="doWithOwnersToIgnore:">doWithOwnersToIgnore: aBlock	"See the comment to Inspector&gt;&gt;doWithOwnersToIgnore: for a detailed explanation.	This class is the top component, therefore here we start trickling down enumerating	junk owners on our way."	self enumerateOwnersToIgnore: aBlock</body><body package="Tools-Trippy" selector="enumerateOwnersToIgnore:">enumerateOwnersToIgnore: aBlock	aBlock 		value: self;		value: builder window;		value: builder window component;		value: (self widgetAt: #evaluator).	origin enumerateOwnersToIgnore: aBlock.	trail do: [:each | each enumerateOwnersToIgnore: aBlock]</body><body package="Tools-Trippy" selector="focusObjectChanged">focusObjectChanged	"Some pages may replace the object they have been initially opened	on with another object. A hierarchy page does that when a new element	of a hierarchy is selected. This message is then sent to the shell to notify	it of the change."	self		refreshMenuBar;		refreshToolbar;		refreshWindowLabel</body><body package="Tools-Trippy" selector="partValueChanged:">partValueChanged: aPart	self visit forgetVisitOfPart: aPart</body><body package="Tools-Trippy" selector="revisit:">revisit: aVisit	self resetTrailFor: aVisit.	self refresh</body></methods><methods><class-id>Tools.Trippy.InspectorShell</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="initialize">initialize	super initialize.	current := 0.	evaluationPaneVisible := false.	textHolder := SharedTextHolder.	menuBarHolder := ValueHolder with: nil</body><body package="Tools-Trippy" selector="inspect:">inspect: anObject	| navigator |	origin := Visit object: anObject.	navigator := NullNavigator visit: origin shell: self.	trail := OrderedCollection with: navigator.	current := 1.	self refresh</body><body package="Tools-Trippy" selector="postBuildWith:">postBuildWith: aBuilder	evaluationPaneVisible := EvaluationPaneWasLastShown.	self setEvaluatorLayout.	self evaluatorEditor		initializeMenuForCode;		autoAccept: false</body></methods><methods><class-id>Tools.Trippy.InspectorShell</class-id> <category>private-page switches</category><body package="Tools-Trippy" selector="exploreFocus">exploreFocus	| navigator |	navigator := NullNavigator visit: self visit shell: self inspector: self inspector.	trail at: current put: navigator.	self refresh</body><body package="Tools-Trippy" selector="exploreHierarchy:">exploreHierarchy: aHierarchy	| navigator |	navigator := HierarchyNavigator		visit: self visit		hierarchy: aHierarchy		shell: self		inspector: self inspector.	self addToTrail: navigator.	self refresh</body><body package="Tools-Trippy" selector="exploreParts">exploreParts	| selection visit navigator |	self inspector isPartList ifFalse: [^self].	self inspector hasSingleSelection ifFalse:		[self inspector select: (self inspector partAt: 1)].	selection := self inspector selection.	selection hasValue ifFalse:		[self inspector select: (self inspector partAt: 1).		selection := self inspector selection].	visit := self visit 		visitOfPart: selection		ifNone: [PartVisit part: selection owner: self visit inspector: self inspector].	navigator := OwnerNavigator visit: visit shell: self.	navigator bePartsNavigator.	self addToTrail: navigator.	self refresh</body><body package="Tools-Trippy" selector="exploreSiblings">exploreSiblings	| navigator |	navigator := OwnerNavigator 		visit: self visit 		shell: self		inspector: self inspector.	trail at: current put: navigator.	self refresh</body><body package="Tools-Trippy" selector="exploreVisited">exploreVisited	| navigator |	navigator := VisitTreeNavigator new		initialize: origin		shell: self		initialVisit: self visit		inspector: self inspector.	self 		install: navigator;		refreshMenuBar;		refreshToolbar;		refreshWindowLabel</body><body package="Tools-Trippy" selector="showVicinity:">showVicinity: aSelector	| navigator |	navigator := self object perform: aSelector.	navigator 		initialize: self visit 		shell: self 		inspector: self inspector.	self addToTrail: navigator.	self refresh</body></methods><methods><class-id>Tools.Trippy.InspectorShell</class-id> <category>accessing</category><body package="Tools-Trippy" selector="changeRequest">changeRequest	^[self privateChangeRequest]		on: Error		do: [:ex | ex return: true]</body><body package="Tools-Trippy" selector="inspector">inspector	^self navigator inspector</body><body package="Tools-Trippy" selector="navigator">navigator	^installedNavigator</body><body package="Tools-Trippy" selector="object">object	^self inspector object</body><body package="Tools-Trippy" selector="visit">visit	^self navigator visit</body></methods><methods><class-id>Tools.Trippy.InspectorShell</class-id> <category>private-menus</category><body package="Tools-Trippy" selector="addCollaboratorItemsTo:">addCollaboratorItemsTo: aMenu	| collaborators item |	collaborators := [self object inspectorCollaborators]		on: MessageNotUnderstood 		do: [:ex | ex message selector == #inspectorCollaborators			ifTrue: [ex return: Array new]			ifFalse: [ex pass]].	collaborators do:		[:each |		item := MenuItem labeled: (#ToCollaborator &lt;&lt; #menus &gt;&gt; 'To &lt;1s&gt;' expandMacrosWith: each label).		item value: [self diveIntoCollaborator: each].		aMenu addItem: item]</body><body package="Tools-Trippy" selector="addExploreItemsTo:">addExploreItemsTo: aMenu	| hierarchies |	hierarchies := self object inspectorHierarchies.	hierarchies isEmpty ifFalse:		[aMenu addLine.		hierarchies do:			[:each | | item |			item := MenuItem labeled: each label.			item value: [self exploreHierarchy: each].			self navigator vicinity = each id ifTrue: [item beOn].			aMenu addItem: item]]</body><body package="Tools-Trippy" selector="buildExploreSubmenu">buildExploreSubmenu	| aSubmenu |	aSubmenu := self class baseExploreMenu.	installedNavigator vicinity == #none ifTrue:		[(aSubmenu atNameKey: #exploreFocus) beOn].	installedNavigator vicinity == #owner ifTrue:		[(aSubmenu atNameKey: #exploreSiblings) beOn].	self visit hasOwner ifFalse:		[(aSubmenu atNameKey: #exploreSiblings) disable].	installedNavigator vicinity == #self ifTrue:		[(aSubmenu atNameKey: #exploreParts) beOn].	self inspector isPartList ifFalse:		[(aSubmenu atNameKey: #exploreParts) disable].	installedNavigator vicinity == #visited ifTrue:		[(aSubmenu atNameKey: #exploreVisited) beOn].	self addExploreItemsTo: aSubmenu.	^aSubmenu</body><body package="Tools-Trippy" selector="buildGoSubmenu">buildGoSubmenu	| menu |	menu := self class baseGoSubmenu.	(menu atNameKey: #goDive) enabled: [self canDive].	(menu atNameKey: #goBack) enabled: [self canGoBack].	(menu atNameKey: #goForward) enabled: [self canGoForward].	self addCollaboratorItemsTo: menu.	^menu</body><body package="Tools-Trippy" selector="buildHistorySubmenu">buildHistorySubmenu	| menu item |	menu := Menu new.	trail keysAndValuesDo:		[:index :navigator | | label |		label := index &lt; 10			ifTrue: ['&amp;', index printString, '. ', navigator visit displayString]			ifFalse: [navigator visit displayString].		item := MenuItem labeled: label.		item value: [self goTo: index].		index = current ifTrue: [item beOn].		menu addItem: item].	^menu</body><body package="Tools-Trippy" selector="buildMenuBar">buildMenuBar	| menu |	menu := self class menuBar.	self hasCurrentInspector ifTrue:		[self inspector augmentMenuBar: menu].	(menu atNameKey: #go) submenu: self buildGoSubmenu.	(menu atNameKey: #history) submenu: self buildHistorySubmenu.	(menu atNameKey: #explore) submenu: self buildExploreSubmenu.	(menu atNameKey: #toggleToolbar) indication: [self builder window toolbarVisible].	(menu atNameKey: #toggleEvaluationPane) indication: [evaluationPaneVisible].	[menu		augmentFrom: self class		to: InspectorShell		menuName: #menuBar		for: self]			on: MenuAugmentationError			do: [:ex | ex isResumable ifTrue: [ex resume]].	^menu</body><body package="Tools-Trippy" selector="refreshMenuBar">refreshMenuBar	menuBarHolder value: self buildMenuBar</body></methods><methods><class-id>Tools.Trippy.InspectorShell</class-id> <category>user interface</category><body package="Tools-Trippy" selector="inspectorCollaborators">inspectorCollaborators	^Array		with: (Collaborator label: (#Navigator &lt;&lt; #labels &gt;&gt; 'Navigator') block: [self navigator])		with: (Collaborator label: (#Inspector &lt;&lt; #labels &gt;&gt; 'Inspector') block: [self inspector])</body></methods><methods><class-id>Tools.Trippy.InspectorShell class</class-id> <category>generated resources</category><body package="Tools-Trippy" selector="buildImageWithEnablement:">buildImageWithEnablement: baseString	^OpaqueImageWithEnablement		figure: (ToolbarIconLibrary perform: (baseString, '20x20') asSymbol)		shape: (ToolbarIconLibrary perform: (baseString, '20x20mask') asSymbol)		inactiveMask: (ToolbarIconLibrary perform: (baseString, '20x20bw') asSymbol)</body><body package="Tools-Trippy" selector="exploreParts">exploreParts	"Cannot share these because enablement status is set in the images."	^self buildImageWithEnablement: 'exploreParts'</body><body package="Tools-Trippy" selector="exploreSiblings">exploreSiblings	"Cannot share these because enablement status is set in the images."	^self buildImageWithEnablement: 'exploreSiblings'</body><body package="Tools-Trippy" selector="exploreVisited">exploreVisited	"Cannot share these because enablement status is set in the images."	^self buildImageWithEnablement: 'exploreVisited'</body><body package="Tools-Trippy" selector="focus">focus	"Cannot share these because enablement status is set in the images."	^self buildImageWithEnablement: 'exploreOff'</body><body package="Tools-Trippy" selector="next">next	"Cannot share these because enablement status is set in the images."	^self buildImageWithEnablement: 'next'</body><body package="Tools-Trippy" selector="previous">previous	"Cannot share these because enablement status is set in the images."	^self buildImageWithEnablement: 'previous'</body></methods><methods><class-id>Tools.Trippy.InspectorShell class</class-id> <category>instance creation</category><body package="Tools-Trippy" selector="openOn:">openOn: anObject	self new open; inspect: anObject</body></methods><methods><class-id>Tools.Trippy.InspectorShell class</class-id> <category>notifications</category><body package="Tools-Trippy" selector="instanceMethodsChanged">instanceMethodsChanged	ScheduledControllers scheduledControllers do: 		[:each | 		(each model isKindOf: self) 			ifTrue: [each model refreshMenuBar]]</body></methods><methods><class-id>Tools.Trippy.ReplacementUndo</class-id> <category>accessing</category><body package="Tools-Trippy" selector="explanation">explanation	^(savedValues size = 1		ifTrue: [(#AssignmentTo1s &lt;&lt; #dialogs &gt;&gt; 'Assignment to &lt;1s&gt;')			expandMacrosWith: (Inspector				safeDisplayStringOf: savedValues first partName)]		ifFalse: [(#AssignmentTo1sFields &lt;&lt; #dialogs &gt;&gt; 'Assignment to &lt;1p&gt; Fields')			expandMacrosWith: savedValues size])</body><body package="Tools-Trippy" selector="undoIn:">undoIn: aPage	aPage undoReplacement: self</body></methods><methods><class-id>Tools.Trippy.IndexedVariable</class-id> <category>comparing</category><body package="Tools-Trippy" selector="=">= anObject	^self class = anObject class and: [self index = anObject index]</body><body package="Tools-Trippy" selector="hash">hash	^index hash</body></methods><methods><class-id>Tools.Trippy.IndexedVariable</class-id> <category>initialize-release</category><body package="Tools-Trippy" selector="index:">index: anIndex	index := anIndex</body></methods><methods><class-id>Tools.Trippy.IndexedVariable</class-id> <category>accessing</category><body package="Tools-Trippy" selector="asVariableName">asVariableName	^'at', index printString</body><body package="Tools-Trippy" selector="displayString">displayString	^Inspector safeDisplayStringOf: index</body><body package="Tools-Trippy" selector="index">index	^index</body><body package="Tools-Trippy" selector="key">key	^index</body><body package="Tools-Trippy" selector="partName">partName	^index printString</body><body package="Tools-Trippy" selector="value">value	^object basicAt: index</body><body package="Tools-Trippy" selector="value:">value: anObject	^object basicAt: index put: anObject</body></methods><methods><class-id>Tools.Trippy.IndexedVariable class</class-id> <category>instance creation</category><body package="Tools-Trippy" selector="of:at:">of: anObject at: anInteger	^self new		object: anObject;		index: anInteger</body></methods><methods><class-id>UI.ApplicationStandardSystemController class</class-id> <category>user interface</category><body package="Tools-Trippy" selector="protectedInstVarNames">protectedInstVarNames	^self instVarNames</body></methods><methods><class-id>UI.ScheduledWindow</class-id> <category>user interface</category><body package="Tools-Trippy" selector="componentHierarchyChildren">componentHierarchyChildren	^Array with: component</body><body package="Tools-Trippy" selector="inspectorActions">inspectorActions	^Array 		with: (Tools.Trippy.Action label: (#Raise &lt;&lt; #dialogs &gt;&gt; 'Raise') block: [self raise] enablement: [self isOpen])		with: (Tools.Trippy.Action label: (#Close &lt;&lt; #dialogs &gt;&gt; 'Close') block: [self close] enablement: [self isOpen])</body><body package="Tools-Trippy" selector="inspectorClasses">inspectorClasses	^Array		with: Tools.Trippy.PreviewingInspector		with: Tools.Trippy.BasicInspector</body><body package="Tools-Trippy" selector="inspectorCollaborators">inspectorCollaborators	^Array 		with: (Tools.Trippy.Collaborator label: (#Model &lt;&lt; #dialogs &gt;&gt; 'Model') variable: 'model' object: model)		with: (Tools.Trippy.Collaborator label: (#Controller &lt;&lt; #dialogs &gt;&gt; 'Controller') variable: 'controller' object: controller)		with: (Tools.Trippy.Collaborator label: (#Component &lt;&lt; #dialogs &gt;&gt; 'Component') variable: 'component' object: component)</body><body package="Tools-Trippy" selector="inspectorHierarchies">inspectorHierarchies	^Array with: 		(Tools.Trippy.Hierarchy 			id: #componentHierarchy			label: (#ComponentHierarchy &lt;&lt; #dialogs &gt;&gt; 'Component Hierarchy') 			parentBlock: [:vc | vc componentHierarchyParent]			childrenBlock: [:vc | vc componentHierarchyChildren])</body></methods><methods><class-id>Core.Fraction</class-id> <category>printing</category><body package="Tools-Trippy" selector="inspectorExtraAttributes">inspectorExtraAttributes	^Array with:		(Tools.Trippy.DerivedAttribute			label: #asFloat &lt;&lt; #dialogs &gt;&gt; 'asFloat'			valueBlock: [self asFloat])</body></methods><methods><class-id>Core.Set</class-id> <category>user interface</category><body package="Tools-Trippy" selector="inspectorClasses">inspectorClasses	^Array		with: Tools.Trippy.SetInspector		with: Tools.Trippy.BasicInspector</body></methods><methods><class-id>Core.ClassDescription class</class-id> <category>user interface</category><body package="Tools-Trippy" selector="protectedInstVarNames">protectedInstVarNames	^self instVarNames</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>user interface</category><body package="Tools-Trippy" selector="inspectorExtraAttributes">inspectorExtraAttributes	^Array with:		(Tools.Trippy.TextAttribute			label: (#comment &lt;&lt; #dialogs &gt;&gt; 'comment')			textBlock: [self comment])</body></methods><methods><class-id>Core.Signal</class-id> <category>user interface</category><body package="Tools-Trippy" selector="inspectorHierarchies">inspectorHierarchies	^Array with:		(Tools.Trippy.Hierarchy			id: #exception			label: (#ExceptionHierarchy &lt;&lt; #dialogs &gt;&gt; 'Exception Hierarchy')			parentBlock: [:ex | ex isBehavior 				ifTrue: [ex == GenericException 					ifTrue: [nil]					ifFalse: [ex superclass]]				ifFalse: [ex parent]]			childrenBlock: [:ex | 				(Signal allInstances select: [:some | some parent == self]),					(ex isBehavior ifTrue: [ex subclasses] ifFalse: [#()])])</body></methods><methods><class-id>Core.Object</class-id> <category>user interface</category><body package="Tools-Trippy" selector="inspect">inspect	"Create and schedule an Inspector in which the user can examine the	receiver's variables."	Tools.Trippy.Inspector useSimpleInspector		ifTrue: [self inspectorClass openOn: self]		ifFalse: [Tools.Trippy.Inspector openOn: self]</body><body package="Tools-Trippy" selector="inspectorActions">inspectorActions	"Answer a collection of Action instances listing the common actions	a user might want to perform on an object. They are added to the 	inspector's Object menu."	^#()</body><body package="Tools-Trippy" selector="inspectorClasses">inspectorClasses	"Answer a sequence of inspector classes that can represent the receiver in an	inspector. The first page in the array is the one used by default in a new inspector."	^Array with: Tools.Trippy.BasicInspector</body><body package="Tools-Trippy" selector="inspectorCollaborators">inspectorCollaborators	"Answer a collection of Collaborator instances listing the important other	objects a person looking at this one might want to see. For example,	collaborators of a view would be its model and the controller.	Collaborators are added to the inspector's Go menu."	^#()</body><body package="Tools-Trippy" selector="inspectorExtraAttributes">inspectorExtraAttributes	"Subclasses may reimplement this to answer a sequence of	DerivedAttribute or TextAttribute instances that should show up	in the inspector in addition to named instance variables and	indexed variables. See implementors for an example."	^#()</body><body package="Tools-Trippy" selector="inspectorHierarchies">inspectorHierarchies	"Answer a collection of instances of Hierarchy describing the hierarchies	this object is a member of."	^#()</body></methods><methods><class-id>UI.View</class-id> <category>user interface</category><body package="Tools-Trippy" selector="inspectorCollaborators">inspectorCollaborators	^Array 		with: (Tools.Trippy.Collaborator label: (#Model &lt;&lt; #labels &gt;&gt; 'Model') variable: 'model' object: model)		with: (Tools.Trippy.Collaborator label: (#Controller &lt;&lt; #labels &gt;&gt; 'Controller') variable: 'controller' object: controller)</body></methods><methods><class-id>Kernel.Context</class-id> <category>user interface</category><body package="Tools-Trippy" selector="inspectorExtraAttributes">inspectorExtraAttributes	^self method inspectorExtraAttributes</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>user interface</category><body package="Tools-Trippy" selector="inspectorClasses">inspectorClasses	^Array		with: Tools.Trippy.PoolDictionaryInspector		with: Tools.Trippy.BasicInspector</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>user interface</category><body package="Tools-Trippy" selector="inspectorClasses">inspectorClasses	^Array		with: Tools.Trippy.TextEditorInspector		with: Tools.Trippy.ArrayInspector		with: Tools.Trippy.BasicInspector</body></methods><methods><class-id>Core.KeyedCollection</class-id> <category>user interface</category><body package="Tools-Trippy" selector="inspectorClasses">inspectorClasses	^self size &gt; 10000		ifTrue:			[Array with: Tools.Trippy.BasicInspector]		ifFalse:			[Array				with: Tools.Trippy.DictionaryInspector				with: Tools.Trippy.BasicInspector]</body></methods><methods><class-id>UI.SubCanvasSpec</class-id> <category>user interface</category><body package="Tools-Trippy" selector="specHierarchyChildren">specHierarchyChildren	"Try to get the spec we embed and return it as the children.	This will not work for all possible uses of subcanvases since majorKey	and minorKey are not required to be a class reference and a selector	but it will make life easier at least in some cases."	^[Array with: (self majorKey value interfaceSpecFor: self minorKey)]		on: Error		do: [:ex | ex return: nil]</body></methods><methods><class-id>UI.SpecCollection</class-id> <category>user interface</category><body package="Tools-Trippy" selector="specHierarchyChildren">specHierarchyChildren	^collection</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>user interface</category><body package="Tools-Trippy" selector="inspectorClasses">inspectorClasses	^Array		with: Tools.Trippy.SequenceInspector		with: Tools.Trippy.BasicInspector</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>user interface</category><body package="Tools-Trippy" selector="inspectorActions">inspectorActions	^Array with: (Tools.Trippy.Action 				label: (#BrowseMethod &lt;&lt; #dialogs &gt;&gt; 'Browse Method')				block: 					[| array md |					array := self who.					md := MethodDefinition class: (array at: 1) selector: (array at: 2).					MethodCollector new 						openListBrowserOn: (Array with: md)						label: (#InspectedMethod &lt;&lt; #dialogs &gt;&gt; 'Inspected Method')						initialSelection: nil]				enablement: [self who notNil])</body></methods><methods><class-id>Graphics.VisualComponent</class-id> <category>user interface</category><body package="Tools-Trippy" selector="componentHierarchyChildren">componentHierarchyChildren	^Array new</body><body package="Tools-Trippy" selector="componentHierarchyParent">componentHierarchyParent	^nil</body><body package="Tools-Trippy" selector="inspectorClasses">inspectorClasses	"For VisualComponents, the preferred page is not the first one.	 See the redefined #preferredInspectorPageClass."	^Array		with: Tools.Trippy.PreviewingInspector		with: Tools.Trippy.BasicInspector</body><body package="Tools-Trippy" selector="inspectorHierarchies">inspectorHierarchies	^Array with: 		(Tools.Trippy.Hierarchy 			id: #componentHierarchy			label: (#ComponentHierarchy &lt;&lt; #dialogs &gt;&gt; 'Component Hierarchy') 			parentBlock: [:vc | vc componentHierarchyParent]			childrenBlock: [:vc | vc componentHierarchyChildren])</body></methods><methods><class-id>UI.ControlManager class</class-id> <category>user interface</category><body package="Tools-Trippy" selector="protectedInstVarNames">protectedInstVarNames	^self instVarNames</body></methods><methods><class-id>Kernel.CompiledCode</class-id> <category>user interface</category><body package="Tools-Trippy" selector="inspectorExtraAttributes">inspectorExtraAttributes	^Array 		with: (Tools.Trippy.TextAttribute				label: (#bytecode &lt;&lt; #dialogs &gt;&gt; 'bytecode') 				textBlock: [self symbolic])		with: (Tools.Trippy.TextAttribute				label: (#decompiled &lt;&lt; #dialogs &gt;&gt; 'decompiled') 				textBlock: [self decompiledSource])		with:			(Tools.Trippy.TextAttribute				label: (#source &lt;&lt; #dialogs &gt;&gt; 'source') 				textBlock: 					[(self homeMethod getSourceForUserIfNone: [(#noSource &lt;&lt; #dialogs &gt;&gt; 'no source')])						asText makeSelectorBoldIn: self mclass])</body></methods><methods><class-id>Core.Behavior</class-id> <category>user interface</category><body package="Tools-Trippy" selector="inspectorCollaborators">inspectorCollaborators	^Array		with: (Tools.Trippy.Collaborator label: (#AllInstances &lt;&lt; #labels &gt;&gt; 'All Instances') block: [self allInstances])</body><body package="Tools-Trippy" selector="inspectorHierarchies">inspectorHierarchies	^Array with:		(Tools.Trippy.Hierarchy			id: #class			label: (#ClassHierarchy &lt;&lt; #labels &gt;&gt; 'Class Hierarchy')			parentBlock: [:class | class superclass]			childrenBlock: 				[:class | 				class subclasses asSortedCollection: [:a :b | a name &lt;= b name]])</body><body package="Tools-Trippy" selector="protectedInstVarNames">protectedInstVarNames	"Answer a collection of instance variable names that should be treated by	the inspector as protected -- see the explanation in Part&gt;&gt;isProtected.	Note that the inspector sends this message to all classes on the	inheritance chain and collects all answered names.	This method will typically be implemented on the class side, and would	answer either a collection of variable names (strings) or be implemented as		^self instVarNames	or		^self allInstVarNames."	^#()</body></methods><methods><class-id>Core.Integer</class-id> <category>user interface</category><body package="Tools-Trippy" selector="inspectorExtraAttributes">inspectorExtraAttributes	^Array		with: (Tools.Trippy.TextAttribute label: (#hexadecimal &lt;&lt; #dialogs &gt;&gt; 'hexadecimal') text: (self printStringRadix: 16))		with: (Tools.Trippy.TextAttribute label: (#octal &lt;&lt; #dialogs &gt;&gt; 'octal') text: (self printStringRadix: 8))		with: (Tools.Trippy.TextAttribute label: (#binary &lt;&lt; #dialogs &gt;&gt; 'binary') text: self paddedBinaryPrintString)</body><body package="Tools-Trippy" selector="paddedBinaryPrintString">paddedBinaryPrintString	"Answer a string with the ''hacker's'' binary representation of the receiver--	broken into bytes and padded to a power-of-two number of bytes."	| binaryDigits paddedSize paddedString binaryStream |	binaryDigits := self abs printStringRadix: 2.	paddedSize := 8.	[paddedSize &lt; binaryDigits size] whileTrue: [paddedSize := 2 * paddedSize].	paddedString := String new: paddedSize withAll: $0.	paddedString replaceFrom: paddedSize - binaryDigits size + 1 to: paddedSize with: binaryDigits.	binaryStream := (String new: 50) writeStream.	self &lt; 0 ifTrue: [binaryStream nextPutAll: '-'].	1 to: paddedSize by: 8 do:		[:base | 	binaryStream nextPutAll: (paddedString copyFrom: base to: base + 7); space].	binaryStream skip: -1.	^binaryStream contents</body></methods><methods><class-id>Core.Symbol</class-id> <category>user interface</category><body package="Tools-Trippy" selector="inspectorClasses">inspectorClasses	"Removing the superclass' TextEditorInspector--	at least until I think well about what it could do to symbols."	^Array		with: Tools.Trippy.ArrayInspector		with: Tools.Trippy.BasicInspector</body></methods><methods><class-id>Core.GenericException class</class-id> <category>user interface</category><body package="Tools-Trippy" selector="inspectorHierarchies">inspectorHierarchies	^Array 		with:			(Tools.Trippy.Hierarchy				id: #class				label: (#ClassHierarchy &lt;&lt; #dialogs &gt;&gt; 'Class Hierarchy')				parentBlock: [:class | class superclass]				childrenBlock: [:class | class subclasses])		with:			(Tools.Trippy.Hierarchy				id: #exception				label: (#ExceptionHierarchy &lt;&lt; #dialogs &gt;&gt; 'Exception Hierarchy')				parentBlock: [:ex | ex isBehavior 					ifTrue: [ex == GenericException 						ifTrue: [nil]						ifFalse: [ex superclass]]					ifFalse: [ex parent]]				childrenBlock: [:ex | 					(Signal allInstances select: [:some | some parent == self]),						(ex isBehavior ifTrue: [ex subclasses] ifFalse: [#()])])</body></methods><methods><class-id>UI.FullSpec</class-id> <category>user interface</category><body package="Tools-Trippy" selector="specHierarchyChildren">specHierarchyChildren	^Array with: window with: component</body></methods><methods><class-id>UI.Controller class</class-id> <category>user interface</category><body package="Tools-Trippy" selector="protectedInstVarNames">protectedInstVarNames	^self instVarNames</body></methods><methods><class-id>UI.Controller</class-id> <category>user interface</category><body package="Tools-Trippy" selector="inspectorCollaborators">inspectorCollaborators	^Array 		with: (Tools.Trippy.Collaborator label: (#Model &lt;&lt; #labels &gt;&gt; 'Model') variable: 'model' object: model)		with: (Tools.Trippy.Collaborator label: (#View &lt;&lt; #labels &gt;&gt; 'View') variable: 'view' object: view)</body></methods><methods><class-id>Core.ArrayedCollection</class-id> <category>user interface</category><body package="Tools-Trippy" selector="inspectorClasses">inspectorClasses	"For some arrayed collections there is no real difference between the	array and basic views, but for some there is so let's provide both. If this 	proves to be confusing, we can do a finer-grained tuning in individual	subclasses."	^Array		with: Tools.Trippy.ArrayInspector		with: Tools.Trippy.BasicInspector</body></methods><methods><class-id>Core.Dictionary</class-id> <category>user interface</category><body package="Tools-Trippy" selector="inspectorClasses">inspectorClasses	^Array		with: Tools.Trippy.DictionaryInspector		with: Tools.Trippy.BasicInspector</body></methods><methods><class-id>Core.Metaclass class</class-id> <category>user interface</category><body package="Tools-Trippy" selector="protectedInstVarNames">protectedInstVarNames	^self instVarNames</body></methods><methods><class-id>UI.UISpecification</class-id> <category>user interface</category><body package="Tools-Trippy" selector="inspectorHierarchies">inspectorHierarchies	^Array with: 		(Tools.Trippy.Hierarchy 			id: #specHierarchy			label: (#SpecHierarchy &lt;&lt; #labels &gt;&gt; 'Spec Hierarchy') 			root: self			childrenBlock: [:spec | spec specHierarchyChildren])</body></methods><methods><class-id>Kernel.PoolDictionary</class-id> <category>user interface</category><body package="Tools-Trippy" selector="inspectorClasses">inspectorClasses	^Array		with: Tools.Trippy.PoolDictionaryInspector		with: Tools.Trippy.BasicInspector</body></methods><methods><class-id>Graphics.VisualPart</class-id> <category>user interface</category><body package="Tools-Trippy" selector="componentHierarchyParent">componentHierarchyParent	^container</body><body package="Tools-Trippy" selector="inspectorActions">inspectorActions	^Array 		with: (Tools.Trippy.Action label: (#Flash &lt;&lt; #dialogs &gt;&gt; 'Flash') block: [self flash])</body></methods><methods><class-id>Graphics.CompositePart</class-id> <category>user interface</category><body package="Tools-Trippy" selector="componentHierarchyChildren">componentHierarchyChildren	^components</body></methods><methods><class-id>UI.ApplicationWindow</class-id> <category>user interface</category><body package="Tools-Trippy" selector="inspectorCollaborators">inspectorCollaborators	^super inspectorCollaborators copyWith: 		(Tools.Trippy.Collaborator label: (#Application &lt;&lt; #labels &gt;&gt; 'Application') variable: 'application' object: application)</body></methods><methods><class-id>Core.Character</class-id> <category>user interface</category><body package="Tools-Trippy" selector="inspectorExtraAttributes">inspectorExtraAttributes	| integerAttr name symbolicStream nameAttr |	integerAttr := Tools.Trippy.DerivedAttribute label: (#asInteger &lt;&lt; #dialogs &gt;&gt; 'asInteger') value: self asInteger.	name := self class constantNameFor: self.	name notNil ifTrue:		[symbolicStream := String new writeStream.		symbolicStream store: self class; space; nextPutAll: name.		nameAttr := Tools.Trippy.TextAttribute label: (#symbolic &lt;&lt; #dialogs &gt;&gt; 'symbolic') text: symbolicStream contents.		^Array with: integerAttr with: nameAttr].	^Array with: integerAttr</body></methods><methods><class-id>Core.Class class</class-id> <category>user interface</category><body package="Tools-Trippy" selector="protectedInstVarNames">protectedInstVarNames	^self instVarNames</body></methods><methods><class-id>Core.Class</class-id> <category>user interface</category><body package="Tools-Trippy" selector="inspectorCollaborators">inspectorCollaborators	^super inspectorCollaborators copyWith:		(Tools.Trippy.Collaborator label: (#NewInstance &lt;&lt; #dialogs &gt;&gt; 'New Instance') block: [self new])</body></methods><methods><class-id>Graphics.Wrapper</class-id> <category>user interface</category><body package="Tools-Trippy" selector="componentHierarchyChildren">componentHierarchyChildren	^Array with: component</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>user interface</category><body package="Tools-Trippy" selector="inspectorExtraAttributes">inspectorExtraAttributes	^self method inspectorExtraAttributes</body></methods><methods><class-id>Tools.Trippy.OwnerNavigator class</class-id> <category>interface specs</category><body package="Tools-Trippy" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #labels) 			#bounds: #(#{Graphics.Rectangle} 412 284 706 525 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 0.25 0 1 ) 					#name: #fieldList 					#model: #fieldListHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #fieldDoubleClicked ) 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.25 0 0 0 1 0 1 ) 					#name: #inspector 					#model: #inspectorHolder 					#labels: #() ) ) ) )</body></methods><methods><class-id>Tools.Trippy.Inspector class</class-id> <category>resources</category><body package="Tools-Trippy" selector="baseObjectSubmenu">baseObjectSubmenu	"Tools.MenuEditor new openOnClass: self andSelector: #baseObjectSubmenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Refresh 					#defaultString: '&amp;Refresh' 					#catalogID: #menus ) 				#value: #refresh 				#shortcutKeyCharacter: #F5 				#shortcutModifiers: 0 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Browse 					#defaultString: '&amp;Browse' 					#catalogID: #menus ) 				#nameKey: #objectBrowse 				#value: #browseClass 				#shortcutKeyCharacter: $B 				#shortcutModifiers: 3 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Inspect 					#defaultString: '&amp;Inspect' 					#catalogID: #menus ) 				#nameKey: #objectSpawn 				#value: #spawn ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #InspectOwners 					#defaultString: 'Inspect &amp;Owners' 					#catalogID: #menus ) 				#nameKey: #objectInspectOwners 				#value: #inspectOwners ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #InspectReferencePaths 					#defaultString: 'Inspect Reference &amp;Paths' 					#catalogID: #menus ) 				#nameKey: #objectReferencePath 				#value: #inspectReferencePath ) ) #(1 4 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.Trippy.HierarchyNavigator class</class-id> <category>resources</category><body package="Tools-Trippy" selector="hierarchyMenu">hierarchyMenu	"MenuEditor new openOnClass: self andSelector: #hierarchyMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #ContractBranch #defaultString: '&amp;Contract Branch' #catalogID: #menus) 				#value: #contractBranch ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #ExpandBranch #defaultString: '&amp;Expand Branch' #catalogID: #menus) 				#value: #expandBranch ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #ContractAll #defaultString: '&amp;Contract All' #catalogID: #menus) 				#value: #contractAll ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #ExpandAll #defaultString: '&amp;Expand All' #catalogID: #menus) 				#value: #expandAll ) ) #(2 2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.Trippy.HierarchyNavigator class</class-id> <category>interface specs</category><body package="Tools-Trippy" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #labels) 			#bounds: #(#{Graphics.Rectangle} 359 217 666 552 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.HierarchicalViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 0.35 ) 					#name: #hierarchyList 					#flags: 15 					#model: #hierarchyHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #hierarchyDoubleClicked ) 					#menu: #hierarchyMenu 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0.35 0 1 0 1 ) 					#name: #inspector 					#model: #inspectorHolder 					#labels: #() ) ) ) )</body></methods><methods><class-id>Tools.Trippy.InspectorHolder class</class-id> <category>interface specs</category><body package="Tools-Trippy" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #labels) 			#bounds: #(#{Graphics.Rectangle} 412 284 612 484 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #inspector 					#flags: 0 ) ) ) )</body></methods><methods><class-id>Tools.Trippy.TextEditorInspector class</class-id> <category>interface specs</category><body package="Tools-Trippy" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #labels) 			#bounds: #(#{Graphics.Rectangle} 512 384 712 584 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #text 					#model: #textHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#textAccepted: ) 					#tabRequiresControl: true ) ) ) )</body></methods><methods><class-id>Tools.Trippy.BehaviorInspector class</class-id> <category>resources</category><body package="Tools-Trippy" selector="methodListMenu">methodListMenu	"MenuEditor new openOnClass: self andSelector: #methodListMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #SendIt #defaultString: 'Sen&amp;d It' #catalogID: #menus) 				#nameKey: #methodsSendIt 				#value: #sendIt 				#enablementSelector: #singleUnaryMethodIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #SendAndDive #defaultString: 'Send and Di&amp;ve' #catalogID: #menus) 				#nameKey: #methodsSendAndDive 				#value: #sendAndDive 				#enablementSelector: #singleUnaryMethodIsSelected ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Senders #defaultString: '&amp;Senders' #catalogID: #menus) 				#nameKey: #senders ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Implementors #defaultString: '&amp;Implementors' #catalogID: #menus) 				#nameKey: #implementors ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #LocalSe_nders #defaultString: 'Local Se&amp;nders' #catalogID: #menus) 				#nameKey: #localSenders ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #LocalI_mplementors #defaultString: 'Local I&amp;mplementors' #catalogID: #menus) 				#nameKey: #localImplementors ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #ReferencedClasses #defaultString: 'Referenced &amp;Classes' #catalogID: #menus) 				#nameKey: #referencedClasses ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Remove #defaultString: '&amp;Remove' #catalogID: #menus) 				#value: #removeMethods 				#enablementSelector: #canRemoveMethods ) ) #(2 5 1 ) nil ) decodeAsLiteralArray</body><body package="Tools-Trippy" selector="protocolListMenu">protocolListMenu	"Tools.MenuEditor new openOnClass: self andSelector: #protocolListMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_NewDot #defaultString: '&amp;New...' #catalogID: #menus) 				#value: #addProtocol ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Re_nameAsDot #defaultString: 'Re&amp;name As...' #catalogID: #menus) 				#value: #renameProtocol 				#enablementSelector: #canRenameProtocol ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Remove #defaultString: '&amp;Remove' #catalogID: #menus) 				#value: #removeProtocol 				#enablementSelector: #canRemoveProtocol ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_FindMethod #defaultString: '&amp;Find Method...' #catalogID: #menus) 				#nameKey: #findMethod 				#value: #findMethod ) ) #(1 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.Trippy.BehaviorInspector class</class-id> <category>interface specs</category><body package="Tools-Trippy" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #labels) 			#bounds: #(#{Graphics.Rectangle} 512 384 936 710 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 0.4 -20 0.4 ) 					#name: #protocolList 					#model: #protocolListHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: #updateRequest ) 					#menu: #protocolListMenu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.4 0 0 0 1 0 0.4 ) 					#name: #methodList 					#model: #methodListHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #selectorDoubleClicked 						#requestValueChangeSelector: #updateRequest ) 					#menu: #methodListMenu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0.4 0 1 0 1 ) 					#name: #text 					#model: #textHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#textAccepted: 						#requestValueChangeSelector: 						#textAcceptAllowed: ) 					#isReadOnly: false 					#tabRequiresControl: true ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0 0 0.4 0 1 ) 					#model: #sideHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: #updateRequest ) 					#label: #(#{Kernel.UserMessage} #key: #instance #defaultString: 'instance' #catalogID: #labels) 					#select: #instance ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.2 0 0.4 0 1 ) 					#model: #sideHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: #updateRequest ) 					#label: #(#{Kernel.UserMessage} #key: #class #defaultString: 'class' #catalogID: #labels) 					#select: #class ) ) ) )</body></methods><methods><class-id>Tools.Trippy.NullNavigator class</class-id> <category>interface specs</category><body package="Tools-Trippy" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #labels) 			#bounds: #(#{Graphics.Rectangle} 512 384 712 584 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #inspector 					#model: #inspectorHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: #changeRequest ) 					#labels: #() ) ) ) )</body></methods><methods><class-id>Tools.Trippy.PartListAbstractInspector class</class-id> <category>resources</category><body package="Tools-Trippy" selector="baseEditSubmenu">baseEditSubmenu	"MenuEditor new openOnClass: self andSelector: #baseEditSubmenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Undo #defaultString: '&amp;Undo' #catalogID: #menus) 				#nameKey: #editUndo 				#value: #undo 				#shortcutKeyCharacter: $Z 				#shortcutModifiers: 2 ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Select_All #defaultString: 'Select &amp;All' #catalogID: #menus) 				#nameKey: #editSelectAll 				#value: #selectAll 				#shortcutKeyCharacter: $A 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #selectAll ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Copy #defaultString: '&amp;Copy' #catalogID: #menus) 				#nameKey: #editCopy 				#value: #copySelection 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #copy ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Paste #defaultString: '&amp;Paste' #catalogID: #menus) 				#nameKey: #editPaste 				#value: #paste 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #paste ) ) ) #(1 1 2 ) nil ) decodeAsLiteralArray</body><body package="Tools-Trippy" selector="fieldListMenu">fieldListMenu	"MenuEditor new openOnClass: self andSelector: #fieldListMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Inspect #defaultString: '&amp;Inspect' #catalogID: #menus) 				#nameKey: #spawn 				#value: #spawn ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Dive #defaultString: '&amp;Dive' #catalogID: #menus) 				#nameKey: #dive 				#value: #dive ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Back #defaultString: '&amp;Back' #catalogID: #menus) 				#nameKey: #back 				#value: #back 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #previous ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Copy #defaultString: '&amp;Copy' #catalogID: #menus) 				#nameKey: #copy 				#value: #copySelection 				#enablementSelector: #canCopy 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #copy ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Paste #defaultString: '&amp;Paste' #catalogID: #menus) 				#nameKey: #paste 				#value: #paste 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #paste ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Refresh #defaultString: '&amp;Refresh' #catalogID: #menus) 				#nameKey: #refresh 				#value: #refresh ) ) #(3 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.Trippy.PartListAbstractInspector class</class-id> <category>interface specs</category><body package="Tools-Trippy" selector="segmentedSpec">segmentedSpec	"UIPainter new openOnClass: self andSelector: #segmentedSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #labels) 			#bounds: #(#{Graphics.Rectangle} 386 220 693 555 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragOkSelector 						#wantToDrag: #dragEnterSelector 						#dragEntry: #dragOverSelector 						#dragOver: #dragStartSelector 						#doDrag: #dropSelector 						#drop: #dragExitSelector 						#dragExit: ) 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0.4 0 0.4 0 1 ) 					#name: #fieldList 					#flags: 15 					#model: #fieldListHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #dive 						#requestValueChangeSelector: #changeRequest ) 					#menu: #fieldListMenu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.4 0 0 0 1 0 1 ) 					#name: #text 					#model: #textHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#textAccepted: 						#requestValueChangeSelector: 						#textAcceptAllowed: ) ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 0.4 0 0.4 ) 					#name: #segmentList 					#flags: 15 					#model: #segmentListHolder 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) ) ) )</body><body package="Tools-Trippy" selector="unsegmentedSpec">unsegmentedSpec	"UIPainter new openOnClass: self andSelector: #unsegmentedSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #labels) 			#bounds: #(#{Graphics.Rectangle} 359 217 666 552 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragOkSelector 						#wantToDrag: #dragEnterSelector 						#dragEntry: #dropSelector 						#drop: #dragStartSelector 						#doDrag: #dragOverSelector 						#dragOver: #dragExitSelector 						#dragExit: ) 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 0.4 0 1 ) 					#name: #fieldList 					#flags: 15 					#model: #fieldListHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #dive 						#requestValueChangeSelector: #changeRequest ) 					#menu: #fieldListMenu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.4 0 0 0 1 0 1 ) 					#name: #text 					#model: #textHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#textAccepted: 						#requestValueChangeSelector: 						#textAcceptAllowed: ) ) ) ) )</body></methods><methods><class-id>Tools.Trippy.DictionaryInspector class</class-id> <category>interface specs</category><body package="Tools-Trippy" selector="segmentedSpec">segmentedSpec	"UIPainter new openOnClass: self andSelector: #segmentedSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #labels) 			#bounds: #(#{Graphics.Rectangle} 581 223 888 558 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragOkSelector 						#wantToDrag: #dragEnterSelector 						#dragEntry: #dragOverSelector 						#dragOver: #dragStartSelector 						#doDrag: #dropSelector 						#drop: #dragExitSelector 						#dragExit: ) 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0.4 0 0.4 0 1 ) 					#name: #fieldList 					#flags: 15 					#model: #fieldListHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #dive 						#requestValueChangeSelector: #changeRequest ) 					#menu: #fieldListMenu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.4 0 0 0 1 -20 1 ) 					#name: #text 					#model: #textHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#textAccepted: 						#requestValueChangeSelector: 						#textAcceptAllowed: ) ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 0.4 0 0.4 ) 					#name: #segmentList 					#flags: 15 					#model: #segmentListHolder 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.4 0 1 0 1 ) 					#model: #valueOrKeyHolder 					#label: #(#{Kernel.UserMessage} #key: #ValueAtKey #defaultString: 'Value at Key' #catalogID: #labels) 					#select: #value ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 4 0.7 0 1 0 1 ) 					#model: #valueOrKeyHolder 					#label: #(#{Kernel.UserMessage} #key: #Key #defaultString: 'Key' #catalogID: #labels) 					#select: #key ) ) ) )</body><body package="Tools-Trippy" selector="unsegmentedSpec">unsegmentedSpec	"UIPainter new openOnClass: self andSelector: #unsegmentedSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #labels) 			#bounds: #(#{Graphics.Rectangle} 581 223 888 558 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragOkSelector 						#wantToDrag: #dragEnterSelector 						#dragEntry: #dragOverSelector 						#dragOver: #dragStartSelector 						#doDrag: #dropSelector 						#drop: #dragExitSelector 						#dragExit: ) 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 0.4 0 1 ) 					#name: #fieldList 					#flags: 15 					#model: #fieldListHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #dive 						#requestValueChangeSelector: #changeRequest ) 					#menu: #fieldListMenu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.4 0 0 0 1 -20 1 ) 					#name: #text 					#model: #textHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#textAccepted: 						#requestValueChangeSelector: 						#textAcceptAllowed: ) ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.4 0 1 0 1 ) 					#model: #valueOrKeyHolder 					#label: #(#{Kernel.UserMessage} #key: #ValueAtKey #defaultString: 'Value at Key' #catalogID: #labels) 					#select: #value ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 4 0.7 0 1 0 1 ) 					#model: #valueOrKeyHolder 					#label: #(#{Kernel.UserMessage} #key: #Key #defaultString: 'Key' #catalogID: #labels) 					#select: #key ) ) ) )</body></methods><methods><class-id>Tools.Trippy.PreviewingInspector class</class-id> <category>interface specs</category><body package="Tools-Trippy" selector="segmentedSpec">segmentedSpec	"UIPainter new openOnClass: self andSelector: #segmentedSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #labels) 			#bounds: #(#{Graphics.Rectangle} 359 217 666 552 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragOkSelector 						#wantToDrag: #dragEnterSelector 						#dragEntry: #dragOverSelector 						#dragOver: #dragStartSelector 						#doDrag: #dropSelector 						#drop: #dragExitSelector 						#dragExit: ) 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0.6 0 0.4 0 1 ) 					#name: #fieldList 					#flags: 15 					#model: #fieldListHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #dive 						#requestValueChangeSelector: #changeRequest ) 					#menu: #fieldListMenu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.4 0 0 0 1 0 1 ) 					#name: #text 					#model: #textHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#textAccepted: 						#requestValueChangeSelector: 						#textAcceptAllowed: ) ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0.4 0 0.4 0 0.6 ) 					#name: #segmentList 					#flags: 15 					#model: #segmentListHolder 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 0.4 0 0.4 ) 					#name: #preview 					#flags: 11 					#component: #preview ) ) ) )</body><body package="Tools-Trippy" selector="unsegmentedSpec">unsegmentedSpec	"UIPainter new openOnClass: self andSelector: #unsegmentedSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #labels) 			#bounds: #(#{Graphics.Rectangle} 359 217 666 552 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragOkSelector 						#wantToDrag: #dragEnterSelector 						#dragEntry: #dropSelector 						#drop: #dragStartSelector 						#doDrag: #dragOverSelector 						#dragOver: #dragExitSelector 						#dragExit: ) 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0.4 0 0.4 0 1 ) 					#name: #fieldList 					#flags: 15 					#model: #fieldListHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #dive 						#requestValueChangeSelector: #changeRequest ) 					#menu: #fieldListMenu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.4 0 0 0 1 0 1 ) 					#name: #text 					#model: #textHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: 						#textAccepted: 						#requestValueChangeSelector: 						#textAcceptAllowed: ) ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 0.4 0 0.4 ) 					#name: #preview 					#flags: 11 					#component: #preview ) ) ) )</body></methods><methods><class-id>Tools.Trippy.InspectorShell class</class-id> <category>interface specs</category><body package="Tools-Trippy" selector="evaluatorSpec">evaluatorSpec	"UIPainter new openOnClass: self andSelector: #evaluatorSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #labels) 			#bounds: #(#{Graphics.Rectangle} 412 284 612 484 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #evaluator 					#model: #textHolder ) ) ) )</body><body package="Tools-Trippy" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #Inspector #defaultString: 'Inspector' #catalogID: #labels) 			#min: #(#{Core.Point} 190 162 ) 			#bounds: #(#{Graphics.Rectangle} 512 368 1012 768 ) 			#flags: 4 			#menu: #menuBarHolder 			#toolBar: #toolbar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 -1 0.6 ) 					#name: #navigator 					#flags: 0 ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -1 0.6 0 1 2 0.6 ) 					#name: #splitter 					#horizontal: true 					#minAboveSize: 50 					#minBelowSize: 25 					#aboveWidgets: 'navigator' 					#belowWidgets: 'evaluatorPane' ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 2 0.6 0 1 0 1 ) 					#name: #evaluatorPane 					#flags: 0 					#minorKey: #evaluatorSpec ) ) ) )</body></methods><methods><class-id>Tools.Trippy.InspectorShell class</class-id> <category>resources</category><body package="Tools-Trippy" selector="baseExploreMenu">baseExploreMenu	"MenuEditor new openOnClass: self andSelector: #baseExploreMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Focus #defaultString: '&amp;Focus' #catalogID: #menus) 				#nameKey: #exploreFocus 				#value: #exploreFocus 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #exploreOff ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Siblings #defaultString: '&amp;Siblings' #catalogID: #menus) 				#nameKey: #exploreSiblings 				#value: #exploreSiblings 				#shortcutKeyCharacter: #Up 				#shortcutModifiers: 8 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #exploreSiblings ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Parts #defaultString: '&amp;Parts' #catalogID: #menus) 				#nameKey: #exploreParts 				#value: #exploreParts 				#shortcutKeyCharacter: #Down 				#shortcutModifiers: 8 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #exploreParts ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Visited #defaultString: '&amp;Visited' #catalogID: #menus) 				#nameKey: #exploreVisited 				#value: #exploreVisited 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #exploreVisited ) ) ) #(1 3 ) nil ) decodeAsLiteralArray</body><body package="Tools-Trippy" selector="baseGoSubmenu">baseGoSubmenu	"MenuEditor new openOnClass: self andSelector: #baseGoSubmenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Dive #defaultString: '&amp;Dive' #catalogID: #menus) 				#nameKey: #goDive 				#value: #dive ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Back #defaultString: '&amp;Back' #catalogID: #menus) 				#nameKey: #goBack 				#value: #back 				#shortcutKeyCharacter: #Left 				#shortcutModifiers: 8 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.Trippy.InspectorShell} #previous ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Forward #defaultString: '&amp;Forward' #catalogID: #menus) 				#nameKey: #goForward 				#value: #forward 				#shortcutKeyCharacter: #Right 				#shortcutModifiers: 8 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.Trippy.InspectorShell} #next ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #ToClass #defaultString: 'To &amp;Class' #catalogID: #menus) 				#nameKey: #goDiveIntoClass 				#value: #diveIntoClass ) ) #(1 2 1 ) nil ) decodeAsLiteralArray</body><body package="Tools-Trippy" selector="menuBar">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Go 					#defaultString: '&amp;Go' 					#catalogID: #menus ) 				#nameKey: #go ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_History 					#defaultString: '&amp;History' 					#catalogID: #menus ) 				#nameKey: #history ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #E_xplore 					#defaultString: 'E&amp;xplore' 					#catalogID: #menus ) 				#nameKey: #explore ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Tools 					#defaultString: '&amp;Tools' 					#catalogID: #menus ) 				#nameKey: #window 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_CompareToClipboard 								#defaultString: '&amp;Compare to Clipboard...' 								#catalogID: #menus ) 							#nameKey: #compareObjectToClipboard 							#value: #compareObjectToClipboard 							#enablementSelector: #clipboardNotEmpty 							#shortcutKeyCharacter: #F6 							#shortcutModifiers: 0 ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_InspectClipboard 								#defaultString: '&amp;Inspect Clipboard' 								#catalogID: #menus ) 							#nameKey: #inspectClipboard 							#value: #inspectClipboard 							#enablementSelector: #clipboardNotEmpty ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_EmptyClipboard 								#defaultString: '&amp;Empty Clipboard' 								#catalogID: #menus ) 							#nameKey: #emptyClipboard 							#value: #emptyClipboard 							#enablementSelector: #clipboardNotEmpty ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Toolbar 								#defaultString: '&amp;Toolbar' 								#catalogID: #menus ) 							#nameKey: #toggleToolbar 							#value: #toggleToolbar 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Evaluation_Pane 								#defaultString: 'Evaluation &amp;Pane' 								#catalogID: #menus ) 							#nameKey: #toggleEvaluationPane 							#value: #toggleEvaluationPane 							#shortcutKeyCharacter: #F2 							#shortcutModifiers: 0 ) ) #(3 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Help 					#defaultString: '&amp;Help' 					#catalogID: #menus ) 				#nameKey: #help 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Inspector 								#defaultString: '&amp;Inspector' 								#catalogID: #menus ) 							#value: #helpInspector 							#shortcutKeyCharacter: #F1 							#shortcutModifiers: 0 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #help ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Inspecting_Objects 								#defaultString: 'Inspecting &amp;Objects' 								#catalogID: #menus ) 							#value: #helpInspectingObjects ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_AboutVisualWorksDot 								#defaultString: '&amp;About VisualWorks...' 								#catalogID: #menus ) 							#value: #helpAbout ) ) #(2 1 ) nil ) ) ) #(5 ) nil ) decodeAsLiteralArray</body><body package="Tools-Trippy" selector="toolbar">toolbar	"MenuEditor new openOnClass: self andSelector: #toolbar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Back #defaultString: 'Back' #catalogID: #menus) 				#nameKey: #back 				#value: #back 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.Trippy.InspectorShell} #previous ) 				#helpText: #(#{Kernel.UserMessage} #key: #Back #defaultString: 'Back' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Forward #defaultString: 'Forward' #catalogID: #menus) 				#nameKey: #forward 				#value: #forward 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.Trippy.InspectorShell} #next ) 				#helpText: #(#{Kernel.UserMessage} #key: #Forward #defaultString: 'Forward' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Focus #defaultString: 'Focus' #catalogID: #menus) 				#nameKey: #focus 				#value: #exploreFocus 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.Trippy.InspectorShell} #focus ) 				#helpText: #(#{Kernel.UserMessage} #key: #Focus #defaultString: 'Focus' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #ExploreSiblings #defaultString: 'Explore Siblings' #catalogID: #menus) 				#nameKey: #exploreSiblings 				#value: #exploreSiblings 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.Trippy.InspectorShell} #exploreSiblings ) 				#helpText: #(#{Kernel.UserMessage} #key: #ExploreSiblings #defaultString: 'Explore Siblings' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #ExploreParts #defaultString: 'Explore Parts' #catalogID: #menus) 				#nameKey: #exploreParts 				#value: #exploreParts 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.Trippy.InspectorShell} #exploreParts ) 				#helpText: #(#{Kernel.UserMessage} #key: #ExploreParts #defaultString: 'Explore Parts' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #ExploreVisited #defaultString: 'Explore Visited' #catalogID: #menus) 				#nameKey: #exploreVisited 				#value: #exploreVisited 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.Trippy.InspectorShell} #exploreVisited ) 				#helpText: #(#{Kernel.UserMessage} #key: #ExploreVisited #defaultString: 'Explore Visited' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #All #defaultString: 'All' #catalogID: #menus) 				#value: #selectAll 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #selectAll ) 				#helpText: #(#{Kernel.UserMessage} #key: #SelectAllFields #defaultString: 'Select All Fields' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Eval #defaultString: 'Eval' #catalogID: #menus) 				#value: #toggleEvaluationPane 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #toggleEvalPane ) 				#helpText: #(#{Kernel.UserMessage} #key: #ToggleEvaluationPane #defaultString: 'Toggle Evaluation Pane' #catalogID: #menus) ) ) #(2 4 2 ) nil ) decodeAsLiteralArray</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Magnitude</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>UISpecification</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>Context</name><environment>Kernel</environment><super>Kernel.InstructionStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sender receiver stackp stack </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>MethodDefinition</name><environment>Tools</environment><super>Tools.GeneralMethodDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inheritingClass implementingClass selector extraText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>Tools-Programming</package></attributes></class><class><name>VisualComponent</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>KeyedCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>SubCanvasSpec</name><environment>UI</environment><super>UI.NamedSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>majorKey minorKey clientKey </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>OrderedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>firstIndex lastIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>ClassDescription</name><environment>Core</environment><super>Core.Behavior</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instanceVariables organization </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>FullSpec</name><environment>UI</environment><super>UI.UISpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>window component </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>CompiledCode</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>bytes </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>CompiledMethod</name><environment>Kernel</environment><super>Kernel.CompiledMainBlock</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>mclass sourceCode </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Signal</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent mayProceed notifierString nameClass nameMessage exceptionClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>SpecCollection</name><environment>UI</environment><super>UI.UISpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Set</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>tally </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>PoolDictionary</name><environment>Kernel</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>definingClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Support</category><attributes><package>System-Support</package></attributes></class><class><name>VisualPart</name><environment>Graphics</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>container eventHandlers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>CompositePart</name><environment>Graphics</environment><super>Graphics.VisualPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>components preferredBounds </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>Wrapper</name><environment>Graphics</environment><super>Graphics.VisualPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>component </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>View</name><environment>UI</environment><super>Graphics.DependentPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controller properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>GeneralNameSpace</name><environment>Kernel</environment><super>Core.KeyedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>organization bindings specificImports generalImports </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>Controller</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model view sensor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>ArrayedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Symbol</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Fraction</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars>numerator denominator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>ScheduledWindow</name><environment>UI</environment><super>Graphics.Window</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label icon minimumSize maximumSize component lookPreferences paintPreferences edgeDecorationPolicy widgetPolicy controller model damageRepairPolicy masterWindow </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>ApplicationWindow</name><environment>UI</environment><super>UI.ScheduledWindow</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyboardProcessor application sendWindowEvents receiveWindowEvents windowEventBlock damageRepairIsLazy activationNotification isEventDriven toolbarVisible dropTarget dragDropInProgress dragDropTracker </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class></st-source>