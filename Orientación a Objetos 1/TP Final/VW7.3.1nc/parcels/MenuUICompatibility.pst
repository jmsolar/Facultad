<?xml version="1.0"?><st-source><!-- Name: MenuUICompatibilityNotice: Copyright © 2005 Cincom Systems, Inc.  All Rights Reserved.Comment: MenuUICompatibility is a preview parcel for coding changes to support AR 47543 "Menu UILookPolicy feel compliance issues".  The changes attempt to remove incompatibilities of VW menu bar menus with  host OS menu feel requirements so that:   1.  For Windows, a mouse drag (i.e. mouse button hold and move) to a menu item with a submenu should not close the menu or submenu upon button release.2.  Only Windows menus will highlight disabled menu items; other platforms skip past disabled menu items entirely.3.  MacOSX menus will not wrap highlight of menu items for key up/down navigation.4.  Mac OS8/9 closes all menus upon any key press.5.  Unix platforms will not highlight menu items while moving the mouse cursor over an item; the mouse button must be down to do this.  6.  Except on Unix, submenu item menus open after about a 0.5 second delay when the mouse cursor is over them.7.  For the Motif and Windows look, a menu and submenu should remain open after a mouse click and release on a menu item with a submenu.8.  On Mac platforms, moving the mouse outside a menu to the right should not close all submenus open.9.  On Mac OSX, <Tab> and <Shift><Tab> navigate and open menus right and left in the menu bar.10. On Mac OSX, a menu and all its submenus should not close prematurely if the up or down arrow keys are used to navigate to a menu item with an unopened submenu.11. (Optional) For MS Windows and Motif menus, a menu item that opens a submenu cannot become selection itself then close; only a menu item without submenu may be the menu selection.For item 11 above, there are VW users that wish to preserve the ability to assume a menu item with a submenu as selection.  By default this has been preserved.  To assume the MS Windows and Motif standard behavior he class variable SubmenuAssumesSelection has been added to Win95MenuController and MotifMenuController.  Class comments of MotifMenuController and Win95MenuController were changed to include the definition of the class variables.It is described as follows:If true, extend MS Windows [OSF/Motif] behavior and allow a menu item with a submenu to be the selection.  If false, only a menu item without a submenu may assume selection (standard MS Windows [OSF/Motif] behavior).Evaluating:  MotifMenuController submenuAssumesSelection: false.  Win95MenuController submenuAssumesSelection: false.will change to the OS standard menu behavior for either policy (i.e. item 11 on).DbIdentifier: bear73DbTrace: 50375HideSource: falsePackageName: MenuUICompatibilityParcel: #('MenuUICompatibility')ParcelName: MenuUICompatibilityPrintStringCache: (7.3 - 1.0,bobw)SaveSource: trueVersion: 7.3.1Date: 8:33:42 pm April 10, 2005 --><time-stamp>From VisualWorks®, 7.3.1 of April 10, 2005 on April 10, 2005 at 8:33:42 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>MotifMenuItemController</name><environment>UI</environment><super>UI.MenuItemController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UILooks-Motif</category><attributes><package>MenuUICompatibility</package></attributes></class><comment><class-id>UI.MotifMenuItemController</class-id><body>Instances of MotifMenuItemController are the standard Controller for MotifMenuItemViews. It is used for the Motif look and feel.This class is private to the implementation of MotifMenuItemView and MotifMenuView.  Other users should not interface to this class and should not subclass it.</body></comment><class><name>MotifMenuController</name><environment>UI</environment><super>UI.MenuController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UILooks-Motif</category><attributes><package>MenuUICompatibility</package></attributes></class><comment><class-id>UI.MotifMenuController</class-id><body>MotifMenuController defines behavior common for control of submenus with a MotifMenuView.   It is used for the Motif look and feel style menusThis class is private to the implementation of MenuView.  Users should not use this class directly or subclass it.Class Variables:	SubmenuAssumesSelection	&lt;Boolean&gt;	If true, allow a menu item with a submenu to assume selection.  Otherwise no menu items with a submenu can be selected (standard OSF/Motif behavior).</body></comment><class><name>MotifMenuAsSubmenuController</name><environment>UI</environment><super>UI.MotifMenuController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Controllers</category><attributes><package>MenuUICompatibility</package></attributes></class><comment><class-id>UI.MotifMenuAsSubmenuController</class-id><body>A MotifMenuAsSubmenuController is the controller for a MotifMenuView that has been opened as a submenu from a parent MotifMenuItemView. It is used with the Motif look and feel.This class is private to the implementation of MenuView.  Users should not use this class directly or subclass it.</body></comment><class><name>MotifMenuFromMenuBarController</name><environment>UI</environment><super>UI.MotifMenuController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Controllers</category><attributes><package>MenuUICompatibility</package></attributes></class><comment><class-id>UI.MotifMenuFromMenuBarController</class-id><body>A MotifMenuFromMenuBarController is the controller for a MotifMenuView that has been opened from a menu bar.  It is used for the Motif look and feel.This class is private to the implementation of MenuView.  Users should not use this class directly or subclass it.</body></comment><shared-variable><name>SubmenuAssumesSelection</name><environment>UI.Win95MenuController</environment><private>false</private><constant>false</constant><category>setup</category><initializer>true</initializer><attributes><package>MenuUICompatibility</package></attributes></shared-variable><shared-variable><name>SubmenuAssumesSelection</name><environment>UI.MotifMenuController</environment><private>false</private><constant>false</constant><category>setup</category><initializer>true</initializer><attributes><package>MenuUICompatibility</package></attributes></shared-variable><methods><class-id>UI.MotifMenuItemController</class-id> <category>events</category><body package="MenuUICompatibility" selector="mouseMovedEvent:">mouseMovedEvent: event 	super mouseMovedEvent: event.	(event anyButtonPressed and: [self view menuItem hasSubmenu]) 		ifTrue: [self view openSubMenu]</body></methods><methods><class-id>UI.MotifMenuController</class-id> <category>events</category><body package="MenuUICompatibility" selector="closeEvent:">closeEvent: event	"Don't shut down but allow a button pressed event to follow and possibily open another menu bar menu"	self shutDownScrollProcess.	^nil</body></methods><methods><class-id>UI.MotifMenuController class</class-id> <category>setup</category><body package="MenuUICompatibility" selector="submenuAssumesSelection">submenuAssumesSelection	^SubmenuAssumesSelection ifNil:[true]</body><body package="MenuUICompatibility" selector="submenuAssumesSelection:">submenuAssumesSelection: aBoolean	"If true, extend OSF/Motif behavior and allow a menu item with a submenu to assume selection.  If false, only a menu item without a submenu may assume selection (standard OSF/Motif behavior)"	SubmenuAssumesSelection := aBoolean</body></methods><methods><class-id>UI.MotifMenuAsSubmenuController</class-id> <category>events</category><body package="MenuUICompatibility" selector="buttonPressedEvent:">buttonPressedEvent: event 	"If a button press is outside my bounds allow my parent menu to process it because the event might be intended to select an item in my parent menu"	"Ignore bogus button pressed events caused by opening up the TransientWindow"	state == #waitForReleaseToSelect ifTrue: [^nil].	(self handlerToKeepForMouseEvent: event) ifNotNil: 			[:targetController | 			targetController == self 				ifFalse: 					[| targetWindow |					targetWindow := targetController view topComponent.					targetWindow windowManager addEvent: (event window: targetWindow).					^event]].	state == #waitForMousePressed 		ifTrue: 			[state := #waitForReleaseToSelect.			^event].	^nil</body><body package="MenuUICompatibility" selector="buttonReleasedEvent:">buttonReleasedEvent: event 	(self class submenuAssumesSelection 		and: [state == #waitForReleaseToSelect]) 			ifTrue: 				[state := #finished.				view noSelectedMenuItem.				^event].	view highlightedMenuItemView ifNil: 			[state := #waitForMousePressed.			view highlightNextMenuItem.			^event].	state == #waitForReleaseToSelect 		ifTrue: 			[(self parentViewHasCursorWithEvent: event) 				ifFalse: 					[state := #finished.					view noSelectedMenuItem.					^event].			^nil].	^nil</body><body package="MenuUICompatibility" selector="exposeEvent:">exposeEvent: event 	super exposeEvent: event.	state := event anyButtonPressed 				ifTrue: [#waitForReleaseToSelect]				ifFalse: [#waitForMousePressed].	^nil</body><body package="MenuUICompatibility" selector="mouseMovedEvent:">mouseMovedEvent: event 	"If the cursor moves to a new item in a parent menu or menu bar close the submenu.  Otherwise, keep the submenu open. Compensate for the global origin offset of the translating sensor"	event anyButtonPressed 		ifTrue: 			[((view bounds expandedBy: self leftEdgeOffset @ 0) 				containsPoint: (sensor cursorPointFor: event)) 					ifFalse: 						[view parentMenuItemView ifNil: [^nil].						(self isControlWantedInMenuBarWithEvent: event) 							ifTrue: 								[self finishAllParents.								^event].						self finishOnNextParentItemWithEvent: event].			^super mouseMovedEvent: event].	^nil</body></methods><methods><class-id>UI.MotifMenuAsSubmenuController</class-id> <category>privileged</category><body package="MenuUICompatibility" selector="finishOnNextParentItemWithEvent:">finishOnNextParentItemWithEvent: event 	"If the cursor has moved to a new item in any parent menu then finish this submenu and answer true"	| parentItemView result |	state = #finished ifTrue: [^true].	parentItemView := view parentMenuItemView.	result := parentItemView isNil or: 					[parentItemView isOpen not or: 							[(parentItemView controller isChildControlActiveWithEvent: event) not and: 									[| parentMenuController |									parentMenuController := parentItemView menuView controller.									(parentMenuController isMenuItemControlActiveWithEvent: event) 										or: [parentMenuController finishOnNextParentItemWithEvent: event]]]].	result ifTrue: [state := #finished].	^result</body><body package="MenuUICompatibility" selector="handlerToKeepForMouseEvent:">handlerToKeepForMouseEvent: event 	"If event targets any predecessor menu then finish this submenu and answer the target controller.  Answer nil and finish all if the event lies outside all menus "	| targetController |	targetController := (self viewHasCursorWithEvent: event) 				ifTrue: [self]				ifFalse: 					[view parentMenuItemView 						ifNotNil: [:parentItemView | parentItemView menuView controller handlerToKeepForMouseEvent: event]].	targetController == self ifFalse: [state := #finished].	^targetController</body><body package="MenuUICompatibility" selector="parentViewHasCursorWithEvent:">parentViewHasCursorWithEvent: event 	"Answer whether the receiver should retain control of any predecessor menu.  If the cursor is in any menu item view from whose ancestry the receiver view has opened then let the receiver retain control.  Compare with MenuItemController&gt;&gt;isChildControlActiveWithEvent:"	^view parentMenuItemView ifNil: [false]		ifNotNil: 			[:parentItemView | 			(parentItemView controller viewHasCursorWithEvent: event) 				or: [parentItemView menuView controller parentViewHasCursorWithEvent: event]]</body></methods><methods><class-id>UI.MotifMenuAsSubmenuController</class-id> <category>initialize-release</category><body package="MenuUICompatibility" selector="initialize">initialize	"Initialize the receiver to assume the mouse is pressed."	super initialize.	state := #waitForMousePressed</body></methods><methods><class-id>UI.MotifMenuAsSubmenuController</class-id> <category>private</category><body package="MenuUICompatibility" selector="leftEdgeOffset">leftEdgeOffset	^3</body></methods><methods><class-id>UI.MotifMenuFromMenuBarController</class-id> <category>events</category><body package="MenuUICompatibility" selector="buttonPressedEvent:">buttonPressedEvent: event 	state == #waitForMousePressed ifTrue: [state := #waitForReleaseToSelect].	(self viewHasCursorWithEvent: event) 		ifFalse: 			[self isControlWantedInMenuBarWithEvent: event.			state := #finished.			^nil].	^event</body><body package="MenuUICompatibility" selector="buttonReleasedEvent:">buttonReleasedEvent: event 	"Mouse button released between two menu items; no selection"	(state ~~ #waitForReleaseToOpen 		or: [self viewHasCursorWithEvent: event]) 			ifFalse:				[self view highlightedMenuItemView == nil 					ifTrue: [self view highlightSelectionMemoryMenuItem].				state := #waitForMousePressed].	state == #waitForReleaseToSelect 		ifTrue: 			[state := #finished.			view noSelectedMenuItem.			^event].	^nil</body><body package="MenuUICompatibility" selector="exposeEvent:">exposeEvent: event 	super exposeEvent: event.	state := event anyButtonPressed 				ifTrue: 					[#waitForReleaseToOpen]				ifFalse: 					[self view highlightedMenuItemView == nil 						ifTrue: [self view highlightSelectionMemoryMenuItem].					#waitForMousePressed].	^nil</body><body package="MenuUICompatibility" selector="mouseMovedEvent:">mouseMovedEvent: event 	super mouseMovedEvent: event.	event anyButtonPressed 		ifTrue: 			[(self viewHasCursorWithEvent: event) 				ifTrue: 					[state == #waitForReleaseToOpen ifTrue: [state := #waitForReleaseToSelect]]				ifFalse: 					[(self isControlWantedInMenuBarWithEvent: event) 						ifTrue: [state := #finished]].			^event].	^nil</body></methods><methods><class-id>UI.MotifMenuFromMenuBarController</class-id> <category>privileged</category><body package="MenuUICompatibility" selector="handlerToKeepForMouseEvent:">handlerToKeepForMouseEvent: aMouseEvent 	"If event targets any menu bar button then finish this submenu and answer nil.  Otherwise answer the receiver"	^(self viewHasCursorWithEvent: aMouseEvent) 		ifTrue: [self]		ifFalse: 			[self isControlWantedInMenuBarWithEvent: aMouseEvent.			state := #finished.			nil]</body></methods><methods><class-id>UI.MotifMenuFromMenuBarController</class-id> <category>event driven</category><body package="MenuUICompatibility" selector="releaseToOpen">releaseToOpen	"Check if the user can and did use click-release to open this 	menu.Wait for and answer whether control is finally transferred 	from the menu bar button by the user releasing the mouse button 	(answer false if the user just moves off the menu bar button 	without releasing the menu bar button)."	^self view parentMenuBarButtonView canClickReleaseToOpenMenu</body><body package="MenuUICompatibility" selector="viewHasCursorWithEvent:">viewHasCursorWithEvent: event	"Answer true if the cursor point of the receiver's sensor lies within	 the display box of the receiver's view. Controller|viewHasCursor is	 normally used in internal methods."	view == nil ifTrue: [^false].	event hasPoint ifFalse: [^false].	^(view bounds expandedBy: (Rectangle		left: 0		right: 0		top: view insetWidthOfMenuBorder		bottom: 0)) containsPoint: (self sensor mousePointForEvent: event)</body></methods><methods><class-id>UI.MotifMenuFromMenuBarController</class-id> <category>cursor</category><body package="MenuUICompatibility" selector="viewHasCursor">viewHasCursor	"Answer true if the cursor point of the receiver's sensor lies within 	the display box of the receiver's view. Expand the bounds to include 	the border of a menu window pulled down from a menu bar."	| sen |	view == nil ifTrue: [^false].	sen := self sensor.	^sen isActive and: [(view bounds expandedBy: (Rectangle				left: 0				right: 0				top: view borderTopThickness				bottom: 0))			containsPoint: sen cursorPoint]</body></methods><methods><class-id>UI.MotifMenuItemView</class-id> <category>privileged-selection</category><body package="MenuUICompatibility" selector="assumeSelection">assumeSelection	"The receiver is to become the 'selected' highlighted menu item.  Usually sent from the controller."	self menuView highlightedMenuItemView: self.</body></methods><methods><class-id>UI.MotifMenuItemView</class-id> <category>controller accessing</category><body package="MenuUICompatibility" selector="defaultControllerClass">defaultControllerClass	"Answer the class of the default controller for the receiver."	^MotifMenuItemController</body></methods><methods><class-id>UI.MotifMenuItemView</class-id> <category>privileged-selection</category><body package="MenuUICompatibility" selector="openSubMenu">openSubMenu	self menuView controller waitToOpenSubmenu.	super openSubMenu.</body><body package="MenuUICompatibility" selector="openSubMenuByKey">openSubMenuByKey	"Open the submenu of this menu item with a default item highlighted."	self upcastEvent: #triggerEvent: with: (Array with: #submenuOpened: with: model nameKey).	(self subMenuViewClass model: model submenu) 		highlightSelectionMemoryMenuItem;	     openFromParentMenuItemView: self.	self upcastEvent: #triggerEvent: with: (Array with: #submenuClosed: with: model nameKey).</body></methods><methods><class-id>UI.MacOSXMenuItemView</class-id> <category>privileged-selection</category><body package="MenuUICompatibility" selector="finalizeSelection">finalizeSelection	"The user has indicated completion of menu item selection while over this menu item.  So if this menu item is enabled, this is the selected menu item.  This message is sent from the controller."	self isEnabled		ifTrue: [self menuView highlightMenuItemView: self flashRepeat: 1 delayedBy: 90.				  self menuView selectedMenuItem: self model]		ifFalse: [self menuView noSelectedMenuItem].</body></methods><methods><class-id>UI.Win95MenuFromMenuBarController</class-id> <category>events</category><body package="MenuUICompatibility" selector="buttonPressedEvent:">buttonPressedEvent: event 	state == #waitForMousePressed ifTrue: [state := #waitForReleaseToSelect].	(self viewHasCursorWithEvent: event) 		ifFalse: 			[self isControlWantedInMenuBarWithEvent: event.			state := #finished.			^nil].	^event</body></methods><methods><class-id>UI.MenuItemController</class-id> <category>basic control sequence</category><body package="MenuUICompatibility" selector="controlInitialize">controlInitialize	"Initializing the controlLoop of the receiver (taking into account the current state of its model, view, and sensor."		super controlInitialize.	self isEnabled ifTrue: [self view assumeSelection].</body><body package="MenuUICompatibility" selector="controlTerminate">controlTerminate	"Terminating the controlLoop of the receiver (taking into account the current state of its model, view, and sensor)."	super controlTerminate.	self view isSelection ifTrue: [self view resignSelection]</body></methods><methods><class-id>UI.MenuItemController</class-id> <category>events</category><body package="MenuUICompatibility" selector="redButtonPressedEvent:">redButtonPressedEvent: event 	self view isSelection ifFalse: [self view assumeSelection].	self view menuItem hasSubmenu ifTrue: [self view openSubMenu].</body><body package="MenuUICompatibility" selector="redButtonReleasedEvent:">redButtonReleasedEvent: event 	self view menuItem hasSubmenu ifFalse: [self sensorNoButtonPressed]</body></methods><methods><class-id>UI.Win95MenuController class</class-id> <category>setup</category><body package="MenuUICompatibility" selector="submenuAssumesSelection">submenuAssumesSelection	^SubmenuAssumesSelection ifNil:[true]</body><body package="MenuUICompatibility" selector="submenuAssumesSelection:">submenuAssumesSelection: aBoolean	"If true, extend MS Windows behavior and allow a menu item with a submenu to assume selection.  If false, only a menu item without a submenu may assume selection (standard MS Windows behavior)"	SubmenuAssumesSelection := aBoolean</body></methods><methods><class-id>UI.Win95MenuController</class-id> <category>events</category><body package="MenuUICompatibility" selector="finishAllParents">finishAllParents	(self class submenuAssumesSelection and: [self isMenuItemControlActive]) 		ifFalse: [super finishAllParents]</body><body package="MenuUICompatibility" selector="handleEvent:">handleEvent: event 	"In the OS-Window System world, we only need to know if someone has hit outside of the menu	which includes outside the window the menu is popped in"	(event isWindowExit not 		or: [state == #waitForMouse or: [self viewHasCursorWithEvent: event]]) 			ifFalse: 				[self finishAllParents.				self shutDownScrollProcess.				^event].	^super handleEvent: event</body></methods><methods><class-id>UI.MacMenuItemView</class-id> <category>privileged-selection</category><body package="MenuUICompatibility" selector="assumeSelection">assumeSelection	"The receiver is to become the 'selected' highlighted menu item.	Usually sent from the controller."	self menuView highlightedMenuItemView: self.	(self menuItem hasSubmenu and: [self isEnabled]) 		ifTrue: [self openSubMenuDelayedBy: 300]</body><body package="MenuUICompatibility" selector="assumeSelectionByKey">assumeSelectionByKey	"The receiver is to become the 'selected' highlighted menu item.	Usually sent from the controller."	self menuView highlightedMenuItemView: self.</body><body package="MenuUICompatibility" selector="finalizeSelection">finalizeSelection	"The user has indicated completion of menu item selection while over this menu item.  So if this menu item is enabled, this is the selected menu item.  This message is sent from the controller."	self isEnabled		ifTrue: [self menuView highlightMenuItemView: self flashRepeat: 3 delayedBy: 40.				  self menuView selectedMenuItem: self model]		ifFalse: [self menuView noSelectedMenuItem].</body><body package="MenuUICompatibility" selector="openSubMenuByKey">openSubMenuByKey	"Open the submenu of this menu item."	| submenuView |	self upcastEvent: #triggerEvent: with: (Array with: #submenuOpened: with: model nameKey).	(submenuView := self subMenuViewClass model: model submenu) 		highlightedMenuItemView: submenuView menuItemViewsAsCollection first;	     openFromParentMenuItemView: self.	self upcastEvent: #triggerEvent: with: (Array with: #submenuClosed: with: model nameKey).</body></methods><methods><class-id>UI.Win95MenuAsSubmenuController</class-id> <category>events</category><body package="MenuUICompatibility" selector="exposeEvent:">exposeEvent: event 	super exposeEvent: event.	state := event anyButtonPressed		ifTrue: [#waitForReleaseToSelect]		ifFalse: [#waitForMousePressed].	^nil</body></methods><methods><class-id>UI.Win95MenuAsSubmenuController</class-id> <category>privileged</category><body package="MenuUICompatibility" selector="finishAllParents">finishAllParents	"Finish and close all parent menus"	view parentMenuItemView 		ifNotNil: [:parentItemView | parentItemView menuView controller finishAllParents].	super finishAllParents</body><body package="MenuUICompatibility" selector="finishOnNextParentItemWithEvent:">finishOnNextParentItemWithEvent: event 	"If the cursor has moved to a new item in any parent menu then finish this submenu and answer true"	| parentItemView result |	state = #finished ifTrue: [^true].	parentItemView := view parentMenuItemView.	result := parentItemView isNil or: 					[parentItemView isOpen not or: 							[(parentItemView controller isChildControlActiveWithEvent: event) not and: 									[| parentMenuController |									parentMenuController := parentItemView menuView controller.									(parentMenuController isMenuItemControlActiveWithEvent: event) 										or: [parentMenuController finishOnNextParentItemWithEvent: event]]]].	result ifTrue: [state := #finished].	^result</body></methods><methods><class-id>UI.Win95MenuAsSubmenuController</class-id> <category>events</category><body package="MenuUICompatibility" selector="handleEvent:">handleEvent: event 	(self class submenuAssumesSelection not 		and: [self parentViewHasCursorWithEvent: event]) ifTrue: [^nil].	^super handleEvent: event</body><body package="MenuUICompatibility" selector="mouseMovedEvent:">mouseMovedEvent: event 	"If the cursor moves to a new item in a parent menu or menu bar close the submenu.  Otherwise, keep the submenu open. Compensate for the global origin offset of the translating sensor"	((view bounds expandedBy: 3 @ 0) 		containsPoint: (sensor cursorPointFor: event)) 			ifFalse: 				[view parentMenuItemView ifNil: [^nil].				(self isControlWantedInMenuBarWithEvent: event) 					ifTrue: 						[self finishAllParents.						^event].				self finishOnNextParentItemWithEvent: event].	^super mouseMovedEvent: event</body></methods><methods><class-id>UI.Win95MenuAsSubmenuController</class-id> <category>privileged</category><body package="MenuUICompatibility" selector="parentViewHasCursorWithEvent:">parentViewHasCursorWithEvent: event 	"Answer whether the receiver should retain control of any ancestor menu.  If the cursor is in any menu item view from whose ancestry the receiver view has opened then let the receiver retain control.  Compare with MenuItemController&gt;&gt;isChildControlActiveWithEvent:"	^view parentMenuItemView ifNil: [false]		ifNotNil: 			[:parentItemView | 			(parentItemView controller viewHasCursorWithEvent: event) 				or: [parentItemView menuView controller parentViewHasCursorWithEvent: event]]</body></methods><methods><class-id>UI.Win95MenuAsSubmenuController</class-id> <category>events</category><body package="MenuUICompatibility" selector="windowEnterEvent:">windowEnterEvent: event 	state := event anyButtonPressed 				ifTrue: [#waitForReleaseToSelect]				ifFalse: [#waitForMousePressed].	^nil</body></methods><methods><class-id>UI.MenuFromMenuBarController</class-id> <category>events</category><body package="MenuUICompatibility" selector="buttonReleasedEvent:">buttonReleasedEvent: event 	"Mouse button released between two menu items; no selection"	(state == #waitForReleaseToOpen 		and: [(self viewHasCursorWithEvent: event) not]) 			ifTrue: 				[self view highlightedMenuItemView == nil 					ifTrue: [self view highlightSelectionMemoryMenuItem].				state := #waitForMousePressed].	state == #waitForReleaseToSelect 		ifTrue: 			[state := #finished.			^event].	^nil</body><body package="MenuUICompatibility" selector="enterEvent:">enterEvent: event 	^event anyButtonPressed 		ifTrue: 			[state := self releaseToOpen 						ifTrue: [#waitForReleaseToOpen]						ifFalse: [#waitForReleaseToSelect].			event]		ifFalse: 			[state := self releaseToOpen 						ifTrue: [#waitForReleaseToSelect]						ifFalse: [#finished].			nil]</body><body package="MenuUICompatibility" selector="exposeEvent:">exposeEvent: event 	super exposeEvent: event.	state := event anyButtonPressed 				ifTrue: 					[self releaseToOpen 						ifTrue: [#waitForReleaseToOpen]						ifFalse: [#waitForReleaseToSelect]]				ifFalse: 					[self view highlightedMenuItemView == nil 						ifTrue: [self view highlightSelectionMemoryMenuItem].					self releaseToOpen ifTrue: [#waitForMousePressed] ifFalse: [#finished]].	^nil</body></methods><methods><class-id>UI.MenuView</class-id> <category>privileged-current selection</category><body package="MenuUICompatibility" selector="childSelectionValue:">childSelectionValue: aMenuItem 	"Set the value object associated with a selection that 	has been made in a child submenu. 	If the selection is still in the receiver's menu then set 	the value to the menuItem's value."	| menuItem |	menuItem := self highlightedMenuItemView ifNotNil: [:view | view menuItem].	selectedValue := aMenuItem ifNil: 					[menuItem 						ifNotNil: [:item | (item value isKindOf: Menu) ifTrue: [nil] ifFalse: [menuItem]]].	selectionFinal := true.	self menu selectionMemory: menuItem</body><body package="MenuUICompatibility" selector="highlightFirstMenuItem">highlightFirstMenuItem	"Hilight the first enabled menu item"	highlightedMenuItemView ifNil: [self highlightNextMenuItem]</body><body package="MenuUICompatibility" selector="highlightMenuItemView:flashRepeat:delayedBy:">highlightMenuItemView: aMenuItemView flashRepeat: repeatTimes delayedBy: milliseconds 	| delay |	delay := Delay forMilliseconds: milliseconds.	repeatTimes timesRepeat: 			[self highlightedMenuItemView: aMenuItemView.			delay wait.			self highlightedMenuItemView: nil.			delay wait].	self highlightedMenuItemView: aMenuItemView.	delay wait.</body></methods><methods><class-id>UI.MenuView</class-id> <category>privileged-parent menu</category><body package="MenuUICompatibility" selector="openFromParentMenuItemView:">openFromParentMenuItemView: theParentMenuItemView 	"Open the receiver as a child menu of the given parent MenuItemView.  Allow the user to make a selection.  Answer the menu item that was selected (or nil if none)."	| theScreen parentDisplayBox monitorRectangle wrappedMenu menuWindowBounds intoMonitor menuWindow theSelectionMemoryMenuItem positioningMenuItemView offsetForMenuItem |	parentMenuItemView := theParentMenuItemView.	self controller: MenuAsSubmenuController new.	(self prepareMenuItemViewsToMinWidth: 0) ifFalse: [^nil].	theScreen := theParentMenuItemView graphicsDevice.	parentDisplayBox := self displayBoxOfView: parentMenuItemView.	monitorRectangle := (theScreen 				preferredRectangleToConstrain: parentDisplayBox) insetBy: 4.	wrappedMenu := self withBoundedWrapper.	menuWindowBounds := wrappedMenu preferredBounds.	menuWindowBounds 		height: (menuWindowBounds height min: monitorRectangle height).	wrappedMenu bounds: (0 @ 0 extent: menuWindowBounds extent).	menuWindow := self menuWindowOn: theScreen in: menuWindowBounds.	menuWindow component: wrappedMenu.	"Position last selected menu item next to parent menu item."	theParentMenuItemView menuView usedSelectionMemory 		ifTrue: 			[usedSelectionMemory := true.			theSelectionMemoryMenuItem := self menu selectionMemory.			self menuItemViewsAsCollection do: 					[:eachView | 					eachView menuItem == theSelectionMemoryMenuItem 						ifTrue: [positioningMenuItemView := eachView]]].	offsetForMenuItem := positioningMenuItemView == nil 				ifTrue: [0 @ 0]				ifFalse: 					[positioningMenuItemView 						localPointToGlobal: positioningMenuItemView bounds origin].	menuWindow 		moveTo: parentDisplayBox topRight + self topRightOffsetAsChildMenu 				- offsetForMenuItem.	"Adjust to fit between left and right sides of monitor."	intoMonitor := menuWindow displayBox 				amountToTranslateWithin: monitorRectangle.	menuWindow moveTo: menuWindow globalOrigin + intoMonitor.	self setColorsInMenuWindow: menuWindow from: theParentMenuItemView.	self mapAndStartupEventDriven: menuWindow.	selectionFinal == true 		ifTrue: [theParentMenuItemView menuView childSelectionValue: self selectedValue]</body></methods><methods><class-id>UI.MenuView</class-id> <category>privileged-parent view</category><body package="MenuUICompatibility" selector="openFromView:">openFromView: aView 	"Open the menu over aView in the 'pop up' style.  Answer the value object associated with the menu item that was selected (or nil if none)."	| theScreen parentDisplayBox monitorRectangle wrappedMenu menuWindowBounds intoMonitor menuWindow positioningMenuItemView offsetForMenuItem theSelectionMemoryMenuItem |	self controller: MenuAsPopUpController new.	(self prepareMenuItemViewsToMinWidth: 0) ifFalse: [^nil].	theScreen := aView graphicsDevice.	parentDisplayBox := self displayBoxOfView: aView.	monitorRectangle := (theScreen 				preferredRectangleToConstrain: parentDisplayBox) insetBy: 4.	wrappedMenu := self withBoundedWrapper.	menuWindowBounds := wrappedMenu preferredBounds.	menuWindowBounds 		height: (menuWindowBounds height min: monitorRectangle height).	wrappedMenu bounds: (0 @ 0 extent: menuWindowBounds extent).	menuWindow := self menuWindowOn: theScreen in: menuWindowBounds.	menuWindow component: wrappedMenu.	"Position last selected menu item under cursor."	usedSelectionMemory := true.	theSelectionMemoryMenuItem := self menu selectionMemory.	self menuItemViewsAsCollection do: 			[:eachView | 			eachView menuItem == theSelectionMemoryMenuItem 				ifTrue: 					[positioningMenuItemView := eachView.					selectedValue := theSelectionMemoryMenuItem]].	offsetForMenuItem := positioningMenuItemView == nil 				ifTrue: [0 @ 0]				ifFalse: 					[positioningMenuItemView 						localPointToGlobal: positioningMenuItemView bounds origin].	menuWindow 		moveTo: self controller sensor globalCursorPoint 				+ self cursorOffsetForPopUpStyle - offsetForMenuItem.	"Adjust to fit between left and right sides of monitor."	intoMonitor := menuWindow displayBox 				amountToTranslateWithin: monitorRectangle.	menuWindow moveTo: menuWindow globalOrigin + intoMonitor.	self setColorsInMenuWindow: menuWindow from: aView.	self mapAndStartupEventDriven: menuWindow.	aView topComponent becomeActive.	^self selectedValue</body></methods><methods><class-id>UI.MenuView</class-id> <category>private</category><body package="MenuUICompatibility" selector="parentMenuBarButtonView">parentMenuBarButtonView	"Answer the parent menu bar button view (or nil if none)."	^parentMenuBarButtonView ifNil: 			[parentMenuItemView 				ifNotNil: [parentMenuItemView menuView parentMenuBarButtonView]]</body></methods><methods><class-id>UI.MenuView</class-id> <category>privileged-parent menu</category><body package="MenuUICompatibility" selector="parentMenuItemSelected">parentMenuItemSelected	"Answer if the menu item that is the parent of the this menu is selected, or false if none exists"	^parentMenuItemView ifNil: [false]		ifNotNil: [parentMenuItemView isSelection]</body></methods><methods><class-id>UI.MenuView</class-id> <category>privileged-current selection</category><body package="MenuUICompatibility" selector="returnToParentOrMenuToLeft">returnToParentOrMenuToLeft	"Close the receiver and return to the parent menu item view or the menu to the left on the menu bar."	self noSelectedMenuItem.	parentMenuItemView ifNil: [self highlightPreviousMenuBarButton]</body></methods><methods><class-id>UI.MenuView</class-id> <category>privileged-parent menu</category><body package="MenuUICompatibility" selector="submenuClosed">submenuClosed	"A submenu of one of self's menu items has closed and it is notifying self.	If the selection isn't finalized, I may have to worry about repairing damage on myself or my parent menu."	self selectionFinalized ifTrue: [^self].	self topComponent ifNotNil: [:win | win repairDamages].	parentMenuItemView ifNotNil: [parentMenuItemView menuView submenuClosed]</body></methods><methods><class-id>UI.MenuController</class-id> <category>events</category><body package="MenuUICompatibility" selector="closeEvent:">closeEvent: event	self finishAllParents.	self shutDownScrollProcess.	^nil</body></methods><methods><class-id>UI.MenuController</class-id> <category>privileged</category><body package="MenuUICompatibility" selector="finishAllParents">finishAllParents	state := #finished.	self processEscape</body><body package="MenuUICompatibility" selector="finishOnNextParentItemWithEvent:">finishOnNextParentItemWithEvent: aMouseEvent 	^false</body><body package="MenuUICompatibility" selector="handlerToKeepForMouseEvent:">handlerToKeepForMouseEvent: aMouseEvent 	"If event targets any menu bar button then finish this submenu and answer nil.  Otherwise answer the receiver"	^(self viewHasCursorWithEvent: aMouseEvent) 		ifTrue: [self]		ifFalse: 			[state := #finished.			nil]</body><body package="MenuUICompatibility" selector="parentViewHasCursorWithEvent:">parentViewHasCursorWithEvent: event	^false</body></methods><methods><class-id>UI.MenuController</class-id> <category>protected-keyboard</category><body package="MenuUICompatibility" selector="processRightKey">processRightKey	"Perform the standard action when the right arrow is pressed."	"By default, when the highlighted menu item hasSubmenu, then open the submenu."	state := #waitForMouse.	self view openSubMenuOrMenuToRight</body></methods><methods><class-id>UI.MenuController</class-id> <category>privileged</category><body package="MenuUICompatibility" selector="waitToOpenSubmenu">waitToOpenSubmenu	state := #waitForMousePressed</body></methods><methods><class-id>UI.MenuItemView</class-id> <category>selection-privileged</category><body package="MenuUICompatibility" selector="openSubMenu">openSubMenu	"Open the submenu of this menu item."	self upcastEvent: #triggerEvent: with: (Array with: #submenuOpened: with: model nameKey).	(self subMenuViewClass model: model submenu) openFromParentMenuItemView: self.	self upcastEvent: #triggerEvent: with: (Array with: #submenuClosed: with: model nameKey).</body><body package="MenuUICompatibility" selector="openSubMenuDelayedBy:">openSubMenuDelayedBy: delayMilliseconds 	"Open the submenu of this menu item if it is still selected after delayMilliseconds"		[(Delay forMilliseconds: delayMilliseconds) wait.	[(self isSelection and: [self isOpen]) ifTrue: [self openSubMenu]] uiEvent] 			fork</body></methods><methods><class-id>UI.MacOSXMenuAsSubmenuController</class-id> <category>events</category><body package="MenuUICompatibility" selector="buttonPressedEvent:">buttonPressedEvent: event 	"A button press toggles my mode. No button press outside my window will enter here in an event based control system"	state == #waitForMousePressed		ifTrue: 			[state := #waitForReleaseToSelect.			^event].	^nil</body></methods><methods><class-id>UI.MacOSXMenuAsSubmenuController</class-id> <category>privileged</category><body package="MenuUICompatibility" selector="finishOnNextParentItemWithEvent:">finishOnNextParentItemWithEvent: event 	"If the cursor has moved to a new item in any parent menu then finish this submenu and answer true"	| parentItemView result |	state = #finished ifTrue: [^true].	parentItemView := view parentMenuItemView.	result := parentItemView isNil or: 					[parentItemView isOpen not or: 							[(parentItemView controller isChildControlActiveWithEvent: event) not and: 									[| parentMenuController |									parentMenuController := parentItemView menuView controller.									(parentMenuController isMenuItemControlActiveWithEvent: event) 										or: [parentMenuController finishOnNextParentItemWithEvent: event]]]].	result 		ifTrue: 			[state := #finished].	^result</body></methods><methods><class-id>UI.MacOSXMenuAsSubmenuController</class-id> <category>private</category><body package="MenuUICompatibility" selector="leftEdgeOffset">leftEdgeOffset	^3</body></methods><methods><class-id>UI.MacOSXMenuAsSubmenuController</class-id> <category>events</category><body package="MenuUICompatibility" selector="mouseMovedEvent:">mouseMovedEvent: event 	"If the cursor moves to a new item in a parent menu or menu bar close the submenu.  Otherwise, keep the submenu open. Compensate for the global origin offset of the translating sensor"	((view bounds expandedBy: self leftEdgeOffset @ 0) 		containsPoint: (sensor cursorPointFor: event)) 			ifFalse: 				[view parentMenuItemView ifNil: [^nil].				(self isControlWantedInMenuBarWithEvent: event) 					ifTrue: 						[self finishAllParents.						^event].				self finishOnNextParentItemWithEvent: event].	^super mouseMovedEvent: event</body></methods><methods><class-id>UI.Win95MenuFromMenuButtonController</class-id> <category>events</category><body package="MenuUICompatibility" selector="buttonPressedEvent:">buttonPressedEvent: event 	state == #waitForMousePressed ifTrue: [state := #waitForReleaseToSelect].	(self viewHasCursorWithEvent: event) 		ifFalse: 			[self isControlWantedInMenuBarWithEvent: event.			state := #finished.			^nil].	^event</body><body package="MenuUICompatibility" selector="enterEvent:">enterEvent: event 	state := event anyButtonPressed		ifTrue: [#waitForReleaseToSelect]		ifFalse: [#waitForMousePressed].	^event</body></methods><methods><class-id>UI.Win95MenuView</class-id> <category>privileged-parent menu</category><body package="MenuUICompatibility" selector="openFromParentMenuItemView:">openFromParentMenuItemView: theParentMenuItemView	"Open the receiver as a child menu of the given parent MenuItemView.  Allow the user to make a selection.  Answer the menu item that was selected (or nil if none)."	| theScreen parentDisplayBox monitorRectangle wrappedMenu menuWindowBounds intoMonitor menuWindow theSelectionMemoryMenuItem positioningMenuItemView offsetForMenuItem |	parentMenuItemView := theParentMenuItemView.	self controller: Win95MenuAsSubmenuController new.	(self prepareMenuItemViewsToMinWidth: 0) ifFalse: [^nil].	theScreen := theParentMenuItemView graphicsDevice.	parentDisplayBox := self displayBoxOfView: parentMenuItemView.	monitorRectangle := theScreen preferredRectangleToConstrain: parentDisplayBox.	wrappedMenu := self withBoundedWrapper.	menuWindowBounds := wrappedMenu preferredBounds.	menuWindowBounds height: (menuWindowBounds height min: monitorRectangle height).	wrappedMenu bounds: (0@0 extent: menuWindowBounds extent).	menuWindow := self menuWindowOn: theScreen in: menuWindowBounds.	menuWindow component: wrappedMenu.	"Position last selected menu item next to parent menu item."	theParentMenuItemView menuView usedSelectionMemory ifTrue: [		usedSelectionMemory := true.		theSelectionMemoryMenuItem := self menu selectionMemory.		self menuItemViewsAsCollection do: [:eachView |			eachView menuItem == theSelectionMemoryMenuItem ifTrue: [				positioningMenuItemView := eachView]]].	positioningMenuItemView == nil		ifTrue: [offsetForMenuItem := 0@0]		ifFalse: [offsetForMenuItem := positioningMenuItemView localPointToGlobal: positioningMenuItemView bounds origin].	menuWindow moveTo: parentDisplayBox topRight + self topRightOffsetAsChildMenu - offsetForMenuItem.	(menuWindow displayBox right &gt; monitorRectangle right		and: [menuWindow displayBox left - parentDisplayBox width &gt;= monitorRectangle left])		ifTrue: [menuWindow moveTo: menuWindow globalOrigin - (parentDisplayBox width + menuWindow width - 4 @ 0)].	"Adjust to fit between left and right sides of monitor."	intoMonitor := menuWindow displayBox amountToTranslateWithin: monitorRectangle.	menuWindow moveTo: menuWindow globalOrigin + intoMonitor.	self setColorsInMenuWindow: menuWindow from: theParentMenuItemView.	self mapAndStartupEventDriven: menuWindow.	self selectedValue ifNotNil: [:theValue| theParentMenuItemView menuView childSelectionValue: theValue]</body></methods><methods><class-id>UI.MacOSXMenuFromMenuBarController</class-id> <category>events</category><body package="MenuUICompatibility" selector="exposeEvent:">exposeEvent: event 	super exposeEvent: event.	state := event anyButtonPressed 				ifTrue: [#waitForReleaseToOpen]				ifFalse: [#waitForMousePressed].	^nil</body><body package="MenuUICompatibility" selector="mouseMovedEvent:">mouseMovedEvent: event 	super mouseMovedEvent: event.	((self viewHasCursorWithEvent: event) not 		and: [self isControlWantedInMenuBarWithEvent: event]) 			ifTrue: [state := #finished].	^event</body></methods><methods><class-id>UI.Win95MenuItemView</class-id> <category>privileged-selection</category><body package="MenuUICompatibility" selector="assumeSelection">assumeSelection	"The receiver is to become the 'selected' highlighted menu item.	Usually sent from the controller."	self menuView highlightedMenuItemView: self.	(self menuItem hasSubmenu and: [self isEnabled])		ifTrue: [self openSubMenuDelayedBy: 300]</body></methods><methods><class-id>UI.MacMenuView</class-id> <category>privileged-current selection</category><body package="MenuUICompatibility" selector="highlightNextMenuItem">highlightNextMenuItem	"Hilight the next enabled menu item, if any (after the one currently highlighted). Don't wrap to first item in menu"	| flatMenuViews nextHighlight |	flatMenuViews := self menuItemViewsAsCollection.	nextHighlight := highlightedMenuItemView == nil 				ifTrue: [1]				ifFalse: [(flatMenuViews indexOf: highlightedMenuItemView) + 1].	nextHighlight to: flatMenuViews size		do: 			[:index | 			| nextMenuItemView |			(nextMenuItemView := flatMenuViews at: index) isEnabled 				ifTrue: 					[highlightedMenuItemView == nil 						ifFalse: [highlightedMenuItemView resignSelection].					nextMenuItemView assumeSelectionByKey.					^self]]</body><body package="MenuUICompatibility" selector="highlightPreviousMenuItem">highlightPreviousMenuItem	"Hilight the previous enabled menu item, if any (after the one currently highlighted). Don't wrap to last item in menu"	| flatMenuViews nextHighlight |	flatMenuViews := self menuItemViewsAsCollection.	nextHighlight := highlightedMenuItemView == nil 				ifTrue: [flatMenuViews size]				ifFalse: [(flatMenuViews indexOf: highlightedMenuItemView) - 1].	(nextHighlight to: 1 by: -1) do: 			[:index | 			| nextMenuItemView |			(nextMenuItemView := flatMenuViews at: index) isEnabled 				ifTrue: 					[highlightedMenuItemView == nil 						ifFalse: [highlightedMenuItemView resignSelection].					nextMenuItemView assumeSelectionByKey.					^self]]</body></methods><methods><class-id>UI.MacMenuView</class-id> <category>privileged-parent view</category><body package="MenuUICompatibility" selector="openFromMenuBarButton:">openFromMenuBarButton: theParentMenuBarButtonView	"Open the menu as a menu appearing from a menu button on a menu bar (the parentMenuBarButtonView).  The user will be given the opportunity to make a selection.  Answer the value object associated with the menu item that was selected (or nil if none)."	| theScreen parentDisplayBox monitorRectangle wrappedMenu menuWindowBounds intoMonitor menuWindow |	parentMenuBarButtonView := theParentMenuBarButtonView.	self controller: MacOSXMenuFromMenuBarController new.	(self prepareMenuItemViewsToMinWidth: 0) ifFalse: [^nil].	theScreen := theParentMenuBarButtonView graphicsDevice.	parentDisplayBox := self displayBoxOfView: theParentMenuBarButtonView.	monitorRectangle := (theScreen preferredRectangleToConstrain: parentDisplayBox) insetBy: 4.	wrappedMenu := self withBoundedWrapper.	menuWindowBounds := wrappedMenu preferredBounds.	menuWindowBounds := menuWindowBounds align: menuWindowBounds topLeft with: parentDisplayBox bottomLeft.	"Adjust to fit between left and right sides of monitor."	intoMonitor := menuWindowBounds amountToTranslateWithin: monitorRectangle.	menuWindowBounds := menuWindowBounds translatedBy: intoMonitor.	menuWindowBounds := menuWindowBounds intersect: monitorRectangle.	"Need to eventually adjust if the intersection makes the bounds too small."	menuWindow := self menuWindowOn: theScreen in: menuWindowBounds.	self setColorsInMenuWindow: menuWindow from: theParentMenuBarButtonView.	wrappedMenu bounds: (0@0 extent: menuWindowBounds extent).	menuWindow component: wrappedMenu.	self mapAndStartupEventDriven: menuWindow.	parentMenuBarButtonView topComponent becomeActive.	^self selectedValue</body><body package="MenuUICompatibility" selector="openFromParentMenuItemView:">openFromParentMenuItemView: theParentMenuItemView 	"Open the receiver as a child menu of the given parent MenuItemView. 	Allow the user to make a selection. 	Answer the menu item that was selected (or nil if none)."	| theScreen parentDisplayBox monitorRectangle wrappedMenu menuWindowBounds intoMonitor menuWindow theSelectionMemoryMenuItem positioningMenuItemView offsetForMenuItem |	parentMenuItemView := theParentMenuItemView.	self controller: MacOSXMenuAsSubmenuController new.	(self prepareMenuItemViewsToMinWidth: 0)		ifFalse: [^nil].	theScreen := theParentMenuItemView graphicsDevice.	parentDisplayBox := self displayBoxOfView: parentMenuItemView.	monitorRectangle := (theScreen preferredRectangleToConstrain: parentDisplayBox) insetBy: 4.	wrappedMenu := self withBoundedWrapper.	menuWindowBounds := wrappedMenu preferredBounds.	menuWindowBounds height: (menuWindowBounds height min: monitorRectangle height).	wrappedMenu bounds: (0 @ 0 extent: menuWindowBounds extent).	menuWindow := self menuWindowOn: theScreen in: menuWindowBounds.	menuWindow component: wrappedMenu.	"Position last selected menu item next to parent menu item."	theParentMenuItemView menuView usedSelectionMemory ifTrue: 		[usedSelectionMemory := true.		theSelectionMemoryMenuItem := self menu selectionMemory.		self menuItemViewsAsCollection do: 			[:each | 			each menuItem == theSelectionMemoryMenuItem ifTrue: [positioningMenuItemView := each]]].	positioningMenuItemView == nil		ifTrue: [offsetForMenuItem := 0 @ 0]		ifFalse: [offsetForMenuItem := positioningMenuItemView localPointToGlobal: positioningMenuItemView bounds origin].	menuWindow moveTo: parentDisplayBox topRight + self topRightOffsetAsChildMenu - offsetForMenuItem.	"Adjust to fit between left and right sides of monitor."	intoMonitor := menuWindow displayBox amountToTranslateWithin: monitorRectangle.	"Better submenu accessibility at the right monitor border"	intoMonitor x &lt; 0 ifTrue: 		[menuWindow moveTo: monitorRectangle corner x @ menuWindow globalOrigin y.		intoMonitor x: parentMenuItemView topComponent globalOrigin x - monitorRectangle corner x - (self bounds width - 9)].	"A Menu should be positioned inside the monitors bounds, and the beginning of the labels should be readable"	menuWindow moveTo: (menuWindow globalOrigin x + intoMonitor x max: 0) @ (menuWindow globalOrigin y + intoMonitor y).	self setColorsInMenuWindow: menuWindow from: theParentMenuItemView.	self mapAndStartupEventDriven: menuWindow.	selectionFinal == true 		ifTrue: [theParentMenuItemView menuView childSelectionValue: self selectedValue]</body></methods><methods><class-id>UI.MacMenuView</class-id> <category>privileged-current selection</category><body package="MenuUICompatibility" selector="openSubMenuOrMenuToRight">openSubMenuOrMenuToRight	"Open the submenu (if there is one) otherwise close the receiver and open the 	menu to the right on the menu bar."	highlightedMenuItemView ifNil: [self highlightNextMenuItem]		ifNotNil: 			[(highlightedMenuItemView menuItem hasSubmenu 				and: [highlightedMenuItemView menuItem isEnabled]) 					ifTrue: [highlightedMenuItemView openSubMenuByKey]					ifFalse: 						[self noSelectedMenuItem.						self highlightNextMenuBarButton]]</body></methods><methods><class-id>UI.MenuBarButtonController</class-id> <category>privileged</category><body package="MenuUICompatibility" selector="isControlWantedByOtherMenuBarButton">isControlWantedByOtherMenuBarButton	"Answer whether another menu bar button on the same menu bar wants control."	self view menuBar menuButtons do: 			[:each | 			each == self view 				ifFalse: 					[((each bounds containsPoint: each controller sensor cursorPoint) 						and: [each isEnabled]) 							ifTrue: 								[self view menuBar highlightThisMenuBarButton: each.								^true]]].	^false</body></methods><methods><class-id>UI.MenuFromMenuButtonController</class-id> <category>events</category><body package="MenuUICompatibility" selector="buttonPressedEvent:">buttonPressedEvent: event 	"A button press toggles my mode. No button press outside my window will enter here in an event based control system"	state == #waitForReleaseToSelect ifTrue: [^nil].	state == #waitForMousePressed 		ifTrue: 			[state := #waitForReleaseToSelect.			^event].	^nil</body><body package="MenuUICompatibility" selector="buttonReleasedEvent:">buttonReleasedEvent: event 	"Mouse button released between two menu items: no selection"	state == #waitForReleaseToSelect 		ifTrue: 			[state := #finished.			view noSelectedMenuItem.			^event].	^nil</body><body package="MenuUICompatibility" selector="exposeEvent:">exposeEvent: event 	super exposeEvent: event.	state := #waitForMousePressed.	^nil</body><body package="MenuUICompatibility" selector="handleEvent:">handleEvent: event 	"In the OS-Window System world, we only need to know if someone has hit outside of the menu	which includes outside the window the menu is popped in"	(event isButtonPressedEvent not 		or:[self viewHasCursorWithEvent: event]) 			ifFalse: 				[self processEscape.				self shutDownScrollProcess.				^event].	^super handleEvent: event</body></methods><methods><class-id>UI.MenuAsSubmenuController</class-id> <category>events</category><body package="MenuUICompatibility" selector="buttonPressedEvent:">buttonPressedEvent: event	"If button down is not in my area, I need to give it	to my parent menu because the press event might	be intended to select an item in my parent menu"	"Ignore bogus button pressed events caused by	opening up the TransientWindow"	state == #waitForReleaseToSelect ifTrue: [^nil].	(self handlerToKeepForMouseEvent: event) ifNil: [^nil].	state == #waitForMousePressed		ifTrue: 			[state := #waitForReleaseToSelect. 			^event].	^nil</body></methods><methods><class-id>UI.MenuAsSubmenuController</class-id> <category>privileged</category><body package="MenuUICompatibility" selector="parentViewHasCursorWithEvent:">parentViewHasCursorWithEvent: event 	"Answer whether the receiver should retain control of any ancestor menu.  If the cursor is in any menu item view from whose ancestry the receiver view has opened then let the receiver retain control.  Compare with MenuItemController&gt;&gt;isChildControlActiveWithEvent:"	^view parentMenuItemView ifNil: [false]		ifNotNil: 			[:parentItemView | 			(parentItemView controller viewHasCursorWithEvent: event) 				or: [parentItemView menuView controller parentViewHasCursorWithEvent: event]]</body></methods><methods><class-id>UI.MenuAsSubmenuController</class-id> <category>events</category><body package="MenuUICompatibility" selector="windowEnterEvent:">windowEnterEvent: event 	event anyButtonPressed 		ifTrue: [state := #waitForReleaseToSelect]		ifFalse: 			[state := #waitForMousePressed.			self view highlightedMenuItemView == nil 				ifTrue: [self view highlightSelectionMemoryMenuItem]].	^nil</body></methods><methods><class-id>UI.MotifMenuView</class-id> <category>privileged-current selection</category><body package="MenuUICompatibility" selector="highlightNextMenuItem">highlightNextMenuItem	"Hilight the next enabled menu item (after the one currently highlighted).  Wrap to the first item and beyond if necessary"	| flatMenuViews nextHighlight itemsSize |	flatMenuViews := self menuItemViewsAsCollection.	itemsSize := flatMenuViews size.	nextHighlight := highlightedMenuItemView == nil 				ifTrue: [1]				ifFalse: [(flatMenuViews indexOf: highlightedMenuItemView) + 1].	nextHighlight to: nextHighlight + itemsSize		do: 			[:step | 			| index nextMenuItemView |			index := (step - 1) \\ itemsSize + 1.			(nextMenuItemView := flatMenuViews at: index) isEnabled 				ifTrue: 					[highlightedMenuItemView == nil 						ifFalse: [highlightedMenuItemView resignSelection].					nextMenuItemView assumeSelection.					^self]]</body><body package="MenuUICompatibility" selector="highlightPreviousMenuItem">highlightPreviousMenuItem	"Hilight the previous enabled menu item (before the one currently highlighted).  Wrap to the last item and beyond if necessary"	| flatMenuViews nextHighlight itemsSize |	flatMenuViews := self menuItemViewsAsCollection.	itemsSize := flatMenuViews size.	nextHighlight := highlightedMenuItemView == nil 				ifTrue: [itemsSize]				ifFalse: [(flatMenuViews indexOf: highlightedMenuItemView) - 1].	(nextHighlight to: nextHighlight - itemsSize by: -1)		do: 			[:step | 			| index nextMenuItemView |			index := (step - 1) \\ itemsSize + 1.			(nextMenuItemView := flatMenuViews at: index) isEnabled 				ifTrue: 					[highlightedMenuItemView == nil 						ifFalse: [highlightedMenuItemView resignSelection].					nextMenuItemView assumeSelection.					^self]]</body></methods><methods><class-id>UI.MotifMenuView</class-id> <category>privileged-parent view</category><body package="MenuUICompatibility" selector="openFromMenuBarButton:">openFromMenuBarButton: theParentMenuBarButtonView	"Open the menu as a menu appearing from a menu button on a menu bar (the parentMenuBarButtonView).  The user will be given the opportunity to make a selection.  Answer the value object associated with the menu item that was selected (or nil if none)."	| theScreen parentDisplayBox monitorRectangle wrappedMenu menuWindowBounds intoMonitor menuWindow |	parentMenuBarButtonView := theParentMenuBarButtonView.	self controller: MotifMenuFromMenuBarController new.	(self prepareMenuItemViewsToMinWidth: 0) ifFalse: [^nil].	theScreen := theParentMenuBarButtonView graphicsDevice.	parentDisplayBox := self displayBoxOfView: theParentMenuBarButtonView.	monitorRectangle := (theScreen preferredRectangleToConstrain: parentDisplayBox) insetBy: 4.	wrappedMenu := self withBoundedWrapper.	menuWindowBounds := wrappedMenu preferredBounds.	menuWindowBounds := menuWindowBounds align: menuWindowBounds topLeft with: parentDisplayBox bottomLeft.	"Adjust to fit between left and right sides of monitor."	intoMonitor := menuWindowBounds amountToTranslateWithin: monitorRectangle.	menuWindowBounds := menuWindowBounds translatedBy: intoMonitor.	menuWindowBounds := menuWindowBounds intersect: monitorRectangle.	"Need to eventually adjust if the intersection makes the bounds too small."	menuWindow := self menuWindowOn: theScreen in: menuWindowBounds.	self setColorsInMenuWindow: menuWindow from: theParentMenuBarButtonView.	wrappedMenu bounds: (0@0 extent: menuWindowBounds extent).	menuWindow component: wrappedMenu.	self mapAndStartupEventDriven: menuWindow.	parentMenuBarButtonView topComponent becomeActive.	^self selectedValue</body><body package="MenuUICompatibility" selector="openFromParentMenuItemView:">openFromParentMenuItemView: theParentMenuItemView 	"Open the receiver as a child menu of the given parent MenuItemView.  Allow the user to make a selection.  Answer the menu item that was selected (or nil if none)."	| theScreen parentDisplayBox monitorRectangle wrappedMenu menuWindowBounds intoMonitor menuWindow theSelectionMemoryMenuItem positioningMenuItemView offsetForMenuItem |	parentMenuItemView := theParentMenuItemView.	self controller: MotifMenuAsSubmenuController new.	(self prepareMenuItemViewsToMinWidth: 0) ifFalse: [^nil].	theScreen := theParentMenuItemView graphicsDevice.	parentDisplayBox := self displayBoxOfView: parentMenuItemView.	monitorRectangle := (theScreen 				preferredRectangleToConstrain: parentDisplayBox) insetBy: 4.	wrappedMenu := self withBoundedWrapper.	menuWindowBounds := wrappedMenu preferredBounds.	menuWindowBounds 		height: (menuWindowBounds height min: monitorRectangle height).	wrappedMenu bounds: (0 @ 0 extent: menuWindowBounds extent).	menuWindow := self menuWindowOn: theScreen in: menuWindowBounds.	menuWindow component: wrappedMenu.	"Position last selected menu item next to parent menu item."	theParentMenuItemView menuView usedSelectionMemory 		ifTrue: 			[usedSelectionMemory := true.			theSelectionMemoryMenuItem := self menu selectionMemory.			self menuItemViewsAsCollection do: 					[:eachView | 					eachView menuItem == theSelectionMemoryMenuItem 						ifTrue: [positioningMenuItemView := eachView]]].	offsetForMenuItem := positioningMenuItemView == nil 				ifTrue: [0 @ 0]				ifFalse: 					[positioningMenuItemView 						localPointToGlobal: positioningMenuItemView bounds origin].	menuWindow 		moveTo: parentDisplayBox topRight + self topRightOffsetAsChildMenu 				- offsetForMenuItem.	"Adjust to fit between left and right sides of monitor."	intoMonitor := menuWindow displayBox 				amountToTranslateWithin: monitorRectangle.	menuWindow moveTo: menuWindow globalOrigin + intoMonitor.	self setColorsInMenuWindow: menuWindow from: theParentMenuItemView.	self mapAndStartupEventDriven: menuWindow.	selectionFinal == true 		ifTrue: [theParentMenuItemView menuView childSelectionValue: self selectedValue]</body></methods><methods><class-id>UI.MotifMenuView</class-id> <category>privileged-current selection</category><body package="MenuUICompatibility" selector="openSubMenuOrMenuToRight">openSubMenuOrMenuToRight	"Open the submenu (if there is one) otherwise close the receiver and open the menu to the right on the menu bar."	(highlightedMenuItemView ~~ nil and: 			[highlightedMenuItemView menuItem hasSubmenu 				and: [highlightedMenuItemView menuItem isEnabled]]) 		ifTrue: [highlightedMenuItemView openSubMenuByKey]		ifFalse: 			[self noSelectedMenuItem.			self highlightNextMenuBarButton]</body><body package="MenuUICompatibility" selector="selectHighlightedMenuItem">selectHighlightedMenuItem	self highlightedMenuItemView ifNotNil: 			[:item | 			(item menuItem hasSubmenu and: [item isEnabled]) 				ifTrue: [item openSubMenuByKey]				ifFalse: [super selectHighlightedMenuItem]]</body></methods><methods><class-id>UI.MacOSXMenuController</class-id> <category>control defaults</category><body package="MenuUICompatibility" selector="handleEvent:">handleEvent: event 	"We test only if someone has hit outside of the menu	which includes outside the window the menu is popped in"	(event isButtonPressedEvent not 		or: [state == #waitForMouse or: [self viewHasCursorWithEvent: event]]) 			ifFalse: 				[self finishAllParents.				self shutDownScrollProcess.				^event].	^super handleEvent: event</body></methods><methods><class-id>UI.MacOSXMenuController</class-id> <category>protected-keyboard</category><body package="MenuUICompatibility" selector="processOtherKey:">processOtherKey: aKeyboardEvent 	"Tab to buttons left or right in the menu bar"	(KeyboardProcessor new isBackTab: aKeyboardEvent) 		ifTrue: [^self view noSelectedMenuItem highlightPreviousMenuBarButton].	aKeyboardEvent keyValue == Character tab 		ifTrue: [^self view noSelectedMenuItem highlightNextMenuBarButton].	super processOtherKey: aKeyboardEvent</body></methods><methods><class-id>UI.Win95MenuItemController</class-id> <category>events</category><body package="MenuUICompatibility" selector="redButtonPressedEvent:">redButtonPressedEvent: event 	Win95MenuController submenuAssumesSelection 		ifTrue: [self view isSelection ifFalse: [self view assumeSelection]]		ifFalse: [super redButtonPressedEvent: event]</body><body package="MenuUICompatibility" selector="redButtonReleasedEvent:">redButtonReleasedEvent: event 	Win95MenuController submenuAssumesSelection 		ifTrue: [self sensorNoButtonPressed]		ifFalse: [super redButtonReleasedEvent: event]</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>MenuBarButtonController</name><environment>UI</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Controllers</category><attributes><package>UIBasics-Controllers</package></attributes></class><class><name>MenuView</name><environment>UI</environment><super>UI.CompositeView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuItemViews parentMenuItemView selectedValue selectionFinal highlightedMenuItemView usedSelectionMemory parentMenuBarButtonView commonTextIndent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>Win95MenuView</name><environment>UI</environment><super>UI.MenuView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>shortcutColumnIndent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UILooks-MSWin</category><attributes><package>UILooks-MSWin</package></attributes></class><class><name>MenuItemView</name><environment>UI</environment><super>UI.View</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuView </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>MacMenuItemView</name><environment>UI</environment><super>UI.MenuItemView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>composedLabel composedCharacter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UILooks-Mac</category><attributes><package>UILooks-Mac</package></attributes></class><class><name>Win95MenuItemView</name><environment>UI</environment><super>UI.MenuItemView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>composedLabel composedCharacter accessCharacter accessIndicator accessIndicatorThickness </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UILooks-MSWin</category><attributes><package>UILooks-MSWin</package></attributes></class><class><name>MotifMenuItemView</name><environment>UI</environment><super>UI.MenuItemView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>composedLabel composedCharacter accessCharacter accessIndicator accessIndicatorThickness </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UILooks-Motif</category><attributes><package>UILooks-Motif</package></attributes></class><class><name>MenuController</name><environment>UI</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scrollWrapper state isEventDriven eventDispatcher scrollProcess </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Controllers</category><attributes><package>UIBasics-Controllers</package></attributes></class><class><name>MacOSXMenuController</name><environment>UI</environment><super>UI.MenuController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UILooks-MacOSX</category><attributes><package>UILooks-MacOSX</package></attributes></class><class><name>MacOSXMenuFromMenuBarController</name><environment>UI</environment><super>UI.MacOSXMenuController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UILooks-MacOSX</category><attributes><package>UILooks-MacOSX</package></attributes></class><class><name>MenuFromMenuBarController</name><environment>UI</environment><super>UI.MenuController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Controllers</category><attributes><package>UIBasics-Controllers</package></attributes></class><class><name>MenuFromMenuButtonController</name><environment>UI</environment><super>UI.MenuController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Controllers</category><attributes><package>UIBasics-Controllers</package></attributes></class><class><name>MacOSXMenuAsSubmenuController</name><environment>UI</environment><super>UI.MacOSXMenuController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UILooks-MacOSX</category><attributes><package>UILooks-MacOSX</package></attributes></class><class><name>MacOSXMenuItemView</name><environment>UI</environment><super>UI.MacMenuItemView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UILooks-MacOSX</category><attributes><package>UILooks-MacOSX</package></attributes></class><class><name>MenuAsSubmenuController</name><environment>UI</environment><super>UI.MenuController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Controllers</category><attributes><package>UIBasics-Controllers</package></attributes></class><class><name>MenuItemController</name><environment>UI</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Controllers</category><attributes><package>UIBasics-Controllers</package></attributes></class><class><name>Win95MenuItemController</name><environment>UI</environment><super>UI.MenuItemController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UILooks-MSWin</category><attributes><package>UILooks-MSWin</package></attributes></class><class><name>MacMenuView</name><environment>UI</environment><super>UI.MenuView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UILooks-Mac</category><attributes><package>UILooks-Mac</package></attributes></class><class><name>Win95MenuController</name><environment>UI</environment><super>UI.MenuController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UILooks-MSWin</category><attributes><package>UILooks-MSWin</package></attributes></class><class><name>Win95MenuFromMenuBarController</name><environment>UI</environment><super>UI.Win95MenuController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UILooks-MSWin</category><attributes><package>UILooks-MSWin</package></attributes></class><class><name>Win95MenuAsSubmenuController</name><environment>UI</environment><super>UI.Win95MenuController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UILooks-MSWin</category><attributes><package>UILooks-MSWin</package></attributes></class><class><name>Win95MenuFromMenuButtonController</name><environment>UI</environment><super>UI.Win95MenuController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UILooks-MSWin</category><attributes><package>UILooks-MSWin</package></attributes></class><class><name>MotifMenuView</name><environment>UI</environment><super>UI.MenuView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>usedAccessCharacters shortcutColumnIndent backgroundColor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UILooks-Motif</category><attributes><package>UILooks-Motif</package></attributes></class></st-source>