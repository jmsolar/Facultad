<?xml version="1.0"?><st-source><!-- Name: Arbor Help System Outline Help CoreNotice: Copyright © 2002 Cincom Systems, Inc.  All Rights Reserved.Comment: Provides basic support for Outline HelpDbIdentifier: bear73DbTrace: 35888DevelopmentPrerequisites: #(#(#any 'Arbor Help System Core' '') #(#any 'Arbor Hypertext' ''))PackageName: Arbor Help System Outline Help CoreParcel: #('Arbor Help System Outline Help Core')ParcelName: Arbor Help System Outline Help CorePrerequisiteParcels: #(#('Arbor Help System Core' '') #('Arbor Hypertext' ''))PrintStringCache: (7 - 2.2,bobw)Version: 7.2Date: 1:27:25 pm October 20, 2003 --><time-stamp>From VisualWorks®, 7.2 of October 20, 2003 on October 20, 2003 at 1:27:25 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>AHSTextGraphicComposite</name><environment>VWHelp</environment><super>UI.CompositeView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>outliner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core-Text/Graphics Mix</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSTextGraphicComposite</class-id><body>AHSTextGraphicCompositeA specialized composite part that will mix graphics and text for display.  The model is intended to be a value-held AHSHelpHyperText which is scanned to separate the various text and graphic components.Instance Variables:outliner	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>AHSReporterData</name><environment>VWHelp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>indent topic topicText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSReporterData</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:indent	&lt;ClassOfVariable&gt;	description of variable's functiontopic	&lt;ClassOfVariable&gt;	description of variable's functiontopicText	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>AHSOutlineViewer</name><environment>VWHelp</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>toolbarTextEditor outliner history infoHasChanged searchEntriesFound searchString outlinerWindowMenu historyIndex shouldUpdateHistoryStack zoomed bookmarks initialSelection outlineSource readOnly lastEntry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSOutlineViewer</class-id><body>Copyright © 1994, 1995 Arbor Intelligent Systems, Inc.This class is the model for help outliners, which are used to stored and display a help outline.Instance Variables:toolbarTextEditor	&lt;ClassOfVariable&gt;	description of variable's functionoutliner	&lt;ClassOfVariable&gt;	description of variable's functionhistory	&lt;ClassOfVariable&gt;	description of variable's functioninfoHasChanged	&lt;ClassOfVariable&gt;	description of variable's functionsearchEntriesFound	&lt;ClassOfVariable&gt;	description of variable's functionsearchString	&lt;ClassOfVariable&gt;	description of variable's functionoutlinerWindowMenu	&lt;ClassOfVariable&gt;	description of variable's functionhistoryIndex	&lt;ClassOfVariable&gt;	description of variable's functionshouldUpdateHistoryStack	&lt;ClassOfVariable&gt;	description of variable's functionzoomed	&lt;ClassOfVariable&gt;	description of variable's functionbookmarks	&lt;ClassOfVariable&gt;	description of variable's functioninitialSelection	&lt;ClassOfVariable&gt;	description of variable's functionoutlineSource	&lt;ClassOfVariable&gt;	description of variable's functionreadOnly	&lt;ClassOfVariable&gt;	description of variable's functionlastEntry	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>AHSHelpOutlineEntry</name><environment>VWHelp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>topic text uniqueID </inst-vars><class-inst-vars>clipboard </class-inst-vars><imports></imports><category>Help-Outline Help-Core</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSHelpOutlineEntry</class-id><body>Copyright Ó 1994, 1995 Arbor Intelligent Systems, Inc.This class is used for storing each of the entries in an outline. Instance Variables:topic	&lt;ClassOfVariable&gt;	description of variable's functiontext	&lt;ClassOfVariable&gt;	description of variable's functionuniqueID	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>AHSGraphicView</name><environment>VWHelp</environment><super>UI.View</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSGraphicView</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:</body></comment><class><name>AHSHistory</name><environment>VWHelp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stack topOfStack linearHistory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSHistory</class-id><body>Copyright Ó 1994, 1995 Arbor Intelligent Systems, Inc.This class contains the history for an outline browser.  It stores each page in two places, a linear list of all topics that have been visited and a "stack" of the most recent tree.  The stack is not a proper stack, although "pop" still answers the top element, the element isn't removed from the stack.  Rather the pointer to the top of the stack decrements by one.  If an element is then pushed onto the stack, any elements above stackIndex are removed.  This is to allow moving both backward and forward through the history stack.Any topic visited should be added to the linear history.  The one exception is that consecutive duplications are not allowed.  A topic should *not* be pushed onto the stack if it was selected using the back or forward methods, this is to allowed traversal through the stack without modifying it.  Also, consecutive duplications are not allowed in the stack, either.The history is considered empty if the linearHistory is empty.  Testing the stack will produce an invalid result because using the back method can result in an empty (appearing) stack that is actually not empty.Instance Variables:	stack  		&lt;OrderedCollection&gt; 		Contains the stack elements.	topOfStack	&lt;Integer&gt;						The index of the element that is at the top of the stack.	linearHistory	&lt;List&gt;							Contains all the topics that have been visited.</body></comment><class><name>AHSOutline</name><environment>VWHelp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name outlineLabel nextID fileFormat glossaryDictionary graphicsDictionary forest </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSOutline</class-id><body>Copyright Ó 1994, 1995 Arbor Intelligent Systems, Inc.This used for help system outlines, which is an ordered forest ofAHSTrees containing AHSHelpOutlineEntries for each tree's data.WARNING: This class answers a deep copy when copied.Instance Variables:name	&lt;ClassOfVariable&gt;	description of variable's functionoutlineLabel	&lt;ClassOfVariable&gt;	description of variable's functionnextID	&lt;ClassOfVariable&gt;	description of variable's functionfileFormat	&lt;ClassOfVariable&gt;	description of variable's functionglossaryDictionary	&lt;ClassOfVariable&gt;	description of variable's functiongraphicsDictionary	&lt;ClassOfVariable&gt;	description of variable's functionforest	&lt;ClassOfVariable&gt;	description of variable's functionClass Variables:FilenameSignal	&lt;ClassOfVariable&gt;	description of variable''s functionFixupSignal	&lt;ClassOfVariable&gt;	description of variable''s function</body></comment><class><name>AHSTextGraphicSelectionTracker</name><environment>VWHelp</environment><super>UI.ScrollingTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pivot current originalStartBlock originalStopBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core-Text/Graphics Mix</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSTextGraphicSelectionTracker</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:pivot	&lt;ClassOfVariable&gt;	description of variable's functioncurrent	&lt;ClassOfVariable&gt;	description of variable's functionoriginalStartBlock	&lt;ClassOfVariable&gt;	description of variable's functionoriginalStopBlock	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>ArborHierarchicalSequenceSelectionTracker</name><environment>VWHelp</environment><super>UI.SequenceSelectionTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>switchInTransition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Arbor Widget Extensions-Outline Browser</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.ArborHierarchicalSequenceSelectionTracker</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:switchInTransition	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>AHSTextGraphicLayoutWrapper</name><environment>VWHelp</environment><super>Graphics.Wrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nextComponentIsBeneath view isCaption </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core-Text/Graphics Mix</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSTextGraphicLayoutWrapper</class-id><body>AHSTextGraphicLayoutWrapperThis class' sole purpose is to provide some layout information that may be queried by a containing AHSTextGraphicComposite.  The composite needs to know if the component after me is to be layed out beneath me or alongside of me.Instance Variables:nextComponentIsBeneath	&lt;ClassOfVariable&gt;	description of variable's functionview	&lt;ClassOfVariable&gt;	description of variable's functionisCaption	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>AHSHelpHyperLinkObject</name><environment>VWHelp</environment><super>VWHelp.ArborHyperlink</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSHelpHyperLinkObject</class-id><body>Copyright © 1994, 1995, 1998 Arbor Intelligent Systems, Inc.Instances of this class's subclasses hold hyperlinked objects from the Arbor Help System Outline Help. Each has a linked object, which is different depending upon which subclass.Instance Variables:</body></comment><class><name>ArborHierarchicalSequenceViewSpec</name><environment>VWHelp</environment><super>UI.SequenceViewSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Arbor Widget Extensions-Outline Browser</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.ArborHierarchicalSequenceViewSpec</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:</body></comment><class><name>ArborHierarchicalSequenceView</name><environment>VWHelp</environment><super>UI.SequenceView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>widthCache inTransition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Arbor Widget Extensions-Outline Browser</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.ArborHierarchicalSequenceView</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:widthCache	&lt;ClassOfVariable&gt;	description of variable's functioninTransition	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>ArborTextStyleDialog</name><environment>VWHelp</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>serif sampleText large underline italic bold paragraphEditor color colorOn </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Arbor GUI Extensions</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.ArborTextStyleDialog</class-id><body>Copyright 1995 Arbor Intelligent Systems, Inc.ArborTextStyleDialogUtility for specifying text styles for text selected within a text view. See the example in the class protocol.Instance Variables:serif	&lt;ClassOfVariable&gt;	description of variable's functionsampleText	&lt;ClassOfVariable&gt;	description of variable's functionlarge	&lt;ClassOfVariable&gt;	description of variable's functionunderline	&lt;ClassOfVariable&gt;	description of variable's functionitalic	&lt;ClassOfVariable&gt;	description of variable's functionbold	&lt;ClassOfVariable&gt;	description of variable's functionparagraphEditor	&lt;ClassOfVariable&gt;	description of variable's functioncolor	&lt;ClassOfVariable&gt;	description of variable's functioncolorOn	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>AHSOutlineTextGraphicMixViewer</name><environment>VWHelp</environment><super>VWHelp.AHSOutlineViewer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core-Text/Graphics Mix</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSOutlineTextGraphicMixViewer</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:</body></comment><class><name>ArborCenteredLabelAndIcon</name><environment>VWHelp</environment><super>UI.LabelAndIcon</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Arbor Widget Extensions</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.ArborCenteredLabelAndIcon</class-id><body>Copyright 1998 AppNet Systems, Inc.ArborCenteredLabelAndIconThe same as LabelAndIcon, except that the icon and text are always vertically centered with respect to each other.  In other words, given an imaginary line, the line will always pass through the vertical center of both the icon and the text.Instance Variables:</body></comment><class><name>AHSReporter</name><environment>VWHelp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rows </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSReporter</class-id><body>Copyright Ó 1994 Arbor Intelligent Systems, Inc.This class creates a report with information about a certain class.Instance Variables:rows	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>ArborAbstractTree</name><environment>VWHelp</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent children </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.ArborAbstractTree</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:parent	&lt;ClassOfVariable&gt;	description of variable's functionchildren	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>AHSTree</name><environment>VWHelp</environment><super>VWHelp.ArborAbstractTree</super><private>false</private><indexed-type>none</indexed-type><inst-vars>data </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core-Collections</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSTree</class-id><body>Copyright Ó 1994 Arbor Intelligent Systems, Inc.Responsibilities:	The data for a node is stored in a separate instance variable and is accessed with the data message.Instance Variables:data	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>ArborHierarchicalSequenceController</name><environment>VWHelp</environment><super>UI.SequenceController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Arbor Widget Extensions-Outline Browser</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.ArborHierarchicalSequenceController</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:</body></comment><class><name>AHSHelpHyperText</name><environment>VWHelp</environment><super>VWHelp.ArborHypertext</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSHelpHyperText</class-id><body>Copyright © 1994, 1995, 1998 Arbor Intelligent Systems, Inc.This class implements the main functionality for storing hyperlinks. It is an extended version of Text with added structures for keeping track of links from the text to another object. When a hyperlink is created, the text styles from the selected text change to a standard text style, so that a visual feedback can be given to the user.Instance Variables:</body></comment><class><name>AHSHyperGraphicLinkObject</name><environment>VWHelp</environment><super>VWHelp.AHSHelpHyperLinkObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>caption imageProportion windowExtent captionLocation isEmbedded </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSHyperGraphicLinkObject</class-id><body>Copyright © 1998 Arbor Intelligent Systems, Inc.Instances of this class's subclasses hold hypergraphic link objects from the Arbor Help System Outline Help.  The link object corresponds to an entry in the graphics dictionary.Instance Variables:caption	&lt;ClassOfVariable&gt;	description of variable's functionimageProportion	&lt;ClassOfVariable&gt;	description of variable's functionwindowExtent	&lt;ClassOfVariable&gt;	description of variable's functioncaptionLocation	&lt;ClassOfVariable&gt;	description of variable's functionisEmbedded	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>AHSHyperGraphicViewer</name><environment>VWHelp</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>availableGraphics outliner graphic listMenu </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSHyperGraphicViewer</class-id><body>Copyright © 1997 Arbor Intelligent Systems, Inc.This class displays the hyperGraphic links defined in the users help system.  Instance Variables:	availableGraphics &lt;SelectionInList&gt; List of names of graphics within outliner's outline	outliner &lt;AHSOutliner&gt; My client outliner	graphic &lt;AHSGraphicView&gt; view to display graphics	listMenu	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>AHSFullGlossaryViewer</name><environment>VWHelp</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fullGlossaryText fullGlossaryList parent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSFullGlossaryViewer</class-id><body>Copyright © 1997 Arbor Intelligent Systems, Inc.This class is used to display all entries in the glossary for the current outline.  This class is for read only viewing of glossary information.Instance Variables:	fullGlossaryText &lt;ValueHolder on: Text&gt; Text for the currently selected glossary entry.	fullGlossaryList &lt;SelectionInList&gt; List of glossary dictionary keys.	parent &lt;ApplicationModel&gt; The outliner which opened me</body></comment><class><name>AHSToolbarTextEditorController</name><environment>VWHelp</environment><super>VWHelp.ArborHypertextEditorController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSToolbarTextEditorController</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:</body></comment><class><name>AHSGlossaryLinkObject</name><environment>VWHelp</environment><super>VWHelp.AHSHelpHyperLinkObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSGlossaryLinkObject</class-id><body>Copyright © 1998 Arbor Intelligent Systems, Inc.Instances of this class hold hyperlinked glossary objects from the Arbor Help System Outline Help. Instance Variables:</body></comment><class><name>AHSCompositeCharacterBlock</name><environment>VWHelp</environment><super>Graphics.CharacterBlock</super><private>false</private><indexed-type>none</indexed-type><inst-vars>localTranslation localIndex localComponent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core-Text/Graphics Mix</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSCompositeCharacterBlock</class-id><body>AHSCompositeCharacterBlockThis class contains character selection information for a composite part that contains a text view.  Instances of this class store composite-relative information in the inherited instance variables, with additional sub-component relative information in the added instance variables.Instance Variables:localTranslation	&lt;ClassOfVariable&gt;	description of variable's functionlocalIndex	&lt;ClassOfVariable&gt;	description of variable's functionlocalComponent	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>AHSGraphicScreen</name><environment>VWHelp</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>image graphicLink caption imageProportion parentWindow </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSGraphicScreen</class-id><body>Copyright © 1994, 1995, 1998 Arbor Intelligent Systems, Inc.This class holds graphic images to be used within the HelpOutliner.Instance Variables:image	&lt;ClassOfVariable&gt;	description of variable's functiongraphicLink	&lt;ClassOfVariable&gt;	description of variable's functioncaption	&lt;ClassOfVariable&gt;	description of variable's functionimageProportion	&lt;ClassOfVariable&gt;	description of variable's functionparentWindow	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>AHSHelpTextEditorController</name><environment>VWHelp</environment><super>VWHelp.AHSToolbarTextEditorController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSHelpTextEditorController</class-id><body>Copyright Ó 1994, 1995 Arbor Intelligent Systems, Inc.This class is the controller for editing hyperlinks. It senses whether the cursor is over a hypertext with links changing accordingly.Instance Variables:</body></comment><class><name>AHSTextGraphicCompositeController</name><environment>VWHelp</environment><super>UI.ControllerWithMenu</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectedComponents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core-Text/Graphics Mix</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><class><name>AHSTopicBodyWriter</name><environment>VWHelp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>owner outputStream state currentEmphasis hyperLink inGroup </inst-vars><class-inst-vars>emphasisConversionDictionary specialCharacterDictionary </class-inst-vars><imports></imports><category>Help-Outline Help-Core-Export</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSTopicBodyWriter</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:owner	&lt;ClassOfVariable&gt;	description of variable's functionoutputStream	&lt;ClassOfVariable&gt;	description of variable's functionstate	&lt;ClassOfVariable&gt;	description of variable's functioncurrentEmphasis	&lt;ClassOfVariable&gt;	description of variable's functionhyperLink	&lt;ClassOfVariable&gt;	description of variable's functioninGroup	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>AHSHTMLTopicBodyWriter</name><environment>VWHelp</environment><super>VWHelp.AHSTopicBodyWriter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>endEmphasisConversionBlocks </class-inst-vars><imports></imports><category>Help-Outline Help-Core-Export</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSHTMLTopicBodyWriter</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:</body></comment><class><name>ArborOutlineLabeledObjectHolder</name><environment>VWHelp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>object emphasis displayBlock isExpanded canBeExpanded parent indentLevel iconSet </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Arbor Widget Extensions-Outline Browser</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.ArborOutlineLabeledObjectHolder</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:object	&lt;ClassOfVariable&gt;	description of variable's functionemphasis	&lt;ClassOfVariable&gt;	description of variable's functiondisplayBlock	&lt;ClassOfVariable&gt;	description of variable's functionisExpanded	&lt;ClassOfVariable&gt;	description of variable's functioncanBeExpanded	&lt;ClassOfVariable&gt;	description of variable's functionparent	&lt;ClassOfVariable&gt;	description of variable's functionindentLevel	&lt;ClassOfVariable&gt;	description of variable's functioniconSet	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>AHSOutlineTopicIndex</name><environment>VWHelp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>topicIndex allTopics </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core-Export</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSOutlineTopicIndex</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:topicIndex	&lt;ClassOfVariable&gt;	description of variable's functionallTopics	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>AHSPersistentSet</name><environment>VWHelp</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core-Collections</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSPersistentSet</class-id><body>Copyright Ó 1994 Arbor Intelligent Systems, Inc.This class allows a set to have persistence properties when used in conjunction with a database.Instance Variables: *Indexed*</body></comment><class><name>ArborDragBarController</name><environment>VWHelp</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>above below left right boundedDrag </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Arbor Widget Extensions</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.ArborDragBarController</class-id><body>Copyright 1998 AppNet Systems, Inc.ArborDragBarControllerControls the drag operation in conjunction with ArborDragBarView.Instance Variables:above	&lt;ClassOfVariable&gt;	description of variable's functionbelow	&lt;ClassOfVariable&gt;	description of variable's functionleft	&lt;ClassOfVariable&gt;	description of variable's functionright	&lt;ClassOfVariable&gt;	description of variable's functionboundedDrag	&lt;ClassOfVariable&gt;	description of variable's functionClass Variables:HorizontalDragCursor	&lt;ClassOfVariable&gt;	description of variable''s functionVerticalDragCursor	&lt;ClassOfVariable&gt;	description of variable''s function</body></comment><class><name>AHSPersistentOrderedCollection</name><environment>VWHelp</environment><super>Core.OrderedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core-Collections</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSPersistentOrderedCollection</class-id><body>Copyright Ó 1994 Arbor Intelligent Systems, Inc.This class allows an ordered collection to have persistence properties when used in conjunction with a database.</body></comment><class><name>AHSAdjustableBoundedWrapper</name><environment>VWHelp</environment><super>Graphics.BoundedWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core-Text/Graphics Mix</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSAdjustableBoundedWrapper</class-id><body>AHSAdjustableBoundedWrapperJust like a BoundedWrapper, except I will adjust my bounds if my component announces that its preferredBounds have changed.  This is most useful when wrapping TextEditorViews, since normally a BoundedWrapper defines the bounds of the ComposedText, but if the ComposedText changes (such as by the user typing), I will conform to the new bounds.</body></comment><class><name>AHSOHCPreferencesModel</name><environment>VWHelp</environment><super>VWHelp.AHSPreferencesModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSOHCPreferencesModel</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:</body></comment><class><name>AHSIndentableComposedText</name><environment>VWHelp</environment><super>Graphics.ComposedText</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Smalltalk.TextConstants.*			</imports><category>Help-Outline Help-Core</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSIndentableComposedText</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:</body></comment><class><name>ArborDragBarSpec</name><environment>VWHelp</environment><super>UI.DividerSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>widgetSet1 widgetSet2 etched boundedDrag </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Arbor Widget Extensions</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.ArborDragBarSpec</class-id><body>Copyright 1998 AppNet Systems, Inc.ArborDragBarSpecDefines the VisualWorks attributes necessary for building a drag bar component.Instance Variables:	widgetSet1 	&lt;Array of: Symbol&gt; IDs of widgets to the left or above the drag bar	widgetSet2 	&lt;Array of: Symbol&gt; IDs of widgets to the right or below the drag bar	etched 	&lt;Boolean&gt; true if to display the line 'etched'	boundedDrag 	&lt;Boolean&gt; true if the drag operation is bounded by the far side of associated components </body></comment><class><name>ArborOutlineBrowserModel</name><environment>VWHelp</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>getChildrenBlock getParentBlock hasChildrenBlock displayBlock openedSet menuHolder forest clipModel newEntryBlock moveBlock deleteBlock readOnly includeArrows </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Arbor Widget Extensions-Outline Browser</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.ArborOutlineBrowserModel</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:getChildrenBlock	&lt;ClassOfVariable&gt;	description of variable's functiongetParentBlock	&lt;ClassOfVariable&gt;	description of variable's functionhasChildrenBlock	&lt;ClassOfVariable&gt;	description of variable's functiondisplayBlock	&lt;ClassOfVariable&gt;	description of variable's functionopenedSet	&lt;ClassOfVariable&gt;	description of variable's functionmenuHolder	&lt;ClassOfVariable&gt;	description of variable's functionforest	&lt;ClassOfVariable&gt;	description of variable's functionclipModel	&lt;ClassOfVariable&gt;	description of variable's functionnewEntryBlock	&lt;ClassOfVariable&gt;	description of variable's functionmoveBlock	&lt;ClassOfVariable&gt;	description of variable's functiondeleteBlock	&lt;ClassOfVariable&gt;	description of variable's functionreadOnly	&lt;ClassOfVariable&gt;	description of variable's functionincludeArrows	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>ArborListOutlineBrowserModel</name><environment>VWHelp</environment><super>VWHelp.ArborOutlineBrowserModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>list </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Arbor Widget Extensions-Outline Browser</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.ArborListOutlineBrowserModel</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:list	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>AHSOutlineViewerModel</name><environment>VWHelp</environment><super>VWHelp.ArborListOutlineBrowserModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>master </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSOutlineViewerModel</class-id><body>Copyright © 1997 Arbor Intelligent Systems, Inc.This class is responsible for the Help System specific List Outline Browser functionality, specifically, promoting and demoting, drag and drop, and renaming of topics.Instance Variables:master	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>AHSHTMLGenerator</name><environment>VWHelp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>htmlDirectory outline outputStream topicWriter graphicFileNames </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core-Export</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSHTMLGenerator</class-id><body>Copyright © 1996 Arbor Intelligent Systems, Inc.This class is responsible for generating HTML output for an outline.Instance Variables:htmlDirectory	&lt;ClassOfVariable&gt;	description of variable's functionoutline	&lt;ClassOfVariable&gt;	description of variable's functionoutputStream	&lt;ClassOfVariable&gt;	description of variable's functiontopicWriter	&lt;ClassOfVariable&gt;	description of variable's functiongraphicFileNames	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>AHSHTMLHelpGenerator</name><environment>VWHelp</environment><super>VWHelp.AHSHTMLGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core-Export</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSHTMLHelpGenerator</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:</body></comment><class><name>AHSHelpTextEditorView</name><environment>VWHelp</environment><super>UI.TextEditorView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSHelpTextEditorView</class-id><body>Copyright © 1994 Arbor Intelligent Systems, Inc.This class is the view for managing hyperlinks. It changes the cursor according to whether the cursor is over a hypertext with links (which is sensed by the its controller).Instance Variables:</body></comment><class><name>ArborIconSet</name><environment>VWHelp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>expandedSelected expandedDeselected expandedTransitionSelected expandedTransitionDeselected contractedSelected contractedDeselected contractedTransitionSelected contractedTransitionDeselected emptySelected emptyDeselected hotRegion indentOffset </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Arbor Widget Extensions-Outline Browser</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.ArborIconSet</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:expandedSelected	&lt;ClassOfVariable&gt;	description of variable's functionexpandedDeselected	&lt;ClassOfVariable&gt;	description of variable's functionexpandedTransitionSelected	&lt;ClassOfVariable&gt;	description of variable's functionexpandedTransitionDeselected	&lt;ClassOfVariable&gt;	description of variable's functioncontractedSelected	&lt;ClassOfVariable&gt;	description of variable's functioncontractedDeselected	&lt;ClassOfVariable&gt;	description of variable's functioncontractedTransitionSelected	&lt;ClassOfVariable&gt;	description of variable's functioncontractedTransitionDeselected	&lt;ClassOfVariable&gt;	description of variable's functionemptySelected	&lt;ClassOfVariable&gt;	description of variable's functionemptyDeselected	&lt;ClassOfVariable&gt;	description of variable's functionhotRegion	&lt;ClassOfVariable&gt;	description of variable's functionindentOffset	&lt;ClassOfVariable&gt;	description of variable's functionClass Variables:IconSets	&lt;ClassOfVariable&gt;	description of variable''s function</body></comment><class><name>AHSHyperTextLinkObject</name><environment>VWHelp</environment><super>VWHelp.AHSHelpHyperLinkObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSHyperTextLinkObject</class-id><body>Copyright © 1998 Arbor Intelligent Systems, Inc.Instances of this class hold hypertext link objects from the Arbor Help System Outline Help. Instance Variables:</body></comment><class><name>AHSGlossaryViewer</name><environment>VWHelp</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary key selectedWindowSpec text selectedWord keys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSGlossaryViewer</class-id><body>Copyright © 1994, 1995 Arbor Intelligent Systems, Inc.This class manages the glossary facilities in the help system. Glossaries are considered just another form of hyperlink and are treated in the same way.Instance Variables:dictionary	&lt;ClassOfVariable&gt;	description of variable's functionkey	&lt;ClassOfVariable&gt;	description of variable's functionselectedWindowSpec	&lt;ClassOfVariable&gt;	description of variable's functiontext	&lt;ClassOfVariable&gt;	description of variable's functionselectedWord	&lt;ClassOfVariable&gt;	description of variable's functionkeys	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>AHSToolbarTextEditor</name><environment>VWHelp</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>toolBarMenuHolder text spellChecker findReplace </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSToolbarTextEditor</class-id><body>Copyright © 1996 Arbor Intelligent Systems, Inc.This class is extends the AHSToolbarTextEditor in a way which lets it edit hypertext documents.  The class will notify interested parties when key events happen. Instance Variables:toolBarMenuHolder	&lt;ClassOfVariable&gt;	description of variable's functiontext	&lt;ClassOfVariable&gt;	description of variable's functionspellChecker	&lt;ClassOfVariable&gt;	description of variable's functionfindReplace	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>AHSToolbarHypertextEditor</name><environment>VWHelp</environment><super>VWHelp.AHSToolbarTextEditor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSToolbarHypertextEditor</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:</body></comment><class><name>ArborDragBarView</name><environment>VWHelp</environment><super>UI.VisualDivider</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controller </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Arbor Widget Extensions</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.ArborDragBarView</class-id><body>Copyright 1998 AppNet Systems, Inc.ArborDragBarViewIn conjunction with the ArborDragBarController, the drag bar view provides behavior allowing the adjustment of related component dimensions by dragging a divider.  This widget is sometimes known in other implementations as a 'splitter'.Instance Variables:	controller 	&lt;ArborDragBarController&gt; </body></comment><class><name>ArborSlaveApplicationModel</name><environment>VWHelp</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parentWindow windowType relativeOrigin initialExtent alwaysVisible allowUserPlacement isPinned </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Arbor GUI Extensions</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.ArborSlaveApplicationModel</class-id><body>Copyright 1996, 1998 Arbor Intelligent Systems, Inc.ArborSlaveApplicationModelThis class provides behavior for making an application model's window a 'slave' of another window.  This includes collapsing when the master collapses, optionally sticking to a location relative to the master regardless of where it is moved, closing when the master closes, etc.  The slave can realign itself if either it or the master window is resized.  Optionally, the slave may adhere to the screen boundaries - that is, the slave will not disappear off the screen if the master is too close to the edge.  The overall behavior of instances of this class will be very similar to what one finds on some platforms where a window has a palette 'attached' to it.Instance Variables:parentWindow	&lt;ClassOfVariable&gt;	description of variable's functionwindowType	&lt;ClassOfVariable&gt;	description of variable's functionrelativeOrigin	&lt;ClassOfVariable&gt;	description of variable's functioninitialExtent	&lt;ClassOfVariable&gt;	description of variable's functionalwaysVisible	&lt;ClassOfVariable&gt;	description of variable's functionallowUserPlacement	&lt;ClassOfVariable&gt;	description of variable's functionisPinned	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>AHSOutlinerSubsetList</name><environment>VWHelp</environment><super>VWHelp.ArborSlaveApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>outliner subsetList windowLabel mode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSOutlinerSubsetList</class-id><body>Copyright Ó 1994 Arbor Intelligent Systems, Inc.This class is used by the help outliner to display a list of topics to the user.  Currently used to display the history and search results.Instance Variables:outliner	&lt;ClassOfVariable&gt;	description of variable's functionsubsetList	&lt;ClassOfVariable&gt;	description of variable's functionwindowLabel	&lt;ClassOfVariable&gt;	description of variable's functionmode	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>ArborSearchAndReplace</name><environment>VWHelp</environment><super>VWHelp.ArborSlaveApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>searchString replaceString ignoreCase paragraphEditor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Arbor GUI Extensions</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.ArborSearchAndReplace</class-id><body>This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.  The comment should also explain any unobvious aspects of the implementation.Instance Variables:searchString	&lt;ClassOfVariable&gt;	description of variable's functionreplaceString	&lt;ClassOfVariable&gt;	description of variable's functionignoreCase	&lt;ClassOfVariable&gt;	description of variable's functionparagraphEditor	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>AHSMemoryFriendlyHelpOutlineEntry</name><environment>VWHelp</environment><super>VWHelp.AHSHelpOutlineEntry</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filename </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSMemoryFriendlyHelpOutlineEntry</class-id><body>Copyright Ó 1994, 1995 Arbor Intelligent Systems, Inc.This class is used for storing each of the entries in an outline in a filePointer format which allows topics to be loaded as they are needed, rather than requiring the entire outline to be loaded.Instance Variables:filename	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>AHSSearchDialog</name><environment>VWHelp</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>searchString ignoreCase searchTopics searchText matchWholeWord searchIn </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Outline Help-Core</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></class><comment><class-id>VWHelp.AHSSearchDialog</class-id><body>Copyright © 1995 Arbor Intelligent Systems, Inc.This class implements a dialog which lets a user enter a search specification.  The specificationis used to locate help information which matches the given criteria.Instance Variables:	searchString &lt;ValueHolder on: String&gt;	ignoreCase &lt;Boolean&gt; future use	searchTopics &lt;Boolean&gt; future use	searchText &lt;Boolean&gt; future use	matchWholeWord &lt;Boolean&gt; future use	searchIn &lt;ValueHolder on: (#topics | #text | #both)&gt;</body></comment><shared-variable><name>IconSets</name><environment>VWHelp.ArborIconSet</environment><private>false</private><constant>false</constant><category>Class Vars</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></shared-variable><shared-variable><name>HorizontalDragCursor</name><environment>VWHelp.ArborDragBarController</environment><private>false</private><constant>false</constant><category>Cursors</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></shared-variable><shared-variable><name>VerticalDragCursor</name><environment>VWHelp.ArborDragBarController</environment><private>false</private><constant>false</constant><category>Cursors</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></shared-variable><shared-variable><name>FixupSignal</name><environment>VWHelp.AHSOutline</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></shared-variable><shared-variable><name>FilenameSignal</name><environment>VWHelp.AHSOutline</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Arbor Help System Outline Help Core</package></attributes></shared-variable><methods><class-id>VWHelp.AHSTextGraphicComposite</class-id> <category>private-components</category><body package="Arbor Help System Outline Help Core">addGraphic: aGraphic aboveText: aText	self addWrapper: (AHSTextGraphicLayoutWrapper						on: (LayoutWrapper								on: aGraphic								in: (AlignmentOrigin new										leftFraction: 0.5 offset: 0;										topFraction: 0 offset: 0;										leftAlignmentFraction: 0.5;										topAlignmentFraction: 0))						view: aGraphic						nextIsBeneath: true).	(aText notNil and: [aText isEmpty not])		ifTrue: [| view wrapper half |			"Display the caption under the graphic.  Ensure the width of the text is equal to the graphic but no less than 150."			view := self textComponentFor: aText.			wrapper := AHSAdjustableBoundedWrapper on: view.			half := (aGraphic extent x / 2) rounded max: 75.			wrapper layout: (LayoutFrame								leftFraction: 0.5 offset: half negated								rightFraction: 0.5 offset: half								topFraction: 0 offset: 0								bottomFraction: 1 offset: SmallInteger maxVal).			self addWrapper: (AHSTextGraphicLayoutWrapper on: wrapper view: view isCaption: true nextIsBeneath: true)].</body><body package="Arbor Help System Outline Help Core">addGraphic: aGraphic thenText: aText	| view wrapper |	self addWrapper: (AHSTextGraphicLayoutWrapper						on: (LayoutWrapper on: aGraphic in: 10@0)						view: aGraphic						nextIsBeneath: false).	view := self textComponentFor: aText.	wrapper := AHSAdjustableBoundedWrapper on: view.	wrapper layout: (LayoutFrame						leftFraction: 0 offset: aGraphic extent x + 20						rightFraction: 1 offset: 0						topFraction: 0 offset: 0						bottomFraction: 1 offset: SmallInteger maxVal).	self addWrapper: (AHSTextGraphicLayoutWrapper on: wrapper view: view isCaption: true nextIsBeneath: true).</body><body package="Arbor Help System Outline Help Core">addGraphicComponent: anAHSHelpHyperText	| graphic hypergraphic |	anAHSHelpHyperText isEmpty ifTrue: [^self].	hypergraphic := anAHSHelpHyperText firstAvailableHyperGraphic.	graphic := self outliner outliner forest 					graphicAt: hypergraphic linkObject					ifAbsent: [(('&lt;&lt; Missing Graphic: ', hypergraphic linkObject printString, ' &gt;&gt;') asText emphasizeAllWith: (Array with: #bold with: #large with: #color-&gt;ColorValue red)) asComposedText].	(hypergraphic hasCaption and: [hypergraphic captionIsAtLeft])		ifTrue: [self addText: hypergraphic caption thenGraphic: graphic].	(hypergraphic hasCaption and: [hypergraphic captionIsAtRight])		ifTrue: [self addGraphic: graphic thenText: hypergraphic caption].	(hypergraphic hasCaption not or: [hypergraphic captionIsAtCenter])		ifTrue: [self addGraphic: graphic aboveText: hypergraphic caption].</body><body package="Arbor Help System Outline Help Core">addText: aText thenGraphic: aGraphic	| view wrapper |	view := self textComponentFor: aText.	wrapper := AHSAdjustableBoundedWrapper on: view.	wrapper layout: (LayoutFrame						leftFraction: 0 offset: 0						rightFraction: 1 offset: (aGraphic extent x + 20) negated						topFraction: 0 offset: 0						bottomFraction: 1 offset: SmallInteger maxVal).	self addWrapper: (AHSTextGraphicLayoutWrapper on: wrapper view: view isCaption: true nextIsBeneath: false).	self addWrapper: (AHSTextGraphicLayoutWrapper						on: (LayoutWrapper								on: aGraphic								in: (AlignmentOrigin new										leftFraction: 1 offset: -10;										topFraction: 0 offset: 0;										leftAlignmentFraction: 1;										topAlignmentFraction: 0))						view: aGraphic						nextIsBeneath: true).</body><body package="Arbor Help System Outline Help Core">addTextComponent: anAHSHelpHyperText	| view |	anAHSHelpHyperText isEmpty ifTrue: [^self].	view := self textComponentFor: anAHSHelpHyperText.	self addWrapper: (AHSTextGraphicLayoutWrapper							on: (AHSAdjustableBoundedWrapper on: view at: 0@0)							view: view).</body><body package="Arbor Help System Outline Help Core">backgroundColor	"Answer the receiver's background color."	^ColorValue white.</body><body package="Arbor Help System Outline Help Core">textComponentFor: aText	| view |	view := AHSHelpTextEditorView model: aText asValue.	view controller performer: self outliner.	self outliner isReadOnly ifTrue: [view controller readOnly: true].	^view</body></methods><methods><class-id>VWHelp.AHSTextGraphicComposite</class-id> <category>private-selection support</category><body package="Arbor Help System Outline Help Core">allTextComponentsDo: aBlock	self components do: [:c | c wrapsTextView ifTrue: [aBlock value: c]].</body><body package="Arbor Help System Outline Help Core">characterBlockAtLocalPoint: aPoint for: aComponent	"Answer a character block based on aPoint (which is in aComponent's coordinate system).  The block is translated into my coordinate system, meaning that the string index as well as the bounds of the block are adjusted to be my global view of things."	^self characterBlockAtPoint: aPoint + (self translationFor: aComponent)</body><body package="Arbor Help System Outline Help Core">characterBlockAtPoint: aPoint	"Answer a character block.  The block is translated into my coordinate system, meaning that the string index as well as the bounds of the block are adjusted to be my global view of things."	| c |	^(c := self textComponentNearestTo: aPoint) isNil		ifTrue: [nil]		ifFalse: [| localBlock |			localBlock := c view characterBlockAtPoint: (c view globalPointToLocal: (self localPointToGlobal: aPoint)).			AHSCompositeCharacterBlock				stringIndex: (self sizeOfAllTextUpTo: c) + localBlock stringIndex				translation: (self translationFor: c view)				component: c view				localBlock: localBlock]</body><body package="Arbor Help System Outline Help Core">componentContaining: aPoint ifNone: aBlock	^self components		detect: [:c | (c preferredBounds expandedBy: (0@0 corner: 1@1)) containsPoint: aPoint]		ifNone: aBlock</body><body package="Arbor Help System Outline Help Core">deselect	self allTextComponentsDo: [:c | c view controller deselect].</body><body package="Arbor Help System Outline Help Core">scrollBy: aPoint	"Before scrolling, be sure there are no display events pending or the scroll and pending invalidations may conflict."	self topComponent checkForEvents.	self scrollWrapper scroll: aPoint negated</body><body package="Arbor Help System Outline Help Core">scrollIfNeededTo: aPoint	"Scroll if needed to make aPoint visible.  When possible, scroll by whole text lines only.  Only worry about vertical scrolling."	| bounds dy block |	bounds := self bounds.	block := self characterBlockAtPoint: aPoint.	(dy := (aPoint y min: block top) - bounds top) &lt; 0		ifFalse: [			(dy := (aPoint y max: block bottom) - bounds bottom) &gt; 0				ifFalse: [dy := 0]].	dy ~= 0 ifTrue: [self scrollBy: 0@dy].	^0@dy</body><body package="Arbor Help System Outline Help Core">selection	"This method assumes that the controller has properly managed the components' selection properties.  That is, all components with active selections SHOULD be next to each other but this condition is not verified."	| str |	str := (String new: 500) writeStream.	self allTextComponentsDo: [:comp |		comp view selectionShowing			ifTrue: [				str isEmpty not ifTrue: [str cr; cr].				str nextPutAll: comp view controller selection]].	^str contents</body><body package="Arbor Help System Outline Help Core">sizeOfAllTextUpTo: aComponent	| size |	size := 0.	self allTextComponentsDo: [:comp |		comp = aComponent ifTrue: [^size].		size := size + comp view displayContents text size].	^size</body><body package="Arbor Help System Outline Help Core">textComponentNearestTo: aPoint	"Assuming the composite contains at least one text component, answer the one closest to aPoint.  At the present time, the closest component will either be the one containing the point, the text element immediately to the left of aPoint, or the next text element deemed after the point."	| comp |	comp := self componentContaining: aPoint ifNone: [nil].	^(comp isNil or: [comp wrapsTextView not])		ifTrue: [| before left |			before := nil.			self allTextComponentsDo: [:c || cb |				cb := c preferredBounds.				"See if the component is before aPoint."				(cb bottom &lt; aPoint y)					ifTrue: [						before := c.						left := false]					ifFalse: [						"See if the component is to the left of aPoint."						((cb top &lt; aPoint y) and: [cb right &lt; aPoint x])							ifTrue: [								before := c.								left := true]].				"See if the component is after aPoint."				((cb top &gt; aPoint y) or: [(cb bottom &gt; aPoint y) and: [cb left &gt; aPoint x]])					ifTrue: [^left = true ifTrue: [before] ifFalse: [c]]].			before]		ifFalse: [comp]</body><body package="Arbor Help System Outline Help Core">translationFor: aComponent	"Answer the amount aComponent is translated from my origin."	^(aComponent localPointToGlobal: 0@0) - (self localPointToGlobal: 0@0)</body></methods><methods><class-id>VWHelp.AHSTextGraphicComposite</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">buildComponents	"Build the components from the current model's value.  Base the build on the hyperlinks in the text."	| graphics start mdl |	graphics := OrderedCollection new.	start := 1.	mdl := self model value.	mdl isString not ifTrue: [		mdl emphasesDo: [:emph :interval |			((mdl isHyperGraphic: emph) and: [emph value isEmbedded])				ifTrue: [graphics add: interval]].		graphics do: [:interval |			self addTextComponent: (mdl copyFrom: start to: interval first - 1).			self addGraphicComponent: (mdl copyFrom: interval first to: interval last).			start := interval last + 1]].	self addTextComponent: (mdl copyFrom: start to: mdl size).</body><body package="Arbor Help System Outline Help Core">changedPreferredBounds: oldPreferredBoundsOrNil forComponent: component	"Notify the receiver's container that the receiver's preferredBounds has	changed.  Always assume that if we get this notification that a redraw is necessary."	container == nil		ifFalse: [| lastBounds |				lastBounds := preferredBounds.				self bounds: self bounds.				lastBounds ~= preferredBounds					ifTrue: [						container							changedPreferredBounds: lastBounds							forComponent: self].				"Invalidate only from the changed guy on down."				self invalidateRectangle: (0@component bounds origin y extent: (lastBounds merge: preferredBounds) extent)].</body><body package="Arbor Help System Outline Help Core">discardComponents	"Throw away the current set of components and do any other necessary cleanup."	self controller resetState.	self components do: [:v | v release].	components := OrderedCollection new.</body><body package="Arbor Help System Outline Help Core">layoutComponentsForBounds: newBounds	"The receiver has been sized to the given parameters.  Re-layout all of the receiver's components."	| holdTop top |	preferredBounds := 0@0 extent: 0@0.	holdTop := top := 0.	1 to: components size do:		[:i || component |		component := components at: i.	"1. Set the bounds to coerce the component to recompose itself (if it's a text guy)."	"2. Set the bounds to be the same as the preferred bounds since that's what we want in the first place (but couldn't	know the actual height without recomposing after defining the width - kind of a catch-22)."	"3. Reset the bounds after doing a layout computation so that widgets with special alignments are properly placed."		component bounds: (0@top corner: newBounds corner).		component bounds: component preferredBounds.		component bounds: 	(self								computeDisplayBoxFor: component								inDisplayBox: (0@top corner: newBounds corner)).		holdTop := holdTop max: component preferredBounds bottom + 10.		component nextComponentIsBeneath			ifTrue: [top := holdTop].		preferredBounds := preferredBounds merge: component preferredBounds].</body><body package="Arbor Help System Outline Help Core">scrollWrapper	^self container</body><body package="Arbor Help System Outline Help Core">setModel: aModel	"Coerce an initial update."	super setModel: aModel.	self update: #value.</body></methods><methods><class-id>VWHelp.AHSTextGraphicComposite</class-id> <category>event driven</category><body package="Arbor Help System Outline Help Core">handlerForMouseEvent: aMouseEvent 	"Since I have a controller, ask the controller to handle the event.  Copied out of VisualPart&gt;&gt;handlerForMouseEvent."	| ctrl |	ctrl := self getController.	ctrl notNil ifTrue: [| obj |		obj := Object errorSignal					handle: [:ex |						"Trap errors occurring while searching for 	the object wanting control."						Controller badControllerSignal raiseErrorString: 'Bad controller in handlerForMouseEvent:']					do: [ctrl handlerForMouseEvent: aMouseEvent].		obj notNil ifTrue: [^obj]].	^super handlerForMouseEvent: aMouseEvent</body></methods><methods><class-id>VWHelp.AHSTextGraphicComposite</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">outliner	^outliner</body><body package="Arbor Help System Outline Help Core">outliner: anAHSOutliner	outliner := anAHSOutliner.	self model: self outliner toolbarTextEditor text.</body></methods><methods><class-id>VWHelp.AHSTextGraphicComposite</class-id> <category>controller accessing</category><body package="Arbor Help System Outline Help Core">defaultControllerClass	^AHSTextGraphicCompositeController</body></methods><methods><class-id>VWHelp.AHSTextGraphicComposite</class-id> <category>updating</category><body package="Arbor Help System Outline Help Core">update: anAspectSymbol	"The model has changed.  Discard my current set of components and build up a new one.  Temporarily set the container to nil during the build so that there is minimal flashing during the update."	| parent tc lineGrid |	self container isNil ifTrue: [^self].	((container container isKindOf: BorderedWrapper) and: [container container insideColor isNil])		ifTrue: [container container insideColor: ColorValue white].	parent := self container.	container := nil.	self discardComponents.	self buildComponents.	container := parent.	self deselect.	self layoutComponentsForBounds: self bounds.	(tc := self textComponentNearestTo: 0@0) isNil		ifTrue: [lineGrid := TextAttributes default lineGrid]		ifFalse: [lineGrid := tc view lineGrid].	self scrollWrapper scrollOffsetHolder		value: 0@0;		grid: 20@lineGrid.	self changedPreferredBounds: nil.	self invalidate.</body></methods><methods><class-id>VWHelp.AHSReporterData</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">indentStringFor: aTopicTree	"Private - Answer an indent string for the given topic tree."	^ ((String new: aTopicTree depth) atAllPut: Character tab)</body></methods><methods><class-id>VWHelp.AHSReporterData</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">indent	^ indent</body><body package="Arbor Help System Outline Help Core">topic	^ topic</body><body package="Arbor Help System Outline Help Core">topicText	^ topicText</body></methods><methods><class-id>VWHelp.AHSReporterData</class-id> <category>writing</category><body package="Arbor Help System Outline Help Core">writeTopicBodyTo: aStream	aStream		ahsNextPutAllText: indent;		ahsNextPutAllText: (topic asText emphasizeAllWith: #(bold underline));		cr;		ahsNextPutAllText: indent;		tab;		ahsNextPutAllText: topicText;		cr;		cr</body><body package="Arbor Help System Outline Help Core">writeTopicLineTo: aTextStream	aTextStream		ahsNextPutAllText: indent;		ahsNextPutAllText: topic;		cr.</body></methods><methods><class-id>VWHelp.AHSReporterData</class-id> <category>initialization</category><body package="Arbor Help System Outline Help Core">initFromTopic: aTree	indent := self indentStringFor: aTree.	topic := aTree data topic.	topicText := aTree data text.</body></methods><methods><class-id>VWHelp.AHSReporterData class</class-id> <category>instance creation</category><body package="Arbor Help System Outline Help Core">onTopic: aTree	"Answer a new instance of the receiver initialized with data found in aTree.  A tree	 is assumed to hold outline data."		^ self new		initFromTopic: aTree</body></methods><methods><class-id>VWHelp.AHSOutlineViewer</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">bookmarks	^bookmarks</body><body package="Arbor Help System Outline Help Core">bookmarks: aDictionary	^bookmarks := aDictionary</body><body package="Arbor Help System Outline Help Core">currentTopic	"Private - Answer the currently selected topic."	^ self outliner list selection value</body><body package="Arbor Help System Outline Help Core">history 	^history</body><body package="Arbor Help System Outline Help Core">historyIndex	^historyIndex</body><body package="Arbor Help System Outline Help Core">historyIndex: anIndexOrNil	"Update the history index considering its boundaries in relation to the history size."		(anIndexOrNil notNil and: [self historyIndex notNil])		ifTrue:			[anIndexOrNil &gt; (self history size + 1) ifTrue: [^ historyIndex := self history size + 1].			anIndexOrNil &lt; 0 ifTrue: [^ historyIndex := 0]].	^ historyIndex := anIndexOrNil</body><body package="Arbor Help System Outline Help Core">infoHasChanged	^infoHasChanged</body><body package="Arbor Help System Outline Help Core">infoHasChanged: aBoolean	infoHasChanged := aBoolean</body><body package="Arbor Help System Outline Help Core">initialSelection: aTree 	initialSelection := aTree.	self builder isNil ifFalse: [self builder window isOpen ifTrue: [self outliner selectEntry: aTree]]</body><body package="Arbor Help System Outline Help Core">isReadOnly	^ true</body><body package="Arbor Help System Outline Help Core">lastEntry	^lastEntry</body><body package="Arbor Help System Outline Help Core">lastEntry: anAHSHelpOutlineEntry	^lastEntry := anAHSHelpOutlineEntry.</body><body package="Arbor Help System Outline Help Core">list: aSelectionInList	outliner list: aSelectionInList.</body><body package="Arbor Help System Outline Help Core">outline	^self outliner outline odbRefreshIfNotDirty.</body><body package="Arbor Help System Outline Help Core">outlineFileFormat	^self outline fileFormat</body><body package="Arbor Help System Outline Help Core">outlineName	"Lookup key in database or a file name"	^self outline name</body><body package="Arbor Help System Outline Help Core">outliner	^outliner</body><body package="Arbor Help System Outline Help Core">outlinerWindowMenu	"Answer the contents of the menu bar"	outlinerWindowMenu isNil ifTrue: [outlinerWindowMenu := self menuBar asValue].	^ outlinerWindowMenu</body><body package="Arbor Help System Outline Help Core">outlinerWindowMenu: aValueHolder	outlinerWindowMenu := aValueHolder</body><body package="Arbor Help System Outline Help Core">outlineSource	^outlineSource</body><body package="Arbor Help System Outline Help Core">outlineSource: aSymbol	outlineSource := aSymbol</body><body package="Arbor Help System Outline Help Core">searchEntriesFound	^searchEntriesFound</body><body package="Arbor Help System Outline Help Core">searchString	^searchString</body><body package="Arbor Help System Outline Help Core">searchString: aString	searchString := aString</body><body package="Arbor Help System Outline Help Core">selectedTopic	"Answer the currently selected topic, or nil if no topic is selected."	^ self outliner selectionValue</body><body package="Arbor Help System Outline Help Core">shouldUpdateHistoryStack	^shouldUpdateHistoryStack</body><body package="Arbor Help System Outline Help Core">shouldUpdateHistoryStack: aBoolean	shouldUpdateHistoryStack := aBoolean</body><body package="Arbor Help System Outline Help Core">text	^self toolbarTextEditor text</body><body package="Arbor Help System Outline Help Core">textController	^self toolbarTextEditor textController</body><body package="Arbor Help System Outline Help Core">toolbarTextEditor	^toolbarTextEditor</body></methods><methods><class-id>VWHelp.AHSOutlineViewer</class-id> <category>events</category><body package="Arbor Help System Outline Help Core">noticeOfWindowClose: aWindow	self release.	^ super noticeOfWindowClose: aWindow</body></methods><methods><class-id>VWHelp.AHSOutlineViewer</class-id> <category>history</category><body package="Arbor Help System Outline Help Core">goBackwardsOnce	"Go back one entry in the history list according to historyIndex."	| topic |	self history isEmpty ifTrue: [^Dialog warn: #historyEmpty &lt;&lt; self messageCatalogID].	(topic := self history back) isNil ifTrue: [^Dialog warn: #noPrevEntries &lt;&lt; self messageCatalogID].	self setTopic: topic.</body><body package="Arbor Help System Outline Help Core">goForwardOnce	"Go forward one entry in the history list according to historyIndex."	| topic |	self history isEmpty ifTrue: [^Dialog warn: #historyEmpty &lt;&lt; self messageCatalogID].	(topic := self history forward) isNil ifTrue: [^Dialog warn: #noMoreEntries &lt;&lt; self messageCatalogID].	self setTopic: topic.</body><body package="Arbor Help System Outline Help Core">openHistory	"opens a history of the selected entries in the outline"	| historyListWindow | 	(historyListWindow := self openedHistoryWindow) isNil		ifTrue: [self openHistoryViewer]		ifFalse: [self restoreWindow: historyListWindow model]</body><body package="Arbor Help System Outline Help Core">selectEntryNoHistoryUpdate: obj	"Select the desired entry but avoid updating the history stack."		self shouldUpdateHistoryStack: false.	self outliner selectEntry: obj.	self shouldUpdateHistoryStack: true.</body></methods><methods><class-id>VWHelp.AHSOutlineViewer</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">checkForAutoAccept	"Private - Accept any changes if auto accept is active."		self builder window keyboardProcessor checkForAutoAccept.</body><body package="Arbor Help System Outline Help Core">findBookmarkTopic: aBookmark	"Private - Answer the topic in the outline at the specified bookmark."		^ self outliner outline findTopicNumber: (bookmarks at: aBookmark)</body><body package="Arbor Help System Outline Help Core">fixOutlinerSizeForUnzoom	"fix the outline boundaries when opening the hyperlink manager 	in order to give as much space as possible to the topics outline."	self aisMakeVisible: #dragBar.	self listOutlineBrowser 		newBounds: self topicListUnzoomedBoundaries;		newLayout: self topicListUnzoomedLayout.	self textSubCanvas		newBounds: self topicTextUnzoomedBoundaries;		newLayout: self topicTextUnzoomedLayout.</body><body package="Arbor Help System Outline Help Core">fixOutlinerSizeForZoom	"fix the outline boundaries when opening the hyperlink manager 	in order to give as much space as possible to the topics outline."	self aisMakeInvisible: #dragBar.	self textSubCanvas		newBounds: self topicTextZoomedBoundaries;		newLayout: self topicTextZoomedLayout.	self listOutlineBrowser		newBounds: self topicListZoomedBoundaries;		newLayout: self topicListZoomedLayout.</body><body package="Arbor Help System Outline Help Core">forceAccept	self builder isNil ifFalse: [self toolbarTextEditor accept]</body><body package="Arbor Help System Outline Help Core">getDBAssociationForOpen	"Selects which database open operation should be included in the File menu 	for the help outliner. Since flat files are always in the File menu, avoid	duplicating this menu entry..."	AHSStorageManager outlineSource == #GemStone 		ifTrue: [^ ('#openOutlineFromGemStone'	-&gt;	#openOutlineFromGemStone)].	"AHSStorageManager outlineSource == #Oracle 		ifTrue: [^ ('Open Outline From Oracle...'	-&gt;	#openOutlineFromOracle)].	AHSStorageManager outlineSource == #Sybase 		ifTrue: [^ ('Open Outline From Sybase...'	-&gt;	#openOutlineFromSybase)]."	AHSStorageManager outlineSource == #Versant 		ifTrue: [^ ('#openOutlineFromVersant'	-&gt;	#openOutlineFromVersant)].	AHSStorageManager outlineSource == #Envy 		ifTrue: [^ ('#openOutlineFromEnvy'	-&gt;	#openOutlineFromEnvy)].	^nil</body><body package="Arbor Help System Outline Help Core">getDBAssociationForSave	"Selects which database save operation should be included in the File menu 	for the help outliner."	^ nil</body><body package="Arbor Help System Outline Help Core">glossaryDictionary	"Private - Answer the glossary held by the outline."	^ self outline glossaryDictionary</body><body package="Arbor Help System Outline Help Core">graphicsDictionary	"Private - Answer the graphics dictionary held by the outline."	^self outline graphicsDictionary</body><body package="Arbor Help System Outline Help Core">isHelpVis	^(self builder componentAt: #help) isVisible</body><body package="Arbor Help System Outline Help Core">jumpToTopicReferencedBy: aHyperlink	"Private - Jump to the topic referenced by aHyperlink."	| topic |	(topic := self outline findTopicNumber: (aHyperlink topicName)) isNil ifTrue: [^ Dialog warn: 'This is a link to a deleted topic.'].	self checkForAutoAccept.	self outliner selectEntry: topic.	self toolbarTextEditor deselect</body><body package="Arbor Help System Outline Help Core">openHistoryViewer	"Private - Open a new history window."	| historyList label | 	historyList := AHSOutlinerSubsetList new.	historyList 		parentWindow: self builder window;		relativeOrigin: #left;		outliner: self;		mode: #history.	historyList subsetList list: self history linearHistory.	label := (#outlineHistory &lt;&lt; self messageCatalogID) asString.	self builder window isModalDialog		ifTrue: [historyList openDialogWithLabel: label]		ifFalse: [historyList openWithLabel: label]</body><body package="Arbor Help System Outline Help Core">openOutlineViewerFor: aHyperlink	"Private - Open a new outline window for the item referenced in aHyperlink.  If the link references	 an outline which is already open, reuse the one that is already open.  This assumes that the outline	 is not the outline being viewed by the receiver."	| otherOutline |	otherOutline := aHyperlink outlineName isNil						ifTrue: [self outlineName]						ifFalse: [aHyperlink outlineName].	^ self class		openOutlineNamed: otherOutline		topicNumber: (aHyperlink topicName)		modal: self builder window isModalDialog		raiseExisting: self raiseExistingOutlineViewer.</body><body package="Arbor Help System Outline Help Core">releaseGlossaryLock	"Private - If the glossary link wasn't created, release the lock.  Check to make sure the glossary 	 isn't open somewhere, so I don't interfere with it's lock on the glossary"	self openedGlossaryWindow isNil ifTrue: [self glossaryDictionary odbReleaseUnDirtyLock]</body><body package="Arbor Help System Outline Help Core">restoreWindow: anApplicationModel	"Restore the window identifiied by anApplicationModel."	| window |	window := anApplicationModel builder window.	window isCollapsed ifTrue: [window expand].	window raise</body><body package="Arbor Help System Outline Help Core">setTextValue: aText	"Private - Set the value for the text model.  Make sure the update mechanism isn't triggered."	self text value: aText.</body></methods><methods><class-id>VWHelp.AHSOutlineViewer</class-id> <category>menu messages</category><body package="Arbor Help System Outline Help Core">contractAll	"contract absolutely all entries in the outline."	| flag |	flag := nil.	self outline do: 		[:entry | 		flag isNil			ifTrue: 				[self outliner selectEntry: entry.				flag := 1].		self outliner contract: entry]</body><body package="Arbor Help System Outline Help Core">expandAll	"expand absolutely all entries in the outline."	| obj |	obj := nil.	self outline do: 		[:entry | 		obj isNil ifTrue: [obj := self outliner selectionValue].		self outliner expandFully: entry].	obj notNil ifTrue:		[self outliner 			selectEntry: obj;			expandFully: obj]</body><body package="Arbor Help System Outline Help Core">newOutline	self builder window isModalDialog		ifTrue: [self openAsDialog]		ifFalse: [self open]</body><body package="Arbor Help System Outline Help Core">openOutlineFrom: aString	"Private - Open an outline from the source indicated by aString.  aString should be one of 'Envy', 'File'.	'GemStone' or 'Versant'"	| outlineName chooseMethod |	chooseMethod := ('chooseOutlineNameIn' , aString) asSymbol.	outlineName := AHSStorageManager perform: chooseMethod.	outlineName isNil ifTrue: [^ self].	^ self class		openOutlineNamed: outlineName		modal: self builder window isModalDialog		source: aString asSymbol</body><body package="Arbor Help System Outline Help Core">openOutlineFromEnvy	^ self openOutlineFrom: 'Envy'</body><body package="Arbor Help System Outline Help Core">openOutlineFromFile	^ self openOutlineFrom: 'File'</body><body package="Arbor Help System Outline Help Core">openOutlineFromGemStone	^ self openOutlineFrom: 'GemStone'</body><body package="Arbor Help System Outline Help Core">openOutlineFromVersant	^ self openOutlineFrom: 'Versant'</body><body package="Arbor Help System Outline Help Core">saveAsTextFile	"Save the outline into a text file"	| fname |	(fname := Dialog				requestNewFileName: 'File name:'				default: 'outline.txt') isEmpty ifTrue: [^ self].	Cursor wait showWhile: 		[(AHSReporter on: outliner outline)			writeToFileNamed: fname]</body><body package="Arbor Help System Outline Help Core">showBalloons	AHSWHCProcessor helpEnabled 		ifTrue: 			[AHSWHCProcessor balloonHelpEnabled: AHSWHCProcessor balloonHelpEnabled not]		ifFalse: 			[AHSWHCProcessor balloonHelpEnabled 				ifTrue: [AHSWHCProcessor helpEnabled: true]				ifFalse: 					[AHSWHCProcessor balloonHelpEnabled: true.					AHSWHCProcessor helpEnabled: true]]</body><body package="Arbor Help System Outline Help Core">showHelp	(self builder aspectAt: #ahsFlag) value: self isHelpVis not</body><body package="Arbor Help System Outline Help Core">zoom	"Private - Toggle the zoom state of the window."	zoomed		ifTrue: [self unzoomTopicText]		ifFalse: [self zoomTopicText]</body></methods><methods><class-id>VWHelp.AHSOutlineViewer</class-id> <category>bookmarks</category><body package="Arbor Help System Outline Help Core">addBookmark	"Add a bookmark to the bookmark dictionary for the current page.  The name of the bookmark 	 defaults to the current topic.  The bookmark name must be unique."	| aTree bookmark aMenuItem |	(aTree := self outliner selectionValue) isNil ifTrue: [^ Dialog warn: 'No topic selected.'].	(bookmark := self getNewBookmarkNameFromUser: aTree data topic) isNil ifTrue: [ ^ nil].	self bookmarks 		at: bookmark		put: aTree data uniqueID.		self saveBookmarksInFile.	aMenuItem := MenuItem labeled: (bookmark copyReplaceAll: '&amp;' with: '&amp;&amp;').	self bookmarkMenu numberOfItems == 2		ifTrue: [self bookmarkMenu aisAddSeparator].	self bookmarkMenu 		addItem: aMenuItem 		value: [self engageBookmark: bookmark] 		nameKey: bookmark.</body><body package="Arbor Help System Outline Help Core">bookmarkFilename	^ self outlineName ~= 'Untitled'		ifTrue: 			[| extensionPosition fname oName |			oName := self outlineName asFilename tail.			fname := (extensionPosition := oName lastIndexOf: $.) == 0						ifTrue: [oName]						ifFalse: 							[oName 								copyFrom: 1 								to: extensionPosition - 1].			fname, '.bkm']		ifFalse: ['untitled.bkm']</body><body package="Arbor Help System Outline Help Core">bookmarkMenu	^(self outlinerWindowMenu value atNameKey: #bookmark) submenu</body><body package="Arbor Help System Outline Help Core">buildBookmarkMenu	"Build the bookmarks from the bookmarks dictionary."	self bookmarks keys do: [:bookmark || aMenuItem |		aMenuItem := MenuItem labeled: (bookmark copyReplaceAll: '&amp;' with: '&amp;&amp;').		self bookmarkMenu numberOfItems == 2			ifTrue: [self bookmarkMenu aisAddSeparator].		self bookmarkMenu 			addItem: aMenuItem 			value: [self engageBookmark: bookmark] 			nameKey: bookmark].</body><body package="Arbor Help System Outline Help Core">deleteBookmark	"Delete a bookmark that is selected by the user in a list of bookmarks from the bookmark menu. "	| bookmarkList bookmark |	(bookmarkList := self bookmarks keys asList) isEmpty ifTrue: [^ Dialog warn: 'There are no bookmarks to delete.'].	(bookmark := Dialog 						choose: 'Bookmark to delete:' 						fromList: bookmarkList 						values: bookmarkList 						lines: 10 						cancel: [nil]) isNil ifTrue: [^ nil].	self bookmarks removeKey: bookmark.	self saveBookmarksInFile.	self bookmarkMenu removeItem: (self bookmarkMenu atNameKey: bookmark)</body><body package="Arbor Help System Outline Help Core">engageBookmark: aBookmark	"Set the outline viewer to display the topic associated with the specified bookmark."	self outliner selectEntry: (self findBookmarkTopic: aBookmark).</body><body package="Arbor Help System Outline Help Core">loadBookmarksFromFile	"Load the bookmarks from a flat file, if it exists.  The name of the file is built from the name of outline with the extension .bkm."	| newBookmarks |	(newBookmarks := AHSStorageManager bookmarksInFlatFileNamed: self bookmarkFilename) notNil		ifTrue: 				[self 				bookmarks: newBookmarks;				buildBookmarkMenu].</body><body package="Arbor Help System Outline Help Core">saveBookmarksInFile	"Save the bookmarks in a flat file.  If there are no bookmarks, then remove the file if it exists."	self bookmarks isEmpty		ifTrue: [AHSStorageManager removeBookmarksInFlatFileNamed: self bookmarkFilename]		ifFalse: [			AHSStorageManager 				bookmarksInFlatFileNamed: self bookmarkFilename 				put: self bookmarks].</body></methods><methods><class-id>VWHelp.AHSOutlineViewer</class-id> <category>testing</category><body package="Arbor Help System Outline Help Core">haveBookmark: aBookmark	"Answer true if we currently have the given bookmark."	^ self bookmarks includesKey: aBookmark</body><body package="Arbor Help System Outline Help Core">raiseExistingOutlineViewer	"Private - Answer true if we should utilize an existing outline viewer looking at the same outline."	^ InputState default shiftDown not.</body><body package="Arbor Help System Outline Help Core">referencesSameOutlineAs: aHyperlink	"Private - Answer true if aHyperlink references the same outline name as the one we are currently viewing."	^ aHyperlink outlineName isNil or: [aHyperlink outlineName = self outline name]</body><body package="Arbor Help System Outline Help Core">shouldCloseHelpSubcanvas	"Private - Answer true if we should close the help subcanvas pane."	^self isHelpVis		and: [AHSWHCProcessor helpEnabled not		or: [(self builder aspectAt: #ahsFlag) value not]]</body><body package="Arbor Help System Outline Help Core">shouldOpenHelpSubcanvas	"Private - Answer true if we should open the help subcanvas pane."	^self isHelpVis not		and: [AHSWHCProcessor helpEnabled		and: [(self builder aspectAt: #ahsFlag) value]]</body><body package="Arbor Help System Outline Help Core">shouldOpenNewOutlineViewerFor: aHyperlink	"Private - Answer true if we should open a new outline viewer for the given hyperlink."	^ (self referencesSameOutlineAs: aHyperlink) not or: [self raiseExistingOutlineViewer not]</body></methods><methods><class-id>VWHelp.AHSOutlineViewer</class-id> <category>interface components</category><body package="Arbor Help System Outline Help Core">dragBar	"Private - Answer the drag bar."	^ self builder componentAt: #dragBar</body><body package="Arbor Help System Outline Help Core">listOutlineBrowser	"Private - Answer the listOutlineBrowser pane."	^ self builder componentAt: #listOutlineBrowser</body><body package="Arbor Help System Outline Help Core">textSubCanvas	"Private - Answer the textSubCanvas pane."	^ self builder componentAt: #textSubCanvas</body></methods><methods><class-id>VWHelp.AHSOutlineViewer</class-id> <category>menu construction - private</category><body package="Arbor Help System Outline Help Core">addBookmarkSubmenuTo: aMenu	"Private - Add the Bookmark submenu to aMenu."	| bookmarkMenu |	bookmarkMenu := Menu new.	bookmarkMenu		addItem: ((MenuItem labeled: #addBookmark &lt;&lt; self messageCatalogID)						value: #addBookmark;						shortcutKeyCharacter: $K;						enabled: [self outliner list selectionIndex ~= 0]);		addItem: ((MenuItem labeled: #deleteBookmark &lt;&lt; self messageCatalogID)						value: #deleteBookmark;						enabled: [self bookmarks keys isEmpty not]).	^aMenu addItem: ((MenuItem labeled: #bookmark &lt;&lt; self messageCatalogID)							nameKey: #bookmark;							submenu: bookmarkMenu)</body><body package="Arbor Help System Outline Help Core">addFileSubmenuTo: aMenu	"Private - Add the File submenu to aMenu."	| sub assoc |	sub := Menu new.	sub addItem: ((MenuItem labeled: #openOutlineFromFile &lt;&lt; self messageCatalogID)						value: #openOutlineFromFile;						nameKey: #fileOpen;						shortcutKeyCharacter: $O).	(assoc := self getDBAssociationForOpen) notNil		ifTrue: [sub addItemLabel: assoc key &lt;&lt; self messageCatalogID value: assoc value].	self addExportItemsTo: sub.	self addPrintSubmenuTo: sub.	sub		aisAddSeparator;		addItem: ((MenuItem labeled: #exit &lt;&lt; self messageCatalogID)						value: #closeRequest).	^aMenu addItem: ((MenuItem labeled: #file &lt;&lt; self messageCatalogID)						nameKey: #file;						submenu: sub)</body><body package="Arbor Help System Outline Help Core">addHelpSubmenuTo: aMenu 	"Private - Add the Help submenu to aMenu."	| helpMenu |	helpMenu := Menu new.	helpMenu		addItem: ((MenuItem labeled: #useWidgetHelp &lt;&lt; self messageCatalogID)					value: #showHelp;					indication: [self isHelpVis]);		addItem: ((MenuItem labeled: #useBalloonHelp &lt;&lt; self messageCatalogID)					value: #showBalloons;					indication: [AHSWHCProcessor helpEnabled and: [self ahsWindow ahsProcessor balloonHelpEnabled]]).	^aMenu addItem: ((MenuItem labeled: #help &lt;&lt; self messageCatalogID)				nameKey: #help;				submenu: helpMenu)</body><body package="Arbor Help System Outline Help Core">addNavigateSubmenuTo: aMenu	"Private - Add the 'navigate' components to aMenu."	| navigateMenu |	navigateMenu := Menu new.	navigateMenu		addItem: ((MenuItem labeled: #open &lt;&lt; self messageCatalogID)						value: #openHistory;						shortcutKeyCharacter: $H;						enabled: [self history stack isEmpty not]);		addItem: ((MenuItem labeled: #goBackwardsOnce &lt;&lt; self messageCatalogID)						value: #goBackwardsOnce;						shortcutKeyCharacter: $B;						enabled: [self history topOfStack &gt; 1]);		addItem: ((MenuItem labeled: #goForwardOnce &lt;&lt; self messageCatalogID)						value: #goForwardOnce;						shortcutKeyCharacter: $F;						enabled: [self history stack size ~= self history topOfStack]);		aisAddSeparator;		addItem: ((MenuItem labeled: #search &lt;&lt; self messageCatalogID) value: #search);		addItem: ((MenuItem labeled: #repeatLastSearch &lt;&lt; self messageCatalogID)						value: #repeatLastSearch;						shortcutKeyCharacter: $R;						enabled: [self searchString notNil]);		addItem: ((MenuItem labeled: #findNextWithinText &lt;&lt; self messageCatalogID)						value: #nextOccurrence;						shortcutKeyCharacter: $T).	^aMenu addItem: ((MenuItem labeled: #navigate &lt;&lt; self messageCatalogID)							nameKey: #navigate;							submenu: navigateMenu)</body><body package="Arbor Help System Outline Help Core">addPrintSubmenuTo: aMenu	"Private - Add the Print submenu to aMenu"	^aMenu addItem: ((MenuItem labeled: #print &lt;&lt; self messageCatalogID)						submenu: (Menu new										addItemLabel: #fullOutline &lt;&lt; self messageCatalogID value: #hardcopy;										addItem: ((MenuItem labeled: #selectedTopic &lt;&lt; self messageCatalogID)														value: #printTopic;														shortcutKeyCharacter: $P);										addItemLabel: #selectedTopicAndChildren &lt;&lt; self messageCatalogID value: #printTopicTree))</body><body package="Arbor Help System Outline Help Core">addViewSubmenuTo: aMenu	"Private - Add the View submenu to aMenu."	| viewMenu |	viewMenu := Menu new.	viewMenu		addItem: ((MenuItem labeled: #expandAll &lt;&lt; self messageCatalogID)						value: #expandAll;						shortcutKeyCharacter: $X);		addItem: ((MenuItem labeled: #contractAll &lt;&lt; self messageCatalogID)						value: #contractAll;						shortcutKeyCharacter: $C);		aisAddSeparator;		addItem: ((MenuItem labeled: #zoom &lt;&lt; self messageCatalogID)						value: #zoom;						nameKey: #zoom;						shortcutKeyCharacter: $Z);		aisAddSeparator;		addItem: ((MenuItem labeled: #glossary &lt;&lt; self messageCatalogID)						value: #showFullGlossary;						shortcutKeyCharacter: $L);		addItem: ((MenuItem labeled: #graphics &lt;&lt; self messageCatalogID)						value: #showGraphics;						shortcutKeyCharacter: $G).	^aMenu addItem: ((MenuItem labeled: #view &lt;&lt; self messageCatalogID)						nameKey: #view;						submenu: viewMenu)</body></methods><methods><class-id>VWHelp.AHSOutlineViewer</class-id> <category>menu resources</category><body package="Arbor Help System Outline Help Core">constructedMenuBar	| menu |	menu := Menu new.	^self 		addFileSubmenuTo: menu;		addViewSubmenuTo: menu;		addNavigateSubmenuTo: menu;		addBookmarkSubmenuTo: menu;		addHelpSubmenuTo: menu</body><body package="Arbor Help System Outline Help Core">menuBar	"A menu that provides all operations for the help outliner."	^self constructedMenuBar</body></methods><methods><class-id>VWHelp.AHSOutlineViewer</class-id> <category>enumerating</category><body package="Arbor Help System Outline Help Core">outlineDo: aBlock	^self outliner outlineDo: aBlock</body></methods><methods><class-id>VWHelp.AHSOutlineViewer</class-id> <category>searching</category><body package="Arbor Help System Outline Help Core">getSearchWindow	"Return the search window or nil if one isn't open."	^ScheduledControllers scheduledControllers		relate: [:sc || mdl |			mdl := sc model.			((mdl isKindOf: AHSOutlinerSubsetList)				and: [mdl mode = #search				and: [mdl parentWindow = self builder window]])					ifTrue: [sc view]]		ifNone: [nil]</body><body package="Arbor Help System Outline Help Core">highlightSearchedWord	"highlight the selection that was the objective of the search."	^self toolbarTextEditor findAndSelectString: self searchString.</body><body package="Arbor Help System Outline Help Core">nextOccurrence	"search for the next entry of the selected text within the same piece of text."	self toolbarTextEditor nextOccurrence ifFalse: [		Dialog warn: (#noEntriesMatching &lt;&lt; self messageCatalogID) asString					, ' "', self searchString, '" ' ,					(#foundInOutline &lt;&lt; self messageCatalogID) asString]</body><body package="Arbor Help System Outline Help Core">openSearchResultsList	"opens a list containing the search results."	| aResultsWindow aResultsList label |	aResultsWindow := self getSearchWindow.	aResultsWindow isNil		ifTrue: [			aResultsList := AHSOutlinerSubsetList new.			aResultsList				parentWindow: self builder window;				relativeOrigin: #top;				outliner: self;				mode: #search.			aResultsList subsetList list: self searchEntriesFound.			label := (#searchResultsFor &lt;&lt; self messageCatalogID) asString , ' "', self searchString, '"'.			self builder window isModalDialog				ifTrue: [aResultsList openDialogWithLabel: label]				ifFalse: [aResultsList openWithLabel: label]]		ifFalse: [			aResultsWindow model windowLabel: ((#searchResultsFor &lt;&lt; self messageCatalogID) asString , ' "', self searchString, '"').			aResultsWindow isCollapsed ifTrue: [aResultsWindow expand].			aResultsWindow raise].</body><body package="Arbor Help System Outline Help Core">repeatLastSearch	"Repeat the last search performed."	self showSearchResults</body><body package="Arbor Help System Outline Help Core">search	"Get the search specifications from an AHSSearchDialog, and then perform the search."	| searchDictionary shouldSearchTopics shouldSearchText |	searchDictionary := AHSSearchDialog searchFor: ''.	searchDictionary isNil 		ifTrue: [^nil].	self searchString: (searchDictionary at: #searchString) asString.	shouldSearchTopics := searchDictionary at: #searchTopics ifAbsent: [false].	shouldSearchText := searchDictionary at: #searchText ifAbsent: [false].	self searchEntriesFound removeFrom: 1 to: self searchEntriesFound size.					self outline do:		[:aTree |		aTree do:			[:currentTree || noMatch |			noMatch := true.			shouldSearchTopics ifTrue: 				[(currentTree data topic asString asLowercase indexOfSubCollection: self searchString asLowercase startingAt: 1) ~= 0 ifTrue: 					[self searchEntriesFound add: currentTree data.					noMatch := false]].			(shouldSearchText and: [noMatch])				ifTrue: [(currentTree data text asString asLowercase indexOfSubCollection: self searchString asLowercase startingAt: 1) ~= 0							ifTrue: [self searchEntriesFound add: currentTree data]]]].	self showSearchResults</body><body package="Arbor Help System Outline Help Core">showSearchResults	| aSearchWindow |	(self searchEntriesFound isNil or: [self searchEntriesFound isEmpty])		ifTrue: 			[self searchString isNil ifTrue: [^Dialog warn: #noPreviousSearch &lt;&lt; self messageCatalogID].			aSearchWindow := self getSearchWindow.			aSearchWindow notNil				ifTrue: [aSearchWindow model windowLabel: ((#searchResultsFor &lt;&lt; self messageCatalogID) asString , ' "', self searchString, '"')].			Dialog warn: (#noEntriesMatching &lt;&lt; self messageCatalogID) asString					, ' "', self searchString, '" ' ,					(#foundInOutline &lt;&lt; self messageCatalogID) asString]		ifFalse: [self openSearchResultsList]</body></methods><methods><class-id>VWHelp.AHSOutlineViewer</class-id> <category>printing</category><body package="Arbor Help System Outline Help Core">hardcopy	"Send the outline to the printer"	self print: outliner outline.</body><body package="Arbor Help System Outline Help Core">print: anOutline	"Send the outline to the printer"	| stream |	stream := TextStream on: ''.	Cursor wait showWhile: 		[stream 			nextPutAllText: (#{Smalltalk.Text} value  								new: 7 								withAll: Character tab);			nextPutAllText: self printableOutlineName;			nextPutAllText: (#{Smalltalk.Text} value  								new: 2 								withAll: Character cr);			nextPutAllText: (AHSReporter on: anOutline) text.		stream contents asComposedText hardcopy]</body><body package="Arbor Help System Outline Help Core">printHyperLinksOn: aStream	"loops through outline and  prints out report summarizing all links available"	self outliner outline reportHyperLinksOn: aStream</body><body package="Arbor Help System Outline Help Core">printTopic	"Print the selected topic only."	self print: self topicOutline</body><body package="Arbor Help System Outline Help Core">printTopicTree	"Print information for the selected topic and its children."	self print: self topicTreeOutline</body><body package="Arbor Help System Outline Help Core">saveLinksInCSVFile	"Generate a report on Hyperlinks and save to a CSV File, which can be read by Excel"	| fname aStream |	fname := Dialog			requestNewFileName: 'CSV File name:'			default: 'outlin27.csv'.	Cursor wait showWhile: [		fname isEmpty 			ifFalse: [aStream := fname asFilename writeStream.					self printHyperLinksOn: aStream.					aStream close].].</body><body package="Arbor Help System Outline Help Core">tempOutlineFrom: aTopic	"Private - Answer a temporary outline used for printing information found in aTopic."	^ AHSOutline 		fromTopicTree: aTopic		labeled: self outliner outline outlineLabel</body><body package="Arbor Help System Outline Help Core">topicOutline	"Private - Answer a new outline which contains only the currently selected topic.  Answer nil if	 no topic is currently selected."	| topic |	(topic := self selectedTopic) isNil ifTrue: [^ nil].	^ self tempOutlineFrom: topic treeTop.</body><body package="Arbor Help System Outline Help Core">topicTreeOutline	"Private - Answer a new outline which contains the currently selected topic tree.  Answer nil if	 no topic is currently selected."	| topic |	(topic := self selectedTopic) isNil ifTrue: [^ nil].	^ self tempOutlineFrom: topic.</body></methods><methods><class-id>VWHelp.AHSOutlineViewer</class-id> <category>interface configuration</category><body package="Arbor Help System Outline Help Core">closeHelpSubcanvas	"Private - Close the help subcanvas which is currently visible at the bottom on the window."	| uiBuilder |	uiBuilder := self builder.	(uiBuilder componentAt: #mainCanvas) newLayout: self layoutWithoutHelpPane.	(uiBuilder componentAt: #help) beInvisible.	uiBuilder window refresh</body><body package="Arbor Help System Outline Help Core">layoutWithHelpPane	"Private - Answer a LayoutFrame for a pane containing the help text subcanvas."	^ LayoutFrame		leftFraction: 0 offset: 0		topFraction: 0 offset: 0		rightFraction: 1 offset: 0		bottomFraction: 1 offset: -45.</body><body package="Arbor Help System Outline Help Core">layoutWithoutHelpPane	"Private - Answer a LayoutFrame for a pane which doesn't contain the help text subcanvas."	^ LayoutFrame		leftFraction: 0 offset: 0		topFraction: 0 offset: 0		rightFraction: 1 offset: 0		bottomFraction: 1 offset: 0.</body><body package="Arbor Help System Outline Help Core">openHelpSubcanvas	"Private - Open the help pane subcanvas.  This subcanvas displays real-time help information for	 the receiver."	| uiBuilder |	uiBuilder := self builder.	(uiBuilder componentAt: #mainCanvas) newLayout: self layoutWithHelpPane.	(uiBuilder componentAt: #help) beVisible.	uiBuilder window refresh.</body><body package="Arbor Help System Outline Help Core">relabelZoomMenuItem: aSymbol	"Private - Relabel the 'zoom' menu item to reflect the current zoom state."	(self outlinerWindowMenu value someMenuItemWithValue: #zoom)		rawLabel: aSymbol &lt;&lt; self messageCatalogID</body><body package="Arbor Help System Outline Help Core">topicListUnzoomedBoundaries	"Private - Answer the unzoomed boundaries for the topic list view when the topic text pane is unzoomed."	| oldBoundaries |	oldBoundaries := self listOutlineBrowser bounds.	^  Rectangle		left: oldBoundaries left		right: oldBoundaries right		top: self textSubCanvas container bounds top		bottom: self dragBar bounds center y rounded.</body><body package="Arbor Help System Outline Help Core">topicListUnzoomedLayout	"Private - Answer the LayoutFrame to be used for the topic list when the topic text pane is unzoomed."	| oldLayout dragBarLayout |	oldLayout := self listOutlineBrowser layout.	dragBarLayout := self dragBar layout.	^ LayoutFrame		leftFraction: oldLayout leftFraction 		offset: oldLayout leftOffset		rightFraction: oldLayout rightFraction 		offset: oldLayout rightOffset		topFraction: oldLayout topFraction 		offset: oldLayout topOffset		bottomFraction: dragBarLayout topFraction		offset: 0.</body><body package="Arbor Help System Outline Help Core">topicListZoomedBoundaries	"Private - Answer the zoomed boundaries for the topic list view when the topic text pane is zoomed."	| oldBoundaries |	oldBoundaries := self listOutlineBrowser bounds.	^ Rectangle		left: oldBoundaries left		right: oldBoundaries right		top: oldBoundaries top		bottom: oldBoundaries top.</body><body package="Arbor Help System Outline Help Core">topicListZoomedLayout	"Private - Answer the LayoutFrame to be used for the topic list when the topic text pane is zoomed."	| oldLayout |	oldLayout := self listOutlineBrowser layout.	^ LayoutFrame		leftFraction: oldLayout leftFraction 		offset: oldLayout leftOffset		rightFraction: oldLayout rightFraction 		offset: oldLayout rightOffset		topFraction: oldLayout topFraction 		offset: oldLayout topOffset		bottomFraction: oldLayout topFraction 		offset: oldLayout topOffset.</body><body package="Arbor Help System Outline Help Core">topicTextUnzoomedBoundaries	"Private - Answer the unzoomed boundaries for the topic text pane when the topic text pane is unzoomed."	| oldBoundaries |	oldBoundaries := self textSubCanvas bounds.	^ Rectangle		left: oldBoundaries left		right: oldBoundaries right		top: self listOutlineBrowser bounds bottom		bottom: oldBoundaries bottom.</body><body package="Arbor Help System Outline Help Core">topicTextUnzoomedLayout	"Private - Answer the LayoutFrame to be used for the topic text when the topic text pane is unzoomed."	| oldLayout dragBarLayout |	oldLayout := self textSubCanvas layout.	dragBarLayout := self dragBar layout.	^ LayoutFrame 		leftFraction: oldLayout leftFraction 		offset: oldLayout leftOffset		rightFraction: oldLayout rightFraction 		offset: oldLayout rightOffset		topFraction: dragBarLayout bottomFraction		offset: 0		bottomFraction: 1 		offset: 0.</body><body package="Arbor Help System Outline Help Core">topicTextZoomedBoundaries	"Private - Answer the zoomed boundaries for the topic text pane when the topic text pane is zoomed."	| oldBoundaries |	oldBoundaries := self textSubCanvas bounds.	^ Rectangle		left: oldBoundaries left		right: oldBoundaries right		top: self textSubCanvas container bounds top		bottom: oldBoundaries bottom.</body><body package="Arbor Help System Outline Help Core">topicTextZoomedLayout	"Private - Answer the LayoutFrame to be used for the topic text when the topic text pane is zoomed."	| oldLayout |	oldLayout := self textSubCanvas layout.	^ LayoutFrame		leftFraction: oldLayout leftFraction 		offset: oldLayout leftOffset		rightFraction: oldLayout rightFraction 		offset: oldLayout rightOffset		topFraction: oldLayout topFraction 		offset: oldLayout topOffset		bottomFraction: 1 		offset: oldLayout bottomOffset.</body><body package="Arbor Help System Outline Help Core">unzoomTopicText	"Private - Make the topic text area return to its normal size."	zoomed := false.	self 		relabelZoomMenuItem: #zoom;		fixOutlinerSizeForUnzoom.	self builder window label: self windowLabel</body><body package="Arbor Help System Outline Help Core">windowLabel	"Private - Answer the base component of the window label"	^ (self outline respondsTo: #outlineLabel)		ifTrue: [self outline outlineLabel asString]		ifFalse: ['Help Outline'].</body><body package="Arbor Help System Outline Help Core">zoomTopicText	"Private - Make the topic text area occupy the entire window."	zoomed := true.	self 		fixOutlinerSizeForZoom;		relabelZoomMenuItem: #unzoom.	self currentTopic isNil ifTrue: [^ self].	self builder window label: self windowLabel , ' - ' , self currentTopic data topic asString.</body></methods><methods><class-id>VWHelp.AHSOutlineViewer</class-id> <category>initialize-release</category><body package="Arbor Help System Outline Help Core">configureOutliner	"Private - Configure the model used to handle information manipulated by the receiver."	outliner := self outlinerModelClass new.	outliner 		displayBlock: [:obj | obj data topic displayString];		getParentBlock: [:obj | obj parent];		master: self.</body><body package="Arbor Help System Outline Help Core">initialize	super initialize.	zoomed := false.	history := AHSHistory new.	bookmarks := AHSPersistentDictionary new.	shouldUpdateHistoryStack := true.	searchEntriesFound := List new.	self configureOutliner.	toolbarTextEditor := self textEditorClass on: (#noTopicSelected &lt;&lt; self messageCatalogID).	infoHasChanged := false.	lastEntry := nil.</body><body package="Arbor Help System Outline Help Core">release	super release.	self toolbarTextEditor release.	AHSWHCProcessor helpEnabledModel retractInterestsFor: self.	AHSWHCProcessor balloonHelpEnabledModel retractInterestsFor: self.	self releaseForGemstone.</body></methods><methods><class-id>VWHelp.AHSOutlineViewer</class-id> <category>glossary - private</category><body package="Arbor Help System Outline Help Core">displayFullGlossary	"Private - Open a window or dialog capable of displaying the full glossary."	self builder window isModalDialog		ifTrue: [self fullGlossaryViewerClass fullGlossaryDialogOn: self]		ifFalse: [self fullGlossaryViewerClass fullGlossaryOn: self]</body><body package="Arbor Help System Outline Help Core">fullGlossaryViewerClass	"Private - Answer the class used for viewing all glossary entries."	^ AHSFullGlossaryViewer.</body><body package="Arbor Help System Outline Help Core">glossaryViewerClass	"Private - Answer the class used for viewing a single glossary entry."	^ AHSGlossaryViewer</body><body package="Arbor Help System Outline Help Core">graphicsViewerClass	"Private - Answer the class used for viewing all graphical entries."	^AHSHyperGraphicViewer</body><body package="Arbor Help System Outline Help Core">lockGlossary	"Private - Lock the glossary, answer true if sucessful.  We don't need to lock in runtime so answer true."	^ true</body><body package="Arbor Help System Outline Help Core">lockGraphics	"Private - Lock the graphics dictionary, answer true if sucessful.  For this class, always answer true because we	 are running in read-only mode."	^ true</body><body package="Arbor Help System Outline Help Core">openedFullGlossaryWindow	"Private - Answer the first available full glossary editor or viewer found.  Answer nil if no such window exists."	^ self openedWindow: self fullGlossaryViewerClass</body><body package="Arbor Help System Outline Help Core">openedGlossaryWindow	"Private - Answer the first available full glossary editor or viewer found.  Answer nil if no such window exists."	^ self openedWindow: self glossaryViewerClass</body><body package="Arbor Help System Outline Help Core">openedGraphicsWindow	"Private - Answer the first available full graphics editor or viewer found.  Answer nil if no such window exists."	^ self openedWindow: self graphicsViewerClass</body><body package="Arbor Help System Outline Help Core">openedHistoryWindow	"Private - Answer the first available history viewer found.  Answer nil if no such window exists."	^ScheduledControllers scheduledControllers		relate: [:sc || mdl |			mdl := sc model.			((mdl isKindOf: AHSOutlinerSubsetList)				and: [mdl mode = #history				and: [mdl parentWindow = self builder window]])					ifTrue: [sc view]]		ifNone: [nil]</body><body package="Arbor Help System Outline Help Core">openedWindow: anApplicationModelClass	"Private - Answer the first available window which has a class matching anApplicationModelClass."	| controller |	controller := ScheduledControllers scheduledControllers					detect: [:dep | (dep model isKindOf: anApplicationModelClass)]					ifNone: [nil].	^ controller notNil		ifTrue: [controller model]		ifFalse: [nil]</body></methods><methods><class-id>VWHelp.AHSOutlineViewer</class-id> <category>change messages</category><body package="Arbor Help System Outline Help Core">helpEnabledChanged	"Help has been enabled or disabled.  If appropriate, open or close the help subcanvas.  Note that we need to check the'	 open and close cases independently, i.e. a false answer to the question 'shouldOpenHelpCanvas' does not imply that	 we should close a help canvas."	self shouldOpenHelpSubcanvas ifTrue: [^self openHelpSubcanvas].	self shouldCloseHelpSubcanvas ifTrue: [self closeHelpSubcanvas].</body><body package="Arbor Help System Outline Help Core">selectionChanged	| entry entryData |	"If the last entry wasn't changed, release the lock on it."	(self isReadOnly not and: [self lastEntry notNil])		ifTrue: [self lastEntry data odbReleaseUnDirtyLock].	entry := outliner list selection.	entry isNil		ifTrue: 			[self text value: (#noTopicSelected &lt;&lt; self messageCatalogID) asString.			lastEntry := nil]		ifFalse: 			[entryData := entry value data.			(self outlineSource == #Versant and: [self isReadOnly not])				ifTrue: 					[entryData odbWriteLock						ifTrue: [self toolbarTextEditor editable]						ifFalse: 							[Dialog warn: 'Someone else is accessing that topic, so it is being read as read-only.'.							self toolbarTextEditor readOnly]].			entryData odbDeepRefresh.			self lastEntry: entry value.			self setTextValue: entryData text.			self history add: entryData.			self shouldUpdateHistoryStack ifTrue: [self history push: entryData].			zoomed ifTrue: 				[self builder window label: ((self outliner outline respondsTo: #outlineLabel)													ifTrue: [self outliner outline outlineLabel asString]													ifFalse: ['Help Outline'])												, ' - ' , self outliner list selection value data topic asString]].</body></methods><methods><class-id>VWHelp.AHSOutlineViewer</class-id> <category>private - configuration</category><body package="Arbor Help System Outline Help Core">configureEvents	"Private - Configure the events which only happen when the editor is in a read only state."	| editor |	editor := self toolbarTextEditor.	editor		expressInterestIn: #engageHyperlink		for: self		sendBack: #engageHyperlink:.	editor		expressInterestIn: #engageHyperGraphic		for: self		sendBack: #engageHyperGraphic:.	editor		expressInterestIn: #engageGlossary		for: self		sendBack: #engageGlossary:.</body><body package="Arbor Help System Outline Help Core">configureTextEditor	self isReadOnly ifTrue: [self toolbarTextEditor readOnly].</body><body package="Arbor Help System Outline Help Core">outlinerModelClass	"Private - Answer the ApplicationModel subclass used to managed the outline display."	^ AHSOutlineViewerModel</body><body package="Arbor Help System Outline Help Core">textEditorClass	"Private - Answer the ApplicationModel subclass used for text editing operations."	^ AHSToolbarHypertextEditor</body></methods><methods><class-id>VWHelp.AHSOutlineViewer</class-id> <category>outline</category><body package="Arbor Help System Outline Help Core">jumpToOutline: outlineName topic: topicName	"Private - Jump to the topic referenced by aHyperlink."	| topic |	Cursor wait showWhile: 		[(topic := self outline findTopicForOutline: outlineName name: topicName) isNil 		ifTrue: [^ Dialog warn: 'The linked topic could not be found']].	self checkForAutoAccept.	self outliner selectEntry: topic.	self toolbarTextEditor deselect</body><body package="Arbor Help System Outline Help Core">setTopicSelectionTo: aTopic	self builder window keyboardProcessor checkForAutoAccept.	self outliner selectEntry: aTopic.</body></methods><methods><class-id>VWHelp.AHSOutlineViewer</class-id> <category>interface opening</category><body package="Arbor Help System Outline Help Core">openAsDialog	| dlog |	dlog := SimpleDialog new.	self builder: dlog builder.	dlog preBuildBlock: [:mdl :bldr | self preBuildWith: bldr].	dlog postBuildBlock: [:mdl :bldr | self postBuildWith: bldr].	dlog postOpenBlock: [:mdl :bldr | self postOpenWith: bldr].	^ dlog 		openFor: self 		interface: #dialogSpec</body><body package="Arbor Help System Outline Help Core">postBuildWith: aBuilder 	super postBuildWith: aBuilder.	aBuilder window icon: AHSWHCProcessor reducedHelpWindowIcon.	zoomed := false.	self configureTextEditor.	outliner list selectionIndexHolder onChangeSend: #selectionChanged to: self.	self configureEvents.	self infoHasChanged: false.	(self builder window)		label: self outline outlineLabel;		application: self.	AHSPreferences expandOutlines ifTrue: [self expandAll].	(aBuilder aspectAt: #ahsFlag) onChangeSend: #helpEnabledChanged to: self.	AHSWHCProcessor helpEnabledModel onChangeSend: #helpEnabledChanged to: self.	AHSWHCProcessor balloonHelpEnabledModel onChangeSend: #helpEnabledChanged		to: self.	self helpEnabledChanged</body><body package="Arbor Help System Outline Help Core">postOpenWith: aBuilder	super postOpenWith: aBuilder.	"Make sure the selection is showing (esp. for modal windows)"	self outliner selectEntry: initialSelection.	self outliner list selectionIndex ~= 0 ifTrue: 		[(self outliner builder componentAt: #list) widget makeVisible: self outliner list selectionIndex.	  	self selectionChanged]</body></methods><methods><class-id>VWHelp.AHSOutlineViewer</class-id> <category>graphics</category><body package="Arbor Help System Outline Help Core">displayGraphicsWindow	"Private - Open the window which lets the user view all the graphics defined in the help system."	self graphicsViewerClass		openFrom: self 		modal: self builder window isModalDialog</body><body package="Arbor Help System Outline Help Core">engageHyperGraphic: aLink 	"Do the appropriate actions for engaging a hyperGraphic specified by aLink."	| graphics | 	graphics := self openedGraphicsWindow.	graphics isNil ifTrue: [self graphicsDictionary odbDeepRefresh].	self graphicsViewerClass		showGraphicLinkedTo: aLink 		onHelpOutliner: self.</body><body package="Arbor Help System Outline Help Core">firstAvailableHyperGraphic	"Answer the first available hyper graphic from the selected text."	^ self toolbarTextEditor firstAvailableHyperGraphic</body><body package="Arbor Help System Outline Help Core">graphicAt: aGraphicKey	^self outline		graphicAt: aGraphicKey asSymbol		ifAbsent: [			AHSHyperGraphicViewer notFoundGraphic: aGraphicKey.			nil]</body><body package="Arbor Help System Outline Help Core">graphicsKeys	"Answer a collection of keys corresponding to all available graphics."	^self outline graphicsKeys</body><body package="Arbor Help System Outline Help Core">showGraphics	"The user has requested the window which displays all available graphics."	| graphics | 	graphics := self openedGraphicsWindow.	graphics isNil		ifTrue: [self lockGraphics ifTrue: [self displayGraphicsWindow]]		ifFalse: [self restoreWindow: graphics]</body></methods><methods><class-id>VWHelp.AHSOutlineViewer</class-id> <category>text editor</category><body package="Arbor Help System Outline Help Core">deselect	self toolbarTextEditor deselect.</body></methods><methods><class-id>VWHelp.AHSOutlineViewer</class-id> <category>saving</category><body package="Arbor Help System Outline Help Core">reloadOutline: newOutline	"Reload the outline"	Cursor wait showWhile: [		| openedTopics selectedIndex newOpenedSet |		openedTopics := outliner openedSet collect: [:entry | entry data topic].		selectedIndex := outliner list selectionIndex.		"go through each openedTopic and find the corresponding tree node to reconstruct the openedSet"		newOpenedSet := IdentitySet new.		openedTopics do: [:topic | (newOutline detect: [:tree | (tree detect: [:node | node data topic = topic																					ifTrue: [newOpenedSet add: node.																							true]																					ifFalse: ["a true result will break out of the enumeration loop"																							false]]																ifNone: [nil]) notNil]												ifNone: [nil]) isNil													ifTrue: ["if this answers true, we didn't find a node!"															"should be impossible"															self error: 'couldn''t find node']].		outliner outline: newOutline; openedSet: newOpenedSet; updateDisplay.		outliner list selectionIndex: selectedIndex].</body></methods><methods><class-id>VWHelp.AHSOutlineViewer</class-id> <category>glossary</category><body package="Arbor Help System Outline Help Core">engageGlossary: aLink	"Display the glossary entry associated with aLink."	(self glossaryViewerClass		openOn: self glossaryDictionary		key: aLink linkObject)			ifTrue: [self infoHasChanged: true].</body><body package="Arbor Help System Outline Help Core">glossaryAt: aKey	^self outline glossaryAt: aKey asSymbol</body><body package="Arbor Help System Outline Help Core">showFullGlossary	"Display the glossary."	| glossaryWindow | 	(glossaryWindow := self openedFullGlossaryWindow) isNil		ifTrue: [self lockGlossary ifTrue: [self displayFullGlossary]]		ifFalse: [self restoreWindow: glossaryWindow]</body></methods><methods><class-id>VWHelp.AHSOutlineViewer</class-id> <category>drag drop</category><body package="Arbor Help System Outline Help Core">wantToDrag	^self isReadOnly not</body><body package="Arbor Help System Outline Help Core">wantToDrop	^self isReadOnly not</body></methods><methods><class-id>VWHelp.AHSOutlineViewer</class-id> <category>bookmarks - private</category><body package="Arbor Help System Outline Help Core">getNewBookmarkNameFromUser: defaultNameString	"Private - Answer a new bookmark entered by the user, or nil if the user cancels the operation."	| bookmark |	[true] whileTrue: 		[bookmark := (Dialog 							request: 'Bookmark name:' 							initialAnswer: defaultNameString) trimExteriorBlanks.		bookmark isEmpty ifTrue: [^ nil].		(self haveBookmark: bookmark) 			ifTrue: [Dialog warn: 'A bookmark named "', bookmark ,'" already exists.']			ifFalse: [^ bookmark]]</body></methods><methods><class-id>VWHelp.AHSOutlineViewer</class-id> <category>AHS Export adds</category><body package="Arbor Help System Outline Help Core">saveAsHTML	"Save the outline as a series of HTML files.  One file will contain an indented topic list,	 one file will contain any glossary entries, and several files containing help topic text,	 one help topic per file."	(AHSHTMLGenerator outline: outliner outline) generateHTML</body><body package="Arbor Help System Outline Help Core">saveAsHTMLHelp	"Save the outline as a series of HTML files, slightly modified to be suitable for creating HTMLHelp.  In addition, generate the project file and contents file so that the HTML Help Workshop (available for free from Microsoft - http://www.microsoft.com/workshop/author/htmlhelp/default.asp) can be used to compile the HTML files into a '.chm' file (compiled HTML)."	(AHSHTMLHelpGenerator outline: outliner outline) generateHTML</body></methods><methods><class-id>VWHelp.AHSOutlineViewer</class-id> <category>gemstone</category><body package="Arbor Help System Outline Help Core">releaseForGemstone	"Private - If GemStone is active, release the outline held by GemStone.  This releases the lock on the	outline when the screen closes instead of when it is saved to gemstone."	AHSStorageManager outlineSource ~= #GemStone ifTrue: [^ self].	AHSStorageManager removeLockForOutlineNamed: self outlineName.	self outline odbRelease.</body></methods><methods><class-id>VWHelp.AHSOutlineViewer</class-id> <category>printing - private</category><body package="Arbor Help System Outline Help Core">printableOutlineName	"Private - Answer the name of the outline in a form suitble for printing."	^ (outliner outline outlineLabel asText emphasizeAllWith: #(bold large))</body></methods><methods><class-id>VWHelp.AHSOutlineViewer</class-id> <category>history - private</category><body package="Arbor Help System Outline Help Core">setTopic: aTopic	"Private - Set the current topic to aTopic."	| obj |	obj := self outline findTopicNumber: aTopic uniqueID.	self selectEntryNoHistoryUpdate: obj</body></methods><methods><class-id>VWHelp.AHSOutlineViewer</class-id> <category>hyperlinks</category><body package="Arbor Help System Outline Help Core">engageHyperlink: aHyperlink 	"jump to a hyperlink destination specified by aHyperlink"	Cursor normal show.	(self shouldOpenNewOutlineViewerFor: aHyperlink) 		ifTrue: [self openOutlineViewerFor: aHyperlink]		ifFalse: [self jumpToTopicReferencedBy: aHyperlink]</body></methods><methods><class-id>VWHelp.AHSOutlineViewer</class-id> <category>Help Core mods</category><body package="Arbor Help System Outline Help Core">addExportItemsTo: aMenu	aMenu		aisAddSeparator;		addItemLabel: #'Save As Text File' &lt;&lt; self messageCatalogID value: #saveAsTextFile.</body></methods><methods><class-id>VWHelp.AHSOutlineViewer class</class-id> <category>interface opening</category><body package="Arbor Help System Outline Help Core">open	^ (self onOutline: AHSOutline new) open</body><body package="Arbor Help System Outline Help Core">openAsDialog	^ (self onOutline: AHSOutline new) openAsDialog</body><body package="Arbor Help System Outline Help Core">openOutlineNamed: outlineName	^ self 		openOutlineNamed: outlineName		topicNumber: nil</body><body package="Arbor Help System Outline Help Core">openOutlineNamed: outlineName modal: aBoolean	^ self 		openOutlineNamed: outlineName		topicNumber: nil		modal: aBoolean</body><body package="Arbor Help System Outline Help Core">openOutlineNamed: outlineName modal: modal source: source	^ self 		openOutlineNamed: outlineName		topicNumber: nil		modal: modal		raiseExisting: modal not		readOnly: self allowEditing not		source: source</body><body package="Arbor Help System Outline Help Core">openOutlineNamed: outlineName source: source	^ self 		openOutlineNamed: outlineName		modal: false		source: source</body><body package="Arbor Help System Outline Help Core">openOutlineNamed: outlineName topicNumber: topicNumberOrNil	^ self 		openOutlineNamed: outlineName		topicNumber: topicNumberOrNil		modal: false</body><body package="Arbor Help System Outline Help Core">openOutlineNamed: outlineName topicNumber: topicNumberOrNil modal: modal	^ self 		openOutlineNamed: outlineName		topicNumber: topicNumberOrNil		modal: modal		raiseExisting: modal not</body><body package="Arbor Help System Outline Help Core">openOutlineNamed: outlineName topicNumber: topicNumberOrNil modal: modal raiseExisting: raiseExisting	^ self 		openOutlineNamed: outlineName		topicNumber: topicNumberOrNil		modal: modal		raiseExisting: raiseExisting		readOnly: AHSStorageManager allowEditing not</body><body package="Arbor Help System Outline Help Core">openOutlineNamed: outlineName topicNumber: topicNumberOrNil modal: modal raiseExisting: raiseExisting readOnly: readOnly	^ self 		openOutlineNamed: outlineName		topicNumber: topicNumberOrNil		modal: modal		raiseExisting: raiseExisting		readOnly: readOnly		source: AHSStorageManager outlineSource</body><body package="Arbor Help System Outline Help Core">openOutlineNamed: outlineName topicNumber: topicNumberOrNil modal: modal raiseExisting: raiseExisting readOnly: readOnly source: source	| anOutliner outline needToOpen obj |		"Only raise an existing window if the outline has the same name, the same read only status, and the		same source"	(modal not and: [raiseExisting])		ifTrue: [anOutliner := self								findOpenOutlinerNamed: outlineName 								readOnly: readOnly 								source: source].	anOutliner isNil		ifTrue: 			[needToOpen := true.			outline := AHSStorageManager 						getOutlineNamed: outlineName 						readOnly: readOnly 						source: source.			outline isNil ifTrue: [				"The storage manager should have posted a dialog already if there was a problem."				^nil].			anOutliner := self 							onOutline: outline 							source: source]		ifFalse: 			[needToOpen := false.			anOutliner restoreWindow: anOutliner].	"Set selection to the topic if possible"	topicNumberOrNil notNil ifTrue: 		[obj := anOutliner outline findTopicNumber: topicNumberOrNil.		obj isNil			ifTrue: [Dialog warn: 'Could not find the topic']			ifFalse: [anOutliner initialSelection: obj]].	needToOpen ifTrue: 		[modal			ifTrue: [anOutliner openAsDialog]			ifFalse: [anOutliner open]].	^anOutliner</body></methods><methods><class-id>VWHelp.AHSOutlineViewer class</class-id> <category>help info (AHS)</category><body package="Arbor Help System Outline Help Core">ahsHelpData	^(AHSHelpClassData languages: #(#English) widgetData: ((AHSPersistentDictionary new)	 add: (#underline -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Add/Remove underline text style' runs: (RunArray runs: #(11 9 11) values: #(nil #underline nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#large -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Add/Remove Large text style' runs: (RunArray runs: #(27) values: #(nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#textSubCanvas -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Use these buttons to operate on the text below' runs: (RunArray runs: #(46) values: #(nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#help -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: #(nil) outlineLinks: #(nil))); yourself));	 add: (#undo -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Undo last text edit' runs: (RunArray runs: #(19) values: #(nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#cut -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Cut selected text to clipboard.' runs: (RunArray runs: #(31) values: #(nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#paste -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Paste contents of clipboard' runs: (RunArray runs: #(27) values: #(nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#serif -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Add/Remove Serif text style' runs: (RunArray runs: #(27) values: #(nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#bold -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Add/Remove bold style.' runs: (RunArray runs: #(11 4 7) values: #(nil #bold nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#menuBar -&gt; ((AHSPersistentDictionary new)	 add: (#'File/Print/Selected Topic Only' -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Print the selected topic on the default printer.' runs: (RunArray runs: #(48) values: #(nil))); yourself) outlineLinks: nil));	 add: (#'View/Contract Text' -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Contract the text part of this window so the outline topics are visible' runs: (RunArray runs: #(71) values: #(nil))); yourself) outlineLinks: nil));	 add: (#'Bookmarks/Delete...' -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Delete a bookmark' runs: (RunArray runs: #(17) values: #(nil))); yourself) outlineLinks: #(nil)));	 add: (#'Navigate/Search...' -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Open a search dialog that allows you the search the outline topics and text' runs: (RunArray runs: #(75) values: #(nil))); yourself) outlineLinks: nil));	 add: (#'Help/Use Widget Help' -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Show help information in an area at the bottom of the window' runs: (RunArray runs: #(60) values: #(nil))); yourself) outlineLinks: nil));	 add: (#'Navigate/History...' -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Open a window that shows the linear history of which topics you''ve visited, and allows you to go to any of them' runs: (RunArray runs: #(111) values: #(nil))); yourself) outlineLinks: nil));	 add: (#'File/Create HTMLHelp Project...' -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Create HTMLHelp project and support files, specially formatted ready to be compiled by the HTMLHelp compiler.  Visit http://www.microsoft.com/workshop/author/htmlhelp/ for more info.' runs: (RunArray runs: #(117 50 15) values: ((Array new: 3) at: 2 put: ((Array new: 2) at: 1 put: (#color -&gt; ColorValue blue); at: 2 put: #underline; yourself); yourself))); yourself) outlineLinks: nil));	 add: (#'File/Open from File...' -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Open an outline from a file' runs: (RunArray runs: #(27) values: #(nil))); yourself) outlineLinks: nil));	 add: (#'View/Contract All Topics' -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Contract all the topics in this outline entirely' runs: (RunArray runs: #(48) values: #(nil))); yourself) outlineLinks: nil));	 add: (#'File/Exit' -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Close this window' runs: (RunArray runs: #(17) values: #(nil))); yourself) outlineLinks: nil));	 add: (#'View/Graphics...' -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Open a window allowing you to browse the graphics that are part of this outline' runs: (RunArray runs: #(79) values: #(nil))); yourself) outlineLinks: nil));	 add: (#'View/Expand Text' -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Expand the text part of this window to fill entire window' runs: (RunArray runs: #(57) values: #(nil))); yourself) outlineLinks: nil));	 add: (#'Navigate/Repeat Last Search' -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Repeat the last search operation' runs: (RunArray runs: #(32) values: #(nil))); yourself) outlineLinks: nil));	 add: (#'File/Print/Full Outline' -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Print the entire outline on the default printer' runs: (RunArray runs: #(47) values: #(nil))); yourself) outlineLinks: nil));	 add: (#'File/Print' -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Select the type of printing desired.' runs: (RunArray runs: #(36) values: #(nil))); yourself) outlineLinks: nil));	 add: (#'View/Expand All Topics' -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Expand all topics in this outline entirely' runs: (RunArray runs: #(42) values: #(nil))); yourself) outlineLinks: nil));	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Highlight a menu item for specific help.' runs: (RunArray runs: #(40) values: #(nil))); yourself) outlineLinks: #(nil)));	 add: (#'Help/Use Balloon Help (F3)' -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Show help information in a pop-up "balloon" window' runs: (RunArray runs: #(50) values: #(nil))); yourself) outlineLinks: nil));	 add: (#'File/Print/Selected Topic and Children' -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Print the selected topic and all of its children on the default printer.' runs: (RunArray runs: #(72) values: #(nil))); yourself) outlineLinks: nil));	 add: (#'View/Glossary...' -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Open a window showing all glossary entries' runs: (RunArray runs: #(42) values: #(nil))); yourself) outlineLinks: nil));	 add: (#'Bookmarks/Add...' -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Add a new bookmark for the current page' runs: (RunArray runs: #(39) values: #(nil))); yourself) outlineLinks: #(nil)));	 add: (#'File/Create #{Smalltalk.Text} value File...' -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Create a text file from this outline' runs: (RunArray runs: #(36) values: #(nil))); yourself) outlineLinks: nil));	 add: (#'Navigate/Find Next Within Text' -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Find the next occurrance of the selected text within the currently open topic' runs: (RunArray runs: #(77) values: #(nil))); yourself) outlineLinks: nil));	 add: (#'Navigate/Forward' -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Go forward to the next topic that you had already visited' runs: (RunArray runs: #(57) values: #(nil))); yourself) outlineLinks: nil));	 add: (#'Navigate/Back' -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Go back to the last topic' runs: (RunArray runs: #(25) values: #(nil))); yourself) outlineLinks: nil));	 add: (#'File/Create HTML Files...' -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Create HTML files from this outline.' runs: (RunArray runs: #(36) values: #(nil))); yourself) outlineLinks: nil)); yourself));	 add: (#remove -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Remove all links (if any) from the specified text.' runs: (RunArray runs: #(50) values: #(nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#hypertext -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Create a hypertext link from selected text' runs: (RunArray runs: #(42) values: #(nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#color -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Change color' runs: (RunArray runs: #(7 5) values: ((Array new: 2) at: 2 put: (#color -&gt; ColorValue darkMagenta); yourself))); yourself) outlineLinks: #(nil))); yourself));	 add: (#close -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Close window' runs: (RunArray runs: #(12) values: #(nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#glossary -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Create a glossary from selected text.' runs: (RunArray runs: #(37) values: #(nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#italic -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Add/Remove italic text style' runs: (RunArray runs: #(11 6 11) values: #(nil #italic nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#hypergraphic -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Create a hypergraphic link from selected text' runs: (RunArray runs: #(45) values: #(nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#listOutlineBrowser -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: #(nil) outlineLinks: #(nil))); yourself));	 add: (#mainCanvas -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: #(nil) outlineLinks: #(nil))); yourself));	 add: (#text -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Text associated with the selected topic' runs: (RunArray runs: #(39) values: #(nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#copy -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Copy selected text to clipboard.' runs: (RunArray runs: #(32) values: #(nil))); yourself) outlineLinks: #(nil))); yourself)); yourself))</body><body package="Arbor Help System Outline Help Core">arborHelpEnabled	"Answer true if this application utilizes Arbor Help."	^ true</body></methods><methods><class-id>VWHelp.AHSOutlineViewer class</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">messageCatalogID	^#arborHelpSystem</body></methods><methods><class-id>VWHelp.AHSOutlineViewer class</class-id> <category>queries</category><body package="Arbor Help System Outline Help Core">findOpenOutlinerNamed: outlineName readOnly: readOnly source: source	| ctrl |	ctrl := ScheduledControllers scheduledControllers 			detect: 				[:c | 				(c view model isKindOf: self) 					and: [outlineName asUppercase = c view model outlineName asString asUppercase						and: [readOnly = c view model isReadOnly							and: [source = c view model outlineSource]]]]			ifNone: [nil].	^ ctrl notNil		ifTrue: [ctrl view model]		ifFalse: [nil]</body></methods><methods><class-id>VWHelp.AHSOutlineViewer class</class-id> <category>instance creation</category><body package="Arbor Help System Outline Help Core">new	"Answer either a readonly class or an editing version of the class based on whether read only	 has been specified and if an editing class exists in the image."	| editingVersion result |	editingVersion := self classForEditing.	result := (self allowEditing and: [editingVersion notNil])				ifTrue: [editingVersion basicNew]				ifFalse: [AHSPreferences outlineViewerClass basicNew].	^ result initialize</body><body package="Arbor Help System Outline Help Core">onOutline: anOutline	"anOutline is an OrderedCollection of Trees"	"use only when the source is nil, meaning a newly created outline"	^ self		onOutline: anOutline 		source: nil</body><body package="Arbor Help System Outline Help Core">onOutline: anOutline source: aSymbol 	"anOutline is an OrderedCollection of Trees"	| aHelpOutliner |	aHelpOutliner := self new.	aHelpOutliner outlineSource: aSymbol.	aHelpOutliner outliner outline: anOutline.	aHelpOutliner loadBookmarksFromFile.	anOutline isEmpty ifFalse: [aHelpOutliner initialSelection: anOutline first].	^ aHelpOutliner</body></methods><methods><class-id>VWHelp.AHSOutlineViewer class</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">allowEditing	"Private - Answer true if editing is currently allowed."	^AHSStorageManager allowEditing</body><body package="Arbor Help System Outline Help Core">classForEditing	"Private - Answer the class to use for editing an outline, or nil if that class isn't installed."	^#{AHSOutlineEditor} valueOrDo: [nil]</body></methods><methods><class-id>VWHelp.AHSOutlineViewer class</class-id> <category>examples</category><body package="Arbor Help System Outline Help Core">openOnClasses	"self openOnClasses"	|recursionBlock root|	recursionBlock := [:parentTree :cls |		|tree|		parentTree addChild: (tree := AHSTree data: (AHSHelpOutlineEntry new topic: cls name; text: cls comment)).		(cls subclasses asSortedCollection: [:a :b | a name &lt;= b name])				do: [:sc | recursionBlock value: tree value: sc]].	root := AHSTree new.	Cursor wait showWhile: [		recursionBlock value: root value: Collection].	(self onOutline: ((AHSOutline withAll: root children) name: 'Class Comments')) open window label: 'Class Comments'</body></methods><methods><class-id>VWHelp.AHSHelpOutlineEntry</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">text	^text</body><body package="Arbor Help System Outline Help Core">text: aValue	text := aValue.	self odbDirty</body><body package="Arbor Help System Outline Help Core">topic	^topic</body><body package="Arbor Help System Outline Help Core">topic: aValue	topic := aValue.	self odbDirty</body><body package="Arbor Help System Outline Help Core">uniqueID	^uniqueID</body></methods><methods><class-id>VWHelp.AHSHelpOutlineEntry</class-id> <category>protected</category><body package="Arbor Help System Outline Help Core">uniqueID: anInteger	"Assign my id, unique within the outline I belong to.	Don't call this unless you are sure it's really unique!"	uniqueID := anInteger</body></methods><methods><class-id>VWHelp.AHSHelpOutlineEntry</class-id> <category>printing</category><body package="Arbor Help System Outline Help Core">printOn: aStream	aStream nextPutAll: topic displayString</body></methods><methods><class-id>VWHelp.AHSHelpOutlineEntry</class-id> <category>initialize-release</category><body package="Arbor Help System Outline Help Core">initialize	text := String new.	topic := String new.	self odbDirty</body></methods><methods><class-id>VWHelp.AHSHelpOutlineEntry</class-id> <category>copying</category><body package="Arbor Help System Outline Help Core">postCopy	super postCopy.	topic := topic asString copy.	text := AHSUtils deepCopyOfText: text.</body></methods><methods><class-id>VWHelp.AHSHelpOutlineEntry</class-id> <category>odb support</category><body package="Arbor Help System Outline Help Core">odbDeepRefresh	self odbRefreshIfNotDirty.	self text odbDeepRefresh.</body></methods><methods><class-id>VWHelp.AHSHelpOutlineEntry</class-id> <category>testing</category><body package="Arbor Help System Outline Help Core">containsFilePointers	^false</body></methods><methods><class-id>VWHelp.AHSHelpOutlineEntry</class-id> <category>displaying</category><body package="Arbor Help System Outline Help Core">asText	^self topic displayString</body></methods><methods><class-id>VWHelp.AHSHelpOutlineEntry class</class-id> <category>class release</category><body package="Arbor Help System Outline Help Core">cleanUp	"Private - Clean up the class so that it doesn't reference extraneous objects.  Typically this method	 might be called when the class is being unloaded in an ENVY environment."	self flushClip.</body></methods><methods><class-id>VWHelp.AHSHelpOutlineEntry class</class-id> <category>BOSS conversion</category><body package="Arbor Help System Outline Help Core">binaryRepresentationVersion	^'AHS 2.5'</body></methods><methods><class-id>VWHelp.AHSHelpOutlineEntry class</class-id> <category>class accessing</category><body package="Arbor Help System Outline Help Core">flushClip	"self flushClip"	clipboard := nil</body><body package="Arbor Help System Outline Help Core">getClip	"Answer the last HelpOutlineEntry instance putClipped"	^clipboard</body><body package="Arbor Help System Outline Help Core">putClip: aHelpOutlineEntry	clipboard := aHelpOutlineEntry</body></methods><methods><class-id>VWHelp.AHSHelpOutlineEntry class</class-id> <category>instance creation</category><body package="Arbor Help System Outline Help Core">new	^super new initialize</body></methods><methods><class-id>VWHelp.AHSGraphicView</class-id> <category>displaying</category><body package="Arbor Help System Outline Help Core">displayOn: aGraphicsContext	model notNil ifTrue: [model displayOn: aGraphicsContext]</body><body package="Arbor Help System Outline Help Core">preferredBounds	^model preferredBounds</body></methods><methods><class-id>VWHelp.AHSHistory</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">back	"Answer the topic that is before topOfStack, or nil if there isn't one."	self topOfStack &lt;= 1		ifTrue: [^nil]		ifFalse: [self topOfStack: self topOfStack - 1.				^self stack at: self topOfStack].</body><body package="Arbor Help System Outline Help Core">first	"Answer the first topic visited, which is the first element of the linear history."	^self linearHistory first.</body><body package="Arbor Help System Outline Help Core">forward	"Answer the topic that is after topOfStack, or nil if there isn't one."	self stack size == self topOfStack		ifTrue: [^nil]		ifFalse: [self topOfStack: self topOfStack + 1.				^self stack at: self topOfStack].</body><body package="Arbor Help System Outline Help Core">linearHistory	^linearHistory</body><body package="Arbor Help System Outline Help Core">previous	"Answer the topic visited previous to the current topic.  Note that it retrieves the topic from the linear history."	^self linearHistory size &gt; 1 ifTrue: [self linearHistory at: self linearHistory size - 1] ifFalse: [^nil].</body><body package="Arbor Help System Outline Help Core">stack	^stack</body><body package="Arbor Help System Outline Help Core">stack: aList	stack := aList</body><body package="Arbor Help System Outline Help Core">topOfStack	^topOfStack</body><body package="Arbor Help System Outline Help Core">topOfStack: anInteger	^topOfStack := anInteger</body></methods><methods><class-id>VWHelp.AHSHistory</class-id> <category>removing</category><body package="Arbor Help System Outline Help Core">clear	"Clear out everything."	self linearHistory removeFrom: 1 to: self linearHistory size.	self stack: OrderedCollection new.	self topOfStack: 0.</body><body package="Arbor Help System Outline Help Core">pop	"Answer the element pointed to by topOfStack, then decrement topOfStack.  	 Answer nil if topOfStack is 0 (no element in the stack)."	| topElement |	self topOfStack isZero ifTrue: [^nil].	topElement := self stack at: self topOfStack.	self topOfStack: self topOfStack - 1.	^topElement</body></methods><methods><class-id>VWHelp.AHSHistory</class-id> <category>testing</category><body package="Arbor Help System Outline Help Core">isEmpty	^self linearHistory isEmpty</body></methods><methods><class-id>VWHelp.AHSHistory</class-id> <category>adding</category><body package="Arbor Help System Outline Help Core">add: aTopic	"Add aTopic to the end of the linear history, avoiding consecutive duplications."	| lastEntry |	lastEntry := ''.	self linearHistory isEmpty ifFalse: [lastEntry := self linearHistory last].	lastEntry ~= aTopic ifTrue: [self linearHistory add: aTopic]</body><body package="Arbor Help System Outline Help Core">push: anEntry	"Stick anEntry onto the end of the stack which is pointed to by topOfStack, avoiding any consecutive duplications.  If there are any elements above topOfStack, remove them first."	| stackSize lastEntry |	lastEntry := ''.	self topOfStack &gt; 0 ifTrue: [lastEntry := self stack at: self topOfStack].	lastEntry ~= anEntry 		ifTrue: [	stackSize := self stack size.				self topOfStack &lt; stackSize					ifTrue: [self stack removeLast: (stackSize - self topOfStack)].				self stack add: anEntry.				self topOfStack: self topOfStack + 1]</body></methods><methods><class-id>VWHelp.AHSHistory</class-id> <category>initialize-release</category><body package="Arbor Help System Outline Help Core">initialize	stack := OrderedCollection new.	topOfStack := 0.	linearHistory := List new.</body></methods><methods><class-id>VWHelp.AHSHistory class</class-id> <category>instance creation</category><body package="Arbor Help System Outline Help Core">new	^super new initialize.</body></methods><methods><class-id>VWHelp.AHSOutline</class-id> <category>copying</category><body package="Arbor Help System Outline Help Core">postCopy	self postCopyWithoutForest.	forest := forest collect: [:tree |				tree copy]</body><body package="Arbor Help System Outline Help Core">postCopyWithoutForest	name := name copy.	outlineLabel := outlineLabel copy.	graphicsDictionary := AHSPersistentDictionary withAll:							 (graphicsDictionary associations collect: [:assn |								assn key -&gt; assn value copy]).	glossaryDictionary := AHSPersistentDictionary withAll:							 (glossaryDictionary associations collect: [:assn |								assn key -&gt; (AHSUtils deepCopyOfText: assn value)]).</body></methods><methods><class-id>VWHelp.AHSOutline</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">fileFormat	^ fileFormat isNil 		ifTrue: [#fastAccess] 		ifFalse:[fileFormat]</body><body package="Arbor Help System Outline Help Core">fileFormat: aSymbol	^ fileFormat := aSymbol</body><body package="Arbor Help System Outline Help Core">forest	^forest</body><body package="Arbor Help System Outline Help Core">forest: anAHSPersistentOrderedCollection	forest := anAHSPersistentOrderedCollection.	self odbDirty</body><body package="Arbor Help System Outline Help Core">idCollection	"Answer the collection of IDs which are currently in use."	| aSet |	aSet := Set new.	self topNodesDo: [:aTree | aTree data uniqueID notNil ifTrue: [aSet add: aTree data uniqueID]].	^ aSet.</body><body package="Arbor Help System Outline Help Core">memoryFormat	"Answer #fastAccess or #memoryFriendly.	Note that this is independent of the fileFormat		(except if fileFormat == #fastAccess, then the memoryFormat must be #fastAccess also)"	^self containsFilePointers		ifTrue: [#memoryFriendly]		ifFalse: [#fastAccess]</body><body package="Arbor Help System Outline Help Core">name	^name</body><body package="Arbor Help System Outline Help Core">name: aValue	self odbDirty.	name := aValue</body><body package="Arbor Help System Outline Help Core">nextID	"Answer the next ID for AHSHelpOutlineEntries"	self odbDirty.	^nextID := nextID + 1</body><body package="Arbor Help System Outline Help Core">outlineLabel	^outlineLabel</body><body package="Arbor Help System Outline Help Core">outlineLabel: aValue	self odbDirty.	outlineLabel := aValue</body></methods><methods><class-id>VWHelp.AHSOutline</class-id> <category>backward compatibility-collection protocol</category><body package="Arbor Help System Outline Help Core">add: newObject after: oldObject	self forest odbDirty.	^self forest add: newObject after: oldObject</body><body package="Arbor Help System Outline Help Core">addAll: aCollection	self forest odbDirty.	^self forest addAll: aCollection</body><body package="Arbor Help System Outline Help Core">addFirst: newObject 	"Add newObject to the beginning of the receiver.  Answer newObject."	self forest odbDirty.	^self forest addFirst: newObject.</body><body package="Arbor Help System Outline Help Core">addLast: newObject 	"Add newObject to the end of the receiver.  Answer newObject."	self forest odbDirty.	^ self forest addLast: newObject.</body><body package="Arbor Help System Outline Help Core">at: anInteger	^self forest at: anInteger</body><body package="Arbor Help System Outline Help Core">at: anInteger put: anObject 	self forest odbDirty.	^self forest at: anInteger put: anObject</body><body package="Arbor Help System Outline Help Core">detect: aBlock ifNone: exceptionBlock 	^ self forest 		detect: aBlock 		ifNone: exceptionBlock</body><body package="Arbor Help System Outline Help Core">do: aBlock	^ self forest do: aBlock</body><body package="Arbor Help System Outline Help Core">first	^ self forest first</body><body package="Arbor Help System Outline Help Core">includes: anObject	^self forest includes: anObject</body><body package="Arbor Help System Outline Help Core">indexOf: anElement 	"Answer the index of the first occurrence of	anElement within the receiver.  If the receiver does	not contain anElement, answer 0."	^self forest indexOf: anElement</body><body package="Arbor Help System Outline Help Core">isEmpty	^self forest isEmpty</body><body package="Arbor Help System Outline Help Core">remove: oldObject	self forest odbDirty.	^self forest remove: oldObject</body><body package="Arbor Help System Outline Help Core">remove: oldObject ifAbsent: anExceptionBlock	self forest odbDirty.	^self forest remove: oldObject ifAbsent: anExceptionBlock</body><body package="Arbor Help System Outline Help Core">size	^self forest size</body></methods><methods><class-id>VWHelp.AHSOutline</class-id> <category>accessing-glossary</category><body package="Arbor Help System Outline Help Core">glossaryAt: aSymbol	^self glossaryDictionary at: aSymbol</body><body package="Arbor Help System Outline Help Core">glossaryAt: aSymbol ifAbsent: aBlock	"Answer the glossary entry found in the dictionary at the key location indicated by aSymbol. 	 If not found, answer the result of evaluating aBlock."	^ self glossaryDictionary		at: aSymbol		ifAbsent: [aBlock value].</body><body package="Arbor Help System Outline Help Core">glossaryDictionary	^glossaryDictionary</body><body package="Arbor Help System Outline Help Core">glossaryDictionary: aDictionary	^glossaryDictionary := aDictionary</body></methods><methods><class-id>VWHelp.AHSOutline</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">graphicsDictionary	^graphicsDictionary</body><body package="Arbor Help System Outline Help Core">graphicsDictionary: aDictionary	^graphicsDictionary := aDictionary</body><body package="Arbor Help System Outline Help Core">nextID: anInteger	nextID := anInteger</body></methods><methods><class-id>VWHelp.AHSOutline</class-id> <category>fileIn/Out</category><body package="Arbor Help System Outline Help Core">fixupWith: aString	"Fixup the receiver.  This object must have been created during a BOSS read, and needs to have	 some items modified which weren't able to be modified during BOSS processing."	self forest do: 		[:tree |		tree do: 			[:node |			(node data isKindOf: AHSMemoryFriendlyHelpOutlineEntry) ifTrue: [node data filename: aString asFilename].			node data uniqueID isNil ifTrue: [node data uniqueID: self nextID]]].	self name: aString</body><body package="Arbor Help System Outline Help Core">representBinaryOn: binWriter	" Represent an OrderedCollection by its contents 	(elements). Added support for my instance variables"	| tmp |	tmp := Array new: self forest size + 7.	tmp at: 1 put: self class binaryRepresentationVersion asSymbol;		at: 2 put: self name;		at: 3 put: self outlineLabel;		at: 4 put: nextID;		at: 5 put: fileFormat;		at: 6 put: glossaryDictionary;		at: 7 put: graphicsDictionary.	8 to: tmp size do: [:i |		tmp at: i put: (self forest at: i - 7)].	^MessageSend		receiver: self class		selector: #unboss:		argument: tmp</body></methods><methods><class-id>VWHelp.AHSOutline</class-id> <category>testing</category><body package="Arbor Help System Outline Help Core">containsFilePointers	"Answer whether there are any outline entries that contain file pointers"	^ self graphicsDictionaryHasPointers or: [self treeHasPointers]</body><body package="Arbor Help System Outline Help Core">graphicsDictionaryHasPointers	"Private - Answer true if the graphics dictionary has pointers."	^ (self graphicsDictionary 		detect: [:val | val isKindOf: Integer]		ifNone: [nil]) notNil</body><body package="Arbor Help System Outline Help Core">hasGlossaryEntries	"Answer true if the glossary contains any entries."	^ self glossaryDictionary isEmpty not</body><body package="Arbor Help System Outline Help Core">isMemoryFriendly	^ self memoryFormat = #memoryFriendly</body><body package="Arbor Help System Outline Help Core">treeHasPointers	"Private - Answer true if any element of the tree contains pointers."	^ (self 		detect: 			[:tree |			(tree 				detect: [:node | node data containsFilePointers]				ifNone: [nil]) notNil]		ifNone: [nil]) notNil</body></methods><methods><class-id>VWHelp.AHSOutline</class-id> <category>searching</category><body package="Arbor Help System Outline Help Core">findTopic: topicName	"Find the topic in the outline that matches topicName (case insensitive) and answer the Tree node"	| obj |	topicName isNil ifTrue: [^nil].	self forest		detect: 			[:eachTree |			obj := eachTree					detect: [:node | node data topic asString asUppercase = topicName asString asUppercase]					ifNone: [nil].			obj notNil]		ifNone: [].	^ obj</body><body package="Arbor Help System Outline Help Core">findTopicForOutline: outlineName name: topicName	"Find the topic in the outline and answer the Tree node, or nil if not found"	"Modified to build the xmlOutline before searching for a topic. The test to	see if the xmlOutline is already built is done in the #buildXmlOutlineFrom:	method"	| obj anEntry |	obj := nil.	self forest		detect: 			[:eachTree |			anEntry := eachTree data.			((anEntry isKindOf:VWHelp.OutlineEntry) and: [anEntry proxy notNil])			ifTrue: [(outlineName = (anEntry proxy fileID asLogicalFileSpecification tail))					ifTrue: [self buildXmlOutlineFrom: eachTree]].			(outlineName = anEntry outlineFile)			ifTrue: [ 				obj := eachTree 					detect: [:node |							node data uniqueID = topicName]							ifNone: [nil]].				obj notNil]		ifNone: [].	^obj</body><body package="Arbor Help System Outline Help Core">findTopicNumber: topicNumber	"Find the topic in the outline that has the topic number topicNumber	 and answer the Tree node, or nil if not found"	| obj |	self forest		detect: 			[:eachTree |			obj := eachTree					detect: [:node | node data uniqueID = topicNumber]					ifNone: [nil].			obj notNil]		ifNone: [].	^obj</body></methods><methods><class-id>VWHelp.AHSOutline</class-id> <category>accessing-graphics</category><body package="Arbor Help System Outline Help Core">graphicAt: aSymbol	^self graphicAt: aSymbol ifAbsent: [KeyedCollection keyNotFoundSignal raise]</body><body package="Arbor Help System Outline Help Core">graphicAt: aSymbol ifAbsent: aBlock	"The Image may be in the dictionary, or it may still be on disk"	|graphic|	graphic := self graphicsDictionary at: aSymbol ifAbsent: [^aBlock value].	(AHSMemoryFriendlyHelpOutlineEntry isPositionPersistent: graphic)		ifTrue: [graphic := AHSMemoryFriendlyHelpOutlineEntry positionAsTransient: graphic.				self graphicsDictionary at: aSymbol put: graphic].	graphic isInteger		ifTrue: [ "Image is on disk"			Cursor read showWhile: [|bos|				bos := #{BinaryObjectStorage} value onOldNoScan: self name asFilename readStream.				[bos position: graphic.				graphic := bos next]					ensure: [bos close]]].	^graphic</body><body package="Arbor Help System Outline Help Core">graphicsKeys	^self graphicsDictionary keys asSortedCollection</body></methods><methods><class-id>VWHelp.AHSOutline</class-id> <category>enumerating</category><body package="Arbor Help System Outline Help Core">nodesWithoutIDsDo: aBlock	"For each node in the outline which hasn't been assigned an id, evaluate aBlock passing the	node as the argument."	self topNodesDo: [:aTree | aTree data uniqueID isNil ifTrue: [aBlock value: aTree]]</body><body package="Arbor Help System Outline Help Core">nodesWithTextDo: aBlock	"Private - For each node whose data contains text, evaluate the block with the node as the parameter."	Cursor wait showWhile: [self topNodesDo: [:aTree | aTree dataHasText ifTrue: [aBlock value: aTree]]]</body><body package="Arbor Help System Outline Help Core">topNodesDo: aBlock	"Iterate over all top nodes managed by the receiver, evaluating aBlock with the node as the argument."	self forest do: [:rootTree | rootTree do: [:aTree | aBlock value: aTree]]</body></methods><methods><class-id>VWHelp.AHSOutline</class-id> <category>odb support</category><body package="Arbor Help System Outline Help Core">odbDeepRefresh	"Refresh the entire outline"	self odbRefreshIfNotDirty.	self do: [:aRoot |			aRoot odbDeepRefresh].</body></methods><methods><class-id>VWHelp.AHSOutline</class-id> <category>AHS Export adds-accessing-glossary</category><body package="Arbor Help System Outline Help Core">sortedGlossary	"Answer an ordered collection of glossary entries (associations) sorted by the glossary key."	| result |	result := SortedCollection sortBlock: [:a :b | a key &lt;= b key].	self glossaryDictionary associationsDo: [:assoc | result add: assoc].	^ result asOrderedCollection</body></methods><methods><class-id>VWHelp.AHSOutline</class-id> <category>references</category><body package="Arbor Help System Outline Help Core">linksLike: aLink do: aBlock	"For each link that is like aLink, evaluate aBlock with the link as the parameter.  This allows for things like changing the contents of the link."	| linkEmphasis |	linkEmphasis := aLink asEmphasis.	self nodesWithTextDo: [:aTree |		self			updateTreeTextFor: aTree			using: [:text || change |				change := false.				text					emphasesLike: linkEmphasis					do: [:emph || old |						old := emph value copy.						aBlock value: emph value.						change := change or: [(emph = old) not]].				change]].</body><body package="Arbor Help System Outline Help Core">removeReferencesToLink: aLinkObject	| emphasis |	emphasis := Array with: aLinkObject asEmphasis.	self nodesWithTextDo: [:aTree |		self 			updateTreeTextFor: aTree			using: [:text || old |				old := text copy.				text					addEmphasis: #()					removeEmphasis: emphasis					allowDuplicates: false.				(AHSUtils text: text equals: old) not]]</body></methods><methods><class-id>VWHelp.AHSOutline</class-id> <category>initialize-release</category><body package="Arbor Help System Outline Help Core">initialize	name := 'Untitled' copy.	outlineLabel := 'Untitled' copy.	fileFormat := #fastAccess.	glossaryDictionary := AHSPersistentDictionary new.	graphicsDictionary := AHSPersistentDictionary new.	nextID := 0.	forest := AHSPersistentOrderedCollection new</body></methods><methods><class-id>VWHelp.AHSOutline</class-id> <category>references - private</category><body package="Arbor Help System Outline Help Core">updateTreeTextFor: aTree using: aBlock	"Evaluate aBlock and update the data text value maintained by aTree if a change has occured.  If a change occurred make a deep copy before installing it - this is for database support.  We only mark dirty at the data's #text: level, we don't bother going deeper.  So if the text is the same but the contents (such as the runs) are different, then we need to get a whole new text or the new runs won't make it into the database."	| thisText |	thisText := aTree dataTextValue.	(aBlock value: thisText) ifTrue: [aTree data text: (AHSUtils deepCopyOfText: thisText)].</body></methods><methods><class-id>VWHelp.AHSOutline</class-id> <category>reporting</category><body package="Arbor Help System Outline Help Core">reportHyperLinksOn: aStream	"Loops through outline and prints out report detailing hyperlinks into a CSV file."	self do:		[ :current | 		aStream nextPutAll: '0,Root, '. 		current data topic printOn: aStream.		aStream nextPut: $,.		current depth printOn: aStream.		aStream cr.		current do: 			[:currentTree |  			aStream nextPutAll: '0, Topic, '.			currentTree data topic printOn: aStream.			aStream nextPut: $,.			currentTree depth printOn: aStream.			aStream cr.			currentTree data text printLinksOn: aStream]].</body></methods><methods><class-id>VWHelp.AHSOutline class</class-id> <category>instance creation</category><body package="Arbor Help System Outline Help Core">fromTopicTree: aTopicTree	"Answer a new outline with aTopicTree as its contents.  The label of the outline is the same as the name of the	 top level node in the tree."	^ self		fromTopicTree: aTopicTree		labeled: aTopicTree label.</body><body package="Arbor Help System Outline Help Core">fromTopicTree: aTopicTree labeled: aString	"Answer a new outline with aTopicTree as its contents.  Set the label of the outline to aString."	^ (self new: 1)		addFirst: aTopicTree;		outlineLabel: aString;		yourself</body><body package="Arbor Help System Outline Help Core">new	^super new initialize</body><body package="Arbor Help System Outline Help Core">new: anInteger	|newOutline|	newOutline := self new.	newOutline forest: (AHSPersistentOrderedCollection new: anInteger).	^newOutline</body><body package="Arbor Help System Outline Help Core">withAll: aCollection	|newOutline|	newOutline := self new.	newOutline forest: (AHSPersistentOrderedCollection withAll: aCollection).	^newOutline</body></methods><methods><class-id>VWHelp.AHSOutline class</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">filenameSignal	^FilenameSignal isNil ifTrue: [FilenameSignal := Object informationSignal newSignal] ifFalse: [FilenameSignal]</body><body package="Arbor Help System Outline Help Core">fixupSignal	"Answer the signal used to retrieve the collection of fixup blocks.  When this signal is raised,	 the handler is expected to resume the process, passing an OrderedCollection as the value."	^ FixupSignal isNil 		ifTrue: [FixupSignal := Object informationSignal newSignal] 		ifFalse: [FixupSignal]</body></methods><methods><class-id>VWHelp.AHSOutline class</class-id> <category>BOSS conversion</category><body package="Arbor Help System Outline Help Core">binaryReaderBlockForVersion: oldVersion format: oldFormat 	"An attempt is being made to read instances of 	an obsolete version of this class. Answer a block 	that converts old instances (represented as an array 	or string of instance variable values) to new ones." 		"This is never used, but is requested anyway by BOSS"	^[:oldObj | self error: 'unexpected execution']</body><body package="Arbor Help System Outline Help Core">binaryRepresentationVersion	^'AHS 2.5'</body><body package="Arbor Help System Outline Help Core">getFixupCollectionFromSignal	"Private - Answer the collection used to store fixup blocks.  The collection is answered as a result	 of raising a signal."	^ Signal noHandlerSignal		handle: [:ex | ex returnWith: OrderedCollection new]		do: [self fixupSignal raiseRequest].</body><body package="Arbor Help System Outline Help Core">unboss: aCollection 	"Answer a new instance of this class, whose elements are the 	elements of aCollection. Handle instance variables appropriately"	| newOutline fixups | 	newOutline := self new: aCollection size - 7.	newOutline forest addAll: (aCollection copyFrom: 8 to: aCollection size).	newOutline		name: (aCollection at: 2);		outlineLabel: (aCollection at: 3);		nextID: (aCollection at: 4);		fileFormat: (aCollection at: 5);		glossaryDictionary: (aCollection at: 6);		graphicsDictionary: (aCollection at: 7). 	fixups := self getFixupCollectionFromSignal.	fixups add: [:fn | newOutline fixupWith: fn].	^ newOutline</body></methods><methods><class-id>VWHelp.AHSOutline class</class-id> <category>links</category><body package="Arbor Help System Outline Help Core">newGlossaryLinkOn: aKey	"Answer a new glossary hypertext link."	^AHSGlossaryLinkObject  		newLink: aKey asSymbol.</body><body package="Arbor Help System Outline Help Core">newHyperTextLinkOn: outlineName and: topicNumber	"Answer a new hyper text link object."	^ AHSHyperTextLinkObject  		newLink: (Array with: outlineName with: topicNumber).</body></methods><methods><class-id>VWHelp.AHSTextGraphicSelectionTracker</class-id> <category>events</category><body package="Arbor Help System Outline Help Core">redButtonReleasedEvent: aMouseButtonEvent	"Be sure the controller gets a chance to handle red button released events."	| ctrlr |	ctrlr := controller.	super redButtonReleasedEvent: aMouseButtonEvent.	ctrlr redButtonReleasedEvent: aMouseButtonEvent.</body></methods><methods><class-id>VWHelp.AHSTextGraphicSelectionTracker</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">current	^current</body><body package="Arbor Help System Outline Help Core">current: aValue	current := aValue.</body><body package="Arbor Help System Outline Help Core">originalStartBlock	^originalStartBlock</body><body package="Arbor Help System Outline Help Core">originalStartBlock: aValue	originalStartBlock := aValue.</body><body package="Arbor Help System Outline Help Core">originalStopBlock	^originalStopBlock</body><body package="Arbor Help System Outline Help Core">originalStopBlock: aValue	originalStopBlock := aValue.</body><body package="Arbor Help System Outline Help Core">pivot	^pivot</body><body package="Arbor Help System Outline Help Core">pivot: aValue	pivot := aValue.</body></methods><methods><class-id>VWHelp.AHSTextGraphicSelectionTracker</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">doSelectionTrackingOperationAt: aPoint	self controller		selectionTrackFrom: self current		to: aPoint		pivot: self pivot.	self current: aPoint.</body><body package="Arbor Help System Outline Help Core">finishSelectionFor: aPoint	| tmp |	process notNil ifTrue: [process terminate. process := nil].	tmp := self controller.	controller := nil.	self pivot notNil ifTrue: [		tmp			selectionEndAt: aPoint			pivot: self pivot			originalStart: self originalStartBlock			originalStop: self originalStopBlock].</body><body package="Arbor Help System Outline Help Core">setUpFor: aMouseButtonEvent 		| point comps blk |	point := self cursorPointFor: aMouseButtonEvent.	self originalStartBlock: self controller startBlock.	self originalStopBlock: self controller stopBlock.	self current: point.	self pivot: (self controller					selectionStartAt: point					shiftDown: aMouseButtonEvent shiftDown).	((self originalStartBlock isNil or: [self originalStopBlock isNil])		and: [(comps := controller selectedComponents) isEmpty not])			ifTrue: [				blk := controller characterBlockAtLocalPoint: 0@0 for: comps first.				self originalStartBlock: blk.				self originalStopBlock: blk].</body><body package="Arbor Help System Outline Help Core">trackSelectionFor: aPoint 	"If the setup answered a nil pivot, then we don't want to do any tracking.  Also don't track if already handling a tracking operation."	self pivot notNil ifTrue: [super trackSelectionFor: aPoint].</body></methods><methods><class-id>VWHelp.ArborHierarchicalSequenceSelectionTracker</class-id> <category>events</category><body package="Arbor Help System Outline Help Core">mouseMovedEvent: aMouseMovedEvent	switchInTransition isNil		ifTrue: [^super mouseMovedEvent: aMouseMovedEvent].	^nil</body><body package="Arbor Help System Outline Help Core">redButtonPressedEvent: aMouseButtonEvent	self doSwitchPressed: aMouseButtonEvent.	switchInTransition notNil		ifTrue: [^nil].	^super redButtonPressedEvent: aMouseButtonEvent</body><body package="Arbor Help System Outline Help Core">redButtonReleasedEvent: aMouseButtonEvent	switchInTransition isNil		ifTrue: [^super redButtonReleasedEvent: aMouseButtonEvent].	self doSwitchReleased: aMouseButtonEvent.	^nil</body></methods><methods><class-id>VWHelp.ArborHierarchicalSequenceSelectionTracker</class-id> <category>switch</category><body package="Arbor Help System Outline Help Core">doSwitchPressed: aMouseButtonEvent	"Answer true if the button is pressed on an expansion switch,	false otherwise"	| pt index |	switchInTransition := nil.	pt := self cursorPointFor: aMouseButtonEvent.	index := self controller findElementFor: pt.	index = 0		ifTrue: [^false].	(self view isHotspot: pt)		ifTrue: [self view showTransition: true for: index.				switchInTransition := index.				aMouseButtonEvent initiator grabMouseEventFor: self.				^true].	^false</body><body package="Arbor Help System Outline Help Core">doSwitchReleased: aMouseButtonEvent	"Answer true if the button is pressed on an expansion switch,	false otherwise"	| pt index |	self sensor ungrabMouseEventFor: self.	pt := self cursorPointFor: aMouseButtonEvent.	index := self controller findElementFor: pt.	(switchInTransition = index and: [self view isHotspot: pt])		ifTrue: [			self view inTransition: false.			self controller outlineModel toggleIndex: index fully: aMouseButtonEvent ctrlDown]		ifFalse: [self view showTransition: false for: switchInTransition].</body></methods><methods><class-id>VWHelp.AHSTextGraphicLayoutWrapper</class-id> <category>testing</category><body package="Arbor Help System Outline Help Core">wrapsCaptionTextView	^self isCaption</body><body package="Arbor Help System Outline Help Core">wrapsNormalTextView	^self wrapsTextView and: [self wrapsCaptionTextView not]</body><body package="Arbor Help System Outline Help Core">wrapsTextView	^self wrapsCaptionTextView or: [self view isKindOf: ComposedTextView]</body></methods><methods><class-id>VWHelp.AHSTextGraphicLayoutWrapper</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">backgroundColor	"Answer the receiver's background color."	^ColorValue white</body><body package="Arbor Help System Outline Help Core">isCaption	^isCaption</body><body package="Arbor Help System Outline Help Core">isCaption: aBoolean	isCaption := aBoolean.</body><body package="Arbor Help System Outline Help Core">nextComponentIsBeneath	^nextComponentIsBeneath</body><body package="Arbor Help System Outline Help Core">nextComponentIsBeneath: aBoolean	nextComponentIsBeneath := aBoolean.</body><body package="Arbor Help System Outline Help Core">nextComponentIsBeside	^self nextComponentIsBeneath not</body><body package="Arbor Help System Outline Help Core">view	^view</body><body package="Arbor Help System Outline Help Core">view: aView	view := aView.</body></methods><methods><class-id>VWHelp.AHSTextGraphicLayoutWrapper class</class-id> <category>instance creation</category><body package="Arbor Help System Outline Help Core">on: aComponent view: aView	^self on: aComponent view: aView nextIsBeneath: true</body><body package="Arbor Help System Outline Help Core">on: aComponent view: aView isCaption: captionBoolean nextIsBeneath: beneathBoolean	^(super on: aComponent)		view: aView;		isCaption: captionBoolean;		nextComponentIsBeneath: beneathBoolean</body><body package="Arbor Help System Outline Help Core">on: aComponent view: aView nextIsBeneath: aBoolean	^self on: aComponent view: aView isCaption: false nextIsBeneath: aBoolean</body></methods><methods><class-id>VWHelp.AHSHelpHyperLinkObject</class-id> <category>attributes</category><body package="Arbor Help System Outline Help Core">attributeAt: aString	"Answer the attribute that matches aString"	^self attributeAt: aString ifAbsent: [self error: 'No such attribute: ', aString printString]</body><body package="Arbor Help System Outline Help Core">attributeAt: aString ifAbsent: aBlock	"Answer the attribute that matches aString, if no such attribute evaluate aBlock"	^AHSUtils		performReceiver: self		selector: aString		arguments: #()		ifAbsent: aBlock</body><body package="Arbor Help System Outline Help Core">attributeAt: aString put: aValue	"Store aValue into the attribute named aString"	^self attributeAt: aString put: aValue ifAbsent: [self error: 'No such attribute or cannot store into attribute: ', aValue printString]</body><body package="Arbor Help System Outline Help Core">attributeAt: aString put: aValue ifAbsent: aBlock	"Store aValue into the attribute named aString.  If no such attribute is present, evaluate aBlock"	^AHSUtils		performReceiver: self		selector: aString, ':'		arguments: (Array with: aValue)		ifAbsent: aBlock</body><body package="Arbor Help System Outline Help Core">attributes	"Answer a collection of attributes which are written during RTF export.  It's done this way to minimize having to make changes throughout the system if a hyperlink is enhanced."	"Attributes should be either a number, a string, or nil.  If an attribute is nil, it is ignored."	^#()</body><body package="Arbor Help System Outline Help Core">type	"Answer a unique identifier for the type, used during RTF exports to indicate the type of the link."	^self class type</body></methods><methods><class-id>VWHelp.AHSHelpHyperLinkObject</class-id> <category>AHS Export adds</category><body package="Arbor Help System Outline Help Core">writeHyperlinkUsing: aTopicBodyWriter	^self subclassResponsibility</body></methods><methods><class-id>VWHelp.AHSHelpHyperLinkObject</class-id> <category>testing</category><body package="Arbor Help System Outline Help Core">isGlossary	^false</body><body package="Arbor Help System Outline Help Core">isHyperGraphic	^false</body><body package="Arbor Help System Outline Help Core">isHyperText	^false</body></methods><methods><class-id>VWHelp.AHSHelpHyperLinkObject</class-id> <category>initialize-release</category><body package="Arbor Help System Outline Help Core">initialize	"Stub."</body></methods><methods><class-id>VWHelp.AHSHelpHyperLinkObject class</class-id> <category>attributes</category><body package="Arbor Help System Outline Help Core">type	"Answer a unique identifier for the type, used during RTF exports to indicate the type of the link."	^self subclassResponsibility</body></methods><methods><class-id>VWHelp.AHSHelpHyperLinkObject class</class-id> <category>instance creation</category><body package="Arbor Help System Outline Help Core">new	^super new initialize</body><body package="Arbor Help System Outline Help Core">newForType: aType	"Answer a new instance of the appropriate subclass.  If none found, answer nil."	self allSubclasses do: [:cls |		cls type = aType asSymbol ifTrue: [^cls new]].	^nil</body></methods><methods><class-id>VWHelp.AHSHelpHyperLinkObject class</class-id> <category>BOSS conversion</category><body package="Arbor Help System Outline Help Core">binaryReaderBlockForVersion: oldVersion format: oldFormat	" An attempt is being made to read instances of	an obsolete version of this class.  Answer a block	that converts old instances (represented as an array	or string of instance variable values) to new ones."	^oldVersion = 'Help System version 2.0'		ifTrue: [			[:oldObj | | inst |				inst := (oldObj first = #hyperGraphic							ifTrue: [								AHSHyperGraphicLinkObject new									caption: '';									imageProportion: 1.0]							ifFalse: [								oldObj first = #glossary									ifTrue: [AHSGlossaryLinkObject new]									ifFalse: [AHSHyperTextLinkObject new]]).				2 to: oldObj size do: [:i | inst instVarAt: i - 1 put: (oldObj at: i)].				oldObj become: inst]]		ifFalse: [super binaryReaderBlockForVersion: oldVersion format: oldFormat]</body><body package="Arbor Help System Outline Help Core">binaryRepresentationVersion	^'AHS 3.0'</body></methods><methods><class-id>VWHelp.ArborHierarchicalSequenceViewSpec</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">multipleSelections	"We do not support multi-selection."	^false</body><body package="Arbor Help System Outline Help Core">multipleSelections: aBoolean	"Ignore it.  We do not support multi-selection."</body></methods><methods><class-id>VWHelp.ArborHierarchicalSequenceViewSpec</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">dispatchTo: policy with: builder		policy arborHierarchicalListView: self into: builder</body></methods><methods><class-id>VWHelp.ArborHierarchicalSequenceView</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">computeWidthForLinesFrom: startIndex to: stopIndex	"Measure the receiver's lines from startIndex to stopIndex."	| width |	width := 0.	startIndex to: stopIndex do: [:i |		width := width max: (self widthCache								at: (sequence at: i) value								ifAbsent: [									self widthCache										 at: (sequence at: i) value										put: (self visualComponentForElementIndex: i) preferredBounds width])].	^width</body><body package="Arbor Help System Outline Help Core">computeWidthForTextLinesFrom: startIndex to: stopIndex	"Measure the receiver's lines from startIndex to stopIndex.  Use our cache if possible."	| width compositionScanner limit style |	width := 0.	limit := SmallInteger maxVal.	style := self textStyle.	compositionScanner := CompositionScanner			fontPolicy: Screen default defaultFontPolicy			text: ''			textAttributes: style.	startIndex to: stopIndex do: [:i || w |		w := self widthCache				at: (sequence at: i) value				ifAbsent: [					compositionScanner text: (self displayStringAt: i).					compositionScanner						composeLine: i 						fromCharacterIndex: 1 						leftMargin: self offsetForTextDisplay						rightMargin: limit.					self widthCache at: (sequence at: i) value put: compositionScanner rightX].		width &lt; w ifTrue: [width := w]].	width := width + (style firstIndent max: style restIndent) + style rightIndent.	^width</body><body package="Arbor Help System Outline Help Core">maxItemsVisibleForBounds: aRectangle	^(aRectangle bottom - aRectangle top) // self lineGrid</body><body package="Arbor Help System Outline Help Core">maxVisibleInterval	"Answer the visible interval for the current bounds, regardless of how many elements are actually present in the sequence."	| first lineGrid last bounds | 	bounds := self bounds.	lineGrid := self lineGrid.	first := bounds top // lineGrid + 1.	last := (bounds bottom-lineGrid) // lineGrid + 1.	^first to: last</body><body package="Arbor Help System Outline Help Core">resetWidthCache	self widthCache: IdentityDictionary new.</body><body package="Arbor Help System Outline Help Core">updateModel	self resetWidthCache.	^super updateModel</body></methods><methods><class-id>VWHelp.ArborHierarchicalSequenceView</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">includeArrows	^visualBlock notNil</body><body package="Arbor Help System Outline Help Core">includeArrows: aBoolean	"If 'arrows' (that would be icons) are used, then set up visuals, otherwise use only the text representation."	self includeArrows = aBoolean ifTrue: [^self].	aBoolean		ifTrue: [self initializeVisuals]		ifFalse: [self optimizeForText].	self resetWidthCache.</body><body package="Arbor Help System Outline Help Core">inTransition	^inTransition</body><body package="Arbor Help System Outline Help Core">inTransition: aBoolean	inTransition := aBoolean.</body><body package="Arbor Help System Outline Help Core">isHotspot: aPoint	"Answer whether aPoint is a hotspot for expansion/contraction by mouse"	|index|	index := controller findElementFor: aPoint.	^(index = 0 or: [self includeArrows not])		ifTrue: [false]		ifFalse: [(sequence at: index) isHot: aPoint]</body><body package="Arbor Help System Outline Help Core">showTransition: aBoolean for: index	"Repair the change if going into the transition.  If returning to normal, don't show transition immediately since it is likely an update will occur anyway due to the item being expanded or collapsed."	self inTransition: aBoolean.	self		invalidateRectangle: (self boundsOfElementIndex: index inBounds: self bounds)		repairNow: (aBoolean and: [((self isSelected: index) ifTrue: [#repairNowNoFill] ifFalse: [true])]).</body><body package="Arbor Help System Outline Help Core">widthCache	^widthCache</body><body package="Arbor Help System Outline Help Core">widthCache: aDictionary	widthCache := aDictionary.</body></methods><methods><class-id>VWHelp.ArborHierarchicalSequenceView</class-id> <category>protected</category><body package="Arbor Help System Outline Help Core">forceMaximumVisibility	"Ensures there are no blank lines at the bottom of the list if there are undisplayed items at the top.  Invoked externally."	| b vis max |	b := self bounds.	vis := self visibleIntervalForBounds: b.	max := self maxItemsVisibleForBounds: b.	vis size &lt; max		ifTrue: [self makeVisible: (1 max: (vis first - (max - vis size)))]</body><body package="Arbor Help System Outline Help Core">invalidateToBottomFromElementIndex: anInteger	"Invalidate the list from the element at anInteger to the bottom of the display.  If anInteger is 'beneath' the displayed region, don't bother."	| b origin |	origin := (self boundsOfElementIndex: anInteger inBounds: (b := self bounds)) origin.	origin &lt; b corner		ifTrue: [self invalidateRectangle: (origin corner: b corner)].</body><body package="Arbor Help System Outline Help Core">makeVisibleFrom: startIndex to: stopIndex	"Adjust the list so that as many as possible from startIndex to stopIndex are shown.  Ensure that startIndex is always visible."	| range stop offset comp |	startIndex &gt; self sequence size ifTrue: [^self].	range := self maxVisibleInterval.	(range first = startIndex or: [range first &lt; startIndex and: [range last &gt;= stopIndex]])		ifTrue: [^self].	stop := stopIndex min: startIndex + range last - range first.	offset := (range last - stop) * self lineGrid.	(comp := self topComponent) notNil		ifTrue: [comp displayPendingInvalidation].	scrollOffset value: scrollOffset value + (0@offset).</body></methods><methods><class-id>VWHelp.ArborHierarchicalSequenceView</class-id> <category>controller accessing</category><body package="Arbor Help System Outline Help Core">defaultControllerClass	^ArborHierarchicalSequenceController</body></methods><methods><class-id>VWHelp.ArborHierarchicalSequenceView</class-id> <category>initialize-release</category><body package="Arbor Help System Outline Help Core">initialize	super initialize.	self resetWidthCache.	self inTransition: false.</body><body package="Arbor Help System Outline Help Core">initializeVisuals	"Default to using visual blocks for display.  This assumes the use of ArborLabeledObjectHolders for the list elements."	self visualBlock: [:view :index |		(view sequence at: index)			asVisualComponentWhereSelected: false			inTransition: view inTransition			attributes: view textStyle].	self selectedVisualBlock: [:view :index || vc rw |		vc := (view sequence at: index)				asVisualComponentWhereSelected: true				inTransition: view inTransition				attributes: view textStyle.		rw := ReversingWrapper on: vc component.		rw reverse setValue: true.		vc component: rw].</body></methods><methods><class-id>VWHelp.ArborHierarchicalSequenceView class</class-id> <category>resources</category><body package="Arbor Help System Outline Help Core">contractedImage	| palette |	palette := MappedPalette with: ColorValue white with: ColorValue blue with: ColorValue black.	^Image		extent: 7 @ 13		depth: 2		palette: palette		bits:			#[128 0 0 0 160 0 0 0 152 0 0 0 134			0 0 0 145 128 0 0 132 96 0 0 145 24			0 0 132 96 0 0 145 128 0 0 134 0 0			0 152 0 0 0 160 0 0 0 128 0 0 0 ]</body><body package="Arbor Help System Outline Help Core">expandedImage	| palette |	palette := MappedPalette with: ColorValue white with: ColorValue blue with: ColorValue black.	^Image		extent: 13 @ 7		depth: 2		palette: palette		bits: #[170 170 170 128 36 68 70 0 9 17 24 0 2 68 96 0 0 145 128 0 0 38 0 0 0 8 0 0 ]</body></methods><methods><class-id>VWHelp.ArborTextStyleDialog</class-id> <category>aspects</category><body package="Arbor Help System Outline Help Core">bold	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^bold isNil ifTrue: [bold := false asValue] ifFalse: [bold]</body><body package="Arbor Help System Outline Help Core">color	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^color isNil ifTrue: [color := nil asValue] ifFalse: [color]</body><body package="Arbor Help System Outline Help Core">colorOn	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^colorOn isNil ifTrue: [colorOn := false asValue] ifFalse: [colorOn]</body><body package="Arbor Help System Outline Help Core">italic	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^italic isNil ifTrue: [italic := false asValue] ifFalse: [italic]</body><body package="Arbor Help System Outline Help Core">large	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^large isNil ifTrue: [large := false asValue] ifFalse: [large]</body><body package="Arbor Help System Outline Help Core">sampleText	^sampleText isNil ifTrue: [sampleText := 'The quick brown fox jumped over the lazy sleeping dog.' asText asValue] ifFalse: [sampleText]</body><body package="Arbor Help System Outline Help Core">serif	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^serif isNil ifTrue: [serif := false asValue] ifFalse: [serif]</body><body package="Arbor Help System Outline Help Core">underline	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^underline isNil ifTrue: [underline := false asValue] ifFalse: [underline]</body></methods><methods><class-id>VWHelp.ArborTextStyleDialog</class-id> <category>interface opening</category><body package="Arbor Help System Outline Help Core">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self changeColorSetting.</body></methods><methods><class-id>VWHelp.ArborTextStyleDialog</class-id> <category>actions</category><body package="Arbor Help System Outline Help Core">closeAccept	self accept value		ifTrue: [self changeStyle].	^super closeAccept</body><body package="Arbor Help System Outline Help Core">setColor		|c|	c := self class pickColor: (self color value isNil									ifTrue: [ColorValue black]									ifFalse: [self color value]).	c notNil		ifTrue: [self color value: c]</body></methods><methods><class-id>VWHelp.ArborTextStyleDialog</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">emphasis	|oc|	oc := OrderedCollection new.	self serif value		ifTrue: [oc add: #serif].	self large value		ifTrue: [oc add: #large].	self underline value		ifTrue: [oc add: #underline].	self italic value		ifTrue: [oc add: #italic].	self bold value		ifTrue: [oc add: #bold].	(self colorOn value and: [self color value notNil])		ifTrue: [oc add: #color-&gt;self color value].	^oc asArray</body><body package="Arbor Help System Outline Help Core">paragraphEditor	^paragraphEditor</body><body package="Arbor Help System Outline Help Core">paragraphEditor: editor	| selection emphasis emphases clr |	paragraphEditor := editor.	editor selectionStartIndex = editor selectionStopIndex		ifTrue: [emphasis := editor instVarAt: 7 "emphasisHere".				emphasis notNil					ifTrue: [emphasis := self emphasisAsArray: emphasis.							self serif value: (emphasis includes: #serif).							self large value: (emphasis includes: #large).							self underline value: (emphasis includes: #underline).							self italic value: (emphasis includes: #italic).							self bold value: (emphasis includes: #bold).							self color value: ((emphasis detect: [:e | (e isKindOf: Association) and: [e key = #color]] ifNone: [nil])												value)]]		ifFalse: [selection := editor selection.				emphases := (1 to: selection size) collect: [:i | (self emphasisAsArray: (selection emphasisAt: i))].				emphases detect: [:e | (e includes: #serif) not]					ifNone: [self serif value: true].				emphases detect: [:e | (e includes: #large) not]					ifNone: [self large value: true].				emphases detect: [:e | (e includes: #underline) not]					ifNone: [self underline value: true].				emphases detect: [:e | (e includes: #italic) not]					ifNone: [self italic value: true].				emphases detect: [:e | (e includes: #bold) not]					ifNone: [self bold value: true].				(clr := emphases inject: nil into: [:acc :each | |thisColor|										each detect: [:eachEmph | 											thisColor := ((eachEmph isKindOf: Association) and: [eachEmph key = #color])														ifTrue: [eachEmph value].											thisColor notNil] ifNone: [nil].										thisColor = acc												ifTrue: [acc]												ifFalse: [acc isNil															ifTrue: [thisColor]															ifFalse: [nil]]]) notNil					ifTrue: [clr notNil								ifTrue:[self colorOn value: true.									    self color value: clr.]								ifFalse:[self colorOn value: false.									     self color value: clr].]]</body></methods><methods><class-id>VWHelp.ArborTextStyleDialog</class-id> <category>change messages</category><body package="Arbor Help System Outline Help Core">changeColorSetting	"Change color on setting, disable/enable SetColor button"	| button |	(button := self builder namedComponents at: #setColor ifAbsent: []) notNil		ifTrue:[self colorOn value 				ifTrue:[button enable]				ifFalse:[button disable].	self changeSampleText].</body><body package="Arbor Help System Outline Help Core">changeSampleText	| text |	Cursor wait		showWhile: 			[text := self sampleText value.			self sampleText value: ''.			self sampleText value: (text emphasizeAllWith: self emphasis)]</body></methods><methods><class-id>VWHelp.ArborTextStyleDialog</class-id> <category>initialize-release</category><body package="Arbor Help System Outline Help Core">initialize	super initialize. 	serif := false asValue.	large := false asValue.	underline := false asValue.	italic := false asValue.	bold := false asValue.	colorOn := false asValue.	color := nil asValue.		serif onChangeSend: #changeSampleText to: self.	large onChangeSend: #changeSampleText to: self.	underline onChangeSend: #changeSampleText to: self.	italic onChangeSend: #changeSampleText to: self.	bold onChangeSend: #changeSampleText to: self.	colorOn onChangeSend: #changeColorSetting to: self.	color onChangeSend: #changeSampleText to: self.</body></methods><methods><class-id>VWHelp.ArborTextStyleDialog</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">changeStyle	|start stop| 	start := self paragraphEditor selectionStartIndex.	stop := self paragraphEditor selectionStopIndex.	self paragraphEditor deselect.	start = stop		ifTrue: [self paragraphEditor aisSetEmphasisHere: self emphasis]		ifFalse: [| newText |			newText := self paragraphEditor selection							addEmphasis: self emphasis							removeEmphasis: #{Smalltalk.Text} value aisAllEmphases							allowDuplicates: false.			self paragraphEditor replaceSelectionWith: newText.			self paragraphEditor selectFrom: start to: stop - 1]</body><body package="Arbor Help System Outline Help Core">emphasisAsArray: emph	^(emph isNil or: [emph isSymbol or: [emph isKindOf: Association]])		ifTrue: [Array with: emph]		ifFalse: [emph]</body></methods><methods><class-id>VWHelp.ArborTextStyleDialog class</class-id> <category>interface opening</category><body package="Arbor Help System Outline Help Core">openForParagraphEditor: aParagraphEditor	|dlg|	dlg := self new.	dlg paragraphEditor: aParagraphEditor.	^dlg open</body></methods><methods><class-id>VWHelp.ArborTextStyleDialog class</class-id> <category>utility</category><body package="Arbor Help System Outline Help Core">colorsAndTexts	"Answer a collection of associations where the key is a ColorValue and the value is a text representing the color."	"ArborCoreUtils colorsAndTexts."	| colorNames |	colorNames := (ColorValue constantNames asSortedCollection) sortBlock: [:a :b ||cv1 cv2|						cv1 := ColorValue perform: a.						cv2 := ColorValue perform: b.						cv1 brightness &lt; cv2 brightness							or: [cv1 brightness = cv2 brightness							and: [cv1 hue &lt; cv2 hue							or: [cv1 hue = cv2 hue							and: [cv1 saturation &lt; cv2 saturation]]]]].	^colorNames collect: [:colorName || color textStream |		color := ColorValue perform: colorName.		textStream := TextStream on: String new.		textStream emphasis: (Array with: #bold with: #color-&gt;color).		colorName do: [:ch |			ch isUppercase				ifTrue: [					textStream						nextPut: Character space;						nextPut: ch asLowercase]				ifFalse: [					textStream						nextPut: (textStream position = 0											ifTrue: [ch asUppercase]											ifFalse: [ch])]].		color-&gt;textStream contents]</body><body package="Arbor Help System Outline Help Core">pickColor	"Use a color picker to pick a color.	Answer the new color, or nil if user cancelled."	"self pickColor"	^self pickColor: ColorValue white</body><body package="Arbor Help System Outline Help Core">pickColor: aColorValue	"Use a color picker to pick a color - use the Arbor color picker if installed, otherwise build a list of colors dynamically.	Answer the new color, or nil if user cancelled.  Start with the current color aColorValue, if applicable"	"self pickColor: ColorValue blue"	^(#{ColorPicker} isDefined			and: [#{ColorPicker} value canOpen])		ifTrue: [#{ColorPicker} value openAsDialogOn: aColorValue]		ifFalse: [| colors |			colors := self colorsAndTexts.			Dialog				choose: 'Please pick a color:'				fromList: (colors collect: [:assoc | assoc value])				values: (colors collect: [:assoc | assoc key])				lines: 15				cancel: [nil]]</body></methods><methods><class-id>VWHelp.ArborTextStyleDialog class</class-id> <category>examples</category><body package="Arbor Help System Outline Help Core">example	"self example"	self openForParagraphEditor: (ScheduledControllers activeController model dependents detect: [:dep |											dep isKindOf: ComposedTextView]) controller</body></methods><methods><class-id>VWHelp.AHSOutlineTextGraphicMixViewer</class-id> <category>interface configuration</category><body package="Arbor Help System Outline Help Core">topicTextGraphicUnzoomedBoundaries	"Private - Answer the unzoomed boundaries for the topic text pane when the topic text pane is unzoomed."	| oldBoundaries |	oldBoundaries := self textGraphicWidget bounds.	^ Rectangle		left: oldBoundaries left		right: oldBoundaries right		top: self listOutlineBrowser bounds bottom		bottom: oldBoundaries bottom.</body><body package="Arbor Help System Outline Help Core">topicTextGraphicUnzoomedLayout	"Private - Answer the LayoutFrame to be used for the topic text when the topic text pane is unzoomed."	| oldLayout dragBarLayout |	oldLayout := self textGraphicWidget layout.	dragBarLayout := self dragBar layout.	^ LayoutFrame 		leftFraction: oldLayout leftFraction 		offset: oldLayout leftOffset		rightFraction: oldLayout rightFraction 		offset: oldLayout rightOffset		topFraction: dragBarLayout bottomFraction		offset: 0		bottomFraction: 1 		offset: 0.</body><body package="Arbor Help System Outline Help Core">topicTextGraphicZoomedBoundaries	"Private - Answer the zoomed boundaries for the topic text pane when the topic text pane is zoomed."	| oldBoundaries |	oldBoundaries := self textGraphicWidget bounds.	^ Rectangle		left: oldBoundaries left		right: oldBoundaries right		top: self textSubCanvas container bounds top		bottom: oldBoundaries bottom.</body><body package="Arbor Help System Outline Help Core">topicTextGraphicZoomedLayout	"Private - Answer the LayoutFrame to be used for the topic text when the topic text pane is zoomed."	| oldLayout |	oldLayout := self textGraphicWidget layout.	^ LayoutFrame		leftFraction: oldLayout leftFraction 		offset: oldLayout leftOffset		rightFraction: oldLayout rightFraction 		offset: oldLayout rightOffset		topFraction: oldLayout topFraction 		offset: oldLayout topOffset		bottomFraction: 1 		offset: oldLayout bottomOffset.</body></methods><methods><class-id>VWHelp.AHSOutlineTextGraphicMixViewer</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">fixOutlinerSizeForUnzoom	super fixOutlinerSizeForUnzoom.	self textGraphicWidget		newBounds: self topicTextGraphicUnzoomedBoundaries;		newLayout: self topicTextGraphicUnzoomedLayout.</body><body package="Arbor Help System Outline Help Core">fixOutlinerSizeForZoom	super fixOutlinerSizeForZoom.	self textGraphicWidget		newBounds: self topicTextGraphicZoomedBoundaries;		newLayout: self topicTextGraphicZoomedLayout.</body><body package="Arbor Help System Outline Help Core">postOpenWith: aBuilder	super postOpenWith: aBuilder.	self outliner builder component controller keyboardHook: self copyKeyHook.</body><body package="Arbor Help System Outline Help Core">textGraphicWidget	^self builder componentAt: #textGraphicComposite</body></methods><methods><class-id>VWHelp.AHSOutlineTextGraphicMixViewer</class-id> <category>private - configuration</category><body package="Arbor Help System Outline Help Core">configureTextEditor	super configureTextEditor.	(self builder componentAt: #textSubCanvas) beInvisible.</body></methods><methods><class-id>VWHelp.AHSOutlineTextGraphicMixViewer</class-id> <category>aspects</category><body package="Arbor Help System Outline Help Core">textGraphicComposite	^AHSTextGraphicComposite new outliner: self</body></methods><methods><class-id>VWHelp.AHSOutlineTextGraphicMixViewer</class-id> <category>searching</category><body package="Arbor Help System Outline Help Core">highlightSearchedWord	"highlight the selection that was the objective of the search."	^self textGraphicWidget widget controller findAndSelect: self searchString ignoreCase: true.</body><body package="Arbor Help System Outline Help Core">nextOccurrence	"search for the next entry of the selected text within the same piece of text."	self highlightSearchedWord ifFalse: [		Dialog warn: (#noEntriesMatching &lt;&lt; self messageCatalogID) asString					, ' "', self searchString, '" ' ,					(#foundInOutline &lt;&lt; self messageCatalogID) asString]</body></methods><methods><class-id>VWHelp.AHSOutlineTextGraphicMixViewer</class-id> <category>As yet unclassified</category><body package="Arbor Help System Outline Help Core">copyKeyHook	^[:event :object |	(event keyValue isSymbol not and: [event keyValue asInteger = 3])		ifTrue: 			[(builder aspectAt: #textGraphicComposite) controller copySelection.			nil] 		ifFalse: [event]]</body></methods><methods><class-id>VWHelp.ArborCenteredLabelAndIcon</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">height	"Answer the height in pixels of one line of text in the receiver.  If the	offset is not zero then the answer will include the height of the offset."	self width = 0 ifTrue: [^0].	icon == nil ifTrue: [^super height].	^super height max: (icon preferredBounds height + self offset y)</body><body package="Arbor Help System Outline Help Core">iconOffset	"Answer the offset for displaying the icon, which takes into account the height of the icon and the height of the text."	^(icon preferredBounds height &gt; self attributes lineGrid)		ifTrue: [self offset]		ifFalse: [self offset + (0 @ ((self attributes lineGrid - icon bounds height) / 2.0) rounded)]</body></methods><methods><class-id>VWHelp.ArborCenteredLabelAndIcon</class-id> <category>displaying</category><body package="Arbor Help System Outline Help Core">displayOn: aGraphicsContext	"Display the receiver on aGraphicsContext. The receiver may alter	aGraphicsContext in any way it chooses."	icon notNil ifTrue: [icon displayOn: aGraphicsContext at: self iconOffset].	self displayTextOn: aGraphicsContext</body><body package="Arbor Help System Outline Help Core">displayTextOn: aGraphicsContext	| scanner wid yDelta |	(text == nil or: [text isEmpty]) ifTrue: 	[^self].	icon == nil ifTrue: [^super displayTextOn: aGraphicsContext].	yDelta := (self attributes lineGrid &gt; icon preferredBounds height)					ifTrue: [self offset y]					ifFalse: [self offset y + ((icon preferredBounds height - self attributes lineGrid) / 2.0) rounded].	wid := (width == nil ifTrue: [SmallInteger maxVal] ifFalse: [width]).	scanner := DisplayScanner new.	scanner textStyle: self attributes.	scanner		displayLine: (1 to: text size)		inText: text		left: self left		right: wid		top: yDelta		on: aGraphicsContext.</body></methods><methods><class-id>VWHelp.AHSReporter</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">writeBodyTo: aStream	"Write each of the topic texts to aStream"	rows do: [:row | row writeTopicBodyTo: aStream].</body><body package="Arbor Help System Outline Help Core">writeOutlineAsText	"Answer the Outline Report as a Text object"	| textStream |	textStream := TextStream on: ''.	self writeOutlineWithTOCOn: textStream.	^ textStream contents</body><body package="Arbor Help System Outline Help Core">writeOutlineWithTOCOn: aStream	"Answer the Outline Report as a Text object"	rows do: [:row | row writeTopicLineTo: aStream].	self 		writeSeparatorTo: aStream;		writeBodyTo: aStream.</body><body package="Arbor Help System Outline Help Core">writeSeparatorTo: aStream	aStream 		nextPutAll: '**********************************************************************' ;		cr.</body></methods><methods><class-id>VWHelp.AHSReporter</class-id> <category>initialization</category><body package="Arbor Help System Outline Help Core">initFromOutline: anOutline	"Private - Initialize the receiver with information found in anOutline."	rows := OrderedCollection new.	anOutline topNodesDo: [:aTopic | rows add: (AHSReporterData onTopic: aTopic)].</body></methods><methods><class-id>VWHelp.AHSReporter</class-id> <category>writing</category><body package="Arbor Help System Outline Help Core">text	"answers the report as a Text object"	^self writeOutlineAsText</body><body package="Arbor Help System Outline Help Core">writeToFileNamed: aString	"Writes the Outline Report to the file named aString"	| ws |	ws := aString asFilename writeStream.	[self writeOutlineWithTOCOn: ws]		ensure: [ws close].</body></methods><methods><class-id>VWHelp.AHSReporter class</class-id> <category>instance creation</category><body package="Arbor Help System Outline Help Core">on: anOutline 	"creates a HelpReport from the contents of anOutline"	 ^ self new		 initFromOutline: anOutline</body></methods><methods><class-id>VWHelp.ArborAbstractTree</class-id> <category>testing</category><body package="Arbor Help System Outline Help Core">hasChildren	"Answer whether the receiver has children"	^self isLeaf not</body><body package="Arbor Help System Outline Help Core">hasParent	"Answer whether the receiver has a parent."	^self isRoot not</body><body package="Arbor Help System Outline Help Core">isEmpty	"Answer whether the receiver contains any elements."	"Trees always contain at least the receiver. 	Note that this is different than whether the receiver is an empty 	tree, which implies that it has no children"	^false</body><body package="Arbor Help System Outline Help Core">isLeaf	"Answer whether or not this tree is a leaf"	^self children isEmpty</body><body package="Arbor Help System Outline Help Core">isRoot	"Answer true if the receiver is the top node in the tree hierarchy"	^self parent isNil</body></methods><methods><class-id>VWHelp.ArborAbstractTree</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">ancestors	"Answer an ordered collection of the receiver's ancestors, starting with the root.  Do not include the receiver."	| ancestors ancestor |	ancestor := self.	ancestors := self species new: 10.	[(ancestor := ancestor parent) notNil]		whileTrue: [ancestors addFirst: ancestor].	^ancestors</body><body package="Arbor Help System Outline Help Core">children	"Answer a collection of the children Trees"	"For performance reasons, I answer the collection that I own.	Senders should not modify the returned collection, but should modify the	children via other messages sent to me."	^children</body><body package="Arbor Help System Outline Help Core">children: anOrderedCollectionOfTrees	"Set the children Trees"	anOrderedCollectionOfTrees do: [:tree | tree parent: self].	children := anOrderedCollectionOfTrees</body><body package="Arbor Help System Outline Help Core">depth	^self isRoot		ifTrue: [0]		ifFalse: [self parent depth + 1]</body><body package="Arbor Help System Outline Help Core">parent	^parent</body><body package="Arbor Help System Outline Help Core">parent: aTree	"Should only be called from the receiver or from another Tree"	parent := aTree.</body><body package="Arbor Help System Outline Help Core">root	"Answer the node that acts as the root for the tree."	^self isRoot		ifTrue: [self]		ifFalse: [self parent root]</body><body package="Arbor Help System Outline Help Core">siblings	"Answer my siblings (including me)"	^self isRoot		ifTrue: [self species with: self]		ifFalse: [self parent children]</body><body package="Arbor Help System Outline Help Core">withAncestors	"Answer my ancestors up to and including me, root first."	^self ancestors addLast: self; yourself</body></methods><methods><class-id>VWHelp.ArborAbstractTree</class-id> <category>copying</category><body package="Arbor Help System Outline Help Core">copyEmpty: aSize	"Answer a copy of the receiver that contains no elements"	self shouldNotImplement</body><body package="Arbor Help System Outline Help Core">postCopy	super postCopy.	self children: (self children collect: [:child | child copy parent: self]).</body></methods><methods><class-id>VWHelp.ArborAbstractTree</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">do: aBlock after: aTree	"Start an iteration in my children AFTER aTree, then proceed to request the same from my parent."	| index kids |	index := (kids := self children copy) indexOf: aTree ifAbsent: [^self].	index + 1 to: kids size do: [:i |		(kids at: i) do: aBlock].	self isRoot not ifTrue: [self parent do: aBlock after: self].</body><body package="Arbor Help System Outline Help Core">species	"Answer the preferred class for reconstructing the receiver.	Doing a select: or a collect: on a Tree results in an OrderedCollection.	This is kind of a hack, but then so is the species method in the first place"	^OrderedCollection</body></methods><methods><class-id>VWHelp.ArborAbstractTree</class-id> <category>enumerating</category><body package="Arbor Help System Outline Help Core">do: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument."	"Evaluate by default in preorder"	self preorderDo: aBlock</body><body package="Arbor Help System Outline Help Core">postorderDo: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument."	self children copy do: [:child | child postorderDo: aBlock].	aBlock value: self.</body><body package="Arbor Help System Outline Help Core">preorderDo: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument."	aBlock value: self.	self children copy do: [:child | child preorderDo: aBlock]</body><body package="Arbor Help System Outline Help Core">remainderDo: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  Same as #do: except the receiver will NOT evaluate aBlock and will forward iteration to its parent in order to complete iteration over the rest of the tree."	self children copy do: [:child | child do: aBlock].	self isRoot not ifTrue: [self parent do: aBlock after: self].</body></methods><methods><class-id>VWHelp.ArborAbstractTree</class-id> <category>printing</category><body package="Arbor Help System Outline Help Core">printOn: aStream	aStream		nextPutAll: self class name;		nextPut: $(.	self size - 1 storeOn: aStream.	aStream nextPutAll: ' child nodes)'.</body><body package="Arbor Help System Outline Help Core">storeOn: aStream 	"Append to the argument aStream a sequence of characters that is an expression 	whose evaluation creates an collection similar to the receiver."	self notYetImplemented</body></methods><methods><class-id>VWHelp.ArborAbstractTree</class-id> <category>adding</category><body package="Arbor Help System Outline Help Core">add: newObject 	"Include newObject as one of the receiver's elements.  Answer newObject.	This message should not be sent to instances of subclasses of ArrayedCollection."	"Ambiguous concept for trees"	self shouldNotImplement</body><body package="Arbor Help System Outline Help Core">addChild: aTree 	"Add aTree to the end of the ordered list of children"	self		addChild: aTree		after: (self children isEmpty				ifTrue: [nil]				ifFalse: [self children last]).</body><body package="Arbor Help System Outline Help Core">addChild: aTree after: aSiblingTree	"Add aTree to the ordered list of children, after aSiblingTree.	If aSiblingTree is nil, then add it to the beginning."	aSiblingTree isNil		ifTrue: [self children addFirst: aTree]		ifFalse: [self children add: aTree after: aSiblingTree].	aTree parent: self.</body><body package="Arbor Help System Outline Help Core">addChild: aTree before: aSiblingTree	"Add aTree to the ordered list of children, before aSiblingTree.	If aSiblingTree is nil, then add it to the end."	aSiblingTree isNil		ifTrue: [self children addLast: aTree]		ifFalse: [self children add: aTree before: aSiblingTree].	aTree parent: self.</body></methods><methods><class-id>VWHelp.ArborAbstractTree</class-id> <category>removing</category><body package="Arbor Help System Outline Help Core">remove: oldObject ifAbsent: anExceptionBlock 	"Remove oldObject as one of the receiver's elements.  If several of the	elements are equal to oldObject, only one is removed. If no element is equal to	oldObject, answer the result of evaluating anExceptionBlock.  Otherwise,	answer the argument, oldObject."	self notYetImplemented</body><body package="Arbor Help System Outline Help Core">removeChild: aTree	^self removeChild: aTree ifAbsent: [self notFoundError]</body><body package="Arbor Help System Outline Help Core">removeChild: aTree ifAbsent: anExceptionBlock 	"Remove aTree as one of the receiver's children.  If no child is equal to	aTree, answer the result of evaluating anExceptionBlock.  Otherwise,	answer the argument, aTree."	| fail result |	fail := false.	result := self children				remove: aTree				ifAbsent: [					fail := true.					anExceptionBlock].	fail not ifTrue: [aTree parent: nil].	^result</body></methods><methods><class-id>VWHelp.ArborAbstractTree</class-id> <category>initialize-release</category><body package="Arbor Help System Outline Help Core">initialize	self children: self species new.</body></methods><methods><class-id>VWHelp.ArborAbstractTree</class-id> <category>converting</category><body package="Arbor Help System Outline Help Core">asOrderedCollection	"Answer a new instance of OrderedCollection whose elements are the elements of	the receiver.  The order in which elements are added depends on the order in	which the receiver enumerates its elements.  In the case of unordered collections,	the ordering is not necessarily the same for multiple requests for the conversion."	"Optimized so size is not sent, which iterates the whole tree"	| anOrderedCollection |	anOrderedCollection := OrderedCollection new.	self do: [:each | anOrderedCollection addLast: each].	^anOrderedCollection</body></methods><methods><class-id>VWHelp.ArborAbstractTree class</class-id> <category>instance creation</category><body package="Arbor Help System Outline Help Core">new	^super new initialize</body></methods><methods><class-id>VWHelp.AHSTree</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">children: anOrderedCollectionOfTrees	"Set the children Trees"	self odbDirty.	super children: anOrderedCollectionOfTrees</body><body package="Arbor Help System Outline Help Core">data	"Answer the data object associated with the receiver"	^data</body><body package="Arbor Help System Outline Help Core">data: anObject	"Set the data object associated with the receiver"	self odbDirty.	data := anObject</body><body package="Arbor Help System Outline Help Core">dataTextValue	"Answer a hyper text represenation of the text held on to by the data."	^ self data text asAHSHyperText.</body><body package="Arbor Help System Outline Help Core">parent: aTree	"Should only be called from the receiver or from another Tree"	self odbDirty.	super parent: aTree</body><body package="Arbor Help System Outline Help Core">treeTop	"Answer a copy of the receiver which represents the top most element of the tree."	| result |	result := self copy.	result children: OrderedCollection new.	^ result.</body></methods><methods><class-id>VWHelp.AHSTree</class-id> <category>adding</category><body package="Arbor Help System Outline Help Core">addChild: aTree 	"Add aTree to the end of the ordered list of children"	self odbDirty.	children odbDirty.	super addChild: aTree</body><body package="Arbor Help System Outline Help Core">addChild: aTree after: aSiblingTree	"Add aTree to the ordered list of children, after aSiblingTree.	If aSiblingTree is nil, then add it to the beginning."	self odbDirty.	children odbDirty.	super addChild: aTree after: aSiblingTree</body></methods><methods><class-id>VWHelp.AHSTree</class-id> <category>removing</category><body package="Arbor Help System Outline Help Core">removeChild: aTree ifAbsent: anExceptionBlock 	"Remove aTree as one of the receiver's children.  If no child is equal to	aTree, answer the result of evaluating anExceptionBlock.  Otherwise,	answer the argument, aTree."	self odbDirty.	children odbDirty.	^super removeChild: aTree ifAbsent: anExceptionBlock</body></methods><methods><class-id>VWHelp.AHSTree</class-id> <category>copying</category><body package="Arbor Help System Outline Help Core">postCopy	super postCopy.	data := data copy</body></methods><methods><class-id>VWHelp.AHSTree</class-id> <category>converting</category><body package="Arbor Help System Outline Help Core">asText	^self data asText.</body></methods><methods><class-id>VWHelp.AHSTree</class-id> <category>printing</category><body package="Arbor Help System Outline Help Core">printOn: aStream	"print data out"	aStream nextPutAll: self class name;			   nextPut: $(;		        nextPutAll: self data printString;			   nextPut: $);			    cr</body></methods><methods><class-id>VWHelp.AHSTree</class-id> <category>testing</category><body package="Arbor Help System Outline Help Core">dataHasText	"Answer true if the data held on to by the receiver has non-empty text."	^ self data text isEmpty not</body></methods><methods><class-id>VWHelp.AHSTree</class-id> <category>odb support</category><body package="Arbor Help System Outline Help Core">odbDeepRefresh	"Refresh self and everything underneath me."	self odbRefreshIfNotDirty.	self children odbRefreshIfNotDirty.	self children do: [:aChild |					aChild odbDeepRefresh].	self data odbRefreshIfNotDirty.</body></methods><methods><class-id>VWHelp.AHSTree class</class-id> <category>instance creation</category><body package="Arbor Help System Outline Help Core">data: anObject	^self new data: anObject</body></methods><methods><class-id>VWHelp.AHSTree class</class-id> <category>boss conversion</category><body package="Arbor Help System Outline Help Core">binaryRepresentationVersion	^'Help System version 2.0'</body></methods><methods><class-id>VWHelp.ArborHierarchicalSequenceController</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">outlineModel	"Answer the outline model, generally an instance of ArborListOutlineBrowserModel."	^self dispatcher receiver</body></methods><methods><class-id>VWHelp.ArborHierarchicalSequenceController</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">toggleIndex: anInteger	"Select the index being toggled."	self outlineModel notNil		ifTrue: [self outlineModel toggleIndex: anInteger fully: self sensor ctrlDown].</body></methods><methods><class-id>VWHelp.ArborHierarchicalSequenceController</class-id> <category>event driven</category><body package="Arbor Help System Outline Help Core">selectionTracker	^ArborHierarchicalSequenceSelectionTracker on: self</body></methods><methods><class-id>VWHelp.ArborHierarchicalSequenceController</class-id> <category>control defaults</category><body package="Arbor Help System Outline Help Core">redButtonActivity	|pt index|	pt := sensor cursorPoint.	((index := self findElementFor: pt) ~= 0		and: [sensor redButtonPressed		and: [self view isHotspot: pt]])			ifTrue: [				self view showTransition: true for: index.				sensor waitNoButton.				pt := sensor cursorPoint.				((self findElementFor: pt) = index and: [view isHotspot: pt])					ifTrue: [						self view inTransition: false.						self toggleIndex: index]					ifFalse: [self view showTransition: false for: index]]			ifFalse: [super redButtonActivity]</body></methods><methods><class-id>VWHelp.AHSHelpHyperText</class-id> <category>converting</category><body package="Arbor Help System Outline Help Core">asAHSHyperText	^self</body></methods><methods><class-id>VWHelp.AHSHelpHyperText</class-id> <category>printing</category><body package="Arbor Help System Outline Help Core">printLinksOn: aStream	"Print information on the links stored in the AHSHelpHyperText"	self emphasesDo: [:emphasis :range |		(self isHyperLink: emphasis)			ifTrue: [				self					printRunOffset: range first					emphasis: emphasis					text: (self copyFrom: range first to: range last)					on: aStream]].</body><body package="Arbor Help System Outline Help Core">printRunOffset: anInteger emphasis: anEmphasis text: aText on: aStream	anInteger printOn: aStream.	aStream nextPut: $,.	anEmphasis value printOn: aStream.	aStream 		nextPutAll: (',"' , aText );		nextPut: $";		cr</body></methods><methods><class-id>VWHelp.AHSHelpHyperText</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">firstAvailableGlossary	"returns the first available Glossary link found in the text or nil"	^self firstAvailable: [:item | self isGlossary: item]</body><body package="Arbor Help System Outline Help Core">firstAvailableHyperGraphic	"returns the first available Hyper Graphic link found in the text or nil"	^self firstAvailable: [:item | self isHyperGraphic: item]</body><body package="Arbor Help System Outline Help Core">firstAvailableHyperText	"returns the first available Hyper Text link found in the text or nil"	^self firstAvailable: [:item | self isHyperText: item]</body></methods><methods><class-id>VWHelp.AHSHelpHyperText</class-id> <category>testing</category><body package="Arbor Help System Outline Help Core">isGlossary: anEmphasis	"Returns true if anEmphasis is a Glossary hyperlink"	^(self isHyperLink: anEmphasis) and:[anEmphasis value isGlossary]</body><body package="Arbor Help System Outline Help Core">isHyperGraphic: anEmphasis	"Returns true if anEmphasis is a HyperGraphic hyperlink"	^(self isHyperLink: anEmphasis) and:[anEmphasis value isHyperGraphic]</body><body package="Arbor Help System Outline Help Core">isHyperText: anEmphasis	"Returns true if anEmphasis is a HyperText hyperlink"	^(self isHyperLink: anEmphasis) and:[anEmphasis value isHyperText]</body></methods><methods><class-id>VWHelp.AHSHelpHyperText</class-id> <category>comparing</category><body package="Arbor Help System Outline Help Core">= anotherText	"Do a full equality check, including the runs."	^AHSUtils text: self equals: anotherText</body></methods><methods><class-id>VWHelp.AHSHelpHyperText class</class-id> <category>BOSS conversion</category><body package="Arbor Help System Outline Help Core">binaryReaderBlockForVersion: oldVersion format: oldFormat	^oldVersion = 'Help System version 2.0'		ifTrue: [self convertBlock20]		ifFalse: [			super 				binaryReaderBlockForVersion: oldVersion 				format: oldFormat]</body><body package="Arbor Help System Outline Help Core">binaryRepresentationVersion	^'AHS 3.0'</body><body package="Arbor Help System Outline Help Core">convertBlock20	"Answer the conversion block for AHS Version 2.0"	| inst new textRuns linkRuns textIndex removeArray |	^ [:oldObj |		inst := self basicNew.		new := Array new: (oldObj size - 2).		new 			at: 1 			put: (oldObj at: 1).		textRuns := (oldObj at: 2).		linkRuns := (oldObj at: 3).		textIndex := 1.		1 to: linkRuns values size do:			[ :index || item emphasisArray | 			((item := linkRuns values at: index) notNil) ifTrue:				[(item isKindOf: Array) ifFalse:[item := Array with: item].				emphasisArray := (item 									inject: OrderedCollection new 									into: [:oc :next | oc add: (ArborHyperlinkAssociation value: next). oc])										asArray. 				removeArray := Array new.				item do: [:each | removeArray := removeArray , each class textEmphasis]. 				textRuns := textRuns 							add: emphasisArray 							remove: removeArray 							duplicate: false 							from: textIndex 							to: (textIndex + (linkRuns runs at: index) - 1)].			textIndex := textIndex + (linkRuns runs at: index)]. 		new 			at: 2 			put: textRuns.		oldObj become: new.		oldObj changeClassToThatOf: inst]</body></methods><methods><class-id>VWHelp.AHSHyperGraphicLinkObject</class-id> <category>testing</category><body package="Arbor Help System Outline Help Core">captionIsAtCenter	^self captionLocation = #center</body><body package="Arbor Help System Outline Help Core">captionIsAtLeft	^self captionLocation = #left</body><body package="Arbor Help System Outline Help Core">captionIsAtRight	^self captionLocation = #right</body><body package="Arbor Help System Outline Help Core">hasCaption	^self caption notNil and: [self caption isEmpty not]</body><body package="Arbor Help System Outline Help Core">isHyperGraphic	^true</body></methods><methods><class-id>VWHelp.AHSHyperGraphicLinkObject</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">caption	^caption</body><body package="Arbor Help System Outline Help Core">caption: aValue	caption := aValue asString.</body><body package="Arbor Help System Outline Help Core">captionLocation	^captionLocation</body><body package="Arbor Help System Outline Help Core">captionLocation: aSymbol	| sym |	sym := aSymbol asSymbol.	(#(left right center) includes: sym) not		ifTrue: [self error: 'Invalid caption location'].	captionLocation := sym.</body><body package="Arbor Help System Outline Help Core">imageProportion	^imageProportion</body><body package="Arbor Help System Outline Help Core">imageProportion: aValue	imageProportion := aValue</body><body package="Arbor Help System Outline Help Core">isEmbedded	^isEmbedded</body><body package="Arbor Help System Outline Help Core">isEmbedded: aBoolean	isEmbedded := aBoolean.</body><body package="Arbor Help System Outline Help Core">windowExtent	^windowExtent</body><body package="Arbor Help System Outline Help Core">windowExtent: aPoint	windowExtent := aPoint</body></methods><methods><class-id>VWHelp.AHSHyperGraphicLinkObject</class-id> <category>engaging</category><body package="Arbor Help System Outline Help Core">engageFor: anObject	"The hyperlink has been engaged within the context of anObject."	^anObject engageHyperGraphic: self</body></methods><methods><class-id>VWHelp.AHSHyperGraphicLinkObject</class-id> <category>attributes</category><body package="Arbor Help System Outline Help Core">attributes	^super attributes, #(key caption imageProportion width height embedded captionLocation)</body><body package="Arbor Help System Outline Help Core">embedded	"Attributes must be either a number, a string, or nil.  If an attribute is nil, it is ignored."	^self isEmbedded		ifTrue: ['y']		ifFalse: ['n']</body><body package="Arbor Help System Outline Help Core">embedded: aValue	"Attributes must be either a number, a string, or nil.  If an attribute is nil, it is ignored."	aValue notNil ifTrue: [self isEmbedded: (aValue = 'y')].</body><body package="Arbor Help System Outline Help Core">height	^self windowExtent isNil		ifTrue: [nil]		ifFalse: [self windowExtent y]</body><body package="Arbor Help System Outline Help Core">height: aValue	aValue notNil ifTrue: [		self windowExtent isNil ifTrue: [self windowExtent: 100@100].		self windowExtent y: aValue].</body><body package="Arbor Help System Outline Help Core">key	^self linkObject asString</body><body package="Arbor Help System Outline Help Core">key: aValue	^self linkObject: aValue asSymbol</body><body package="Arbor Help System Outline Help Core">width	^self windowExtent isNil		ifTrue: [nil]		ifFalse: [self windowExtent x]</body><body package="Arbor Help System Outline Help Core">width: aValue	aValue notNil ifTrue: [		self windowExtent isNil ifTrue: [self windowExtent: 100@100].		self windowExtent x: aValue].</body></methods><methods><class-id>VWHelp.AHSHyperGraphicLinkObject</class-id> <category>copying</category><body package="Arbor Help System Outline Help Core">postCopy	super postCopy.	imageProportion := imageProportion copy.	caption := caption copy.	windowExtent := windowExtent copy.</body></methods><methods><class-id>VWHelp.AHSHyperGraphicLinkObject</class-id> <category>printing</category><body package="Arbor Help System Outline Help Core">printOn: aStream	aStream nextPutAll: 'HyperGraphic,'.	self linkObject printOn: aStream.</body></methods><methods><class-id>VWHelp.AHSHyperGraphicLinkObject</class-id> <category>AHS Export adds</category><body package="Arbor Help System Outline Help Core">writeHyperlinkUsing: aTopicBodyWriter	^aTopicBodyWriter writeHypergraphicLink: self</body></methods><methods><class-id>VWHelp.AHSHyperGraphicLinkObject</class-id> <category>initialize-release</category><body package="Arbor Help System Outline Help Core">initialize	super initialize.	self caption: 'Enter Caption Text Here' asText.	self imageProportion: 0.75.		"Only used if isEmbedded is false"	self windowExtent: nil.			"Only used if isEmbedded is false"	self isEmbedded: false.	self captionLocation: #center.	"Only used if isEmbedded is true"</body></methods><methods><class-id>VWHelp.AHSHyperGraphicLinkObject class</class-id> <category>instance creation</category><body package="Arbor Help System Outline Help Core">newGraphicLink: aSymbol caption: aString	"creates an instance of a graphic link with a caption"	^self new		linkObject: aSymbol;		caption: aString</body><body package="Arbor Help System Outline Help Core">newGraphicLink: aSymbol caption: aString proportion: anInteger extent: aPoint	"creates an instance of a graphic link with a caption"	^self new		linkObject: aSymbol;		caption: aString;		imageProportion: anInteger;		windowExtent: aPoint</body></methods><methods><class-id>VWHelp.AHSHyperGraphicLinkObject class</class-id> <category>color &amp; emphasis</category><body package="Arbor Help System Outline Help Core">defaultColor	^self defaultColorValueClass blue</body><body package="Arbor Help System Outline Help Core">defaultEmphasis	^#italic</body></methods><methods><class-id>VWHelp.AHSHyperGraphicLinkObject class</class-id> <category>attributes</category><body package="Arbor Help System Outline Help Core">type	"Answer a unique identifier for the type, used during RTF exports to indicate the type of the link."	^#graphic</body></methods><methods><class-id>VWHelp.AHSHyperGraphicViewer</class-id> <category>aspects</category><body package="Arbor Help System Outline Help Core">availableGraphics	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^ availableGraphics isNil 		ifTrue: [availableGraphics := SelectionInList new] 		ifFalse: [availableGraphics]</body><body package="Arbor Help System Outline Help Core">graphic	graphic isNil ifTrue: 		[graphic := AHSGraphicView new						model: self blankImage;						yourself].	^ graphic</body></methods><methods><class-id>VWHelp.AHSHyperGraphicViewer</class-id> <category>interface opening</category><body package="Arbor Help System Outline Help Core">openAsDialog	| dlog |	dlog :=SimpleDialog new.	self builder: dlog builder.	dlog preBuildBlock: [:mdl :bldr | self preBuildWith: bldr].	dlog postBuildBlock: [:mdl :bldr | self postBuildWith: bldr].	^ dlog 		openFor: self 		interface: #windowSpec</body><body package="Arbor Help System Outline Help Core">postBuildWith: aBuilder 	super postBuildWith: aBuilder.	self updateGraphicsList.	self availableGraphics selectionIndexHolder 		onChangeSend: #graphicSelectionChanged 		to: self.</body></methods><methods><class-id>VWHelp.AHSHyperGraphicViewer</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">currentGraphicKey	"Answer the currently selected graphic key."	^ self availableGraphics selection</body><body package="Arbor Help System Outline Help Core">graphicsDictionary	"Private - Answer the dictionary of all graphic images."	^ self outline graphicsDictionary</body><body package="Arbor Help System Outline Help Core">graphicsKeys	"Private - Answer an ordered collection of all the graphic keys."	^List withAll: self graphicsDictionary keys asSortedCollection</body><body package="Arbor Help System Outline Help Core">listMenu	listMenu isNil ifTrue: [listMenu := Menu new asValue].	^ listMenu</body><body package="Arbor Help System Outline Help Core">outline	^ outliner outline</body><body package="Arbor Help System Outline Help Core">outliner	^ outliner</body><body package="Arbor Help System Outline Help Core">outliner: anOutliner	outliner := anOutliner</body></methods><methods><class-id>VWHelp.AHSHyperGraphicViewer</class-id> <category>events</category><body package="Arbor Help System Outline Help Core">noticeOfWindowClose: aWindow	self graphicsDictionary odbReleaseUnDirtyLock.	^ super noticeOfWindowClose: aWindow</body></methods><methods><class-id>VWHelp.AHSHyperGraphicViewer</class-id> <category>change messages</category><body package="Arbor Help System Outline Help Core">graphicSelectionChanged	"The availableGraphics selection has changed."	self currentGraphicKey isNil		ifTrue: [self clearGraphic]		ifFalse: [self setGraphic].	graphic invalidate</body></methods><methods><class-id>VWHelp.AHSHyperGraphicViewer</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">blankImage	"Private - Answer a blank image which can be displayed."	^ Image 		extent: 0 @ 0 		depth: 1 		palette: MappedPalette whiteBlack</body><body package="Arbor Help System Outline Help Core">clearGraphic	"Private - Clear the graphic pane."	graphic model: self blankImage</body><body package="Arbor Help System Outline Help Core">setGraphic	"Private - Set the graphic which is displayed to correspond to the current key selection."	graphic model: (self outliner graphicAt: self currentGraphicKey)</body><body package="Arbor Help System Outline Help Core">updateGraphicsList	"Private - Update the graphics list with keys from the graphics dictionary."	self availableGraphics list: self graphicsKeys</body></methods><methods><class-id>VWHelp.AHSHyperGraphicViewer class</class-id> <category>interface opening</category><body package="Arbor Help System Outline Help Core">openFrom: anOutliner modal: aBoolean	"Builds or removes a hyperGraphic link."	| me |	me := self new.	me outliner: anOutliner.	aBoolean		ifTrue: [me openAsDialog]		ifFalse: [me open]</body><body package="Arbor Help System Outline Help Core">showGraphicLinkedTo: aLinkObject onHelpOutliner: aHelpOutliner 	"Shows the graphic (if any) associated to the information stored in aLinkObject."	| image mdl |	image := aHelpOutliner outline				graphicAt: aLinkObject linkObject				ifAbsent: [^self notFoundGraphic: aLinkObject linkObject].	mdl := self graphicScreenClass				onImage: image				link: aLinkObject				parent: aHelpOutliner ahsWindow.	aHelpOutliner ahsWindow isModalDialog		ifTrue: [mdl openAsDialog]		ifFalse: [mdl open].</body></methods><methods><class-id>VWHelp.AHSHyperGraphicViewer class</class-id> <category>defaults</category><body package="Arbor Help System Outline Help Core">graphicScreenClass	^AHSGraphicScreen</body></methods><methods><class-id>VWHelp.AHSHyperGraphicViewer class</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">messageCatalogID	^#arborHelpSystem</body></methods><methods><class-id>VWHelp.AHSHyperGraphicViewer class</class-id> <category>errors</category><body package="Arbor Help System Outline Help Core">notFoundGraphic: aGraphicName	^Dialog warn: 'The graphic named ' , aGraphicName printString , ' no longer exists.'</body></methods><methods><class-id>VWHelp.AHSFullGlossaryViewer</class-id> <category>aspects</category><body package="Arbor Help System Outline Help Core">fullGlossaryList	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	fullGlossaryList isNil ifTrue: [fullGlossaryList := SelectionInList new].	^ fullGlossaryList</body><body package="Arbor Help System Outline Help Core">fullGlossaryText	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	fullGlossaryText isNil ifTrue: [fullGlossaryText := String new asValue].	^ fullGlossaryText</body></methods><methods><class-id>VWHelp.AHSFullGlossaryViewer</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">clearGlossaryText	"Private - Clear the glossary text currently displayed."	self glossaryText: ''</body><body package="Arbor Help System Outline Help Core">setGlossaryText	"Private - Set the contents of the glossary text pane to the glossary value associated with the selected glossary entry."	self glossaryText: self currentGlossaryEntry</body><body package="Arbor Help System Outline Help Core">updateGlossaryList	"Private - Update the glossary list with keys from the glossary dictionary."	self fullGlossaryList list: self dictionary keys asSortedCollection.</body></methods><methods><class-id>VWHelp.AHSFullGlossaryViewer</class-id> <category>events</category><body package="Arbor Help System Outline Help Core">noticeOfWindowClose: aWindow	self dictionary odbReleaseUnDirtyLock.	^ super noticeOfWindowClose: aWindow</body></methods><methods><class-id>VWHelp.AHSFullGlossaryViewer</class-id> <category>interface opening</category><body package="Arbor Help System Outline Help Core">openAsDialog	| dlog |	dlog := SimpleDialog new.	self builder: dlog builder.	dlog preBuildBlock: [:mdl :bldr | self preBuildWith: bldr].	dlog postBuildBlock: [:mdl :bldr | self postBuildWith: bldr].	^ dlog		openFor: self 		interface: #windowSpec</body><body package="Arbor Help System Outline Help Core">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self updateGlossaryList.	self fullGlossaryList selectionIndexHolder 		onChangeSend: #selectionChanged 		to: self.</body></methods><methods><class-id>VWHelp.AHSFullGlossaryViewer</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">currentGlossaryEntry	"Answer the glossary entry for the current key."	^ self outliner glossaryAt: self currentGlossaryKey</body><body package="Arbor Help System Outline Help Core">currentGlossaryKey	"Answer the current glossary key selection"	^ self fullGlossaryList selection</body><body package="Arbor Help System Outline Help Core">dictionary	^ self outline glossaryDictionary</body><body package="Arbor Help System Outline Help Core">glossaryText: aValue	"Private- Set the text to be displayed for the current glossary entry."	^ self fullGlossaryText value: aValue</body><body package="Arbor Help System Outline Help Core">outline	^ self parent outline</body><body package="Arbor Help System Outline Help Core">outliner	^self parent</body><body package="Arbor Help System Outline Help Core">parent	^ parent</body><body package="Arbor Help System Outline Help Core">parent: anApplicationModel	^ parent := anApplicationModel</body></methods><methods><class-id>VWHelp.AHSFullGlossaryViewer</class-id> <category>change messages</category><body package="Arbor Help System Outline Help Core">selectionChanged	self fullGlossaryText retractInterestsFor: self.	self currentGlossaryKey isNil		ifTrue: [self clearGlossaryText]		ifFalse: [self setGlossaryText].	self fullGlossaryText 		onChangeSend: #textChanged 		to: self</body></methods><methods><class-id>VWHelp.AHSFullGlossaryViewer class</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">messageCatalogID	^#arborHelpSystem</body></methods><methods><class-id>VWHelp.AHSFullGlossaryViewer class</class-id> <category>interface opening</category><body package="Arbor Help System Outline Help Core">fullGlossaryDialogOn: anOutliner	^ self new initialize		parent: anOutliner; 		openAsDialog</body><body package="Arbor Help System Outline Help Core">fullGlossaryOn: anOutliner	^ self new		parent: anOutliner; 		open</body></methods><methods><class-id>VWHelp.AHSToolbarTextEditorController</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">emphasis: emph1 includes: emph2	^(self emphasisAsArray: emph1) includes: emph2</body><body package="Arbor Help System Outline Help Core">emphasisAsArray: anEmphasis	^(anEmphasis isSequenceable and: [anEmphasis isSymbol not])		ifTrue: [anEmphasis]		ifFalse: [Array with: anEmphasis]</body><body package="Arbor Help System Outline Help Core">fixIndentationFrom: start to: stop	"Ensure that the indentation is consistent from start to stop.  This means that if start is in the middle of a line, have it inherit the line's indentation, and if stop is in the middle of a line, continue that indentation to the end of the line."	| indentEmphasis indentDepthBlock lines offset |	self deselect.	indentEmphasis := AHSIndentableComposedText indentKey-&gt;0.	indentDepthBlock := [:emphasis |		((self emphasisAsArray: emphasis)			detect: [:emph | emph supersedesAsTextEmphasis: indentEmphasis]			ifNone: [indentEmphasis]) value].	(lines := self lineRangesBetween: start and: stop) isEmpty not ifTrue: [		lines first first &lt; start ifTrue: [			offset := (indentDepthBlock value: (self text rawEmphasisAt: start - 1))						- (indentDepthBlock value: (self text rawEmphasisAt: start)).			offset ~= 0 ifTrue: [self changeIndentFrom: start to: stop by: offset]].		((stop + 1) &lt;= lines last last) ifTrue: [			offset := (indentDepthBlock value: (self text rawEmphasisAt: stop))						- (indentDepthBlock value: (self text rawEmphasisAt: stop + 1)).			offset ~= 0 ifTrue: [self changeIndentFrom: stop + 1 to: lines last last by: offset]]].	self restoreSelection.</body><body package="Arbor Help System Outline Help Core">lineRangeAt: anIndex	"Answer an interval describing the start and end positions of the line encompassing anIndex.  The answered range WILL include the terminating carraige return (if one exists).  If anIndex is at the end of the text and the text is empty or the last character is a CR, the start will be less than the stop."	| end start |	anIndex &gt; self text size		ifTrue: [end := self text size]		ifFalse: [			end := anIndex.			[end &lt; self text size and: [(self text at: end) ~= Character cr]]				whileTrue: [end := end + 1]].	start := anIndex - 1.	[start &gt; 0 and: [(self text at: start) ~= Character cr]]		whileTrue: [start := start - 1].	start := start + 1.	^start to: end</body><body package="Arbor Help System Outline Help Core">lineRangesBetween: start and: stop	"Answer a collection of intervals describing the start and end positions of all lines intercepted by start and stop."	| ranges end |	end := stop = 0 ifTrue: [1] ifFalse: [self text size min: stop].	ranges := OrderedCollection new.	ranges add: (self lineRangeAt: start).	[ranges last last &lt; end]		whileTrue: [ranges addLast: (self lineRangeAt: ranges last last + 1)].	^ranges reject: [:r | r first &gt; r last]</body><body package="Arbor Help System Outline Help Core">resetState	"Maintain emphasisHere so buttons can take focus without losing it"	|oldEmphasisHere|	oldEmphasisHere := emphasisHere.	super resetState.	emphasisHere := oldEmphasisHere</body><body package="Arbor Help System Outline Help Core">selectionAllEmphasizedWith: anEmphasis	"Does the entire selection have the emphasis anEmphasis?"	|seln|	seln := self selection.	seln isEmpty		ifTrue: [^self emphasis: emphasisHere includes: anEmphasis].	1 to: seln size do: [:i |		(self emphasis: (seln rawEmphasisAt: i) includes: anEmphasis)			ifFalse: [^false]].	^true</body><body package="Arbor Help System Outline Help Core">silentCut	"Keep indentation consistent."	super silentCut.	self fixIndentationFrom: self selectionStartIndex to: self selectionStopIndex.</body></methods><methods><class-id>VWHelp.AHSToolbarTextEditorController</class-id> <category>editing-functions</category><body package="Arbor Help System Outline Help Core">backspaceKey: aCharEvent	"Keep indentation consistent."	self selectionStartIndex &lt; self selectionStopIndex		ifTrue: [super backspaceKey: aCharEvent]		ifFalse: [			super backspaceKey: aCharEvent.			self fixIndentationFrom: self selectionStartIndex to: self selectionStopIndex].</body><body package="Arbor Help System Outline Help Core">findNext	"Search for the next entry of the selected text."	^self findNextIgnoreCase: false</body><body package="Arbor Help System Outline Help Core">findNext: aString ignoreCase: aBoolean	"Search for the next entry of the aString."	| index |	index := (self text 				findString: aString				startingAt: self selectionStopIndex 				ignoreCase: aBoolean 				useWildcards: false) first.	index = 0 ifTrue: [^false].	self 		selectAndScrollFrom: index 		to: index + aString size - 1.	^ true</body><body package="Arbor Help System Outline Help Core">findNextIgnoreCase: aBoolean	"Search for the next entry of the selected text."	^self findNext: self selection ignoreCase: aBoolean</body></methods><methods><class-id>VWHelp.AHSToolbarTextEditorController</class-id> <category>editing</category><body package="Arbor Help System Outline Help Core">changeColor	|clr|	clr := AHSUtils pickColor: ColorValue black.	clr notNil		ifTrue: [self toggleEmphasis: #color-&gt;clr]		ifFalse: [self restoreSelection]</body><body package="Arbor Help System Outline Help Core">changeIndentBy: indentOffset	"Change the indent level for the lines identified by the selection."	self deselect.	(self selectionStartIndex &gt; self text size		and: [self text size isZero or: [(self text at: self text size) = Character cr]])			ifTrue: [				"Since the indentation is an emphasis, be sure there's a character there to emphasize so it will 'stick'."				self					replaceFrom: self text size + 1					to: self text size					with: ((String with: Character cr) asText							emphasizeAllWith: emphasisHere)].	(self lineRangesBetween: self selectionStartIndex and: self selectionStopIndex - 1)		do: [:range | self changeIndentFrom: range first to: range last by: indentOffset].	self indentEmphasisHereBy: indentOffset.	self restoreSelectionKeepingEmphasisHere.</body><body package="Arbor Help System Outline Help Core">changeIndentFrom: start to: stop by: indentOffset	| sel indentEmphasis skip oldSelStart oldSelStop later |	oldSelStart := self selectionStartIndex.	oldSelStop := self selectionStopIndex.	self selectionStartIndex: start stopIndex: stop + 1.	sel := self selection.	indentEmphasis := AHSIndentableComposedText indentKey-&gt;indentOffset.	skip := Set new.	later := Set new.	sel copy emphasesDo: [:emph :interval |		(skip includes: interval) not ifTrue: [			(indentEmphasis supersedesAsTextEmphasis: emph)				ifTrue: [					later remove: interval ifAbsent: [].					skip add: interval.					sel						addEmphasis: ((indentOffset positive or: [indentOffset abs &lt; emph value])											ifTrue: [Array with: emph key-&gt;(emph value + indentOffset)]											ifFalse: [#()])						removeEmphasis: ((indentOffset negative and: [indentOffset abs &gt;= emph value])											ifTrue: [Array with: indentEmphasis]											ifFalse: [#()])						allowDuplicates: false						from: interval first						to: interval last]				ifFalse: [later add: interval]]].	indentOffset positive ifTrue: [		later do: [:interval |			sel				addEmphasis: (Array with: indentEmphasis)				removeEmphasis: #()				allowDuplicates: false				from: interval first				to: interval last]].	self replaceSelectionWith: sel saveSelectionForUndo: false.	self selectionStartIndex: oldSelStart stopIndex: oldSelStop.</body><body package="Arbor Help System Outline Help Core">decreaseIndent	"Decrease the indent level for the lines identified by the selection by 1."	self changeIndentBy: -1.</body><body package="Arbor Help System Outline Help Core">deleteKey: aCharEvent	"Keep indentation consistent."	self selectionStartIndex &lt; self selectionStopIndex		ifTrue: [super deleteKey: aCharEvent]		ifFalse: [			super deleteKey: aCharEvent.			self fixIndentationFrom: self selectionStartIndex to: self selectionStopIndex].</body><body package="Arbor Help System Outline Help Core">increaseIndent	"Increase the indent level for the lines identified by the selection by 1."	self changeIndentBy: 1.</body><body package="Arbor Help System Outline Help Core">indentEmphasisHereBy: indentOffset	| txt indentEmphasis removeEmphasis |	txt := 'X' asArborHypertext emphasizeAllWith: emphasisHere.	indentEmphasis := AHSIndentableComposedText indentKey-&gt;0.	txt emphasesLike: indentEmphasis do: [:emph |		indentEmphasis value: emph value].	removeEmphasis := (indentEmphasis value + indentOffset) &lt;= 0.	txt		addEmphasis: (removeEmphasis								ifTrue: [#()]								ifFalse: [Array with: (indentEmphasis value:  indentEmphasis value + indentOffset)])		removeEmphasis: (removeEmphasis								ifTrue: [Array with: indentEmphasis]								ifFalse: [#()])		allowDuplicates: false.	emphasisHere := txt emphasisAt: 1.</body><body package="Arbor Help System Outline Help Core">toggleEmphasis: anEmphasis	|seln|	seln := self selection.	self deselect.	(self selectionAllEmphasizedWith: anEmphasis)		ifTrue: [self selection isEmpty				ifTrue: [(emphasisHere isKindOf: Array)						ifTrue: [emphasisHere := emphasisHere copyWithout: anEmphasis]						ifFalse: [emphasisHere := nil]]				ifFalse: [self replaceSelectionWith:						(seln addEmphasis: #()							removeEmphasis: (Array with: anEmphasis)							allowDuplicates: false)]]		ifFalse: [self selection isEmpty					ifTrue: [emphasisHere isNil								ifTrue: [emphasisHere := anEmphasis]								ifFalse: [(emphasisHere isKindOf: Array)									ifTrue: [emphasisHere := emphasisHere copyWith: anEmphasis]									ifFalse: [emphasisHere := Array with: emphasisHere with: anEmphasis]]]					ifFalse: [self replaceSelectionWith:						(seln addEmphasis: (Array with: anEmphasis)							removeEmphasis: #()							allowDuplicates: false)]].	self restoreSelectionKeepingEmphasisHere.</body></methods><methods><class-id>VWHelp.AHSToolbarTextEditorController</class-id> <category>selecting</category><body package="Arbor Help System Outline Help Core">restoreSelection	self selectFrom: self selectionStartIndex to: self selectionStopIndex - 1.	keyboardProcessor notNil		ifTrue: [keyboardProcessor requestActivationFor: self]</body><body package="Arbor Help System Outline Help Core">restoreSelectionKeepingEmphasisHere	| emph |	emph := emphasisHere.	self restoreSelection.	emphasisHere := emph.</body><body package="Arbor Help System Outline Help Core">selectAt: characterIndex	"When positioning, ensure that the default emphasis is set by the current location, not by the first character in the editor."	super selectAt: characterIndex.	self setEmphasisHere.</body></methods><methods><class-id>VWHelp.AHSToolbarTextEditorController</class-id> <category>menu messages</category><body package="Arbor Help System Outline Help Core">cut	"Keep indentation consistent."	super cut.	self fixIndentationFrom: self selectionStartIndex to: self selectionStopIndex.</body><body package="Arbor Help System Outline Help Core">paste	"Keep indentation consistent."	super paste.	self fixIndentationFrom: self selectionStartIndex to: self selectionStopIndex - 1.</body><body package="Arbor Help System Outline Help Core">undo	"Keep indentation consistent."	super undo.	self fixIndentationFrom: self selectionStartIndex to: self selectionStopIndex - 1.</body></methods><methods><class-id>VWHelp.AHSToolbarTextEditorController</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">deactivate	"Make this text field not be the keyboard focus"	view hasFocus: false.	self view isOpen ifTrue:		[self resetTypein.		self controlTerminate.		self focusOut]</body></methods><methods><class-id>VWHelp.AHSToolbarTextEditorController</class-id> <category>view access</category><body package="Arbor Help System Outline Help Core">view: aView	super view: aView.	self paragraph changeClassToThatOf: AHSIndentableComposedText new.</body></methods><methods><class-id>VWHelp.AHSGlossaryLinkObject</class-id> <category>attributes</category><body package="Arbor Help System Outline Help Core">attributes	^super attributes, #(key)</body><body package="Arbor Help System Outline Help Core">key	^self linkObject asString</body><body package="Arbor Help System Outline Help Core">key: aValue	^self linkObject: aValue asSymbol</body></methods><methods><class-id>VWHelp.AHSGlossaryLinkObject</class-id> <category>engaging</category><body package="Arbor Help System Outline Help Core">engageFor: anObject	"The hyperlink has been engaged within the context of anObject."	^anObject engageGlossary: self</body></methods><methods><class-id>VWHelp.AHSGlossaryLinkObject</class-id> <category>AHS Export adds</category><body package="Arbor Help System Outline Help Core">writeHyperlinkUsing: aTopicBodyWriter	^aTopicBodyWriter writeGlossaryLink: self</body></methods><methods><class-id>VWHelp.AHSGlossaryLinkObject</class-id> <category>testing</category><body package="Arbor Help System Outline Help Core">isGlossary	"Is my linkType a glossary type?"	^true</body></methods><methods><class-id>VWHelp.AHSGlossaryLinkObject</class-id> <category>printing</category><body package="Arbor Help System Outline Help Core">printOn: aStream	aStream nextPutAll: 'Glossary,'.	self linkObject printOn: aStream.</body></methods><methods><class-id>VWHelp.AHSGlossaryLinkObject class</class-id> <category>color &amp; emphasis</category><body package="Arbor Help System Outline Help Core">defaultColor	^self defaultColorValueClass darkRed</body><body package="Arbor Help System Outline Help Core">defaultEmphasis	^#italic</body></methods><methods><class-id>VWHelp.AHSGlossaryLinkObject class</class-id> <category>attributes</category><body package="Arbor Help System Outline Help Core">type	"Answer a unique identifier for the type, used during RTF exports to indicate the type of the link."	^#glossary</body></methods><methods><class-id>VWHelp.AHSCompositeCharacterBlock</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">localComponent	^localComponent</body><body package="Arbor Help System Outline Help Core">localComponent: aTextView	localComponent := aTextView.</body><body package="Arbor Help System Outline Help Core">localIndex	^localIndex</body><body package="Arbor Help System Outline Help Core">localIndex: anInteger	localIndex := anInteger.</body><body package="Arbor Help System Outline Help Core">localTranslation	^localTranslation</body><body package="Arbor Help System Outline Help Core">localTranslation: aPoint	localTranslation := aPoint.</body></methods><methods><class-id>VWHelp.AHSCompositeCharacterBlock</class-id> <category>converting</category><body package="Arbor Help System Outline Help Core">asLocalCharacterBlock	"Answer a character block that is relative to the localComponent."	^CharacterBlock		stringIndex: self localIndex		character: self character		boundingRectangle: (self translatedBy: self localTranslation negated)</body></methods><methods><class-id>VWHelp.AHSCompositeCharacterBlock class</class-id> <category>instance creation</category><body package="Arbor Help System Outline Help Core">stringIndex: anInteger translation: aPoint component: aView localBlock: aCharacterBlock	"Answer an instance of the receiver with values set to the arguments."	^self new		newStringIndex: anInteger			Character: aCharacterBlock character			BoundingRectangle: (aCharacterBlock translatedBy: aPoint);		localIndex: aCharacterBlock stringIndex;		localTranslation: aPoint;		localComponent: aView</body></methods><methods><class-id>VWHelp.AHSGraphicScreen</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">builtWindow	^ self builder window</body><body package="Arbor Help System Outline Help Core">captionWidget	^self builder componentAt: #annotatedGraphicSubCanvas</body><body package="Arbor Help System Outline Help Core">doneButton	^ (self builder componentAt: #doneButton)</body><body package="Arbor Help System Outline Help Core">graphicLink	graphicLink isNil		ifTrue: [graphicLink := AHSHyperGraphicLinkObject new asValue].	^graphicLink</body><body package="Arbor Help System Outline Help Core">graphicLink: aHyperGraphicLink	aHyperGraphicLink isNil		ifTrue: [self graphicLink setValue: nil]		ifFalse: [self graphicLink value: aHyperGraphicLink].</body><body package="Arbor Help System Outline Help Core">image	"Answer the image to be displayed"	^image</body><body package="Arbor Help System Outline Help Core">parentWindow	"Parent Application"		^parentWindow</body><body package="Arbor Help System Outline Help Core">parentWindow: anApplication	"Parent Application"		parentWindow := anApplication.</body><body package="Arbor Help System Outline Help Core">sliderWidget	^ (self builder componentAt: #imageProportionSlider)</body><body package="Arbor Help System Outline Help Core">windowExtent	| ext |	ext := self graphicLink value windowExtent.	^ext isNil		ifTrue: [| imageExtent |			imageExtent := (self image extent + (20@20)) max: 100@100.			imageExtent x @ (imageExtent y / self imageProportion value) rounded]		ifFalse: [ext]</body></methods><methods><class-id>VWHelp.AHSGraphicScreen</class-id> <category>interface opening</category><body package="Arbor Help System Outline Help Core">allButOpenInterface: aSpec	"Force the window to be the size saved in the Hyperlink"	super allButOpenInterface: aSpec.	self builder window displayBox: (0@0 extent: self preferredExtent).	^builder</body><body package="Arbor Help System Outline Help Core">openAsDialog	|dlog box |	dlog :=SimpleDialog new.	self builder: dlog builder.	dlog preBuildBlock: [:mdl :bldr | self preBuildWith: bldr].	dlog postBuildBlock: [:mdl :bldr | self postBuildWith: bldr].	dlog postOpenBlock: [:mdl :bldr | bldr window label: 'Graphic: ', self graphicLink value linkObject].	dlog builder source: self.	dlog allButOpenFrom: (self class interfaceSpecFor: #windowSpec).	dlog builder doFinalHookup.	box := 0@0 extent: self preferredExtent.	box := box			align: box center			with: WindowSensor cursorPoint.	dlog builder openPopUpIn: box type: #normal.	^dlog accept value</body><body package="Arbor Help System Outline Help Core">openInterface: aSymbol 	self allButOpenInterface: aSymbol.	self builder openAroundCursorWithExtent: self builder window extent andType: #normal.	self builder window displayPendingInvalidation.	self postOpenWith: builder.	^builder</body><body package="Arbor Help System Outline Help Core">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self imageProportion onChangeSend: #proportionChanged to: self.	self proportionChanged.	aBuilder window			label: 'Graphic: ', self graphicLink value linkObject;			application: self parentWindow application;			beSlave.</body><body package="Arbor Help System Outline Help Core">preBuildWith: aBuilder	super preBuildWith: aBuilder.	aBuilder visualAt: #image put: (self image).</body></methods><methods><class-id>VWHelp.AHSGraphicScreen</class-id> <category>actions</category><body package="Arbor Help System Outline Help Core">done	self graphicLink: nil.	self closeRequest.</body></methods><methods><class-id>VWHelp.AHSGraphicScreen</class-id> <category>updating</category><body package="Arbor Help System Outline Help Core">proportionChanged	"Update the window accordingly."	| p widget |	self graphicLink value isNil ifTrue: [^self].	(self builder componentAt: #captionTextEditor) isNil ifTrue:[^self].	p := self imageProportion value.	widget := self builder componentAt: #image.	widget newLayout: (widget layout topFraction: p / 2).	widget := self builder componentAt: #captionTextEditor.	widget newLayout: (widget layout topFraction: p).	self relayoutSubCanvas.</body></methods><methods><class-id>VWHelp.AHSGraphicScreen</class-id> <category>initialize-release</category><body package="Arbor Help System Outline Help Core">setImage: anImage	(anImage isKindOf: Image)		ifTrue: [image := CachedImage on: anImage]		ifFalse: [image := anImage]</body></methods><methods><class-id>VWHelp.AHSGraphicScreen</class-id> <category>aspects</category><body package="Arbor Help System Outline Help Core">caption	caption isNil		ifTrue: [caption := (AspectAdaptor forAspect: #caption)								subjectChannel: self graphicLink].	^caption</body><body package="Arbor Help System Outline Help Core">imageProportion	imageProportion isNil		ifTrue: [imageProportion := (AspectAdaptor forAspect: #imageProportion)										subjectChannel: self graphicLink].	^imageProportion</body></methods><methods><class-id>VWHelp.AHSGraphicScreen</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">preferredExtent	"Answer the extent of the window so that the subcanvas containing the annotated graphic is sized correctly."	| canvasExtent difference |	self builtWindow extentEvent: self builtWindow extent.	"Get the components to layout."		canvasExtent := self captionWidget bounds extent.	difference := self windowExtent value - canvasExtent.	^self builtWindow extent + difference</body><body package="Arbor Help System Outline Help Core">relayoutSubCanvas	| widget |	widget := (self builder componentAt: #annotatedGraphicSubCanvas) widget.	widget 		layoutComponentsForBounds: widget bounds;		invalidate.</body></methods><methods><class-id>VWHelp.AHSGraphicScreen class</class-id> <category>instance creation</category><body package="Arbor Help System Outline Help Core">onImage: anImage link: aHyperGraphicsLink parent: aWindow	^self new		setImage: anImage;		graphicLink: aHyperGraphicsLink;		parentWindow: aWindow</body></methods><methods><class-id>VWHelp.AHSGraphicScreen class</class-id> <category>resources</category><body package="Arbor Help System Outline Help Core">image	^((#noImageDefined &lt;&lt; self messageCatalogID &gt;&gt; 'noImageDefined') asText emphasizeAllWith: #(bold large)) asComposedText</body></methods><methods><class-id>VWHelp.AHSGraphicScreen class</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">messageCatalogID	^#arborHelpSystem</body></methods><methods><class-id>VWHelp.AHSGraphicScreen class</class-id> <category>testing</category><body package="Arbor Help System Outline Help Core">haveExistingWindowFor: aSymbol	"Answer true if we opened an existing window for an image with the name aSymbol."	| existingWindow |	existingWindow := ScheduledControllers scheduledControllers 						detect: [:c | (c model isMemberOf: self) and: [c view label == aSymbol]]						ifNone: [^ false].	existingWindow view isCollapsed ifTrue: [existingWindow view expand].	existingWindow view raise.	^true.</body></methods><methods><class-id>VWHelp.AHSHelpTextEditorController</class-id> <category>searching</category><body package="Arbor Help System Outline Help Core">findNext	"Search for the next entry of the selected text."	| index |	index := (self text findString: self selection startingAt: self selectionStopIndex ignoreCase: true useWildcards: false) first.	index = 0 ifTrue: [^false].	self selectAndScrollFrom: index to: index + self selection size - 1.	^true</body></methods><methods><class-id>VWHelp.AHSHelpTextEditorController</class-id> <category>text updates</category><body package="Arbor Help System Outline Help Core">updateHyperLinkForLastWord	"If a hyperlink is added to the very last word in this	text, then add a few blank spaces at the end, in 	order to avoid text style assimilation when the text	is expanded."	(self selectionStopIndex &gt; self model value size)		ifTrue:			[self model value: (self model value , '   ' asText)]</body></methods><methods><class-id>VWHelp.AHSHelpTextEditorController</class-id> <category>selecting</category><body package="Arbor Help System Outline Help Core">selectFrom: start to: stop	"When selecting a region, also set the default emphasis."	super selectFrom: start to: stop.	self setEmphasisHere.</body></methods><methods><class-id>VWHelp.AHSTextGraphicCompositeController</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">selectedComponents	^selectedComponents</body><body package="Arbor Help System Outline Help Core">selectedComponents: aCollection	selectedComponents := aCollection.</body></methods><methods><class-id>VWHelp.AHSTextGraphicCompositeController</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">characterBlockAtLocalPoint: aPoint for: aComponent	^self view characterBlockAtLocalPoint: aPoint for: aComponent</body><body package="Arbor Help System Outline Help Core">characterBlockAtPoint: aPoint	^self view characterBlockAtPoint: aPoint</body><body package="Arbor Help System Outline Help Core">compileSelection	"Compile the current text selection as an expression and answer	the resulting method. Signal CompilationError if compilation fails."	| compiler |	compiler := self doItReceiver class evaluatorClass new.	^compiler		compile: self selection readStream		in: self doItContext		allowReceiver: true		class: self doItReceiver class		environment: self doItEnvironment		noPattern: true		notifying: self		ifFail: [CompilationError raise]		handler: SilentCompilerErrorHandler new</body><body package="Arbor Help System Outline Help Core">debug: aCompiledMethod	"Open the debugger on the first expression of the argument CompiledMethod.	This method partly duplicates the logic of #evaluateCompiled: but it is necessary	because of problems with automatic stepping through that method."	| doItReceiver doItContext guineaPig context debugger |	doItReceiver := self doItReceiver.	doItContext := self doItContext.	guineaPig := doItContext isNil		ifTrue: [[doItReceiver performMethod: aCompiledMethod] newProcess]		ifFalse: [[doItReceiver performMethod: aCompiledMethod with: doItContext] newProcess].	"Need to manually push copied values from the closure into the context	before stepping because they are not getting pushed during the simulation!"	context := guineaPig suspendedContext.	context receiver pushCopiedValues: context.	debugger := Debugger new 		process: guineaPig		context: context		interrupted: false		proceedable: true.	debugger setCurrentContext: context.	[debugger currentContext method == aCompiledMethod]		whileFalse: [debugger send].	Debugger openFullViewOn: debugger label: 'Debug It'.	debugger updateText</body><body package="Arbor Help System Outline Help Core">deselectAll	self view deselect.	self selectedComponents: #().</body><body package="Arbor Help System Outline Help Core">doItContext	^nil</body><body package="Arbor Help System Outline Help Core">doItEnvironment	^Examples</body><body package="Arbor Help System Outline Help Core">doItReceiver	^nil</body><body package="Arbor Help System Outline Help Core">evaluateCompiled: aMethod	"Assuming the argument is a method answered by #compileSelection,	evaluate it on the proper receiver and answer the result."	| context |	context := self doItContext.	^context isNil		ifTrue: [self doItReceiver performMethod: aMethod]		ifFalse: [self doItReceiver performMethod: aMethod with: context]</body><body package="Arbor Help System Outline Help Core">evaluateSelection	"Evaluate the current text selection as an expression and answer the result.	CompilationError may be signaled by #compileSelection."	| code result |	code := self compileSelection.	result := Cursor execute showWhile: [self evaluateCompiled: code].	SourceFileManager default logChange: self selection string.	^result</body><body package="Arbor Help System Outline Help Core">globalBlockClosestTo: startBlock 	| rightMost |	(self selectedComponents includes: startBlock localComponent) 		ifTrue: [^startBlock].	^startBlock &gt;= (rightMost := self rightMostCharacterBlock) 		ifTrue: [rightMost]		ifFalse: [self leftMostCharacterBlock]</body><body package="Arbor Help System Outline Help Core">growComponentSelectionTo: aComponent	"Extend the selection up to aComponent.  Select all text in each intermediate component."	| comps goal current new |	comps := self view components collect: [:c | c view].	(goal := comps indexOf: aComponent) &lt; (current := comps indexOf: self selectedComponents first)		ifTrue: [self selectedComponents addAllFirst: (new := comps copyFrom: goal to: current - 1)]		ifFalse: [self selectedComponents addAllLast: (new := comps copyFrom: (comps indexOf: self selectedComponents last) + 1 to: goal)].	new remove: aComponent ifAbsent: [].	new do: [:c |		(c respondsTo: #selectionStartIndex:stopIndex:)			ifTrue: [				c selectionStartIndex: 1 stopIndex: c displayContents text size + 1.				c select]].</body><body package="Arbor Help System Outline Help Core">leftMostCharacterBlock	"Answer the left-most character block in the selected components."	^self characterBlockAtPoint: (self view globalPointToLocal: (self selectedComponents first localPointToGlobal: 0@0))</body><body package="Arbor Help System Outline Help Core">localBlock: startBlock basedOn: endBlock	^startBlock localComponent = endBlock localComponent		ifTrue: [startBlock asLocalCharacterBlock]		ifFalse: [			startBlock &lt; endBlock				ifTrue: [endBlock localComponent characterBlockAtPoint: 0@0]				ifFalse: [endBlock localComponent characterBlockAtPoint: endBlock localComponent bounds corner]]</body><body package="Arbor Help System Outline Help Core">rightMostCharacterBlock	"Answer the right-most character block in the selected components."	^self characterBlockAtPoint: (self view globalPointToLocal: (self selectedComponents last localPointToGlobal: self selectedComponents last preferredBounds corner))</body><body package="Arbor Help System Outline Help Core">selectAtPoint: aPoint	| blk |	self deselectAll.	(blk := self characterBlockAtPoint: aPoint) isNil ifTrue: [^self].	blk localComponent controller selectAt: blk localIndex.	self selectedComponents: (OrderedCollection with: blk localComponent).</body><body package="Arbor Help System Outline Help Core">shrinkComponentSelectionTo: aComponent fromRight: aBoolean	"Shrink the selection down to aComponent.  Shrink from the end (right) if aBoolean is true, otherwise shrink from the left."	| comps |	comps := self selectedComponents.	aBoolean not ifTrue: [comps := comps reverse].	[comps last ~= aComponent]		whileTrue: [| c |			c := comps removeLast.			(c respondsTo: #deselect) ifTrue: [c deselect]].	self selectedComponents: (aBoolean ifTrue: [comps] ifFalse: [comps reverse]).</body><body package="Arbor Help System Outline Help Core">startBlock	| c |	self selectedComponents isEmpty ifTrue: [^nil].	c := self selectedComponents first.	^self characterBlockAtLocalPoint: c startBlock center for: c</body><body package="Arbor Help System Outline Help Core">stopBlock	| c |	self selectedComponents isEmpty ifTrue: [^nil].	c := self selectedComponents last.	^self characterBlockAtLocalPoint: c stopBlock center for: c</body></methods><methods><class-id>VWHelp.AHSTextGraphicCompositeController</class-id> <category>private-selection</category><body package="Arbor Help System Outline Help Core">selection	^self view selection</body><body package="Arbor Help System Outline Help Core">selectionEndAt: aPoint pivot: pivot originalStart: originalStart originalStop: originalStop	"Selection has ended."	(self selectedComponents size = 1 and: [self selectedComponents first controller readOnly not])		ifTrue: [| comp |			comp := self selectedComponents first.			comp controller				completeSelectionWithPrevStart: originalStart asLocalCharacterBlock				prevStop: originalStop asLocalCharacterBlock				pivotBlock: pivot asLocalCharacterBlock				showingCaret: (comp startBlock = comp stopBlock and: [comp selectionShowing])].</body><body package="Arbor Help System Outline Help Core">selectionStartAt: aPoint shiftDown: aBoolean	"Answer the pivot point."	^(aBoolean and: [self selectedComponents isEmpty not])		ifTrue: [| start stop current pivot |			start := self startBlock.			stop := self stopBlock.			current := self characterBlockAtPoint: aPoint.			(current stringIndex - start stringIndex) abs &lt; (current stringIndex - stop stringIndex) abs				ifTrue: [					start := start origin.					pivot := stop]				ifFalse: [					pivot := start.					start := stop corner].			self selectionTrackFrom: start to: aPoint pivot: pivot.			pivot]		ifFalse: [			self selectAtPoint: aPoint.			self characterBlockAtPoint: aPoint]</body><body package="Arbor Help System Outline Help Core">selectionTrackFrom: startPoint to: endPoint pivot: pivot	"Track the dragging selection."	| start end |	self view scrollIfNeededTo: endPoint.	start := self characterBlockAtPoint: startPoint.	end := self characterBlockAtPoint: endPoint.	start = end ifTrue: [^self].	"Handle the case where start and end (and maybe the pivot) are within the same component."	start localComponent = end localComponent		ifTrue: [^self trackLocalFrom: start to: end pivot: pivot].	"Handle the case where start and end are on the same side of the pivot but in different components."	(start &lt;= pivot and: [end &lt;= pivot])		ifTrue: [			^start &lt; end				ifTrue: [self trackGlobalShrinkFrom: start to: end pivot: pivot]				ifFalse: [self trackGlobalGrowFrom: start to: end pivot: pivot]].	(start &gt;= pivot and: [end &gt;= pivot])		ifTrue: [			^start &lt; end				ifTrue: [self trackGlobalGrowFrom: start to: end pivot: pivot]				ifFalse: [self trackGlobalShrinkFrom: start to: end pivot: pivot]].	"If here, then start and end straddle the pivot across components."	self trackGlobalShrinkFrom: start to: pivot pivot: pivot.	^self trackGlobalGrowFrom: pivot to: end pivot: pivot</body><body package="Arbor Help System Outline Help Core">showingCaretIn: aComponent	^aComponent startBlock = aComponent stopBlock and: [aComponent selectionShowing]</body><body package="Arbor Help System Outline Help Core">trackGlobalGrowFrom: startBlock to: stopBlock pivot: pivotBlock	"startBlock and stopBlock are on the same side of pivotBlock, but (probably) not in the same component."	| c |	"Start and stop blocks may have the same index - if so we still grow the components, but don't touch the selection."	startBlock ~= stopBlock ifTrue: [		stopBlock &gt; startBlock			ifTrue: ["grow right"				c := self selectedComponents last.				c controller selection isEmpty ifTrue: [c deselect].				c selectionStopIndex: c displayContents text size + 1.				c turnSelectionOn: c graphicsContext within: c clippingBox.				stopBlock localComponent selectionStartIndex: 1 stopIndex: 1]			ifFalse: ["grow left" | sz |				c := self selectedComponents first.				c controller selection isEmpty ifTrue: [c deselect].				c selectionStartIndex: 1.				c turnSelectionOn: c graphicsContext within: c clippingBox.				sz := stopBlock localComponent displayContents text size.				stopBlock localComponent selectionStartIndex: sz + 1 stopIndex: sz + 1]].	self growComponentSelectionTo: stopBlock localComponent.	stopBlock localComponent select.	self		trackLocalFrom: ((startBlock &gt; stopBlock) ifTrue: [self startBlock] ifFalse: [self stopBlock])		to: stopBlock		pivot: pivotBlock.</body><body package="Arbor Help System Outline Help Core">trackGlobalShrinkFrom: startBlock to: stopBlock pivot: pivotBlock	"startBlock and stopBlock are on the same side of pivotBlock, but (probably) not in the same component."	self shrinkComponentSelectionTo: stopBlock localComponent fromRight: (startBlock &gt; stopBlock).	self		trackLocalFrom: ((startBlock &gt; stopBlock) ifTrue: [self stopBlock] ifFalse: [self startBlock])		to: stopBlock		pivot: pivotBlock.</body><body package="Arbor Help System Outline Help Core">trackLocalFrom: startBlock to: stopBlock pivot: pivotBlock	"start and stop blocks are within the same component - the pivot may or may not be in the same component.  Note that the start and stop blocks may, in fact, be outside of the current selection so this condition must be checked (and the selection grown if necessary)."	| comp |	comp := startBlock localComponent.	(self selectedComponents includes: comp) not		ifTrue: [self trackGlobalGrowFrom: (self globalBlockClosestTo: startBlock) to: startBlock pivot: pivotBlock]		ifFalse: [			"Does the selection need to shrink?"			((startBlock &gt; pivotBlock and: [startBlock localComponent ~= self selectedComponents last])				or: [startBlock &lt; pivotBlock and: [startBlock localComponent ~= self selectedComponents first]])					ifTrue: [						startBlock &gt;= pivotBlock							ifTrue: [self trackGlobalShrinkFrom: self rightMostCharacterBlock to: startBlock pivot: pivotBlock].						startBlock &lt;= pivotBlock							ifTrue: [self trackGlobalShrinkFrom: self leftMostCharacterBlock to: startBlock pivot: pivotBlock]]].	^comp controller		trackSelectionFrom: startBlock asLocalCharacterBlock		to: (comp globalPointToLocal: (self view localPointToGlobal: stopBlock center))		pivotBlock: (self localBlock: pivotBlock basedOn: startBlock)		showingCaret: (self showingCaretIn: comp)</body></methods><methods><class-id>VWHelp.AHSTextGraphicCompositeController</class-id> <category>selection</category><body package="Arbor Help System Outline Help Core">findAndSelect: aString	^self findAndSelect: aString ignoreCase: false</body><body package="Arbor Help System Outline Help Core">findAndSelect: aString ignoreCase: aBoolean	"Starting after the current selection (or at the top if there is no selection), highlight the next string that matches aString.  Answer true if a match was found, else answer false."	| startC comps |	comps := (self view components select: [:c | c wrapsTextView])				collect: [:c | c view].	comps isEmpty ifTrue: [^false].	self selectedComponents isEmpty		ifTrue: [startC := comps first]		ifFalse: [startC := self selectedComponents last].	[comps first ~= startC and: [comps isEmpty not]] whileTrue: [comps removeFirst].	comps isEmpty ifTrue: [^false].	"Shouldn't happen, but to be safe..."	comps do: [:c |		(c controller findNext: aString ignoreCase: aBoolean) ifTrue: [			self deselectAll.			c controller select.			self selectedComponents: (OrderedCollection with: c).			self view scrollIfNeededTo: self stopBlock center.			^true]].	^false</body></methods><methods><class-id>VWHelp.AHSTextGraphicCompositeController</class-id> <category>event driven</category><body package="Arbor Help System Outline Help Core">mouseMovedEvent: anEvent	"Forward mouse move events to the local component's controller - the controller may change the cursor for hyperlinks."	| cb |	cb := self characterBlockAtPoint: (self sensor mousePointFor: anEvent).	cb notNil ifTrue: [cb localComponent controller mouseMovedEvent: anEvent].</body><body package="Arbor Help System Outline Help Core">redButtonPressedEvent: event	self selectEvent: event.</body><body package="Arbor Help System Outline Help Core">redButtonReleasedEvent: anEvent	"Forward red button release events to the local component's controller - the controller may wish to engage a hyperlink."	| cb |	cb := self characterBlockAtPoint: (self sensor mousePointFor: anEvent).	cb notNil ifTrue: [cb localComponent controller redButtonReleasedEvent: anEvent].</body><body package="Arbor Help System Outline Help Core">selectionTracker	^AHSTextGraphicSelectionTracker on: self</body></methods><methods><class-id>VWHelp.AHSTextGraphicCompositeController</class-id> <category>menu messages</category><body package="Arbor Help System Outline Help Core">copySelection	| sel |	sel := self selection.	sel isEmpty not ifTrue: [ParagraphEditor currentSelection: sel].</body><body package="Arbor Help System Outline Help Core">debugIt	"Prepare to evaluate the current text selection as an expression.	Break and bring up the debugger before the first statement."	| code |	self selection isEmpty ifTrue: [^self].	code := [self compileSelection]		on: CompilationError		do: [:ex | Dialog warn: 'Compilation error'. ex return: nil].	code notNil ifTrue:		[SourceFileManager default logChange: self selection string.		self debug: code]</body><body package="Arbor Help System Outline Help Core">doIt	"Evaluate the current text selection as an expression."	self selection isEmpty		ifTrue: [^self].	"If the current selection is empty, just return."	[self evaluateSelection]		on: CompilationError		do: [:ex | Dialog warn: 'Compilation error'. ex return: nil]</body><body package="Arbor Help System Outline Help Core">inspectIt	"Evaluate the current text selection as an expression and open an inspector on the result."	self selection isEmpty		ifTrue: [^self].	"If the current selection is empty, just return."	[self evaluateSelection inspect]		on: CompilationError		do: [:ex | Dialog warn: 'Compilation error'. ex return: nil]</body><body package="Arbor Help System Outline Help Core">printIt	"Evaluate the current text selection as an expression and then print it on the transcript."	self selection isEmpty		ifTrue: [^self].	"If the current selection is empty, just return."	[Transcript cr; print: self evaluateSelection; flush]		on: CompilationError		do: [:ex | Dialog warn: 'Compilation error'. ex return: nil]</body></methods><methods><class-id>VWHelp.AHSTextGraphicCompositeController</class-id> <category>initialize-release</category><body package="Arbor Help System Outline Help Core">initialize	super initialize.	self resetState.</body><body package="Arbor Help System Outline Help Core">initializeMenu	| menu |	menu := Menu new.	menu addItem: 		((MenuItem labeled: 'Copy')			value: #copySelection;			enabled: [self view selection isEmpty not]).	menu addPart: ParagraphEditor evaluateGroup.	menuHolder := menu asValue</body><body package="Arbor Help System Outline Help Core">resetState	self selectedComponents: #().</body></methods><methods><class-id>VWHelp.AHSTopicBodyWriter</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">appendEmphasisFrom: anElem to: aStream	"Private - Answer a new emphasis value derived from anEmphasisElement."	| aKey |	aKey := self emphasisKeyFrom: anElem.	inGroup := true.	aStream isEmpty ifTrue: [self appendGroupStartTo: aStream].	aStream nextPutAll: (self 							conversionStringFor: anElem 							at: aKey)</body><body package="Arbor Help System Outline Help Core">appendGroupStartTo: aStream	"Private - Append the group start sequence to aStream"	^ self subclassResponsibility</body><body package="Arbor Help System Outline Help Core">asAttributeArray: anEmphasisCollection	"Answer a flattened Array containing TextAttributes.  Believe it or not, aTextAttribute may be an array that contains arrays."	anEmphasisCollection isNil ifTrue: [^#()].	^ (anEmphasisCollection isSymbol not and: [anEmphasisCollection isSequenceable])		ifTrue: [| stream |			stream := (Array new: 20) writeStream.			anEmphasisCollection do: [:item | stream nextPutAll: (self asAttributeArray: item)].			stream contents]		ifFalse: [Array with: anEmphasisCollection]</body><body package="Arbor Help System Outline Help Core">conversionStringFor: anElem at: aKey	"Private - Answer a string which represents the converted emphasis element value."	^ ((self emphasisConversionBlockAt: aKey)		value: self 		value: anElem)</body><body package="Arbor Help System Outline Help Core">convertedEmphasisFrom: anEmphasis	"Private - Answer a new emphasis which is appropriate for RTF output."	| newEmphasis emphasisStream |	newEmphasis := self strippedEmphasisFrom: anEmphasis.	emphasisStream := WriteStream on: ''.	newEmphasis do: [:anElem |		(anElem aisIsAssociation			and: [anElem isArborHyperlinkAssociation			and: [anElem value isKindOf: AHSHelpHyperLinkObject]])				ifTrue: [					newEmphasis size == 1 ifTrue: [inGroup := false].					hyperLink := anElem value]				ifFalse: [					self						appendEmphasisFrom: anElem						to: emphasisStream]].	^ emphasisStream contents</body><body package="Arbor Help System Outline Help Core">emphasisConversionBlockAt: aKey	"Private - Answer the emphasis conversion block found at a key.  If absent, simply answer	 a block which will answer an empty string."	^ self emphasisConversionDictionary		at: aKey 		ifAbsent: [[:writer :anEmph | String new]]</body><body package="Arbor Help System Outline Help Core">emphasisKeyFrom: anElem	"Private - Answer the emphasis key from anElem, where anElem may be an association." 	^ (anElem isKindOf: Association) 		ifTrue: [anElem key]		ifFalse: [anElem].</body><body package="Arbor Help System Outline Help Core">exportableEmphasisFrom: anEmphasis	"Answer an exportable emphasis derived from the ST emphasis."	hyperLink := nil.	^ (self definesEmphasis: anEmphasis)		ifTrue: [self convertedEmphasisFrom: anEmphasis]		ifFalse: 			[inGroup := false.			String new].</body><body package="Arbor Help System Outline Help Core">exportableStringFrom: aString	"Convert aString to an exportable string, which means replacing any special character with their exportable equivalents."	| outStream |	outStream := WriteStream on: String new.	aString do: [:aChar | outStream nextPutAll: (self translatedCharacterStringFor: aChar)].	^ outStream contents asString</body><body package="Arbor Help System Outline Help Core">setOwner: anObject	owner := anObject</body><body package="Arbor Help System Outline Help Core">strippedEmphasisFrom: anEmphasis	"Private - Answer a new emphasis which has had link information stripped from it."	^ self removeHyperlinkEmphasis: anEmphasis.</body><body package="Arbor Help System Outline Help Core">translatedCharacterStringFor: aChar	"Private - Answer a translated character string for the given character.  Some characters need to	 be modified before being sent to the output stream."	^ self specialCharacterDictionary 		at: aChar 		ifAbsent: [String with: aChar].</body></methods><methods><class-id>VWHelp.AHSTopicBodyWriter</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">emphasisConversionDictionary	^ self class emphasisConversionDictionary</body><body package="Arbor Help System Outline Help Core">owner	^ owner</body><body package="Arbor Help System Outline Help Core">specialCharacterDictionary	^ self class specialCharacterDictionary</body></methods><methods><class-id>VWHelp.AHSTopicBodyWriter</class-id> <category>writing</category><body package="Arbor Help System Outline Help Core">writeBody: aText	"Convert aText and write it out."	1 to: aText size do: [:index |		self			writeText: aText			at: index].</body><body package="Arbor Help System Outline Help Core">writeBody: aText on: aStream	"Convert aText and write it out on aStream"	outputStream := aStream.	inGroup := false.	self writeBody: aText asAHSHyperText.	self writeTopicTermination.</body><body package="Arbor Help System Outline Help Core">writeCharacter: aChar	"Write the character out to outputStream, converting it if necessary."	outputStream nextPutAll: (self translatedCharacterStringFor: aChar).</body><body package="Arbor Help System Outline Help Core">writeConvertedEmphasis: anEmphasis	"Private - Write anEmphasis in a form appropriate to the format used for the output file."	^ self subclassResponsibility</body><body package="Arbor Help System Outline Help Core">writeCurrentEmphasisTermination	"Private - Write the sting which terminates the current emphasis."	^ self subclassResponsibility</body><body package="Arbor Help System Outline Help Core">writeEmphasisChange: anEmphasis	"Write the RTF code for the any changes in the emphasis."	(self isNewEmphasis: anEmphasis) ifFalse: [^ self].	self writeGroupTermination.	self writeConvertedEmphasis: anEmphasis.	currentEmphasis := anEmphasis</body><body package="Arbor Help System Outline Help Core">writeGlossaryLink: theLink	^self subclassResponsibility</body><body package="Arbor Help System Outline Help Core">writeGroupTermination	"Write an appropriate group termination string for the receiver."	^self subclassResponsibility</body><body package="Arbor Help System Outline Help Core">writeHypergraphicLink: theLink	^self subclassResponsibility</body><body package="Arbor Help System Outline Help Core">writeHyperLink: oldLink	"If oldLink and the current link, self hyperLink, are different, write out the needed tags to denote the ending or beginning of a new tag."	hyperLink = oldLink ifTrue: [^self].	oldLink notNil ifTrue: [self writeHyperlinkTermination: oldLink].	hyperLink isNil ifTrue: [^self].	"The hyperlink writing method may set hyperLink to nil if the link is to be ignored."	hyperLink writeHyperlinkUsing: self.</body><body package="Arbor Help System Outline Help Core">writeHyperlinkTermination: aLink	"Private - Write the string which represents the end of a hyperlink definition."	self subclassResponsibility.</body><body package="Arbor Help System Outline Help Core">writeHypertextLink: theLink	"Write a hypertext link definition for the recevier."	^self subclassResponsibility</body><body package="Arbor Help System Outline Help Core">writeText: aText at: anInteger	"Private - Write the character in aText located at the index position indicated by anInteger."	| emphasis oldLink |	emphasis := aText emphasisAt: anInteger asArray: true.	oldLink := hyperLink.	self 		writeEmphasisChange: emphasis;		writeHyperLink: oldLink.	"Only write out the link text if it's a non-embedded hypergraphic."	"Embedded graphic links are to have their text ignored."	(hyperLink notNil and: [hyperLink isHyperGraphic and: [self shouldImbed: hyperLink]]) not		ifTrue: [self writeCharacter: (aText at: anInteger)].</body><body package="Arbor Help System Outline Help Core">writeTopicTermination	hyperLink notNil		ifTrue: [			self writeHyperlinkTermination: hyperLink.			hyperLink := nil].	self writeGroupTermination.</body></methods><methods><class-id>VWHelp.AHSTopicBodyWriter</class-id> <category>testing</category><body package="Arbor Help System Outline Help Core">definesEmphasis: anEmphasis	"Private - Answer true if anEmphasis actually defines an emphasis."	^ (anEmphasis notNil and: [anEmphasis isEmpty not])</body><body package="Arbor Help System Outline Help Core">isNewEmphasis: anEmphasis	"Private - Answer true if anEmphasis represents a new emphasis"	^ (anEmphasis ~= currentEmphasis)</body></methods><methods><class-id>VWHelp.AHSTopicBodyWriter</class-id> <category>utility</category><body package="Arbor Help System Outline Help Core">removeHyperlinkEmphasis: anEmphasis	"If anEmphasis has a hyperlink in it, remove any associated text emphasis."	| flattenedEmphasis |	flattenedEmphasis := (self asAttributeArray: anEmphasis) asSet.	flattenedEmphasis copy do: [:emph |		(emph aisIsAssociation and: [emph isArborHyperlinkAssociation])			ifTrue: [				(self asAttributeArray: emph value textEmphasis)					do: [:em | flattenedEmphasis remove: em ifAbsent: []]]].	^flattenedEmphasis asArray</body></methods><methods><class-id>VWHelp.AHSTopicBodyWriter class</class-id> <category>class initialization</category><body package="Arbor Help System Outline Help Core">initializeEmphasisConversionDictionary	^self subclassResponsibility</body><body package="Arbor Help System Outline Help Core">initializeSpecialCharacters	^self subclassResponsibility</body><body package="Arbor Help System Outline Help Core">reinitialize	"Initialize the class.  This method would typically be used to reinitialize the special dictionaries if	  their code definition has changed.  Otherwise, the dictionaries are self-initializing."	self		initializeEmphasisConversionDictionary;		initializeSpecialCharacters</body></methods><methods><class-id>VWHelp.AHSTopicBodyWriter class</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">emphasisConversionDictionary	emphasisConversionDictionary isNil ifTrue: [self initializeEmphasisConversionDictionary].	^ emphasisConversionDictionary</body><body package="Arbor Help System Outline Help Core">specialCharacterDictionary	specialCharacterDictionary isNil ifTrue: [self initializeSpecialCharacters].	^ specialCharacterDictionary</body></methods><methods><class-id>VWHelp.AHSTopicBodyWriter class</class-id> <category>constants</category><body package="Arbor Help System Outline Help Core">graphicExtension	"The extension to be used for graphic files."	^'.bos'</body><body package="Arbor Help System Outline Help Core">graphicsDirectory	^'graphics'</body></methods><methods><class-id>VWHelp.AHSTopicBodyWriter class</class-id> <category>instance creation</category><body package="Arbor Help System Outline Help Core">forOwner: anObject	"Answer a new instance of the receiver which can be used to output topic body text for anOwner."	^ self basicNew setOwner: anObject</body></methods><methods><class-id>VWHelp.AHSHTMLTopicBodyWriter</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">endEmphasisConversionBlocks	^ self class endEmphasisConversionBlocks</body></methods><methods><class-id>VWHelp.AHSHTMLTopicBodyWriter</class-id> <category>writing</category><body package="Arbor Help System Outline Help Core">emitCaptionCell: aLink	"Emit the caption table cell."	aLink hasCaption ifTrue: [		outputStream 			nextPutAll: '&lt;TD&gt;&lt;P&gt;';			nextPutAll: aLink caption;			nextPutAll: '&lt;/P&gt;&lt;/TD&gt;'].</body><body package="Arbor Help System Outline Help Core">emitCaptionCenter: aLink	"Emit the graphic and caption with the caption in the center."	outputStream nextPutAll: '&lt;TR&gt;'.	self emitGraphicCenterCell: aLink.	outputStream nextPutAll: '&lt;/TR&gt;'.	aLink hasCaption ifTrue: [		outputStream nextPutAll: '&lt;TR&gt;'.		self emitCaptionCell: aLink.		outputStream nextPutAll: '&lt;/TR&gt;'].</body><body package="Arbor Help System Outline Help Core">emitCaptionLeft: aLink	"Emit the graphic and caption with the caption on the left."	outputStream nextPutAll: '&lt;TR&gt;'.	self emitCaptionCell: aLink.	self emitGraphicEdgeCell: aLink.	outputStream nextPutAll: '&lt;/TR&gt;'.</body><body package="Arbor Help System Outline Help Core">emitCaptionRight: aLink	"Emit the graphic and caption with the caption on the right."	outputStream nextPutAll: '&lt;TR&gt;'.	self emitGraphicEdgeCell: aLink.	self emitCaptionCell: aLink.	outputStream nextPutAll: '&lt;/TR&gt;'.</body><body package="Arbor Help System Outline Help Core">emitGraphicCenterCell: aLink	"Emit the graphic into a cell so that the graphic is centered."	outputStream		nextPutAll: '&lt;TD&gt;&lt;P align="center"&gt;';		nextPutAll: (owner embedGraphic: aLink);		nextPutAll: '&lt;/P&gt;&lt;/TD&gt;'.</body><body package="Arbor Help System Outline Help Core">emitGraphicEdgeCell: aLink	"Emit the graphic into a cell whose width matches the image size."	outputStream		nextPutAll: '&lt;TD width=';		print: (owner graphicAt: aLink linkObject) width;		nextPut: $&gt;;		nextPutAll: (owner embedGraphic: aLink);		nextPutAll: '&lt;/TD&gt;'.</body><body package="Arbor Help System Outline Help Core">writeBody: aText	"Convert aText to HTML and write it out on an outputStream.  Override my parent's implementation to properly handle BLOCKQUOTE tags."	| blockQuoteLevel |	blockQuoteLevel := 0.	1 to: aText size do: [:index |		(index = 1 or: [(aText at: index - 1) = Character cr])			ifTrue: [| t depth |				t := aText copyFrom: index to: index.				depth := 0.				t emphasesLike: #ahsIndent-&gt;nil do: [:emph | depth := emph value].				depth &gt; blockQuoteLevel					ifTrue: [depth - blockQuoteLevel timesRepeat: [outputStream nextPutAll: '&lt;blockquote&gt;']]					ifFalse: [blockQuoteLevel - depth timesRepeat: [outputStream nextPutAll: '&lt;/blockquote&gt;']].				blockQuoteLevel := depth].		self			writeText: aText			at: index].	blockQuoteLevel timesRepeat: [outputStream nextPutAll: '&lt;/blockquote&gt;'].</body><body package="Arbor Help System Outline Help Core">writeConvertedEmphasis: anEmphasis	"Private - Write anEmphasis in a form appropriate to the format used for the output file."	| newEmphasis outputValue |	outputValue := (newEmphasis := self exportableEmphasisFrom: anEmphasis) isEmpty						ifTrue: ['']						ifFalse: [newEmphasis].	outputStream nextPutAll: outputValue</body><body package="Arbor Help System Outline Help Core">writeCurrentEmphasisTermination	"Private - Write the sting which terminates the current emphasis."	currentEmphasis isNil ifTrue: [^ self].	outputStream nextPutAll: (self emphasisTerminationStringFor: currentEmphasis)</body><body package="Arbor Help System Outline Help Core">writeEmbeddedHypergraphicLink: aLink	outputStream		cr; nextPutAll: '&lt;DIV align="center"&gt;&lt;CENTER&gt;';		nextPutAll: '&lt;TABLE WIDTH='.	aLink captionIsAtCenter		ifTrue: [outputStream print: ((owner graphicAt: aLink linkObject) extent x max: 150)]		ifFalse: [outputStream nextPutAll: '100%'].	outputStream nextPutAll: '&gt;'.	aLink captionIsAtCenter ifTrue: [self emitCaptionCenter: aLink].	aLink captionIsAtLeft ifTrue: [self emitCaptionLeft: aLink].	aLink captionIsAtRight ifTrue: [self emitCaptionRight: aLink].	outputStream nextPutAll: '&lt;/TABLE&gt;&lt;/CENTER&gt;&lt;/DIV&gt;'; cr.</body><body package="Arbor Help System Outline Help Core">writeGlossaryLink: theLink	"Private - Write a glossary link to the output stream."	outputStream 		nextPutAll: '&lt;a href=''';		nextPutAll: (owner glossaryLinkFor: theLink);		nextPutAll: '''&gt;'</body><body package="Arbor Help System Outline Help Core">writeGroupTermination	"Private - Write the sting which represents the end of a group."	self writeCurrentEmphasisTermination</body><body package="Arbor Help System Outline Help Core">writeHypergraphicLink: theLink	"Private - Write a hypergraphic link to the output stream.  If the graphic should be embedded, then DON'T write anything out.  When the text hyperlink ends, THEN the HTML will be written (see #writeHyperlinkTermination:) - it is done this way to get the embedded graphic to appear after the text rather than before."	(self shouldImbed: theLink) not		ifTrue: [outputStream nextPutAll: (owner linkToGraphic: theLink)].</body><body package="Arbor Help System Outline Help Core">writeHyperlinkTermination: aLink	"Private - Write the sting which represents the end of a hyperlink definition."	(aLink isHyperGraphic and: [self shouldImbed: aLink])		ifTrue: [self writeEmbeddedHypergraphicLink: aLink]		ifFalse: [outputStream nextPutAll: '&lt;/a&gt;'].</body><body package="Arbor Help System Outline Help Core">writeHypertextLink: theLink	"Private - Write a hypertext link."	outputStream 		nextPutAll: '&lt;a href=''';		nextPutAll: (owner hypertextLinkFor: theLink);		nextPutAll: '''&gt;'.</body></methods><methods><class-id>VWHelp.AHSHTMLTopicBodyWriter</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">appendEmphasisTerminationFor: anElem to: aStream	"Private - Append the proper emphasis termination string to aStream.."	| aKey |	aKey := self emphasisKeyFrom: anElem.	aStream nextPutAll: (self 							terminationStringFor: anElem 							at: aKey)</body><body package="Arbor Help System Outline Help Core">appendGroupStartTo: aStream	"Private - Append the group start sequence to aStream"</body><body package="Arbor Help System Outline Help Core">convertedEmphasisEndFrom: anEmphasis	"Private - Answer a new emphasis which is appropriate for RTF output."	| newEmphasis emphasisStream |	newEmphasis := self strippedEmphasisFrom: anEmphasis.	emphasisStream := WriteStream on: ''.	newEmphasis reverseDo: 		[:anElem |		(anElem isKindOf: AHSHelpHyperLinkObject)			ifFalse: 				[self					appendEmphasisTerminationFor: anElem					to: emphasisStream]].	^ emphasisStream contents</body><body package="Arbor Help System Outline Help Core">emphasisTerminationBlockAt: aKey	"Private - Answer the emphasis termination block found at a key.  If absent, simply answer	 a block which will answer an empty string."	^ self endEmphasisConversionBlocks		at: aKey 		ifAbsent: [[:writer :anEmph | String new]]</body><body package="Arbor Help System Outline Help Core">emphasisTerminationStringFor: anEmphasis	"Answer a string which terminates the given emphasis."	^ (self definesEmphasis: anEmphasis)		ifTrue: [self convertedEmphasisEndFrom: anEmphasis]		ifFalse: [String new].</body><body package="Arbor Help System Outline Help Core">terminationStringFor: anElem at: aKey	"Private - Answer a string which represents the proper termination string for an emphasis element value."	^ ((self emphasisTerminationBlockAt: aKey)		value: self 		value: anElem)</body></methods><methods><class-id>VWHelp.AHSHTMLTopicBodyWriter</class-id> <category>testing</category><body package="Arbor Help System Outline Help Core">shouldImbed: aHyperGraphicLink	"Private - Answer true if we are imbedding the link."	^owner shouldImbed: aHyperGraphicLink</body></methods><methods><class-id>VWHelp.AHSHTMLTopicBodyWriter class</class-id> <category>class initialization</category><body package="Arbor Help System Outline Help Core">initializeEmphasisConversionDictionary	emphasisConversionDictionary := Dictionary new.	emphasisConversionDictionary		at: #strikeout		put: [:writer :emph | '&lt;strike&gt;'].	emphasisConversionDictionary		at: #bold 		put: [:writer :emph | '&lt;b&gt;'].	emphasisConversionDictionary 		at: #italic 		put: [:writer :emph | '&lt;i&gt;'].	emphasisConversionDictionary 		at: #large 		put: [:writer :emph | '&lt;big&gt;'].	emphasisConversionDictionary 		at: #underline 		put: [:writer :emph | '&lt;u&gt;'].	emphasisConversionDictionary 		at: #strikeout 		put: [:writer :emph | '&lt;strike&gt;'].	emphasisConversionDictionary 		at: #serif		put: [:write :emph | '&lt;tt&gt;'].	emphasisConversionDictionary 		at: #color 		put: [:writer :emph | '&lt;font color=' , emph value htmlColorCode , '&gt;']."	emphasisConversionDictionary 		at: #ahsIndent		put: [:writer :emph || s |			s := String new writeStream.			emph value timesRepeat: [s nextPutAll: '&lt;blockquote&gt;'].			s contents]."</body><body package="Arbor Help System Outline Help Core">initializeEndEmphasisConversionBlocks	endEmphasisConversionBlocks := Dictionary new.	endEmphasisConversionBlocks		at: #strikeout		put: [:writer :emph | '&lt;/strike&gt;'].	endEmphasisConversionBlocks 		at: #bold 		put: [:writer :emph | '&lt;/b&gt;'].	endEmphasisConversionBlocks 		at: #italic 		put: [:writer :emph | '&lt;/i&gt;'].	endEmphasisConversionBlocks 		at: #large 		put: [:writer :emph | '&lt;/big&gt;'].	endEmphasisConversionBlocks 		at: #underline 		put: [:writer :emph | '&lt;/u&gt;'].	endEmphasisConversionBlocks 		at: #strikeout 		put: [:writer :emph | '&lt;/strike&gt;'].	endEmphasisConversionBlocks		at: #serif		put: [:write :emph | '&lt;/tt&gt;'].	endEmphasisConversionBlocks 		at: #color		put: [:writer :emph | '&lt;/font&gt;']."	endEmphasisConversionBlocks 		at: #ahsIndent		put: [:writer :emph || s |			s := String new writeStream.			emph value timesRepeat: [s nextPutAll: '&lt;/blockquote&gt;'].			s contents]."</body><body package="Arbor Help System Outline Help Core">initializeSpecialCharacters	"The SpecialCharacterDictionary hold those character that must be converted to a special RTF representation."	specialCharacterDictionary := Dictionary new.	specialCharacterDictionary 		at: $&lt; 		put: '&amp;lt;'.	specialCharacterDictionary 		at: $&gt; 		put: '&amp;gt;'.	specialCharacterDictionary 		at: $&amp; 		put: '&amp;amp;'.	specialCharacterDictionary 		at: $" 		put: '&amp;quot;'.</body><body package="Arbor Help System Outline Help Core">reinitialize	super reinitialize.	self initializeEndEmphasisConversionBlocks</body></methods><methods><class-id>VWHelp.AHSHTMLTopicBodyWriter class</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">endEmphasisConversionBlocks	"Answer the dictionary containing the code blocks which will answer a string used to terminate an	 emphasis."	endEmphasisConversionBlocks isNil ifTrue: [self initializeEndEmphasisConversionBlocks].		^ endEmphasisConversionBlocks</body></methods><methods><class-id>VWHelp.ArborOutlineLabeledObjectHolder</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">iconForSelected: isSelected inTransition: isInTransition	"Build the appropriate selector and fetch the necessary icon."	| set exp trans sel |	set := self iconSet.	exp := self isExpanded				ifTrue: ['expanded']				ifFalse: [					self canBeExpanded						ifTrue: ['contracted']						ifFalse: ['empty']].	trans := (isInTransition and: [exp ~= 'empty']) ifTrue: ['Transition'] ifFalse: [''].	sel := isSelected ifTrue: ['Selected'] ifFalse: ['Deselected'].	^set perform: (exp, trans, sel) asSymbol</body><body package="Arbor Help System Outline Help Core">iconSetNamed: aName	^ArborIconSet iconSetNamed: aName</body><body package="Arbor Help System Outline Help Core">indentDistance	^self indentLevel * self indentOffset</body><body package="Arbor Help System Outline Help Core">indentOffset	"Pixel value - how far to indent for each level."	^self iconSet indentOffset</body><body package="Arbor Help System Outline Help Core">indentString	^(String new: 10) writeStream		next: self indentLevel * 3 put: Character space;		contents</body></methods><methods><class-id>VWHelp.ArborOutlineLabeledObjectHolder</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">canBeExpanded	^canBeExpanded</body><body package="Arbor Help System Outline Help Core">canBeExpanded: aBoolean	canBeExpanded := aBoolean.</body><body package="Arbor Help System Outline Help Core">displayBlock	^displayBlock</body><body package="Arbor Help System Outline Help Core">displayBlock: aBlockClosure	displayBlock := aBlockClosure</body><body package="Arbor Help System Outline Help Core">emphasis	^emphasis</body><body package="Arbor Help System Outline Help Core">emphasis: anEmphasis	emphasis := anEmphasis</body><body package="Arbor Help System Outline Help Core">iconSet	^(iconSet isSymbol or: [iconSet isNil])		ifTrue: [self iconSetNamed: iconSet]		ifFalse: [iconSet]</body><body package="Arbor Help System Outline Help Core">iconSet: aSymbol	iconSet := aSymbol.</body><body package="Arbor Help System Outline Help Core">indentLevel	^indentLevel</body><body package="Arbor Help System Outline Help Core">indentLevel: anInteger	indentLevel := anInteger.</body><body package="Arbor Help System Outline Help Core">isExpanded	^isExpanded</body><body package="Arbor Help System Outline Help Core">isExpanded: aBoolean	isExpanded := aBoolean.</body><body package="Arbor Help System Outline Help Core">parent	^parent</body><body package="Arbor Help System Outline Help Core">parent: anOutlineLabeledObjectHolder	parent := anOutlineLabeledObjectHolder.</body><body package="Arbor Help System Outline Help Core">value	^object</body><body package="Arbor Help System Outline Help Core">value: anObject	object := anObject.</body></methods><methods><class-id>VWHelp.ArborOutlineLabeledObjectHolder</class-id> <category>printing</category><body package="Arbor Help System Outline Help Core">displayString	"Generally shouldn't be used, but if it is then include the indentation with the string."	| str |	str := self value isNil			ifTrue: [self indentString]			ifFalse: [self indentString, (self displayBlock value: object)].	^self canBeExpanded		ifTrue: [str, '...']		ifFalse: [str]</body><body package="Arbor Help System Outline Help Core">printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		print: self value;		nextPut: $).</body></methods><methods><class-id>VWHelp.ArborOutlineLabeledObjectHolder</class-id> <category>testing</category><body package="Arbor Help System Outline Help Core">hasChildren	^self isExpanded or: [self canBeExpanded]</body><body package="Arbor Help System Outline Help Core">isHot: aPoint	^self hasChildren and: [self iconSet isHot: aPoint - (self indentDistance @ 0)]</body></methods><methods><class-id>VWHelp.ArborOutlineLabeledObjectHolder</class-id> <category>comparing</category><body package="Arbor Help System Outline Help Core">= anObject	^(anObject isKindOf: self class)		ifTrue: [self == anObject				or: [self value = anObject value]]		ifFalse: [self value = anObject]</body><body package="Arbor Help System Outline Help Core">hash	^self value hash</body></methods><methods><class-id>VWHelp.ArborOutlineLabeledObjectHolder</class-id> <category>converting</category><body package="Arbor Help System Outline Help Core">asPureText	"Answer the 'pure' text - without any indentation."	^(self displayBlock value: object) asText		emphasizeAllWith: self emphasis</body><body package="Arbor Help System Outline Help Core">asText	"Answer the text representation of myself, including indentation."	^self indentString asText, self asPureText</body><body package="Arbor Help System Outline Help Core">asVisualComponentWhereSelected: isSelected inTransition: isInTransition attributes: aTextAttributes	| label |	label := ArborCenteredLabelAndIcon with: self asPureText attributes: aTextAttributes offset: self indentDistance @ 0.	label icon: (self iconForSelected: isSelected inTransition: isInTransition).	label gap: 2.	^BoundedWrapper on: label at: 0@0</body></methods><methods><class-id>VWHelp.ArborOutlineLabeledObjectHolder</class-id> <category>initialize-release</category><body package="Arbor Help System Outline Help Core">initialize	self iconSet: #default.	self displayBlock: [:obj | obj displayString]</body></methods><methods><class-id>VWHelp.ArborOutlineLabeledObjectHolder class</class-id> <category>instance creation</category><body package="Arbor Help System Outline Help Core">new	^self newValue: nil indentLevel: 0 parent: nil</body><body package="Arbor Help System Outline Help Core">newValue: anObject indentLevel: anInteger parent: anOutlineLabeledObjectHolderOrNil	^super new initialize		value: anObject;		indentLevel: anInteger;		parent: anOutlineLabeledObjectHolderOrNil</body></methods><methods><class-id>VWHelp.AHSOutlineTopicIndex</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">addItem: aTreeNode	"Update the index with information about aTreeNode."	| info |	info := aTreeNode data uniqueID.	allTopics add: info.	topicIndex		at: info		put: allTopics size</body><body package="Arbor Help System Outline Help Core">nextNode: aTreeNode	"Answer the node which immediately follows aTreeNode, or nil if no node exists."	| index |	index := topicIndex at: aTreeNode uniqueID.	^ index = allTopics size		ifTrue: [nil]		ifFalse: [allTopics at: index + 1]</body><body package="Arbor Help System Outline Help Core">previousNode: aTreeNode	"Answer the node previous to aTreeNode, or nil if no node exists."	| index |	index := topicIndex at: aTreeNode uniqueID.	^ index = 1		ifTrue: [nil]		ifFalse: [allTopics at: index - 1]</body></methods><methods><class-id>VWHelp.AHSOutlineTopicIndex</class-id> <category>initialize-release</category><body package="Arbor Help System Outline Help Core">initialize	"Private - Initialize the receiver by creating an empty topicIndex and allTopics."	topicIndex := Dictionary new.	allTopics := OrderedCollection new.</body></methods><methods><class-id>VWHelp.AHSOutlineTopicIndex class</class-id> <category>instance creation</category><body package="Arbor Help System Outline Help Core">new	"Answer a new, initialized instance of the receiver."	^ super new initialize.</body></methods><methods><class-id>VWHelp.AHSPersistentSet</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">add: anObject	self odbDirty.	^super add: anObject.</body><body package="Arbor Help System Outline Help Core">remove: anObject ifAbsent: aBlock	self odbDirty.	^super remove: anObject ifAbsent: aBlock.</body></methods><methods><class-id>VWHelp.AHSPersistentSet</class-id> <category>gemstone replication support</category><body package="Arbor Help System Outline Help Core">stValues: anArray"the super implementation of stValues uses the #add: method which marks the object dirty, but since we are just faulting in the object from Gemstone we are not making the object dirty so we must unmark it after it is faulted in"	super stValues: anArray.	self markNotDirty.</body></methods><methods><class-id>VWHelp.AHSPersistentSet</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">atNewIndex: index put: anObject 	self odbDirty.	^super atNewIndex: index put: anObject</body><body package="Arbor Help System Outline Help Core">changeCapacityTo: newCapacity	self odbDirty.	^super changeCapacityTo: newCapacity</body><body package="Arbor Help System Outline Help Core">fixCollisionsFrom: index 	self odbDirty.	^super fixCollisionsFrom: index</body><body package="Arbor Help System Outline Help Core">swap: oneElement with: otherElement 	self odbDirty.	^super swap: oneElement with: otherElement</body></methods><methods><class-id>VWHelp.ArborDragBarController</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">above	^above</body><body package="Arbor Help System Outline Help Core">above: aCollection	above := aCollection.</body><body package="Arbor Help System Outline Help Core">below	^below</body><body package="Arbor Help System Outline Help Core">below: aCollection	below := aCollection.</body><body package="Arbor Help System Outline Help Core">boundedDrag	^boundedDrag</body><body package="Arbor Help System Outline Help Core">boundedDrag: aBoolean	boundedDrag := aBoolean.</body><body package="Arbor Help System Outline Help Core">left	^left</body><body package="Arbor Help System Outline Help Core">left: aCollection	left := aCollection.</body><body package="Arbor Help System Outline Help Core">right	^right</body><body package="Arbor Help System Outline Help Core">right: aCollection	right := aCollection.</body></methods><methods><class-id>VWHelp.ArborDragBarController</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">adjustAboveBy: offset	self above do: [:component || layout b |		layout := component layout asLayout.		layout bottomOffset: layout bottomOffset + offset.		component			layout: layout;			newBounds: ((b := component bounds) origin corner: (b corner + (0@offset)))].</body><body package="Arbor Help System Outline Help Core">adjustBelowBy: offset	self below do: [:component || layout b |		layout := component layout asLayout.		layout topOffset: layout topOffset + offset.		component			layout: layout;			newBounds: ((b := component bounds) origin + (0 @ offset) corner: b corner)].</body><body package="Arbor Help System Outline Help Core">adjustComponentsBy: adjustmentPoint	self isVertical		ifTrue: [			self adjustLeftBy: adjustmentPoint x.			self adjustHorizontallyBy: adjustmentPoint x.			self adjustRightBy: adjustmentPoint x]		ifFalse: [			self adjustAboveBy: adjustmentPoint y.			self adjustVerticallyBy: adjustmentPoint y.			self adjustBelowBy: adjustmentPoint y].</body><body package="Arbor Help System Outline Help Core">adjustHorizontallyBy: offset	"Move my view horizontally by offset pixels."	| specWrapper layout |	specWrapper := self view aisWidgetWrapper.	specWrapper isNil ifTrue: [^self].	"Shouldn't happen, but better to be safe..."	layout := specWrapper layout asLayout.	layout		rightOffset: layout rightOffset + offset;		leftOffset: layout leftOffset + offset.	specWrapper		layout: layout;		newBounds: (specWrapper bounds translatedBy: offset @ 0).</body><body package="Arbor Help System Outline Help Core">adjustLeftBy: offset	self left do: [:component || layout b |		layout := component layout asLayout.		layout rightOffset: layout rightOffset + offset.		component			layout: layout;			newBounds: ((b := component bounds) origin corner: (b corner + (offset@0)))].</body><body package="Arbor Help System Outline Help Core">adjustRightBy: offset	self right do: [:component || layout b |		layout := component layout asLayout.		layout leftOffset: layout leftOffset + offset.		component			layout: layout;			newBounds: ((b := component bounds) origin + (offset @ 0) corner: b corner)].</body><body package="Arbor Help System Outline Help Core">adjustVerticallyBy: offset	"Move my view vertically by offset pixels."	| specWrapper layout |	specWrapper := self view aisWidgetWrapper.	specWrapper isNil ifTrue: [^self].	"Shouldn't happen, but better to be safe..."	layout := specWrapper layout asLayout.	layout		topOffset: layout topOffset + offset;		bottomOffset: layout bottomOffset + offset.	specWrapper		layout: layout;		newBounds: (specWrapper bounds translatedBy: 0 @ offset).</body><body package="Arbor Help System Outline Help Core">doDragFrom: startPoint	"startPoint refers to the current mouse position in window-relative coordinates."	| endPoint |	self dragCursor showWhile: [| shape |		self isVertical			ifTrue: [| topEnd |				topEnd := (self view globalPointToLocal: startPoint) y negated.				shape := Array with: 0 @ topEnd with: 0 @ (topEnd + self view bounds height)]			ifFalse: [| leftEnd |				leftEnd := (self view globalPointToLocal: startPoint) x negated.				shape := Array with: leftEnd @ 0 with: (leftEnd + self view bounds width) @ 0].		endPoint := Screen default						dragShape: shape						lineWidth: (self view lineWidth max: 1)						offset: 0 @ 0						gridPhase: 0 @ 0						gridSpacing: 1 @ 1						boundedBy: (Rectangle										left: (self limitLeftFrom: startPoint)										right: (self limitRightFrom: startPoint)										top: (self limitTopFrom: startPoint)										bottom: (self limitBottomFrom: startPoint))						whileButton: 1						isDown: true].	endPoint := endPoint - self view topComponent globalOrigin.	self adjustComponentsBy: endPoint - startPoint.</body><body package="Arbor Help System Outline Help Core">dragCursor	^self isVertical		ifTrue: [self class verticalDragCursor]		ifFalse: [self class horizontalDragCursor]</body><body package="Arbor Help System Outline Help Core">limitBottomFrom: startPoint	"Answer the bottom edge of the bounding box for dragging.  Use #localPointToGlobal: instead of a simple #bounds request because #bounds may not be actual bounds within the window, especially if the component is within a ReComposingComposite which can dynamically relocate widgets (such as due to a menubar dynamically wrapping in a window)."	| tc y |	y := (tc := self view topComponent) globalOrigin y.	^self isVertical		ifTrue: [y + startPoint y]		ifFalse: [			self boundedDrag				ifTrue: [(self below inject: tc height into: [:edge :c | edge min: (c localPointToGlobal: c bounds corner) y]) + y]				ifFalse: [y + tc height]]</body><body package="Arbor Help System Outline Help Core">limitLeftFrom: startPoint	"Answer the left edge of the bounding box for dragging."	| x |	x := self view topComponent globalOrigin x.	^self isVertical		ifTrue: [			self boundedDrag				ifTrue: [(self left inject: 0 into: [:edge :c | edge max: c bounds left]) + x]				ifFalse: [x]]		ifFalse: [x + startPoint x]</body><body package="Arbor Help System Outline Help Core">limitRightFrom: startPoint	"Answer the right edge of the bounding box for dragging."	| tc x |	x := (tc := self view topComponent) globalOrigin x.	^self isVertical		ifTrue: [			self boundedDrag				ifTrue: [(self right inject: tc width into: [:edge :c | edge min: c bounds right]) + x]				ifFalse: [x + tc width]]		ifFalse: [x + startPoint x]</body><body package="Arbor Help System Outline Help Core">limitTopFrom: startPoint	"Answer the top edge of the bounding box for dragging.  Use #localPointToGlobal: instead of a simple #bounds request because #bounds may not be actual bounds within the window, especially if the component is within a ReComposingComposite which can dynamically relocate widgets (such as due to a menubar dynamically wrapping in a window)."	| y |	y := self view topComponent globalOrigin y.	^self isVertical		ifTrue: [y + startPoint y]		ifFalse: [			self boundedDrag				ifTrue: [(self above inject: 0 into: [:edge :c | edge max: (c localPointToGlobal:c bounds origin) y]) + y]				ifFalse: [y]]</body></methods><methods><class-id>VWHelp.ArborDragBarController</class-id> <category>control defaults</category><body package="Arbor Help System Outline Help Core">controlActivity	"Use 'window sensor' instead of 'windowSensor' because #windowSensor is only available in VW 2.5 if events are loaded."	self sensor redButtonPressed ifTrue: [self doDragFrom: self sensor window sensor cursorPoint].</body><body package="Arbor Help System Outline Help Core">controlInitialize	self dragCursor show.	super controlInitialize.</body><body package="Arbor Help System Outline Help Core">controlTerminate	Cursor normal show.	super controlTerminate.</body></methods><methods><class-id>VWHelp.ArborDragBarController</class-id> <category>initialize-release</category><body package="Arbor Help System Outline Help Core">initialize	self		above: OrderedCollection new;		below: OrderedCollection new;		left: OrderedCollection new;		right: OrderedCollection new;		boundedDrag: false.</body></methods><methods><class-id>VWHelp.ArborDragBarController</class-id> <category>events</category><body package="Arbor Help System Outline Help Core">redButtonPressedEvent: event	self doDragFrom: event point.</body></methods><methods><class-id>VWHelp.ArborDragBarController</class-id> <category>testing</category><body package="Arbor Help System Outline Help Core">isVertical	^self view isVertical</body></methods><methods><class-id>VWHelp.ArborDragBarController class</class-id> <category>cursors</category><body package="Arbor Help System Outline Help Core">horizontalDragCursor	^HorizontalDragCursor isNil		ifTrue: [			HorizontalDragCursor := Cursor										image: self horizontalDragImage										mask: self horizontalDragMask										hotSpot: 7@8										name: 'horizontal drag']		ifFalse: [HorizontalDragCursor]</body><body package="Arbor Help System Outline Help Core">verticalDragCursor	^VerticalDragCursor isNil		ifTrue: [			VerticalDragCursor := Cursor										image: self verticalDragImage										mask: self verticalDragMask										hotSpot: 7@8										name: 'vertical drag']		ifFalse: [VerticalDragCursor]</body></methods><methods><class-id>VWHelp.AHSPersistentOrderedCollection</class-id> <category>converting</category><body package="Arbor Help System Outline Help Core">asArray	"Answer a new instance of PersistentArray whose elements are the elements of	the receiver, in the same order."	self shouldNotImplement	"| newPA |	newPA := AHSPersistentArray new: self size.	1 to: self size do: [:index | newPA at: index put: (self at: index)].	^newPA"</body><body package="Arbor Help System Outline Help Core">asOrderedCollection	"Return a copy of myself because I am conceptually more of an OrderedCollection variant than a subclass of OrderedCollection."	^self copy</body></methods><methods><class-id>VWHelp.AHSPersistentOrderedCollection</class-id> <category>removing</category><body package="Arbor Help System Outline Help Core">removeFirst	self odbDirty.	^super removeFirst.</body><body package="Arbor Help System Outline Help Core">removeFirst: numElements	self odbDirty.	^super removeFirst: numElements.</body><body package="Arbor Help System Outline Help Core">removeIndex: anIndex	self odbDirty.	^super removeIndex: anIndex.</body><body package="Arbor Help System Outline Help Core">removeLast	self odbDirty.	^super removeLast</body><body package="Arbor Help System Outline Help Core">removeLast: numElements	self odbDirty.	^super removeLast: numElements</body></methods><methods><class-id>VWHelp.AHSPersistentOrderedCollection</class-id> <category>adding</category><body package="Arbor Help System Outline Help Core">addFirst: newObject 	"Add newObject to the beginning of the receiver.  Answer newObject."	self odbDirty.	^super addFirst: newObject.</body><body package="Arbor Help System Outline Help Core">addLast: newObject 	"Add newObject to the end of the receiver.  Answer newObject."	self odbDirty.	^super addLast: newObject.</body><body package="Arbor Help System Outline Help Core">addLastNoCheck: newObject 	"Add newObject to the end of the receiver."	self odbDirty.	^super addLastNoCheck: newObject.</body><body package="Arbor Help System Outline Help Core">insert: anObject before: anIndex	self odbDirty.	^super insert: anObject before: anIndex.</body><body package="Arbor Help System Outline Help Core">makeRoomAtFirst	self odbDirty.	^super makeRoomAtFirst</body><body package="Arbor Help System Outline Help Core">makeRoomAtLast	self odbDirty.	^super makeRoomAtLast</body></methods><methods><class-id>VWHelp.AHSPersistentOrderedCollection</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">at: anInteger put: anObject 	"Put anObject at element index anInteger.  	at:put: can not be used to append, front or back, to an ordered  	collection;  it is used by a knowledgeable client to replace an 	element."	self odbDirty.	^super at: anInteger put: anObject</body></methods><methods><class-id>VWHelp.AHSAdjustableBoundedWrapper</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">backgroundColor	"Answer the receiver's background color."	^ColorValue white</body><body package="Arbor Help System Outline Help Core">changedPreferredBounds: oldPreferredBounds forComponent: aVisualComponent	"The preferred bounds of aVisualComponent has changed from oldPreferredBounds.  If the old bounds matches my bounds, then update myself to match the change."	self bounds: aVisualComponent preferredBounds.	"Copied from TranslatingWrapper"	container == nil		ifFalse: [oldPreferredBounds == nil					ifTrue: [container								changedPreferredBounds: oldPreferredBounds								forComponent: self]					ifFalse: [container								changedPreferredBounds: (oldPreferredBounds translatedBy: self translation)								forComponent: self]].</body></methods><methods><class-id>VWHelp.AHSOHCPreferencesModel</class-id> <category>interface opening</category><body package="Arbor Help System Outline Help Core">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self bookmarkDirectoryChanged.</body><body package="Arbor Help System Outline Help Core">preBuildWith: aBuilder	super preBuildWith: aBuilder.	aBuilder		aspectAt: #expandOutlines			put: (self adaptPreference: #expandOutlines);		aspectAt: #bookmarkDirectory			put: (self adaptPreference: #bookmarkDirectory);		aspectAt: #specifiedDirectory			put: (self adaptPreference: #specifiedDirectory);		aspectAt: #outlineViewerStyle			put: (self adaptPreference: #outlineViewerStyle).	(aBuilder aspectAt: #bookmarkDirectory)		onChangeSend: #bookmarkDirectoryChanged to: self.</body></methods><methods><class-id>VWHelp.AHSOHCPreferencesModel</class-id> <category>actions</category><body package="Arbor Help System Outline Help Core">selectDirectory	"Use a dialog to select the directory."	| aDirectory |	aDirectory := Dialog requestFileName: 'Choose a Directory' default: self specifiedDirectory value version: #mustBeOld.	(aDirectory notNil and: [aDirectory isEmpty not])		ifTrue: [			aDirectory asFilename isDirectory				ifFalse: [aDirectory := aDirectory asFilename directory asString].			self specifiedDirectory value: aDirectory asString].</body></methods><methods><class-id>VWHelp.AHSOHCPreferencesModel</class-id> <category>builder accessing</category><body package="Arbor Help System Outline Help Core">bookmarkDirectory	^self builder aspectAt: #bookmarkDirectory</body><body package="Arbor Help System Outline Help Core">specifiedDirectory	^self builder aspectAt: #specifiedDirectory</body></methods><methods><class-id>VWHelp.AHSOHCPreferencesModel</class-id> <category>updating</category><body package="Arbor Help System Outline Help Core">bookmarkDirectoryChanged	self bookmarkDirectory value == #specified		ifTrue: [self aisEnable: #(#specifiedDirectory #selectDirectory)]		ifFalse: [self aisDisable: #(#specifiedDirectory #selectDirectory)].</body></methods><methods><class-id>VWHelp.AHSOHCPreferencesModel class</class-id> <category>class initialization</category><body package="Arbor Help System Outline Help Core">initialize	self addPreferenceSpec: #bookmarkSpec.	self addPreferenceSpec: #outlinerSpec.</body></methods><methods><class-id>VWHelp.AHSOHCPreferencesModel class</class-id> <category>help info (AHS)</category><body package="Arbor Help System Outline Help Core">ahsHelpData	^(AHSHelpClassData languages: #(#English) widgetData: ((AHSPersistentDictionary new)	 add: (#currentDirectoryRB -&gt; ((AHSPersistentDictionary new)	 add: (#on -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'The Bookmark file will now be saved in the current directory.' runs: (RunArray runs: #(61) values: #(nil))); yourself) outlineLinks: nil));	 add: (#disabled -&gt; (AHSHelpData texts: nil outlineLinks: nil));	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Select this option to save the Bookmark file in the current directory.' runs: (RunArray runs: #(70) values: #(nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#specifiedDirectory -&gt; ((AHSPersistentDictionary new)	 add: (#disabled -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'When the radio button is selected, the Bookmark file will be stored in this directory.' runs: (RunArray runs: #(86) values: #(nil))); yourself) outlineLinks: #(nil)));	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'The Bookmark file will be stored in this directory.' runs: (RunArray runs: #(51) values: #(nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#expandOutlines -&gt; ((AHSPersistentDictionary new)	 add: (#on -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Outlines will open will all topics fully expanded.  Deselect this checkbox to have outlines open with no expansion.' runs: (RunArray runs: #(115) values: #(nil))); yourself) outlineLinks: nil));	 add: (#disabled -&gt; (AHSHelpData texts: nil outlineLinks: nil));	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Outlines will open with no topics expanded. Select this checkbox to have all outlines open already expanded.' runs: (RunArray runs: #(108) values: #(nil))); yourself) outlineLinks: nil)); yourself));	 add: (#linkGraphicsRB -&gt; ((AHSPersistentDictionary new)	 add: (#on -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Outlines with graphics marked as "embedded" will not embed - the graphics will appear as hyperlinks.' runs: (RunArray runs: #(44 8 48) values: #(nil #bold nil))); yourself) outlineLinks: nil));	 add: (#disabled -&gt; (AHSHelpData texts: nil outlineLinks: nil));	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Select this option to present all graphics as links within the text.' runs: (RunArray runs: #(68) values: #(nil))); yourself) outlineLinks: nil)); yourself));	 add: (#outlinerBox -&gt; ((AHSPersistentDictionary new)	 add: (#disabled -&gt; (AHSHelpData texts: nil outlineLinks: nil));	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'This section provides some configuration options of the Outliner.' runs: (RunArray runs: #(65) values: #(nil))); yourself) outlineLinks: nil)); yourself));	 add: (#outlineDirectoryRB -&gt; ((AHSPersistentDictionary new)	 add: (#on -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'The Bookmark file will now be stored in the same location as the outline file.' runs: (RunArray runs: #(78) values: #(nil))); yourself) outlineLinks: #(nil)));	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Select this option to store Bookmark files in the same location as the outline file.' runs: (RunArray runs: #(84) values: #(nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#specifiedDirectoryRB -&gt; ((AHSPersistentDictionary new)	 add: (#on -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'The Bookmark file will be stored in the directory shown. Use the Select... button to change the directory.' runs: (RunArray runs: #(65 9 32) values: #(nil #bold nil))); yourself) outlineLinks: #(nil)));	 add: (#disabled -&gt; (AHSHelpData texts: nil outlineLinks: nil));	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Select this option to specify the directory where the Bookmark file is to be stored.' runs: (RunArray runs: #(84) values: #(nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#bookmarkBox -&gt; ((AHSPersistentDictionary new)	 add: (#disabled -&gt; (AHSHelpData texts: nil outlineLinks: nil));	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Define the location of the bookmark file.  Users may create bookmarks when viewing an outline.' runs: (RunArray runs: #(94) values: #(nil))); yourself) outlineLinks: nil)); yourself));	 add: (#embedGraphicsRB -&gt; ((AHSPersistentDictionary new)	 add: (#on -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Outlines with graphics marked as "embedded" will display with the graphics embedded in the text.' runs: (RunArray runs: #(44 4 48) values: #(nil #bold nil))); yourself) outlineLinks: nil));	 add: (#disabled -&gt; (AHSHelpData texts: nil outlineLinks: nil));	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Select this option to embed graphics within the text when possible.' runs: (RunArray runs: #(67) values: #(nil))); yourself) outlineLinks: nil)); yourself));	 add: (#selectDirectory -&gt; ((AHSPersistentDictionary new)	 add: (#disabled -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Please choose the neighboring radio button to enable this button.' runs: (RunArray runs: #(65) values: #(nil))); yourself) outlineLinks: #(nil)));	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Presents a dialog used to specify the directory where Bookmark files will be stored.' runs: (RunArray runs: #(84) values: #(nil))); yourself) outlineLinks: #(nil))); yourself)); yourself))</body></methods><methods><class-id>VWHelp.AHSIndentableComposedText</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">backgroundColor	"Answer the receiver's background color."	^ColorValue white</body><body package="Arbor Help System Outline Help Core">baseIndentOffset	"Answer the number of pixels to indent for each indent level."	^DefaultTab</body><body package="Arbor Help System Outline Help Core">indentLevelAt: anIndex	"Support a text with an emphasis indicating an indent level."	| index |	index := anIndex isNil ifTrue: [1] ifFalse: [anIndex].	index &gt; self text size ifTrue: [^0].	self text		emphasis: (self text emphasisAt: index)		do: [:emph |			(emph aisIsAssociation and: [emph key = self class indentKey])				ifTrue: [^emph value]].	^0</body><body package="Arbor Help System Outline Help Core">indentOffsetAt: anIndex	^(self indentLevelAt: anIndex) * self baseIndentOffset</body><body package="Arbor Help System Outline Help Core">leftMarginForCompositionForLine: lineIndex	"Answer the left margin, taking into account information in the text requesting an indent.  Do not allow a left indent to exceed the right margin or the display routines blow up (when line wrapping is enabled, which is usually)."	^((super leftMarginForCompositionForLine: lineIndex)		+ (self indentOffsetAt: (lineTable lineStartAt: lineIndex)))			min: self rightMarginForComposition - 20</body></methods><methods><class-id>VWHelp.AHSIndentableComposedText class</class-id> <category>constants</category><body package="Arbor Help System Outline Help Core">indentKey	"Answer the key to use in an association within a Text to indicate an indent level."	^#ahsIndent</body></methods><methods><class-id>VWHelp.ArborDragBarSpec</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">aboveWidgets	^self isVertical		ifTrue: [#()]		ifFalse: [self widgetSet1]</body><body package="Arbor Help System Outline Help Core">belowWidgets	^self isVertical		ifTrue: [#()]		ifFalse: [self widgetSet2]</body><body package="Arbor Help System Outline Help Core">boundedDrag	^boundedDrag isNil		ifTrue: [true]		ifFalse: [boundedDrag]</body><body package="Arbor Help System Outline Help Core">boundedDrag: aBoolean	^aBoolean = true		ifTrue: [boundedDrag := nil]		ifFalse: [boundedDrag := aBoolean]</body><body package="Arbor Help System Outline Help Core">etched	^etched isNil		ifTrue: [true]		ifFalse: [etched]</body><body package="Arbor Help System Outline Help Core">etched: aBoolean	aBoolean = true		ifTrue: [etched := nil]		ifFalse: [etched := aBoolean].</body><body package="Arbor Help System Outline Help Core">leftWidgets	^self isVertical		ifTrue: [self widgetSet1]		ifFalse: [#()]</body><body package="Arbor Help System Outline Help Core">rightWidgets	^self isVertical		ifTrue: [self widgetSet2]		ifFalse: [#()]</body><body package="Arbor Help System Outline Help Core">widgetSet1	^widgetSet1 isNil		ifTrue: [#()]		ifFalse: [widgetSet1 asArray]</body><body package="Arbor Help System Outline Help Core">widgetSet1: aCollection	^aCollection isEmpty		ifTrue: [widgetSet1 := nil]		ifFalse: [widgetSet1 := aCollection]</body><body package="Arbor Help System Outline Help Core">widgetSet2	^widgetSet2 isNil		ifTrue: [#()]		ifFalse: [widgetSet2 asArray]</body><body package="Arbor Help System Outline Help Core">widgetSet2: aCollection	^aCollection isEmpty		ifTrue: [widgetSet2 := nil]		ifFalse: [widgetSet2 := aCollection]</body></methods><methods><class-id>VWHelp.ArborDragBarSpec</class-id> <category>building</category><body package="Arbor Help System Outline Help Core">dispatchTo: policy with: builder	"In concert with the given UILookPolicy, create a component in the builder as indicated by this spec."	policy arborDragBarView: self into: builder</body></methods><methods><class-id>VWHelp.ArborDragBarSpec</class-id> <category>testing</category><body package="Arbor Help System Outline Help Core">isVertical	^self orientation = #vertical</body></methods><methods><class-id>VWHelp.ArborOutlineBrowserModel</class-id> <category>menu messages</category><body package="Arbor Help System Outline Help Core">contract	"Contract the receiver's current selection and all of its children to a single item, keeping the state of expanded children expanded."	| oc |	Cursor wait showWhile: [		oc := List withAll: self displayedObjects.		self updateDisplayUsing: (self contractIndex: self selectedRowIndex in: oc fully: false)].</body><body package="Arbor Help System Outline Help Core">contract: anEntry	"Contract anEntry and all of its children to a single item, keeping the state of expanded children expanded."	| oc |	Cursor wait showWhile: [		oc := List withAll: self displayedObjects.		self updateDisplayUsing: (self contractIndex: (self holderIndexOf: anEntry in: oc) in: oc fully: false)].</body><body package="Arbor Help System Outline Help Core">contractFully	"Contract the receiver's current selection and all of its children to a single item"	| oc |	Cursor wait showWhile: [		oc := List withAll: self displayedObjects.		self updateDisplayUsing: (self contractIndex: self selectedRowIndex in: oc fully: true)].</body><body package="Arbor Help System Outline Help Core">contractFully: anEntry	"Contract anEntry and all of its children to a single item"	| oc |	Cursor wait showWhile: [		oc := List withAll: self displayedObjects.		self updateDisplayUsing: (self contractIndex: (self holderIndexOf: anEntry in: oc) in: oc fully: true)].</body><body package="Arbor Help System Outline Help Core">copy	"Copy the currently selected entry into my local clipboard."	self clipModel value: self selectedObject value.</body><body package="Arbor Help System Outline Help Core">cut	| curEntry |	curEntry := self selectedObject value.	"Contract it to clean up the openedSet."	self		contractIndex: self selectedRowIndex		in: (List withAll: self displayedObjects)		fully: true.	self deselectEntry.	curEntry isNil ifTrue: [^false].	(self parentFor: curEntry) isNil		ifTrue: [self forest remove: curEntry].	self deleteBlock value: curEntry.	self clipModel value: curEntry.	"If we've just deleted the last child, close the parent node"	self openedSet: (self openedSet select: self hasChildrenBlock).	self updateDisplay</body><body package="Arbor Help System Outline Help Core">expand	"Expand the receiver's current selection."	| oc |	Cursor wait showWhile: [		oc := List withAll: self displayedObjects.		self updateDisplayUsing: (self expandIndex: self selectedRowIndex in: oc fully: false)].</body><body package="Arbor Help System Outline Help Core">expand: anEntry	"Expand anEntry"	| oc |	Cursor wait showWhile: [		oc := List withAll: self displayedObjects.		self updateDisplayUsing: (self expandIndex: (self holderIndexOf: anEntry in: oc) in: oc fully: false)].</body><body package="Arbor Help System Outline Help Core">expandFully	"Expand the receiver's current selection and all of its children."	| oc |	Cursor wait showWhile: [		oc := List withAll: self displayedObjects.		self updateDisplayUsing: (self expandIndex: self selectedRowIndex in: oc fully: true)].</body><body package="Arbor Help System Outline Help Core">expandFully: anEntry	"Expand anEntry and all of its children."	| oc |	Cursor wait showWhile: [		oc := List withAll: self displayedObjects.		self updateDisplayUsing: (self expandIndex: (self holderIndexOf: anEntry in: oc) in: oc fully: true)].</body><body package="Arbor Help System Outline Help Core">newAfter	^self addNewEntry: #after</body><body package="Arbor Help System Outline Help Core">newBefore	^self addNewEntry: #before</body><body package="Arbor Help System Outline Help Core">newChild	^self addNewEntry: #child</body><body package="Arbor Help System Outline Help Core">pasteAfter	^self pasteEntry: #after</body><body package="Arbor Help System Outline Help Core">pasteBefore	^self pasteEntry: #before</body><body package="Arbor Help System Outline Help Core">pasteChild	^self pasteEntry: #child</body><body package="Arbor Help System Outline Help Core">toggle	self toggleIndex: self list selectionIndex fully: InputState default ctrlDown</body></methods><methods><class-id>VWHelp.ArborOutlineBrowserModel</class-id> <category>interface</category><body package="Arbor Help System Outline Help Core">selectedObject	"Answer the outline object currently selected or nil."	^self subclassResponsibility</body><body package="Arbor Help System Outline Help Core">selectedRowIndex	"Answer the row index that is currently selected.  0 means no selection."	^self subclassResponsibility</body></methods><methods><class-id>VWHelp.ArborOutlineBrowserModel</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">clipModel	^clipModel</body><body package="Arbor Help System Outline Help Core">deleteBlock	^deleteBlock</body><body package="Arbor Help System Outline Help Core">displayBlock	^displayBlock</body><body package="Arbor Help System Outline Help Core">forest	^forest</body><body package="Arbor Help System Outline Help Core">forest: aCollection	forest := aCollection.</body><body package="Arbor Help System Outline Help Core">getChildrenBlock	^getChildrenBlock</body><body package="Arbor Help System Outline Help Core">getParentBlock	^getParentBlock</body><body package="Arbor Help System Outline Help Core">hasChildrenBlock	^hasChildrenBlock</body><body package="Arbor Help System Outline Help Core">includeArrows	"Answer whether we are to include the arrows in the display.  The	arrows, when selected by the user, will contract or expand a node	in the hierarchical display."	^includeArrows</body><body package="Arbor Help System Outline Help Core">includeArrows: aBoolean	"Set whether we are to include the arrows in the display.  The	arrows, when selected by the user, will contract or expand a node	in the hierarchical display."	includeArrows := aBoolean.</body><body package="Arbor Help System Outline Help Core">isReadOnly	^readOnly == true</body><body package="Arbor Help System Outline Help Core">isReadOnly: aBoolean	readOnly := aBoolean.</body><body package="Arbor Help System Outline Help Core">menu	^menuHolder isNil ifTrue: [menuHolder := self buildMenu asValue] ifFalse: [menuHolder]</body><body package="Arbor Help System Outline Help Core">menu: aPopUpMenu	menuHolder isNil		ifTrue: [menuHolder := ValueHolder new].	menuHolder value: aPopUpMenu.</body><body package="Arbor Help System Outline Help Core">moveBlock	^moveBlock</body><body package="Arbor Help System Outline Help Core">newEntryBlock	^newEntryBlock</body><body package="Arbor Help System Outline Help Core">openedSet	^openedSet</body><body package="Arbor Help System Outline Help Core">openedSet: aSet	openedSet := aSet.</body><body package="Arbor Help System Outline Help Core">outline	"Answer the outline I'm displaying/editing"	^self forest</body><body package="Arbor Help System Outline Help Core">outline: anOrderedCollection	"Set the forest that makes up the outline we're viewing/editing.  This includes clearing the current selection as well as clearing out the openedSet and any other miscellaneous operations."	self		deselectEntry;		openedSet: IdentitySet new;		forest: anOrderedCollection;		updateDisplay</body></methods><methods><class-id>VWHelp.ArborOutlineBrowserModel</class-id> <category>default blocks</category><body package="Arbor Help System Outline Help Core">defaultDeleteBlock	"Default to using the Tree protocol (a bad assumption?)."	^[:obj | obj parent isNil ifFalse: [obj parent removeChild: obj ifAbsent: []]]</body><body package="Arbor Help System Outline Help Core">defaultDisplayBlock	^[:obj | obj displayString]</body><body package="Arbor Help System Outline Help Core">defaultGetChildrenBlock	"Default to the Tree protocol (a bad assumption?)."	^[:parent | parent children]</body><body package="Arbor Help System Outline Help Core">defaultGetParentBlock	"Default to using the tree protocol."	^[:child | child parent]</body><body package="Arbor Help System Outline Help Core">defaultHasChildrenBlock	"By default, use the getChildrenBlock to determine whether	there are children.  There may be a more efficient way of doing this."	^[:parent | (self getChildrenBlock value: parent) isEmpty not]</body><body package="Arbor Help System Outline Help Core">defaultMoveBlock	"Default to using the Tree protocol (a bad assumption?)."	^[:newChild :parent :olderSibling |		newChild parent isNil			ifFalse: [newChild parent removeChild: newChild ifAbsent: []].		parent isNil			ifFalse: [parent addChild: newChild after: olderSibling]].</body><body package="Arbor Help System Outline Help Core">defaultNewEntryBlock	"Default to using a Tree (a bad assumption?)."	^[ArborAbstractTree new]</body><body package="Arbor Help System Outline Help Core">secondaryDefaultGetParentBlock	"Default to using the labeled object holders.  It would be best if the	user overrode this implementation as it has (at least) two flaws:		a) It will be get slower with the number of nodes displayed		b) It only works for those nodes actually displayed.  This			means that methods like #selectEntry: may NOT work			since it might require fetching the parent of a node that			is not yet displayed.  The parent of an undisplayed node			is nil (just like a root node - got a better idea?)."	"Use this as the 'get parent' block if you are not using trees in the outline and choose not to maintain parental references."	^[:child | | holder |		(holder := self displayedObjects					detect: [:obj | obj value = child]					ifNone: [nil]) isNil			ifTrue: [nil]			ifFalse: [holder parent value]]</body></methods><methods><class-id>VWHelp.ArborOutlineBrowserModel</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">addChild: anObject to: anOrderedCollection parent: aParent	|isOpen loh|	isOpen := self isOpen: anObject.	loh := self labeledObjectHolderFor: anObject parent: aParent.	anOrderedCollection add: loh.	isOpen		ifTrue:			[ | children |			children := self childrenFor: anObject.			children do: [:child |				self addChild: child to: anOrderedCollection parent: loh]]</body><body package="Arbor Help System Outline Help Core">childrenFor: anObject	^self getChildrenBlock value: anObject</body><body package="Arbor Help System Outline Help Core">contractIndex: anIndex in: aCollection fully: aBoolean	"Contract the entry at anIndex in aCollection.  If aBoolean is true, then contract all children recursively."	^self contractIndex: anIndex in: aCollection fully: aBoolean topNode: true</body><body package="Arbor Help System Outline Help Core">contractIndex: anIndex in: aCollection fully: aBoolean topNode: isTop	"Contract the entry at anIndex in aCollection.  If aBoolean is true, then contract all children recursively.  If we are the top node (as indicated by isTop) then remove the element at anIndex from the openedSet also."	| anEntry lohEntry lohChild |	anIndex isZero ifTrue: [^self].	anEntry := (lohEntry := aCollection at: anIndex) value.	((self openedSet includes: anEntry) and: [self hasChildren: anEntry])		ifTrue: [(self childrenFor: anEntry) size timesRepeat: [					lohChild := aCollection at: anIndex + 1.					self contractIndex: anIndex + 1 in: aCollection fully: aBoolean topNode: false.					aBoolean ifTrue: [self openedSet remove: lohChild value ifAbsent: []].					aCollection removeAtIndex: anIndex + 1].				isTop ifTrue: [self openedSet remove: anEntry ifAbsent: []].				lohEntry isExpanded: false.				lohEntry canBeExpanded: true]		ifFalse: [	"There may be undisplayed children that are open.  Close those too."			(aBoolean and: [self hasChildren: anEntry])				ifTrue: [| nodes |					nodes := OrderedCollection withAll: (self childrenFor: anEntry).					[nodes isEmpty not] whileTrue: [| n |						n := nodes removeFirst.						self openedSet remove: n ifAbsent: [].						nodes addAllLast: (self childrenFor: n)]]].	^aCollection</body><body package="Arbor Help System Outline Help Core">displayedObjects	"Answer the collection of objects being displayed in the window."	^self subclassResponsibility</body><body package="Arbor Help System Outline Help Core">emphasisFor: anObject	^#bold</body><body package="Arbor Help System Outline Help Core">expandIndex: anIndex in: aCollection fully: aBoolean	"Expand the entry at anIndex in aCollection.  If aBoolean is true, then expand all children recursively."	| anEntry children lohEntry |	anEntry := (lohEntry := aCollection at: anIndex) value.	(self hasChildren: anEntry) ifTrue: [		children := self childrenFor: anEntry.		(self openedSet includes: anEntry) ifFalse: [			self openedSet add: anEntry.			lohEntry isExpanded: true.			lohEntry canBeExpanded: false.			children reverseDo: [:child |				aCollection					add: (self labeledObjectHolderFor: child parent: lohEntry)					beforeIndex: anIndex + 1.				(self openedSet includes: child)					ifTrue: [self openedSet remove: child.	"A wee little kludge."							self expandIndex: anIndex + 1 in: aCollection fully: false]]].		aBoolean ifTrue: [| bareCollection |			bareCollection := aCollection collect: [:loh | loh value].			children reverseDo: [:child |				self					expandIndex: (self indexOf: child in: bareCollection)					in: aCollection					fully: true]]].	^aCollection</body><body package="Arbor Help System Outline Help Core">hasChildren: anObject	^self hasChildrenBlock value: anObject</body><body package="Arbor Help System Outline Help Core">holderIndexOf: anObject in: aSequenceableCollection	"Answer the index of the holder of anObject in aSequenceableCollection."	^self indexOf: anObject in: (aSequenceableCollection collect: [:loh | loh value])</body><body package="Arbor Help System Outline Help Core">indexOf: anObject in: aSequenceableCollection	"Use #== to compare and find the index - the normal #indexOf: implementation on SequenceableCollection uses #=."	^(1 to: aSequenceableCollection size)		detect: [:i | (aSequenceableCollection at: i) == anObject]		ifNone: [0]</body><body package="Arbor Help System Outline Help Core">isOpen: anObject		"Make sure anObject can still BE open.		The hierarchy may have been edited w/o my		knowledge..."		| open |	open := self openedSet includes: anObject.	(open and: [(self hasChildren: anObject) not])		ifTrue: [open := false.				self openedSet remove: anObject].	^open</body><body package="Arbor Help System Outline Help Core">labeledObjectHolderFor: anObject parent: aParent	| loh |	(loh := ArborOutlineLabeledObjectHolder			newValue: anObject			indentLevel: (aParent isNil							ifTrue: [0]							ifFalse: [aParent indentLevel + 1])			parent: aParent)				isExpanded: (self isOpen: anObject);				canBeExpanded: ((self isOpen: anObject) not and: [self hasChildren: anObject]).	loh emphasis: (self emphasisFor: anObject).	self displayBlock isNil		ifFalse: [loh displayBlock: self displayBlock].	^loh</body><body package="Arbor Help System Outline Help Core">parentFor: anEntry	^(self forest includes: anEntry)		ifTrue: [nil]		ifFalse: [getParentBlock value: anEntry]</body><body package="Arbor Help System Outline Help Core">pContractFully: aNode	"Remove aNode and all children from the opened set."	| n |	n := self openedSet remove: aNode ifAbsent: [].	n == aNode		ifFalse:	[^self].	(self childrenFor: aNode) do: 		[:child | 		self pContractFully: child]</body><body package="Arbor Help System Outline Help Core">redrawDisplayUsing: aCollection	"Physically refresh the outline displayed."	self subclassResponsibility.</body><body package="Arbor Help System Outline Help Core">toggleIndex: anInteger fully: aBoolean	| loh oc redisplay |	redisplay := false.	oc := List withAll: self displayedObjects.	loh := self list list at: anInteger.	loh isExpanded		ifTrue: [oc := self contractIndex: anInteger in: oc fully: aBoolean.				redisplay := true]		ifFalse: [loh canBeExpanded					ifTrue: [oc := self expandIndex: anInteger in: oc fully: aBoolean.							redisplay := true]].	redisplay		ifTrue: [self updateDisplayUsing: oc]</body><body package="Arbor Help System Outline Help Core">updateDisplayUsing: aCollection	"Update the display on the screen with a new/modified outline.  It is assumed that related instance variables are properly maintained (such as the openedSet)."	self redrawDisplayUsing: aCollection.</body></methods><methods><class-id>VWHelp.ArborOutlineBrowserModel</class-id> <category>actions</category><body package="Arbor Help System Outline Help Core">deselectEntry	"Deselect any existing selection."	^self subclassResponsibility</body><body package="Arbor Help System Outline Help Core">removeEntry: aNode	"Remove aNode from the outline.  This method does not require that aNode be the currently selected object (unlike #cut)."	self removeEntryQuietly: aNode.	self updateDisplay.</body><body package="Arbor Help System Outline Help Core">removeEntryQuietly: aNode	"Remove aNode from the outline.  This method does not require that aNode be the currently selected object (unlike #cut).  Does not update the display when finished.  This is useful when multiple removes are performed so the outline doesn't flash.  Be sure to send #updateDisplay when complete."	| oc |	aNode isNil ifTrue: [^false].	self selectedObject value == aNode		ifTrue: [self deselectEntry].	"Contract it to clean up the openedSet."	oc := List withAll: self displayedObjects.	self		contractIndex: (self holderIndexOf: aNode in: oc)		in: oc		fully: true.	(self parentFor: aNode) isNil		ifTrue: [self forest remove: aNode ifAbsent: []].	self deleteBlock value: aNode.	self clipModel value: aNode.	"If we've just deleted the last child, close the parent node"	self openedSet: (self openedSet select: self hasChildrenBlock).</body><body package="Arbor Help System Outline Help Core">selectEntry: anEntry	"Try to select anEntry in the outline, expanding if necessary.  If a node requires expansion, then update the display once all expansions are complete."	"Expand all ancestors"	| anc updateRequired |	self selectedObject value == anEntry ifTrue: [^self].	updateRequired := false.	anc := anEntry notNil ifTrue: [self parentFor: anEntry] ifFalse: [anEntry].	[anc isNil] whileFalse: [		(self openedSet includes: anc) not			ifTrue: [				self openedSet add: anc.				updateRequired := true].		anc := self parentFor: anc].	updateRequired ifTrue: [self updateDisplay].</body><body package="Arbor Help System Outline Help Core">updateDisplay	"Update the display on the screen with a new/modified outline.  Entirely rebuild the display tree from the openedSet and base forest.  This is as opposed to using #updateDisplayUsing: which is used to avoid generating excess garbage as well as avoiding repeated hierarchy traversal whenever a node is expanded or contracted (which can get quite slow for large and/or deep hierarchies)."	| coll |	coll := List new.	self forest do: [:tree |		self addChild: tree to: coll parent: nil].	self redrawDisplayUsing: coll.</body></methods><methods><class-id>VWHelp.ArborOutlineBrowserModel</class-id> <category>client hooks</category><body package="Arbor Help System Outline Help Core">clipModel: aValueModel	"Set the clipboard channel.  Should be a value model that provides clipboard functionality."	clipModel := aValueModel.</body><body package="Arbor Help System Outline Help Core">deleteBlock: aBlockClosure	deleteBlock := aBlockClosure</body><body package="Arbor Help System Outline Help Core">displayBlock: aBlockClosure	"Provide a block for displaying objects.	The default is to send it the #displayString message.	The block takes the object as an argument, and should answer a String"	displayBlock := aBlockClosure</body><body package="Arbor Help System Outline Help Core">getChildrenBlock: aBlockClosure	"Provide a block for getting the children from an object.	The default sends the message #children to the object.	The block should take the object as an argument, and answer an OrderedCollection		of children objects"	getChildrenBlock := aBlockClosure</body><body package="Arbor Help System Outline Help Core">getParentBlock: aBlockClosure	"Provide a block for getting the parent of an object.	The default sends the message #parent to the object.	The block should take the object as an argument, and answer the parent"	getParentBlock := aBlockClosure</body><body package="Arbor Help System Outline Help Core">hasChildrenBlock: aBlockClosure	"Provide a block for finding out whether an object has children.	The default evaluates the getChildren block and checks the size.	The block should take the object as an argument"	hasChildrenBlock := aBlockClosure</body><body package="Arbor Help System Outline Help Core">moveBlock: aBlockClosure	"Provide a block for moving a new or old entry in the outline.	The default assumes Tree protocol (see intialize).	The block takes three arguments:		1.  The object to be moved		2. The new parent of the object, or nil.			If nil, then the object is being moved to the top of the hierarchy,			and it will be added to the forest proper (in which case			the block is not responsible for doing that)		3. The sibling object that the object should be added after.			If nil, then it should be the first child of the new parent"		moveBlock := aBlockClosure</body><body package="Arbor Help System Outline Help Core">newEntryBlock: aBlockClosure	"Provide a block for creating a new entry in the outline.	The default creates an empty instance of Tree.	The block takes no arguments.	After the entry is created, it will then be inserted into the outline	by evaluating the moveBlock (see moveBlock:)"		newEntryBlock := aBlockClosure</body></methods><methods><class-id>VWHelp.ArborOutlineBrowserModel</class-id> <category>private-outline editing</category><body package="Arbor Help System Outline Help Core">addEntry: anEntry where: aSymbol	"aSymbol: &lt;#before | #after | #child | #firstChild | #lastChild &gt;  (#child defaults to #lastChild)"	^self addEntry: anEntry where: aSymbol inRelationTo: self selectedObject value</body><body package="Arbor Help System Outline Help Core">addEntry: anEntry where: aSymbol inRelationTo: anotherEntry	"aSymbol: &lt;#before | #after | #child | #firstChild | #lastChild &gt;  (#child defaults to #lastChild)"	| parent siblings|	parent := anotherEntry notNil ifTrue: [self parentFor: anotherEntry].	siblings := parent isNil					ifTrue: [self forest]					ifFalse: [self childrenFor: parent].	aSymbol == #before		ifTrue: [|afterSibling i|				i := 1.				[(siblings at: i) == anotherEntry]					whileFalse: [i := i + 1].				i &gt; 1					ifTrue: [afterSibling := siblings at: i - 1].				parent isNil ifTrue: [afterSibling isNil									ifTrue: [self forest addFirst: anEntry]									ifFalse: [self forest add: anEntry after: afterSibling]].				self moveBlock value: anEntry value: parent value: afterSibling].	aSymbol == #after		ifTrue: [parent isNil					ifTrue: [anotherEntry isNil							ifTrue: [self forest addFirst: anEntry]							ifFalse: [self forest add: anEntry after: anotherEntry]].				self moveBlock value: anEntry value: parent value: anotherEntry].	(aSymbol == #child or: [aSymbol == #firstChild or: [aSymbol == #lastChild]])		ifTrue: [| olderSibling |			self openedSet add: anotherEntry.			(aSymbol ~= #firstChild and: [anotherEntry children isEmpty not])				ifTrue: [olderSibling := anotherEntry children last].			self moveBlock value: anEntry value: anotherEntry value: olderSibling].	self updateDisplay.</body><body package="Arbor Help System Outline Help Core">addNewEntry: aSymbol	"aSymbol: &lt;#before | #after | #child | #firstChild | #lastChild &gt;  (#child defaults to #lastChild)"	|new|	new := self newEntryBlock value.	^new isNil		ifFalse: [self addEntry: new where: aSymbol]</body><body package="Arbor Help System Outline Help Core">pasteEntry: aSymbol	"aSymbol: &lt;#before | #after | #child&gt;"	|entry|	entry := self clipModel value copy.	entry isNil ifTrue: [self error: 'Nothing on the clipboard'].	^self addEntry: entry where: aSymbol</body></methods><methods><class-id>VWHelp.ArborOutlineBrowserModel</class-id> <category>initialize-release</category><body package="Arbor Help System Outline Help Core">initialize	super initialize.	self		includeArrows: true;		openedSet: IdentitySet new;		clipModel: nil asValue;		forest: List new;		getChildrenBlock: self defaultGetChildrenBlock;		getParentBlock: self defaultGetParentBlock;		hasChildrenBlock: self defaultHasChildrenBlock;		displayBlock: self defaultDisplayBlock;		newEntryBlock: self defaultNewEntryBlock;		moveBlock: self defaultMoveBlock;		deleteBlock: self defaultDeleteBlock.</body></methods><methods><class-id>VWHelp.ArborOutlineBrowserModel</class-id> <category>private-menu building</category><body package="Arbor Help System Outline Help Core">addCopyCutPasteToMenu: aMenu	| group |	group := OrderedCollection new: 4.	#(copy cut)		with: #(selectedCopy selectedCut)		do: [:action :id |			group				add: ((MenuItem labeled: action)							value: action;							nameKey: id;							hidden: [self selectedObject value isNil or: [self isReadOnly]])].	group		add: ((MenuItem labeled: 'paste')					value: #paste;					nameKey: #unselectedPaste;					enabled: [self clipModel value notNil];					hidden: [self selectedObject value notNil or: [self isReadOnly]]);		add: ((MenuItem labeled: 'paste')					submenu: (Menu									labelArray: #('before' 'after' 'child')									values: #(pasteBefore pasteAfter pasteChild));					nameKey: #selectedPaste;					enabled: [self clipModel value notNil];					hidden: [self selectedObject value isNil or: [self isReadOnly]]).	aMenu addItemGroup: group.</body><body package="Arbor Help System Outline Help Core">addEntryCreationToMenu: aMenu	| group |	group := OrderedCollection new: 4.	group		add: ((MenuItem labeled: 'new')					value: #newAfter;					nameKey: #unselectedNew;					hidden: [self selectedObject value notNil or: [self isReadOnly]]);		add: ((MenuItem labeled: 'new')					submenu: (Menu									labelArray: #('before' 'after' 'child')									values: #(newBefore newAfter newChild));					nameKey: #selectedNew;					hidden: [self selectedObject value isNil or: [self isReadOnly]]).	aMenu addItemGroup: group.</body><body package="Arbor Help System Outline Help Core">addExpandContractToMenu: aMenu	| group hasChildren canExpand canContract |	group := OrderedCollection new: 4.	#('expand' 'expand fully' 'contract' 'contract fully')		with: #(expand expandFully contract contractFully)		do: [:label :action |			group add: ((MenuItem labeled: label)							value: action;							nameKey: action;							hidden: [self selectedObject value isNil])].	aMenu addItemGroup: group.	hasChildren := [self hasChildren: self selectedObject value].	canExpand := [hasChildren value and: [(self isOpen: self selectedObject value) not]].	canContract := [hasChildren value and: [self isOpen: self selectedObject value]].	(aMenu atNameKey: #expand) enabled: canExpand.	(aMenu atNameKey: #expandFully) enabled: hasChildren.	(aMenu atNameKey: #contract) enabled: canContract.	(aMenu atNameKey: #contractFully) enabled: hasChildren.</body><body package="Arbor Help System Outline Help Core">buildMenu	"Build and answer the menu."	| m |	m := Menu new.	self		addExpandContractToMenu: m;		addEntryCreationToMenu: m;		addCopyCutPasteToMenu: m.	^m</body></methods><methods><class-id>VWHelp.ArborOutlineBrowserModel</class-id> <category>change messages</category><body package="Arbor Help System Outline Help Core">doubleClickOccurred	self toggle.	self changed: #doubleClick with: self selectedObject.</body><body package="Arbor Help System Outline Help Core">selectionChanged	self changed: #selection with: self selectedObject.</body></methods><methods><class-id>VWHelp.ArborListOutlineBrowserModel</class-id> <category>interface</category><body package="Arbor Help System Outline Help Core">selectedObject	(self list list size &gt;= self list selectionIndexHolder value)		ifTrue: [^self list selection]		ifFalse: [^nil asValue]</body><body package="Arbor Help System Outline Help Core">selectedRowIndex	"Answer the row index that is currently selected in the list.  0 means no selection."	^self list selectionIndex</body></methods><methods><class-id>VWHelp.ArborListOutlineBrowserModel</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">displayedObjects	"Answer the collection of objects being displayed in the window."	^self list listHolder value</body><body package="Arbor Help System Outline Help Core">expandIndex: anIndex in: aCollection fully: aBoolean	"Adjust the list so that after expanding as many of the children as possible are visible."	| startSize |	startSize := aCollection size.	super expandIndex: anIndex in: aCollection fully: aBoolean.	aCollection size ~= startSize ifTrue: [		(self builder componentAt: #list) widget			makeVisibleFrom: anIndex			to: anIndex + aCollection size - startSize].	^aCollection</body><body package="Arbor Help System Outline Help Core">redrawDisplayUsing: aCollection	"Reset the list, but be careful of how it gets redrawn.  The parameter is a collection	of appropriately indented strings."	| start min disp |	start := (((1 to: (min := ((disp := self displayedObjects) size min: aCollection size)))				detect: [:i | (disp at: i) ~~ (aCollection at: i)]				ifNone: [min + 1]) - 1) max: 1.	self list listHolder setValue: aCollection.	self builder isNil		ifFalse: [| view |			view := (self builder componentAt: #list) widget.			view targetIndex &gt; aCollection size ifTrue: [view targetIndex: view zeroIndex].			view selectionIndex &gt; aCollection size ifTrue: [view setSelectionIndex: view zeroIndex].			"Duplicate some of SelectionView&gt;&gt;updateModel"			view	 			sequence: aCollection;				elementsInSequenceHaveChanged;				changedPreferredBounds: nil;				forceMaximumVisibility;				invalidateToBottomFromElementIndex: start].</body><body package="Arbor Help System Outline Help Core">toggleIndex: anInteger fully: aBoolean	"Be sure the element being toggled is selected."	self list selectionIndex: anInteger.	^super toggleIndex: anInteger fully: aBoolean</body></methods><methods><class-id>VWHelp.ArborListOutlineBrowserModel</class-id> <category>interface opening</category><body package="Arbor Help System Outline Help Core">autoConvertList	"Support subclasses that expect my #postBuildWith: method to convert the list from a regular list to a hierarchical list.  This should only happen for subclasses in older modules.  The new approach is to use Arbor's hierarchical list widget from the painter."	| seqView outSeqView |	seqView := (self builder componentAt: #list) widget.	(seqView isKindOf: ArborHierarchicalSequenceView) ifTrue: [^self].	outSeqView := ArborHierarchicalSequenceView new.	1 to: SequenceView instSize do: [:i | 	outSeqView instVarAt: i put: (seqView instVarAt: i)].	outSeqView controller: nil.	1 to: SequenceController instSize do: [:i | outSeqView controller instVarAt: i put: (seqView controller instVarAt: i)].	seqView become: outSeqView.</body><body package="Arbor Help System Outline Help Core">postBuildWith: aBuilder	| seqView style |	super postBuildWith: aBuilder.	self autoConvertList.	seqView := (aBuilder componentAt: #list) widget.	seqView includeArrows: self includeArrows.	"Adjust the style for appropriate list-type viewing.  This is done in case the user has overridden the text style - otherwise the lineGrid is too large and the list looks ugly."	style := seqView textStyle copy.	style gridForFont: nil withLead: 0.	seqView setTextStyle: style.</body></methods><methods><class-id>VWHelp.ArborListOutlineBrowserModel</class-id> <category>private-outline editing</category><body package="Arbor Help System Outline Help Core">addEntry: anEntry where: aSymbol	super addEntry: anEntry where: aSymbol.	self list selection: anEntry.</body></methods><methods><class-id>VWHelp.ArborListOutlineBrowserModel</class-id> <category>actions</category><body package="Arbor Help System Outline Help Core">deselectEntry	"Deselect the entry in the list."	self list selection: nil</body><body package="Arbor Help System Outline Help Core">selectEntry: anEntry	super selectEntry: anEntry.	"Be sure any pending redraws are complete, otherwise it can get messy (visually)."	ScheduledControllers checkForEvents.	self list selection: anEntry</body></methods><methods><class-id>VWHelp.ArborListOutlineBrowserModel</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">includeArrows: aBoolean	"Remove arrows (or whatever the expand/contract icons may be) from the display."	| view |	includeArrows = aBoolean ifTrue: [^self].	super includeArrows: aBoolean.	self builder notNil ifTrue: [		view := (self builder componentAt: #list) widget.		view includeArrows: aBoolean.		view invalidate].</body><body package="Arbor Help System Outline Help Core">list	"Answer our SelectionInList"	^list</body><body package="Arbor Help System Outline Help Core">list: aSelectionInList	list := aSelectionInList.</body></methods><methods><class-id>VWHelp.ArborListOutlineBrowserModel</class-id> <category>initialize-release</category><body package="Arbor Help System Outline Help Core">initialize	super initialize.	self list: (SelectionInList with: self forest).	self list selectionIndexHolder onChangeSend: #selectionChanged to: self.</body></methods><methods><class-id>VWHelp.ArborListOutlineBrowserModel</class-id> <category>default blocks</category><body package="Arbor Help System Outline Help Core">defaultDisplayBlock	^[:obj | obj displayString]</body></methods><methods><class-id>VWHelp.ArborListOutlineBrowserModel</class-id> <category>obsolete</category><body package="Arbor Help System Outline Help Core">indentString: aString	"OBSOLETE - support for earlier releases."</body></methods><methods><class-id>VWHelp.AHSOutlineViewerModel</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">buildMenu	"Build and answer the menu."	| m |	m := Menu new.	self addExpandContractToMenu: m.	^m</body><body package="Arbor Help System Outline Help Core">canExpand: anEntry fully: fully	"Answer true if able to get a read lock on all of the trees that will be opened by expanding anEntry."	| canExpand |	canExpand := true.	anEntry value children do: 		[:child |	| loh |		child odbReadLock			ifTrue: 				[loh := self 							labeledObjectHolderFor: child 							parent: anEntry.				(loh isExpanded or: [fully]) ifTrue: 					[(self 						canExpand: loh 						fully: fully) ifFalse: [canExpand := false]]]			ifFalse: [canExpand := false]].	^ canExpand.</body><body package="Arbor Help System Outline Help Core">canSelect: anEntry	"Answer true if able to get a read lock on all of the trees that will be displayed by selecting anEntry."	| canSelect currEntry |	canSelect := true.	currEntry := anEntry.	[(currEntry := currEntry parent) isNil not and: [canSelect]] 		whileTrue: [currEntry children do: [:child |										child odbReadLock											ifFalse: [canSelect := false]]].	^canSelect.</body><body package="Arbor Help System Outline Help Core">contractIndex: anIndex in: aCollection fully: aBoolean topNode: isTop	self master textController textHasChanged ifTrue: [self master forceAccept].	^ super 		contractIndex: anIndex 		in: aCollection 		fully: aBoolean 		topNode: isTop</body><body package="Arbor Help System Outline Help Core">expandIndex: anIndex in: aCollection fully: aBoolean	self master textController textHasChanged ifTrue: [self master forceAccept].	^ super 		expandIndex: anIndex 		in: aCollection 		fully: aBoolean</body><body package="Arbor Help System Outline Help Core">labeledObjectHolderFor: anObject parent: aParent	| loh |	loh := super 			labeledObjectHolderFor: anObject 			parent: aParent.	loh isExpanded: ((self isOpen: anObject) and: [self hasChildren: anObject]).	loh iconSet: #book.	^ loh</body><body package="Arbor Help System Outline Help Core">toggleIndex: anInteger fully: aBoolean	| loh |	self list selectionIndex: anInteger.	loh := self list list at: anInteger.	loh isExpanded		ifTrue: 			[aBoolean				ifTrue: [self contractFully: loh value]				ifFalse: [self contract: loh value]]		ifFalse: 			[loh canBeExpanded ifTrue: 				[aBoolean					ifTrue: [self expandFully: loh value]					ifFalse: [self expand: loh value]]].</body><body package="Arbor Help System Outline Help Core">updateLocks	"Update locks.  Since we are read only we shouldn't need to do anything.  In fact, we should find out if we need	 to use this method at all."</body></methods><methods><class-id>VWHelp.AHSOutlineViewerModel</class-id> <category>testing</category><body package="Arbor Help System Outline Help Core">hasEmptySelection	"Answer true if the list associated with the receiver does not have an active selection."		^ self hasSelection not</body><body package="Arbor Help System Outline Help Core">hasSelection	"Answer true if the list associated with the receiver has an active selection."		^ self list selection notNil</body></methods><methods><class-id>VWHelp.AHSOutlineViewerModel</class-id> <category>actions</category><body package="Arbor Help System Outline Help Core">outlineDo: aBlock	^self outline do: [:each | each do: aBlock]</body><body package="Arbor Help System Outline Help Core">selectEntry: anEntry	"If all the topics that will be displayed by selected anEntry can aquire a read lock, then select the entry."	(anEntry isNil or: [self canSelect: anEntry])		ifTrue: [super selectEntry: anEntry]		ifFalse: 			[self updateLocks.			Dialog warn: 'Can not select the entry because someone is changing the outline structure.']</body><body package="Arbor Help System Outline Help Core">updateDisplay	"Update the display on the screen with a new/modified outline.  Entirely rebuild the display tree from the openedSet and base forest.  This is as opposed to using #updateDisplayUsing: which is used to avoid generating excess garbage as well as avoiding repeated hierarchy traversal whenever a node is expanded or contracted (which can get quite slow for large and/or deep hierarchies)."	| oc |	oc := List new.	self outline odbDeepRefresh.	self updateLocks.	self openedSet: (self openedSet select: self hasChildrenBlock).	self outline do: 		[:tree |		self 			addChild: tree 			to: oc 			parent: nil].	self redrawDisplayUsing: oc.</body></methods><methods><class-id>VWHelp.AHSOutlineViewerModel</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">forest	^super forest odbRefreshIfNotDirty.</body><body package="Arbor Help System Outline Help Core">isReadOnly	^ true</body><body package="Arbor Help System Outline Help Core">master	^master</body><body package="Arbor Help System Outline Help Core">master: anApplicationModel	^master := anApplicationModel</body><body package="Arbor Help System Outline Help Core">selectionValue	"Answer the value of the current selection, or nil if no selection exists."	^ self hasSelection		ifTrue: [self list selection value]		ifFalse: [nil]</body></methods><methods><class-id>VWHelp.AHSOutlineViewerModel</class-id> <category>menu messages</category><body package="Arbor Help System Outline Help Core">contract	"Contract the receiver's current selection and all of its children to a single item, keeping the state of expanded children expanded."	| oc |	Cursor wait showWhile: 		[oc := self displayedObjects asOrderedCollection.		self updateDisplayUsing: (self 										contractIndex: self selectedRowIndex 										in: oc 										fully: false).		self updateLocks].</body><body package="Arbor Help System Outline Help Core">contract: anEntry	"Contract anEntry and all of its children to a single item, keeping the state of expanded children expanded."	| oc |	Cursor wait showWhile: 		[oc := self displayedObjects asOrderedCollection.		self updateDisplayUsing: (self 										contractIndex: (oc indexOf: anEntry) 										in: oc 										fully: false).		self updateLocks].</body><body package="Arbor Help System Outline Help Core">contractFully	"Contract the receiver's current selection and all of its children to a single item"	| oc |	Cursor wait showWhile: [		oc := self displayedObjects asOrderedCollection.		self updateDisplayUsing: (self contractIndex: self selectedRowIndex in: oc fully: true).		self updateLocks].</body><body package="Arbor Help System Outline Help Core">contractFully: anEntry	"Contract anEntry and all of its children to a single item"	| oc |	Cursor wait showWhile: 		[oc := self displayedObjects asOrderedCollection.		self updateDisplayUsing: (self 										contractIndex: (oc indexOf: anEntry) 										in: oc 										fully: true).		self updateLocks].</body><body package="Arbor Help System Outline Help Core">expand	"Expand the receiver's current selection."	| oc |	Cursor wait showWhile: 		[oc := self displayedObjects asOrderedCollection.		self outline odbDeepRefresh.		self updateLocks.		(self 			canExpand: self selectedObject 			fully: false)			ifTrue: 				[self updateDisplayUsing: (self 												expandIndex: self selectedRowIndex 												in: oc 												fully: false)]			ifFalse: 				[self updateLocks.				Dialog warn: 'Unable to expand because someone is modifying the outline structure.']].</body><body package="Arbor Help System Outline Help Core">expand: anEntry	"Expand anEntry"	| oc |	Cursor wait showWhile: [		oc := self displayedObjects asOrderedCollection.		self outline odbDeepRefresh.		self updateLocks.		(self canExpand: (oc at: (oc indexOf: anEntry)) fully: false)			ifTrue: [self updateDisplayUsing: (self expandIndex: (oc indexOf: anEntry) in: oc fully: false)]			ifFalse: [self updateLocks.					Dialog warn: 'Unable to expand because someone is modifying the outline structure.']].</body><body package="Arbor Help System Outline Help Core">expandFully	"Expand the receiver's current selection and all of its children."	| oc |	Cursor wait showWhile: [		oc := self displayedObjects asOrderedCollection.		self outline odbDeepRefresh.		self updateLocks.		(self canExpand: self selectedObject fully: true)			ifTrue: [self updateDisplayUsing: (self expandIndex: self selectedRowIndex in: oc fully: true)]			ifFalse: [self updateLocks.					Dialog warn: 'Unable to expand because someone is modifying the outline structure.']].</body><body package="Arbor Help System Outline Help Core">expandFully: anEntry	"Expand anEntry and all of its children."	| oc |	Cursor wait showWhile: [		oc := self displayedObjects asOrderedCollection.		self outline odbDeepRefresh.		self updateLocks.		(self canExpand: (oc at: (oc indexOf: anEntry)) fully: true)			ifTrue:[self updateDisplayUsing: (self expandIndex: (oc indexOf: anEntry) in: oc fully: true)]			ifFalse: [self updateLocks.					Dialog warn: 'Unable to expand because someone is modifying the outline structure.']].</body></methods><methods><class-id>VWHelp.AHSOutlineViewerModel class</class-id> <category>configuration constants</category><body package="Arbor Help System Outline Help Core">outlineViewClass	"Answer the class to be used by the model when displaying the outline view."	^ ArborHierarchicalSequenceView</body></methods><methods><class-id>VWHelp.AHSOutlineViewerModel class</class-id> <category>help info (AHS)</category><body package="Arbor Help System Outline Help Core">ahsHelpData	^(AHSHelpClassData languages: #(#English) widgetData: ((AHSPersistentDictionary new)	 add: (#list -&gt; ((AHSPersistentDictionary new)	 add: (#disabled -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'This is disabled because linking to an outline is not appropriate for this widget, or no state or key is currently selected' runs: (RunArray runs: #(123) values: #(nil))); yourself) outlineLinks: #(nil)));	 add: (#empty -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Specify an Outline Name above and the outline''s topics will be displayed here.' runs: (RunArray runs: #(78) values: #(nil))); yourself) outlineLinks: #(nil)));	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Select the desired topic to link to. Use the triangles to the left of topics to expand or contract topics as necessary.' runs: (RunArray runs: #(119) values: #(nil))); yourself) outlineLinks: #(nil))); yourself)); yourself))</body></methods><methods><class-id>VWHelp.AHSHTMLGenerator</class-id> <category>helpfile generation - private</category><body package="Arbor Help System Outline Help Core">fileStreamFor: aHelpOutlineEntry	"Private - Answer a file stream for aHelpOutlineEntry.  The name of the file is based	 on the uniqueID of the entry."	^ (self htmlDirectory construct: (self helpHTMLFilename: aHelpOutlineEntry data uniqueID)) writeStream</body><body package="Arbor Help System Outline Help Core">generateHelpTextFor: aHelpOutlineEntry on: aStream using: aTopicIndex	"Generate the help text for the specified outline item.  Write the text to aStream."	self 		generateHeaderOn: aStream		title: aHelpOutlineEntry topic.	self 		generateNavigateLineFor: aHelpOutlineEntry 		on: aStream		using: aTopicIndex.	self generateNavigateLineDividerOn: aStream.	aStream		nextPutAll: (self 						headerFor: aHelpOutlineEntry topic 						level: self topicHeaderLevel); cr;		nextPutAll: (self topicTextFor: aHelpOutlineEntry); cr.	self generateNavigateLineDividerOn: aStream.	self 		generateNavigateLineFor: aHelpOutlineEntry		on: aStream 		using: aTopicIndex.	self generateFooterOn: aStream.</body><body package="Arbor Help System Outline Help Core">generateNavigateLineDividerOn: aStream	aStream nextPutAll: '&lt;hr&gt;'; cr.</body><body package="Arbor Help System Outline Help Core">generateNavigateLineFor: aHelpOutlineEntry on: aStream using: aTopicIndex	"Private - Generate the line which lets a user jump to Contents, Previous or Next.	 Use the topic index to determine if there is a next or previous and adjust the output	 accordingly."	| previous next contents |	previous := aTopicIndex previousNode: aHelpOutlineEntry.	next := aTopicIndex nextNode: aHelpOutlineEntry.	contents := self 					link: 'Contents'					to: self topicHTMLFilename.	aStream		nextPutAll: '&lt;pre&gt;&lt;center&gt;&lt;b&gt;';		nextPutAll: (self navigateDefFor: previous label: 'Previous');		nextPutAll: '    ';		nextPutAll: contents;		nextPutAll: '    ';		nextPutAll: (self navigateDefFor: next label: 'Next');		nextPutAll: '&lt;/b&gt;&lt;/center&gt;&lt;/pre&gt;'.</body><body package="Arbor Help System Outline Help Core">helpHTMLFilename: anInteger	"Private - Answer the name of the HTML file to use to store the help topic contents found	 in the node identified by anInteger."	^ self htmlFilenameFor: anInteger printString.</body><body package="Arbor Help System Outline Help Core">htmlFilenameFor: aString	"Private - Answer the filename for storing HTML data.  aString is the root of the file name."	^ aString , self fileExtension</body><body package="Arbor Help System Outline Help Core">processText: aText	"Answer a string which consists of the help text with hypertext and glossary	 links converted into HTML"		| result |	result := WriteStream on: ''.	topicWriter		writeBody: aText		on: result.	^ result contents</body><body package="Arbor Help System Outline Help Core">topicHeaderLevel	"Return the header level for topics contained in the help text HTML file.  Currently this is 	 hardcoded at 2. Ultimately it could be configured by the user."	^ 2</body><body package="Arbor Help System Outline Help Core">topicTextFor: aHelpOutlineEntry	"Private - Answer the string containing the processed topic text.  The string contains appropriate	 HTML substituted for any glossary or hypertext links found in the help topic text."	^ aHelpOutlineEntry text isEmpty 		ifTrue: [''] 		ifFalse: [(self paragraphFrom: (self processText: aHelpOutlineEntry text))]</body><body package="Arbor Help System Outline Help Core">topicTitle: aTree	"Private - Answer the string to be generated for the topic associated with aTree."	^ aTree data topic</body></methods><methods><class-id>VWHelp.AHSHTMLGenerator</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">defaultHTMLDirectory	"Private - Answer a string which represents the default directory where the HTML files for the	 current outline should be stored."	^ self fullOutlineName: outline name</body><body package="Arbor Help System Outline Help Core">embedGraphic: aHyperLink	"Private - Answer an HTML specification for embedding a graphic in the text."	| output |	output := WriteStream on: ''.	^output		nextPutAll: '&lt;img src=''';		nextPutAll: (self exportGraphicFrom: aHyperLink);		nextPutAll: '''&gt;';		contents</body><body package="Arbor Help System Outline Help Core">exportGraphicFrom: aHyperLink	"Private - File out the graphic identified by aHyperLink.  Answer the name of the file to which the graphic was exported.  If the user has installed the appropriate graphics conversion software, the graphic will automatically be written to the file, otherwise a dummy file will be created and the user will have to manually convert the graphic."	| graphicName name |	graphicName := aHyperLink linkObject.	name := (self haveWrittenGraphic: graphicName)				ifTrue: [self mappedGraphicNameFor: graphicName]				ifFalse: [self writeGraphicNamed: graphicName].	^(aHyperLink isEmbedded or: [aHyperLink hasCaption not])		ifTrue: [name]		ifFalse: [			"Create new page with the graphic and caption text combined."			Dialog warn: 'Generating HTML for non-embedded graphics that\contain captions is not currently supported.\\Graphic name: ' withCRs, graphicName.			name]</body><body package="Arbor Help System Outline Help Core">externalAnchorFor: aHyperLink	"Private - Answer the href portion of an HTML anchor specification for a link residing in	 an external outline.  The reference will include the name of the external outline in addition	 to the id of the topic.  The relative location of the external HTML files will mimic the relative	 location of the external outline file to the current outline file." 	| topicDir |	topicDir := self externalOutlineDirectory: aHyperLink.	^ topicDir constructString: aHyperLink topicName printString</body><body package="Arbor Help System Outline Help Core">externalOutlineDirectory: aHyperLink 	"Private - Answer the external outline directory referenced by aHyperLiink.	 NOTE: This method is temporary.  It doesn't work properly because of the way it handles	 relative path names.  It might generate usable HTML for PC's and Unix system, but the link	 will behave funny on a PC and won't be correct at all on a Macintosh."		| dir |	^ (dir := self outlineDirectory: aHyperLink outlineName) isRelative		ifTrue: [('..' , (String with: dir separator) , dir asString) asFilename]  "TEMPORARY"		ifFalse: [dir]</body><body package="Arbor Help System Outline Help Core">fileExtension	"Private - Answer the extension used to identify HTML files.  Currently hardwired to '.htm'."	^ '.htm'.</body><body package="Arbor Help System Outline Help Core">fullOutlineName	"Private - Answer the name of the outline, exclusive of any extension but including any path."	^ self fullOutlineName: outline name</body><body package="Arbor Help System Outline Help Core">fullOutlineName: aString	"Private - Answer the name of the outline, exclusive of any extension but including any path.	 The name of the outline is specified in aString."	^ (Filename splitExtension: aString) at: 1.</body><body package="Arbor Help System Outline Help Core">getDirectoryNameFromUser	"Private - Answer a directory filestream, nil, or #repeat based on information retrieved from the user.  A nil	 value means the user cancelled the operation.  A #repeat means that the user wants to enter another name."	| dir |	(dir := self outlineDirectory) isNil ifTrue: [^ dir]. 	dir exists		ifTrue:			[dir isDirectory				ifTrue: [dir := self promptForReuse: dir]				ifFalse: 					[Dialog warn: 'Unable to create or use directory "' ,  dir asString , '".' , (String with: Character cr) ,									'A file of that name already exists.'.					dir := #repeat]]		ifFalse: [dir makeDirectory].	^ dir</body><body package="Arbor Help System Outline Help Core">getHTMLDirectory	"Private - Answer a filestream, or nil, which represents the location where HTML files corresponding to the	outline should be saved."	| dir |	dir := #repeat.	[dir == #repeat] whileTrue: [(dir := self getDirectoryNameFromUser) isNil ifTrue: [^ dir]].	^ dir.</body><body package="Arbor Help System Outline Help Core">glossaryLinkFor: aHyperLink	"Private - Answer an HTML specification for a link to the glossary."	^ self glossaryFilename , '#' , aHyperLink linkObject asString</body><body package="Arbor Help System Outline Help Core">graphicWriter	"Private - Answer the tool used to write graphics to the system.  Answer either the writer class or nil if that class is unavailable."	^#{ArborGIFReaderWriter} valueOrDo: [nil]</body><body package="Arbor Help System Outline Help Core">htmlDirectory	"Private - Answer the Filename object representing the directory into which the HTML files are stored."	htmlDirectory isNil ifTrue: [htmlDirectory := self getHTMLDirectory].	^ htmlDirectory</body><body package="Arbor Help System Outline Help Core">hypertextLinkFor: aHyperLink	"Private - Answer an HTML specification for a link to another topic."	| anchor |	anchor := aHyperLink outlineName notNil					ifTrue: [self externalAnchorFor: aHyperLink]					ifFalse: [aHyperLink topicName printString].	^ self htmlFilenameFor: anchor</body><body package="Arbor Help System Outline Help Core">indent: anInteger	"Private - Answer a string used to indent anInteger amount."	^ ((String new: anInteger * 4) atAllPut: Character space)</body><body package="Arbor Help System Outline Help Core">indent: aString amount: anInteger on: aStream	"Private - Output aString to aStream indented by anInteger."	| indentation cr |	indentation := self indent: anInteger.	cr := String with: Character cr.	aStream		nextPutAll: indentation;		nextPutAll: (aString						copyReplaceAll: cr						with: cr, indentation).</body><body package="Arbor Help System Outline Help Core">linkToGraphic: aHyperLink	"Private - Answer an HTML specification for a link to a graphic.  Currently only support linking to an external graphic (as opposed to one embedded in the text)."	| output |	output := WriteStream on: ''.	^output		nextPutAll: '&lt;a href=''';		nextPutAll: (self exportGraphicFrom: aHyperLink);		nextPutAll: '''&gt;';		contents</body><body package="Arbor Help System Outline Help Core">navigateDefFor: aTopicID label: aString	"Private - Answer an HTML definition for navigating from aTopicID."	^ aTopicID isNil		ifTrue: [aString]		ifFalse: [self					link: aString					to: (self helpHTMLFilename: aTopicID)].</body><body package="Arbor Help System Outline Help Core">outlineDirectory	"Private - Answer a Filestream which represents the directory where the current outline	 is stored.  Prompt the user to enter the name of the directory, using aString as a default."	| result |	result := (Dialog				requestFileName: 'Enter directory where HTML files should be stored:'				default: (self defaultHTMLDirectory)) trimExteriorBlanks.	^ result isEmpty		ifTrue: [nil]		ifFalse: [result asFilename].</body><body package="Arbor Help System Outline Help Core">outlineDirectory: aString	"Private - Answer a Filename which represents the directory where the current outline	 is stored."	^ (self fullOutlineName: aString) asFilename</body><body package="Arbor Help System Outline Help Core">outlineName	"Private - Answer the name of the outline, exclusive of any extension or path."	^ (Filename splitPath: (self fullOutlineName)) at: 2.</body><body package="Arbor Help System Outline Help Core">promptForReuse: aFilename	"Private - Answer a directory filename, nil, or #repeat based on information retrieved from the user.  A nil	 value means the user cancelled the operation.  A #repeat means that the user wants to enter another name."	^ (Dialog confirm: '"' , aFilename asString , '" already exists.  Do you wish to update thecontents of this directory?  (Old contents will be removed.)')		ifTrue: [| fn |			fn := aFilename asFilename construct: 'graphics'.			(fn exists and: [fn isDirectory]) ifTrue: [				fn directoryContents do: [:name || file |					file := fn construct: name.					file isWritable ifTrue: [file delete]].				fn isWritable ifTrue: [fn delete]].			(fn := aFilename asFilename) isDirectory ifTrue: [				fn directoryContents do: [:name || file |					(('*', self fileExtension match: name) and: [name first isDigit or: [name = self topicHTMLFilename]]) 						ifTrue: [							file := fn construct: name.							file isWritable ifTrue: [file delete]]]].			aFilename]		ifFalse: [#repeat]</body><body package="Arbor Help System Outline Help Core">topicsDo: aBlock	"Private - Evaluate aBlock for every topic node found in the outline tree."	outline do: [: tree | tree do: [: helpTopic | aBlock value: helpTopic]]</body><body package="Arbor Help System Outline Help Core">writeDummyGraphicFor: aSymbol to: aFilename	"comment"	| stream |	stream := aFilename writeStream.	[stream		nextPutAll: 'Placeholder for graphic: ';		nextPutAll: aSymbol;		cr] ensure: [stream close].</body><body package="Arbor Help System Outline Help Core">writeGraphic: aSymbol to: aFilename	"Output the graphic as a GIF if we have the GIFReadWriter installed.  Otherwise, generate a	 placeholder file."	| writer |	(writer := self graphicWriter) isNil		ifTrue: [self 					writeDummyGraphicFor: aSymbol					to: aFilename]		ifFalse: [writer					putImage: (self graphicAt: aSymbol)					onFileNamed: aFilename]</body><body package="Arbor Help System Outline Help Core">writeGraphicNamed: aSymbol	"Private - Write the graphic identified by aSymbol.  Answer the name of the file where the graphic was stored."	| directoryName fileName fn |	directoryName := 'graphics'.	fileName := self mappedGraphicNameFor: aSymbol.	fn := self htmlDirectory asFilename construct: directoryName.	fn exists not ifTrue: [fn makeDirectory].	self		writeGraphic: aSymbol		to: 	(fn construct: fileName).	^ directoryName, '/', fileName</body></methods><methods><class-id>VWHelp.AHSHTMLGenerator</class-id> <category>html generation</category><body package="Arbor Help System Outline Help Core">adjustFontSizeFor: aString by: anInteger	"Private - Answer a generated header specification which wraps aString.  The header level is given by anInteger."	| stream sign |	anInteger = 0 ifTrue: [^ aString].	stream := WriteStream on: ''.	sign := anInteger &gt; 0				ifTrue: ['+']				ifFalse: [''].	^ stream		nextPutAll: (self startTag: ('font size=' , sign , anInteger printString));		nextPutAll: aString;		nextPutAll: (self endTag: 'font');		contents</body><body package="Arbor Help System Outline Help Core">anchor: aString named: anchorName	"Private - Answer aString as preceeded by an anchor link.  Name the link if	 anchorName is not nil."	| name |	name := anchorName notNil				ifTrue: [' name="' , anchorName , '"']				ifFalse: [''].	^ '&lt;a' , name , '&gt;' , aString , '&lt;/a&gt;'</body><body package="Arbor Help System Outline Help Core">definition: aString	"Private - Answer a glossary definition formatted as a definition list &lt;dd&gt; tag."	^ '&lt;dd&gt;' , aString</body><body package="Arbor Help System Outline Help Core">definitionTerm: aString	"Private - Answer a glossary entry key formatted as a definition term &lt;dt&gt; tag."	^ '&lt;dt&gt;' , aString</body><body package="Arbor Help System Outline Help Core">endTag: aString 	"Private - Answer an 'end tag' version of aString."	^ '&lt;/' , aString , '&gt;'</body><body package="Arbor Help System Outline Help Core">generateDefinitionListFor: anAssociationCollection on: aStream 	"Private - Produce a definition list derived from the contents of anAssociationCollection.  The	 key in the association is the definintion term, the value is the definition itself."	aStream nextPutAll: '&lt;dl&gt;'; cr.	anAssociationCollection do:		[:assoc |		aStream			nextPutAll: (self glossaryKey: assoc key asString); cr; 			nextPutAll: (self glossaryDefinition: assoc value); cr		].	aStream nextPutAll: '&lt;/dl&gt;'; cr.</body><body package="Arbor Help System Outline Help Core">generateEndTag: aString for: nestDepth on: aStream	"Private - Generate a sufficient number of end tags to close out any open tags.  The	 number of tags needed is indicated by how deeply we are nested."	self 		generateEndTag:  '&lt;/' , aString , '&gt;'		for: nestDepth		until: -1		on: aStream.</body><body package="Arbor Help System Outline Help Core">generateEndTag: aString for: nestDepth until: endDepth on: aStream	"Private - Generate a sufficient number of end tags to close out any open tags.  The	 number of tags needed is indicated by how deeply we are nested."	| depth |	nestDepth &lt; 0 ifTrue: [^ self].	depth := nestDepth.	(depth - 1) to: endDepth by: -1 do: 		[:int |		self			indent: aString			amount: depth			on: aStream.		aStream cr.		depth := depth - 1]</body><body package="Arbor Help System Outline Help Core">generateFooterOn: aStream	"Generate an appropriate HTML footer on the given stream."	aStream		nextPutAll: '&lt;/body&gt;'; cr;		nextPutAll: '&lt;/html&gt;'; cr</body><body package="Arbor Help System Outline Help Core">generateHeaderOn: aStream title: titleString	"Generate an appropriate HTML Header on the given stream."	aStream		nextPutAll: '&lt;html&gt;'; cr; cr;		nextPutAll: '&lt;!--'; cr;		nextPutAll: 'Generated by the Arbor Help System version ';		nextPutAll: AHSUtils version;		nextPutAll: ' on ';		print: Date today;		nextPutAll: ' at ';		print: Time now;		nextPut: $.; cr;		nextPutAll: 'Source outline name: ', outline outlineLabel; cr;		nextPutAll: 'Source filename: ', outline name; cr;		nextPutAll: 'Visit http://www.aisys.com for more info on the Arbor Help system.'; cr;		nextPutAll: '--&gt;'; cr; cr;		nextPutAll: '&lt;head&gt;'; cr;		nextPutAll: '&lt;title&gt;', outline outlineLabel, ' - ', (topicWriter exportableStringFrom: titleString) , '&lt;/title&gt;'; cr;		nextPutAll: '&lt;/head&gt;'; cr;		nextPutAll: '&lt;body&gt;'; cr.</body><body package="Arbor Help System Outline Help Core">generateNestTag: aString oldDepth: depth newDepth: newDepth on: aStream	"Private - Generate either a start tag or an end tag for a nestable item.  Answer the	 new depth."	depth = newDepth ifTrue: [^ newDepth].	depth &lt; newDepth 		ifTrue: 			[self				indent: (self startTag: aString)				amount: newDepth				on: aStream]		ifFalse: 			[self				generateEndTag: (self endTag: aString)				for: depth				until: newDepth				on: aStream].	^ newDepth</body><body package="Arbor Help System Outline Help Core">generateUnorderedListFor: aCollection on: aStream	"Private - Generate an unordered list specification for the contents of aCollection."	aStream		nextPutAll: (self startTag: self unorderedList);		cr.	aCollection do:		[:each | 		aStream			nextPutAll: (self listItem: each);			cr].	self 		generateEndTag: self unorderedList		for: 0		on: aStream.</body><body package="Arbor Help System Outline Help Core">glossaryDefinition: aString	"Private - Answer the glossary definition found in aString as an HTML definition list definition	 item."	^  self definition: (self paragraphFrom: aString)</body><body package="Arbor Help System Outline Help Core">glossaryKey: aString	"Private - Answer aString formatted for HTML output.  We output glossary keys as	 an anchor entry and formatted with a 'strong' font."	^ self definitionTerm: (self								anchor: (self strong: aString)								named: aString)</body><body package="Arbor Help System Outline Help Core">headerFor: aString level: anInteger	"Private - Answer a generated header specification which wraps aString.  The header level is given by anInteger."	| levelString stream |	stream := WriteStream on: ''.	levelString := 'h' , anInteger printString.	^ stream		nextPutAll: (self startTag: levelString);		nextPutAll: (topicWriter exportableStringFrom: aString);		nextPutAll: (self endTag: levelString);		contents</body><body package="Arbor Help System Outline Help Core">link: aString to: anchorName	"Private - Answer aString containing HTML tags to link aString to anchorName."	^ '&lt;a href="' , anchorName , '"&gt;' , (topicWriter exportableStringFrom: aString) , '&lt;/a&gt;'</body><body package="Arbor Help System Outline Help Core">listItem: aString	"Private - Answer aString as a 'list item' HTML string."	^ '&lt;li&gt;' , aString asString</body><body package="Arbor Help System Outline Help Core">paragraphFrom: aCharArray	"Answer a string containing the paragraph definition for aCharArray.  aCharArray is processed	 and line breaks are added wherever a 'cr' is found in the string."	| lines result |	lines := aCharArray asArrayOfLines.	lines isEmpty ifTrue: [^ ''].	result := WriteStream on: ''.	result nextPutAll: '&lt;p&gt;'.	1 to: lines size do: [:i || line |		line := lines at: i.		result nextPutAll: line asString.		i = lines size			ifTrue: [result nextPutAll: '&lt;/p&gt;']			ifFalse: [				"Don't emit the break if there's a blockquote on either side of it - a break is implied."				(('&lt;/blockquote&gt;*' match: (lines at: i + 1))					or: [('&lt;blockquote&gt;*' match: (lines at: i + 1))					or: [('*blockquote&gt;' match: line)]]) not						ifTrue: [result nextPutAll: '&lt;br&gt;']].		result cr].	^result contents.</body><body package="Arbor Help System Outline Help Core">startTag: aString 	"Private - Answer a 'start tag' version of aString."	^ '&lt;' , aString , '&gt;'</body><body package="Arbor Help System Outline Help Core">strong: aString	"Private - Answer aString as a 'strong' HTML string."	^ '&lt;strong&gt;' , aString asString , '&lt;/strong&gt;'.</body><body package="Arbor Help System Outline Help Core">unorderedList 	"Answer the HTML used for unordered lists."	^ 'ul'</body></methods><methods><class-id>VWHelp.AHSHTMLGenerator</class-id> <category>testing</category><body package="Arbor Help System Outline Help Core">haveWrittenGraphic: aSymbol	"Private - Answer true if we have already written the graphic identified by aSymbol."	^ self graphicFileNames includes: aSymbol</body><body package="Arbor Help System Outline Help Core">shouldImbed: aGraphicLinkObject	"Answer true if the graphic specified by the link is able to be imbedded in the text."	^self graphicWriter notNil and: [aGraphicLinkObject isEmbedded]</body></methods><methods><class-id>VWHelp.AHSHTMLGenerator</class-id> <category>accessing - private</category><body package="Arbor Help System Outline Help Core">graphicFileNames	"Private - Answer the dictionary of filenames used to store graphics objects."	graphicFileNames isNil ifTrue: [graphicFileNames := Dictionary new].	^ graphicFileNames.</body></methods><methods><class-id>VWHelp.AHSHTMLGenerator</class-id> <category>glossary generation</category><body package="Arbor Help System Outline Help Core">generateGlossaryIn: aDirectory	"Generate the HTML page containing the glossary definitions."	| stream |	outline hasGlossaryEntries ifFalse: [^ self].	stream := (aDirectory construct: self glossaryFilename) writeStream.	[self generateGlossaryOn: stream] ensure: [stream close]</body><body package="Arbor Help System Outline Help Core">generateGlossaryOn: aStream	"Produce an HTML file containing glossary information contained in the outline."	Cursor write showWhile:		[self 			generateHeaderOn: aStream			title: 'Glossary'.		self 			generateDefinitionListFor: outline sortedGlossary			on: aStream.		self generateFooterOn: aStream]</body></methods><methods><class-id>VWHelp.AHSHTMLGenerator</class-id> <category>graphic generation - private</category><body package="Arbor Help System Outline Help Core">graphicAt: aSymbol	"Private - Answer the graphic object identified by aSymbol."	^ outline graphicAt: aSymbol</body><body package="Arbor Help System Outline Help Core">graphicFilenameFor: graphicKey	"Convert graphicKey into a filename.  Restrict the characters in the filename, and guarantee a unique filename of length 12 (8.3) or less."	| filename count baseFilename extension lastWasSpace |	lastWasSpace := true.	baseFilename := (graphicKey asString collect: [:ch || was |						was := lastWasSpace.						lastWasSpace := ch isSeparator.						was ifTrue: [ch asUppercase] ifFalse: [ch]])							select: [:c | c isAlphaNumeric or: ['-_+(){}[]~' includes: c]].	extension := self graphicWriter isNil ifTrue: [''] ifFalse: ['.gif'].	filename := baseFilename, extension.	count := 1.	[self graphicFileNames values includes: filename] whileTrue: [		count := count + 1.		filename := baseFilename, count printString, extension].	^filename</body><body package="Arbor Help System Outline Help Core">mappedGraphicNameFor: aGraphicName	| files |	files := self graphicFileNames.	^ files		at: aGraphicName		ifAbsent: [			files				at: aGraphicName				put: (self graphicFilenameFor: aGraphicName)]</body></methods><methods><class-id>VWHelp.AHSHTMLGenerator</class-id> <category>topic generation - private</category><body package="Arbor Help System Outline Help Core">generateGlossaryRefOn: aStream	"Private - If a glossary exists, generate a reference to it on the table of contents page."	outline hasGlossaryEntries ifFalse: [^ self].	self 		generateUnorderedListFor: (Array with: (self 														link: 'Glossary' 														to: self glossaryFilename))		on: aStream.</body><body package="Arbor Help System Outline Help Core">generateHeaderCaption: aString on: aStream	"Private - Start the HTML document and generate a level 2 header with the text contained in aString."	self 		generateHeaderOn: aStream 		title: aString.	aStream		nextPutAll: (self 						headerFor: aString						level: 1); cr.</body><body package="Arbor Help System Outline Help Core">generateTopicTreeOn: aStream	"Private - Generate the topic tree on aStream.  Answer the topic index for the topic tree."	| depth topicIndex  |	depth := -1.	topicIndex := AHSOutlineTopicIndex new.	self topicsDo:		[: aTopic |		topicIndex addItem: aTopic.		depth := self					generateNestTag: self unorderedList					oldDepth: depth					newDepth: aTopic depth					on: aStream.		aStream cr.		self			indent: (self listItem: (self topicTitleFor: aTopic))			amount: aTopic depth			on: aStream.		aStream cr].	self 		generateEndTag: self unorderedList 		for: depth		on: aStream.	^ topicIndex</body><body package="Arbor Help System Outline Help Core">topicHTMLFilename	"Private - Answer the name of the HTML file to use to store the topic contents"	^ self htmlFilenameFor: self outlineName</body><body package="Arbor Help System Outline Help Core">topicTitleFor: aTree	"Private - Answer the string to be generated for the topic associated with aTree."	^ self 		link: aTree data topic		to: (aTree data uniqueID printString , self fileExtension)</body></methods><methods><class-id>VWHelp.AHSHTMLGenerator</class-id> <category>initialize-release</category><body package="Arbor Help System Outline Help Core">initialize	topicWriter := AHSHTMLTopicBodyWriter forOwner: self.</body><body package="Arbor Help System Outline Help Core">setOutline: anOutline 	"Set the instance variables."	self initialize.	outline := anOutline.</body></methods><methods><class-id>VWHelp.AHSHTMLGenerator</class-id> <category>glossary generation - private</category><body package="Arbor Help System Outline Help Core">glossaryFilename	"Private - Answer the name of the HTML file to use to store the glossary contents"	^ self htmlFilenameFor: 'glossary'</body></methods><methods><class-id>VWHelp.AHSHTMLGenerator</class-id> <category>writing</category><body package="Arbor Help System Outline Help Core">generateHTML	"Generate HTML for the outline.  The output will be placed in a subdirectory which	 has the same name as the outline.  Separate files will be generated for the topic	 hierarchy, glossary, and individual help topic entries."	| topicIndex dir |	htmlDirectory := nil.	(dir := self htmlDirectory) isNil ifTrue: [^ self].	Cursor wait showWhile: 		[topicIndex := self generateTopicsIn: dir.		self 			generateGlossaryIn: dir;			generateHelpFilesUsing: topicIndex].</body></methods><methods><class-id>VWHelp.AHSHTMLGenerator</class-id> <category>topic generation</category><body package="Arbor Help System Outline Help Core">generateTopicsIn: aDirectory	"Generate the HTML page containing the topic structure.  Answer the topic index for the topic tree."	| stream result |	stream := (aDirectory construct: self topicHTMLFilename) writeStream.	[result := self generateTopicsOn: stream] ensure: [stream close].	^ result</body><body package="Arbor Help System Outline Help Core">generateTopicsOn: aStream	"Generate an HTML specification corresponding to the help topic structure.  Answer	 an outline topic index for the generated tree."	| topicIndex |	Cursor write showWhile: 		[self 			generateHeaderCaption: 'Table of Contents'			on: aStream.		topicIndex := self generateTopicTreeOn: aStream.		self generateGlossaryRefOn: aStream.		self generateFooterOn: aStream].	^ topicIndex.</body></methods><methods><class-id>VWHelp.AHSHTMLGenerator</class-id> <category>helpfile generation</category><body package="Arbor Help System Outline Help Core">generateHelpFilesUsing: aTopicIndex	"Generate help files for each help topic in the outline.  Generate proper links for imbedded	 hypertext links."	| stream |	Cursor write showWhile: [self topicsDo:		[: helpTopic |		stream := self fileStreamFor: helpTopic.		[self 			generateHelpTextFor: helpTopic data			on: stream			using: aTopicIndex] ensure: [stream close]]].</body></methods><methods><class-id>VWHelp.AHSHTMLGenerator class</class-id> <category>instance creation</category><body package="Arbor Help System Outline Help Core">outline: anOutline 	"Answer a new instance of the receiver capable of generating HTML output for anOutline."	^ self basicNew		setOutline: anOutline</body></methods><methods><class-id>VWHelp.AHSHTMLHelpGenerator</class-id> <category>topic generation - private</category><body package="Arbor Help System Outline Help Core">generateGlossaryRefOn: aStream	"Not needed for HTMLHelp."	^self</body><body package="Arbor Help System Outline Help Core">topicTitleFor: aTree	"Private - Answer the string to be generated for the topic associated with aTree.  This string is actually an entry in the HTMLHelp contents file."	| str break |	str := String new writeStream.	break := (String with: Character cr), '  '.	str		nextPutAll: '&lt;object type="text/sitemap"&gt;'; nextPutAll: break;		nextPutAll: '&lt;param name="Name" value="';			nextPutAll: (topicWriter exportableStringFrom: aTree data topic);			nextPutAll: '"&gt;'; nextPutAll: break;		nextPutAll: '&lt;param name="Type" value="Reference"&gt;'; nextPutAll: break;		nextPutAll: '&lt;param name="Local" value="';			nextPutAll: aTree data uniqueID printString, self fileExtension;			nextPutAll: '"&gt;'; nextPutAll: break;		nextPutAll: '&lt;/object&gt;'.	^str contents</body></methods><methods><class-id>VWHelp.AHSHTMLHelpGenerator</class-id> <category>writing</category><body package="Arbor Help System Outline Help Core">generateHTML	"Generate the HTML, then generate the HTMLHelp project file.  The HTMLHelp contents file is generated during #generateHTML."	super generateHTML.	htmlDirectory isNil ifTrue: [^self].	self generateHTMLHelpProject.</body><body package="Arbor Help System Outline Help Core">generateHTMLHelpProject	"Generate the project file used by HTMLHelp Workshop from Microsoft (a free product)."	| projectFile |	projectFile := (self htmlDirectory construct: self projectFilename) writeStream.	projectFile		nextPutAll: '[OPTIONS]'; cr;		nextPutAll: 'Compatibility=1.1'; cr;		nextPutAll: 'Compiled file=', self compiledFilename; cr;		nextPutAll: 'Contents file=', self contentsFilename; cr;		nextPutAll: 'Default topic=', (self helpHTMLFilename: outline forest first data uniqueID); cr;		nextPutAll: 'Display compile progress=Yes'; cr;		nextPutAll: 'Full-text search=Yes'; cr;		nextPutAll: 'Language=0x409 English (United States)'; cr;		cr;		nextPutAll: '[FILES]'; cr.	self topicsDo: [:helpTopic |		projectFile nextPutAll: (self helpHTMLFilename: helpTopic data uniqueID); cr].	self graphicFileNames do: [:name |		projectFile nextPutAll: 'graphics/', name; cr].	projectFile close.</body></methods><methods><class-id>VWHelp.AHSHTMLHelpGenerator</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">compiledFilename	^self outlineName, '.chm'</body><body package="Arbor Help System Outline Help Core">contentsFilename	^self outlineName, '.hhc'</body><body package="Arbor Help System Outline Help Core">projectFilename	^self outlineName, '.hhp'</body></methods><methods><class-id>VWHelp.AHSHTMLHelpGenerator</class-id> <category>helpfile generation - private</category><body package="Arbor Help System Outline Help Core">generateNavigateLineDividerOn: aStream	"Don't generate navigation for HTMLHelp."	^self</body><body package="Arbor Help System Outline Help Core">generateNavigateLineFor: aHelpOutlineEntry on: aStream using: aTopicIndex	"Don't generate navigation for HTMLHelp."	^self</body></methods><methods><class-id>VWHelp.AHSHTMLHelpGenerator</class-id> <category>topic generation</category><body package="Arbor Help System Outline Help Core">generateTopicsIn: aDirectory	"Generate the topic info onto the help contents stream, creating a contents file for the project.  Return the topic index."	| contents |	contents := (aDirectory construct: self contentsFilename) writeStream.	contents nextPutAll: '&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN"&gt;'; cr.	^[self generateTopicsOn: contents] ensure: [contents close]</body></methods><methods><class-id>VWHelp.AHSHelpTextEditorView</class-id> <category>model accessing</category><body package="Arbor Help System Outline Help Core">editString: aString 	"The paragraph to be displayed is created from the characters in aString."	self editText: aString</body><body package="Arbor Help System Outline Help Core">editText: aTextOrString	"Set the text of the receiver to be a non-nil text value."	super editText: (self nonNilText: aTextOrString).</body><body package="Arbor Help System Outline Help Core">getContents	"Answer the contents to be displayed by the receiver."	^ self nonNilText: model value.</body><body package="Arbor Help System Outline Help Core">newText: aText	"Set aText to be the text model for the receiver.  If aText is nil, it's value will be substituted	  with a text object compatible with the receiver."	self editText: aText.</body></methods><methods><class-id>VWHelp.AHSHelpTextEditorView</class-id> <category>conversion</category><body package="Arbor Help System Outline Help Core">compatibleTextFrom: aTextOrString   "Private - Answer a form of aTextOrString which is guaranteed to be compatible with the receiver."	^ aTextOrString asAHSHyperText.</body><body package="Arbor Help System Outline Help Core">nonNilText: aTextOrString   "Private - Answer a non-nil instance of aTextOrString.  If aTextOrString is non-nil, answer aText, 	otherwise answer a new instance of a text object compatible with the receiver."	^ aTextOrString == nil			ifTrue: [self compatibleTextFrom: '']			ifFalse: [self compatibleTextFrom: aTextOrString].</body></methods><methods><class-id>VWHelp.AHSHelpTextEditorView</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">backgroundColor	"Answer the receiver's background color."	^ColorValue white</body><body package="Arbor Help System Outline Help Core">displayInsertionPointFor: aCharacterBlock on: aGraphicsContext 	"Display the insertion point on aGraphicsContext for aCharacterBlock."	((self controller respondsTo: #readOnly) not or: [self controller readOnly not])		ifTrue: [super displayInsertionPointFor: aCharacterBlock on: aGraphicsContext].</body></methods><methods><class-id>VWHelp.AHSHelpTextEditorView</class-id> <category>controller access</category><body package="Arbor Help System Outline Help Core">defaultControllerClass	"Answer the default controller class for the receiver."	^AHSHelpTextEditorController</body></methods><methods><class-id>VWHelp.AHSHelpTextEditorView</class-id> <category>initialize-release</category><body package="Arbor Help System Outline Help Core">initialDisplayContents	"Answer a text compatible with the receiver."	^AHSIndentableComposedText new text: (self nonNilText: nil).</body></methods><methods><class-id>VWHelp.ArborIconSet</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">contractedDeselected	^contractedDeselected isNil		ifTrue: [self contractedSelected]		ifFalse: [contractedDeselected]</body><body package="Arbor Help System Outline Help Core">contractedDeselected: anObject	contractedDeselected := anObject</body><body package="Arbor Help System Outline Help Core">contractedSelected	^contractedSelected</body><body package="Arbor Help System Outline Help Core">contractedSelected: anObject	contractedSelected := anObject</body><body package="Arbor Help System Outline Help Core">contractedTransitionDeselected	^contractedTransitionDeselected isNil		ifTrue: [self contractedTransitionSelected]		ifFalse: [contractedTransitionDeselected]</body><body package="Arbor Help System Outline Help Core">contractedTransitionDeselected: anObject	contractedTransitionDeselected := anObject</body><body package="Arbor Help System Outline Help Core">contractedTransitionSelected	^contractedTransitionSelected isNil		ifTrue: [self contractedSelected]		ifFalse: [contractedTransitionSelected]</body><body package="Arbor Help System Outline Help Core">contractedTransitionSelected: anObject	contractedTransitionSelected := anObject</body><body package="Arbor Help System Outline Help Core">emptyDeselected	^emptyDeselected isNil		ifTrue: [self emptySelected]		ifFalse: [emptyDeselected]</body><body package="Arbor Help System Outline Help Core">emptyDeselected: anObject	emptyDeselected := anObject</body><body package="Arbor Help System Outline Help Core">emptySelected	^emptySelected</body><body package="Arbor Help System Outline Help Core">emptySelected: anObject	emptySelected := anObject</body><body package="Arbor Help System Outline Help Core">expandedDeselected	^expandedDeselected isNil		ifTrue: [self expandedSelected]		ifFalse: [expandedDeselected]</body><body package="Arbor Help System Outline Help Core">expandedDeselected: anObject	expandedDeselected := anObject</body><body package="Arbor Help System Outline Help Core">expandedSelected	^expandedSelected</body><body package="Arbor Help System Outline Help Core">expandedSelected: anObject	expandedSelected := anObject</body><body package="Arbor Help System Outline Help Core">expandedTransitionDeselected	^expandedTransitionDeselected isNil		ifTrue: [self expandedTransitionSelected]		ifFalse: [expandedTransitionDeselected]</body><body package="Arbor Help System Outline Help Core">expandedTransitionDeselected: anObject	expandedTransitionDeselected := anObject</body><body package="Arbor Help System Outline Help Core">expandedTransitionSelected	^expandedTransitionSelected isNil		ifTrue: [self expandedSelected]		ifFalse: [expandedTransitionSelected]</body><body package="Arbor Help System Outline Help Core">expandedTransitionSelected: anObject	expandedTransitionSelected := anObject</body><body package="Arbor Help System Outline Help Core">hotRegion	hotRegion isNil ifTrue: [| extent img |		extent := 0@0.		#(expandedSelected expandedDeselected expandedTransitionSelected expandedTransitionDeselected contractedSelected contractedDeselected contractedTransitionSelected contractedTransitionDeselected emptySelected emptyDeselected) do: [:sel |			img := self perform: sel.			img notNil ifTrue: [extent := extent max: img bounds extent]].		hotRegion := 0@0 extent: extent].	^hotRegion</body><body package="Arbor Help System Outline Help Core">hotRegion: aRectangle	hotRegion := aRectangle.</body><body package="Arbor Help System Outline Help Core">indentOffset	^indentOffset isNil		ifTrue: [self hotRegion width]		ifFalse: [indentOffset]</body><body package="Arbor Help System Outline Help Core">indentOffset: anIntegerOrNil	indentOffset := anIntegerOrNil.</body></methods><methods><class-id>VWHelp.ArborIconSet</class-id> <category>displaying</category><body package="Arbor Help System Outline Help Core">display: anIconSelector on: aGraphicsContext	^self display: anIconSelector on: aGraphicsContext at: 0@0</body><body package="Arbor Help System Outline Help Core">display: anIconSelector on: aGraphicsContext at: aPoint	| icon |	icon := self perform: anIconSelector.	icon notNil ifTrue: [icon displayOn: aGraphicsContext at: aPoint].	^icon</body></methods><methods><class-id>VWHelp.ArborIconSet</class-id> <category>testing</category><body package="Arbor Help System Outline Help Core">isHot: aPoint	"Answer true if aPoint's X value is within the bounds of the hotRegion.  aPoint should be in the local coordinate system."	^aPoint x between: self hotRegion left and: self hotRegion right</body></methods><methods><class-id>VWHelp.ArborIconSet class</class-id> <category>class initialization</category><body package="Arbor Help System Outline Help Core">initialize	self iconSets isNil ifTrue: [self initializeIconSets].</body><body package="Arbor Help System Outline Help Core">initializeBookIconSet	self iconSets		at: #book		put: (self				newExpanded: self openBookIcon				expandedTransition: self halfwayBookIcon				contracted: self closedBookIcon				contractedTransition: self halfwayBookIcon				empty: self pageIcon				hotRegion: nil)</body><body package="Arbor Help System Outline Help Core">initializeDefaultIconSet	self iconSets		at: #default		put: (self				newExpanded: self expandedIcon				expandedTransition: self expandedTransitionIcon				contracted: self contractedIcon				contractedTransition: self contractedTransitionIcon				empty: self emptyIcon				hotRegion: nil)</body><body package="Arbor Help System Outline Help Core">initializeIconSets	IconSets := Dictionary new.	self initializeDefaultIconSet.	self initializeBookIconSet.</body></methods><methods><class-id>VWHelp.ArborIconSet class</class-id> <category>resources</category><body package="Arbor Help System Outline Help Core">closedBookIcon	^OpaqueImage		figure: self closedBookImage		shape: self closedBookMask</body><body package="Arbor Help System Outline Help Core">contractedIcon	^OpaqueImage		figure: (CachedImage on: self contractedImage)		shape: (CachedImage on: self contractedMask)</body><body package="Arbor Help System Outline Help Core">contractedTransitionIcon	^OpaqueImage		figure: (CachedImage on: self contractedTransitionImage)		shape: (CachedImage on: self contractedMask)</body><body package="Arbor Help System Outline Help Core">emptyIcon	^OpaqueImage		figure: self emptyImage		shape: self emptyMask</body><body package="Arbor Help System Outline Help Core">expandedIcon	^OpaqueImage		figure: (CachedImage on: self expandedImage)		shape: (CachedImage on: self expandedMask)</body><body package="Arbor Help System Outline Help Core">expandedTransitionIcon	^OpaqueImage		figure: (CachedImage on: self expandedTransitionImage)		shape: (CachedImage on: self expandedMask)</body><body package="Arbor Help System Outline Help Core">halfwayBookIcon	^OpaqueImage		figure: self halfwayBookImage		shape: self halfwayBookMask</body><body package="Arbor Help System Outline Help Core">openBookIcon	^OpaqueImage		figure: self openBookImage		shape: self openBookMask</body><body package="Arbor Help System Outline Help Core">pageIcon	^OpaqueImage		figure: self pageImage		shape: self pageMask</body></methods><methods><class-id>VWHelp.ArborIconSet class</class-id> <category>instance creation</category><body package="Arbor Help System Outline Help Core">newExpanded: expanded contracted: contracted empty: empty hotRegion: aRectangle	"aRectangle may be nil and will then default to the largest image."	^self		newExpanded: expanded		expandedTransition: nil		contracted: contracted		contractedTransition: nil		empty: empty		hotRegion: aRectangle</body><body package="Arbor Help System Outline Help Core">newExpanded: expanded expandedTransition: expandedTransition contracted: contracted contractedTransition: contractedTransition empty: empty hotRegion: aRectangle	"aRectangle may be nil and will then default to the largest image.  The transition images may be nil, in which case they default to the non-transition image."	^self new		expandedSelected: expanded;		expandedTransitionSelected: expandedTransition;		contractedSelected: contracted;		contractedTransitionSelected: contractedTransition;		emptySelected: empty;		hotRegion: aRectangle</body></methods><methods><class-id>VWHelp.ArborIconSet class</class-id> <category>icon set accessing</category><body package="Arbor Help System Outline Help Core">defaultIconSet	^self iconSetNamed: #default</body><body package="Arbor Help System Outline Help Core">iconSetNamed: anIconSetName	^IconSets at: anIconSetName ifAbsent: [self defaultIconSet]</body><body package="Arbor Help System Outline Help Core">iconSets	^IconSets</body></methods><methods><class-id>VWHelp.AHSHyperTextLinkObject</class-id> <category>attributes</category><body package="Arbor Help System Outline Help Core">attributes	^super attributes, #(outlineName topicNumber)</body></methods><methods><class-id>VWHelp.AHSHyperTextLinkObject</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">outlineName 	^self linkObject first</body><body package="Arbor Help System Outline Help Core">outlineName: aStringOrNil 	self linkObject at: 1 put: aStringOrNil.</body><body package="Arbor Help System Outline Help Core">topicName	"Backward compatibility with older AHS versions."	^self topicNumber</body><body package="Arbor Help System Outline Help Core">topicNumber 	^self linkObject at: 2</body><body package="Arbor Help System Outline Help Core">topicNumber: aNumber 	^self linkObject at: 2 put: aNumber</body></methods><methods><class-id>VWHelp.AHSHyperTextLinkObject</class-id> <category>AHS Export adds</category><body package="Arbor Help System Outline Help Core">writeHyperlinkUsing: aTopicBodyWriter	^aTopicBodyWriter writeHypertextLink: self</body></methods><methods><class-id>VWHelp.AHSHyperTextLinkObject</class-id> <category>printing</category><body package="Arbor Help System Outline Help Core">printOn: aStream	aStream nextPutAll: 'Hypertext,'.	self linkObject printOn: aStream.</body></methods><methods><class-id>VWHelp.AHSHyperTextLinkObject</class-id> <category>initialize-release</category><body package="Arbor Help System Outline Help Core">initialize	super initialize.	self linkObject: (Array with: nil with: nil).</body></methods><methods><class-id>VWHelp.AHSHyperTextLinkObject</class-id> <category>engaging</category><body package="Arbor Help System Outline Help Core">engageFor: anObject	"The hyperlink has been engaged within the context of anObject."	^anObject engageHyperlink: self</body></methods><methods><class-id>VWHelp.AHSHyperTextLinkObject</class-id> <category>testing</category><body package="Arbor Help System Outline Help Core">isHyperText	"Is my linkType a hyper text type?"	^true</body></methods><methods><class-id>VWHelp.AHSHyperTextLinkObject class</class-id> <category>color &amp; emphasis</category><body package="Arbor Help System Outline Help Core">defaultColor	^self defaultColorValueClass darkGreen</body><body package="Arbor Help System Outline Help Core">defaultEmphasis	^#underline</body></methods><methods><class-id>VWHelp.AHSHyperTextLinkObject class</class-id> <category>instance creation</category><body package="Arbor Help System Outline Help Core">newLinkWithOutline: aString topic: anInteger	"creates an instance of hyper link"	| anInstance |	anInstance := self new.	anInstance linkObject: (Array with: aString with: anInteger).	^anInstance</body></methods><methods><class-id>VWHelp.AHSHyperTextLinkObject class</class-id> <category>attributes</category><body package="Arbor Help System Outline Help Core">type	"Answer a unique identifier for the type, used during RTF exports to indicate the type of the link."	^#text</body></methods><methods><class-id>VWHelp.AHSGlossaryViewer</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">availableKeys	"Answer a dictionary with all available keys."	^ self dictionary isNil		ifTrue: [Array with: '']		ifFalse: [self dictionary keys asSortedCollection]</body><body package="Arbor Help System Outline Help Core">entryAt: aSymbol	"Private - Answer the entry for the given key.  If the key is absent, return an error string."	^ self dictionary 		at: aSymbol		ifAbsent: ['This glossary entry references a deleted key.' asText allBold]</body><body package="Arbor Help System Outline Help Core">entryForKey	"Private - Answer the current entry for the given key.  If the key is nil, return a null string."	^ key isNil 		ifTrue: ['' asText]		ifFalse: [self entryAt: self symbolicKey]</body><body package="Arbor Help System Outline Help Core">setDictionary: aDictionary key: aSymbol	dictionary := aDictionary.	key := aSymbol.</body><body package="Arbor Help System Outline Help Core">symbolicKey	"Private - Answer the current key, ensuring it is a symbol."	^ self key asSymbol</body></methods><methods><class-id>VWHelp.AHSGlossaryViewer</class-id> <category>interface opening</category><body package="Arbor Help System Outline Help Core">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self selectedWord 		onChangeSend: #keyChanged 		to: self.	self keyChanged</body></methods><methods><class-id>VWHelp.AHSGlossaryViewer</class-id> <category>testing</category><body package="Arbor Help System Outline Help Core">haveEntryForKey	"Private - Answer true if we have an entry for the current key."	^ self dictionary includesKey: self symbolicKey</body></methods><methods><class-id>VWHelp.AHSGlossaryViewer</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">dictionary	^dictionary</body><body package="Arbor Help System Outline Help Core">dictionary: aDictionary	^dictionary := aDictionary</body><body package="Arbor Help System Outline Help Core">key	^key</body><body package="Arbor Help System Outline Help Core">key: aSymbol	^key := aSymbol</body><body package="Arbor Help System Outline Help Core">selectedWindowSpec	^selectedWindowSpec</body><body package="Arbor Help System Outline Help Core">selectedWindowSpec: aSymbol	selectedWindowSpec := aSymbol</body><body package="Arbor Help System Outline Help Core">textValue	^ self text value</body><body package="Arbor Help System Outline Help Core">textValue: aTextValue	self text value: aTextValue</body></methods><methods><class-id>VWHelp.AHSGlossaryViewer</class-id> <category>aspects</category><body package="Arbor Help System Outline Help Core">keys	^ keys isNil		ifTrue: [keys := (List withAll: (self availableKeys)) asValue]		ifFalse: [keys]</body><body package="Arbor Help System Outline Help Core">selectedWord	selectedWord isNil ifTrue: [selectedWord := self key asString asText allBold asValue].	^ selectedWord</body><body package="Arbor Help System Outline Help Core">text	text isNil ifTrue: [text := self entryForKey asValue].	^ text</body></methods><methods><class-id>VWHelp.AHSGlossaryViewer</class-id> <category>change messages</category><body package="Arbor Help System Outline Help Core">keyChanged	key isNil ifTrue: [^ self].	self key: self selectedWord value.	self textValue: (self dictionary 						at: self symbolicKey						ifAbsent: ['']) asText</body></methods><methods><class-id>VWHelp.AHSGlossaryViewer class</class-id> <category>interface opening</category><body package="Arbor Help System Outline Help Core">on: aGlossaryDictionary key: aGlossaryKey	"Answer an unopened glossary window used for viewing a glossary entry."	^ self new		setDictionary: aGlossaryDictionary		key: aGlossaryKey.</body><body package="Arbor Help System Outline Help Core">openOn: aGlossaryDictionary key: aGlossaryKey	"Open a glossary window for viewing a glossary entry."	^ (self		on: aGlossaryDictionary		key: aGlossaryKey) open</body></methods><methods><class-id>VWHelp.AHSGlossaryViewer class</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">messageCatalogID	^#arborHelpSystem</body></methods><methods><class-id>VWHelp.AHSGlossaryViewer class</class-id> <category>resources</category><body package="Arbor Help System Outline Help Core">textMenu	^AHSUtils textMenu</body></methods><methods><class-id>VWHelp.AHSToolbarTextEditor</class-id> <category>interface opening</category><body package="Arbor Help System Outline Help Core">configureWindow	"Private - Configure the window to use the proper controller, view, menu, etc."	self 		replaceEditorView;		replaceEditorController;		replaceEditorMenu.</body><body package="Arbor Help System Outline Help Core">postBuildWith: aBuilder	"Make sure the receiver is using the proper controller."	super postBuildWith: aBuilder.	self configureWindow.	self initializeSpellChecker.	self findReplace: (ArborSearchAndReplace new paragraphEditor: self textController).</body></methods><methods><class-id>VWHelp.AHSToolbarTextEditor</class-id> <category>toolbar control</category><body package="Arbor Help System Outline Help Core">hideCopyCutPaste	self setCopyCutPasteVisibilityTo: false</body><body package="Arbor Help System Outline Help Core">hideFindReplace	self setFindReplaceVisibilityTo: false</body><body package="Arbor Help System Outline Help Core">hideFormatting	self setFormattingVisibilityTo: false</body><body package="Arbor Help System Outline Help Core">hideSpellCheck	self setSpellCheckVisibilityTo: false</body><body package="Arbor Help System Outline Help Core">hideStyles	self setStylesVisibilityTo: false</body><body package="Arbor Help System Outline Help Core">setCopyCutPasteVisibilityTo: aBoolean	#(copy cut paste) do: [:nameKey | (self toolBarMenuHolder value atNameKey: nameKey) hidden: aBoolean not].	self updateToolBar.</body><body package="Arbor Help System Outline Help Core">setFindReplaceVisibilityTo: aBoolean	(self toolBarMenuHolder value atNameKey: #findReplace) hidden: aBoolean not.	self updateToolBar.</body><body package="Arbor Help System Outline Help Core">setFormattingVisibilityTo: aBoolean	#(indent outdent) do: [:nameKey | (self toolBarMenuHolder value atNameKey: nameKey) hidden: aBoolean not].	self updateToolBar.</body><body package="Arbor Help System Outline Help Core">setSpellCheckVisibilityTo: aBoolean	"Don't allow spell check button to display if the spell checker isn't loaded or can't be run, regardless of the value of aBoolean."	| item |	(item := self toolBarMenuHolder value atNameKey: #spellCheckButton)		isNil ifTrue: [^self].	item hidden: (		AHSUtils spellCheckerIsLoaded not			or: [(self respondsTo: #doSpellCheck) not			or: [aBoolean not]]).	self updateToolBar.</body><body package="Arbor Help System Outline Help Core">setStylesVisibilityTo: aBoolean	#(bold italic underline serif large color)		do: [:nameKey | (self toolBarMenuHolder value atNameKey: nameKey) hidden: aBoolean not].	self updateToolBar.</body><body package="Arbor Help System Outline Help Core">showCopyCutPaste	self setCopyCutPasteVisibilityTo: true</body><body package="Arbor Help System Outline Help Core">showFindReplace	self setFindReplaceVisibilityTo: true</body><body package="Arbor Help System Outline Help Core">showFormatting	self setFormattingVisibilityTo: true</body><body package="Arbor Help System Outline Help Core">showSpellCheck	self setSpellCheckVisibilityTo: true</body><body package="Arbor Help System Outline Help Core">showStyles	self setStylesVisibilityTo: true</body><body package="Arbor Help System Outline Help Core">updateToolBar	"Get the tool bar to rebuild itself."	self toolBarMenuHolder value: self toolBarMenuHolder value.</body></methods><methods><class-id>VWHelp.AHSToolbarTextEditor</class-id> <category>selecting</category><body package="Arbor Help System Outline Help Core">deselect	"Deselect any current selection found in the text view."	self textController view deselect</body><body package="Arbor Help System Outline Help Core">hideSelection	"Hide the selection"	self textController view displaySelection: false.</body><body package="Arbor Help System Outline Help Core">replaceSelectionWith: aString	"Replace the selected text with aString."	self textController replaceSelectionWith: aString</body><body package="Arbor Help System Outline Help Core">restoreSelection	"Restore the last selection"	self textController restoreSelection</body><body package="Arbor Help System Outline Help Core">selectAll	"Select all text in the editor window."	((self widgetWithID: #text)		takeKeyboardFocus;		widget) controller selectEntireText.</body><body package="Arbor Help System Outline Help Core">selectedText	"Answer the text currently selected in the text view."		^ self textController selection</body><body package="Arbor Help System Outline Help Core">showSelection	"Show the selection"	self textController view displaySelection: true.</body></methods><methods><class-id>VWHelp.AHSToolbarTextEditor</class-id> <category>searching</category><body package="Arbor Help System Outline Help Core">findAndSelectString: aString	"Find and highlight aString."	self textController view		selectionStartIndex: 1 stopIndex: 1;		displaySelection: true.	self textController view controller findNext: aString ignoreCase: true.</body><body package="Arbor Help System Outline Help Core">nextOccurrence	"search for the next entry of the selected text within the same piece of text."	^self textController findNextIgnoreCase: true</body></methods><methods><class-id>VWHelp.AHSToolbarTextEditor</class-id> <category>actions</category><body package="Arbor Help System Outline Help Core">changeColor	self textController changeColor</body><body package="Arbor Help System Outline Help Core">decreaseIndent	self textController decreaseIndent.</body><body package="Arbor Help System Outline Help Core">doCopy	self textController copySelection; restoreSelection</body><body package="Arbor Help System Outline Help Core">doCut	self textController cut; restoreSelection</body><body package="Arbor Help System Outline Help Core">doFindReplace	self activateFindReplace beStandard.</body><body package="Arbor Help System Outline Help Core">doPaste	self textController paste; restoreSelection</body><body package="Arbor Help System Outline Help Core">editable	"Make the receiver editable."	self showToolbar.	self textController readOnly: false.</body><body package="Arbor Help System Outline Help Core">hideToolbar	"Hide the icon toolbar in the text subcanvas"	self toolbarVisible ifTrue: [self toggleToolbar]</body><body package="Arbor Help System Outline Help Core">increaseIndent	self textController increaseIndent.</body><body package="Arbor Help System Outline Help Core">readOnly	"Make the receiver read only."	self 		hideToolbar;		hideSelection.	self textController readOnly: true.</body><body package="Arbor Help System Outline Help Core">selectEditorText	"Private - Select all of the text contained in the toolbar text editor."	| txtWidget |	txtWidget := self widgetWithID: #text.	txtWidget takeKeyboardFocus.	txtWidget widget controller selectEntireText.	self preventHelpTextChange</body><body package="Arbor Help System Outline Help Core">showToolbar	"Show the icon toolbar in the text subcanvas"	self toolbarVisible ifFalse: [self toggleToolbar]</body><body package="Arbor Help System Outline Help Core">toggleBold	self textController toggleEmphasis: #bold.</body><body package="Arbor Help System Outline Help Core">toggleItalic	self textController toggleEmphasis: #italic</body><body package="Arbor Help System Outline Help Core">toggleLarge	self textController toggleEmphasis: #large</body><body package="Arbor Help System Outline Help Core">toggleSerif	self textController toggleEmphasis: #serif</body><body package="Arbor Help System Outline Help Core">toggleToolbar	"Show/Hide the icon toolbar in the text view"	self 		aisSetVisibilityOf: #toolBar to: self toolbarVisible not;		adjustTextComponentLayout.</body><body package="Arbor Help System Outline Help Core">toggleUnderline	self textController toggleEmphasis: #underline</body></methods><methods><class-id>VWHelp.AHSToolbarTextEditor</class-id> <category>aspects</category><body package="Arbor Help System Outline Help Core">text	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^text isNil		ifTrue:			[text := String new asValue]		ifFalse:			[text]</body><body package="Arbor Help System Outline Help Core">toolBar	^ToolBar menu: self toolBarMenuHolder performer: self</body></methods><methods><class-id>VWHelp.AHSToolbarTextEditor</class-id> <category>private-toolbar</category><body package="Arbor Help System Outline Help Core">addCopyCutPasteTo: aMenu	| m |	m := Menu new			addItem: ((MenuItem labeled: 'Cut')						nameKey: #cut;						value: #doCut;						labelImage: (self bound: self class cutIcon));			addItem: ((MenuItem labeled: 'Copy')						nameKey: #copy;						value: #doCopy;						labelImage: (self bound: self class copyIcon));			addItem: ((MenuItem labeled: 'Paste')						nameKey: #paste;						value: #doPaste;						labelImage: (self bound: self class pasteIcon)).	aMenu aisAddMenu: m withSeparator: true.</body><body package="Arbor Help System Outline Help Core">addFormattingTo: aMenu	| m |	m := Menu new			addItem: ((MenuItem labeled: 'Outdent')						nameKey: #outdent;						value: #decreaseIndent;						labelImage: (self bound: self class outdentIcon));			addItem: ((MenuItem labeled: 'Indent')						nameKey: #indent;						value: #increaseIndent;						labelImage: (self bound: self class indentIcon)).	aMenu aisAddMenu: m withSeparator: true.</body><body package="Arbor Help System Outline Help Core">addSearchReplaceTo: aMenu	aMenu		aisAddItem: ((MenuItem labeled: 'Find and Replace...')						nameKey: #findReplace;						value: #doFindReplace;						labelImage: (self bound: self class findIcon))		after: (aMenu atNameKey: #paste)</body><body package="Arbor Help System Outline Help Core">addSpellCheckTo: aMenu	| item |	item := AHSUtils				performReceiver: self				selector: #spellCheckMenuItem				arguments: #()				ifAbsent: [^self].	item labelImage: (self bound: self class spellCheckIcon).	aMenu		aisAddItem: item		after: (aMenu atNameKey: #findReplace).</body><body package="Arbor Help System Outline Help Core">addStylesTo: aMenu	| m |	m := Menu new			addItem: ((MenuItem labeled: 'Bold')						nameKey: #bold;						value: #toggleBold;						labelImage: (self bound: self class boldIcon));			addItem: ((MenuItem labeled: 'Italic')						nameKey: #italic;						value: #toggleItalic;						labelImage: (self bound: self class italicIcon));			addItem: ((MenuItem labeled: 'Underline')						nameKey: #underline;						value: #toggleUnderline;						labelImage: (self bound: self class underlineIcon));			addItem: ((MenuItem labeled: 'Serif')						nameKey: #serif;						value: #toggleSerif;						labelImage: (self bound: self class serifIcon));			addItem: ((MenuItem labeled: 'Large')						nameKey: #large;						value: #toggleLarge;						labelImage: (self bound: self class largeIcon));			addItem: ((MenuItem labeled: 'Color')						nameKey: #color;						value: #changeColor;						labelImage: (self bound: self class colorIcon)).	aMenu aisAddMenu: m withSeparator: true.</body><body package="Arbor Help System Outline Help Core">bound: anIcon	"Define a fixed bounds for anIcon - this is meant to be used with button icons for the toolbar.  By using this method, all buttons will have the same shape."	^VisualBlock		block: [:gc :bounds | anIcon displayOn: gc at: (bounds center - (anIcon bounds extent // 2))]		extent: 20@20</body><body package="Arbor Help System Outline Help Core">defaultToolBarMenu	| menu |	menu := Menu new.	self		addCopyCutPasteTo: menu;		addStylesTo: menu;		addFormattingTo: menu;		addSearchReplaceTo: menu;		addSpellCheckTo: menu.	^menu</body></methods><methods><class-id>VWHelp.AHSToolbarTextEditor</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">activateFindReplace	^self findReplace		makeWindowVisible;		yourself</body><body package="Arbor Help System Outline Help Core">adjustTextComponentLayout	"Private - The toolbar has just been toggled.  Readjust the text component accordingly."	| cmp |	cmp := self widgetWithID: #text.	cmp 		newLayout: (cmp layout topOffset: (cmp layout topOffset bitXor: 30));		bounds: (cmp rectangleRelativeTo: cmp container bounds).	cmp container invalidate</body><body package="Arbor Help System Outline Help Core">controllerClass	"Private - Answer the controller used by the receiver."		^ AHSToolbarTextEditorController</body><body package="Arbor Help System Outline Help Core">preventHelpTextChange	"Private - Reset the focus so that the help text doesn't change from what it currently says."		| processor |	(processor := self ahsWindow ahsProcessor) isNil ifTrue: [^ self].	processor resetFocusChanged.</body><body package="Arbor Help System Outline Help Core">replaceEditorController	"Private - Replace the default controller class with one appropriate for the receiver."	self textController changeClassToThatOf: self controllerClass basicNew.	self textController paragraph changeClassToThatOf: AHSIndentableComposedText new.</body><body package="Arbor Help System Outline Help Core">replaceEditorMenu	"Private - Replace the default controller menu with one appropriate for the receiver.	 The default action is to do nothing."</body><body package="Arbor Help System Outline Help Core">replaceEditorView	"Private - Replace the default controller view with one appropriate for the receiver.	 The default action is to do nothing."</body><body package="Arbor Help System Outline Help Core">textMenu	| menu spellItem find |	menu := AHSUtils textMenu.	"Only add a spell check item if the AHS spell check extensions are loaded."	spellItem := AHSUtils					performReceiver: self					selector: #spellCheckMenuItem					arguments: #()					ifAbsent: [(MenuItem labeled: 'Spell Check Placeholder') hidden: true].	menu		aisAddItem: spellItem before: (menu menuItemWithValue: #hardcopy);		aisAddSeparatorBefore: spellItem;		removeItem: (menu menuItemWithValue: #find);		removeItem: (menu menuItemWithValue: #replace);		aisAddItem: (find := (MenuItem labeled: 'Find/Replace...')								nameKey: #findReplace;								value: [self doFindReplace])			after: nil;		aisAddSeparatorAfter: find.	^menu</body><body package="Arbor Help System Outline Help Core">textView	"Private - Answer the view containing the text to edit."	^ (self widgetWithID: #text) widget.</body></methods><methods><class-id>VWHelp.AHSToolbarTextEditor</class-id> <category>controller interface</category><body package="Arbor Help System Outline Help Core">accept	self textController accept.</body><body package="Arbor Help System Outline Help Core">replaceFrom: start to: stop with: aString	self textController replaceFrom: start to: stop with: aString.</body></methods><methods><class-id>VWHelp.AHSToolbarTextEditor</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">findReplace	^findReplace</body><body package="Arbor Help System Outline Help Core">findReplace: aSearchAndReplace	findReplace := aSearchAndReplace.</body><body package="Arbor Help System Outline Help Core">setTextValue: aString	"Set the value of text to aString.  This method will not cause the change mechanism	 to be invoked if one is defined for text."	self text setValue: aString.</body><body package="Arbor Help System Outline Help Core">spellChecker	^spellChecker</body><body package="Arbor Help System Outline Help Core">textController		^(self widgetWithID: #text) widget controller</body><body package="Arbor Help System Outline Help Core">textValue: aString	"Set the value of text to aString.  This method will cause the change mechanism	 to be invoked if one is defined for text."	self text value: aString.</body><body package="Arbor Help System Outline Help Core">toolBarMenuHolder	toolBarMenuHolder isNil ifTrue: [toolBarMenuHolder := self defaultToolBarMenu asValue].	^toolBarMenuHolder</body><body package="Arbor Help System Outline Help Core">toolBarMenuHolder: aValueModel	toolBarMenuHolder := aValueModel</body></methods><methods><class-id>VWHelp.AHSToolbarTextEditor</class-id> <category>testing</category><body package="Arbor Help System Outline Help Core">hasEmptySelection	"Answer true if no text is currently selected."		^ self textController selection isEmpty</body><body package="Arbor Help System Outline Help Core">hasSelection	"Answer true if some text is currently selected."		^ self hasEmptySelection not</body><body package="Arbor Help System Outline Help Core">hasTextChanged	"Answer true if the text has changed."	^ self textController textHasChanged</body><body package="Arbor Help System Outline Help Core">toolbarVisible	"Answer true if the toolbar is visible."	^(self widgetWithID: #toolBar) isVisible</body></methods><methods><class-id>VWHelp.AHSToolbarTextEditor</class-id> <category>event handlers</category><body package="Arbor Help System Outline Help Core">textChanged	"Private - The text in the editor has changed.   Notify our dependents."	self changed: #editorText.</body></methods><methods><class-id>VWHelp.AHSToolbarTextEditor</class-id> <category>spell check</category><body package="Arbor Help System Outline Help Core">closeSpellChecker	self spellChecker notNil ifTrue: [self spellChecker closeSpellInterface].</body><body package="Arbor Help System Outline Help Core">initializeSpellChecker	spellChecker := AHSUtils spellCheckerIsAvailable						ifTrue: [AHSUtils spellCheckerClass new]						ifFalse: [nil].</body></methods><methods><class-id>VWHelp.AHSToolbarTextEditor</class-id> <category>initialize-release</category><body package="Arbor Help System Outline Help Core">release	self closeSpellChecker.	super release.</body><body package="Arbor Help System Outline Help Core">setText: aString	"Set the text variable to aString as a value holder."	text := aString asValue</body></methods><methods><class-id>VWHelp.AHSToolbarTextEditor class</class-id> <category>resources</category><body package="Arbor Help System Outline Help Core">boldIcon	^OpaqueImageWithEnablement		figure: self boldImage		shape: self boldMask		inactiveMask: self boldInactiveMask</body><body package="Arbor Help System Outline Help Core">colorIcon	^OpaqueImage		figure: self colorImage		shape: self colorMask</body><body package="Arbor Help System Outline Help Core">copyIcon	^OpaqueImage		figure: self copyImage		shape: self copyMask</body><body package="Arbor Help System Outline Help Core">cutIcon	^OpaqueImage		figure: self cutImage		shape: self cutMask</body><body package="Arbor Help System Outline Help Core">findIcon	^OpaqueImage		figure: self findImage		shape: self findMask</body><body package="Arbor Help System Outline Help Core">indentIcon	^OpaqueImage		figure: self indentImage		shape: self indentMask</body><body package="Arbor Help System Outline Help Core">italicIcon	^OpaqueImage		figure: self italicImage		shape: self italicMask</body><body package="Arbor Help System Outline Help Core">largeIcon	^OpaqueImage		figure: self largeImage		shape: self largeMask</body><body package="Arbor Help System Outline Help Core">outdentIcon	^OpaqueImage		figure: self outdentImage		shape: self outdentMask</body><body package="Arbor Help System Outline Help Core">pasteIcon	^OpaqueImage		figure: self pasteImage		shape: self pasteMask</body><body package="Arbor Help System Outline Help Core">serifIcon	^OpaqueImage		figure: self serifImage		shape: self serifMask</body><body package="Arbor Help System Outline Help Core">spellCheckIcon	^OpaqueImageWithEnablement		figure: self spellCheckImage		shape: self spellCheckMask		inactiveMask: self spellCheckInactiveMask</body><body package="Arbor Help System Outline Help Core">underlineIcon	^OpaqueImage		figure: self underlineImage		shape: self underlineMask</body></methods><methods><class-id>VWHelp.AHSToolbarTextEditor class</class-id> <category>instance creation</category><body package="Arbor Help System Outline Help Core">on: aString	"Answer a new instance of the receiver, using aString as the default text value."	^ self basicNew		setText: aString</body></methods><methods><class-id>VWHelp.AHSToolbarTextEditor class</class-id> <category>help info (AHS)</category><body package="Arbor Help System Outline Help Core">ahsHelpData	^(AHSHelpClassData languages: #(#English) widgetData: ((AHSPersistentDictionary new)	 add: (#paste -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Paste contents of clipboard' runs: (RunArray runs: #(27) values: #(nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#serif -&gt; ((AHSPersistentDictionary new)	 add: (#disabled -&gt; (AHSHelpData texts: #(nil) outlineLinks: #(nil)));	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Add/remove serif style' runs: (RunArray runs: #(11 5 6) values: #(nil #serif nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#large -&gt; ((AHSPersistentDictionary new)	 add: (#disabled -&gt; (AHSHelpData texts: #(nil) outlineLinks: #(nil)));	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Add/remove large style' runs: (RunArray runs: #(11 5 6) values: #(nil #large nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#copy -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Copy selected text to clipboard' runs: (RunArray runs: #(31) values: #(nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#underline -&gt; ((AHSPersistentDictionary new)	 add: (#disabled -&gt; (AHSHelpData texts: #(nil) outlineLinks: #(nil)));	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Add/remove underline style' runs: (RunArray runs: #(11 9 6) values: #(nil #underline nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#bold -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Add/remove bold style' runs: (RunArray runs: #(11 4 6) values: #(nil #bold nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#spellCheckButton -&gt; ((AHSPersistentDictionary new)	 add: (#disabled -&gt; (AHSHelpData texts: nil outlineLinks: nil));	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Perform a spell check on the text.' runs: (RunArray runs: #(34) values: #(nil))); yourself) outlineLinks: nil)); yourself));	 add: (#findReplace -&gt; ((AHSPersistentDictionary new)	 add: (#disabled -&gt; (AHSHelpData texts: nil outlineLinks: nil));	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Find and optionally replace text.' runs: (RunArray runs: #(33) values: #(nil))); yourself) outlineLinks: nil)); yourself));	 add: (#italic -&gt; ((AHSPersistentDictionary new)	 add: (#disabled -&gt; (AHSHelpData texts: #(nil) outlineLinks: #(nil)));	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Add/remove italic style' runs: (RunArray runs: #(11 6 6) values: #(nil #italic nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#color -&gt; ((AHSPersistentDictionary new)	 add: (#disabled -&gt; (AHSHelpData texts: #(nil) outlineLinks: #(nil)));	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Change the color of the selected text.' runs: (RunArray runs: #(11 1 1 1 1 1 22) values: ((Array new: 7) at: 2 put: ((Array new: 2) at: 1 put: #bold; at: 2 put: (#color -&gt; (ColorValue scaledRed: 8191 scaledGreen: 4915 scaledBlue: 2056)); yourself); at: 3 put: ((Array new: 2) at: 1 put: #bold; at: 2 put: (#color -&gt; ColorValue blue); yourself); at: 4 put: ((Array new: 2) at: 1 put: #bold; at: 2 put: (#color -&gt; (ColorValue scaledRed: 0 scaledGreen: 4112 scaledBlue: 4112)); yourself); at: 5 put: ((Array new: 2) at: 1 put: #bold; at: 2 put: (#color -&gt; ColorValue purple); yourself); at: 6 put: ((Array new: 2) at: 1 put: #bold; at: 2 put: (#color -&gt; ColorValue red); yourself); yourself))); yourself) outlineLinks: #(nil))); yourself));	 add: (#text -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Edit text here' runs: (RunArray runs: #(14) values: #(nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#cut -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Cut selected text to clipboard' runs: (RunArray runs: #(30) values: #(nil))); yourself) outlineLinks: #(nil))); yourself)); yourself))</body></methods><methods><class-id>VWHelp.AHSToolbarHypertextEditor</class-id> <category>actions</category><body package="Arbor Help System Outline Help Core">engageGlossary: aText	"The user has clicked on a glossary entry.  Notify the interested party sending the selected text."	^ self changed: #engageGlossary with: aText</body><body package="Arbor Help System Outline Help Core">engageHyperGraphic: aLink	"The controller has detected a graphic link access.  Notify interested party."	^ self changed: #engageHyperGraphic with: aLink</body><body package="Arbor Help System Outline Help Core">engageHyperlink: aLink	"The controller has detected a link access.  Notify interested parties."	^self changed: #engageHyperlink with: aLink</body></methods><methods><class-id>VWHelp.AHSToolbarHypertextEditor</class-id> <category>event handlers</category><body package="Arbor Help System Outline Help Core">link	"Private - The user has requested the link operation.  Trigger the link event."	self changed: #createLink.</body><body package="Arbor Help System Outline Help Core">openGlossary	"Private - The user has requested the open glossary operation.  Trigger the event."	self changed: #openGlossary</body><body package="Arbor Help System Outline Help Core">openHyperGraphics	"Private - The user has requested the open hypergraphic link operation.  Trigger the event."	self changed: #openHyperGraphics.</body></methods><methods><class-id>VWHelp.AHSToolbarHypertextEditor</class-id> <category>hyperlinks</category><body package="Arbor Help System Outline Help Core">firstAvailableHyperGraphic	"Answer the first available hyper graphic from the selected text."	^ self textController selection asAHSHyperText firstAvailableHyperGraphic.</body><body package="Arbor Help System Outline Help Core">updateHyperLinkForLastWord	"Update the hyper text link for the last word."	self textController updateHyperLinkForLastWord</body></methods><methods><class-id>VWHelp.AHSToolbarHypertextEditor</class-id> <category>private-toolbar</category><body package="Arbor Help System Outline Help Core">addHyperlinkingTo: aMenu	| m |	m := Menu new			addItem: ((MenuItem labeled: 'Hypertext')						nameKey: #hypertext;						value: #link;						labelImage: (self bound: self class linkIcon));			addItem: ((MenuItem labeled: 'Glossary')						nameKey: #glossary;						value: #openGlossary;						labelImage: (self bound: self class glossaryIcon));			addItem: ((MenuItem labeled: 'Hypergraphic')						nameKey: #hypergraphic;						value: #openHyperGraphics;						labelImage: (self bound: self class graphicsIcon)).	aMenu aisAddMenu: m withSeparator: true.</body><body package="Arbor Help System Outline Help Core">defaultToolBarMenu	| menu |	menu := super defaultToolBarMenu.	self addHyperlinkingTo: menu.	^menu</body></methods><methods><class-id>VWHelp.AHSToolbarHypertextEditor</class-id> <category>menu messages</category><body package="Arbor Help System Outline Help Core">findNextFor: aHelpTextEditorController	"Search for the next entry of the selected text within the same piece of text."	aHelpTextEditorController findNext</body><body package="Arbor Help System Outline Help Core">removeLinkFrom: aTextController	| selectedText |	selectedText := aTextController selection.	selectedText removeAllHyperLinks.	aTextController 		replaceSelectionWith: selectedText;		accept.	self changed: #linkRemoved.	aTextController restoreSelection.</body></methods><methods><class-id>VWHelp.AHSToolbarHypertextEditor</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">controllerClass	"Private - Answer the controller used by the receiver."		^ AHSHelpTextEditorController</body><body package="Arbor Help System Outline Help Core">editorViewClass	"Private - Answer the view used by the receiver."		^ AHSHelpTextEditorView</body><body package="Arbor Help System Outline Help Core">replaceEditorMenu	"Private - Replace the default controller menu with one appropriate for the receiver."	self textController		menuHolder: self textMenu</body><body package="Arbor Help System Outline Help Core">replaceEditorView	"Private - Replace the default controller view with one appropriate for the receiver."	self textView changeClassToThatOf: self editorViewClass basicNew.	self textView widgetState colors: (LookPreferences new backgroundColor: ColorValue white).</body><body package="Arbor Help System Outline Help Core">textMenu	"Answer a text menu that provides operations for style	changes and managing hyperlinks"	| menu hyperMenu |	menu := super textMenu.	hyperMenu := Menu new					addItemLabel: 'Hypertext' value: #link;					addItemLabel: 'Graphic' value: #openHyperGraphics;					addItemLabel: 'Glossary' value: #openGlossary;					addItemGroupLabels: #('Remove')						values:  (Array with: [:aHelpTextEditorController | self removeLinkFrom: aHelpTextEditorController]).	menu		aisAddItem: ((MenuItem labeled: 'Find Next')						value: [:aHelpTextEditorController | self findNextFor: aHelpTextEditorController])			after: (menu atNameKey: #findReplace);		aisAddItem: ((MenuItem labeled: 'Hyperlinks')						submenu: hyperMenu)			after: (menu atNameKey: #noEmphasis).	^menu</body></methods><methods><class-id>VWHelp.AHSToolbarHypertextEditor class</class-id> <category>resources</category><body package="Arbor Help System Outline Help Core">glossaryIcon	^OpaqueImage		figure: self glossaryImage		shape: self glossaryMask</body><body package="Arbor Help System Outline Help Core">graphicsIcon	^OpaqueImage		figure: self graphicsImage		shape: self graphicsMask</body><body package="Arbor Help System Outline Help Core">linkIcon	^OpaqueImage		figure: self linkImage		shape: self linkMask</body></methods><methods><class-id>VWHelp.AHSToolbarHypertextEditor class</class-id> <category>help info (AHS)</category><body package="Arbor Help System Outline Help Core">ahsHelpData	^(AHSHelpClassData languages: #(#English) widgetData: ((AHSPersistentDictionary new)	 add: (#paste -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Paste contents of clipboard' runs: (RunArray runs: #(27) values: #(nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#serif -&gt; ((AHSPersistentDictionary new)	 add: (#disabled -&gt; (AHSHelpData texts: #(nil) outlineLinks: #(nil)));	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Add/remove serif style' runs: (RunArray runs: #(11 5 6) values: #(nil #serif nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#large -&gt; ((AHSPersistentDictionary new)	 add: (#disabled -&gt; (AHSHelpData texts: #(nil) outlineLinks: #(nil)));	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Add/remove large style' runs: (RunArray runs: #(11 5 6) values: #(nil #large nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#copy -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Copy selected text to clipboard' runs: (RunArray runs: #(31) values: #(nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#underline -&gt; ((AHSPersistentDictionary new)	 add: (#disabled -&gt; (AHSHelpData texts: #(nil) outlineLinks: #(nil)));	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Add/remove underline style' runs: (RunArray runs: #(11 9 6) values: #(nil #underline nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#bold -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Add/remove bold style' runs: (RunArray runs: #(11 4 6) values: #(nil #bold nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#spellCheckButton -&gt; ((AHSPersistentDictionary new)	 add: (#disabled -&gt; (AHSHelpData texts: nil outlineLinks: nil));	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Perform a spell check on the text.' runs: (RunArray runs: #(34) values: #(nil))); yourself) outlineLinks: nil)); yourself));	 add: (#findReplace -&gt; ((AHSPersistentDictionary new)	 add: (#disabled -&gt; (AHSHelpData texts: nil outlineLinks: nil));	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Find and optionally replace text.' runs: (RunArray runs: #(33) values: #(nil))); yourself) outlineLinks: nil)); yourself));	 add: (#italic -&gt; ((AHSPersistentDictionary new)	 add: (#disabled -&gt; (AHSHelpData texts: #(nil) outlineLinks: #(nil)));	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Add/remove italic style' runs: (RunArray runs: #(11 6 6) values: #(nil #italic nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#color -&gt; ((AHSPersistentDictionary new)	 add: (#disabled -&gt; (AHSHelpData texts: #(nil) outlineLinks: #(nil)));	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Change the color of the selected text.' runs: (RunArray runs: #(11 1 1 1 1 1 22) values: ((Array new: 7) at: 2 put: ((Array new: 2) at: 1 put: #bold; at: 2 put: (#color -&gt; (ColorValue scaledRed: 8191 scaledGreen: 4915 scaledBlue: 2056)); yourself); at: 3 put: ((Array new: 2) at: 1 put: #bold; at: 2 put: (#color -&gt; ColorValue blue); yourself); at: 4 put: ((Array new: 2) at: 1 put: #bold; at: 2 put: (#color -&gt; (ColorValue scaledRed: 0 scaledGreen: 4112 scaledBlue: 4112)); yourself); at: 5 put: ((Array new: 2) at: 1 put: #bold; at: 2 put: (#color -&gt; ColorValue purple); yourself); at: 6 put: ((Array new: 2) at: 1 put: #bold; at: 2 put: (#color -&gt; ColorValue red); yourself); yourself))); yourself) outlineLinks: #(nil))); yourself));	 add: (#text -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Edit text here' runs: (RunArray runs: #(14) values: #(nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#cut -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Cut selected text to clipboard' runs: (RunArray runs: #(30) values: #(nil))); yourself) outlineLinks: #(nil))); yourself));	 add: (#indent -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Increase the indent of all selected text (shift text right).' runs: (RunArray runs: #(60) values: #(nil))); yourself) outlineLinks: nil)); yourself));	 add: (#outdent -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Reduce the indent of all selected text (shift text left).' runs: (RunArray runs: #(57) values: #(nil))); yourself) outlineLinks: nil)); yourself));	 add: (#hypergraphic -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Link to a graphic.  The graphic may open in a separate window or be embedded in the text.' runs: (RunArray runs: #(4 85) values: ((Array new: 2) at: 1 put: ((Array new: 2) at: 1 put: (#color -&gt; ColorValue blue); at: 2 put: #italic; yourself); yourself))); yourself) outlineLinks: nil)); yourself));	 add: (#glossary -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Link the selected text to the outline''s glossary.' runs: (RunArray runs: #(4 45) values: ((Array new: 2) at: 1 put: ((Array new: 2) at: 1 put: (#color -&gt; ColorValue darkRed); at: 2 put: #italic; yourself); yourself))); yourself) outlineLinks: nil)); yourself));	 add: (#hypertext -&gt; ((AHSPersistentDictionary new)	 add: (#default -&gt; (AHSHelpData texts: ((Array new: 1) at: 1 put: (#{Smalltalk.Text} value string: 'Link the selected text to another entry, either in this outline or in an outline in another file.' runs: (RunArray runs: #(4 93) values: ((Array new: 2) at: 1 put: ((Array new: 2) at: 1 put: #underline; at: 2 put: (#color -&gt; ColorValue darkGreen); yourself); yourself))); yourself) outlineLinks: nil)); yourself)); yourself))</body></methods><methods><class-id>VWHelp.ArborDragBarView</class-id> <category>controller accessing</category><body package="Arbor Help System Outline Help Core">controller	"Answer the receiver`s current controller. If the receiver's controller 	is nil (the default case), an initialized instance of the receiver's 	default controller is installed and returned."	^self getController</body><body package="Arbor Help System Outline Help Core">controller: aController 	"Set the receiver's controller to aController.  An instance of NoController can be	specified to indicate that the receiver will not have a controller.  The model of	aController is set to the receiver's model."	self setController: aController</body><body package="Arbor Help System Outline Help Core">defaultController	"Answer an initialized instance of the receiver's default controller.	Subclasses should redefine this message only if the default controller 	instances need to be initialized in a nonstandard way."	^self defaultControllerClass new</body><body package="Arbor Help System Outline Help Core">defaultControllerClass	"Answer the class of the default controller for the receiver."	^ArborDragBarController</body></methods><methods><class-id>VWHelp.ArborDragBarView</class-id> <category>testing</category><body package="Arbor Help System Outline Help Core">containsPoint: aPoint	"Revert to the default implementation."	^self bounds containsPoint: aPoint</body><body package="Arbor Help System Outline Help Core">isVertical	^self orientation = #vertical</body></methods><methods><class-id>VWHelp.ArborDragBarView</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">getController	"Answer the receiver`s current controller. If the receiver's controller 	is nil (the default case), an initialized instance of the receiver's 	default controller is installed and returned."	controller == nil ifTrue: [self setController: self defaultController].	^controller</body><body package="Arbor Help System Outline Help Core">setController: aController 	"Set the receiver's controller to aController. If aController is not nil, its view is set to the receiver 	and its model is set to the receiver's model."	aController == nil ifFalse: [aController view: self].	controller := aController</body></methods><methods><class-id>VWHelp.ArborDragBarView</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">lineWidth	^lineWidth</body></methods><methods><class-id>VWHelp.ArborDragBarView</class-id> <category>displaying</category><body package="Arbor Help System Outline Help Core">displayOn: aGraphicsContext	"Display the divider on aGraphicsContext."	| box hilite |	hilite := self hiliteColor.	box := self bounds.	etched == true		ifTrue: [aGraphicsContext paint: self shadowColor]		ifFalse: [aGraphicsContext paint: SymbolicPaint foreground].	orientation == #vertical		ifTrue: [			box := (box topCenter - ((lineWidth / 2)@0)) corner: box corner.			aGraphicsContext displayRectangle: (box origin corner: box bottomLeft + (lineWidth@0)).			(etched == true and: [lineWidth &gt; 0])				ifTrue: [					aGraphicsContext paint: hilite.					aGraphicsContext displayRectangle: (box origin + ((lineWidth)@0) corner: box bottomLeft + ((lineWidth+1)@0))]]		ifFalse: [			box := (box leftCenter - (0@(lineWidth / 2))) corner: box corner.			aGraphicsContext displayRectangle: (box origin corner: box topRight + (0@lineWidth)).			(etched == true and: [lineWidth &gt; 0])				ifTrue: [					aGraphicsContext paint:  hilite.					aGraphicsContext displayRectangle: (box origin+ (0@(lineWidth)) corner: box topRight + (0@(lineWidth+1)))]]</body></methods><methods><class-id>VWHelp.ArborSlaveApplicationModel</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">allowUserPlacement	^allowUserPlacement</body><body package="Arbor Help System Outline Help Core">allowUserPlacement: aBoolean	allowUserPlacement := aBoolean.</body><body package="Arbor Help System Outline Help Core">alwaysVisible	^alwaysVisible</body><body package="Arbor Help System Outline Help Core">alwaysVisible: aBoolean	alwaysVisible := aBoolean.	self resetWindowOrigin.</body><body package="Arbor Help System Outline Help Core">initialExtent	^initialExtent</body><body package="Arbor Help System Outline Help Core">initialExtent: aPoint	initialExtent := aPoint.</body><body package="Arbor Help System Outline Help Core">isPinned	^isPinned</body><body package="Arbor Help System Outline Help Core">isPinned: aBoolean	^isPinned := aBoolean</body><body package="Arbor Help System Outline Help Core">parentWindow	^parentWindow</body><body package="Arbor Help System Outline Help Core">parentWindow: aWindow	parentWindow := aWindow.</body><body package="Arbor Help System Outline Help Core">relativeOrigin	^relativeOrigin</body><body package="Arbor Help System Outline Help Core">relativeOrigin: aValue	"aValue may be #top, #bottom, #left, #right, #mouse, a Point, or an Association.  If a Point, then the point is assumed to be fractional (for X and Y values between 0 and 1).  If an Association, the key must be #fractional or #absolute, and the value is a Point.  If #mouse, then the window is centered around the mouse cursor."	| val |	(aValue isSymbol or: [aValue aisIsAssociation])		ifTrue: [val := aValue]		ifFalse: [val := #fractional-&gt;aValue].	relativeOrigin = val ifTrue: [^self].	relativeOrigin := val.	self resetWindowOrigin.</body></methods><methods><class-id>VWHelp.ArborSlaveApplicationModel</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">captureRelativeOrigin	"If appropriate, snag the current relative origin and record it."	(self allowUserPlacement and: [self builder window displayBox ~= self windowBox])		ifTrue: [self relativeOrigin: #absolute-&gt;(self builder window globalOrigin - self parentWindow globalOrigin)].</body><body package="Arbor Help System Outline Help Core">computedOrigin	^self parentWindow isNil		ifTrue: [InputState default mousePoint]		ifFalse: [self parentWindow globalOrigin + self computedRelativeOrigin]</body><body package="Arbor Help System Outline Help Core">computedRelativeOrigin	"Compute my origin as relative to my parent window's origin.  The relative origin value may be a symbol (#left #right #top #bottom), or an association whose key is either #fractional or #absolute.  A fractional specification results in taking an X or Y between 0 and 1 as a fractional offset of the placement region.  For #absolute values (or #fractional values not between 0 and 1), the X and Y values are considered an absolute relative offset from my parent window's origin."	| slaveExtent parentExtent ro |	slaveExtent := self windowExtent.	parentExtent := self parentWindow extent.	(ro := self relativeOrigin) = #mouse		ifTrue: [ro := #absolute-&gt;(InputState default mousePoint - self parentWindow globalOrigin - (slaveExtent / 2) rounded)].	^ro isSymbol		ifTrue: [| dec |			dec := self class decoratorOffset.			(#(left right top bottom) includes: ro) ifFalse: [ro := #top].			ro = #left ifTrue: [ro := (slaveExtent x negated - dec x) @ 0].			ro = #right ifTrue: [ro := (parentExtent x + dec x) @ 0].			ro = #bottom ifTrue: [ro := 0 @ (parentExtent y + dec y)].			ro = #top ifTrue: [ro := 0 @ (slaveExtent y negated - dec y)].			ro]		ifFalse: [| x y placementExtent |			x := ro value x.			y := ro value y.			(ro key = #fractional or: [ro key ~= #absolute])				ifTrue: [| offset |					offset := slaveExtent + self class decoratorOffset.					placementExtent := parentExtent + (2 * offset).					(x between: 0 and: 1)						ifTrue: [x := (placementExtent x * x - (slaveExtent x * x)) rounded - offset x].					(y between: 0 and: 1)						ifTrue: [y := (placementExtent y * y - (slaveExtent y * y)) rounded - offset y]].			x@y]</body><body package="Arbor Help System Outline Help Core">doClose	"Close the window, no questions asked.  Note that #requestForWindowClose will NOT be invoked."	self builder window isNil ifTrue: [^self].	self builder window controller closeAndUnschedule.</body><body package="Arbor Help System Outline Help Core">doMasterClose	"The master window has closed.  Default is to close myself as well."	self doClose.</body><body package="Arbor Help System Outline Help Core">doSlaveClose	"I have been requested to close.  Default is to unmap myself ('hide' the window).  Subclasses may wish to actually close the window instead (which may be accomplished by simply overriding this method to return 'true')."	^self parentWindow isNil		or: [self parentWindow isOpen not		or: [			self builder window unmap.			self changed: #unmap.			false]]</body><body package="Arbor Help System Outline Help Core">isHostWin4	"Answer true if our host OS is Windows 95, 98, or NT."	| id |	id := OSHandle currentPlatformID.	^('win32* 95 *' match: id)		or: [('win32* 98 *' match: id)		or: ['win32* nt *' match: id]]</body><body package="Arbor Help System Outline Help Core">openWindowIn: aRectangle	"Subclasses may override this message to provide specific opening behaviors."	self builder openIn: aRectangle</body><body package="Arbor Help System Outline Help Core">resetWindowOrigin	| myWin newBox |	(self builder isNil or: [self builder window isNil]) ifTrue: [^self].	self isPinned ifTrue: [^self].	myWin := self builder window.	newBox := self windowBox.	myWin displayBox ~= newBox		ifTrue: [myWin displayBox: newBox].</body><body package="Arbor Help System Outline Help Core">setupParentWindow	"Set up my parent window's event dispatching and application."	| parentWin |	(parentWin := self parentWindow) isNil ifTrue: [^self].	parentWin application isNil		ifTrue: [parentWin application: parentWin model].	parentWin sendWindowEvents: ((parentWin sendWindowEvents isNil										ifTrue: [Set new]										ifFalse: [parentWin sendWindowEvents asSet])											addAll: #(#close #expand #resize #bounds #move #release #collapse);											yourself) asArray.	parentWin receiveWindowEvents: ((parentWin receiveWindowEvents isNil										ifTrue: [Set new]										ifFalse: [parentWin receiveWindowEvents asSet])											addAll: #(#expand);											yourself) asArray.</body><body package="Arbor Help System Outline Help Core">setupSlaveWindow	"Set up my window's application and event dispatching."	| win |	self parentWindow isNil ifTrue: [^self].	win := self builder window.	win application: self parentWindow application.	win beSlave.	win sendWindowEvents: ((win sendWindowEvents isNil								ifTrue: [Set new]								ifFalse: [win sendWindowEvents asSet])									addAll: #(#resize #bounds #enter #move);									yourself) asArray.	"Events my window dispatches to its master"	win receiveWindowEvents: ((win receiveWindowEvents isNil								ifTrue: [Set new]								ifFalse: [win receiveWindowEvents asSet])									addAll: #(#resize #bounds #move #release);									yourself) asArray.	"Events my window receives from its master."	"The following block processes events from my master.  If my master has multiple slaves, then this block may also get events from other slaves which need to be ignored.  Other events are handled in a dependency update - see #windowEvent:for:"	win windowEventBlock: [:myWin :event :otherWin |		otherWin = self parentWindow			ifTrue: [				(#(resize #bounds #move) includes: event key)					ifTrue: [						"In event driven mode, expose events are processed as resize events and come through before anything else.  If the slave is moved (and is allowed to move) and exposes some of the master, then the resize/expose event should be ignored.  This condition is checked by seeing if the current window is the slave window.  This could cause problems for slaves that resize the master window, or if the master window is in fact resized when the slave is the active window."						(event key ~= #resize or: [Window currentWindow ~= self builder window])							ifTrue: [self resetWindowOrigin]]					ifFalse: [						"Check for the #release event rather than #close because a bug (?) in VW has the #release event being dispatched for both regular windows and dialogs, but the #close only gets propagated for regular windows."						(otherWin = self parentWindow and: [event key = #release])							ifTrue: [self doClose]]].		"Answering true means no further processing is necessary.  For the #collapse event, the window will hide automatically in 95, 98 &amp; NT (assuming the master window is set), so ignore it."		otherWin ~= self parentWindow			or: 	[event key = #collapse and: [self isHostWin4]]].</body><body package="Arbor Help System Outline Help Core">windowBox	"Answer the box for the window.  If the window is supposed to be always visible, coerce the box to be within the bounds of the screen.  This method may be overridden if subclasses have differing ideas about what this means."	| box |	box := self computedOrigin extent: self windowExtent.	^self alwaysVisible		ifTrue: [Screen default makeRectangleVisible: box]		ifFalse: [box]</body><body package="Arbor Help System Outline Help Core">windowEvent: anEvent for: aWindow	"Note: This method only gets invoked due to the additional dependency placed upon my parentWindow's model.  This is because my window's application is set to be my parentWindow, so all event dispatching goes there.  A dependency was added to my parentWindow's model (which is the same as my window's application) to dispatch all event notifications back to here so we can handle the ones that are appropriate."	aWindow = self builder window ifTrue: [		(#(#bounds #resize #enter #move) includes: anEvent key)			ifTrue: [self captureRelativeOrigin].	"Store new location, if necessary."		(#(#bounds #resize #move) includes: anEvent key)			ifTrue: [self resetWindowOrigin].		"Re-layout if my size has changed."		"While sometimes useful, the following causes some problems, such as mouse actions bleeding through the slave into the master if they overlap and have events turned on.  So it's commented out by default."		"(#enter = anEvent key and: [self parentWindow isOpen])			ifTrue: [self parentWindow raise]"].	"Always keep my parent with focus when possible."</body><body package="Arbor Help System Outline Help Core">windowExtent	"Answer the extent for the window.  This method may be overridden if subclasses have differing ideas about how this is calculated."	^self builder window extent</body></methods><methods><class-id>VWHelp.ArborSlaveApplicationModel</class-id> <category>interface opening</category><body package="Arbor Help System Outline Help Core">allButOpenInterface: aSymbol	"Set up some of the necessary dependencies to make my window a slave and size the window properly for opening."	| bldr extent |	bldr := super allButOpenInterface: aSymbol.	bldr window masterWindow: self parentWindow.	extent := self initialExtent isNil				ifTrue: [(self class interfaceSpecFor: aSymbol) window bounds extent]				ifFalse: [self initialExtent].	bldr window minimumSize: (builder window minimumSize max: 10@10).	bldr window displayBox: (0@0 extent: extent).	self resetWindowOrigin.	self setupParentWindow.	self setupSlaveWindow.	^bldr</body><body package="Arbor Help System Outline Help Core">makeWindowVisible	(self builder isNil or: [self builder window isNil or: [self builder window isOpen not]])		ifTrue: [self open]		ifFalse: [			self builder window				map;				expand].</body><body package="Arbor Help System Outline Help Core">openInterface: aSymbol	| bldr |	bldr := self allButOpenInterface: aSymbol.	bldr doFinalHookup.	bldr window openIn: bldr window displayBox withType: #normal.	self postOpenWith: bldr.	bldr window displayPendingInvalidation.	^bldr</body><body package="Arbor Help System Outline Help Core">openInterface: aSymbol withPolicy: aPolicy inSession: anApplicationContext	"VW 3.0 or later.  This method will only be invoked if a subclass overrides the opening process.  Everything needs to go through #openInterface: for the dependencies to be set up correctly, so I override this method to co-opt control and return it to #openInterface:."	^self openInterface: aSymbol</body><body package="Arbor Help System Outline Help Core">postOpenWith: aBuilder	"Have my window's application (which is the model of my parentWindow) notify me when it gets updated.  This is mainly to catch the events coming into my window which then get dispatched to its application.  Normal windows generally have their application be the same as their model.  However, since I am a slave window, my window's application isn't me so it takes a bit more work for me to get notified when my window receives events."	super postOpenWith: aBuilder.	aBuilder window application notNil ifTrue: [		aBuilder window application			expressInterestIn: #windowState for: self sendBack: #windowEvent:for:].</body></methods><methods><class-id>VWHelp.ArborSlaveApplicationModel</class-id> <category>events</category><body package="Arbor Help System Outline Help Core">noticeOfWindowClose: aWindow	super noticeOfWindowClose: aWindow.	self builder window application		retractInterestIn: #windowState for: self.</body><body package="Arbor Help System Outline Help Core">requestForWindowClose	"Special case - if everything looks OK then invoke #doSlaveClose (which may choose to not close the window but do something different, like unmap the window!)"	^super requestForWindowClose and: [self doSlaveClose]</body></methods><methods><class-id>VWHelp.ArborSlaveApplicationModel</class-id> <category>initialize-release</category><body package="Arbor Help System Outline Help Core">initialize	super initialize.	self isPinned: false.	self allowUserPlacement: false.	self alwaysVisible: true.	self relativeOrigin: #top.</body></methods><methods><class-id>VWHelp.ArborSlaveApplicationModel</class-id> <category>actions</category><body package="Arbor Help System Outline Help Core">togglePin	| c |	self isPinned: self isPinned not.	(c := self builder componentAt: #pinButton) notNil		ifTrue: [			c widget label: (self isPinned								ifTrue: [self class pinDownIcon]								ifFalse: [self class pinUpIcon])].	self captureRelativeOrigin.	self isPinned not ifTrue: [self resetWindowOrigin].</body></methods><methods><class-id>VWHelp.ArborSlaveApplicationModel class</class-id> <category>interface opening</category><body package="Arbor Help System Outline Help Core">openWith: aWindow	"Open an instance of myself attached to aWindow."	^self new		parentWindow: aWindow;		open</body><body package="Arbor Help System Outline Help Core">openWith: aWindow at: aLocation	"Open an instance of myself attached to aWindow at aLocation (one of #top, #right, #left, #bottom, or a fractional point, or an association - see the instance method #relativeOrigin: for details)."	^self new		parentWindow: aWindow;		relativeOrigin: aLocation;		open</body><body package="Arbor Help System Outline Help Core">openWith: aWindow at: aLocation extent: aPoint	"Open an instance of myself attached to aWindow at aLocation (one of #top, #right, #left, #bottom, or a fractional point, or an association - see the instance method #relativeOrigin: for details) whose extent is aPoint."	^self new		parentWindow: aWindow;		relativeOrigin: aLocation;		initialExtent: aPoint;		open</body></methods><methods><class-id>VWHelp.ArborSlaveApplicationModel class</class-id> <category>resources</category><body package="Arbor Help System Outline Help Core">pinDownIcon	^OpaqueImage		figure: self pinDownImage		shape: self pinDownMask</body><body package="Arbor Help System Outline Help Core">pinUpIcon	^OpaqueImage		figure: self pinUpImage		shape: self pinUpMask</body></methods><methods><class-id>VWHelp.ArborSlaveApplicationModel class</class-id> <category>examples</category><body package="Arbor Help System Outline Help Core">masterSlaveExample	"This method opens a master window with a single slave window directly above it."	"self masterSlaveExample"	self openWith: (ApplicationWindow new model: ApplicationModel new; open).</body><body package="Arbor Help System Outline Help Core">masterSlaveExample2	"This method opens a master window with a slave window on either side of it that can hide/show."	"self masterSlaveExample2"	| win mw rcc left right sub |	win := (ApplicationWindow new) model: ApplicationModel new; open.	left := self openWith: win at: #left extent: 25 @ 250.	right := self openWith: win at: #right extent: 80 @ 30.	"The following code is overly complex in order to avoid creating a new ApplicationModel to support a menuBar."	sub := Menu new.	(Array with: left with: right) with: #('Left Palette' 'Right Palette') do: [:bldr :str || on |		on := true.		bldr source expressInterestIn: #unmap for: [on := false] sendBack: #value.		sub addItem: ((MenuItem labeled: str)							indication: [on];							value: [								(on := on not)									ifTrue: [bldr window map]									ifFalse: [bldr window unmap]])].	mw := (UIBuilder defaultPolicyClass new menuBarClass				menu: (Menu new addItem: ((MenuItem labeled: 'Slave Controls') submenu: sub); yourself)				performer: nil) inMenuBarWrapper.	rcc := ReComposingComposite new.	rcc addWrapper: mw.	win		keyboardProcessor: KeyboardProcessor new;		component: rcc;		extentEvent: win extent.</body><body package="Arbor Help System Outline Help Core">masterSlaveExample3	"This method opens a master window with a single slave window in the master's center that:		- can be relocated by the user		- can be partially visible (that is, can be 'pushed' off the screen)"	"self masterSlaveExample3"	| bldr |	bldr := self				openWith: (ApplicationWindow new model: ApplicationModel new; open)				at: 0.5 @ 0.5				extent: 80@40.	bldr source		allowUserPlacement: true;		alwaysVisible: false.</body></methods><methods><class-id>VWHelp.ArborSlaveApplicationModel class</class-id> <category>constants</category><body package="Arbor Help System Outline Help Core">decoratorOffset	"The amount to pad for X and Y to take into account the window system decorations."	^10@30</body></methods><methods><class-id>VWHelp.AHSOutlinerSubsetList</class-id> <category>actions</category><body package="Arbor Help System Outline Help Core">clearHistory	| selection |	(Dialog confirm: #areYouSure &lt;&lt; self messageCatalogID)		ifFalse: [^self].	selection := self outliner outliner list selection.	self outliner history clear.	selection notNil		ifTrue: [self outliner history					add: selection value data;					push: selection value data].	self subsetList list: self outliner history linearHistory.	self subsetList list isEmpty not		ifTrue: [self subsetList selectionIndex: 1]</body></methods><methods><class-id>VWHelp.AHSOutlinerSubsetList</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">doSlaveClose	"Always close the slave when requested (default is to unmap the window and answer false)."	^true</body></methods><methods><class-id>VWHelp.AHSOutlinerSubsetList</class-id> <category>interface opening</category><body package="Arbor Help System Outline Help Core">openAsDialog	|dlog|	dlog :=SimpleDialog new.	self builder: dlog builder.	dlog preBuildBlock: [:mdl :bldr | self preBuildWith: bldr].	dlog postBuildBlock: [:mdl :bldr | self postBuildWith: bldr].	^dlog openFor: self interface: (self mode == #history ifTrue: [#historyWindowSpec] ifFalse: [#windowSpec])</body><body package="Arbor Help System Outline Help Core">openDialogWithLabel: aLabel	"open my windowSpec with label aLabel."	self windowLabel: aLabel.	self openAsDialog</body><body package="Arbor Help System Outline Help Core">openInterface	"Open the ApplicationModel's user interface, using the specification 	resource of the standard name."	^self openInterface: (self mode == #history ifTrue: [#historyWindowSpec] ifFalse: [#windowSpec])</body><body package="Arbor Help System Outline Help Core">openWithLabel: aLabel	"open my windowSpec with label aLabel."	self windowLabel: aLabel.	self open</body><body package="Arbor Help System Outline Help Core">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self builder window label: self windowLabel.	windowLabel onChangeSend: #windowLabelChanged to: self.	self subsetList selectionIndexHolder			onChangeSend: #subsetListChanged to: self.</body></methods><methods><class-id>VWHelp.AHSOutlinerSubsetList</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">mode	^mode</body><body package="Arbor Help System Outline Help Core">mode: aSymbol		mode := aSymbol</body><body package="Arbor Help System Outline Help Core">outliner	^outliner</body><body package="Arbor Help System Outline Help Core">outliner: anOutline	outliner := anOutline</body><body package="Arbor Help System Outline Help Core">windowLabel	^windowLabel value</body><body package="Arbor Help System Outline Help Core">windowLabel: aLabel	^windowLabel value: aLabel</body></methods><methods><class-id>VWHelp.AHSOutlinerSubsetList</class-id> <category>aspects</category><body package="Arbor Help System Outline Help Core">subsetList	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^subsetList isNil ifTrue: [subsetList := SelectionInList new] ifFalse: [subsetList]</body></methods><methods><class-id>VWHelp.AHSOutlinerSubsetList</class-id> <category>change messages</category><body package="Arbor Help System Outline Help Core">subsetListChanged	| obj |	obj := self subsetList selection.	obj notNil		ifTrue: [obj := self outliner outline findTopicNumber: obj uniqueID].	self outliner builder window keyboardProcessor checkForAutoAccept.	self outliner outliner selectEntry: obj.	self outliner historyIndex: self subsetList selectionIndexHolder value.	self mode == #search 		ifTrue: [self outliner highlightSearchedWord].	"Uncomment the following to have the SubsetList close when an item is selected."	"self closeRequest"</body><body package="Arbor Help System Outline Help Core">windowLabelChanged	self builder window label: self windowLabel.</body></methods><methods><class-id>VWHelp.AHSOutlinerSubsetList</class-id> <category>initialize-release</category><body package="Arbor Help System Outline Help Core">initialize	super initialize.	windowLabel := String new asValue.	self allowUserPlacement: true.</body></methods><methods><class-id>VWHelp.AHSOutlinerSubsetList class</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">messageCatalogID	^#arborHelpSystem</body></methods><methods><class-id>VWHelp.ArborSearchAndReplace</class-id> <category>private</category><body package="Arbor Help System Outline Help Core">doSlaveClose	^true</body><body package="Arbor Help System Outline Help Core">handleFailedSearch	^self highlightNextMatchFromTop</body><body package="Arbor Help System Outline Help Core">highlightNextMatch	"Answer true if a match was found, false if not."	^self paragraphEditor		aisFindAndSelect: self searchString value		ignoreCase: self ignoreCase value</body><body package="Arbor Help System Outline Help Core">highlightNextMatchFromTop	self paragraphEditor deselect.	self paragraphEditor		selectionStartIndex: 1 		stopIndex: 1.	^self highlightNextMatch</body><body package="Arbor Help System Outline Help Core">makeCapitalizationOf: aString match: rootString	"By default, only worry about the capitalization of the first letter and only if it's to be uppercased."	| result |	result := String with: (rootString first isUppercase							ifTrue: [aString first asUppercase]							ifFalse: [aString first]).	^aString size &gt; 1		ifTrue: [result, (aString copyFrom: 2 to: aString size)]		ifFalse: [result]</body><body package="Arbor Help System Outline Help Core">replaceSelection	self paragraphEditor		deselect;		replaceSelectionWith: (self makeCapitalizationOf: replaceString value match: self paragraphEditor selection);		selectAndScroll.</body><body package="Arbor Help System Outline Help Core">setReplaceEnablement	self		aisSetEnablementOf: #(replaceButton replaceAllButton)		to: (self searchString value size &gt; 0 and: [self replaceString value size &gt; 0]).</body><body package="Arbor Help System Outline Help Core">setSearchEnablement	self aisSetEnablementOf: #findNextButton to: self searchString value size &gt; 0.	self setReplaceEnablement.</body><body package="Arbor Help System Outline Help Core">setWindowLabel	(self builder notNil and: [self builder window notNil])		ifTrue: [| ss |			(ss := self searchString value) isEmpty not ifTrue: [ss := ' - ', ss].			self builder window label: 'Find/Replace', ss].</body></methods><methods><class-id>VWHelp.ArborSearchAndReplace</class-id> <category>interface opening</category><body package="Arbor Help System Outline Help Core">openInterface: aSpec	^self paragraphEditor isNil		ifTrue: [Dialog warn: 'A ParagraphEditor must be specified!']		ifFalse: [			self parentWindow isNil				ifTrue: [self parentWindow: self paragraphEditor view topComponent].			super openInterface: aSpec]</body><body package="Arbor Help System Outline Help Core">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self searchString changed: #value.	self replaceString changed: #value.	(aBuilder componentAt: #searchString) widget controller continuousAccept: true.	(aBuilder componentAt: #replaceString) widget controller continuousAccept: true.	self setWindowLabel.</body></methods><methods><class-id>VWHelp.ArborSearchAndReplace</class-id> <category>actions</category><body package="Arbor Help System Outline Help Core">doSearch	"Answer true if the search was successful, false if nothing found."	| range |	range := self paragraphEditor selectionStartIndex to: self paragraphEditor selectionStopIndex - 1.	^self highlightNextMatch		or: [self handleFailedSearch		or: [			self paragraphEditor selectFrom: range first to: range last.			Dialog warn: 'Search item not found.'.			false]].</body><body package="Arbor Help System Outline Help Core">doSearchAndReplace	"Answer true if an item was replaced, false if none."	| result |	"In VW 2.5 and 2.5.1, the method #equivalentTo:ignoreCase: does the opposite of what is expected, although it has been fixed in later releases.  To make this code generic, we perform a little dance using exclusive-or and inversion to ensure we pass the correct value to the #findString:... method."	(result := self paragraphEditor selection string					equivalentTo: self searchString value					ignoreCase: (self ignoreCase value xor: ($A equivalentTo: $a ignoreCase: true)) not)		ifTrue: [self replaceSelection].	self doSearch.	^result</body><body package="Arbor Help System Outline Help Core">doSearchAndReplaceAll	"Answer true if an item was replaced, false if none."	| result range |	range := self paragraphEditor selectionStartIndex to: self paragraphEditor selectionStopIndex - 1.	(result := self highlightNextMatchFromTop)		ifTrue: [			[self replaceSelection.			self highlightNextMatch] whileTrue]		ifFalse: [			self paragraphEditor selectFrom: range first to: range last.			Dialog warn: 'Search item not found.'].	^result</body></methods><methods><class-id>VWHelp.ArborSearchAndReplace</class-id> <category>initialize-release</category><body package="Arbor Help System Outline Help Core">beEnhanced	"A placeholder.  Subclasses may wish to do something to effect an 'enhanced' set of options or widgets."</body><body package="Arbor Help System Outline Help Core">beStandard	"A placeholder.  Subclasses may wish to do something to effect a 'standard' set of options or widgets."</body><body package="Arbor Help System Outline Help Core">initialize	super initialize.	self allowUserPlacement: true.	self relativeOrigin: #mouse.	self searchString compute: [		self setSearchEnablement.		self setWindowLabel].	self replaceString compute: [self setReplaceEnablement].</body></methods><methods><class-id>VWHelp.ArborSearchAndReplace</class-id> <category>find &amp; replace</category><body package="Arbor Help System Outline Help Core">replace: findString with: replacementString ignoreCase: ignoreBoolean	self searchString value: findString string.	self ignoreCase value: ignoreBoolean.	replacementString isNil		ifTrue: [self doSearch]		ifFalse: [			self replaceString value: replacementString string.			self doSearchAndReplace].</body></methods><methods><class-id>VWHelp.ArborSearchAndReplace</class-id> <category>aspects</category><body package="Arbor Help System Outline Help Core">ignoreCase	^ignoreCase isNil		ifTrue: [ignoreCase := true asValue]		ifFalse: [ignoreCase]</body><body package="Arbor Help System Outline Help Core">replaceString	^replaceString isNil		ifTrue: [replaceString := String new asValue]		ifFalse: [replaceString]</body><body package="Arbor Help System Outline Help Core">searchString	^searchString isNil		ifTrue: [searchString := String new asValue]		ifFalse: [searchString]</body></methods><methods><class-id>VWHelp.ArborSearchAndReplace</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">paragraphEditor	^paragraphEditor</body><body package="Arbor Help System Outline Help Core">paragraphEditor: aParagraphEditor	paragraphEditor := aParagraphEditor.</body></methods><methods><class-id>VWHelp.ArborSearchAndReplace class</class-id> <category>find &amp; replace</category><body package="Arbor Help System Outline Help Core">find: findString ignoreCase: ignoreBoolean in: aParagraphEditor	^self replace: findString with: nil ignoreCase: ignoreBoolean in: aParagraphEditor</body><body package="Arbor Help System Outline Help Core">find: findString in: aParagraphEditor	^self find: findString ignoreCase: true in: aParagraphEditor</body><body package="Arbor Help System Outline Help Core">replace: findString with: replaceString ignoreCase: ignoreBoolean in: aParagraphEditor	| model |	model := self new.	model paragraphEditor: aParagraphEditor.	model open.	^model replace: findString with: replaceString ignoreCase: ignoreBoolean.</body><body package="Arbor Help System Outline Help Core">replace: findString with: replaceString in: aParagraphEditor	^self replace: findString with: replaceString ignoreCase: true in: aParagraphEditor</body><body package="Arbor Help System Outline Help Core">searchAndReplaceIn: aParagraphEditor	| mdl |	mdl := self new.	mdl searchString value: aParagraphEditor selection string.	mdl paragraphEditor: aParagraphEditor.	mdl open.	^mdl</body></methods><methods><class-id>VWHelp.AHSMemoryFriendlyHelpOutlineEntry</class-id> <category>converting</category><body package="Arbor Help System Outline Help Core">asAHSHelpOutlineEntry	|newEntry|	newEntry := AHSHelpOutlineEntry new					topic: self topic.	newEntry text: self text.	newEntry uniqueID: self uniqueID.	^newEntry</body></methods><methods><class-id>VWHelp.AHSMemoryFriendlyHelpOutlineEntry</class-id> <category>testing</category><body package="Arbor Help System Outline Help Core">containsFilePointers	^(text isKindOf: Integer)</body></methods><methods><class-id>VWHelp.AHSMemoryFriendlyHelpOutlineEntry</class-id> <category>accessing</category><body package="Arbor Help System Outline Help Core">filename	^filename</body><body package="Arbor Help System Outline Help Core">filename: aFilename	filename := aFilename asFilename.	self odbDirty</body><body package="Arbor Help System Outline Help Core">text	|textOrPosn|	textOrPosn := text.		"The text may still be in its 'persistent' form for storage in a file.		Convert to the transient form if necessary"	(self class isPositionPersistent: textOrPosn)		ifTrue: [text := textOrPosn := self class positionAsTransient: textOrPosn].	(textOrPosn isKindOf: Integer)		ifTrue: [ "text is on disk"				Cursor read showWhile: [|bos|					bos := #{BinaryObjectStorage} value onOldNoScan: self filename readStream.					[bos position: textOrPosn.					textOrPosn := bos next]						ensure: [bos close]]].	^textOrPosn</body></methods><methods><class-id>VWHelp.AHSMemoryFriendlyHelpOutlineEntry</class-id> <category>copying</category><body package="Arbor Help System Outline Help Core">postCopy	topic := topic asString copy.	(text isKindOf: CharacterArray)		ifTrue: [text := AHSUtils deepCopyOfText: text].</body></methods><methods><class-id>VWHelp.AHSMemoryFriendlyHelpOutlineEntry class</class-id> <category>utilities</category><body package="Arbor Help System Outline Help Core">isPositionPersistent: anObject	"Answer whether anObject is in its persistent form"	^anObject class == LargePositiveInteger</body><body package="Arbor Help System Outline Help Core">positionAsPersistent: anInteger	"Convert a file position to the representation used in files.	Canonical representation is a 4-byte positive integer"	| int |	int := Integer new: 4 neg: false.	1 to: 4 do: [:i |		int digitAt: i put: ((anInteger bitShift: -8 * (i - 1)) bitAnd: 16rFF)].	^int</body><body package="Arbor Help System Outline Help Core">positionAsTransient: aLargePositiveInteger	"Convert the persistent form of a file position back to	transient form"	^aLargePositiveInteger compressed</body></methods><methods><class-id>VWHelp.AHSMemoryFriendlyHelpOutlineEntry class</class-id> <category>constants</category><body package="Arbor Help System Outline Help Core">maxPosition	^16rFFFFFFFF</body><body package="Arbor Help System Outline Help Core">zeroPosition	"Answer the object representing the zero position"	^Integer new: 4 neg: false</body></methods><methods><class-id>VWHelp.AHSSearchDialog</class-id> <category>aspects</category><body package="Arbor Help System Outline Help Core">searchIn	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^searchIn isNil		ifTrue:			[searchIn := nil asValue]		ifFalse:			[searchIn]</body><body package="Arbor Help System Outline Help Core">searchString	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^searchString isNil		ifTrue:			[searchString := String new asValue]		ifFalse:			[searchString]</body></methods><methods><class-id>VWHelp.AHSSearchDialog</class-id> <category>actions</category><body package="Arbor Help System Outline Help Core">ok	self accept value: true.</body></methods><methods><class-id>VWHelp.AHSSearchDialog</class-id> <category>initialize-release</category><body package="Arbor Help System Outline Help Core">initialize	super initialize.	self searchIn value: #text.</body></methods><methods><class-id>VWHelp.AHSSearchDialog class</class-id> <category>interface opening</category><body package="Arbor Help System Outline Help Core">searchFor: defaultString	| aSearch answerDictionary |	aSearch := self new.	aSearch searchString value: defaultString.	answerDictionary := nil.	aSearch open		ifTrue: [| searchIn |				searchIn := aSearch searchIn value.				answerDictionary := Dictionary new.				answerDictionary at: #searchString put: aSearch searchString value.				answerDictionary at: #searchTopics put: (searchIn = #topics or: [searchIn = #both]).				answerDictionary at: #searchText put: (searchIn = #text or: [searchIn = #both])].	^answerDictionary</body></methods><methods><class-id>UI.ApplicationModel</class-id> <category>Arbor Core adds</category><body package="Arbor Help System Outline Help Core">aisDisable: idOrCollection	"Disable the component(s) specified in the argument."	| bldr |	(bldr := self builder) isNil ifTrue: [^self].	idOrCollection isSymbol		ifTrue: [| comp |			(comp := bldr componentAt: idOrCollection) notNil				ifTrue: [comp disable]]		ifFalse: [			idOrCollection do: [:id || comp |				(comp := bldr componentAt: id) notNil					ifTrue: [comp disable]]].</body><body package="Arbor Help System Outline Help Core">aisEnable: idOrCollection	"Enable the component(s) specified in the argument."	| bldr |	(bldr := self builder) isNil ifTrue: [^self].	idOrCollection isSymbol		ifTrue: [| comp |			(comp := bldr componentAt: idOrCollection) notNil				ifTrue: [comp enable]]		ifFalse: [			idOrCollection do: [:id || comp |				(comp := bldr componentAt: id) notNil					ifTrue: [comp enable]]].</body><body package="Arbor Help System Outline Help Core">aisMakeInvisible: idOrCollection	"Make the component(s) specified in the argument invisible."	| bldr |	(bldr := self builder) isNil ifTrue: [^self].	idOrCollection isSymbol		ifTrue: [| comp |			(comp := bldr componentAt: idOrCollection) notNil				ifTrue: [comp beInvisible]]		ifFalse: [			idOrCollection do: [:id || comp |				(comp := bldr componentAt: id) notNil					ifTrue: [comp beInvisible]]].</body><body package="Arbor Help System Outline Help Core">aisMakeVisible: idOrCollection	"Make the component(s) specified in the argument visible."	| bldr |	(bldr := self builder) isNil ifTrue: [^self].	idOrCollection isSymbol		ifTrue: [| comp |			(comp := bldr componentAt: idOrCollection) notNil				ifTrue: [comp beVisible]]		ifFalse: [			idOrCollection do: [:id || comp |				(comp := bldr componentAt: id) notNil					ifTrue: [comp beVisible]]].</body><body package="Arbor Help System Outline Help Core">aisSetEnablementOf: aCollection to: aBoolean	aBoolean		ifTrue: [self aisEnable: aCollection]		ifFalse: [self aisDisable: aCollection].</body><body package="Arbor Help System Outline Help Core">aisSetVisibilityOf: aCollection to: aBoolean	aBoolean		ifTrue: [self aisMakeVisible: aCollection]		ifFalse: [self aisMakeInvisible: aCollection].</body></methods><methods><class-id>VWHelp.AHSPreferences class</class-id> <category>AHSOHC adds-accessing</category><body package="Arbor Help System Outline Help Core">bookmarkDirectory	^self preferenceAt: #bookmarkDirectory ifAbsent: [#current]</body><body package="Arbor Help System Outline Help Core">bookmarkDirectory: aSymbol	^self preferenceAt: #bookmarkDirectory put: aSymbol</body><body package="Arbor Help System Outline Help Core">expandOutlines	^self preferenceAt: #expandOutlines ifAbsent: [false]</body><body package="Arbor Help System Outline Help Core">expandOutlines: aBoolean	^self preferenceAt: #expandOutlines put: aBoolean</body><body package="Arbor Help System Outline Help Core">outlineViewerClass	| style |	style := self outlineViewerStyle.	style = #embedGraphics ifTrue: [^AHSOutlineTextGraphicMixViewer].	style = #linkGraphics ifTrue: [^AHSOutlineViewer].	Dialog warn: 'Unknown viewer style: ', style printString, '\\Using embedded graphics viewer...' withCRs.	^AHSOutlineTextGraphicMixViewer</body><body package="Arbor Help System Outline Help Core">outlineViewerStyle	^self preferenceAt: #outlineViewerStyle ifAbsent: [#embedGraphics]</body><body package="Arbor Help System Outline Help Core">outlineViewerStyle: aSymbol	"Either #embedGraphics or #linkGraphics."	self preferenceAt: #outlineViewerStyle put: aSymbol.</body><body package="Arbor Help System Outline Help Core">specifiedDirectory	^self preferenceAt: #specifiedDirectory ifAbsent: [String new]</body><body package="Arbor Help System Outline Help Core">specifiedDirectory: aString	^self preferenceAt: #specifiedDirectory put: aString</body></methods><methods><class-id>VWHelp.AHSStorageManager class</class-id> <category>AHSOHC adds-outlines</category><body package="Arbor Help System Outline Help Core">bookmarksInFlatFileNamed: aString	"Answers nil if not found"	| bookmarks aFilename |	bookmarks := nil.	Cursor wait		showWhile: [aFilename := self fullBookmarkFilename: aString.					aFilename asFilename exists						ifTrue: [bookmarks := AHSUtils bossInObjectFrom: aFilename.								"Make sure it's an AHSPersistentDictionary"								(bookmarks isKindOf: AHSPersistentDictionary)									ifFalse: [bookmarks := nil]]].	^bookmarks</body><body package="Arbor Help System Outline Help Core">bookmarksInFlatFileNamed: aString put: bookmarks	"Save bookmarks in a flat file."	Cursor wait 		showWhile: [| aFilename |					aFilename := self fullBookmarkFilename: aString.					AHSUtils bossOutObject: bookmarks on: aFilename].	^true</body></methods><methods><class-id>VWHelp.AHSStorageManager class</class-id> <category>AHSOHC adds-outlines - private</category><body package="Arbor Help System Outline Help Core">bossInOutlineNamed: aString	"Private - Answer the outline contained in the boss file named aString.  Perform any necessary fixups	before answering the outline."	| fixups outline |	fixups := OrderedCollection new.	outline := AHSOutline fixupSignal				handle: [:ex | ex proceedWith: fixups]				do: [AHSUtils bossInObjectFrom: aString].	fixups do: [:each | each value: aString].	^ outline</body></methods><methods><class-id>VWHelp.AHSStorageManager class</class-id> <category>AHSOHC adds-outlines</category><body package="Arbor Help System Outline Help Core">chooseOutlineNameInFile	"Put up a dialog to choose an outline name for a file"	| fname |	fname := Dialog requestFileName: 'Outline name:'							default: '*'								version: #mustBeOld								ifFail: [^nil].	^fname</body><body package="Arbor Help System Outline Help Core">fullBookmarkFilename: aString	"Converts the bookmark filename to the full filename by prepending the bookmark directory from AHSPreferences."	| aFilename |	aFilename := aString.	AHSPreferences bookmarkDirectory == #current		ifTrue: [aFilename := aString asFilename tail].	AHSPreferences bookmarkDirectory == #outline		ifTrue: [aFilename := aString].	AHSPreferences bookmarkDirectory == #specified		ifTrue: [| aDirectory |				(aDirectory := AHSPreferences specifiedDirectory) isNil					ifTrue: [aDirectory := String new]					ifFalse: [(aDirectory asFilename exists and: [aDirectory asFilename isDirectory])								ifFalse: [aDirectory := String new]								ifTrue: [aDirectory asString last ~= Filename separator											ifTrue: [aDirectory := aDirectory asString, (String with: Filename separator)]]].				aFilename := aDirectory, aFilename].	^aFilename</body><body package="Arbor Help System Outline Help Core">getOutlineNamed: aString 	"Get the outline named aString"	"By default, answers a read-only outline"	^self getOutlineNamed: aString readOnly: true</body><body package="Arbor Help System Outline Help Core">getOutlineNamed: aString readOnly: readOnly	"Get the outline named aString"	^self getOutlineNamed: aString readOnly: readOnly source: self outlineSource</body><body package="Arbor Help System Outline Help Core">getOutlineNamed: aString readOnly: readOnly source: aSymbol	"Get the outline named aString in the source aSymbol"	aSymbol == #Versant ifTrue: 		[^ self 			outlineInVersantNamed: aString 			readOnly: readOnly].	aSymbol == #GemStone ifTrue: 		[^ self 			outlineInGemStoneNamed: aString 			readOnly: readOnly].	aSymbol == #Envy ifTrue: 		[^ self 			outlineInEnvyNamed: aString 			readOnly: readOnly].	aSymbol == #File ifTrue: 		[^ self 			outlineInFileNamed: aString 			readOnly: readOnly].</body><body package="Arbor Help System Outline Help Core">getOutlineNamed: aString source: aSymbol	"Get the outline named aString, first checking in a database, then try a file by that name"	"By default, answers a read-only outline"	^ self 		getOutlineNamed: aString 		readOnly: true 		source: aSymbol</body></methods><methods><class-id>VWHelp.AHSStorageManager class</class-id> <category>AHSOHC adds-private-accessing</category><body package="Arbor Help System Outline Help Core">helpOutlines	"Answer the GemStone help outlines"	^GemStoneHelpOutlines</body><body package="Arbor Help System Outline Help Core">helpOutlines: aDictionary	"Set the GemStone help outlines"	GemStoneHelpOutlines := aDictionary.</body></methods><methods><class-id>VWHelp.AHSStorageManager class</class-id> <category>AHSOHC adds-private</category><body package="Arbor Help System Outline Help Core">invalidOutline: aString	"Answer nil.  Display a dialog indicating that the the item named aString does not contain	 a valid outline."	Dialog warn: aString asText allBold , ' does not contain an outline.'.	^ nil</body></methods><methods><class-id>VWHelp.AHSStorageManager class</class-id> <category>AHSOHC adds-testing - private</category><body package="Arbor Help System Outline Help Core">isValidOutline: anOutline	"Private - Answer true if anOutline is a valid outline file."	^ anOutline notNil and: [anOutline isKindOf: AHSOutline]</body></methods><methods><class-id>VWHelp.AHSStorageManager class</class-id> <category>AHSOHC adds-outlines</category><body package="Arbor Help System Outline Help Core">outlineInFileNamed: aString 	"Answers nil if not found"	^ self 		outlineInFileNamed: aString 		readOnly: self allowEditing not</body><body package="Arbor Help System Outline Help Core">outlineInFileNamed: aString readOnly: readOnly	"Answers an outline from the file named aString, or nil if not found.	 Note that readOnly is not used.  I don't know why not. (jwh)"	| outline |	outline := OSErrorHolder inaccessibleSignal				handle: [:ex | nil]				do: [self readOutlineFileNamed: aString].	^(self isValidOutline: outline)		ifTrue: [outline]		ifFalse: [self invalidOutline: aString].</body></methods><methods><class-id>VWHelp.AHSStorageManager class</class-id> <category>AHSOHC adds-class accessing</category><body package="Arbor Help System Outline Help Core">outlineSource	^OutlineSource value</body><body package="Arbor Help System Outline Help Core">outlineSource: aBoolean	OutlineSource value: aBoolean</body><body package="Arbor Help System Outline Help Core">outlineSourceModel	^OutlineSource</body></methods><methods><class-id>VWHelp.AHSStorageManager class</class-id> <category>AHSOHC adds-outlines - private</category><body package="Arbor Help System Outline Help Core">readBOSSOutline: aString	"Private - Answer an outline contained in a BOSS format file named aString.  If the file can't	 be read, answer nil."	#{BinaryObjectStorage} isDefined not ifTrue: [		Dialog warn: 'BOSS must be loaded to perform this operation'.		^nil].	^#{BinaryObjectStorage} value errorSignal		handle: [:ex | 			Dialog warn: ex errorString.			ex returnWith: nil]		do: [self bossInOutlineNamed: aString]</body><body package="Arbor Help System Outline Help Core">readOutlineFileNamed: aString	"Answer an outline derived from the contents of the file named aString.  If the file	 is not found, answer nil."	| outline |	outline := AHSUtils				performReceiver: self				selector: #readRTFOutline:				arguments: (Array with: aString)				ifAbsent: [nil].	^ outline isNil 		ifTrue: [self readBOSSOutline: aString]		ifFalse: [outline]</body></methods><methods><class-id>VWHelp.AHSStorageManager class</class-id> <category>AHSOHC adds-outlines</category><body package="Arbor Help System Outline Help Core">removeBookmarksInFlatFileNamed: aString	"Remove the bookmark file."	Cursor wait showWhile: [| aFilename |		aFilename := (self fullBookmarkFilename: aString) asFilename.		aFilename exists ifTrue: [aFilename delete]].</body></methods><methods><class-id>UI.ParagraphEditor</class-id> <category>Arbor GUI Extensions adds</category><body package="Arbor Help System Outline Help Core">aisFindAndSelect: aString ignoreCase: aBoolean	"Search for the text aString in the text and select it if found."	| index |	index := (self text				findString: aString				startingAt: self selectionStopIndex				ignoreCase: aBoolean				useWildcards: false) first.	index = 0 ifTrue: [^false].	self view displaySelection: true.	self selectAndScrollFrom: index to: index + aString size - 1.	^true</body><body package="Arbor Help System Outline Help Core">aisSetEmphasisHere: anEmphasis	"Set the current emphasis directly."	emphasisHere := anEmphasis.</body></methods><methods><class-id>VWHelp.AHSUtils class</class-id> <category>AHSOHC adds-file utilities</category><body package="Arbor Help System Outline Help Core">bossInObjectFrom: aFilename 	"Answer the first object in the BOSS File named aFilename"	| b |	#{BinaryObjectStorage} isDefined not ifTrue: [^Dialog warn: 'BOSS must be loaded to perform this operation'].	^Cursor read showWhile: [		b := #{BinaryObjectStorage} value onOld: aFilename asFilename readStream.		[b next] ensure: [b close]]</body><body package="Arbor Help System Outline Help Core">bossOutObject: anObject on: aFilename 	"Boss out anObject on a filename."	| b |	#{BinaryObjectStorage} isDefined not ifTrue: [^Dialog warn: 'BOSS must be loaded to perform this operation'].	Cursor write showWhile: [		b := #{BinaryObjectStorage} value onNew: aFilename asFilename writeStream.		[b nextPut: anObject] ensure: [b close]]</body></methods><methods><class-id>VWHelp.AHSUtils class</class-id> <category>AHSOHC adds-testing</category><body package="Arbor Help System Outline Help Core">hasEnvy	"Answer true if this is an ENVY image."	^#{Application} isDefined		and: [#{SubApplication} isDefined		and: [#{System} isDefined]]</body></methods><methods><class-id>VWHelp.AHSUtils class</class-id> <category>AHSOHC adds-utilities</category><body package="Arbor Help System Outline Help Core">performReceiver: anObject selector: selector arguments: arguments ifAbsent: aBlock	"If the method identified by selector exists, execute a #perform:withArguments: operation.  Otherwise evaluate aBlock.  This method can be used to provide optional behavior if certain extensions are loaded, while not requiring that the extension be loaded for a valid operation to occur."	| sel args |	sel := selector asSymbol.	args := arguments asArray.	^(anObject respondsTo: sel)		ifTrue: [anObject perform: sel withArguments: args]		ifFalse: [aBlock value].</body><body package="Arbor Help System Outline Help Core">pickColor: defaultColor	^ArborTextStyleDialog pickColor: defaultColor</body></methods><methods><class-id>VWHelp.AHSUtils class</class-id> <category>AHSOHC adds-testing</category><body package="Arbor Help System Outline Help Core">spellCheckerClass	"Answer the spell checker class, or nil if there is none loaded."	^#{ArborSpellChecker} valueOrDo: [nil]</body><body package="Arbor Help System Outline Help Core">spellCheckerIsAvailable	"Answer true if the spell checker is present and useable.  That is, answer true if the spell checker code is present in the image and we are running on a supported platform/environment."	^self spellCheckerClass notNil and: [self spellCheckerClass isAvailable]</body><body package="Arbor Help System Outline Help Core">spellCheckerIsLoaded	"Answer true if the spell checker exists in the image, whether or not it can actually run."	^self spellCheckerClass notNil</body></methods><methods><class-id>VWHelp.AHSUtils class</class-id> <category>AHSOHC adds-resources</category><body package="Arbor Help System Outline Help Core">stringMenu	"Answer a string menu"	^MenuBuilder new		add: 'Undo'-&gt;#undo;		line;		addCopyCutPaste;		menu</body><body package="Arbor Help System Outline Help Core">textMenu	"Answer a text menu that provides operations for style changes"	^MenuBuilder new			addDefaultTextMenu;			line;			add: 'Change Style'-&gt;[:ctrlr | ArborTextStyleDialog openForParagraphEditor: ctrlr];			addItem: ((MenuItem labeled: 'Plain')					nameKey: #noEmphasis;					value: [:ctrlr || selectedText | 							selectedText := ctrlr selection.							selectedText addEmphasis: #() removeEmphasis: #{Smalltalk.Text} value aisAllEmphases allowDuplicates: false.							ctrlr replaceSelectionWith: selectedText.							ctrlr accept.							ctrlr restoreSelection]);			line;			addHardcopy;			menu</body></methods><methods><class-id>Core.Text class</class-id> <category>Arbor Core adds</category><body package="Arbor Help System Outline Help Core">aisAllEmphases	"Answer a collection of all normal emphases.  Other emphases may be added and interpreted by the CharacterAttributes' attributes."	^#(#strikeout #serif #large #underline #italic #bold) copyWith: #color-&gt;nil</body></methods><methods><class-id>Core.Text</class-id> <category>AHSOHC adds</category><body package="Arbor Help System Outline Help Core">asAHSHyperText	^#{VWHelp.AHSHelpHyperText} value string: self string runs: self runs</body><body package="Arbor Help System Outline Help Core">emphasisAt: characterIndex asArray: aBoolean	"Answer the code for characters in the run beginning at characterIndex."	| emph |	emph := self emphasisAt: characterIndex.	^(aBoolean and: [emph notNil])		ifTrue:[			(emph isKindOf: Array)				ifTrue: [emph]				ifFalse: [Array with: emph]]		ifFalse: [emph]</body></methods><methods><class-id>Core.String</class-id> <category>AHSOHC adds</category><body package="Arbor Help System Outline Help Core">asAHSHyperText	"Answer an AHSHelpHyperText whose string is the receiver."	^#{VWHelp.AHSHelpHyperText} value fromString: self</body></methods><methods><class-id>UI.Menu</class-id> <category>AHS Outline Help Core adds</category><body package="Arbor Help System Outline Help Core">aisAddItem: aMenuItem after: previousMenuItem	"Add aMenuItem after previousMenuItem.  If previousMenuItem does not exist or is nil, aMenuItem is added as the first item in the menu.  The new menu item will become part of the last group of menu items."	| index total groupIndex |	index := items indexOf: previousMenuItem ifAbsent: [0].	items := items asOrderedCollection				add: aMenuItem beforeIndex: index + 1;				asArray.	total := 0.	groupIndex := (1 to: groupSizes size)					relate: [:i | (total := total + (groupSizes at: i)) &gt;= index ifTrue: [i] ifFalse: [nil]].	groupSizes at: groupIndex put: ((groupSizes at: groupIndex) + 1).</body><body package="Arbor Help System Outline Help Core">aisAddItem: aMenuItem before: previousMenuItem	"Add aMenuItem before previousMenuItem.  If previousMenuItem does not exist or is nil, aMenuItem is added as the last item in the menu.  The new menu item will become part of the last group of menu items."	| index |	(index := self indexOfMenuItem: previousMenuItem) = 0		ifTrue: [index := self menuItems size + 1].	^self		aisAddItem: aMenuItem		after: (index = 1 ifTrue: [nil] ifFalse: [self menuItemAt: index - 1])</body><body package="Arbor Help System Outline Help Core">aisAddMenu: aMenu withSeparator: aBoolean	"Add the items from aMenu to myself.  If aBoolean is true, place a separator between the current menu contents and the contents of aMenu."	| first |	first := true.	aMenu aisMenuItemGroups do: [:grp || group |		group := grp collect: [:item | item copy].		(first and: [aBoolean not])			ifTrue: [				group do: [:item | self addItem: item].				first := false]			ifFalse: [self addItemGroup: group]].</body><body package="Arbor Help System Outline Help Core">aisAddSeparator	"Insert a separator at the end of the menu."	groupSizes last ~= 0		ifTrue: [groupSizes := groupSizes copyWith: 0].</body><body package="Arbor Help System Outline Help Core">aisAddSeparatorAfter: aMenuItem	"Insert a separator after aMenuItem.  If aMenuItem does not exist in the menu, or if aMenuItem is already the last item in a group then no separator is added to the menu."	| index newSizes range |	(index := self indexOfMenuItem: aMenuItem) = 0 ifTrue: [^self].	newSizes := OrderedCollection new.	range := 0 to: 0.	groupSizes do: [:size |		range := range last + 1 to: range last + size.		((range includes: index) and: [range last ~= index])			ifTrue:[| partial |				partial := (index - range first) + 1.				newSizes addLast: partial.				newSizes addLast: range size - partial]			ifFalse: [newSizes addLast: size]].	groupSizes := newSizes asArray.</body><body package="Arbor Help System Outline Help Core">aisAddSeparatorBefore: aMenuItem	"Insert a separator before aMenuItem.  If aMenuItem does not exist in the menu, or if aMenuItem is already the first item in a group then no separator is added to the menu."	| index |	(index := self indexOfMenuItem: aMenuItem) &lt;= 1		ifTrue: [^self].	^self aisAddSeparatorAfter: (self menuItemAt: index - 1)</body><body package="Arbor Help System Outline Help Core">aisMenuItemGroups	| groups base |	groups := OrderedCollection new.	base := OrderedCollection withAll: self menuItems.	groupSizes do: [:size |		groups addLast: OrderedCollection new.		size timesRepeat: [groups last addLast: base removeFirst]].	^groups</body></methods><methods><class-id>Graphics.CachedImage</class-id> <category>AHSOHC adds</category><body package="Arbor Help System Outline Help Core">ahsAsCachedImage	^self</body><body package="Arbor Help System Outline Help Core">ahsAsImage	^self image</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>AHSOHC adds</category><body package="Arbor Help System Outline Help Core">ahsOpenOutlineEnablement	^#{BinaryObjectStorage} isDefined</body></methods><methods><class-id>UI.ScheduledWindow</class-id> <category>Arbor Core adds</category><body package="Arbor Help System Outline Help Core">aisWidgetWrapper	"Try and find the widget wrapper.  If it can't be found, answer nil."	^nil</body></methods><methods><class-id>Graphics.Image</class-id> <category>AHSOHC adds</category><body package="Arbor Help System Outline Help Core">ahsAsCachedImage	^CachedImage on: self</body><body package="Arbor Help System Outline Help Core">ahsAsImage	^self</body></methods><methods><class-id>UI.UILookPolicy</class-id> <category>Arbor Widgets adds-building</category><body package="Arbor Help System Outline Help Core">arborDragBarView: spec into: builder	| c  unhooked |	c := #{VWHelp.ArborDragBarView} value new.	c etched: spec etched.	c setLineWidth: spec lineWidth.	c setOrientation: spec orientation.	c controller boundedDrag: spec boundedDrag.	unhooked := OrderedCollection new.	(Array		with: spec leftWidgets		with: spec rightWidgets		with: spec aboveWidgets		with: spec belowWidgets)			with: #(left right above below)			do: [:ids :access |				ids do: [:id || sw |					(sw := builder componentAt: id) isNil						ifTrue: [unhooked add: id]						ifFalse: [(c controller perform: access) add: sw]]].	unhooked isEmpty not ifTrue: [| str |		str := String new writeStream.		(spec name isNil or: [spec name isEmpty])			ifTrue: [str nextPutAll: 'An unnamed drag bar']			ifFalse: [str nextPutAll: 'The drag bar '; print: spec name].		str nextPutAll: ' was unable to hook up to the'; cr; nextPutAll: 'following components:'.		unhooked do: [:id | str crtab; print: id].		str cr; cr.		builder isEditing			ifTrue: [str nextPutAll: 'The specified components do not appear to exist.']			ifFalse: [				str					nextPutAll: 'To correct this problem, ensure all component names are'; cr;					nextPutAll: 'correct and place the components BEHIND the drag bar in'; cr;					nextPutAll: 'the UIPainter.'].		Dialog warn: str contents].	c widgetState isEnabled: spec initiallyEnabled.	builder isEditing ifFalse: [c widgetState isVisible: spec initiallyVisible].	builder component: c.	builder wrapWith: BoundingWrapper new.	builder applyLayout: spec layout.	builder wrapWith: (self simpleWidgetWrapperOn: builder spec: spec)</body><body package="Arbor Help System Outline Help Core">arborHierarchicalListView: spec into: builder 	| lv model menu performer dropSourceCallbacks |	model := spec modelInBuilder: builder.	lv := #{VWHelp.ArborHierarchicalSequenceView} value new.	lv model: model listHolder.	spec hasHorizontalScrollBar ifTrue: [lv measureWidth: true].	lv selectionChannel: model selectionIndexHolder.	(menu := spec getMenuIn: builder) == nil 		ifFalse: [lv controller menuHolder: menu].	(performer := spec getPerformerIn: builder) == nil 		ifFalse: [lv controller performer: performer].	self setStyleOf: lv to: spec style.	self		arborSetDispatcherOf: lv		fromSpec: spec		builder: builder.	spec tabable		ifTrue: 			[lv widgetState isTabStop: true.			builder sendKeyboardTo: lv]		ifFalse: 			[lv widgetState canTakeFocus: true.			lv controller keyboardProcessor: builder keyboardProcessor].	lv widgetState isEnabled: spec initiallyEnabled.	builder isEditing ifFalse: [lv widgetState isVisible: spec initiallyVisible].	dropSourceCallbacks := spec dropSourceCallbacksOrNilInBuilder: builder.	dropSourceCallbacks == nil		ifFalse: 			[lv controller dragDropCallbacks: dropSourceCallbacks.			lv controller selectOnDownWithDrag: spec selectOnDownIfDragEnabled].	builder component: lv.	self manufactureGeneralWrapperFor: spec into: builder.	builder applyLayout: spec layout.	builder wrapWith: (self simpleWidgetWrapperOn: builder spec: spec)</body><body package="Arbor Help System Outline Help Core">arborSetDispatcherOf: component fromSpec: spec builder: builder	"This method ensures that the controller will have at least an empty dispatcher with the receiver set to the 'performer' (which is generally the builder's source - the ApplicationModel whose composite view contains 'component')."	builder isEditing ifTrue: [^self].	component controller setDispatcher: (UIDispatcher new receiver: (spec getPerformerIn: builder)).	self setDispatcherOf: component fromSpec: spec builder: builder.</body></methods><methods><class-id>Graphics.OpaqueImage</class-id> <category>AHSOHC adds</category><body package="Arbor Help System Outline Help Core">ahsAsCachedImage	^self class		figure: self figure ahsAsCachedImage		shape: self shape ahsAsCachedImage</body><body package="Arbor Help System Outline Help Core">ahsAsImage	^self figure ahsAsImage</body></methods><methods><class-id>UI.WidgetWrapper</class-id> <category>Arbor Core adds</category><body package="Arbor Help System Outline Help Core">aisWidgetWrapper	"Try and find the widget wrapper.  If it can't be found, answer nil."	^self</body></methods><methods><class-id>Core.Collection</class-id> <category>AHS Outline Help Core adds</category><body package="Arbor Help System Outline Help Core">relate: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument.  Answer the result of evaluating aBlock the first time that evaluation is non-nil.  (That is, find the first non-nil relationship to an element with myself.)"	^self relate: aBlock ifNone: [self notFoundError]</body><body package="Arbor Help System Outline Help Core">relate: aBlock ifNone: exceptionBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  Answer the result of evaluating aBlock the first time that evaluation is non-nil.  (That is, find the first non-nil relationship to an element with myself.)"	self do: [:each | | result | (result := aBlock value: each) notNil ifTrue: [^result]].	^exceptionBlock value</body></methods><methods><class-id>Graphics.VisualPart</class-id> <category>Arbor Core adds</category><body package="Arbor Help System Outline Help Core">aisWidgetWrapper	"Try and find the widget wrapper.  If it can't be found, answer nil."	^self container isNil		ifTrue: [nil]		ifFalse: [self container aisWidgetWrapper]</body></methods><methods><class-id>VWHelp.AHSOutlineViewer class</class-id> <category>interface specs</category><body package="Arbor Help System Outline Help Core">dialogSpec	"UIPainter new openOnClass: self andSelector: #dialogSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Help Outline' 			#min: #(#Point 626 400 ) 			#bounds: #(#Rectangle 91 83 717 483 ) 			#flags: 4 			#menu: #outlinerWindowMenu ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#SubCanvasSpec 					#layout: #(#LayoutFrame 0 0 0 0 0 1 -40 1 ) 					#name: #mainCanvas 					#flags: 0 					#majorKey: #AHSOutlineViewer 					#minorKey: #dialogSubSpec ) 				#(#SubCanvasSpec 					#layout: #(#LayoutFrame 0 0 -40 1 0 1 0 1 ) 					#name: #help 					#flags: 0 					#minorKey: #ahsSpec ) ) ) )</body><body package="Arbor Help System Outline Help Core">dialogSubSpec	"UIPainter new openOnClass: self andSelector: #dialogSubSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Help Outline' 			#min: #(#Point 626 400 ) 			#bounds: #(#Rectangle 399 503 1025 903 ) 			#flags: 4 			#menu: #outlinerWindowMenu ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#SubCanvasSpec 					#layout: #(#LayoutFrame 0 0 0 0 0 1 0 0.33 ) 					#name: #listOutlineBrowser 					#majorKey: #AHSOutlineViewerModel 					#minorKey: #verticalScrollingSpec 					#clientKey: #outliner ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -30 0.5 -26 1 30 0.5 -1 1 ) 					#name: #close 					#model: #accept 					#label: 					#(#UserMessage 						#key: #closeButton 						#defaultString: '(close)' 						#catalogID: #help ) 					#defaultable: true ) 				#(#SubCanvasSpec 					#layout: #(#LayoutFrame 0 0 0 0.33 0 1 -30 1 ) 					#name: #textSubCanvas 					#majorKey: #AHSToolbarHypertextEditor 					#minorKey: #subcanvasSpec 					#clientKey: #toolbarTextEditor ) ) ) )</body><body package="Arbor Help System Outline Help Core">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Help Outline' 			#min: #(#{Core.Point} 189 159 ) 			#bounds: #(#{Graphics.Rectangle} 427 101 955 690 ) 			#flags: 4 			#menu: #outlinerWindowMenu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -45 1 0 1 0 1 ) 					#name: #help 					#flags: 0 					#minorKey: #ahsSpec ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 -45 1 ) 					#name: #mainCanvas 					#flags: 0 					#minorKey: #windowSubSpec ) ) ) )</body><body package="Arbor Help System Outline Help Core">windowSubSpec	"UIPainter new openOnClass: self andSelector: #windowSubSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Help Outline' 			#min: #(#{Core.Point} 189 159 ) 			#bounds: #(#{Graphics.Rectangle} 206 184 819 584 ) 			#flags: 4 			#menu: #outlinerWindowMenu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 0.333333 ) 					#name: #listOutlineBrowser 					#majorKey: #AHSOutlineViewerModel 					#minorKey: #verticalScrollingSpec 					#clientKey: #outliner ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 0 0.333333 0 1 0 1 ) 					#name: #textSubCanvas 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) 						#setSelectionBackgroundColor: #(#ColorValue #white ) ) 					#majorKey: #{AHSToolbarHypertextEditor} 					#minorKey: #subcanvasSpec 					#clientKey: #toolbarTextEditor ) 				#(#{VWHelp.ArborDragBarSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -1 0.333333 0 1 1 0.333333 ) 					#name: #dragBar 					#lineWidth: 0 					#widgetSet1: #(#listOutlineBrowser ) 					#widgetSet2: #(#textSubCanvas ) 					#etched: false ) ) ) )</body></methods><methods><class-id>VWHelp.ArborHierarchicalSequenceView class</class-id> <category>resources</category><body package="Arbor Help System Outline Help Core">contractedMask	"UIMaskEditor new openOnClass: self andSelector: #contractedMask"	&lt;resource: #image&gt;	^Image		extent: 7@13		depth: 1		 palette: CoveragePalette monoMaskPalette		bits: #[128 0 0 0 192 0 0 0 224 0 0 0 240 0 0 0 248 0 0 0 252 0 0 0 254 0 0 0 252 0 0 0 248 0 0 0 240 0 0 0 224 0 0 0 192 0 0 0 128 0 0 0 ]		pad: 32</body><body package="Arbor Help System Outline Help Core">contractedTransitionImage	"UIMaskEditor new openOnClass: self andSelector: #contractedTransitionImage"	&lt;resource: #image&gt;	^Image		extent: 7@13		depth: 1		palette: MappedPalette whiteBlack		bits: #[128 0 0 0 192 0 0 0 224 0 0 0 240 0 0 0 248 0 0 0 252 0 0 0 254 0 0 0 252 0 0 0 248 0 0 0 240 0 0 0 224 0 0 0 192 0 0 0 128 0 0 0 ]		pad: 32</body><body package="Arbor Help System Outline Help Core">expandedMask	"UIMaskEditor new openOnClass: self andSelector: #expandedMask"	&lt;resource: #image&gt;	^Image		extent: 13@7		depth: 1		palette: CoveragePalette monoMaskPalette		bits: #[255 248 0 0 127 240 0 0 63 224 0 0 31 192 0 0 15 128 0 0 7 0 0 0 2 0 0 0 ]		pad: 32</body><body package="Arbor Help System Outline Help Core">expandedTransitionImage	"UIMaskEditor new openOnClass: self andSelector: #expandedTransitionImage"	&lt;resource: #image&gt;	^Image		extent: 13@7		depth: 1		palette: MappedPalette whiteBlack		bits: #[255 248 0 0 127 240 0 0 63 224 0 0 31 192 0 0 15 128 0 0 7 0 0 0 2 0 0 0 ]		pad: 32</body></methods><methods><class-id>VWHelp.ArborTextStyleDialog class</class-id> <category>interface specs</category><body package="Arbor Help System Outline Help Core">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Text Style' 			#min: #(#Point 395 255 ) 			#max: #(#Point 395 255 ) 			#bounds: #(#Rectangle 123 113 518 368 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#TextEditorSpec 					#layout: #(#Rectangle 166 67 370 136 ) 					#name: #sampleText 					#flags: 12 					#model: #sampleText 					#isReadOnly: true ) 				#(#LabelSpec 					#layout: #(#Point 92 12 ) 					#colors: 					#(#LookPreferences 						#setForegroundColor: #(#ColorValue #blue ) ) 					#label: 'Set Style of Text Selection:' ) 				#(#LabelSpec 					#layout: #(#Point 180 36 ) 					#label: 'Sample:' ) 				#(#CheckBoxSpec 					#layout: #(#Point 56 37 ) 					#name: #underline 					#model: #underline 					#label: 'underline' ) 				#(#CheckBoxSpec 					#layout: #(#Point 56 63 ) 					#name: #serif 					#model: #serif 					#label: 'serif' ) 				#(#CheckBoxSpec 					#layout: #(#Point 56 89 ) 					#name: #bold 					#model: #bold 					#label: 'bold' ) 				#(#CheckBoxSpec 					#layout: #(#Point 56 115 ) 					#name: #italic 					#model: #italic 					#label: 'italic' ) 				#(#CheckBoxSpec 					#layout: #(#Point 56 141 ) 					#name: #large 					#model: #large 					#label: 'large' ) 				#(#CheckBoxSpec 					#layout: #(#Point 56 167 ) 					#name: #colorOn 					#model: #colorOn 					#label: 'color' ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 48 194 112 223 ) 					#name: #setColor 					#flags: 40 					#model: #setColor 					#label: 'Set Color' 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 221 194 285 223 ) 					#name: #accept 					#model: #accept 					#label: 'OK' 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 297 194 361 223 ) 					#name: #cancel 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>VWHelp.AHSOutlineTextGraphicMixViewer class</class-id> <category>interface specs</category><body package="Arbor Help System Outline Help Core">windowSubSpec	"UIPainter new openOnClass: self andSelector: #windowSubSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Help Outline' 			#min: #(#Point 189 159 ) 			#bounds: #(#Rectangle 206 440 819 840 ) 			#flags: 4 			#menu: #outlinerWindowMenu 			#isEventDriven: true ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#SubCanvasSpec 					#layout: #(#LayoutFrame 0 0 0 0 0 1 0 0.33 ) 					#name: #listOutlineBrowser 					#majorKey: #AHSOutlineViewerModel 					#minorKey: #verticalScrollingSpec 					#clientKey: #outliner ) 				#(#ArbitraryComponentSpec 					#layout: #(#LayoutFrame 3 0 2 0.33 -3 1 -2 1 ) 					#name: #textGraphicComposite 					#flags: 9 					#component: #textGraphicComposite ) 				#(#SubCanvasSpec 					#layout: #(#LayoutFrame 50 0 50 0.33 -50 1 -50 1 ) 					#name: #textSubCanvas 					#flags: 24 					#majorKey: #AHSToolbarHypertextEditor 					#minorKey: #subcanvasSpec 					#clientKey: #toolbarTextEditor ) 				#(#ArborDragBarSpec 					#layout: #(#LayoutFrame 0 0 -1 0.333333 0 1 1 0.333333 ) 					#name: #dragBar 					#lineWidth: 0 					#widgetSet1: #(#listOutlineBrowser ) 					#widgetSet2: #(#textGraphicComposite ) 					#etched: false ) ) ) )</body></methods><methods><class-id>VWHelp.AHSHyperGraphicViewer class</class-id> <category>interface specs</category><body package="Arbor Help System Outline Help Core">paneSubSpec	"UIPainter new openOnClass: self andSelector: #paneSubSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Unlabeled Canvas' 			#bounds: #(#Rectangle 520 220 1003 453 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#SequenceViewSpec 					#layout: #(#LayoutFrame 4 0 30 0 0 0.438923 -4 1 ) 					#name: #availableGraphics 					#model: #availableGraphics 					#menu: #listMenu ) 				#(#ArbitraryComponentSpec 					#layout: #(#LayoutFrame 0 0.451346 30 0 -3 1 -4 1 ) 					#name: #graphic 					#flags: 11 					#component: #graphic ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 218 0 30 0 0 1 ) 					#label: 					#(#UserMessage 						#key: #graphic1 						#defaultString: '(graphic)' 						#catalogID: #help ) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 4 0 30 0 0 1 ) 					#label: 					#(#UserMessage 						#key: #availableGraphics1 						#defaultString: '(availableGraphics)' 						#catalogID: #help ) ) ) ) )</body><body package="Arbor Help System Outline Help Core">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Graphics Browser' 			#min: #(#Point 475 293 ) 			#bounds: #(#Rectangle 694 173 1169 466 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -104 1 -34 1 -2 1 -6 1 ) 					#name: #ok 					#model: #closeRequest 					#label: 					#(#UserMessage 						#key: #ok1 						#defaultString: '(ok)' 						#catalogID: #help ) 					#isDefault: true 					#defaultable: true ) 				#(#SubCanvasSpec 					#layout: #(#LayoutFrame 0 0 0 0 0 1 -40 1 ) 					#name: #listPanes 					#flags: 0 					#majorKey: #AHSHyperGraphicViewer 					#minorKey: #paneSubSpec ) ) ) )</body></methods><methods><class-id>VWHelp.AHSFullGlossaryViewer class</class-id> <category>interface specs</category><body package="Arbor Help System Outline Help Core">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Glossary' 			#min: #(#Point 471 237 ) 			#bounds: #(#Rectangle 158 478 629 715 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#SequenceViewSpec 					#layout: #(#LayoutFrame 4 0 26 0 -2 0.35 -38 1 ) 					#name: #fullGlossaryList 					#model: #fullGlossaryList ) 				#(#TextEditorSpec 					#layout: #(#LayoutFrame 2 0.35 26 0 -4 1 -38 1 ) 					#name: #fullGlossaryText 					#model: #fullGlossaryText 					#isReadOnly: true ) 				#(#LabelSpec 					#layout: #(#Rectangle 4 3 135 24 ) 					#label: 					#(#UserMessage 						#key: #glossaryWords 						#defaultString: 'Glossary Words' 						#catalogID: #help ) ) 				#(#LabelSpec 					#layout: #(#LayoutFrame 2 0.35 4 0 -4 1 25 0 ) 					#label: 					#(#UserMessage 						#key: #definition 						#defaultString: 'Definition' 						#catalogID: #help ) ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -71 1 -30 1 -4 1 -4 1 ) 					#name: #closeRequest 					#model: #closeRequest 					#label: 					#(#UserMessage 						#key: #OK 						#defaultString: 'OK' 						#catalogID: #help ) 					#isDefault: true 					#defaultable: true ) ) ) )</body></methods><methods><class-id>VWHelp.AHSGraphicScreen class</class-id> <category>interface specs</category><body package="Arbor Help System Outline Help Core">annotatedGraphicSpec	"UIPainter new openOnClass: self andSelector: #annotatedGraphicSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: '' 			#bounds: #(#Rectangle 242 410 662 756 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 0 0.333333 0.5 0.5 ) 					#name: #image 					#label: #image 					#hasCharacterOrientedLabel: false ) 				#(#TextEditorSpec 					#layout: #(#LayoutFrame 0 0 0 0.666666 0 1 0 1 ) 					#name: #captionTextEditor 					#flags: 12 					#isOpaque: true 					#model: #caption 					#isReadOnly: true ) ) ) )</body><body package="Arbor Help System Outline Help Core">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: '' 			#bounds: #(#Rectangle 158 369 578 715 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -30 0.5 -33 1 30 0.5 -6 1 ) 					#name: #doneButton 					#model: #done 					#label: 					#(#UserMessage 						#key: #ok1 						#defaultString: '(ok)' 						#catalogID: #help ) 					#defaultable: true ) 				#(#SubCanvasSpec 					#layout: #(#LayoutFrame 3 0 0 0 -3 1 -40 1 ) 					#name: #annotatedGraphicSubCanvas 					#flags: 0 					#minorKey: #annotatedGraphicSpec ) ) ) )</body></methods><methods><class-id>VWHelp.ArborDragBarController class</class-id> <category>resources</category><body package="Arbor Help System Outline Help Core">horizontalDragImage	"UIMaskEditor new openOnClass: self andSelector: #horizontalDragImage"	&lt;resource: #image&gt;	^(Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 1 0 0 0 3 128 0 0 7 192 0 0 1 0 0 0 1 0 0 0 1 0 0 0 255 254 0 0 255 254 0 0 1 0 0 0 1 0 0 0 1 0 0 0 7 192 0 0 3 128 0 0 1 0 0 0 0 0 0 0])</body><body package="Arbor Help System Outline Help Core">horizontalDragMask	"UIMaskEditor new openOnClass: self andSelector: #horizontalDragMask"	&lt;resource: #image&gt;	^(Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[1 0 0 0 3 128 0 0 7 192 0 0 15 224 0 0 15 224 0 0 3 128 0 0 255 254 0 0 255 254 0 0 255 254 0 0 255 254 0 0 3 128 0 0 15 224 0 0 15 224 0 0 7 192 0 0 3 128 0 0 1 0 0 0])</body><body package="Arbor Help System Outline Help Core">verticalDragImage	"UIMaskEditor new openOnClass: self andSelector: #verticalDragImage"	&lt;resource: #image&gt;	^(Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 1 128 0 0 1 128 0 0 1 128 0 0 1 128 0 0 1 128 0 0 17 136 0 0 49 140 0 0 127 254 0 0 49 140 0 0 17 136 0 0 1 128 0 0 1 128 0 0 1 128 0 0 1 128 0 0 1 128 0 0])</body><body package="Arbor Help System Outline Help Core">verticalDragMask	"UIMaskEditor new openOnClass: self andSelector: #verticalDragMask"	&lt;resource: #image&gt;	^(Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 3 192 0 0 3 192 0 0 3 192 0 0 3 192 0 0 27 216 0 0 59 220 0 0 127 254 0 0 255 255 0 0 127 254 0 0 59 220 0 0 27 216 0 0 3 192 0 0 3 192 0 0 3 192 0 0 3 192 0 0])</body></methods><methods><class-id>VWHelp.AHSOHCPreferencesModel class</class-id> <category>interface specs</category><body package="Arbor Help System Outline Help Core">bookmarkSpec	"UIPainter new openOnClass: self andSelector: #bookmarkSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Unlabeled Canvas' 			#bounds: #(#Rectangle 262 146 524 240 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 3 0 1 0 -3 1 -3 1 ) 					#name: #bookmarkBox 					#label: 'Bookmark File Location' 					#style: #'Arbor-12-Squeeze' ) 				#(#RadioButtonSpec 					#layout: #(#AlignmentOrigin 18 0 4 0.25 0 0.5 ) 					#name: #currentDirectoryRB 					#model: #bookmarkDirectory 					#label: 'Current Directory' 					#style: #'Arbor-12-Squeeze' 					#select: #current ) 				#(#RadioButtonSpec 					#layout: #(#AlignmentOrigin 18 0 3 0.5 0 0.5 ) 					#name: #outlineDirectoryRB 					#model: #bookmarkDirectory 					#label: 'Outline Directory' 					#style: #'Arbor-12-Squeeze' 					#select: #outline ) 				#(#RadioButtonSpec 					#layout: #(#AlignmentOrigin 18 0 3 0.75 0 0.5 ) 					#name: #specifiedDirectoryRB 					#model: #bookmarkDirectory 					#style: #'Arbor-12-Squeeze' 					#select: #specified ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 108 0 -11 0.75 -5 1 15 0.75 ) 					#name: #specifiedDirectory 					#flags: 0 					#model: #specifiedDirectory 					#tabable: false 					#style: #'Arbor-12-Squeeze' 					#isReadOnly: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 37 0 -11 0.75 108 0 15 0.75 ) 					#name: #selectDirectory 					#model: #selectDirectory 					#label: 'Select...' 					#style: #'Arbor-12-Squeeze' ) ) ) )</body><body package="Arbor Help System Outline Help Core">outlinerSpec	"UIPainter new openOnClass: self andSelector: #outlinerSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Unlabeled Canvas' 			#bounds: #(#Rectangle 385 497 680 592 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 3 0 1 0 -3 1 -3 1 ) 					#name: #outlinerBox 					#label: 'Outliner Options' 					#style: #'Arbor-12-Squeeze' ) 				#(#CheckBoxSpec 					#layout: #(#AlignmentOrigin 20 0 33 0 0 0.5 ) 					#name: #expandOutlines 					#model: #expandOutlines 					#label: 'Expand Outlines when Opened' 					#style: #'Arbor-12-Squeeze' ) 				#(#RadioButtonSpec 					#layout: #(#Point 20 46 ) 					#name: #embedGraphicsRB 					#model: #outlineViewerStyle 					#label: 'Embed Graphics with Text' 					#style: #'Arbor-12-Squeeze' 					#select: #embedGraphics ) 				#(#RadioButtonSpec 					#layout: #(#Point 20 66 ) 					#name: #linkGraphicsRB 					#model: #outlineViewerStyle 					#label: 'Show Graphics as Links' 					#style: #'Arbor-12-Squeeze' 					#select: #linkGraphics ) ) ) )</body></methods><methods><class-id>VWHelp.ArborOutlineBrowserModel class</class-id> <category>resources</category><body package="Arbor Help System Outline Help Core">downArrow	"UIMaskEditor new openOnClass: self andSelector: #downArrow"	&lt;resource: #image&gt;	^Image extent: 16@8 depth: 1 palette: CoveragePalette monoMaskPalette bits: #[63 255 0 0 42 1 0 0 21 2 0 0 10 4 0 0 5 8 0 0 2 144 0 0 1 32 0 0 0 192 0 0 ] pad: 32</body><body package="Arbor Help System Outline Help Core">rightArrow	"UIMaskEditor new openOnClass: self andSelector: #rightArrow"	&lt;resource: #image&gt;	^Image extent: 13@14 depth: 1 palette: CoveragePalette monoMaskPalette bits: #[6 0 0 0 5 0 0 0 4 128 0 0 4 64 0 0 4 32 0 0 4 16 0 0 4 8 0 0 4 40 0 0 5 80 0 0 6 160 0 0 5 64 0 0 6 128 0 0 5 0 0 0 6 0 0 0 ] pad: 32</body></methods><methods><class-id>VWHelp.ArborListOutlineBrowserModel class</class-id> <category>interface specs</category><body package="Arbor Help System Outline Help Core">dualScrollingSpec	"UIPainter new openOnClass: self andSelector: #dualScrollingSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Unlabeled Canvas' 			#min: #(#Point 50 50 ) 			#bounds: #(#Rectangle 343 583 659 836 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#ArborHierarchicalSequenceViewSpec 					#layout: #(#LayoutFrame 0 0 0 0 0 1 0 1 ) 					#name: #list 					#flags: 15 					#model: #list 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#doubleClickSelector: #doubleClickOccurred ) 					#menu: #menu 					#useModifierKeys: true 					#selectionType: #highlight ) ) ) )</body><body package="Arbor Help System Outline Help Core">verticalScrollingSpec	"UIPainter new openOnClass: self andSelector: #verticalScrollingSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Unlabeled Canvas' 			#min: #(#Point 50 50 ) 			#bounds: #(#Rectangle 343 583 659 836 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#ArborHierarchicalSequenceViewSpec 					#layout: #(#LayoutFrame 0 0 0 0 0 1 0 1 ) 					#name: #list 					#model: #list 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#doubleClickSelector: #doubleClickOccurred ) 					#menu: #menu 					#useModifierKeys: true 					#selectionType: #highlight ) ) ) )</body></methods><methods><class-id>VWHelp.AHSOutlineViewerModel class</class-id> <category>resources</category><body package="Arbor Help System Outline Help Core">closedFolder	"UIMaskEditor new openOnClass: self andSelector: #closedFolder"	&lt;resource: #image&gt;	^(Image extent: 15@13 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[62 0 0 0 127 0 0 0 255 252 0 0 128 6 0 0 191 254 0 0 191 254 0 0 191 254 0 0 191 254 0 0 191 254 0 0 191 254 0 0 191 254 0 0 255 254 0 0 127 254 0 0])</body><body package="Arbor Help System Outline Help Core">openFolder	"UIMaskEditor new openOnClass: self andSelector: #openFolder"	&lt;resource: #image&gt;	^(Image extent: 16@13 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[31 0 0 0 32 128 0 0 95 126 0 0 95 131 0 0 95 255 0 0 255 255 0 0 128 31 0 0 191 255 0 0 95 255 0 0 95 255 0 0 47 255 0 0 63 255 0 0 31 255 0 0])</body></methods><methods><class-id>VWHelp.ArborIconSet class</class-id> <category>resources</category><body package="Arbor Help System Outline Help Core">closedBookImage	"UIMaskEditor new openOnClass: self andSelector: #closedBookImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@15 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 5) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 6167 scaledGreen: 6167 scaledBlue: 6167); at: 3 put: (ColorValue scaledRed: 4112 scaledGreen: 4112 scaledBlue: 4112); at: 4 put: ColorValue white; at: 5 put: (ColorValue scaledRed: 4112 scaledGreen: 0 scaledBlue: 4112); yourself)) usingBits: #[51 51 51 48 3 51 51 51 51 51 48 4 64 51 51 51 51 48 4 68 68 3 51 51 48 4 68 68 68 64 51 51 1 68 68 68 68 68 3 51 4 20 68 68 68 68 64 51 4 65 68 68 68 68 68 3 4 68 20 68 68 68 68 0 4 68 65 68 68 68 0 35 48 68 68 20 68 0 35 35 51 4 68 65 0 33 49 0 51 48 68 64 35 19 16 3 51 51 4 64 49 48 3 51 51 51 48 64 32 3 51 51 51 51 51 0 3 51 51 51])</body><body package="Arbor Help System Outline Help Core">closedBookMask	"UIMaskEditor new openOnClass: self andSelector: #closedBookMask"	&lt;resource: #image&gt;	^(Image extent: 16@15 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[1 128 0 0 7 192 0 0 31 224 0 0 127 240 0 0 255 248 0 0 255 252 0 0 255 254 0 0 255 255 0 0 255 254 0 0 127 254 0 0 63 255 0 0 31 254 0 0 15 248 0 0 7 224 0 0 3 128 0 0])</body><body package="Arbor Help System Outline Help Core">contractedImage	"UIMaskEditor new openOnClass: self andSelector: #contractedImage"	&lt;resource: #image&gt;	^(Image extent: 13@13 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 3) at: 1 put: ColorValue black; at: 2 put: ColorValue blue; at: 3 put: ColorValue white; yourself)) usingBits: #[168 170 170 128 168 42 170 128 168 74 170 128 168 146 170 128 168 100 170 128 168 153 42 128 168 102 74 128 168 153 42 128 168 100 170 128 168 146 170 128 168 74 170 128 168 42 170 128 168 170 170 128])</body><body package="Arbor Help System Outline Help Core">contractedMask	"UIMaskEditor new openOnClass: self andSelector: #contractedMask"	&lt;resource: #image&gt;	^(Image extent: 13@13 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[16 0 0 0 24 0 0 0 28 0 0 0 30 0 0 0 31 0 0 0 31 128 0 0 31 192 0 0 31 128 0 0 31 0 0 0 30 0 0 0 28 0 0 0 24 0 0 0 16 0 0 0])</body><body package="Arbor Help System Outline Help Core">contractedTransitionImage	"UIMaskEditor new openOnClass: self andSelector: #contractedTransitionImage"	&lt;resource: #image&gt;	^(Image extent: 13@13 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 3) at: 1 put: ColorValue black; at: 2 put: ColorValue blue; at: 3 put: ColorValue white; yourself)) usingBits: #[168 170 170 128 168 42 170 128 168 74 170 128 168 18 170 128 168 68 170 128 168 17 42 128 168 68 74 128 168 17 42 128 168 68 170 128 168 18 170 128 168 74 170 128 168 42 170 128 168 170 170 128])</body><body package="Arbor Help System Outline Help Core">emptyImage	"UIMaskEditor new openOnClass: self andSelector: #emptyImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 13@1 depth: 1 bitsPerPixel: 1 palette: (MappedPalette withColors: ((Array new: 2) at: 1 put: ColorValue black; at: 2 put: ColorValue red; yourself)) usingBits: #[85 80 0 0])</body><body package="Arbor Help System Outline Help Core">emptyMask	"UIMaskEditor new openOnClass: self andSelector: #emptyMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 13@1 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0])</body><body package="Arbor Help System Outline Help Core">expandedImage	&lt;resource: #image&gt;	| palette |	palette := MappedPalette with: ColorValue white with: ColorValue blue with: ColorValue black.	^Image		extent: 13 @ 7		depth: 2		palette: palette		bits: #[170 170 170 128 36 68 70 0 9 17 24 0 2 68 96 0 0 145 128 0 0 38 0 0 0 8 0 0 ]</body><body package="Arbor Help System Outline Help Core">expandedMask	"UIMaskEditor new openOnClass: self andSelector: #expandedMask"	&lt;resource: #image&gt;	^Image		extent: 13@7		depth: 1		palette: CoveragePalette monoMaskPalette		bits: #[255 248 0 0 127 240 0 0 63 224 0 0 31 192 0 0 15 128 0 0 7 0 0 0 2 0 0 0 ]		pad: 32</body><body package="Arbor Help System Outline Help Core">expandedTransitionImage	"UIMaskEditor new openOnClass: self andSelector: #expandedTransitionImage"	&lt;resource: #image&gt;	^(Image extent: 13@7 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 3) at: 1 put: ColorValue black; at: 2 put: ColorValue blue; at: 3 put: ColorValue white; yourself)) usingBits: #[0 0 0 0 132 68 68 128 161 17 18 128 168 68 74 128 170 17 42 128 170 132 170 128 170 162 170 128])</body><body package="Arbor Help System Outline Help Core">halfwayBookImage	"UIMaskEditor new openOnClass: self andSelector: #halfwayBookImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@15 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 6) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 6167 scaledGreen: 6167 scaledBlue: 6167); at: 3 put: ColorValue white; at: 4 put: (ColorValue scaledRed: 4112 scaledGreen: 4112 scaledBlue: 4112); at: 5 put: ColorValue yellow; at: 6 put: (ColorValue scaledRed: 4112 scaledGreen: 0 scaledBlue: 4112); yourself)) usingBits: #[34 34 34 34 0 2 34 34 34 34 34 32 85 2 34 34 34 34 32 5 85 2 34 34 34 34 5 85 85 0 34 34 34 32 85 85 85 2 2 34 34 5 85 85 85 2 80 34 34 5 85 85 85 2 80 34 34 5 85 85 80 50 80 34 34 5 85 85 4 50 80 34 34 5 85 80 34 50 80 34 34 5 85 2 36 50 80 34 34 5 80 36 0 2 80 34 34 1 0 3 17 34 80 34 34 1 5 85 85 85 80 34 34 32 0 0 0 0 0 34])</body><body package="Arbor Help System Outline Help Core">halfwayBookMask	"UIMaskEditor new openOnClass: self andSelector: #halfwayBookMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@15 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 224 0 0 1 224 0 0 7 224 0 0 15 240 0 0 31 248 0 0 63 252 0 0 63 252 0 0 63 252 0 0 63 252 0 0 63 252 0 0 63 252 0 0 63 252 0 0 63 252 0 0 63 252 0 0 31 252 0 0])</body><body package="Arbor Help System Outline Help Core">openBookImage	"UIMaskEditor new openOnClass: self andSelector: #openBookImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 6) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 6167 scaledGreen: 6167 scaledBlue: 6167); at: 3 put: ColorValue white; at: 4 put: (ColorValue scaledRed: 4112 scaledGreen: 4112 scaledBlue: 4112); at: 5 put: ColorValue yellow; at: 6 put: (ColorValue scaledRed: 4112 scaledGreen: 0 scaledBlue: 4112); yourself)) usingBits: #[34 50 34 34 34 34 34 34 35 19 34 34 34 34 34 34 5 33 50 34 35 51 34 34 5 34 50 35 50 35 34 34 5 34 19 50 34 67 0 34 5 34 32 18 66 35 37 2 5 34 32 18 34 67 37 2 5 34 32 18 66 35 37 2 5 34 32 18 34 67 37 2 5 34 32 18 66 35 37 2 5 82 32 18 34 67 37 2 32 85 32 18 48 0 37 2 34 5 32 0 49 18 37 2 34 5 0 85 85 85 85 2 34 5 85 0 0 0 0 2 34 32 0 34 34 34 34 34])</body><body package="Arbor Help System Outline Help Core">openBookMask	"UIMaskEditor new openOnClass: self andSelector: #openBookMask"	&lt;resource: #image&gt;	^(Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[32 0 0 0 112 0 0 0 248 112 0 0 249 240 0 0 255 252 0 0 255 254 0 0 255 254 0 0 255 254 0 0 255 254 0 0 255 254 0 0 255 254 0 0 127 254 0 0 63 254 0 0 63 254 0 0 63 254 0 0 28 0 0 0])</body><body package="Arbor Help System Outline Help Core">pageImage	"UIMaskEditor new openOnClass: self andSelector: #pageImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@15 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 6) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 6167 scaledGreen: 6167 scaledBlue: 6167); at: 3 put: ColorValue white; at: 4 put: (ColorValue scaledRed: 4112 scaledGreen: 4112 scaledBlue: 4112); at: 5 put: ColorValue yellow; at: 6 put: ColorValue blue; yourself)) usingBits: #[34 51 51 51 51 51 34 34 34 50 34 66 34 67 50 34 34 50 66 34 66 32 0 34 34 50 34 66 34 66 16 34 34 50 85 85 85 82 16 34 34 50 34 66 34 66 16 34 34 50 85 85 85 82 16 34 34 50 34 66 34 66 16 34 34 50 85 85 85 82 16 34 34 50 34 66 34 66 16 34 34 50 85 85 85 82 16 34 34 50 34 66 34 66 16 34 34 50 85 85 85 82 16 34 34 49 17 17 17 17 16 34 34 0 0 0 0 0 0 34])</body><body package="Arbor Help System Outline Help Core">pageMask	"UIMaskEditor new openOnClass: self andSelector: #pageMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@15 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[63 240 0 0 63 248 0 0 63 252 0 0 63 252 0 0 63 252 0 0 63 252 0 0 63 252 0 0 63 252 0 0 63 252 0 0 63 252 0 0 63 252 0 0 63 252 0 0 63 252 0 0 63 252 0 0 63 252 0 0])</body></methods><methods><class-id>VWHelp.AHSGlossaryViewer class</class-id> <category>interface specs</category><body package="Arbor Help System Outline Help Core">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Glossary Entry' 			#min: #(#Point 413 181 ) 			#max: #(#Point 640 480 ) 			#bounds: #(#Rectangle 504 462 917 661 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#TextEditorSpec 					#layout: #(#LayoutFrame 3 0 26 0 -3 1 -44 1 ) 					#name: #text 					#isOpaque: true 					#model: #text 					#isReadOnly: true ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 2 0 2 0 -150 1 24 0 ) 					#name: #selectedWord 					#flags: 0 					#model: #selectedWord 					#isReadOnly: true 					#type: #text ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -33 0.5 -37 1 47 0.5 -7 1 ) 					#model: #closeRequest 					#label: 					#(#UserMessage 						#key: #OK 						#defaultString: 'OK' 						#catalogID: #help ) 					#isDefault: true 					#defaultable: true ) ) ) )</body></methods><methods><class-id>VWHelp.AHSToolbarTextEditor class</class-id> <category>resources</category><body package="Arbor Help System Outline Help Core">boldImage	"UIMaskEditor new openOnClass: self andSelector: #boldImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 10@12 depth: 4 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 14) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 6007 scaledGreen: 6007 scaledBlue: 6007); at: 3 put: (ColorValue scaledRed: 2184 scaledGreen: 2184 scaledBlue: 2184); at: 4 put: ColorValue white; at: 5 put: (ColorValue scaledRed: 5139 scaledGreen: 5139 scaledBlue: 5268); at: 6 put: (ColorValue scaledRed: 4369 scaledGreen: 4369 scaledBlue: 4369); at: 7 put: (ColorValue scaledRed: 546 scaledGreen: 546 scaledBlue: 546); at: 8 put: (ColorValue scaledRed: 2730 scaledGreen: 2730 scaledBlue: 2730); at: 9 put: (ColorValue scaledRed: 4915 scaledGreen: 4915 scaledBlue: 4915); at: 10 put: (ColorValue scaledRed: 1092 scaledGreen: 1092 scaledBlue: 1092); at: 11 put: (ColorValue scaledRed: 3276 scaledGreen: 3276 scaledBlue: 3276); at: 12 put: ColorValue lightGray; at: 13 put: (ColorValue scaledRed: 1638 scaledGreen: 1638 scaledBlue: 1638); at: 14 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); yourself)) usingBits: #[76 204 204 123 51 0 0 0 134 0 0 6 67 0 0 0 140 106 61 0 115 0 0 0 128 10 51 0 35 0 0 0 128 2 82 0 83 0 0 0 128 0 0 109 51 0 0 0 128 12 169 0 211 0 0 0 128 10 51 32 1 0 0 0 128 10 51 112 8 0 0 0 128 2 138 0 97 0 0 0 128 0 0 6 131 0 0 0 186 170 170 209 51 0 0 0])</body><body package="Arbor Help System Outline Help Core">boldInactiveMask	"UIMaskEditor new openOnClass: self andSelector: #boldInactiveMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 10@12 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[126 0 0 0 127 0 0 0 115 0 0 0 115 0 0 0 127 0 0 0 126 0 0 0 127 0 0 0 115 128 0 0 115 128 0 0 119 128 0 0 127 0 0 0 126 0 0 0])</body><body package="Arbor Help System Outline Help Core">boldMask	"UIMaskEditor new openOnClass: self andSelector: #boldMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 10@12 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 0 0 0 255 128 0 0 247 128 0 0 243 128 0 0 255 128 0 0 255 0 0 0 255 128 0 0 243 192 0 0 243 192 0 0 255 192 0 0 255 128 0 0 255 0 0 0])</body><body package="Arbor Help System Outline Help Core">colorImage	"UIMaskEditor new openOnClass: self andSelector: #colorImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 13@16 depth: 4 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 10) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 0 scaledGreen: 4915 scaledBlue: 6135); at: 3 put: (ColorValue scaledRed: 0 scaledGreen: 1638 scaledBlue: 4112); at: 4 put: (ColorValue scaledRed: 0 scaledGreen: 1638 scaledBlue: 2056); at: 5 put: (ColorValue scaledRed: 546 scaledGreen: 546 scaledBlue: 546); at: 6 put: (ColorValue scaledRed: 6553 scaledGreen: 6553 scaledBlue: 6553); at: 7 put: ColorValue white; at: 8 put: (ColorValue scaledRed: 1638 scaledGreen: 4915 scaledBlue: 6135); at: 9 put: (ColorValue scaledRed: 0 scaledGreen: 3276 scaledBlue: 4112); at: 10 put: (ColorValue scaledRed: 1092 scaledGreen: 1092 scaledBlue: 1092); yourself)) usingBits: #[102 102 102 102 96 85 0 0 102 102 102 102 96 85 0 0 102 102 102 102 5 80 96 0 102 102 102 102 5 80 96 0 102 102 102 96 85 6 96 0 102 102 102 96 85 6 96 0 102 102 102 5 80 102 96 0 102 102 102 5 80 102 96 0 102 102 96 64 6 102 96 0 102 102 1 116 6 102 96 0 102 96 17 112 6 102 96 0 102 104 23 48 6 102 96 0 102 7 19 0 102 102 96 0 102 151 32 6 102 102 96 0 96 121 0 102 102 102 96 0 0 144 102 102 102 102 96 0])</body><body package="Arbor Help System Outline Help Core">colorMask	"UIMaskEditor new openOnClass: self andSelector: #colorMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 13@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 120 0 0 0 120 0 0 0 240 0 0 0 240 0 0 1 224 0 0 1 224 0 0 3 192 0 0 3 192 0 0 7 128 0 0 15 128 0 0 31 128 0 0 31 128 0 0 63 0 0 0 62 0 0 0 124 0 0 0 240 0 0 0])</body><body package="Arbor Help System Outline Help Core">copyImage	"UIMaskEditor new openOnClass: self andSelector: #copyImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@13 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[3 254 0 0 121 254 0 0 122 254 0 0 72 14 0 0 125 230 0 0 65 234 0 0 125 32 0 0 65 252 0 0 125 4 0 0 1 252 0 0 253 4 0 0 253 252 0 0 252 0 0 0])</body><body package="Arbor Help System Outline Help Core">copyMask	"UIMaskEditor new openOnClass: self andSelector: #copyMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@13 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[252 0 0 0 254 0 0 0 255 0 0 0 255 240 0 0 255 248 0 0 255 252 0 0 255 254 0 0 255 254 0 0 255 254 0 0 255 254 0 0 3 254 0 0 3 254 0 0 3 254 0 0])</body><body package="Arbor Help System Outline Help Core">cutImage	"UIMaskEditor new openOnClass: self andSelector: #cutImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@16 depth: 4 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 10) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 6007 scaledGreen: 6007 scaledBlue: 6007); at: 3 put: (ColorValue scaledRed: 6167 scaledGreen: 6167 scaledBlue: 6167); at: 4 put: (ColorValue scaledRed: 4915 scaledGreen: 4915 scaledBlue: 4915); at: 5 put: (ColorValue scaledRed: 2184 scaledGreen: 2184 scaledBlue: 2184); at: 6 put: ColorValue white; at: 7 put: (ColorValue scaledRed: 546 scaledGreen: 546 scaledBlue: 546); at: 8 put: (ColorValue scaledRed: 1638 scaledGreen: 1638 scaledBlue: 2056); at: 9 put: ColorValue lightGray; at: 10 put: (ColorValue scaledRed: 7099 scaledGreen: 7099 scaledBlue: 7099); yourself)) usingBits: #[85 85 85 80 117 85 85 80 85 85 85 80 80 85 85 80 85 85 85 144 80 149 85 80 80 5 85 80 80 149 85 80 8 48 149 144 144 85 85 80 5 88 1 148 9 85 85 80 80 0 0 0 85 85 85 80 85 17 85 0 2 85 85 80 85 85 85 70 64 117 85 80 85 85 85 64 19 64 85 80 85 85 85 48 85 23 5 80 85 85 85 48 85 85 128 16 85 85 85 87 85 85 87 128 85 85 85 80 37 85 85 80 85 85 85 80 21 85 85 80 85 85 85 82 85 85 85 80])</body><body package="Arbor Help System Outline Help Core">cutMask	"UIMaskEditor new openOnClass: self andSelector: #cutMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[1 128 0 0 1 64 0 0 3 96 0 0 97 96 0 0 251 192 0 0 159 192 0 0 127 0 0 0 51 192 0 0 3 224 0 0 3 240 0 0 3 56 0 0 3 14 0 0 1 6 0 0 1 128 0 0 1 128 0 0 1 0 0 0])</body><body package="Arbor Help System Outline Help Core">findImage	"UIMaskEditor new openOnClass: self andSelector: #findImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@15 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 3) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 6167 scaledGreen: 6167 scaledBlue: 6167); at: 3 put: ColorValue white; yourself)) usingBits: #[170 170 170 168 168 10 128 168 168 138 136 168 168 10 128 168 160 2 0 40 162 2 32 40 128 0 0 8 8 4 32 0 8 4 32 0 8 0 32 0 0 2 0 0 32 42 162 0 32 42 162 0 0 42 160 0 170 170 170 168])</body><body package="Arbor Help System Outline Help Core">findMask	"UIMaskEditor new openOnClass: self andSelector: #findMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@15 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 28 112 0 0 28 112 0 0 28 112 0 0 62 248 0 0 62 248 0 0 127 252 0 0 255 254 0 0 255 254 0 0 255 254 0 0 254 254 0 0 248 62 0 0 248 62 0 0 248 62 0 0 0 0 0 0])</body><body package="Arbor Help System Outline Help Core">indentImage	"UIMaskEditor new openOnClass: self andSelector: #indentImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@15 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 3) at: 1 put: ColorValue black; at: 2 put: ColorValue white; at: 3 put: (ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4112); yourself)) usingBits: #[85 84 85 84 85 85 85 84 80 4 0 0 85 85 85 84 89 84 0 0 90 84 0 0 170 149 85 84 90 84 0 20 89 84 0 20 85 85 85 84 80 4 0 0 85 85 85 84 80 4 21 84 85 85 85 84 85 84 85 84])</body><body package="Arbor Help System Outline Help Core">indentMask	"UIMaskEditor new openOnClass: self andSelector: #indentMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@15 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[1 0 0 0 0 0 0 0 61 254 0 0 0 0 0 0 33 254 0 0 49 254 0 0 248 0 0 0 49 248 0 0 33 248 0 0 0 0 0 0 61 254 0 0 0 0 0 0 61 128 0 0 0 0 0 0 1 0 0 0])</body><body package="Arbor Help System Outline Help Core">italicImage	"UIMaskEditor new openOnClass: self andSelector: #italicImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 6@14 depth: 4 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 13) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 6007 scaledGreen: 6007 scaledBlue: 6007); at: 3 put: (ColorValue scaledRed: 2184 scaledGreen: 2184 scaledBlue: 2184); at: 4 put: ColorValue white; at: 5 put: (ColorValue scaledRed: 5139 scaledGreen: 5139 scaledBlue: 5268); at: 6 put: (ColorValue scaledRed: 4369 scaledGreen: 4369 scaledBlue: 4369); at: 7 put: (ColorValue scaledRed: 546 scaledGreen: 546 scaledBlue: 546); at: 8 put: (ColorValue scaledRed: 2730 scaledGreen: 2730 scaledBlue: 2730); at: 9 put: (ColorValue scaledRed: 4915 scaledGreen: 4915 scaledBlue: 4915); at: 10 put: (ColorValue scaledRed: 1092 scaledGreen: 1092 scaledBlue: 1092); at: 11 put: (ColorValue scaledRed: 3276 scaledGreen: 3276 scaledBlue: 3276); at: 12 put: ColorValue lightGray; at: 13 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); yourself)) usingBits: #[51 51 65 0 51 60 6 0 51 50 2 0 51 51 131 0 51 51 51 0 51 28 83 0 58 0 99 0 114 96 115 0 56 0 179 0 50 2 51 0 16 8 51 0 192 104 35 0 144 102 67 0 150 161 51 0])</body><body package="Arbor Help System Outline Help Core">italicMask	"UIMaskEditor new openOnClass: self andSelector: #italicMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 6@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[12 0 0 0 28 0 0 0 28 0 0 0 8 0 0 0 0 0 0 0 56 0 0 0 120 0 0 0 248 0 0 0 120 0 0 0 112 0 0 0 240 0 0 0 248 0 0 0 248 0 0 0 240 0 0 0])</body><body package="Arbor Help System Outline Help Core">largeImage	"UIMaskEditor new openOnClass: self andSelector: #largeImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 14@16 depth: 4 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 12) at: 1 put: (ColorValue scaledRed: 4369 scaledGreen: 4369 scaledBlue: 4369); at: 2 put: (ColorValue scaledRed: 1638 scaledGreen: 1638 scaledBlue: 1638); at: 3 put: (ColorValue scaledRed: 6007 scaledGreen: 6007 scaledBlue: 6007); at: 4 put: ColorValue black; at: 5 put: (ColorValue scaledRed: 3276 scaledGreen: 3276 scaledBlue: 3276); at: 6 put: (ColorValue scaledRed: 546 scaledGreen: 546 scaledBlue: 546); at: 7 put: (ColorValue scaledRed: 2184 scaledGreen: 2184 scaledBlue: 2184); at: 8 put: ColorValue white; at: 9 put: (ColorValue scaledRed: 5139 scaledGreen: 5139 scaledBlue: 5268); at: 10 put: (ColorValue scaledRed: 4915 scaledGreen: 4915 scaledBlue: 4915); at: 11 put: ColorValue lightGray; at: 12 put: (ColorValue scaledRed: 2730 scaledGreen: 2730 scaledBlue: 2730); yourself)) usingBits: #[129 17 17 16 119 119 119 0 114 99 53 167 119 119 119 0 119 147 52 119 119 119 119 0 119 147 52 119 119 119 119 0 119 147 52 119 119 119 119 0 119 147 52 119 119 119 119 0 119 147 52 119 119 119 119 0 119 147 52 119 119 119 119 0 119 147 52 119 119 119 119 0 119 147 52 119 119 119 119 0 119 147 52 119 119 119 119 0 119 147 52 119 119 119 119 0 119 147 52 119 119 119 152 0 119 147 59 119 119 119 90 0 119 67 53 167 119 166 87 0 145 51 51 51 51 51 183 0])</body><body package="Arbor Help System Outline Help Core">largeMask	"UIMaskEditor new openOnClass: self andSelector: #largeMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 14@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 0 0 0 126 0 0 0 60 0 0 0 60 0 0 0 60 0 0 0 60 0 0 0 60 0 0 0 60 0 0 0 60 0 0 0 60 0 0 0 60 0 0 0 60 0 0 0 60 12 0 0 60 12 0 0 62 56 0 0 255 248 0 0])</body><body package="Arbor Help System Outline Help Core">outdentImage	"UIMaskEditor new openOnClass: self andSelector: #outdentImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@15 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 3) at: 1 put: ColorValue black; at: 2 put: ColorValue white; at: 3 put: (ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4112); yourself)) usingBits: #[85 84 85 84 85 85 85 84 80 4 0 0 85 85 85 84 89 84 0 0 105 84 0 0 170 149 85 84 105 84 0 20 89 84 0 20 85 85 85 84 80 4 0 0 85 85 85 84 80 4 21 84 85 85 85 84 85 84 85 84])</body><body package="Arbor Help System Outline Help Core">outdentMask	"UIMaskEditor new openOnClass: self andSelector: #outdentMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@15 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[1 0 0 0 0 0 0 0 61 254 0 0 0 0 0 0 33 254 0 0 97 254 0 0 248 0 0 0 97 248 0 0 33 248 0 0 0 0 0 0 61 254 0 0 0 0 0 0 61 128 0 0 0 0 0 0 1 0 0 0])</body><body package="Arbor Help System Outline Help Core">pasteImage	"UIMaskEditor new openOnClass: self andSelector: #pasteImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@14 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 4) at: 1 put: ColorValue black; at: 2 put: ColorValue white; at: 3 put: (ColorValue scaledRed: 6553 scaledGreen: 6553 scaledBlue: 6553); at: 4 put: (ColorValue scaledRed: 4369 scaledGreen: 4369 scaledBlue: 4369); yourself)) usingBits: #[85 64 21 85 64 5 0 21 42 16 74 133 44 85 83 133 44 0 3 133 42 170 170 133 42 160 0 5 42 161 85 5 42 161 85 17 42 161 1 0 42 161 85 84 42 161 0 4 64 1 85 84 85 80 0 0])</body><body package="Arbor Help System Outline Help Core">pasteMask	"UIMaskEditor new openOnClass: self andSelector: #pasteMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[7 128 0 0 127 248 0 0 255 252 0 0 255 252 0 0 255 252 0 0 255 252 0 0 255 252 0 0 255 252 0 0 255 254 0 0 255 255 0 0 255 255 0 0 255 255 0 0 127 255 0 0 3 255 0 0])</body><body package="Arbor Help System Outline Help Core">serifImage	"UIMaskEditor new openOnClass: self andSelector: #serifImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 14@13 depth: 4 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 15) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 6007 scaledGreen: 6007 scaledBlue: 6007); at: 3 put: (ColorValue scaledRed: 2184 scaledGreen: 2184 scaledBlue: 2184); at: 4 put: ColorValue white; at: 5 put: (ColorValue scaledRed: 5139 scaledGreen: 5139 scaledBlue: 5268); at: 6 put: (ColorValue scaledRed: 4369 scaledGreen: 4369 scaledBlue: 4369); at: 7 put: (ColorValue scaledRed: 546 scaledGreen: 546 scaledBlue: 546); at: 8 put: (ColorValue scaledRed: 2730 scaledGreen: 2730 scaledBlue: 2730); at: 9 put: (ColorValue scaledRed: 4915 scaledGreen: 4915 scaledBlue: 4915); at: 10 put: (ColorValue scaledRed: 1092 scaledGreen: 1092 scaledBlue: 1092); at: 11 put: (ColorValue scaledRed: 7099 scaledGreen: 7099 scaledBlue: 7099); at: 12 put: (ColorValue scaledRed: 3276 scaledGreen: 3276 scaledBlue: 3276); at: 13 put: ColorValue lightGray; at: 14 put: (ColorValue scaledRed: 1638 scaledGreen: 1638 scaledBlue: 1638); at: 15 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); yourself)) usingBits: #[51 51 51 51 51 52 19 0 51 135 215 195 49 38 108 0 53 100 25 227 50 179 227 0 57 211 56 179 16 179 51 0 54 108 51 51 224 40 51 0 50 6 227 60 32 219 51 0 49 32 13 19 128 179 51 0 51 62 96 115 128 179 51 0 51 51 64 99 128 179 51 0 139 51 61 99 128 179 51 0 198 67 54 115 128 179 51 0 57 103 34 19 208 110 51 0 51 24 170 51 51 51 51 0])</body><body package="Arbor Help System Outline Help Core">serifMask	"UIMaskEditor new openOnClass: self andSelector: #serifMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 14@13 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 24 0 0 62 124 0 0 126 104 0 0 102 224 0 0 112 240 0 0 121 240 0 0 126 224 0 0 30 224 0 0 14 224 0 0 198 224 0 0 230 224 0 0 126 240 0 0 60 0 0 0])</body><body package="Arbor Help System Outline Help Core">spellCheckImage	"UIMaskEditor new openOnClass: self andSelector: #spellCheckImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 14@14 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 3) at: 1 put: ColorValue black; at: 2 put: ColorValue white; at: 3 put: (ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4112); yourself)) usingBits: #[69 5 65 80 17 17 21 80 1 5 21 96 17 17 21 144 17 5 66 80 85 85 89 80 85 85 101 80 85 85 149 80 101 86 85 80 169 90 85 80 106 105 85 80 90 165 85 80 86 165 85 80 85 149 85 80])</body><body package="Arbor Help System Outline Help Core">spellCheckInactiveMask	"UIMaskEditor new openOnClass: self andSelector: #spellCheckInactiveMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 14@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[76 96 0 0 170 128 0 0 236 132 0 0 170 136 0 0 172 112 0 0 0 32 0 0 0 64 0 0 0 128 0 0 65 0 0 0 227 0 0 0 118 0 0 0 60 0 0 0 28 0 0 0 8 0 0 0])</body><body package="Arbor Help System Outline Help Core">spellCheckMask	"UIMaskEditor new openOnClass: self andSelector: #spellCheckMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 14@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[76 96 0 0 170 128 0 0 236 132 0 0 170 140 0 0 172 120 0 0 0 48 0 0 0 96 0 0 0 192 0 0 97 128 0 0 243 128 0 0 127 0 0 0 62 0 0 0 30 0 0 0 12 0 0 0])</body><body package="Arbor Help System Outline Help Core">underlineImage	"UIMaskEditor new openOnClass: self andSelector: #underlineImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 13@14 depth: 4 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 13) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 6007 scaledGreen: 6007 scaledBlue: 6007); at: 3 put: (ColorValue scaledRed: 2184 scaledGreen: 2184 scaledBlue: 2184); at: 4 put: ColorValue white; at: 5 put: (ColorValue scaledRed: 5139 scaledGreen: 5139 scaledBlue: 5268); at: 6 put: (ColorValue scaledRed: 546 scaledGreen: 546 scaledBlue: 546); at: 7 put: (ColorValue scaledRed: 2730 scaledGreen: 2730 scaledBlue: 2730); at: 8 put: (ColorValue scaledRed: 4915 scaledGreen: 4915 scaledBlue: 4915); at: 9 put: (ColorValue scaledRed: 1092 scaledGreen: 1092 scaledBlue: 1092); at: 10 put: (ColorValue scaledRed: 3276 scaledGreen: 3276 scaledBlue: 3276); at: 11 put: ColorValue lightGray; at: 12 put: (ColorValue scaledRed: 1638 scaledGreen: 1638 scaledBlue: 1638); at: 13 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); yourself)) usingBits: #[54 188 51 51 187 67 48 0 59 9 51 51 0 115 48 0 59 9 51 51 0 115 48 0 59 9 51 51 0 115 48 0 59 9 51 51 0 115 48 0 59 9 51 51 0 115 48 0 59 9 51 51 0 115 48 0 59 9 51 51 0 115 48 0 54 11 51 55 0 19 48 0 60 0 195 168 5 51 48 0 51 32 0 0 87 51 48 0 51 55 155 44 19 51 48 0 71 119 119 119 119 119 160 0 201 153 153 153 153 153 112 0])</body><body package="Arbor Help System Outline Help Core">underlineMask	"UIMaskEditor new openOnClass: self andSelector: #underlineMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 13@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[112 224 0 0 112 224 0 0 112 224 0 0 112 224 0 0 112 224 0 0 112 224 0 0 112 224 0 0 112 224 0 0 113 224 0 0 123 192 0 0 63 192 0 0 31 128 0 0 255 248 0 0 255 248 0 0])</body></methods><methods><class-id>VWHelp.AHSToolbarTextEditor class</class-id> <category>interface specs</category><body package="Arbor Help System Outline Help Core">subcanvasSpec	"UIPainter new openOnClass: self andSelector: #subcanvasSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Toolbar Text Editor Subcanvas' 			#bounds: #(#{Graphics.Rectangle} 313 301 711 468 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 29 0 0 1 0 1 ) 					#name: #text 					#model: #text 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #textChanged ) 					#menu: #textMenu 					#tabRequiresControl: true ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} -3 0 0 0 0 1 29 0 ) 					#name: #toolBar 					#flags: 0 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#component: #toolBar ) ) ) )</body></methods><methods><class-id>VWHelp.AHSToolbarHypertextEditor class</class-id> <category>resources</category><body package="Arbor Help System Outline Help Core">glossaryImage	"UIMaskEditor new openOnClass: self andSelector: #glossaryImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 14@17 depth: 5 bitsPerPixel: 8 palette: (MappedPalette withColors: ((Array new: 18) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 6167 scaledGreen: 6167 scaledBlue: 6167); at: 3 put: (ColorValue scaledRed: 6007 scaledGreen: 6007 scaledBlue: 6007); at: 4 put: (ColorValue scaledRed: 2184 scaledGreen: 2184 scaledBlue: 2184); at: 5 put: (ColorValue scaledRed: 1638 scaledGreen: 1638 scaledBlue: 2056); at: 6 put: ColorValue white; at: 7 put: (ColorValue scaledRed: 5139 scaledGreen: 5139 scaledBlue: 5268); at: 8 put: (ColorValue scaledRed: 4369 scaledGreen: 4369 scaledBlue: 4369); at: 9 put: (ColorValue scaledRed: 546 scaledGreen: 546 scaledBlue: 546); at: 10 put: (ColorValue scaledRed: 6553 scaledGreen: 6553 scaledBlue: 6553); at: 11 put: (ColorValue scaledRed: 4915 scaledGreen: 4915 scaledBlue: 4915); at: 12 put: (ColorValue scaledRed: 1092 scaledGreen: 1092 scaledBlue: 1092); at: 13 put: (ColorValue scaledRed: 7099 scaledGreen: 7099 scaledBlue: 7099); at: 14 put: (ColorValue scaledRed: 3276 scaledGreen: 3276 scaledBlue: 3276); at: 15 put: ColorValue lightGray; at: 16 put: (ColorValue scaledRed: 1638 scaledGreen: 1638 scaledBlue: 1638); at: 17 put: (ColorValue scaledRed: 7645 scaledGreen: 7645 scaledBlue: 7645); at: 18 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); yourself)) usingBits: (ByteArray fromPackedString: 'APTEAPTEAPTIB @EAPT@@@TEAPTEAP8CB@4@APTE@@@EAPTACP DB!@DDQDEAP@@AQDKB0PNC@HM@ TD@ T@@@@C@PTMA04B@!@B@@ H@@@HB@DM@ (HA@ HA@ JB@@@B@$@@@&lt;H@ HLAPTEAP @@@ EBA@EAP@@@@@@APTH@@@HAP4PAP@@APT@@@TEB@@@B@TMD@@@APTEAPTEAP @@@ ECQ@@@@TE@@@@@@TH@@@HAP4P@@@EAPT@@@TEB@@@B@TMD@T@@@TE@@@EAP @@@ ECQ@EAP@@@@@EAPTH@@@@@P4PAPTEAPTIA @@B@@@B ,H@ (@@0,@C0@QAPT@@@TJ@@P@A0HBAPTEAPTE@@@b'))</body><body package="Arbor Help System Outline Help Core">glossaryMask	"UIMaskEditor new openOnClass: self andSelector: #glossaryMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 14@17 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 224 0 0 3 224 0 0 31 240 0 0 127 248 0 0 255 252 0 0 255 252 0 0 255 252 0 0 255 252 0 0 255 252 0 0 255 252 0 0 255 252 0 0 255 252 0 0 255 252 0 0 255 252 0 0 255 252 0 0 255 240 0 0 127 0 0 0])</body><body package="Arbor Help System Outline Help Core">graphicsImage	"UIMaskEditor new openOnClass: self andSelector: #graphicsImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@13 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 5) at: 1 put: ColorValue black; at: 2 put: ColorValue yellow; at: 3 put: ColorValue white; at: 4 put: (ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4112); at: 5 put: (ColorValue scaledRed: 0 scaledGreen: 4915 scaledBlue: 4112); yourself)) usingBits: #[34 34 34 32 0 0 0 0 34 34 34 32 18 18 18 0 34 34 34 32 33 33 33 0 34 34 34 32 18 18 18 0 34 34 32 32 33 33 33 0 34 34 3 0 0 0 18 0 34 32 51 48 68 68 1 0 34 3 51 4 68 68 64 0 32 51 51 4 68 68 64 32 0 0 0 4 68 68 64 32 34 34 34 4 68 68 64 32 34 34 34 32 68 68 2 32 34 34 34 34 0 0 34 32])</body><body package="Arbor Help System Outline Help Core">graphicsMask	"UIMaskEditor new openOnClass: self andSelector: #graphicsMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@13 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[1 254 0 0 1 254 0 0 1 254 0 0 1 254 0 0 5 254 0 0 15 254 0 0 31 254 0 0 63 254 0 0 127 252 0 0 255 252 0 0 3 252 0 0 1 248 0 0 0 240 0 0])</body><body package="Arbor Help System Outline Help Core">linkImage	"UIMaskEditor new openOnClass: self andSelector: #linkImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@7 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[193 131 0 0 190 125 0 0 96 6 0 0 87 234 0 0 96 6 0 0 190 125 0 0 193 131 0 0])</body><body package="Arbor Help System Outline Help Core">linkMask	"UIMaskEditor new openOnClass: self andSelector: #linkMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@7 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[62 124 0 0 127 254 0 0 255 255 0 0 239 247 0 0 255 255 0 0 127 254 0 0 62 124 0 0])</body></methods><methods><class-id>VWHelp.ArborSlaveApplicationModel class</class-id> <category>interface specs</category><body package="Arbor Help System Outline Help Core">pinSpec	"UIPainter new openOnClass: self andSelector: #pinSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Unlabeled Canvas' 			#bounds: #(#Rectangle 400 627 504 656 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 0 0 0 0 0 1 0 1 ) 					#name: #pinButton 					#flags: 0 					#model: #togglePin 					#label: #pinUpIcon 					#hasCharacterOrientedLabel: false 					#defaultable: true ) ) ) )</body><body package="Arbor Help System Outline Help Core">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: '' 			#bounds: #(#Rectangle 127 619 385 763 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#SubCanvasSpec 					#layout: #(#Rectangle 2 0 27 16 ) 					#flags: 0 					#minorKey: #pinSpec ) ) ) )</body></methods><methods><class-id>VWHelp.ArborSlaveApplicationModel class</class-id> <category>resources</category><body package="Arbor Help System Outline Help Core">pinDownImage	"UIMaskEditor new openOnClass: self andSelector: #pinDownImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@13 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 4) at: 1 put: (ColorValue scaledRed: 2184 scaledGreen: 2184 scaledBlue: 2184); at: 2 put: ColorValue white; at: 3 put: (ColorValue scaledRed: 7099 scaledGreen: 7099 scaledBlue: 7099); at: 4 put: ColorValue lightGray; yourself)) usingBits: #[85 86 165 85 85 85 80 0 85 171 248 85 85 85 80 0 90 239 252 85 85 85 80 0 111 191 255 21 85 85 80 0 111 191 255 21 85 85 80 0 191 191 255 21 85 85 80 0 191 175 252 85 85 85 80 0 191 195 240 85 85 85 80 0 175 192 0 85 85 85 80 0 111 252 1 85 85 85 80 0 96 255 1 85 85 85 80 0 128 0 5 85 85 85 80 0 5 0 85 85 85 85 80 0])</body><body package="Arbor Help System Outline Help Core">pinDownMask	"UIMaskEditor new openOnClass: self andSelector: #pinDownMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@13 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[1 192 0 0 15 240 0 0 63 240 0 0 127 248 0 0 127 248 0 0 255 248 0 0 255 240 0 0 255 240 0 0 255 240 0 0 127 224 0 0 127 224 0 0 255 192 0 0 207 0 0 0])</body><body package="Arbor Help System Outline Help Core">pinUpImage	"UIMaskEditor new openOnClass: self andSelector: #pinUpImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@13 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 4) at: 1 put: (ColorValue scaledRed: 2184 scaledGreen: 2184 scaledBlue: 2184); at: 2 put: ColorValue white; at: 3 put: (ColorValue scaledRed: 7099 scaledGreen: 7099 scaledBlue: 7099); at: 4 put: ColorValue lightGray; yourself)) usingBits: #[85 85 85 106 85 85 80 0 85 85 85 111 21 86 144 0 85 85 85 111 21 91 192 0 85 85 85 111 42 171 192 0 85 85 85 111 63 251 192 0 85 106 170 175 63 251 192 0 85 80 0 47 63 243 192 0 85 85 85 111 0 3 192 0 65 85 85 111 0 0 0 0 62 85 85 96 5 80 0 0 62 85 85 96 21 84 16 0 105 85 85 96 85 85 80 0 85 85 85 85 85 85 80 0])</body><body package="Arbor Help System Outline Help Core">pinUpMask	"UIMaskEditor new openOnClass: self andSelector: #pinUpMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@13 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 7 0 0 0 7 129 128 0 7 131 192 0 7 255 192 0 7 255 192 7 255 255 192 3 255 255 192 0 7 255 192 96 7 255 192 240 7 195 192 240 7 129 128 96 7 0 0 0 0 0 0])</body></methods><methods><class-id>VWHelp.AHSOutlinerSubsetList class</class-id> <category>interface specs</category><body package="Arbor Help System Outline Help Core">historyWindowSpec	"UIPainter new openOnClass: self andSelector: #historyWindowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Outline Subset List' 			#min: #(#Point 280 172 ) 			#bounds: #(#Rectangle 359 192 639 364 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#SequenceViewSpec 					#layout: #(#LayoutFrame 3 0 3 0 -3 1 -40 1 ) 					#name: #subsetList 					#model: #subsetList ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -71 1 -35 1 -3 1 -2 1 ) 					#name: #close 					#model: #closeRequest 					#label: 					#(#UserMessage 						#key: #closeButton 						#defaultString: '(close)' 						#catalogID: #help ) 					#style: #'Arbor-12-Squeeze' 					#isDefault: true 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 3 0 -35 1 112 0 -2 1 ) 					#name: #clearHistory 					#model: #clearHistory 					#label: 					#(#UserMessage 						#key: #clearHistory 						#defaultString: '(clear history)' 						#catalogID: #help ) 					#style: #'Arbor-12-Squeeze' 					#defaultable: true ) ) ) )</body><body package="Arbor Help System Outline Help Core">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Outline Subset List' 			#min: #(#Point 280 172 ) 			#bounds: #(#Rectangle 360 224 640 396 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#SequenceViewSpec 					#layout: #(#LayoutFrame 0 0.0107143 0 0.0174419 0 0.989286 -38 1 ) 					#name: #subsetList 					#model: #subsetList ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -67 1 -33 1 0 0.996428 0 0.988372 ) 					#name: #close 					#model: #closeRequest 					#label: 					#(#UserMessage 						#key: #closeButton 						#defaultString: '(close)' 						#catalogID: #help ) 					#style: #'Arbor-12-Squeeze' 					#isDefault: true ) ) ) )</body></methods><methods><class-id>VWHelp.ArborSearchAndReplace class</class-id> <category>interface specs</category><body package="Arbor Help System Outline Help Core">replaceWindowSpec	"UIPainter new openOnClass: self andSelector: #replaceWindowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Search' 			#min: #(#Point 446 65 ) 			#max: #(#Point 446 65 ) 			#bounds: #(#Rectangle 362 387 808 452 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#AlignmentOrigin 91 0 7 0 1 0 ) 					#label: 'Replace With:' 					#style: #'Arbor-10' ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 92 0 5 0 -91 1 28 0 ) 					#name: #replaceString 					#model: #replaceString 					#style: #'Arbor-10' ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -84 1 4 0 -5 1 30 0 ) 					#name: #replaceButton 					#flags: 40 					#model: #doSearchAndReplace 					#label: 'Replace' 					#style: #'Arbor-10' ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -84 1 32 0 -5 1 58 0 ) 					#name: #replaceAllButton 					#flags: 40 					#model: #doSearchAndReplaceAll 					#label: 'Replace All' 					#style: #'Arbor-10' ) ) ) )</body><body package="Arbor Help System Outline Help Core">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Find / Replace' 			#min: #(#Point 304 128 ) 			#max: #(#Point 992 128 ) 			#bounds: #(#Rectangle 282 291 730 419 ) 			#isEventDriven: true ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#AlignmentOrigin 91 0 9 0 1 0 ) 					#name: #searchLabel 					#label: 'Find What:' 					#style: #'Arbor-10' ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 92 0 9 0 -93 1 32 0 ) 					#name: #searchString 					#model: #searchString 					#style: #'Arbor-10' ) 				#(#CheckBoxSpec 					#layout: #(#Point 92 33 ) 					#name: #ignoreCaseCheckbox 					#model: #ignoreCase 					#label: 'Ignore Case' 					#style: #'Arbor-10' ) 				#(#SubCanvasSpec 					#layout: #(#LayoutFrame 0 0 64 0 0 1 0 1 ) 					#name: #replaceSubCanvas 					#flags: 0 					#minorKey: #replaceWindowSpec ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -84 1 7 0 -5 1 33 0 ) 					#name: #findNextButton 					#flags: 40 					#model: #doSearch 					#label: 'Find Next' 					#style: #'Arbor-10' 					#isDefault: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -84 1 35 0 -5 1 61 0 ) 					#name: #cancelButton 					#model: #closeRequest 					#label: 'Cancel' 					#style: #'Arbor-10' ) ) ) )</body></methods><methods><class-id>VWHelp.AHSSearchDialog class</class-id> <category>interface specs</category><body package="Arbor Help System Outline Help Core">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: 'Search' 			#min: #(#Point 233 148 ) 			#max: #(#Point 233 148 ) 			#bounds: #(#Rectangle 460 376 693 524 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#InputFieldSpec 					#layout: #(#Rectangle 18 28 205 50 ) 					#name: #searchString 					#model: #searchString ) 				#(#LabelSpec 					#layout: #(#Point 12 6 ) 					#name: #searchLabel 					#label: 'Search For:' ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 22 114 92 139 ) 					#name: #ok 					#model: #ok 					#label: 'OK' 					#isDefault: true 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 136 114 206 139 ) 					#name: #cancel 					#model: #doCancel 					#label: 'Cancel' 					#defaultable: true ) 				#(#GroupBoxSpec 					#layout: #(#Rectangle 5 59 220 103 ) 					#name: #searchInBox 					#label: 'Search In' ) 				#(#RadioButtonSpec 					#layout: #(#Point 85 78 ) 					#name: #topics 					#model: #searchIn 					#label: 'Topics' 					#select: #topics ) 				#(#RadioButtonSpec 					#layout: #(#Point 20 78 ) 					#name: #text 					#model: #searchIn 					#label: 'Text' 					#select: #text ) 				#(#RadioButtonSpec 					#layout: #(#Point 161 78 ) 					#name: #both 					#model: #searchIn 					#label: 'Both' 					#select: #both ) ) ) )</body></methods><initialize><class-id>VWHelp.AHSOHCPreferencesModel</class-id></initialize><initialize><class-id>VWHelp.ArborIconSet</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ArborHyperlink</name><environment>VWHelp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>linkObject </inst-vars><class-inst-vars>color emphasis </class-inst-vars><imports></imports><category>Help-Arbor Hypertext</category><attributes><package>Arbor Hypertext</package></attributes></class><class><name>DividerSpec</name><environment>UI</environment><super>UI.NamedSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lineWidth orientation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>CachedImage</name><environment>Graphics</environment><super>Graphics.PixelArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars>image retainedMedium conversionMessage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Images</category><attributes><package>Graphics-Images</package></attributes></class><class><name>Menu</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>items groupSizes adornment selectionMemory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Menus</category><attributes><package>Interface-Menus</package></attributes></class><class><name>CharacterBlock</name><environment>Graphics</environment><super>Graphics.Rectangle</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stringIndex character </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>Graphics-Text Support</category><attributes><package>Graphics-Text Support</package></attributes></class><class><name>OpaqueImage</name><environment>Graphics</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>figure shape </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Images</category><attributes><package>Graphics-Images</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector toolDock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>UILookPolicy</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>systemAttributes systemWidgetAttributes useSystemFontOnWidgets systemMenuAttributes </class-inst-vars><imports></imports><category>UIBuilder-Support</category><attributes><package>UIBuilder-Support</package></attributes></class><class><name>Image</name><environment>Graphics</environment><super>Graphics.PixelArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bits width height depth bitsPerPixel palette maxPixelValue rowByteSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Images</category><attributes><package>Graphics-Images</package></attributes></class><class><name>SequenceViewSpec</name><environment>UI</environment><super>UI.MenuComponentSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>multipleSelections style useModifierKeys selectionType autoSelect </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>ScrollingTracker</name><environment>UI</environment><super>UI.SelectionTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>process </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events-Trackers</category><attributes><package>Interface-Events-Trackers</package></attributes></class><class><name>SequenceSelectionTracker</name><environment>UI</environment><super>UI.ScrollingTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>wantsToDrag selectionDone startPoint </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events-Trackers</category><attributes><package>Interface-Events-Trackers</package></attributes></class><class><name>ComposedText</name><environment>Graphics</environment><super>Graphics.TextLines</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text compositionWidth compositionHeight wordWrap fontPolicy lineTable fitWidth </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>Graphics-Text Support</category><attributes><package>Graphics-Text Support</package></attributes></class><class><name>LabelAndIcon</name><environment>UI</environment><super>UI.Label</super><private>false</private><indexed-type>none</indexed-type><inst-vars>icon gap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>OrderedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>firstIndex lastIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Text</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string runs </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>ArborHypertext</name><environment>VWHelp</environment><super>Core.Text</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Arbor Hypertext</category><attributes><package>Arbor Hypertext</package></attributes></class><class><name>Set</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>tally </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>AHSPreferencesModel</name><environment>VWHelp</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>triggerChannel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Core</category><attributes><package>Arbor Help System Core</package></attributes></class><class><name>VisualPart</name><environment>Graphics</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>container eventHandlers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>VisualDivider</name><environment>UI</environment><super>UI.SimpleComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>orientation lineWidth etched </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>Wrapper</name><environment>Graphics</environment><super>Graphics.VisualPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>component </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>WidgetWrapper</name><environment>UI</environment><super>Graphics.Wrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>widget widgetState effectivelyVisible decorator dependents dropTarget </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Support</category><attributes><package>UIBuilder-Support</package></attributes></class><class><name>View</name><environment>UI</environment><super>Graphics.DependentPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controller properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>TextEditorView</name><environment>UI</environment><super>UI.ComposedTextView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state helpText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>SequenceView</name><environment>UI</environment><super>UI.SelectionView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>visualBlock selectedVisualBlock measureWidth cachedWidth helpText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>CompositeView</name><environment>UI</environment><super>Graphics.DependentComposite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controller </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>Controller</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model view sensor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>ControllerWithMenu</name><environment>UI</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuHolder performer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>SequenceController</name><environment>UI</environment><super>UI.ControllerWithMenu</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyboardProcessor outside searchString keyboardHook doStringSearching dispatcher dragDropCallbacks selectOnDownWithDrag autoSelect </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>UIBasics-Controllers</category><attributes><package>UIBasics-Controllers</package></attributes></class><class><name>ParagraphEditor</name><environment>UI</environment><super>UI.ControllerWithMenu</super><private>false</private><indexed-type>none</indexed-type><inst-vars>beginTypeInIndex anchorIndex emphasisHere dispatchTable charComposer textHasChanged feelPolicy supportCodeEditingFeels localMenuItems extendingDown </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>ArborHypertextEditorController</name><environment>VWHelp</environment><super>UI.TextEditorController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Help-Arbor Hypertext</category><attributes><package>Arbor Hypertext</package></attributes></class><class><name>ScheduledWindow</name><environment>UI</environment><super>Graphics.Window</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label icon minimumSize maximumSize component lookPreferences paintPreferences edgeDecorationPolicy widgetPolicy controller model damageRepairPolicy masterWindow </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>BoundedWrapper</name><environment>Graphics</environment><super>Graphics.LayoutWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>extent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class></st-source>