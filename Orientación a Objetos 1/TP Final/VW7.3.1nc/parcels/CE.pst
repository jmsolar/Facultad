<?xml version="1.0"?><st-source><!-- Name: CEComment: This Parcel contains the support code making VisualWorks compatible with WindowsCE devices.  The most important change is the provision of a mode that generates a right-button press if the left-button, or stylus, is held down without moving for 0.65 seconds.  This can be disabled via the Look and Feel Settings page.HideSource: falsePackageName: CEParcel: #('CE')ParcelName: CESaveSource: trueVersion: 7.2.1 previewDate: 6:26:03 pm June 23, 2004 --><time-stamp>From VisualWorksÂ®, 7.2.1 of June 14, 2004 on June 23, 2004 at 6:26:03 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>InputState</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y bitState shiftState ctrlState lockState metaState metaKeyState otherMetaKey1State lastClick eventDispatcher lastDownPoint lastUpPoint lastUpButton lastWindow contextMenuDelay delayedEvent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category></class><comment><class-id>UI.InputState</class-id><body>Class InputState flattens the mouse motion and mouse button state into booleans for polling InputSensors.  Keyboard shift, control and meta are also flattened. Instance Variables:	x	&lt;Integer&gt;  mouse coordinate	y	&lt;Integer&gt;  mouse coordinate	bitState	&lt;Integer&gt;  vector of all the mouse buttons	shiftState	&lt;Integer&gt;  state of the left shift key	ctrlState	&lt;Integer&gt;  state of the control key	lockState	&lt;Integer&gt;  state of the caps-lock key	metaState	&lt;Integer&gt;  vector of all the modifier key states	metaKeyState	&lt;Integer&gt;  state of the meta key	otherMetaKey1State	&lt;Integer&gt;  state of the 2nd meta key	activitySemaphore	&lt;Semaphore&gt;  used to halt polling when no input is available	lastEventTime	&lt;Integer&gt;  millisecond time of the last input event	eventDispatcher	&lt;Object | nil&gt; an object which dispatches general events--those events not bound to a particular window.  The object, if not nil, must respond to #dispatchEvent:.	lastDownPoint	&lt;Point&gt;	The mouse position the last time a mouse button was pressed	lastUpPoint		&lt;point&gt;	The mouse position the last time a mouse button was released	lastUpButton    &lt;Integer&gt; The last button releasedClass Variables:	CtrlMask &lt;Integer&gt;  bits of metaState vector specifying control key state	DefaultState	&lt;InputState&gt;  usual input state for windows	DoubleClickTimeout	&lt;Integer&gt;  milliseconds between two clicks of a double click	FunctionKeyNames	&lt;Array&gt;  maps function key codes to Symbols	FunctionKeyValues	&lt;Array&gt;  	InputProcess	&lt;Process&gt;  dispatches input events	InputSemaphore	&lt;Semaphore&gt;  signalled on input events	InterruptKey	&lt;Integer&gt;  input encoding of the interrupt key	LockMask &lt;Integer&gt;  bits of metaState vector specifying lock key state	MetaFunctionKeyMap	&lt;Integer&gt; maps function key codes to Booleans as to whether a key is a modifier key	MetaMask &lt;Integer&gt;  bits of metaState vector specifying meta key state	OtherMeta1Mask &lt;Integer&gt;  bits of metaState vector specifying other meta (1) key state	PollingTimeout &lt;Integer&gt;	number of milliseconds to wait for input before sleeping	ShiftMask &lt;Integer&gt;  bits of metaState vector specifying shift key state	GrabProtect &lt;Semaphore&gt;	guarantees mutual exclusive access to GrabQueue.	GrabQueue	&lt;OrderedCollection&gt;	a queue of windows that are grabbing mouse input. 				The last item in the collection is the current grab object.</body></comment><class><name>CEFilename</name><environment>OS</environment><super>OS.NTFSFilename</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-PC</category></class><class><name>WinCESystemSupport</name><environment>OS</environment><super>OS.OSSystemSupport</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.WinCESystemSupportDictionary.*			</imports><category>OS-Support</category><attributes><includeFiles><item>sipapi.h</item></includeFiles><includeDirectories><item></item></includeDirectories><libraryFiles><item>aygshell.dll</item></libraryFiles><libraryDirectories><item>\Windows</item></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel></attributes></class><comment><class-id>OS.WinCESystemSupport</class-id><body>This class provides access to Windows CE-specific functionality.</body></comment><shared-variable><name>CurrentDirectoryString</name><environment>OS.CEFilename</environment><private>false</private><constant>false</constant><category>current settings</category><initializer>'\'</initializer></shared-variable><shared-variable><name>RightMouseButtonEmulationActive</name><environment>UI.InputState</environment><private>false</private><constant>false</constant><category>button emulation</category><initializer>false</initializer></shared-variable><shared-variable><name>RightMouseButtonEmulation</name><environment>UI.InputState</environment><private>false</private><constant>false</constant><category>button emulation</category><initializer>true</initializer></shared-variable><methods><class-id>UI.InputState</class-id> <category>private dispatching</category><body>send: window eventButtonPress: event 	| focusWindow thisClick |	self changeWindowOrigin: window andSwapButtonsNow: event.	lastDownPoint := x @ y.	self setStateFromVector: (event at: 8).	(focusWindow := self focusWindowOr: window) ifNil: [^self].	event at: 2 put: focusWindow key.	thisClick := event at: 9.	((event at: 7) = 1 and: [self startContextWaitProcessWith: event for: focusWindow]) ifTrue: [^self].	((lastUpButton anyMask: self mouseButtons) and: 		[lastClick + self class doubleClickTimeout &gt; thisClick and: 		[(lastDownPoint - lastUpPoint) abs &lt;= (2 @ 2)]]) 			ifTrue: [focusWindow sensor eventDoubleClick: event]			ifFalse: [focusWindow sensor eventButtonPress: event].	lastClick := thisClick</body><body>send: window eventButtonRelease: event 	| focusWindow |	contextMenuDelay ifNotNil: 			[self stopContextMenuDelay].	self changeWindowOrigin: window andSwapButtonsNow: event.	lastUpPoint := x @ y.	self setStateFromVector: (event at: 8).	lastUpButton := 1 bitShift: (event at: 7) - 1.	(focusWindow := self focusWindowOr: window) ifNil: [^self].	event at: 2 put: focusWindow key.	focusWindow sensor eventButtonRelease: event</body><body>send: window eventMouseMoved: event	| focusWindow |	contextMenuDelay ifNotNil: 			[(x@y dist: lastDownPoint) &gt; 3 ifTrue:[self stopContextMenuDelay]].	self changeWindowOrigin: window andSwapButtons: event.	window ifNil: [^self processUnboundEvent: event].	focusWindow := self focusWindowOr: window.	focusWindow ifNil: [^self sendMouseTransition: focusWindow].	event at: 2 put: focusWindow key.	focusWindow sensor eventMouseMoved: event.	focusWindow ~= lastWindow ifTrue: [self sendMouseTransition: focusWindow]</body><body>startContextWaitProcessWith: event for: focusWindow 	"This forks a process doing a lot of things:		1. wait for 650 ms		2. continue only if this delay wasn't canceled		3. draw a small red circle arround the mouse position to warn the user that a menu is about to come up		4. wait another 650 ms		5. restore the area where the circle was drawn		6. continue only if the second delay wasn't canceled		7. send the event as a release button event, otherwise we cannot open a menu		8. convert the event into a middle mouse button pressed event, and send it.		9. nill out the delayedEvent if the fake event was sent since we don't wat to send it after we open the menu	The delays are stored in instVar contextMenuDelay, which is accesses by 'process:' to clear and 	cancel the delay if another event is to be processed while the delay is running."	self class rbEmulationEnabledActive ifFalse: [^false].	delayedEvent := event.	contextMenuDelay := Delay forMilliseconds: 650.		[	[| copiedEvent |	copiedEvent := event copy.	contextMenuDelay wait.	contextMenuDelay ifNotNil: 			[| gc pixmap focusPoint |						[| pixExtent square |			gc := focusWindow graphicsContext.			pixExtent := 19 @ 18.			pixmap := Pixmap extent: pixExtent.			square := 0 @ 0 extent: 14 @ 14.			gc paint: ColorValue red.			gc lineWidth: 2.			focusPoint := lastDownPoint - focusWindow globalOrigin - (7 @ 7).			pixmap graphicsContext 				copyRectangularArea: (0 @ 0 extent: pixExtent)				from: gc				sourceOffsetX: focusPoint x - 2				y: focusPoint y - 1				destinationOffsetX: 0				y: 0.			gc 				displayArcBoundedBy: square				startAngle: 0				sweepAngle: 360				at: focusPoint.			gc flush.			(contextMenuDelay := Delay forMilliseconds: 650) wait] 					ensure: [gc notNil &amp; pixmap notNil ifTrue: 								[gc displayPixmap: pixmap at: focusPoint - (2 @ 1).								gc flush]].			contextMenuDelay ifNotNil: 					[copiedEvent at: 7 put: 2.	"make it middle mouse button and ctrl down, then send it off to the window sensor, it should pop up a menu"					copiedEvent at: 8 put: ((copiedEvent at: 8) bitOr: CtrlMask).					focusWindow sensor eventButtonPress: copiedEvent.					delayedEvent := nil]]] 			on: Error			do: [:s | ]] 			forkAt: 51.	^true</body><body>stopContextMenuDelay	| window thisClick |	contextMenuDelay disable.	contextMenuDelay := nil.	delayedEvent ifNil: [^self].	window := Window findRegistrant: (delayedEvent at: 2).	(window := self focusWindowOr: window) ifNil: [^self].	thisClick := delayedEvent at: 9.	((lastUpButton anyMask: self mouseButtons) and: 		[lastClick + self class doubleClickTimeout &gt; thisClick and: 		[(lastDownPoint - lastUpPoint) abs &lt;= (2 @ 2)]]) 			ifTrue: [window sensor eventDoubleClick: delayedEvent]			ifFalse: [window sensor eventButtonPress: delayedEvent].	lastClick := thisClick</body></methods><methods><class-id>UI.InputState class</class-id> <category>accessing</category><body>rbEmulationEnabled	^RightMouseButtonEmulation</body><body>rbEmulationEnabled: aBoolean	RightMouseButtonEmulation := aBoolean</body><body>rbEmulationEnabledActive	^RightMouseButtonEmulationActive</body><body>rbEmulationEnabledActive: aBoolean	RightMouseButtonEmulationActive := aBoolean</body></methods><methods><class-id>UI.InputState class</class-id> <category>system startup</category><body>postSnapshot	"Clean up after a snapshot"	InputProcess resume</body><body>postStartup	"Clean up after a snapshot"	self rbEmulationEnabledActive: (self rbEmulationEnabled		and: ['* ce *' match: OSHandle currentPlatformID]).</body></methods><methods><class-id>OS.CEFilename</class-id> <category>private</category><body>named: n 	n first == self separator 		ifTrue: [^super named: n]		ifFalse: 			[| path |			path := self class getDefaultDirectory asString.			path last == self separator 				ifTrue: [^super named: path , n]				ifFalse: [^super named: path , (String with: self separator) , n]]</body></methods><methods><class-id>OS.CEFilename class</class-id> <category>private</category><body>currentDirectoryString	"Return the platform-specific token that represents the current directory"	^CurrentDirectoryString copy</body><body>hookupTo: pn	"The receiver has become the default class for  Filename.  Get prepared."	ObjectMemory addDependent: self.	self setCwd</body><body>setCwd	"set current working directory at startup time"	"self setCwd"	| commandLine fileName |	commandLine := CEnvironment commandLine.	fileName := commandLine select: [:s | '*.im' match: s].	fileName isEmpty ifTrue: [fileName := commandLine].	"Transcript show: fileName first asFilename head."	self setCurrentDirectory: fileName first asFilename head</body><body>update: anAspect 	anAspect == #returnFromSnapshot ifTrue: [self setCwd]</body></methods><methods><class-id>OS.CEFilename class</class-id> <category>accessing</category><body>getDefaultDirectory	^CurrentDirectoryString</body><body>setCurrentDirectory: aFileName	CurrentDirectoryString := aFileName asString</body></methods><methods><class-id>OS.CEFilename class</class-id> <category>utilities</category><body>volumes	^Array with: '\'</body></methods><methods><class-id>OS.WinCESystemSupport</class-id> <category>types</category><body>BOOL	&lt;C: typedef long BOOL&gt;</body><body>CLSID	&lt;C: typedef void * CLSID&gt;</body><body>DWORD	&lt;C: typedef unsigned long DWORD&gt;</body><body>HANDLE	&lt;C: typedef void * HANDLE&gt;</body><body>HWND	&lt;C: typedef void * HWND&gt;</body><body>IMENUMINFO	&lt;C: typedef struct tagIMENUMINFO IMENUMINFO&gt;</body><body>IMENUMPROC	&lt;C: typedef int (* IMENUMPROC)(IMENUMINFO * )&gt;</body><body>IMWINDOWPOS	&lt;C: typedef struct tagIMWINDOWPOS IMWINDOWPOS&gt;</body><body>LPBYTE	&lt;C: typedef unsigned char * LPBYTE&gt;</body><body>LPCWSTR	&lt;C: typedef wchar_t * LPCWSTR&gt;</body><body>LPSTR	&lt;C: typedef char * LPSTR&gt;</body><body>LPVOID	&lt;C: typedef void * LPVOID&gt;</body><body>LPWSTR	&lt;C: typedef wchar_t * LPWSTR&gt;</body><body>PIMENUMINFO	&lt;C: typedef struct tagIMENUMINFO * PIMENUMINFO&gt;</body><body>RECT	&lt;C: typedef struct _RECT RECT&gt;</body><body>SIPINFO	&lt;C: typedef struct tagSIPINFO SIPINFO&gt;</body><body>wchar_t	&lt;C: typedef short wchar_t&gt;</body><body>WORD	&lt;C: typedef unsigned short  WORD&gt;</body></methods><methods><class-id>OS.WinCESystemSupport</class-id> <category>structs</category><body>PROCESS_INFORMATION	"Describes a created process and its main thread."	&lt;C: struct PROCESS_INFORMATION {			HANDLE hProcess;			HANDLE hThread;			DWORD dwProcessId;			DWORD dwThreadId;		}&gt;</body><body>tagIMENUMINFO	&lt;C: struct tagIMENUMINFO {			unsigned short szName[260];			CLSID clsid;		}&gt;</body><body>tagIMWINDOWPOS	&lt;C: struct tagIMWINDOWPOS {			int x, y, cx, cy;		}&gt;</body><body>tagSIPINFO	&lt;C: struct tagSIPINFO {			unsigned long cbSize, fdwFlags;			RECT rcVisibleDesktop, rcSipRect;			unsigned long dwImDataSize;			void * pvImData;		}&gt;</body><body>_RECT	&lt;C: struct _RECT {			long left, top, right, bottom;		}&gt;</body></methods><methods><class-id>OS.WinCESystemSupport</class-id> <category>private- accessing</category><body>createPath: path in: key	"Iterate through a path and create each branch under a key."	| errorCode newKey initialKey disposition |	initialKey := key.	disposition := CIntegerType long newInFixedSpace.	newKey := CVoidType void pointerType newInFixedSpace.	path do:		[ :subKey |		errorCode :=  self regCreateKey: initialKey asInteger  			named: subKey result: newKey disposition: disposition. 		errorCode = self ERROR_SUCCESS ifFalse: [^nil].		initialKey := newKey contents].	^newKey</body></methods><methods><class-id>OS.WinCESystemSupport</class-id> <category>procedures</category><body>regCreateKey: hKey named: lpSubKey result: phkResult disposition: lpdwDisposition 		"Shortcut for RegCreateKey"	^self RegCreateKey: hKey 			named: lpSubKey 			reserved: 0 			class: nil 			options: 0 			sam: self writeAccessMask  			security: nil 			result: phkResult 			disposition: lpdwDisposition.</body></methods><methods><class-id>OS.WinCESystemSupport</class-id> <category>constants</category><body>ERROR_SUCCESS	^0</body><body>HKEY_CLASSES_ROOT	^16r80000000</body><body>REG_SZ	^1</body><body>SIP_DOWN	^1</body><body>SIP_FORCEDOWN	^2</body><body>SIP_INPUTDIALOG	^4</body><body>SIP_UNCHANGED	^3</body><body>SIP_UP	^0</body><body>writeAccessMask	"defined by WinNT API"	^131078</body></methods><methods><class-id>OS.WinCESystemSupport</class-id> <category>accessing</category><body>registerVisualworksExtension	"self new registerVisualworksExtension"	self setVariableWithRoot: self HKEY_CLASSES_ROOT path: (Array with: '.im' asWordArg) key: 'Default' asWordArg value: 'visual_im' asWordArg.	self setVariableWithRoot: self HKEY_CLASSES_ROOT 		path: (Array with: 'visual_im' asWordArg with:'shell' asWordArg with:'open' asWordArg with:'command' asWordArg)		 key: 'Default' asWordArg		 value: ('"',CEnvironment commandLine first,'"  "%1"') asWordArg.</body><body>removeVariableWithRoot: rootValue path: path name: parameterName ifAbsent: errorBlock	"Remove the value of the named parameter, which must be a string.  If not 	 present in registry, return value of errorBlock."	| key errorCode voidPointerType stream |	key := (voidPointerType := CVoidType void pointerType) newInFixedSpace.	key contents: (voidPointerType cast: rootValue).	stream := WriteStream on: (String new: 64).	path do: [:each | stream nextPutAll: each] separatedBy: [stream nextPut: $\]. 	errorCode :=		self			RegOpenKeyEx: key contents			subKey: stream contents			options: 0			access: self KEY_SET_VALUE			result: key.	errorCode = self ERROR_SUCCESS ifFalse: [^errorBlock value].	errorCode := self RegDeleteValueW: key contents name: parameterName.	self RegCloseKey: key contents.	errorCode = self ERROR_SUCCESS ifFalse: [^errorBlock value]</body><body>setVariableWithRoot: rootValue path: path key: subkey value: value	"Set the value in the registry of subkey, which value must be a string.  	 Answer whether the operation was successful."	| key newKey errorCode voidPointerType|	key := (voidPointerType := CVoidType void pointerType) newInFixedSpace.	key contents: (voidPointerType cast: rootValue).	newKey := self createPath: path in: key contents.	newKey == nil ifTrue: [^false].	errorCode :=		self			RegSetValueEx: newKey contents asInteger			name: subkey			reserved: 0			type: self REG_SZ			data: value			size: value size.	^errorCode = self ERROR_SUCCESS</body></methods><methods><class-id>OS.WinCESystemSupport</class-id> <category>utilities</category><body>hideSIP	| pSipInfo result |	self halt.	pSipInfo := self SIPINFO calloc.	pSipInfo memberAt: #cbSize put: pSipInfo type referentType dataSize.	result := self SipGetInfo: pSipInfo.	result ifFalse:[result := self GetLastError.	self halt.].	pSipInfo memberAt: #fdwFlags put: ((pSipInfo memberAt: #fdwFlags) bitAnd: SIPF_ON value bitInvert).	result := self SipSetInfo: pSipInfo.	result ifFalse:[result := self GetLastError.	self halt.].</body><body>setCurrentDirectory: pathName	"Set the current working directory."CEFilename setCurrentDirectory: pathName</body><body>showSIP	| pSipInfo result |	pSipInfo := self SIPINFO calloc.	pSipInfo memberAt: #cbSize put: pSipInfo type referentType dataSize.	result := self SipGetInfo: pSipInfo.	result ifFalse:[result := self GetLastError.	self halt.].	pSipInfo memberAt: #fdwFlags put: ((pSipInfo memberAt: #fdwFlags) bitOr: SIPF_ON value).	result := self SipSetInfo: pSipInfo.	result ifFalse:[result := self GetLastError.	self halt.].</body><body>showSIPFor: aWindow	^self SHFullScreen: aWindow windowHandle with: SHFS_SHOWSIPBUTTON value</body></methods><methods><class-id>OS.WinCESystemSupport</class-id> <category>defines</category><body>IM_NARROWIMAGE	&lt;C: #define IM_NARROWIMAGE 2	&gt;</body><body>IM_POSITION	&lt;C: #define IM_POSITION 0	&gt;</body><body>IM_WIDEIMAGE	&lt;C: #define IM_WIDEIMAGE 1	&gt;</body><body>MAX_PATH	&lt;C: #define MAX_PATH 260	&gt;</body><body>SHFS_SHOWSIPBUTTON	&lt;C: #define SHFS_SHOWSIPBUTTON          0x0004	&gt;</body><body>SIPF_DOCKED	&lt;C: #define SIPF_DOCKED 0x00000002	&gt;</body><body>SIPF_LOCKED	&lt;C: #define SIPF_LOCKED 0x00000004	&gt;</body><body>SIPF_OFF	&lt;C: #define SIPF_OFF 0x00000000	&gt;</body><body>SIPF_ON	&lt;C: #define SIPF_ON 0x00000001	&gt;</body><body>SIP_STATUS_AVAILABLE	&lt;C: #define SIP_STATUS_AVAILABLE 1	&gt;</body><body>SIP_STATUS_UNAVAILABLE	&lt;C: #define SIP_STATUS_UNAVAILABLE 0	&gt;</body><body>SPI_GETCURRENTIM	&lt;C: #define SPI_GETCURRENTIM 227	&gt;</body><body>SPI_GETSIPINFO	&lt;C: #define SPI_GETSIPINFO 225	&gt;</body><body>SPI_SETCOMPLETIONINFO	&lt;C: #define SPI_SETCOMPLETIONINFO 223	&gt;</body><body>SPI_SETCURRENTIM	&lt;C: #define SPI_SETCURRENTIM 226	&gt;</body><body>SPI_SETSIPINFO	&lt;C: #define SPI_SETSIPINFO 224	&gt;</body></methods><methods><class-id>OS.WinCESystemSupport class</class-id> <category>utilities</category><body>CreateProcess: aProgramNameString arguments: anArgumentString 	"Create a new process with a specific argument list. 	Answer aCCompositePointer to a PROCESS_INFORMATION struct.	The example is intended to run on PocketPC 2003."	"self CreateProcess: 'iexplore.exe' arguments: ' \Windows\agdefault.htm'"	^self		CreateProcess: aProgramNameString		arguments: anArgumentString		creationFlags: 0.</body><body>CreateProcess: aProgramNameString arguments: anArgumentString creationFlags: creationFlags 	"Create a new detached process with a specific argument list and creationFlags. 	Answer aCCompositePointer to a PROCESS_INFORMATION struct."	| interface processInfo |	interface := self new.	processInfo := interface PROCESS_INFORMATION gcMalloc.	interface		CreateProcess: (aProgramNameString ifNil: [nil] ifNotNil: [aProgramNameString asWordArg])		commandLine: anArgumentString asWordArg		pSecurity: nil		tSecurity: nil		inheritHandles: 0		creationFlags: creationFlags		environment: nil		currentDirectoryName: nil		startupInfo: nil		processInfo: processInfo.	^processInfo</body></methods><methods><class-id>UI.WindowManager</class-id> <category>event processing</category><body>processNextEvent	| event |	event := eventQueue next.	activeController := event activeWindowController.	"need this for debugging"	self safelyDispatchForWindowManager: event.	self repairDamages.	event isExposeEvent ifTrue: [event window setupKeyboard].	Processor yield.	^event</body></methods><methods><class-id>OS.SocketAccessor</class-id> <category>accessing</category><body>getPendingErrorOnCE	"Return the value of my pending error option. 	This can be checked before performing operations on me to verify 	that some previous operation hasn't resulted in a SOL_SOCKET-level 	error which could cause subsequent operations to signal an 	exception. On most CE devices this getSockOpt call is not supported,	so we provide the current errorCode instead."	| ba oldError |	oldError := self errorCode. oldError isNil ifTrue:[oldError := 0].	[ba := self getOptionsLevel: self class SOL_SOCKET name: self class SO_ERROR] on: OsIllegalOperation do: [:exception | ^oldError].	ba changeClassTo: UninterpretedBytes.	^ba unsignedLongAt: 1</body></methods><methods><class-id>Kernel.ObjectMemory class</class-id> <category>system startup</category><body>bringAllWindowsToFront	InputState postStartup.	('* ce *' match: OSHandle currentPlatformID) ifTrue: 		[Window allGeneralInstances do: [:x | x isOpen ifTrue: [x raise]]]</body></methods><methods><class-id>OS.Filename class</class-id> <category>class initialization</category><body>hookupFor: ps withID: id	"hook-up default subclasses."	| dpc |	dpc := id = 'unix' ifTrue: [UnixFilename]			ifFalse:	[id = 'mac' ifTrue: [MacFilename]			ifFalse:	[(#('dos' 'os2' 'win32') includes: id) ifTrue: [('*ce*' match: ps) ifTrue:[CEFilename hookupTo: ps]. PCFilename]			ifFalse:	[self]]].	self defaultClass: dpc.	dpc hookupTo: ps.</body></methods><methods><class-id>OS.PCFilename class</class-id> <category>class initialization</category><body>initialize	"Initialize the dictionary of file system classes for the known File Systems.	 Edit this when a new known file system is added.  NT has quite a lot of	 names for file systems and more may be found."	"PCFilename initialize"	(FsDict := Dictionary new) 		at: 'CDFS' put: HPFSFilename;		at: 'DOS' put: FATFilename;		at: 'FAT' put: FATFilename;		at: 'FAT32' put: FATFilename;		at: 'HPFS' put: HPFSFilename;		at: 'LAN' put: FATFilename;		at: 'NETWARE' put: FATFilename;		at: 'NetWare' put: FATFilename;		at: 'NFS' put: HPFSFilename;		at: 'NTFS' put: NTFSFilename;		at: 'NWCOMPA' put: FATFilename;		at: 'NWCOMPAT' put: FATFilename;		at: 'NWFS' put: FATFilename;		at: 'Samba' put: FATFilename;		at: 'VINES' put: FATFilename;		at: 'CEFS' put: CEFilename.	^self</body></methods><methods><class-id>Graphics.ScreenGraphicsContext</class-id> <category>primitives-curves</category><body>roundedPrimDisplayArcBBoxOrigin: originPoint extent: extentPoint startAngle: startAngle sweepAngle: sweepAngle 	"Display an elliptical arc defined by the bounding rectangle of the 	ellipse and by the starting angle and angle of sweep for the arc. 		The bounding rectangle is specified by the coordinates of its top left 	corner and by its width and height. The angles are specified in 	degrees, with positive angles indicating clockwise displacements, 	negative angles counterclockwise. The startAngle specifies that 	starting angular position for the arc, measured from three o'clock. 	The sweep angle specifies the angular path of the arc relative to 	the starting angle. The angles are specified in the (possibly skewed) 	coordinate system of the ellipse. For example, the angle between 	three o'clock and a line from the center of the ellipse to the top 	right corner of the bounding rectangle is always 45 degrees, even if 	the bounding rectangle is not square.	The points have already been rounded and the angles already	converted to Floats.		Use the current line width, cap style, and paint."	&lt;primitive: 990&gt;	" We have already rounded all the points,	so the primitive must be unable to handle	some other aspect of the drawing operation.	Fall back to general-case code. "	self displayGeneralArcBBoxOrigin: originPoint extent: extentPoint startAngle: startAngle sweepAngle: sweepAngle</body></methods><methods><class-id>UI.Event</class-id> <category>testing</category><body>isExposeEvent	^false</body></methods><methods><class-id>Kernel.ObjectMemory class</class-id> <category>system startup</category><body>returnFromSnapshotWithPriority: priority	"Get connected back up to the hardware after a snapshot or quit."	"Call the initialization code that depends on system parameters,	 in case we are coming up on a system different from the one	 that we quit or snapshot on.  The priority argument is passed on	 so that the current Process's priority can be dropped as soon	 as it's safe to do so."	self installSystemWithPriority: priority.	self changed: #returnFromSnapshot.	self primInformSystemReady.	self checkImageAndChanges.	self bringAllWindowsToFront</body></methods><methods><class-id>Graphics.Window</class-id> <category>private</category><body>setupKeyboard		('* PocketPC*' match: OSHandle currentPlatformID) ifTrue:		[WinCESystemSupport new showSIPFor: self ].	^self</body></methods><methods><class-id>OS.SocketAccessor</class-id> <category>accessing</category><body>getPendingError	"Return the value of my pending error option. 	This can be checked before performing operations on me to verify 	that some previous operation hasn't resulted in a SOL_SOCKET-level 	error which could cause subsequent operations to signal an 	exception. On most CE devices this getSockOpt call is not supported,	so we provide the current errorCode instead."	| ba |	('*win* ce *' match: OSHandle currentPlatformID) ifTrue:		[^self getPendingErrorOnCE].	ba := self getOptionsLevel: self class SOL_SOCKET name: self class SO_ERROR.	ba changeClassTo: UninterpretedBytes.	^ba unsignedLongAt: 1</body></methods><methods><class-id>UI.ScheduledWindow</class-id> <category>scheduling</category><body>openIn: aRectangle	"Open and schedule the receiver in aRectangle."	| newBounds |	self setDisplayBox: (newBounds := Screen default makeRectangleVisible: aRectangle).	self privateOpenForced: true.	self extentEvent: self extent.	Cursor normal show.	^newBounds</body></methods><methods><class-id>UI.ExposeEvent</class-id> <category>testing</category><body>isExposeEvent	^true</body></methods><methods><class-id>Core.String</class-id> <category>converting</category><body>asWordArg	^(self, (String new: (self size +2) withAll: (Character value: 0))) asWordArray</body></methods><methods><class-id>UI.TransientWindow</class-id> <category>private</category><body>setupKeyboard	^self</body></methods><methods><class-id>Graphics.ScreenGraphicsContext</class-id> <category>primitives-curves</category><body>roundedPrimDisplayWedgeBBoxOrigin: originPoint extent: extentPoint startAngle: startAngle sweepAngle: sweepAngle 	"Display an elliptical wedge bounded by a zero-width arc and the 	zero-width line segments from the center of the ellipse to the ends 	of the arc. 		The bounding arc is defined by the bounding rectangle of the ellipse 	and by the starting angle and angle of sweep for the arc. The 	bounding rectangle is specified by the coordinates of its top left 	corner and by its width and height. The angles are specified in 	degrees, with positive angles indicating clockwise displacements, 	negative angles counterclockwise. The startAngle specifies that 	starting angular position for the arc, measured from three o'clock. 	The sweep angle specifies the angular path of the arc relative to 	the starting angle. The angles are specified in the (possibly skewed) 	coordinate system of the ellipse. For example, the angle between 	three o'clock and a line from the center of the ellipse to the top 	right corner of the bounding rectangle is always 45 degrees, even if 	the bounding rectangle is not square. 		Use the current paint.	The coordinates have already been rounded and the angles converted	to floats."	&lt;primitive: 991&gt;	(EllipticalArc boundingBox: (originPoint extent: extentPoint) startAngle: startAngle sweepAngle: sweepAngle) asPolyline asFiller displayOn: self</body></methods><methods><class-id>Graphics.Window class</class-id> <category>private</category><body>encodeWindowTypeSpecification: aWindowType 	"Answer the encoded version of this window type specification."	('* PocketPC*' match: OSHandle currentPlatformID) ifTrue:		[^(#(#popUp #dialog #normalX #modelessDialog #imageModalDialog #reserved #postedMenu #normal)			indexOf: aWindowType			ifAbsent: [3]) - 1].	^(#(#popUp #dialog #normal #modelessDialog #imageModalDialog #reserved #postedMenu)		indexOf: aWindowType		ifAbsent: [3]) - 1</body></methods><methods><class-id>OS.OSSystemSupport class</class-id> <category>instance creation</category><body>concreteClassFrom: platformArray	"Answer the specific subclass that interfaces to the OS described by	 the supplied platformArray."	| platformSymbol version |	platformSymbol := platformArray at: 1.	#unix == platformSymbol ifTrue: 		[('*macOSX*' match: (platformArray at: 2))			ifFalse: [^#{UnixSystemSupport} value]			ifTrue:   [^#{MacOSXSystemSupport} value]].	#os2 == platformSymbol		ifTrue: [^#{OS2SystemSupport} value].	#win32 == platformSymbol		ifTrue:			[| stream os |			stream := (platformArray at: 2) readStream.			stream skipThrough: Character space.			version := stream upTo: Character space.			os := stream upTo: Character space. "Should be end of string."			^os = 'win32s'				ifTrue: [('V3.*' match: version)					ifTrue: [#{Win32sSystemSupport} value]					ifFalse: [#{Win95SystemSupport} value]]				ifFalse: [os = '95'					ifTrue: [#{Win95SystemSupport} value]					ifFalse: [os = 'ce' ifTrue: [#{WinCESystemSupport} value]							ifFalse:[#{WinNTSystemSupport} value]]]].	#mac == platformSymbol		ifTrue:			[| stream |			stream := (platformArray at: 2) readStream.			stream				skipThrough: Character space;				skipThrough: Character space;				skipThrough: Character space.			^stream peek == $P				ifTrue: [#{PowerMacSystemSupport} value]				ifFalse: [#{MacSystemSupport} value]].	^#unknown.</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body>lookAndFeelPage	&lt;settingsPage: #(lookAndFeel) position: -30&gt;	^ModularSettingsPage new		label: #LookAndFeel &lt;&lt; #labels &gt;&gt; 'Look and Feel';		icon: (ListIconLibrary visualFor: #window);		addAllSettings: 			(self settingsWithPrefix: #(lookAndFeel) 				except: #(windowPlacement mouseButtonOrder rightButtonEmulation));		useRadioButtonsForEnumerations;		addSetting:			(self settingWithId: #(lookAndFeel windowPlacement));		addSetting:			(self settingWithId: #(lookAndFeel mouseButtonOrder));		addSetting:			(self settingWithId: #(lookAndFeel rightButtonEmulation))</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-look and feel</category><body>lookAndFeel60rightButtonEmulation	&lt;setting: #(lookAndFeel rightButtonEmulation)&gt;	^(BooleanSetting on: InputState aspect: #rbEmulationEnabled)		default: #false;		label: #RightButtonEmulation &lt;&lt; #labels &gt;&gt; 'Right Mouse button emulation for Windows CE';		helpText: #RightButtonEmulationHelpText &lt;&lt; #dialogs &gt;&gt; 'This setting controls the right mouse button emulation designed for the Windows CE platform. If enabled, a normal mouse button selection, where the mouse isn''t moved in any direction, will first draw a small red circle arround the mouse point, and if enough time has elapsed, the middle mouse menu is poped up. The red circle is removed, if the mouse is moved or the button is released in time.Because Windows CE devices normally have no mouse, but only a stylus, this setting should be switched on if application are to be deployed on Windows CE.'</body></methods><methods><class-id>OS.WinCESystemSupport</class-id> <category>procedures</category><body>CreateProcess: imageName commandLine: commandLine pSecurity: lpsaProcess tSecurity: lpsaThread inheritHandles: inheritHandles creationFlags: creationFlags environment: environment currentDirectoryName: currentDirectoryName startupInfo: startupInfo processInfo: processInfo	"Create a new process running in a separate address space. n.b., we use CreateProcessW	(the UNICODE/wide version) rather than CreateProcessA (the ANSI version) since CE implements	only the unicode versions. This differs from the other Windows versions.	Unused structs are replaced by 'void *' types.	Description: http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wcekernl/html/_wcesdk_win32_createprocess.asp"	&lt;C: BOOL CreateProcessW( 					LPCWSTR imageName,					LPCWSTR commandLine,					void * lpsaProcess, 					void * lpsaThread,					BOOL inheritHandles,					DWORD creationFlags,					LPVOID environment,					LPWSTR currentDirectoryName,					void * startupInfo,					struct PROCESS_INFORMATION *processInfo)&gt;</body><body>GetLastError	&lt;C:DWORD GetLastError(void)&gt;</body><body>RegCreateKey: hKey named: lpSubKey reserved: reserved class: lpClass options: dwOptions sam: samDesired security: lpSecurityAttributes result: phkResult disposition: lpdwDisposition 	&lt;C: long RegCreateKeyExW(unsigned long hKey,									wchar_t *  lpSubKey,									unsigned long  reserved,										wchar_t *lpClass,									unsigned long  dwOptions,									unsigned long  samDesired,									void * lpSecurityAttributes,									void ** phkResult,									unsigned long * lpdwDisposition)&gt;	^self externalAccessFailedWith: _errorCode</body><body>RegDeleteValueW: hKey name: lpszValueName	&lt;C: long RegDeleteValueW(void * hKey, WORD *lpszValueName)&gt;	^self externalAccessFailedWith: _errorCode</body><body>RegSetValueEx: hKey name: lpszValueName reserved: dwReserved type: dwType data: lpbData size: cbData	&lt;C: long RegSetValueExW( unsigned long hKey,								wchar_t *lpszValueName,								unsigned long dwReserved,								unsigned long dwType,								unsigned char *lpbData,								unsigned long cbData)&gt;	^self externalAccessFailedWith: _errorCode</body><body>SHFullScreen: hwndRequester with: dwState	&lt;C:__bool int SHFullScreen(HWND hwndRequester, DWORD dwState)&gt;</body><body>SHSipPreferenceForWindow: windowHandle state: sipState	&lt;C: __bool int SHSipPreference(HWND windowHandle,int sipState)&gt;</body><body>SipEnumIM: arg	&lt;C: int SipEnumIM(IMENUMPROC)&gt;	^self externalAccessFailedWith: _errorCode</body><body>SipGetCurrentIM: arg	&lt;C: int SipGetCurrentIM(CLSID * )&gt;	^self externalAccessFailedWith: _errorCode</body><body>SipRegisterNotification: arg	&lt;C: int SipRegisterNotification(void * )&gt;	^self externalAccessFailedWith: _errorCode</body><body>SipSetCurrentIM: arg	&lt;C: int SipSetCurrentIM(CLSID * )&gt;	^self externalAccessFailedWith: _errorCode</body><body>SipSetDefaultRect: arg	&lt;C: int SipSetDefaultRect(RECT * )&gt;	^self externalAccessFailedWith: _errorCode</body><body>SipSetInfo: arg	&lt;C: __bool int SipSetInfo(SIPINFO * )&gt;	^self externalAccessFailedWith: _errorCode</body><body>SipShowIM: arg	&lt;C: int SipShowIM(unsigned long)&gt;	^self externalAccessFailedWith: _errorCode</body><body>SipStatus: argArray	&lt;C: unsigned long SipStatus(...)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>OS.WinCESystemSupport</class-id> <category>accessing</category><body>SipGetInfo: arg	&lt;C: _bool int SipGetInfo(SIPINFO * )&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>OS.WinCESystemSupport</class-id> <category>utilities</category><body>SHSipPreference:  windowHandle with: st	&lt;C:__bool int SHSipPreference (HWND windowHandle, int st)&gt;</body></methods><initialize><class-id>OS.PCFilename</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category></class><class><name>Window</name><environment>Graphics</environment><super>Graphics.DisplaySurface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inputOrigin creationOrigin sensor iconic windowType effectiveWindowType statusLineHeight allowsStatusLine mapped eventHandlers windowManager </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category></class><class><name>TransientWindow</name><environment>UI</environment><super>Graphics.Window</super><private>false</private><indexed-type>none</indexed-type><inst-vars>component paintPreferences isEventDriven controller </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category></class><class><name>NTFSFilename</name><environment>OS</environment><super>OS.PCFilename</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-PC</category></class><class><name>ScreenGraphicsContext</name><environment>Graphics</environment><super>Graphics.GraphicsContext</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Support</category></class><class><name>OSSystemSupport</name><environment>OS</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			OS.OSSystemSupportDictionary.*			</imports><category>OS-Support</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel></attributes></class><class><name>SocketAccessor</name><environment>OS</environment><super>OS.BlockableIOAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>concreteClass </class-inst-vars><imports></imports><category>OS-Sockets</category></class><class><name>ScheduledWindow</name><environment>UI</environment><super>Graphics.Window</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label icon minimumSize maximumSize component lookPreferences paintPreferences edgeDecorationPolicy widgetPolicy controller model damageRepairPolicy masterWindow </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category></class><class><name>Event</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>time initiator window </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events</category></class><class><name>ExposeEvent</name><environment>UI</environment><super>UI.ResizeEvent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>buttonNumber </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events</category></class><class><name>WindowManager</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>windows activeController interruptLock outstandingMetaOrDamage openInProgress eventQueue baseProcess dontFilterEvents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category></class></st-source>