<?xml version="1.0"?><st-source><!-- Name: StoreForPostgreSQLComment: ©Bruce Badger 2000 - 2004. Licensed under the LGPL.This package allows you to use PostgreSQL with StORE.For details on setting up and using a PostgreSQL StORE reporitory, please visit:	http://wiki.cs.uiuc.edu/VisualWorks/PostgreSQL+Librariesand    http://wiki.cs.uiuc.edu/VisualWorks/StORE+for+PostgreSQL+Documentation- - Please send your comments to bbadger@openskills.com.  Thanks.DbIdentifier: OSSYD001DbTrace: 2206DevelopmentPrerequisites: #(#(#any 'PostgreSQLEXDI' '') #(#any 'StoreBase' ''))PackageName: StoreForPostgreSQLParcel: #('StoreForPostgreSQL')ParcelName: StoreForPostgreSQLPrerequisiteParcels: #(#('PostgreSQLEXDI' '') #('StoreBase' ''))PrintStringCache: (1.3 014,bbadger)Version: 1.3 014Date: 8:03:29 pm November 4, 2004 --><time-stamp>From VisualWorks® NonCommercial, 7.2 of November 3, 2003 on November 4, 2004 at 8:03:29 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>PostgreSQLServerBroker</name><environment>Store</environment><super>Store.SQLBroker</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>typeToStringMap blobReadConnectionPair </class-inst-vars><imports></imports><category>Store-PostgreSQL</category><attributes><package>StoreForPostgreSQL</package></attributes></class><class><name>SQLAssistPostgreSQLServer</name><environment>Store</environment><super>Store.SQLAssist</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-PostgreSQL</category><attributes><package>StoreForPostgreSQL</package></attributes></class><class><name>StoreForPostgreSQLTest</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-PostgreSQL</category><attributes><package>StoreForPostgreSQL</package></attributes></class><shared-variable><name>Signals</name><environment>Store.PostgreSQLServerBroker</environment><private>false</private><constant>false</constant><category>signals</category><attributes><package>StoreForPostgreSQL</package></attributes></shared-variable><methods><class-id>Store.PostgreSQLServerBroker class</class-id> <category>private</category><body package="StoreForPostgreSQL">messageFor: exception 	"^a StringI override this because my superclass implementation can't handle exceptions with parameters that do not respond to &gt;&gt;isEmpty.  Evaluate the following string to check that this implementation is OK."	"[OSErrorHolder peerFaultSignal raiseRequestWith: 42] on: OSErrorHolder peerFaultSignal do: [:exception| PostgreSQLServerBroker messageFor: exception]."	| errs msg |	self uglyMethod.	exception signal == self connectionClass authenticationFailureSignal 		ifTrue: [^exception errorString].	(errs := exception parameter) notNil 		ifTrue: 			[(errs isKindOf: Error) ifTrue: [^errs errorString].			((errs respondsTo: #isEmpty) and: 					[errs isEmpty not and: 							[(msg := (exception parameter at: 1) dbmsErrorString) notNil 								and: [msg isEmpty not]]]) 				ifTrue: [^msg]				ifFalse: [^exception errorString]]		ifFalse: [^exception errorString]</body><body package="StoreForPostgreSQL">resetTypeToStringMap	"^self 	I reset the directory of PostgreSQL data types keyed on StORE data 	type symbols."	"PostgreSQLServerBroker resetTypeToStringMap"	typeToStringMap := nil.	^self</body><body package="StoreForPostgreSQL">typeToStringMap	"^a Dictionary 	I return my dictionary of type mappings. The key is the Store type symbol, and the value is the 	string used to define that type to PostgreSQL."	typeToStringMap isNil ifTrue: [typeToStringMap := (Dictionary new)		at: #String put: 'varchar (255) null';		at: #PrimaryKey put: 'integer not null'; 		at: #PrimaryKeyInteger put: 'integer not null'; 		at: #PrimaryKeyString put: 'varchar (255) not null'; 		at: #PrimaryKeyShortString put: 'varchar (50) not null'; 		at: #PrimaryKeyChar put: 'char(1)'; 		at: #Text put: 'text null'; 		at: #Long put: 'integer null'; 		at: #BinData put: 'bytea'; 		at: #Integer put: 'integer null'; 		at: #Char put: 'char(1)'; 		at: #String32 put: 'varchar (32)'; 		yourself].	^typeToStringMap</body><body package="StoreForPostgreSQL">uglyMethod	"^self 	This is a no-op, but it's a way of marking the methods I want to do 	more work on. To find the ugly methods, browse senders of this 	method."	^self</body></methods><methods><class-id>Store.PostgreSQLServerBroker class</class-id> <category>create objects</category><body package="StoreForPostgreSQL">createDatabaseSequence: aClass 	"^self 	I create the sequence in the database for aClass."	self performCreate: 			[self 				processSQL: 'CREATE SEQUENCE ' , (self sequenceNameWithPrefix: aClass)]		for: aClass name</body><body package="StoreForPostgreSQL">createDatabaseTable: aClass 	"^self 	I create the tables in the database which correspond to aClass."	| aKeyCollection aStream |	aKeyCollection := OrderedCollection new.	aStream := (String new: 100) writeStream.	aStream nextPutAll: (self createDatabaseTableColumnsFor: aClass keyNames: aKeyCollection).	aStream nextPutAll: (self createTablePrimaryKeySectionFor: aClass keys: aKeyCollection).	self createTable: (self tableNameWithPrefix: aClass)		columns: '(' , aStream contents</body><body package="StoreForPostgreSQL">createTablePrimaryKeySectionFor: aClass keys: aKeyCollection 	"a String 	I return a string which is the SQL clause declaring the primary key for aClass."	| aStream pkStream |	aStream := (String new: 100) writeStream.	aKeyCollection isEmpty		ifFalse: 			[aStream nextPutAll: 'PRIMARY KEY ('.			pkStream := (String new: 100) writeStream.			aKeyCollection do: [:each | pkStream nextPutAll: each , ', '].			pkStream skip: -2.			aStream nextPutAll: pkStream contents , ')'].	aStream nextPut: $).	^aStream contents</body><body package="StoreForPostgreSQL">createViewForClass: aClass 	"^self 	I create a virtual table that represents an alternative way of looking at the data in one or more 	tables. You can use views as security mechanisms by granting permission on a view but not on 	underlying tables."	self createView: (self tableName: aClass)		selectStatement: (self createViewSelectSQLForClass: aClass).	^self</body><body package="StoreForPostgreSQL">installPhysicalSpaces	"^a Boolean 	For PostgreSQL, this is a no-op (at least for now)."	^true</body><body package="StoreForPostgreSQL">permissionsForSequence	"Answer an array of permissions to grant to sequence tables."	^#( 'SELECT' 'UPDATE' ).</body></methods><methods><class-id>Store.PostgreSQLServerBroker class</class-id> <category>connection class</category><body package="StoreForPostgreSQL">connectionClass	"^a Class 	I return the connection class I use to get to the PostgreSQL database."	^PostgreSQLEXDIConnection</body></methods><methods><class-id>Store.PostgreSQLServerBroker class</class-id> <category>blob handling</category><body package="StoreForPostgreSQL">blobReadConnection	"^a PostgreSQLConnection 	I return the blob read connection. This has to be a different connection from the primary EXDI 	connection used by store to avoid side-effects caused by the need to read blobs inside a 	transaction."	blobReadConnectionPair isNil 		ifTrue: 			[blobReadConnectionPair := self primaryEXDIConnection -&gt; nil.			blobReadConnectionPair value: self newBlobReadConnection]		ifFalse: 			[(blobReadConnectionPair value isNil 				or: [blobReadConnectionPair key ~= self primaryEXDIConnection]) 					ifTrue: [blobReadConnectionPair value: self newBlobReadConnection]].	^blobReadConnectionPair value</body><body package="StoreForPostgreSQL">closeBlobReadConnection	"^self 	I close the blob read connection if there is one."	self uglyMethod.	blobReadConnectionPair value notNil		ifTrue: 			[1 halt.			blobReadConnectionPair value close.			blobReadConnectionPair value: nil].	^self</body><body package="StoreForPostgreSQL">newBlobReadConnection	"^a PostgreSQLConnection 	I close the existing blob read connection (if any) and create a new one."	self closeBlobReadConnection.	^PostgreSQLConnection using: self primaryEXDIConnection connection parameters</body><body package="StoreForPostgreSQL">primaryEXDIConnection	"^a PostgreSQLEXDIConnection 	I return the primary connection through which StORE talks to the database."	^self connection</body></methods><methods><class-id>Store.PostgreSQLServerBroker class</class-id> <category>private-accessing</category><body package="StoreForPostgreSQL">dismissSession: aSession 	"^self 	I dismiss my current session."	^aSession dismiss</body><body package="StoreForPostgreSQL">getNewSession	"^a PostgreSQLEXDISession 	I return a new PostgreSQL EDXI session. I set the translation block 	for handling BLOBs."	| newSession |	newSession := super getNewSession.	^newSession</body><body package="StoreForPostgreSQL">sequenceNameWithPrefix: aClass 	"^a String 	I return the name of the squence for aClass."	^(self tableNameWithPrefix: aClass)		, '_sequence'</body></methods><methods><class-id>Store.PostgreSQLServerBroker class</class-id> <category>grant statements</category><body package="StoreForPostgreSQL">grant: aPermissionList on: aTableName columnList: aColumnList to: aUserNameList 	"^self 	I generate a grant statement which allows the users in aUserNameList to perform the actions 	specified in aPermissionList on aTableName. PostgeSQL does not currently support granting 	permissions to individual columns, so the GRANT applies to all columns in aTableName."	| aStream |	aStream := (String new: 100) writeStream.	aStream nextPutAll: 'GRANT '.	aPermissionList do: [:each | aStream nextPutAll: each , ', '].	aStream skip: -2.	aStream nextPutAll: ' ON ' , aTableName.	aStream nextPutAll: ' TO '.	aUserNameList do: [:each | aStream nextPutAll: each , ', '].	aStream skip: -2.	self processGrantStatement: aStream contents</body><body package="StoreForPostgreSQL">grantSequencePermissionsOn: aClass 	self		grant: #('SELECT' 'UPDATE')		on: (self sequenceNameWithPrefix: aClass)		to: #('PUBLIC')</body><body package="StoreForPostgreSQL">processGrantStatement: aString 	"^self 	I execute the grant statement in aString on the server. For now, if there are any problems I just let 	the exception go unhandled."	self processSQL: aString.	^self</body></methods><methods><class-id>Store.PostgreSQLServerBroker class</class-id> <category>accessing</category><body package="StoreForPostgreSQL">fullTableName: aClass 	"^a String 	I simply return the table name with prefix."	^self tableNameWithPrefix: aClass</body><body package="StoreForPostgreSQL">getBlobData: aData 	"^a ByteArray 	I return aData (a ByteArray) in the form in which the PostgerSQL EXDI interface demands for BLOB 	data - a ByteArray is fine, so I just return that."	^aData</body><body package="StoreForPostgreSQL">maxLongBytes	"^an Integer 	PostgreSQL is limited to 8k on each row. In addition, because binary 	data must be encoded as Base 64, the practical limit is 5.5k. The 	StORE default is to try 32k, so in a worst case, this could mean 	having many more rows in the database than necessary, but in 	practice most items StORE wishes to, er, store are &lt; 5.5k."	^5500</body><body package="StoreForPostgreSQL">needsSequenceFor: aClass 	"^false 	PostgreSQL has an object ID (oid) for every row in the database, so 	sequence numbers should be redundant. The problem is that to 	make use of the row oid would require a schema change, and that 	not an option for now.""hello"	^aClass needsSequence</body><body package="StoreForPostgreSQL">sequenceGeneratorSession: existingSession forClass: aClass 	"^a PostgreSQLStoreSequenceGenerator 	I return a session which is primed to answer new IDs for aClass 	when executed."	existingSession notNil ifTrue: [existingSession dismiss].	^self		safelyExecuteBlock: 			[| newSession |			newSession := self getNewSession.			newSession prepare: (self nextIDQuery: aClass).			newSession]</body><body package="StoreForPostgreSQL">tableNameWithPrefix: aClass 	"^a ByteString 	I return the name of the table in form suitable for PostgreSQL, and that means *without* a prefix."	^self tableName: aClass</body></methods><methods><class-id>Store.PostgreSQLServerBroker class</class-id> <category>queries</category><body package="StoreForPostgreSQL">newSQLFor: aClass 	"^a SQLAssistPostgreSQLServer 	I return an assistant to help generating the SQL to manipulate the contents of the table for aClass."	^self sqlAssistClass newSQLFor: aClass table: (self tableNameWithPrefix: aClass)</body><body package="StoreForPostgreSQL">nextIDQuery: aClass 	"^a String 	I return the string of SQL that will get the next number in sequence 	for aClass."	^'select nextval(''' , (self sequenceNameWithPrefix: aClass) , ''');'</body><body package="StoreForPostgreSQL">sqlAssistClass	"^SQLAssistPostgreSQLServer 	I return the class whose instances know how to generate SQL queries for the PostgreSQL DBMS."	^SQLAssistPostgreSQLServer</body></methods><methods><class-id>Store.PostgreSQLServerBroker class</class-id> <category>sql processing</category><body package="StoreForPostgreSQL">safelyExecuteBlock: aBlock 	"^self 	It seems that 'safely' in this context means: show the database busy cursor and look out for 'brokerSignals' and other exceptions.  Note that the halt is there because in some cases exceptions have been silently squashed, leaving no trace - I'd prefer to know what's happening.  This position should be reviewed at each release of StORE."	self uglyMethod.	DbRegistry isOnline 		ifFalse: [^self currentlyNotConnectedSignal raiseSignal].	^	[[Cursor database showWhile: [aBlock value]] on: self brokerSignals		do: 			[:exception | 			Transcript				show: (self messageFor: exception);				cr.			DbRegistry goOffLine.			(Dialog confirm: 'Currently disconnected. Do you want to reconnect?') 				ifTrue: [DbRegistry reconnect ifTrue: [exception retry]].			exception resignalAs: self currentlyNotConnectedSignal raiseSignal]] 			on: UnhandledException			do: 				[:ex | 				self halt: 'UnhandledException during SQL processing.'.				self processPublishException: ex note: ''.				self currentlyNotConnectedSignal raiseSignal.				^nil]</body></methods><methods><class-id>Store.PostgreSQLServerBroker class</class-id> <category>error handling</category><body package="StoreForPostgreSQL">brokerSignals	"self brokerSignals"	^Signals isNil 		ifTrue: [ Signals := self signalCollection]		ifFalse: [ Signals ]</body><body package="StoreForPostgreSQL">databaseName	^'PostgreSQL'</body><body package="StoreForPostgreSQL">signalCollection	"^an ExceptionSetI return the set of exceptions for which I will assume that the connection with the backend is broken."	^(ExceptionSet new: 6)		add: self connectionClass unableToExecuteSQLSignal;		add: self connectionClass connectionNotOpenSignal;		add: self connectionClass externalDatabaseInformationSignal;		add: self connectionClass externalDatabaseErrorSignal;		add: self connectionClass unableToPrepareSignal;		add: OSErrorHolder peerFaultSignal;		yourself</body></methods><methods><class-id>Store.PostgreSQLServerBroker class</class-id> <category>obsolete</category><body package="StoreForPostgreSQL">createPhysicalSpaces	"^a Boolean	For compatability with pre-5i.3 only. See&gt;&gt;installPhysicalSpaces"	^self installPhysicalSpaces</body></methods><methods><class-id>Store.PostgreSQLServerBroker class</class-id> <category>drop objects</category><body package="StoreForPostgreSQL">dropDatabase: dbName	Transcript show: 'Dropping database ' , dbName; cr.	self performDrop: [ self processSQL:  ('DROP DATABASE ', dbName)]		for: dbName.	Transcript show: 'Database dropped'; cr.</body><body package="StoreForPostgreSQL">dropDatabaseFor: aClass	self dropDatabase: aClass databaseName</body><body package="StoreForPostgreSQL">dropIndexForClass: aClass	self dropIndexForClass: aClass index: aClass indexName.</body><body package="StoreForPostgreSQL">dropIndexForClass: aClass index: aName	self performDrop:[self processSQL: 'DROP INDEX ' , aName]		for: (aClass name, aName)</body><body package="StoreForPostgreSQL">dropSequenceForClass: aClass 	Transcript show: 'Dropping sequence for ' , aClass name; cr.	self performDrop: [self processSQL: 'DROP SEQUENCE ' , (self sequenceNameWithPrefix: aClass)]		for: aClass name</body><body package="StoreForPostgreSQL">dropTableForClass: aClass 	self dropTable: (self tableNameWithPrefix: aClass)</body><body package="StoreForPostgreSQL">dropUser: aName	Transcript show: 'Dropping user ' , aName; cr.	self performDrop: [ self processSQL:  ('DROP USER ', aName )]		for: aName</body><body package="StoreForPostgreSQL">dropViewForClass: aClass	self dropView: (self tableNameWithPrefix: aClass)</body></methods><methods><class-id>Store.PostgreSQLServerBroker class</class-id> <category>initialize</category><body package="StoreForPostgreSQL">initialize	"^self 	I initialize myself. For now, this just involves telling the PostgreSQLEXDIConnection class that I am 	the 'store broker'"	"PostgreSQLServerBroker initialize"	PostgreSQLEXDIConnection storeBroker: self.	^self</body></methods><methods><class-id>Store.SQLAssistPostgreSQLServer</class-id> <category>private</category><body package="StoreForPostgreSQL">removePrimaryKeyColumn: anArray 	"^an Array 	PostgreSQL supports a 'serial' column type which automaticaly adds 	in an id which is unique within a table. It would be nicer still to use 	the PostgreSQL (oid) object id which every row has, and which is 	unique within the PostgreSQL instance.""	^anArray select: [:col | (col equivalentTo: 'primarykey' ignoreCase: true) not]"	^anArray</body><body package="StoreForPostgreSQL">removePrimaryKeyValue: anArray 	"^an Array 	c.f. self&gt;&gt;removePrimaryKeyColumn:."	"^anArray select: [:col | (col equivalentTo: ':primarykey' ignoreCase: true) not]"	^anArray</body></methods><methods><class-id>StoreForPostgreSQLTest class</class-id> <category>testing</category><body package="StoreForPostgreSQL">test01	"^self 	Force DBAccess to make a new connection."	"self test01"	^Store.DBAccess new setConnection</body><body package="StoreForPostgreSQL">test02	"^self 	Install the Store database tables in PostgreSQL."	"self test02"	ExternalDatabaseConnection traceLevel: 0.	Store.PostgreSQLServerBroker resetTypeToStringMap.	Store.DbRegistry installDatabaseTables.	^self</body><body package="StoreForPostgreSQL">test03	"^self 	Install the a package into StORE."	"self test03"	(Parcel parcelNamed: 'PostgreSQLDriver') asPackage.	^self</body></methods><initialize><class-id>Store.PostgreSQLServerBroker</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>SQLBroker</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Broker</category><attributes><package>Store-DB-Broker</package></attributes></class><class><name>SQLAssist</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tableName tableClass sqlStream alias </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-DB-Broker</category><attributes><package>Store-DB-Broker</package></attributes></class></st-source>