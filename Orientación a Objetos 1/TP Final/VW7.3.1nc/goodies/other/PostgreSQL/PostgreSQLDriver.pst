<?xml version="1.0"?><st-source><!-- Name: PostgreSQLDriverComment: ©Bruce Badger 2000 - 2004. Licensed under the LGPL.The classes in the PostgreSQLDriver package are the heart of the PostgreSQL library.  This is the portion of the library that has been ported to other Smalltalk dialects.  To see what kinds of thing the library can do, have a look at the methods in the protocol PostgreSQLTest class>tests.  Work though the test methods to get an idea of the capabilities of the driver, and of PostgreSQL.The driver operates at a fairly low level.  It is anticipated that most users will use a higher level interface, such as EXDI or GLORP.The PostgreSQLDriver is implemented in terms of the concepts described in the PostgreSQL Frontend/Backend protocol specification.  See the procuct documentation at www.postgresql.org.- - Please send your comments to bbadger@openskills.com.  Thanks.DbIdentifier: OSSYD001DbTrace: 2210DevelopmentPrerequisites: #(#(#any 'PostgreSQLVWCompatibility' ''))HideSource: falsePackageName: PostgreSQLDriverPackageName:: PostgreSQLDriverParcel: #('PostgreSQLDriver')PrerequisiteParcels: #(#('PostgreSQLVWCompatibility' ''))PrintStringCache: (1.3 014,bbadger)SaveSource: trueVersion: 1.3 014Date: 8:03:14 pm November 4, 2004 --><time-stamp>From VisualWorks® NonCommercial, 7.2 of November 3, 2003 on November 4, 2004 at 8:03:14 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>PostgreSQLSystemObject</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objectId name databaseRow </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>PostgreSQLSystemObject</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	objectId	&lt;ClassOfVariable&gt;	description of variable's function	name	&lt;ClassOfVariable&gt;	description of variable's function	databaseRow	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>PostgreSQLMessageStream</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection underlyingStream loggingBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><class><name>PostgreSQLTest</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>messageLog </class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>PostgreSQLTest</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>PostgreSQLDataType</name><environment>Smalltalk</environment><super>PostgreSQLSystemObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>PostgreSQLDataType</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>PostgreSQLConnection</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parameters socketSession stringEncodingName readStream writeStream backendKeyData dataTypeTable functionTable </inst-vars><class-inst-vars>activeConnections commonLog </class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>PostgreSQLConnection</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	parameters	&lt;ClassOfVariable&gt;	description of variable's function	externalConnection	&lt;ClassOfVariable&gt;	description of variable's function	readStream	&lt;ClassOfVariable&gt;	description of variable's function	writeStream	&lt;ClassOfVariable&gt;	description of variable's function	backendKeyData	&lt;ClassOfVariable&gt;	description of variable's function	dataTypeTable	&lt;ClassOfVariable&gt;	description of variable's function	functionTable	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>PostgreSQLException</name><environment>Smalltalk</environment><super>NativeError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>PostgreSQLException</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>PostgreSQLMessageReadStream</name><environment>Smalltalk</environment><super>PostgreSQLMessageStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><class><name>PostgreSQLSystemObjectTable</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>systemObjectsByObjectId systemObjectsByName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>PostgreSQLSystemObjectTable</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	systemObjectsByObjectId	&lt;ClassOfVariable&gt;	description of variable's function	systemObjectsByName	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>PostgreSQLFunctionTable</name><environment>Smalltalk</environment><super>PostgreSQLSystemObjectTable</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>PostgreSQLFunctionTable</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>PostgreSQLQueryResultList</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>query queryResults </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>PostgreSQLQueryResultList</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	queryResults	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>ConnectionContextElement</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contextParent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>ConnectionContextElement</class-id><body>The context within which data is exchanged with a PostgreSQL backend is critical.  For example, rows of data only make sense in the context of the row description message which preceeded it, and in turn, the row description only makes sense in the context of the query flow, which in turn executes in the context of a PostgreSQL connection.All of the subclasses of ConnectionContextElement know their immediate context parent.  At the root of a context tree is the PostgreSQL connection itself which is not a ConnectionContextElement, but knows how to behave like one (i.e. it supports the interface).The ConnectionContextElement has been finaly made explicit because of the need to correctly encode Strings.  The character encoding used for a given connection must be known to the most granular ConnectionContextElements, the PacketValues.  As the encoding is connection specific, a PacketValue must be able to work out its connection so the correct encoding is used.  This is done by navigating the context tree to it's root; the connection itself.Instance Variables:	contextParent	&lt;ConnectionContextElement or PostgreSQLConnection&gt;	the context within which an element exists.</body></comment><class><name>FieldDescription</name><environment>Smalltalk</environment><super>ConnectionContextElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name objectID typeSize typeModifier </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>FieldDescription</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	name	&lt;ClassOfVariable&gt;	description of variable's function	objectID	&lt;ClassOfVariable&gt;	description of variable's function	typeSize	&lt;ClassOfVariable&gt;	description of variable's function	typeModifier	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>AsciiField</name><environment>Smalltalk</environment><super>ConnectionContextElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bytes stringValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>AsciiField</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	bytes	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>PostgreSQLMessageFlow</name><environment>Smalltalk</environment><super>ConnectionContextElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><class><name>PostgreSQLTerminationMessageFlow</name><environment>Smalltalk</environment><super>PostgreSQLMessageFlow</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><class><name>PostgreSQLRequest</name><environment>Smalltalk</environment><super>PostgreSQLMessageFlow</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>PostgreSQLRequest</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	connection	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>PostgreSQLQuery</name><environment>Smalltalk</environment><super>PostgreSQLRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>queryMessage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>PostgreSQLQuery</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	queryMessage	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>PostgreSQLStartupMessageFlow</name><environment>Smalltalk</environment><super>PostgreSQLMessageFlow</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><class><name>PostgreSQLFunctionCall</name><environment>Smalltalk</environment><super>PostgreSQLRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>functionCallMessage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>PostgreSQLFunctionCall</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	functionCallMessage	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>PostgreSQLRequestResult</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>request </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>PostgreSQLRequestResult</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	request	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>PostgreSQLFunctionCallResult</name><environment>Smalltalk</environment><super>PostgreSQLRequestResult</super><private>false</private><indexed-type>none</indexed-type><inst-vars>functionResponse </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>PostgreSQLFunctionCallResult</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	functionResponse	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>PostgreSQLQueryResult</name><environment>Smalltalk</environment><super>PostgreSQLRequestResult</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cursorResponse rowDescription rows completedResponses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>PostgreSQLQueryResult</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	cursorResponse	&lt;ClassOfVariable&gt;	description of variable's function	rowDescription	&lt;ClassOfVariable&gt;	description of variable's function	rows	&lt;ClassOfVariable&gt;	description of variable's function	completedResponses	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>PacketValue</name><environment>Smalltalk</environment><super>ConnectionContextElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value bytes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>PacketValue</class-id><body>Copyright © 2000, 2002, 2003  Bruce Badger. All Rights Reserved.All values flowing between over the frontend/backend protocol are passes as instances of my subclasses.  Translations between the bytes passed over the wire and instances of Strings and Integers happens here.  The exception to the translation rule is ByteValue, which does no translation at all - ByteValues on the wire map byte-for-byte to ByteArray instances.String translations are based upon the character encoding known to the PostgreSQLConnection instance in whose context the value exists.  This affects LimStringValue and StringValue.'PacketValue's are intended to be very short-lived, and should not be passed outside of the PostgreSQL driver layer.Instance Variables:	value	&lt;ClassOfVariable&gt;	The internal (Smalltalk) form of the value.	bytes	&lt;ClassOfVariable&gt;	The external (wire) form of the value.</body></comment><class><name>FixedSizeValue</name><environment>Smalltalk</environment><super>PacketValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>numberOfBytes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>FixedSizeValue</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	numberOfBytes	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>LimStringValue</name><environment>Smalltalk</environment><super>FixedSizeValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>LimStringValue</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>ByteValue</name><environment>Smalltalk</environment><super>FixedSizeValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>ByteValue</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>BitMapValue</name><environment>Smalltalk</environment><super>FixedSizeValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>numberOfBits </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>BitMapValue</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	numberOfBits	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>IntValue</name><environment>Smalltalk</environment><super>FixedSizeValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>IntValue</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>StringValue</name><environment>Smalltalk</environment><super>PacketValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>StringValue</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Note that the bytes of a StringValue do *not* include the trailing null termination byte.  This is stripped off when the bytes are read, and added back on again when they are written out.Instance Variables:</body></comment><class><name>PostgreSQLDriverLicense</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>PostgreSQLDriverLicense</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:Class Variables:	TheLicense	&lt;ClassOfVariable&gt;	description of variable''s function</body></comment><class><name>PostgreSQLError</name><environment>Smalltalk</environment><super>PostgreSQLException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>PostgreSQLError</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>PostgreSQLErrorResponse</name><environment>Smalltalk</environment><super>PostgreSQLError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>PostgreSQLErrorResponse</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>PostgreSQLUnexpectedMessage</name><environment>Smalltalk</environment><super>PostgreSQLError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>PostgreSQLUnexpectedMessage</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>PostgreSQLUnsupportedFeature</name><environment>Smalltalk</environment><super>PostgreSQLError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>PostgreSQLUnsupportedFeature</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>PostgreSQLFunction</name><environment>Smalltalk</environment><super>PostgreSQLSystemObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>argumentTypes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>PostgreSQLFunction</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	argumentTypes	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>ConnectionParameterSet</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>host port userName password databaseName additionalArguments debuggingTTY </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>ConnectionParameterSet</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	host	&lt;ClassOfVariable&gt;	description of variable's function	port	&lt;ClassOfVariable&gt;	description of variable's function	userName	&lt;ClassOfVariable&gt;	description of variable's function	password	&lt;ClassOfVariable&gt;	description of variable's function	databaseName	&lt;ClassOfVariable&gt;	description of variable's function	additionalArguments	&lt;ClassOfVariable&gt;	description of variable's function	debuggingTTY	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>PostgreSQLDataTypeTable</name><environment>Smalltalk</environment><super>PostgreSQLSystemObjectTable</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>PostgreSQLDataTypeTable</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>PostgreSQLMessage</name><environment>Smalltalk</environment><super>ConnectionContextElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>subclassesByMessageIdentificationCode </class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>PostgreSQLMessage</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>PostgreSQLBackendMessage</name><environment>Smalltalk</environment><super>PostgreSQLMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>PostgreSQLBackendMessage</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>ReadyForQueryMessage</name><environment>Smalltalk</environment><super>PostgreSQLBackendMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>ReadyForQueryMessage</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>FunctionResponse</name><environment>Smalltalk</environment><super>PostgreSQLBackendMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>FunctionResponse</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>BackendKeyDataMessage</name><environment>Smalltalk</environment><super>PostgreSQLBackendMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>processID secretKey </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>BackendKeyDataMessage</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	processID	&lt;ClassOfVariable&gt;	description of variable's function	secretKey	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>EmptyQueryResponseMessage</name><environment>Smalltalk</environment><super>PostgreSQLBackendMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>EmptyQueryResponseMessage</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>ErrorResponseMessage</name><environment>Smalltalk</environment><super>PostgreSQLBackendMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>errorMessage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>ErrorResponseMessage</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	errorMessage	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>FunctionVoidResponse</name><environment>Smalltalk</environment><super>FunctionResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>FunctionVoidResponse</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>RMessage</name><environment>Smalltalk</environment><super>PostgreSQLBackendMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>subclassesByAuthenticationCode </class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>RMessage</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>AuthenticationOKMessage</name><environment>Smalltalk</environment><super>RMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>AuthenticationOKMessage</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved..Instance Variables:</body></comment><class><name>AuthenticationMD5PasswordMessage</name><environment>Smalltalk</environment><super>RMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>salt </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>AuthenticationMD5PasswordMessage</class-id><body>Copyright © 2002  Bruce Badger. All Rights Reserved.</body></comment><class><name>AuthenticationEncryptedPasswordMessage</name><environment>Smalltalk</environment><super>RMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>AuthenticationEncryptedPasswordMessage</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>AuthenticationKerberosV4Message</name><environment>Smalltalk</environment><super>RMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>AuthenticationKerberosV4Message</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>AsciiRowMessage</name><environment>Smalltalk</environment><super>PostgreSQLBackendMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fields </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>AsciiRowMessage</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	result	&lt;ClassOfVariable&gt;	description of variable's function	fields	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>PostgreSQLFrontendMessage</name><environment>Smalltalk</environment><super>PostgreSQLMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>PostgreSQLFrontendMessage</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>QueryMessage</name><environment>Smalltalk</environment><super>PostgreSQLFrontendMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>queryString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>QueryMessage</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	queryString	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>TerminateMessage</name><environment>Smalltalk</environment><super>PostgreSQLFrontendMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>TerminateMessage</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	connection	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>StartupPacket</name><environment>Smalltalk</environment><super>PostgreSQLFrontendMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection packetSize protocolVersionNumber databaseName userName additionalArguments debuggingTTY </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>StartupPacket</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	connection	&lt;ClassOfVariable&gt;	description of variable's function	packetSize	&lt;ClassOfVariable&gt;	description of variable's function	protocolVersionNumber	&lt;ClassOfVariable&gt;	description of variable's function	databaseName	&lt;ClassOfVariable&gt;	description of variable's function	userName	&lt;ClassOfVariable&gt;	description of variable's function	additionalArguments	&lt;ClassOfVariable&gt;	description of variable's function	debuggingTTY	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>FunctionCallPacket</name><environment>Smalltalk</environment><super>PostgreSQLFrontendMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>function arguments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>FunctionCallPacket</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	function	&lt;ClassOfVariable&gt;	description of variable's function	arguments	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>PasswordPacket</name><environment>Smalltalk</environment><super>PostgreSQLFrontendMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packetSize passwordBytes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><class><name>AuthenticationUnencryptedPasswordMessage</name><environment>Smalltalk</environment><super>RMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>AuthenticationUnencryptedPasswordMessage</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>CursorResponseMessage</name><environment>Smalltalk</environment><super>PostgreSQLBackendMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cursorName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>CursorResponseMessage</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	cursorName	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>RowDescriptionMessage</name><environment>Smalltalk</environment><super>PostgreSQLBackendMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>numberOfFields fieldDescriptions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>RowDescriptionMessage</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	numberOfFields	&lt;ClassOfVariable&gt;	description of variable's function	fieldDescriptions	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>AuthenticationKerberosV5Message</name><environment>Smalltalk</environment><super>RMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>AuthenticationKerberosV5Message</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>FunctionResultResponse</name><environment>Smalltalk</environment><super>FunctionResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>FunctionResultResponse</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	value	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>NoticeResponseMessage</name><environment>Smalltalk</environment><super>PostgreSQLBackendMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>message </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>NoticeResponseMessage</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	message	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>PostgreSQLAbstractCompletedResponseMessage</name><environment>Smalltalk</environment><super>PostgreSQLBackendMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>commandTag </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><class><name>CompletedInsertResponseMessage</name><environment>Smalltalk</environment><super>PostgreSQLAbstractCompletedResponseMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><class><name>CompletedResponseMessage</name><environment>Smalltalk</environment><super>PostgreSQLAbstractCompletedResponseMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>CompletedResponseMessage</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	commandTag	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>PostgreSQLNoticeResponse</name><environment>Smalltalk</environment><super>PostgreSQLException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><comment><class-id>PostgreSQLNoticeResponse</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>PostgreSQLMessageWriteStream</name><environment>Smalltalk</environment><super>PostgreSQLMessageStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Driver</category><attributes><package>PostgreSQLDriver</package></attributes></class><shared-variable><name>TheLicense</name><environment>PostgreSQLDriverLicense</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>PostgreSQLDriver</package></attributes></shared-variable><methods><class-id>PostgreSQLSystemObject</class-id> <category>accessing</category><body package="PostgreSQLDriver">databaseRow	^databaseRow</body><body package="PostgreSQLDriver">name	"^a Symbol 	I return the name of the data type I represent as a Symbol. I'm using a symbol rather than a string 	because it's mofe efficient on look-up, and expect a lot of that to happen."	name isNil ifTrue: [name := self nameFromRow].	^name</body><body package="PostgreSQLDriver">objectId	"^an Integer 	I return the object ID (or oid) of the data type I represent. It is this number that gets used in the row 	descriptions returned by the back end."	objectId isNil ifTrue: [objectId := self objectIdFromRow].	^objectId</body></methods><methods><class-id>PostgreSQLSystemObject</class-id> <category>initialize-release</category><body package="PostgreSQLDriver">from: anAsciiRowMessage 	"^self 	I initialize myself to represent the data type described in anAsciiRowMessage."	databaseRow := anAsciiRowMessage.	^self</body></methods><methods><class-id>PostgreSQLSystemObject</class-id> <category>printing</category><body package="PostgreSQLDriver">printOn: aStream 	"^self 	I write a representation of myself to aStream."	super printOn: aStream.	aStream nextPut: $[.	self objectId printOn: aStream.	aStream nextPutAll: ', '.	self name printOn: aStream.	aStream nextPut: $].	^self</body></methods><methods><class-id>PostgreSQLSystemObject</class-id> <category>private</category><body package="PostgreSQLDriver">nameFromRow	"^a StringI return my name from the database row which describes me.  In fact, my subclasses must implement this."	^self subclassResponsibility</body><body package="PostgreSQLDriver">objectIdFromRow	"^an IntegerI return my oid from the database row which describes me.  In fact, my subclasses must implement this."	^self subclassResponsibility</body></methods><methods><class-id>PostgreSQLSystemObject class</class-id> <category>instance creation</category><body package="PostgreSQLDriver">from: anAsciiRowMessage 	"^a PostgreSQLDataType 	I return a new instance of myself to represent the data type described in anAsciiRowMessage."	^self new from: anAsciiRowMessage</body></methods><methods><class-id>PostgreSQLMessageStream</class-id> <category>initialize-release</category><body package="PostgreSQLDriver">on: aConnection	"^self 	I initialize myself to as a message stream for aConnection."	connection := aConnection.	^self</body></methods><methods><class-id>PostgreSQLMessageStream</class-id> <category>accessing</category><body package="PostgreSQLDriver">connection	"^a PostgreSQLConnection 	I return the connection in whose context I am a message Stream."	^connection</body></methods><methods><class-id>PostgreSQLMessageStream</class-id> <category>private</category><body package="PostgreSQLDriver">underlyingStream	"^a Stream 	I return my underlying read or write stream."	^self subclassResponsibility</body></methods><methods><class-id>PostgreSQLMessageStream</class-id> <category>logging</category><body package="PostgreSQLDriver">log: aMessage 	"^self 	I log the message using the current logging method as embodied in 	my &gt;&gt;loggingBlock."	self loggingBlock value: aMessage.	^self</body><body package="PostgreSQLDriver">loggingBlock	"^a BlockClosure 	I return the current logging block. By default, this is a no-op single 	argument block. Logging machinary can replace this block with 	behavior that actually does something."	loggingBlock isNil ifTrue: [loggingBlock := [:aMessage | ]].	^loggingBlock</body><body package="PostgreSQLDriver">loggingBlock: aBlockClosure 	"^self 	I record the current logging block. c.f. self&gt;&gt;loggingBlock."	loggingBlock := aBlockClosure.	^self</body></methods><methods><class-id>PostgreSQLMessageStream class</class-id> <category>instance creation</category><body package="PostgreSQLDriver">on: aConnection 	"^a PostgreSQLMessageStream 	I return a new instance of my subclasses initialized to as a message 	stream for aConnection."	^self new on: aConnection</body></methods><methods><class-id>PostgreSQLTest</class-id> <category>license</category><body package="PostgreSQLDriver">license	"^a License 	I return the license under which this software is made available."	^PostgreSQLDriverLicense license</body></methods><methods><class-id>PostgreSQLTest class</class-id> <category>testing</category><body package="PostgreSQLDriver">test	"^self 	Just run through all the tests."	"self test"	self messageLogReset.	self test01.	self test02.	self test03.	self test04.	self test05.	self test06.	self test07.	self test08.	self test09.	self test10.	self test11.	self test12.	self test13.	self test14.	self test27.	self test28.	self test30.	self test31.	self test32.	self test33.	self test34.	self test40.	^self messageLog contents</body><body package="PostgreSQLDriver">test01	"^a Connection 	I just create a connection, and then immediately close it."	"self test01"	| connection |	connection := PostgreSQLConnection using: self testParameterSet.	connection close.	^self</body><body package="PostgreSQLDriver">test02	"^self 	I create a connection, run an empty query, and then close the session."	"self test02"	| connection queryMessage |	connection := PostgreSQLConnection using: self testParameterSet.	queryMessage := connection newQuery.	queryMessage execute.	connection close.	^self</body><body package="PostgreSQLDriver">test03	"^self 	I create a connection, run a simple query (SELECT 1 + 3;), and then close the 	session."	"self test03"	| connection queryMessage result |	connection := PostgreSQLConnection using: self testParameterSet.	queryMessage := connection newQuery.	queryMessage queryString: 'SELECT 1 + 3;'.	result := queryMessage execute.	self showResults: result.	connection close.	^self</body><body package="PostgreSQLDriver">test04	"^self 	I create a table, populate it, query it and then drop it.  NOTE: table 'test04' must not exist prior to this test."	"self test04"	| connection |	connection := PostgreSQLConnection using: self testParameterSet.	self showResults: (connection 				executeQuery: 'create table test04 (a int2, b int2)').	self 		showResults: (connection executeQuery: 'insert into test04 values (1, 1)').	self 		showResults: (connection executeQuery: 'insert into test04 values (2, 1)').	self 		showResults: (connection executeQuery: 'insert into test04 values (3, 1)').	self showResults: (connection executeQuery: 'select a, b from test04').	self showResults: (connection executeQuery: 'drop table test04').	connection close.	^self</body><body package="PostgreSQLDriver">test05	"^self 	I create a table containing a column of each data type. I then insert a row into the table, query it and 	drop it."	"self test05"	| connection |	connection := PostgreSQLConnection using: self testParameterSet.	self showResults: (connection 				executeQuery: 'create table test05 (	textField		text,	varcharField		varchar(4),	charField		char(4),	integerField		integer,	int2Field		int2,	int8Field		int8,	oidField			oid,	numericField	numeric(6,2),	floatField		float,	float4Field		float4,	dateField		date,	timeField		time,	timestampField	timestamp,	intervalField		interval,	boolField		bool,	pointField		point,	lsegField		lseg,	pathField		path,	boxField		box,	circleField		circle,	polygonField	polygon,	inetField		inet,	cidrField		cidr,	macaddrField	macaddr,	byteArrayField	bytea)').	self showResults: (connection 				executeQuery: 'insert into test05(	textField,	varcharField,	charField,	integerField,	int2Field,	int8Field,	oidField,	numericField,	floatField,	float4Field,	dateField,	timeField,	timestampField,	intervalField,	boolField,	pointField,	lsegField,	pathField,	boxField,	circleField,	polygonField,	inetField,	cidrField,	macaddrField,	byteArrayField)values (	''Text value'',	''VC1'',	''C4'',	1234,	2468,	1248,	1357,	123.45,	0.1234,	123456.78,	''07-09-2000'',	''14:53:42'',	''07-09-2000 14:54:55'',	''4 05:00:30'',	''true'',	''(2,7)'',	''[(0,0),(1,3)]'',	''((0,0),(3,0),(4,5),(1,6))'',	''(1,1),(3,3)'',	''&lt;(1,2),60&gt;'',	''((3,1),(3,3),(1,0))'',	''192.168.1.12'',	''172.20.90.0/24'',	''0:50:4:1d:f6:db'',	''000'')').	self showResults: (connection executeQuery: 'select * from test05').	self showResults: (connection executeQuery: 'drop table test05').	connection close.	^self</body><body package="PostgreSQLDriver">test06	"^self 	I make a connection and then I get it's data type and function tables. 	This forces the connection to query the database it represents a 	connection to."	"self test06"	| connection dataTypes functions |	connection := PostgreSQLConnection using: self testParameterSet.	dataTypes := connection dataTypeTable.	self messageLog nextPutAll: dataTypes byObjectId printString.	functions := connection functionTable.	self messageLog nextPutAll: functions byObjectId printString.	connection close.	^self</body><body package="PostgreSQLDriver">test07	"^self 	I create a table containing a 'bytea' data type and populate it with 	some byte data which I then read back and make sure that I read 	the same thing that I wrote. I use only alphanumeric 'characters' in	the bytes so that they are writable to the bytea data type - which	 can't hold real bytes despite it's name."	"self test07"	| connection insertQuery sourceBytes queryResultList retrievedString sourceString |	connection := PostgreSQLConnection using: self testParameterSet.	NativeExceptionContext 		for: [self showResults: (connection executeQuery: 'drop table test07')]		on: PostgreSQLErrorResponse		do: [:exception | ].	self showResults: (connection 				executeQuery: 'create table test07 (integerField	integer,	byteArrayField bytea)').	sourceBytes := (ByteArray withAll: (0 to: 255)) 				select: [:byte | byte asCharacter isAlphaNumeric].	sourceString := String 				withAll: (sourceBytes asArray collect: [:aByte | aByte asCharacter]).	insertQuery := 'insert into test07 (	integerField, byteArrayField) values (1234, ''' 				, sourceString , ''')'.	self showResults: (connection executeQuery: insertQuery).	queryResultList := connection executeQuery: 'select * from test07'.	self showResults: queryResultList.	retrievedString := (queryResultList queryResults first rows first fields 				at: 2) bytes 				valueAsString.	self showResults: (connection executeQuery: 'drop table test07').	retrievedString = sourceString 		ifFalse: [PostgreSQLException raiseSignal: 'test07 failed'].	connection close.	^self</body><body package="PostgreSQLDriver">test08	"^a Connection 	I test to make sure that a bad login is handled OK. I call test08b 	which does the login and returns an exception. I check that the 	exception is the one I expect. 	This test is now written in this way to accomodate pre-ANSI 	GemStone exception handling."	"self test08"	| exception |	exception := self test08b.	(exception isNil or: [(exception messageText copyFrom: 1 to: 5)			~= 'FATAL'])		ifTrue: [PostgreSQLException raiseSignal: 'test08 failed'].	^self</body><body package="PostgreSQLDriver">test08b	"^a Connection 	I try to create a connection to a database that does not exist, I catch 	the exception and return it."	"self test08"	| parameterSet |	parameterSet := self testParameterSet.	parameterSet databaseName: 'DoesNotExist'.	NativeExceptionContext		for: [PostgreSQLConnection using: parameterSet]		on: PostgreSQLErrorResponse		do: [:exception | ^exception].	^nil</body><body package="PostgreSQLDriver">test09	"^a Connection 	I try to create a connection to a database that does not exist, I catch 	the exception and return it."	"self test09"	| parameterSet |	parameterSet := self testParameterSet.	parameterSet databaseName: 'DoesNotExist'.	NativeExceptionContext		for: [PostgreSQLConnection using: parameterSet]		on: PostgreSQLErrorResponse		do: [:exception | ^exception].	^nil</body><body package="PostgreSQLDriver">test10	"^self 	I use more sophisticated SQL to force some notification messages."	"self test10"	| connection |	connection := PostgreSQLConnection using: self testParameterSet.	[self showResults: (connection executeQuery: 'drop table test10;')] 		on: PostgreSQLErrorResponse		do: [:exception | ].	NativeExceptionContext 		for: 			[self showResults: (connection 						executeQuery: 'create table test10 (a int2, b int2, PRIMARY KEY(a))')]		on: PostgreSQLNoticeResponse		do: [:exception | exception resume].	self 		showResults: (connection executeQuery: 'insert into test10 values (1, 1)').	self 		showResults: (connection executeQuery: 'insert into test10 values (2, 1)').	self 		showResults: (connection executeQuery: 'insert into test10 values (3, 1)').	self showResults: (connection executeQuery: 'select a, b from test10').	self showResults: (connection executeQuery: 'drop table test10').	connection close.	^self</body><body package="PostgreSQLDriver">test11	"^self 	I include mutiple queries in a single &gt;&gt;executeQuery."	"self test11"	| connection |	connection := PostgreSQLConnection using: self testParameterSet.	self showResults: (connection 				executeQuery: 'select oid, relname from pg_class where relname = ''pg_class'' ;select oid, typname from pg_type where typname = ''bool'';').	connection close.	^self</body><body package="PostgreSQLDriver">test12	"^self 	I test logging in to a database which demands a pasword. I take the 	basic test parameter set and replace the database name to a secured 	database, and add the password. A database and user are created 	(and removed) for this test.	host         authtest     127.0.0.1  255.0.0.0         md5	The idea is to specifically demand that logins to the database authtest must use a password (clear text)."	"self messageLogReset. self test12. self messageLog contents"	| parameterSet connection queryMessage result |	connection := PostgreSQLConnection using: self testParameterSet.	NativeExceptionContext		for: 			[queryMessage := connection newQuery.			queryMessage queryString: 'drop user user12;'.			result := queryMessage execute.			self showResults: result]		on: PostgreSQLErrorResponse		do: [:exception | exception].	NativeExceptionContext		for: 			[queryMessage queryString: 'drop database authtest;'.			result := queryMessage execute.			self showResults: result]		on: PostgreSQLErrorResponse		do: [:exception | exception].	connection close.	connection := PostgreSQLConnection using: self testParameterSet.	queryMessage := connection newQuery.	queryMessage queryString: 'create database authtest;'.	result := queryMessage execute.	self showResults: result.	queryMessage := connection newQuery.	queryMessage queryString: 'create user user12 with password ''test12'';'.	result := queryMessage execute.	self showResults: result.	connection close.	parameterSet := self testParameterSet.	parameterSet databaseName: 'authtest'.	parameterSet userName: 'user12'.	parameterSet password: 'test12'.	connection := PostgreSQLConnection using: parameterSet.	self showResults: (connection executeQuery: 'select ''Logon OK using clear text password!'', 1+ 3;').	connection close.	(Delay forMilliseconds: 20) wait.	connection := PostgreSQLConnection using: self testParameterSet.	queryMessage := connection newQuery.	queryMessage queryString: 'drop user user12;'.	result := queryMessage execute.	self showResults: result.	queryMessage queryString: 'drop database authtest;'.	result := queryMessage execute.	self showResults: result.	connection close.	^self</body><body package="PostgreSQLDriver">test13	"^self 	I make multiple queries in a single &gt;&gt;executeQuery: where one of 	the queries causes an ErrorResponseMessage to be returned. What 	I'm looking for is to be able handle the exception and still get the 	results from the non-errored portions of the query - but I can't, 	because with this test PostgreSQL throws everything out at the 	compile stage - so nothing executes. I need a better test."	"self test13"	| connection |	connection := PostgreSQLConnection using: self testParameterSet.	NativeExceptionContext		for: [self showResults: (connection executeQuery: 'select oid, relname from pg_class where relname = ''pg_class'' ;select non_field1 from pg_class where relname = ''pg_class'' ;select oid, typname from pg_type where typname = ''bool'';')]		on: PostgreSQLErrorResponse		do: [:exception | exception].	connection close.	^self</body><body package="PostgreSQLDriver">test14	"^self 	I open a connection, do a simple query, and then close it - twice. The 	second closing should not raise an exception."	"self test14"	| connection |	connection := PostgreSQLConnection using: self testParameterSet.	NativeExceptionContext		for: [self showResults: (connection executeQuery: 'select 1+ 1;')]		on: PostgreSQLErrorResponse		do: [:exception | exception].	connection close.	connection close.	^self</body><body package="PostgreSQLDriver">test27	"^self 	I make a simple function call. This is a simple test of function calling."	"self test27"	| connection functionCall result |	connection := PostgreSQLConnection using: self testParameterSet.	functionCall := connection newFunctionCall.	functionCall function: (connection functionTable objectWithName: #timenow).	result := functionCall execute.	self showFunctionCallResult: result.	connection close.	^self</body><body package="PostgreSQLDriver">test28	"^self 	I directly manipulate a 'large object' (BLOB). The large object in question is actually a rather small 	ByteArray, but I perform every one of the provided functions on this object, viz: create (lo_creat), 	import(lo_import), export(lo_export), open (lo_open), write (lo_write), read (lo_read), seek (lo_lseek), 	close (lo_close) and delete/remove(lo_unlink).  Note that the literal ByteSymbol s are quoted to	make Squeak happy (otherwise it thinks the undersores in the function names are 'return' symbols)."	"self test28"	| connection testBlob functionCall result blobOid blobDescriptor retrievedBlob blobSize currentPosition |	connection := PostgreSQLConnection using: self testParameterSet.	self showResults: (connection executeQuery: 'begin').	functionCall := connection newFunctionCall.	functionCall 		function: (connection functionTable objectWithName: #'lo_creat').	functionCall 		addArgument: (ByteValue size: 4 value: (ByteArray withAll: #(0 6 0 0)) for: functionCall).	result := functionCall execute.	self showFunctionCallResult: result.	blobOid := result functionResponse value asIntValue.	functionCall := connection newFunctionCall.	functionCall function: (connection functionTable objectWithName: #'lo_open').	functionCall addArgument: blobOid.	functionCall 		addArgument: (ByteValue size: 4 value: (ByteArray withAll: #(0 6 0 0)) for: functionCall).	result := functionCall execute.	blobDescriptor := result functionResponse value asIntValue.	self showFunctionCallResult: result.	functionCall := connection newFunctionCall.	functionCall function: (connection functionTable objectWithName: #'lowrite').	functionCall addArgument: blobDescriptor.	testBlob := ByteArray withAll: (0 to: 200).	functionCall addArgument: (ByteValue size: testBlob size value: testBlob for: functionCall).	result := functionCall execute.	self showFunctionCallResult: result.	functionCall := connection newFunctionCall.	functionCall 		function: (connection functionTable objectWithName: #'lo_close').	functionCall addArgument: blobDescriptor.	result := functionCall execute.	self showFunctionCallResult: result.	functionCall := connection newFunctionCall.	functionCall function: (connection functionTable objectWithName: #'lo_open').	functionCall addArgument: blobOid.	functionCall 		addArgument: (ByteValue size: 4 value:  (ByteArray withAll: #(0 6 0 0)) for: functionCall).	result := functionCall execute.	blobDescriptor := result functionResponse value asIntValue.	self showFunctionCallResult: result.	functionCall := connection newFunctionCall.	functionCall function: (connection functionTable objectWithName: #'lo_tell').	functionCall addArgument: blobDescriptor.	result := functionCall execute.	currentPosition := result functionResponse value asIntValue value.	self showFunctionCallResult: result.	functionCall := connection newFunctionCall.	functionCall 		function: (connection functionTable objectWithName: #'lo_lseek').	functionCall addArgument: blobDescriptor.	functionCall addArgument: (IntValue size: 32 value: 0 for: functionCall).	functionCall addArgument: (IntValue size: 32 value: 2 for: functionCall).	result := functionCall execute.	self showFunctionCallResult: result.	functionCall := connection newFunctionCall.	functionCall function: (connection functionTable objectWithName: #'lo_tell').	functionCall addArgument: blobDescriptor.	result := functionCall execute.	blobSize := result functionResponse value asIntValue value.	self showFunctionCallResult: result.	functionCall := connection newFunctionCall.	functionCall 		function: (connection functionTable objectWithName: #'lo_lseek').	functionCall addArgument: blobDescriptor.	functionCall addArgument: (IntValue size: 32 value: currentPosition for: functionCall).	functionCall addArgument: (IntValue size: 32 value: 0  for: functionCall).	result := functionCall execute.	self showFunctionCallResult: result.	functionCall := connection newFunctionCall.	functionCall function: (connection functionTable objectWithName: #'loread').	functionCall addArgument: blobDescriptor.	functionCall addArgument: (IntValue size: 32 value: blobSize for: functionCall).	result := functionCall execute.	retrievedBlob := result functionResponse value bytes.	self showFunctionCallResult: result.	functionCall := connection newFunctionCall.	functionCall 		function: (connection functionTable objectWithName: #'lo_close').	functionCall addArgument: blobDescriptor.	result := functionCall execute.	self showFunctionCallResult: result.	functionCall := connection newFunctionCall.	functionCall 		function: (connection functionTable objectWithName: #'lo_unlink').	functionCall addArgument: (IntValue size: 32 value: blobOid value for: functionCall).	result := functionCall execute.	self showFunctionCallResult: result.	self showResults: (connection executeQuery: 'commit').	connection close.	blobSize = 201 ifFalse: [1 halt: 'The blob size shoule be 201!'].	retrievedBlob = testBlob 		ifFalse: [1 halt: 'These two should *not* be different!'].	^self</body><body package="PostgreSQLDriver">test30	"^self 	I test that I can make a multibyte database."	"self messageLogReset. self test30. self messageLog contents"	| connection result queryMessage |	connection := PostgreSQLConnection using: self testParameterSet.		[queryMessage := connection newQuery.	queryMessage queryString: 'drop database multibytetest;'.	result := queryMessage execute.	self showResults: result] 			on: PostgreSQLErrorResponse			do: [:exception | ].	queryMessage := connection newQuery.	queryMessage 		queryString: 'create database multibytetest with encoding = ''KOI8'';'.	result := queryMessage execute.	self showResults: result.	queryMessage := connection newQuery.	queryMessage queryString: 'drop database multibytetest;'.	result := queryMessage execute.	self showResults: result.	connection close.	^self</body><body package="PostgreSQLDriver">test31	"^self 	I make a KOI8 encoded database, create a test table and then delete it again."	"self messageLogReset. self test31. self messageLog contents"	| connection |	connection := PostgreSQLConnection using: self testParameterSet.		[self showResults: (connection executeQuery: 'drop database koi8test;')] 			on: PostgreSQLErrorResponse			do: [:exception | ].	self showResults: (connection executeQuery: 'create database koi8test with encoding = ''KOI8'';').	connection close.	connection := PostgreSQLConnection 				using: (self testParameterSet databaseName: 'koi8test').	self showResults: (connection executeQuery: 'create table test(string VARCHAR(3));').	connection close.	(Delay forMilliseconds: 100) wait.	connection := PostgreSQLConnection using: self testParameterSet.	self showResults: (connection executeQuery: 'drop database koi8test;').	connection close.	^self</body><body package="PostgreSQLDriver">test32	"^self 	I make a multibyte database, create a test table insert some KOI8 data into it, and read it back out.  Note that the short delay is needed after closing the KOI8 database and removing it (due to the backend session being a little slow to close).  This is a wierd test because I am putting KOI8 characters into a unicode string, and then allowing a #default encoding (probably UTF8) to send the data to the KOI8 encoded database - so the test is broken from a practical standpoint, but I think it's interesting anyway.  So there.  Tests 33 &amp; 34 make more sense."	"self messageLogReset. self test32. self messageLog contents"	| connection koi8Stream |	connection := PostgreSQLConnection using: self testParameterSet.		[self showResults: (connection executeQuery: 'drop database koi8test;')] 			on: PostgreSQLErrorResponse			do: [:exception | ].	self showResults: (connection executeQuery: 'create database koi8test with encoding = ''KOI8'';').	connection close.	connection := PostgreSQLConnection 				using: (self testParameterSet databaseName: 'koi8test').	self showResults: (connection executeQuery: 'create table test(string VARCHAR(3));').	koi8Stream := String new writeStream.	koi8Stream		nextPutAll: 'insert into test (string) values (''';		nextPut: (Character value: 244);		nextPut: (Character value: 245);		nextPut: (Character value: 246);		nextPutAll: ''');'.	self showResults: (connection executeQuery: koi8Stream contents).	self showResults: (connection executeQuery: 'select * from test;').	connection close.	(Delay forMilliseconds: 100) wait.	connection := PostgreSQLConnection using: self testParameterSet.	self showResults: (connection executeQuery: 'drop database koi8test;').	connection close.	^self</body><body package="PostgreSQLDriver">test33	"^self 	I make a multibyte database, create a test table insert some Unicode data 	into it. I try to get the backend to give me the results back in Unicode form."	"self messageLogReset. self test33. self messageLog contents"	| connection queryStream results testString |	connection := PostgreSQLConnection using: self testParameterSet.	[self showResults: (connection executeQuery: 'drop database unicodetest;')] 		on: PostgreSQLErrorResponse		do: [:exception | ].	self showResults: (connection 				executeQuery: 'create database unicodetest with encoding = ''UNICODE'';').	connection close.	connection := PostgreSQLConnection 				using: (self testParameterSet databaseName: 'unicodetest').	self showResults: (connection 				executeQuery: 'set client_encoding to ''UNICODE'';').	connection stringEncodingName: #'UTF-8'.	self showResults: (connection 				executeQuery: 'create table test(string VARCHAR(3));').	queryStream := String new writeStream.	testString := String 				with: (Character value: 16r0422)				with: (Character value: 16r0423)				with: (Character value: 16r0416).	queryStream		nextPutAll: 'insert into test (string) values (''';		nextPutAll: testString;		nextPutAll: ''');'.	self showResults: (connection executeQuery: queryStream contents).	results := connection executeQuery:  'select * from test;'.	results first rows first fields first asString = testString 		ifFalse: [1 halt: 'Oops - the strings should match'].	self showResults: results.	connection close.	(Delay forMilliseconds: 100) wait.	connection := PostgreSQLConnection using: self testParameterSet.	self showResults: (connection executeQuery:  'drop database unicodetest;').	connection close.	^self</body><body package="PostgreSQLDriver">test34	"^self 	OK, we make a KOI8 database with a simple table.  We set the driver encoding (this end) to KOI8 and write out some characters.  Then we tell PostgreSQL to use a client encoding of unicode, which maps to UTF8 at this end.  We read in the data from the table, and the characters should match."	"self messageLogReset. self test34. self messageLog contents"	| connection testString koi8Stream results |	connection := PostgreSQLConnection using: self testParameterSet.	[self showResults: (connection executeQuery: 'drop database koi8test;')] 			on: PostgreSQLErrorResponse			do: [:exception | ].	self showResults: (connection executeQuery: 'create database koi8test with encoding = ''KOI8'';').	connection close.	connection := PostgreSQLConnection using: (self testParameterSet databaseName: 'koi8test').	connection stringEncodingName: #'KOI8-U'.	self showResults: (connection executeQuery: 'create table test(string VARCHAR(3));').	testString := String with: (Character value: 16r0422)	with: (Character value: 16r0423) with: (Character value: 16r0416).	koi8Stream := String new writeStream.	koi8Stream 	nextPutAll: 'insert into test (string) values ('''; nextPutAll: testString; nextPutAll: ''');'.	self showResults: (connection executeQuery:  koi8Stream contents).	connection close.	connection := PostgreSQLConnection using: (self testParameterSet databaseName: 'koi8test').	self showResults: (connection executeQuery:  'set client_encoding to ''UNICODE'';').	connection stringEncodingName: #'UTF8'.	results := connection executeQuery:  'select * from test;'.	results first rows first fields first asString = testString 		ifFalse: [1 halt: 'Oops - the strings should match'].	self showResults: results.	connection close.	(Delay forMilliseconds: 100) wait.	connection := PostgreSQLConnection using: self testParameterSet.	self showResults: (connection executeQuery: 'drop database koi8test;').	connection close.	^self</body><body package="PostgreSQLDriver">test40	"^self 	Testing MD5 authentication.  Make sure that you have something like the following line in your pg_hba.conf file:	host         md5test     127.0.0.1  255.0.0.0         md5	The idea is to specifically demand that logins to the database md5test must use MD5 encoding for the password."	"self messageLogReset. self test40. self messageLog contents"	| connection |	connection := PostgreSQLConnection using: self testParameterSet.	[self showResults: (connection executeQuery: 'drop database md5test;')] 		on: PostgreSQLErrorResponse		do: [:exception | ].	[self showResults: (connection executeQuery: 'drop user md5user;')] 		on: PostgreSQLErrorResponse		do: [:exception | ].	self showResults: (connection executeQuery: 'create database md5test;').	self showResults: (connection 				executeQuery: 'create user md5user with password ''md5password'';').	connection close.	connection := PostgreSQLConnection using: ((self testParameterSet)						databaseName: 'md5test';						userName: 'md5user';						password: 'md5password';						yourself).	self showResults: (connection executeQuery: 'select ''Logon OK using MD5 password!'', 1+ 3;').	connection close.	(Delay forMilliseconds: 100) wait.	connection := PostgreSQLConnection using: self testParameterSet.	self showResults: (connection executeQuery: 'drop database md5test;').	self showResults: (connection executeQuery: 'drop user md5user;').	connection close.	^self</body></methods><methods><class-id>PostgreSQLTest class</class-id> <category>testing - defaults</category><body package="PostgreSQLDriver">testDatabaseName	"^String 	I return the name of the database to be used for testing. Some tests create (and then remove) their own databases, but for the rest, this is the name of the database to use."	^'test1'</body><body package="PostgreSQLDriver">testHost	"^a String 	I return the name of the host I'll connect to for testing."	"'192.168.10.236'"	"'192.168.1.12'"	"'192.168.10.211'"	^'localhost'</body><body package="PostgreSQLDriver">testParameterSet	"^a ConnectionParameterSet 	I return the connection parameter set to be used for all my tests. Edit this method to suit your 	environment."	| parameterSet |	parameterSet := ConnectionParameterSet new.	parameterSet		host: self testHost;		port: self testPort;		databaseName: self testDatabaseName;		userName: self testUserName;		password: self testPassword.	^parameterSet</body><body package="PostgreSQLDriver">testPassword	"^a String	I return the to use when testing."	^String new</body><body package="PostgreSQLDriver">testPort	"^an Integer 	I return the port number through which to connect to the PostgreSQL postmaster on &gt;&gt;testHost."	^5432</body><body package="PostgreSQLDriver">testUserName	"^a String 	I return the name of the user to be used for testing. This user must be very capable. The user must 	be able to create new databases and new users."	^'bbadger'</body></methods><methods><class-id>PostgreSQLTest class</class-id> <category>testing - support</category><body package="PostgreSQLDriver">messageLog	"^a WriteStream 	I return the current message log. This is intended for testing only."	messageLog isNil ifTrue: [messageLog := WriteStream on: String new].	^messageLog</body><body package="PostgreSQLDriver">messageLog: aStreamLikeThing 	"^self 	Set the message log to something more interesting than a stream."	"self messageLog: Transcript"	messageLog := aStreamLikeThing.	^self</body><body package="PostgreSQLDriver">messageLogReset	"^self 	Reset the message log. It will be initialized again the next time 	someone access it."	"self messageLogReset"	messageLog := nil.	^self</body><body package="PostgreSQLDriver">showFunctionCallResult: result 	"^self 	I display the results in a rather crude way."	self messageLog cr; nextPutAll: '================='; cr.	self messageLog nextPutAll: 'Function call ...'; cr.	self messageLog nextPutAll: result request functionCallPacket function name; cr.	self messageLog nextPutAll: 'Result size: ' , result functionResponse value numberOfBytes printString; cr.	self messageLog nextPutAll: 'Result value: ' , result functionResponse value value printString; cr.	self messageLog nextPutAll: '================='; cr.	^self</body><body package="PostgreSQLDriver">showResult: result 	"^self 	I display the results in a rather crude way."	(self messageLog)		cr;		nextPutAll: '=================';		cr.	result rowDescription isNil 		ifFalse: 			[result rowDescription fieldDescriptions do: 					[:aFieldDescription | 					(self messageLog)						nextPutAll: aFieldDescription name;						tab].			(self messageLog)				cr;				nextPutAll: '---------------';				cr.			result rows do: 					[:aRow | 					aRow fields do: 							[:aField | 							aField isNil 								ifTrue: 									[(self messageLog)										tab;										tab]								ifFalse: 									[(self messageLog)										nextPutAll: aField asString;										tab]].					self messageLog cr].			(self messageLog)				nextPutAll: '---------------';				cr].	result completedResponses do: 			[:aCompletedResponse | 			(self messageLog)				nextPutAll: aCompletedResponse commandTag;				nextPutAll: ' complete.';				cr].	(self messageLog)		nextPutAll: '=================';		cr.	^self</body><body package="PostgreSQLDriver">showResults: aResultList 	"^self 	I display the results in aResultList."	(self messageLog) cr; nextPutAll: '+++++++++++++++++++++++++'; cr.	(self messageLog) nextPutAll: aResultList query queryMessage queryString; cr.	aResultList do: [:aResult | self showResult: aResult].	(self messageLog) cr; nextPutAll: '+++++++++++++++++++++++++'; cr.	^self</body></methods><methods><class-id>PostgreSQLDataType</class-id> <category>private</category><body package="PostgreSQLDriver">nameFromRow	"^a StringI return my name from the database row which describes me."	^ (self databaseRow fields at: 2) asString asSymbol</body><body package="PostgreSQLDriver">objectIdFromRow	"^an IntegerI return my oid from the database row which describes me."	^self databaseRow fields first asString asNumber</body></methods><methods><class-id>PostgreSQLConnection</class-id> <category>testing</category><body package="PostgreSQLDriver">isActive	"^a Boolean 	I return true if I'm. I know this because a) I have an underlying connection, and b) it's active. I use basicSocketSession to avoid any lazy initialization of the socket session."	^self basicSocketSession notNil and: [self basicSocketSession isActive]</body><body package="PostgreSQLDriver">isClosed	"^a Boolean 	I return true if I have been closed. I know this because a) I have an 	underlying connection, and b) it's closed."	^self isActive not</body></methods><methods><class-id>PostgreSQLConnection</class-id> <category>initialize-release</category><body package="PostgreSQLDriver">close	"^self 	If I'm not already closed, I send a termination message and close my 	external interface. 	Thanks to Konrad Rosenbaum for suggesting trapping the 	OsTransferFaultError. This exception caused a problem with the Ad Hoc 	SQL tool when a postmaster shut while the Ad Hoc tool (and the 	PostgreSQL library) thought the connection was still open ... it was not 	possible to close the AdHoc tool in this situation."	self isClosed		ifFalse: 			[NativeExceptionContext				for: [(PostgreSQLTerminationMessageFlow for: self) initiate]				on: NativeExceptionContext brokenPipeException				do: [:exception | ].			self socketSession close].	^self</body><body package="PostgreSQLDriver">startup	"^self 	I create and initiate a startup message flow. The result of this will 	be an open connection to the back end."	(PostgreSQLStartupMessageFlow for: self) initiate.	^self</body><body package="PostgreSQLDriver">using: aParameterSet 	"^a Connection 	I initialize myself to represent the connection described by 	aParameterSet."	parameters := aParameterSet.	^self</body></methods><methods><class-id>PostgreSQLConnection</class-id> <category>services</category><body package="PostgreSQLDriver">connection	"^selfI can be passed around as a connection context.  All connection contexts must be able to answer the connection they are a part of.  I just return myself because, of course, I am the connection."	^self</body><body package="PostgreSQLDriver">encoding	"^a SymbolThis is just a convinience method for getting the symbol which names the string encoding to the used by the connection."	^self stringEncodingName</body><body package="PostgreSQLDriver">encoding: aSymbol 	"^selfThis is just a convinience method for setting the symbol which names the string encoding to the used by the connection."	^self stringEncodingName: aSymbol</body><body package="PostgreSQLDriver">executeQuery: aQueryString 	"^a PostgreSQLQueryResultList 	I create a query message execute it, then return the results."	| queryMessage |	queryMessage := self newQuery.	queryMessage queryString: aQueryString.	^queryMessage execute</body><body package="PostgreSQLDriver">newFunctionCall	"^a PostgreSQLFunctionCall 	I create and return a new function call which will operate in the context of myself."	^PostgreSQLFunctionCall for: self</body><body package="PostgreSQLDriver">newQuery	"^a PostgreSQLQuery 	I create and return a new query which will operate in the context of myself."	^PostgreSQLQuery for: self</body></methods><methods><class-id>PostgreSQLConnection</class-id> <category>private</category><body package="PostgreSQLDriver">dataTypeTableFromBackend	"^a PostgreSQLDataTypeTable 	I build a PostgreSQLDataTypeTable by querying the pg_type table of the database I represent a 	connection to. This operation may be moderately expensive."	^PostgreSQLDataTypeTable for: self</body><body package="PostgreSQLDriver">functionTableFromBackend	"^a PostgreSQLFunctionTable 	I build a PostgreSQLFunctionTable by querying the pg_proc table of the database I represent a 	connection to. This operation may be moderately expensive."	^PostgreSQLFunctionTable for: self</body></methods><methods><class-id>PostgreSQLConnection</class-id> <category>license</category><body package="PostgreSQLDriver">license	"^a License 	I return the license under which this software is made available."	^PostgreSQLDriverLicense license</body></methods><methods><class-id>PostgreSQLConnection</class-id> <category>private - sockets</category><body package="PostgreSQLDriver">basicSocketSession	"^an ExternalConnection or nil	Simply returns the current socket session."	^socketSession</body><body package="PostgreSQLDriver">readStream	"^a Stream 	I return the stream from which messages may be read from the back 	end."	readStream isNil ifTrue: [readStream := PostgreSQLMessageReadStream on: self].	^readStream</body><body package="PostgreSQLDriver">socketSession	"^an ExternalConnection 	I return an external connection. This represents the connection to 	the back end, and makes two streams available, one for reading 	from the back end, and one for writing to the back end. Both streams 	are set to operate in binary mode"	self basicSocketSession isNil 		ifTrue: 			[socketSession := NativeSocketSession openOnHost: self parameters host						port: self parameters port].	^self basicSocketSession</body><body package="PostgreSQLDriver">writeStream	"^a Stream 	I return the stream to which messages may be wrtitten to the back 	end."	writeStream isNil ifTrue: [writeStream := PostgreSQLMessageWriteStream on: self].	^writeStream</body></methods><methods><class-id>PostgreSQLConnection</class-id> <category>accessing</category><body package="PostgreSQLDriver">backendKeyData	"^BackendKeyDataMessage 	I return the BackendKeyDataMessage which contains the secret key 	which may be used to cancel requests. The key is a secret between 	me (the connection) and my backend. The idea appears to be to 	prevent interlopers from hijacking my backend."	^backendKeyData</body><body package="PostgreSQLDriver">backendKeyData: aValue 	"^self 	I record the BackendKeyDataMessage which contains the secret key 	which may be used to cancel requests."	backendKeyData := aValue</body><body package="PostgreSQLDriver">dataTypeTable	"^a PostgreSQLDataTypeTable 	I return the table of data types defined in the database that I am a connection to. PostgreSQL allows 	for the definition of new data types, so every database has a (potentially) unique set of data types. 	Given that every connection could be to a distinct backend, I hold a private copy of this table. In 	this implementation, if a new type is added to the database, a new connection should be made: the 	driver will be OK, but some of the interface layers may not like finding a type in a result which is not 	described in the table."	dataTypeTable isNil ifTrue: [dataTypeTable := self dataTypeTableFromBackend].	^dataTypeTable</body><body package="PostgreSQLDriver">functionTable	"^a PostgreSQLFunctionTable 	I return the table of functions defined in the database that I am a connection to. PostgreSQL allows 	for the definition of new functions, so every database has a (potentially) unique set of functions. 	Given that every connection could be to a distinct backend, I hold a private copy of this table. In 	this implementation, if a new function is added to the database, a new connection should be made."	functionTable isNil ifTrue: [functionTable := self functionTableFromBackend].	^functionTable</body><body package="PostgreSQLDriver">parameters	"^a ConnectionParametersI return my parameters.  These specify what database I'm a connection to, what host/port the postmaster is on and in whose name I am connection."	^parameters</body><body package="PostgreSQLDriver">stringEncodingName	"^a SymbolI return the name of the encoding that is to be presumend to be used for all string values passing between this connection and the PostgreSQL backend."	stringEncodingName isNil ifTrue: [stringEncodingName := #default].	^stringEncodingName</body><body package="PostgreSQLDriver">stringEncodingName: aSymbol 	"^selfI record the name of the encoding that is to be presumend to be used for all string values passing between this connection and the PostgreSQL backend."	stringEncodingName := aSymbol.	^self</body></methods><methods><class-id>PostgreSQLConnection class</class-id> <category>instance creation</category><body package="PostgreSQLDriver">using: aParameterSet 	"^a Connection 	I return a new instance of myself on the basis of the information in 	aParameterSet. I make the new instance, add it to my collection of 	active connections, and then start it up. I start it up last so that any 	logging operations get the chance to log the log-in messages."	| newConnection |	newConnection := self new using: aParameterSet.	self addConnection: newConnection.	newConnection startup.	^newConnection</body></methods><methods><class-id>PostgreSQLConnection class</class-id> <category>private</category><body package="PostgreSQLDriver">addConnection: aNewConnection 	"^self 	I add aConnection to my collection of connections. I have no 	&gt;&gt;removeConnection: because I assume that old connections will go 	away by themselves when closed (given that I'm using a weak array 	to hold them). I do have a bit of a purge when adding a new 	connection though, and only retain existing connections which 	possitively state that they have not been closed."	| existingConnections |	existingConnections := self activeConnections reject: [:connection | connection isClosed].	existingConnections add: aNewConnection.	activeConnections := NativeWeakArray withAll: existingConnections.	self notifyCommonLogOfNewConnection: aNewConnection.	^self</body><body package="PostgreSQLDriver">notifyCommonLogOfNewConnection: aNewConnection 	"^self 	If there is a common log I tell it to start monitoring aNewConnection."	self commonLog notNil ifTrue: [self commonLog startMonitoring: aNewConnection].	^self</body></methods><methods><class-id>PostgreSQLConnection class</class-id> <category>accessing</category><body package="PostgreSQLDriver">activeConnections	"^a Set 	I return the set of currently active connections. Under the covers I 	use a WeakArray to maintain this list, but I don't want to hand that 	out because I'm paranoid. I'm providing this service for developers 	so that they can get hold of stray connections. This is also useful for 	the logging machinery. It seems that the elements of a WeakArray 	are replaced with the Integer 0 when they are garbage collected - I 	remove any 0s from the set I return.  I also check for nil, because 	that's possible in Squeak."	activeConnections isNil 		ifTrue: [activeConnections := NativeWeakArray new: 0].	^(activeConnections 		reject: [:anElement | anElement == 0 or: [anElement isNil]]) asSet</body><body package="PostgreSQLDriver">commonLog	"^ log like thing, or nil 	I return an object which wishes to act as the common logger for all 	of my instances. As logging is really a development time thing, this 	should normally be nil."	^commonLog</body><body package="PostgreSQLDriver">commonLog: aLogOfSomeKind 	"^self 	I record the common log (which may be nil). c.f. &gt;&gt;commonLog"	commonLog := aLogOfSomeKind.	^self</body></methods><methods><class-id>PostgreSQLConnection class</class-id> <category>services</category><body package="PostgreSQLDriver">workInProgress	"^self 	This message may sent by methods in any class in the PostgreSQL 	library family to indicate that they need further work. This method 	is a functional no-op"	^self</body></methods><methods><class-id>PostgreSQLException</class-id> <category>testing</category><body package="PostgreSQLDriver">isNoticeResponse	"^a Boolean 	I return true if I am a notice response, otherwise, I return false. By default, I return false."	^false</body></methods><methods><class-id>PostgreSQLException</class-id> <category>license</category><body package="PostgreSQLDriver">license	"^a License 	I return the license under which this software is made available."	^PostgreSQLDriverLicense license</body></methods><methods><class-id>PostgreSQLMessageReadStream</class-id> <category>accessing</category><body package="PostgreSQLDriver">next	"^a PostgreSQLMessage 	I read the next message from my underlying stream."	^self nextInTheContextOf: self connection</body><body package="PostgreSQLDriver">nextInTheContextOf: aContext 	"^a PostgreSQLMessage 	I read the next message from my underlying stream in the context 	of aContext."	| message |	message := PostgreSQLMessage readFrom: self underlyingStream for: aContext.	self log: message.	^message</body><body package="PostgreSQLDriver">peek	"^a Message or nil 	I return the message that will be returned the next time &gt;&gt;next is 	sent, or nil. If there is no message in the inbound messages queue, I 	return nil."	"To get this going, I need to have a separate thread that is 	constantly reading from the socket. This thread would read 	messages and add them to a shared queue. &gt;&gt;next would read from 	this queue. Problems include the fact that the length of some 	messages can only be known from information in preceeding 	messages (e.g. AsciiRow)."	"PostgreSQLConnection workInProgress."	^nil</body></methods><methods><class-id>PostgreSQLMessageReadStream</class-id> <category>private</category><body package="PostgreSQLDriver">underlyingStream	"^a Stream 	I return my underlying read stream."	underlyingStream isNil ifTrue: [underlyingStream := self connection socketSession readStream binary].	^underlyingStream</body></methods><methods><class-id>PostgreSQLSystemObjectTable</class-id> <category>accessing</category><body package="PostgreSQLDriver">byName	"^a Dictionary 	I return a dictionary of system objects. The dictionary is keyed on the name of the system object."	systemObjectsByName isNil 		ifTrue: 			[systemObjectsByName := Dictionary new: self byObjectId size.			self byObjectId 				do: [:aSystemObject | systemObjectsByName at: aSystemObject name put: aSystemObject]].	^systemObjectsByName</body><body package="PostgreSQLDriver">byObjectId	"^a Dictionary 	I return a dictionary of system objects. The dictionary is keyed on the objectId of the data type."	systemObjectsByObjectId isNil 		ifTrue: [systemObjectsByObjectId := IdentityDictionary new].	^systemObjectsByObjectId</body><body package="PostgreSQLDriver">objectWithId: anInteger 	"^a PostgreSQLSystemObject	I return a system object with objectId anInteger."	^self byObjectId at: anInteger</body><body package="PostgreSQLDriver">objectWithName: aSymbol 	"^a PostgreSQLSystemObject	I return a system object with the name aSymbol."	^self byName at: aSymbol</body></methods><methods><class-id>PostgreSQLSystemObjectTable</class-id> <category>initialize-release</category><body package="PostgreSQLDriver">for: aConnection 	"^ PostgreSQLDataTypeTable 	All system object tables exist in the context of aConnection.  My subclasses must handle the detail of the creation."	^self subclassResponsibility</body></methods><methods><class-id>PostgreSQLSystemObjectTable class</class-id> <category>instance creation</category><body package="PostgreSQLDriver">for: aConnection 	"^ PostgreSQLDataTypeTable 	I create and return an initialized instance of myself that represents the data types defined in the 	database accessible via aConnection."	^self new for: aConnection</body></methods><methods><class-id>PostgreSQLFunctionTable</class-id> <category>initialize-release</category><body package="PostgreSQLDriver">for: aConnection 	"^ PostgreSQLFunctionTable 	I initialize myself to represent the functions defined in the database accessible via aConnection."	| result |	result := (aConnection executeQuery: 'select oid, proname, proargtypes, prorettype from pg_proc') first.	result rows		do: 			[:aRow | 			| function |			function := PostgreSQLFunction from: aRow.			self byObjectId at: function objectId put: function].	^self</body></methods><methods><class-id>PostgreSQLQueryResultList</class-id> <category>accessing</category><body package="PostgreSQLDriver">first	"^a QueryResult 	I return the first query result from my collection of query results."	^self queryResults first</body><body package="PostgreSQLDriver">query	"^ a PostgreSQLQuery 	I return the query for which I am the list of results."	^query</body></methods><methods><class-id>PostgreSQLQueryResultList</class-id> <category>initialize-release</category><body package="PostgreSQLDriver">for: aPostgreSQLQuery 	"^self 	I initialize myself to represents the list of results for 	aPostgreSQLQuery message flow. 	NOTE: this area is ugly for now. I need to implement a message 	stream into which one could peek. 	So this method would be something like: [aPostgreSQLQuery 	readStream peek isReadyForQuery] 	whileFalse ..."	| result |	"PostgreSQLConnection workInProgress."	query := aPostgreSQLQuery.	[(result := PostgreSQLQueryResult for: self query) isReadyForQuery]		whileFalse: [self queryResults add: result].	^self</body></methods><methods><class-id>PostgreSQLQueryResultList</class-id> <category>private</category><body package="PostgreSQLDriver">queryResults	"^an OrderedColection 	*PRIVATE*	I return my collection of query results. Initialize this as an OrderedCollection."	queryResults isNil ifTrue: [queryResults := OrderedCollection new].	^queryResults</body></methods><methods><class-id>PostgreSQLQueryResultList</class-id> <category>enumerating</category><body package="PostgreSQLDriver">do: aBlock 	"^self 	I delegate this to my underlying collection."	self queryResults do: aBlock.	^self</body></methods><methods><class-id>PostgreSQLQueryResultList class</class-id> <category>instance creation</category><body package="PostgreSQLDriver">for: aPostgreSQLQuery 	"^a PostgreSQLRequestResultList 	I return a new instance of myself which represents the results of 	executing aPostgreSQLQuery."	^self new for: aPostgreSQLQuery</body></methods><methods><class-id>ConnectionContextElement</class-id> <category>accessing</category><body package="PostgreSQLDriver">contextParent	"^an Object	I return the object in whose context I exist."	^contextParent</body></methods><methods><class-id>ConnectionContextElement</class-id> <category>private</category><body package="PostgreSQLDriver">contextParent: aContextParent 	"^self	I record the connection context within which I exist."	contextParent := aContextParent.	^self</body></methods><methods><class-id>ConnectionContextElement</class-id> <category>services</category><body package="PostgreSQLDriver">connection	"^a PostgreSQLConnectionI return the connection which is at the root of the context tree.  I delegate this to my context parent, which might actually be the connection."	^self contextParent connection</body></methods><methods><class-id>ConnectionContextElement</class-id> <category>license</category><body package="PostgreSQLDriver">license	"^a License 	I return the license under which this software is made available."	^PostgreSQLDriverLicense license</body></methods><methods><class-id>FieldDescription</class-id> <category>accessing</category><body package="PostgreSQLDriver">name	^name</body><body package="PostgreSQLDriver">objectID	^objectID</body><body package="PostgreSQLDriver">typeModifier	^typeModifier</body><body package="PostgreSQLDriver">typeSize	^typeSize</body></methods><methods><class-id>FieldDescription</class-id> <category>initialize-release</category><body package="PostgreSQLDriver">readFrom: aStream for: aContextParent 	"^self 	I initialize myself to know the name, objectID, typeSize and typeModifier of 	the field description I represent."	self contextParent: aContextParent.	name := (StringValue readFrom: aStream for: self) value asString.	objectID := (IntValue 				size: 32				readFrom: aStream				for: self) value.	typeSize := (IntValue 				size: 16				readFrom: aStream				for: self) value.	typeModifier := (IntValue 				size: 32				readFrom: aStream				for: self) value.	^self</body></methods><methods><class-id>FieldDescription</class-id> <category>printing</category><body package="PostgreSQLDriver">printOn: aStream 	"^self 	I return a string representation of myself. ."	aStream nextPutAll: 'Field description.  Name: ' , self name.	aStream nextPutAll: '.  Object ID: ' , self objectID printString.	aStream nextPutAll: '.  Type size: ' , self typeSize printString.	aStream nextPutAll: '.  Type modifier: ' , self typeModifier printString.	^self</body></methods><methods><class-id>FieldDescription class</class-id> <category>instance creation</category><body package="PostgreSQLDriver">readFrom: aStream for: aContextParent 	"^a FieldDescription 	I return a new instance of myself with my body being read from aStream."	^self new readFrom: aStream for: aContextParent</body></methods><methods><class-id>AsciiField</class-id> <category>accessing</category><body package="PostgreSQLDriver">bytes	^bytes</body><body package="PostgreSQLDriver">stringValue	"^StringValue 	I return a StringValue which can yeild my bytes as a String."	stringValue isNil ifTrue: [stringValue := StringValue fromPacketValue: self bytes].	^stringValue</body></methods><methods><class-id>AsciiField</class-id> <category>services</category><body package="PostgreSQLDriver">asString	"^a String 	I return my value as a String."	^self stringValue value</body></methods><methods><class-id>AsciiField</class-id> <category>instance creation</category><body package="PostgreSQLDriver">readFrom: aStream for: aContextParent	"^self 	I initialize myself to know my bytes."	| fieldSize |	self contextParent: aContextParent.	fieldSize := (IntValue				size: 32				readFrom: aStream				for: self) value - 4.	bytes := ByteValue				size: fieldSize				readFrom: aStream				for: self.	^self</body></methods><methods><class-id>AsciiField</class-id> <category>printing</category><body package="PostgreSQLDriver">printOn: aStream 	"^self 	I write a string representation of myself to aStream."	aStream nextPutAll: 'Bytes (hex): ['.	self bytes printHexStringOn: aStream.	aStream nextPutAll: '].'.	^self</body></methods><methods><class-id>AsciiField class</class-id> <category>instance creation</category><body package="PostgreSQLDriver">readFrom: aStream for: aConnectionContext	"^a FieldDescription 	I return a new instance of myself with my value being read from aStream."	^self new readFrom: aStream for: aConnectionContext</body></methods><methods><class-id>PostgreSQLMessageFlow</class-id> <category>initialize-release</category><body package="PostgreSQLDriver">for: aConnection 	"^self	I initialize myself as message flow for aConnection."	self contextParent: aConnection.	^self</body></methods><methods><class-id>PostgreSQLMessageFlow</class-id> <category>services</category><body package="PostgreSQLDriver">readStream	"^a PostgreSQLMessageReadStream 	I return the message write stream through which messages are read 	from the PostgreSQL server."	^self connection readStream</body><body package="PostgreSQLDriver">writeStream	"^a PostgreSQLMessageWriteStream 	I return the message write stream through which messages are sent 	to the PostgreSQL server."	^self connection writeStream</body></methods><methods><class-id>PostgreSQLMessageFlow class</class-id> <category>instance creation</category><body package="PostgreSQLDriver">for: aConnection 	"^a StartupPacket	I return a new instance of one of my subclasses which represents a 	message flow over aConnection."	^self new for: aConnection</body></methods><methods><class-id>PostgreSQLTerminationMessageFlow</class-id> <category>services</category><body package="PostgreSQLDriver">initiate	"^self 	I run through the termination message flow as defined in the spec. 	This invloves sending the single termination message to the 	backend. The backend does not respond, it simply closes."	self writeStream nextPut: (TerminateMessage for: self connection).	^self</body></methods><methods><class-id>PostgreSQLRequest</class-id> <category>private</category><body package="PostgreSQLDriver">readResults	"^a PostgreSQLRequestResult 	I read the next result from my readStream and return it.  My subclasses must implement this."	^self subclassResponsibility</body></methods><methods><class-id>PostgreSQLRequest</class-id> <category>services</category><body package="PostgreSQLDriver">execute	"^a result 	I do my thing causing the backend to do some work.  My subclasses implement this."	^self subclassResponsibility</body></methods><methods><class-id>PostgreSQLQuery</class-id> <category>services</category><body package="PostgreSQLDriver">execute	"^a PostgreSQLQueryResultList 	I send the query string down to the backend, and return the results."	self writeStream nextPut: self queryMessage.	^self readResults</body><body package="PostgreSQLDriver">queryString: aString 	"^self 	I set the query string of my query message to aString."	self queryMessage queryString: aString.	^self</body></methods><methods><class-id>PostgreSQLQuery</class-id> <category>accessing</category><body package="PostgreSQLDriver">queryMessage	"^a QueryMessage 	I return the query message that I'll send to execute the query I represent."	queryMessage isNil ifTrue: [queryMessage := QueryMessage for: self].	^queryMessage</body></methods><methods><class-id>PostgreSQLQuery</class-id> <category>private</category><body package="PostgreSQLDriver">readResults	"^a PostgreSQLQueryResultList 	I read the next set of results from my readStream (up to the next ReadyForQuery message) and 	return them."	^PostgreSQLQueryResultList for: self</body></methods><methods><class-id>PostgreSQLStartupMessageFlow</class-id> <category>services</category><body package="PostgreSQLDriver">initiate	"^self 	I run through the startup message flow as defined in the spec. This 	invloves getting login details from my connection and sending these 	off to the postmaster. After password chalenges, the postmaster 	creates a new backend process nad hads-off to that."	self writeStream nextPut: (StartupPacket for: self connection).	self readStream next finalizeStartupFor: self.	^self</body></methods><methods><class-id>PostgreSQLFunctionCall</class-id> <category>services</category><body package="PostgreSQLDriver">addArgument: aPacketValue 	"^self 	I add aPacketValue to the collection of arguments for my underlying function call packet."	self functionCallPacket addArgument: aPacketValue.	^self</body><body package="PostgreSQLDriver">execute	"^a result 	I send the function call down to the backend, and get the response."	self writeStream nextPut: self functionCallPacket.	^self readResults</body><body package="PostgreSQLDriver">function: aFunction 	"^self 	I set the function of my function call packet to aFunction."	self functionCallPacket function: aFunction.	^self</body></methods><methods><class-id>PostgreSQLFunctionCall</class-id> <category>private</category><body package="PostgreSQLDriver">readResults	"^a PostgreSQLQueryResult 	I read the next result from my readStream and return it."	^PostgreSQLFunctionCallResult for: self</body></methods><methods><class-id>PostgreSQLFunctionCall</class-id> <category>accessing</category><body package="PostgreSQLDriver">functionCallPacket	"^a QueryMessage 	I return the function call message that I'll send to execute the request I represent."	functionCallMessage isNil 		ifTrue: [functionCallMessage := FunctionCallPacket for: self].	^functionCallMessage</body></methods><methods><class-id>PostgreSQLRequestResult</class-id> <category>accessing</category><body package="PostgreSQLDriver">request	"^a PostgreSQLRequest	I return the request I represent a result for."	^request</body></methods><methods><class-id>PostgreSQLRequestResult</class-id> <category>initialize-release</category><body package="PostgreSQLDriver">for: aRequestMessageFlow 	"^self 	I initialize myself to represent the results of executing aRequest. I 	read the results from aMessageStream."	request := aRequestMessageFlow.	self readResult.	^self</body></methods><methods><class-id>PostgreSQLRequestResult</class-id> <category>private</category><body package="PostgreSQLDriver">readResult	"^self 	I read the next result from my readStream. The various messages 	populate my instance variables."	self readStream next resultFor: self.	^self</body><body package="PostgreSQLDriver">readStream	"^a ReadStream 	I return the stream from which I can read results. This is the read stream of my request."	^self request readStream</body><body package="PostgreSQLDriver">writeStream	"^a ReadStream 	I return the stream to which I write my request. This is the write stream of my request."	^self request writeStream</body></methods><methods><class-id>PostgreSQLRequestResult</class-id> <category>license</category><body package="PostgreSQLDriver">license	"^a License 	I return the license under which this software is made available."	^PostgreSQLDriverLicense license</body></methods><methods><class-id>PostgreSQLRequestResult</class-id> <category>services</category><body package="PostgreSQLDriver">connection	"^a PostgreSQLConnection 	I return the connection I'm a result for."	^self request connection</body></methods><methods><class-id>PostgreSQLRequestResult class</class-id> <category>instance creation</category><body package="PostgreSQLDriver">for: aRequest 	"^a PostgreSQLRequestResult 	I return a new instance of myself which represents the results of 	executing aRequest."	^self new for: aRequest</body></methods><methods><class-id>PostgreSQLFunctionCallResult</class-id> <category>accessing</category><body package="PostgreSQLDriver">functionResponse	"^selfI return my function response."	^functionResponse</body><body package="PostgreSQLDriver">functionResponse: aFunctionResponse 	"^selfI record my function response."	functionResponse := aFunctionResponse.	^self</body></methods><methods><class-id>PostgreSQLQueryResult</class-id> <category>accessing</category><body package="PostgreSQLDriver">addCompletedResponse: aCompletedResponse 	"^selfI add aCompletedResponse to my collection of completed responses.  If a given query string contains a number of actions (either implicit or explicit), there will be a CompletedResponse for each."	self completedResponses add: aCompletedResponse.	^self</body><body package="PostgreSQLDriver">completedResponses	"^a SetI return mu collection of CompletedResponses.  There should be one for every implicit or explicit command in the query string sent to the back end."	completedResponses isNil ifTrue: [completedResponses := Set new].	^completedResponses</body><body package="PostgreSQLDriver">cursorResponse	"^self 	I return the cursor response message. This provides information 	about the cursor (if any) used by my request. Cursors influence 	the way the backend sends results. If aCursorResponse cursorName 	is 'blank', no cursor is used. Otherwise, there is a cursor in use."	^cursorResponse</body><body package="PostgreSQLDriver">cursorResponse: aCursorResponse 	"^self 	I record the cursor response message. c.f. self&gt;&gt;cursorResponse"	cursorResponse := aCursorResponse.	^self</body><body package="PostgreSQLDriver">rowDescription	"^self 	I return my row description. This describes what will be found in 	each row returned by the back end. This description is made up of a 	number of field descriptions, which in turn identify the name, object 	ID, type size and type odifier for each field."	^rowDescription</body><body package="PostgreSQLDriver">rowDescription: aRowDescription 	"^self 	I record my row description. c.f. self&gt;&gt;rowDescription."	rowDescription := aRowDescription.	^self</body><body package="PostgreSQLDriver">rows	"^an OrderedCollection 	I return my collection of rows."	rows isNil ifTrue: [rows := OrderedCollection new].	^rows</body></methods><methods><class-id>PostgreSQLQueryResult</class-id> <category>services</category><body package="PostgreSQLDriver">typeOfColumn: aColumnIndex 	"^a Symbol 	I return the type of data in the column identified by aColumnIndex."	| typeID |	typeID := (self rowDescription fieldDescriptions at: aColumnIndex) objectID.	^(self connection dataTypeTable objectWithId: typeID) name</body></methods><methods><class-id>PostgreSQLQueryResult</class-id> <category>testing</category><body package="PostgreSQLDriver">isReadyForQuery	"^a Booean 	I return true is I don't have any query response stuff, otherwise I return false. This is an ugly way 	of doing things until I get a message stream going."	^self completedResponses isEmpty</body></methods><methods><class-id>PacketValue</class-id> <category>accessing</category><body package="PostgreSQLDriver">bytes	"^a ByteArray 	I return the byte representation of my value."	bytes isNil ifTrue: [bytes := self valueAsBytes].	^bytes</body><body package="PostgreSQLDriver">size	"^nothing 	Size is not an obvious thing for a packet value. Should the rsponse give the size of the bytes, or the 	size of the value? Should size be given in bits or bytes? If you need a size, get the size of the thing 	you want using &gt;&gt;bytes size, or &gt;&gt;value size."	^self shouldNotImplement</body><body package="PostgreSQLDriver">value	"^an Object 	I return the value I'm representing. The nature of the value depends upon which of my subclasses is 	being used."	value isNil ifTrue: [value := self bytesAsValue].	^value</body></methods><methods><class-id>PacketValue</class-id> <category>emitting</category><body package="PostgreSQLDriver">writeTo: aStream 	"^self 	I write my bytes to aStream."	aStream nextPutAll: self bytes.	^self</body></methods><methods><class-id>PacketValue</class-id> <category>private</category><body package="PostgreSQLDriver">bytesAsValue	"^an Object 	I return the value encoded in my bytes. The kind of value depends upon my subclass. My 	subclasses must implement this method."	^self subclassResponsibility</body><body package="PostgreSQLDriver">fromBytes: aByteArray 	"^self 	**PRIVATE** 	I get my byte value and size from aByteArray. This should only be used among PacketValues for conversions."	^self subclassResponsibility</body><body package="PostgreSQLDriver">fromPacketValue: aPacketValue 	"^self 	**PRIVATE** 	I get my byte value and size from aPacketValue. This should only be used among PacketValues."	self contextParent: aPacketValue contextParent.	bytes := aPacketValue bytes.	^self</body><body package="PostgreSQLDriver">valueAsBytes	"^a ByteArray 	I return my value encoded in a byte array. My subclasses must implement this method."	^self subclassResponsibility</body></methods><methods><class-id>PacketValue</class-id> <category>converting</category><body package="PostgreSQLDriver">asIntValue	"^an IntValue 	I create a new IntValue based on my bytes."	^IntValue fromPacketValue: self</body></methods><methods><class-id>PacketValue</class-id> <category>debugging</category><body package="PostgreSQLDriver">asString	"^a String 	*FOR DEBUGGING ONLY*	I return a String representation of myself.	My subclasses must implement this."	^self subclassResponsibility</body></methods><methods><class-id>PacketValue class</class-id> <category>private</category><body package="PostgreSQLDriver">fromPacketValue: aPacketValue 	"^self 	**PRIVATE** 	I get my byte value and size from aPacketValue. This should only be used among PacketValues."	^self basicNew fromPacketValue: aPacketValue</body></methods><methods><class-id>FixedSizeValue</class-id> <category>accessing</category><body package="PostgreSQLDriver">numberOfBits	"^an Integer 	I return the number of bits in length the value I represent occupies when exchanged with the back 	end. For now, I assume that all lengths will be in whole numbers of bytes, so it's safe for me to just 	remember the number of bytes and compute the number of bits as the number of bytes * 8."	^self numberOfBytes * 8</body><body package="PostgreSQLDriver">numberOfBytes	"^an Integer 	I return the number of bytes that I am to occupy."	^numberOfBytes</body></methods><methods><class-id>FixedSizeValue</class-id> <category>initialize-release</category><body package="PostgreSQLDriver">size: aSize readFrom: aStream for: aContextParent 	"^self 	I initialize myself to represent the value of the next aSize bytes from aStream read in the context of aMessage."	self contextParent: aContextParent.	numberOfBytes := self convertSizeToNumberOfBytes: aSize.	bytes := aStream next: self numberOfBytes.	^self</body><body package="PostgreSQLDriver">size: aSize value: aValue for: aContextParent 	"^self 	I initialize myself to represent a value which will occupy aNumberOfBytes when converted to a 	ByteArray.  I exist in the context of aMessage."	self contextParent: aContextParent.	numberOfBytes := self convertSizeToNumberOfBytes: aSize.	value := aValue.	^self</body></methods><methods><class-id>FixedSizeValue</class-id> <category>private</category><body package="PostgreSQLDriver">convertSizeToNumberOfBytes: anInteger 	"^an Integer	I return the number of bytes needed to hold an instance of myself of size anInteger.	The default is that the number of bytes = my size, and hence anInteger.	My subclasses may override this method."	^anInteger</body></methods><methods><class-id>FixedSizeValue class</class-id> <category>instance creation</category><body package="PostgreSQLDriver">size: aSize readFrom: aStream for: aConnectionContext	"^a ByteValue 	I create a new instance of myself that will represent the next aSize bytes from aStream in the context of aMessage."	^self new size: aSize readFrom: aStream for: aConnectionContext</body><body package="PostgreSQLDriver">size: aSize value: aValue for: aConnectionContext	"^an IntValueI create and return a new instance of myself to represent an Int value of aSize with aValue in the context of aMessage."	^self new size: aSize value: aValue for: aConnectionContext</body></methods><methods><class-id>LimStringValue</class-id> <category>private</category><body package="PostgreSQLDriver">bytesAsValue	"^a ByteArray 	I return the value encoded in my bytes. It seems, according to the spec, that we never need to do 	this."	^self shouldNotImplement</body><body package="PostgreSQLDriver">valueAsBytes	"^a ByteArray 	I return my value encoded in a BytesArray. The ByteArray must 	contain my string value as bytes with trailing binary 0's."	| byteArray |	byteArray := ByteArray new: self numberOfBytes.	self value isEmpty		ifTrue: [^byteArray]		ifFalse: [^byteArray				copyReplaceFrom: 1				to: self value size				with: self value asByteArray]</body></methods><methods><class-id>LimStringValue</class-id> <category>debugging</category><body package="PostgreSQLDriver">asString	"^a String 	*FOR DEBUGGING ONLY*	I return a String representation of myself."	^self value</body></methods><methods><class-id>ByteValue</class-id> <category>private</category><body package="PostgreSQLDriver">bytesAsValue	"^a ByteArray	I return the value encoded in my bytes. As my value already *is* a ByteArray, this is a no-op."	^bytes</body><body package="PostgreSQLDriver">valueAsBytes	"^a ByteArray 	I return my value encoded in a BytesArray. As my value *is* bytes, this is a no-op."	^value</body></methods><methods><class-id>ByteValue</class-id> <category>printing</category><body package="PostgreSQLDriver">asHexString	"^a String 	I return my value in the form of hexacedimal digits, like 'aff35b5'."	| hexStream |	hexStream := String new writeStream.	self printHexStringOn: hexStream.	^hexStream contents</body><body package="PostgreSQLDriver">printHexStringOn: aStream 	"^self 	I write a hexadecimal representation of myself to aStream. Each of my bytes becomes two 	characters (00 to FF) when written to a stream.  For VisualWorks, I can just use &gt;&gt;printStringRadix:	but that is not implemented in Squeak, so I use a more pedestrian approach."	| digits |	digits := #($0 $1 $2 $3 $4 $5 $6 $7 $8 $9 $A $B $C $D $E $F).	self bytes do: 			[:aByte | 			| leftNibble rightNibble |			leftNibble := (aByte bitAnd: 16rF0) bitShift: -4.			rightNibble := aByte bitAnd: 16r0F.			aStream nextPut: (digits at: leftNibble + 1).			aStream nextPut: (digits at: rightNibble + 1)].	^self</body><body package="PostgreSQLDriver">valueAsString	"^a String 	I return my value in the form of a String. In VisualWorks, I can just 	use &gt;&gt;value asString, but in GemStone this returns the string 	'ByteArray' :-). So, I implement this here so I can have the same 	behavior in both places. I stole the VisualWorks implementation of 	ByteArray(IntegerArray)&gt;&gt;asString for this."	| new |	bytes := self value.	new := String new: bytes size.	1 to: bytes size do: [:index | new at: index put: (bytes at: index) asCharacter].	^new</body></methods><methods><class-id>ByteValue</class-id> <category>debugging</category><body package="PostgreSQLDriver">asString	"^a String 	*FOR DEBUGGING ONLY*	I return a String representation of myself."	^'&lt;a ByteValue&gt;:', self value printString</body></methods><methods><class-id>BitMapValue</class-id> <category>accessing</category><body package="PostgreSQLDriver">numberOfBits	"^an Integer 	I return my number of bits. This may not be (my number of bytes * 8) !"	^numberOfBits</body></methods><methods><class-id>BitMapValue</class-id> <category>private</category><body package="PostgreSQLDriver">bytesAsValue	"^a ByteArray	I return the value encoded in my bytes."	^bytes</body><body package="PostgreSQLDriver">convertSizeToNumberOfBytes: anInteger 	"^an Integer	I return the number of bytes needed to hold an instance of myself of size anInteger.	Bitmaps can be any number of bits long, so I take anInteger / 8 rounded up to a 	whole number of bytes."	^(anInteger  / 8) ceiling.</body><body package="PostgreSQLDriver">valueAsBytes	"^a ByteArray 	I return my value encoded in a BytesArray."	^value</body></methods><methods><class-id>BitMapValue</class-id> <category>services</category><body package="PostgreSQLDriver">at: aPosition 	"^an Integer 	I return the bit at aPosition. This is either a one or a zero."	| byteOffset sourceByte bitOffset |	byteOffset := (aPosition / 8) ceiling.	sourceByte := self bytes at: byteOffset.	bitOffset := aPosition \\ 8.	bitOffset == 0 ifTrue: [bitOffset := 8].	^(sourceByte bitAnd: (1 bitShift: 8 - bitOffset))		= 0		ifTrue: [0]		ifFalse: [1]</body></methods><methods><class-id>IntValue</class-id> <category>private</category><body package="PostgreSQLDriver">bytesAsValue	"^an Integer 	I return the value encoded in my bytes."	| integer |	integer := 0.	self bytes inject: (self bytes size - 1) * 8		into: 			[:bitOffset :byte | 			integer := integer + (byte asInteger bitShift: bitOffset).			bitOffset - 8].	^integer</body><body package="PostgreSQLDriver">convertSizeToNumberOfBytes: anInteger 	"^an Integer	I return the number of bytes needed to hold an instance of myself of size anInteger.	As integers sizes are specified in bits, I answer anInteger / 8."	^anInteger / 8.</body><body package="PostgreSQLDriver">valueAsBytes	"^an Object 	I return the value encoded in my bytes. The kind of value depends upon my subclass. My 	subclasses must implement this method."	| sourceNumber length byteArray |	sourceNumber := self value.	length := self numberOfBits / 8.	byteArray := ByteArray new: length.	length		to: 1		by: -1		do: 			[:index | 			byteArray at: index put: (sourceNumber bitAnd: 255).			sourceNumber := sourceNumber bitShift: -8].	^byteArray</body></methods><methods><class-id>StringValue</class-id> <category>initialize-release</category><body package="PostgreSQLDriver">readFrom: aByteStream for: aContextParent 	"^self 	I initialize myself to represent the next string of null terminated bytes from aStream. 	I hold my bytes *without* the null termination."	self contextParent: aContextParent.	bytes := aByteStream upTo: 0.	^self</body><body package="PostgreSQLDriver">value: aString for: aContextParent 	"^self 	I initialize myself to represent aString."	self contextParent: aContextParent.	value := aString.	^self</body></methods><methods><class-id>StringValue</class-id> <category>private</category><body package="PostgreSQLDriver">bytesAsValue	"^a String 	I return the value encoded in my bytes."	^self bytes asStringEncoding: self stringEncodingName</body><body package="PostgreSQLDriver">stringEncodingName	"^a Symbol 	I return the local (Smalltalk) name of the encoding to be used when 	sending/receiving strings from the backend. I get the encoding for my 	connection via the message of which I am a part. You can find the list of all 	the locales in VisualWorks with the following expression: 'StreamEncoder 	encoderDirectory'."	^self connection stringEncodingName</body><body package="PostgreSQLDriver">valueAsBytes	"^a ByteArray 	I return my value encoded in a ByteArray."	^self value asByteArrayEncoding: self stringEncodingName</body></methods><methods><class-id>StringValue</class-id> <category>debugging</category><body package="PostgreSQLDriver">asString	"^a String 	*FOR DEBUGGING ONLY*	I return a String representation of myself."	^self value</body></methods><methods><class-id>StringValue</class-id> <category>emitting</category><body package="PostgreSQLDriver">writeTo: aStream 	"^self 	I write my bytes to aStream and terminate them with a null byte."	super writeTo: aStream.	aStream nextPut: 0.	^self</body></methods><methods><class-id>StringValue class</class-id> <category>instance creation</category><body package="PostgreSQLDriver">readFrom: aByteStream for: aConnectionContext 	"^a StringValue 	I create a new instance of myself that will represent the next null terminated string of bytes from 	aByteStream."	^self new readFrom: aByteStream for: aConnectionContext</body><body package="PostgreSQLDriver">value: aString for: aConnectionContext 	"^self 	I create a new instance of myself that will represent aString."	^self new value: aString for: aConnectionContext</body></methods><methods><class-id>PostgreSQLDriverLicense</class-id> <category>accessing</category><body package="PostgreSQLDriver">copyright"^a StringI return the copyright notice which applies to this library."^'	The "PostgreSQL Driver for Smalltalk" allows Smalltalk systems to interact fully with PostgreSQL databases.	Copyright (C) 2000  Bruce Badger'</body><body package="PostgreSQLDriver">libraryName	"^a String 	I return the name of the library."	^'PostgreSQL Driver for Smalltalk'</body><body package="PostgreSQLDriver">license"^a StringI return the PostgreSQLDriver license text. This license applies the whole of the PostgreSQL Smalltalk Driver library."^'			   GNU LESSER GENERAL PUBLIC LICENSE					   Version 2.1, February 1999 Copyright (C) 1991, 1999 Free Software Foundation, Inc.	 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed.[This is the first released version of the Lesser GPL.  It also counts as the successor of the GNU Library Public License, version 2, hence the version number 2.1.]							Preamble  The licenses for most software are designed to take away yourfreedom to share and change it.  By contrast, the GNU General PublicLicenses are intended to guarantee your freedom to share and changefree software--to make sure the software is free for all its users.  This license, the Lesser General Public License, applies to somespecially designated software packages--typically libraries--of theFree Software Foundation and other authors who decide to use it.  Youcan use it too, but we suggest you first think carefully about whetherthis license or the ordinary General Public License is the betterstrategy to use in any particular case, based on the explanations below.  When we speak of free software, we are referring to freedom of use,not price.  Our General Public Licenses are designed to make sure thatyou have the freedom to distribute copies of free software (and chargefor this service if you wish); that you receive source code or can getit if you want it; that you can change the software and use pieces ofit in new free programs; and that you are informed that you can dothese things.  To protect your rights, we need to make restrictions that forbiddistributors to deny you these rights or to ask you to surrender theserights.  These restrictions translate to certain responsibilities foryou if you distribute copies of the library or if you modify it.  For example, if you distribute copies of the library, whether gratisor for a fee, you must give the recipients all the rights that we gaveyou.  You must make sure that they, too, receive or can get the sourcecode.  If you link other code with the library, you must providecomplete object files to the recipients, so that they can relink themwith the library after making changes to the library and recompilingit.  And you must show them these terms so they know their rights.  We protect your rights with a two-step method: (1) we copyright thelibrary, and (2) we offer you this license, which gives you legalpermission to copy, distribute and/or modify the library.  To protect each distributor, we want to make it very clear thatthere is no warranty for the free library.  Also, if the library ismodified by someone else and passed on, the recipients should knowthat what they have is not the original version, so that the originalauthor''s reputation will not be affected by problems that might beintroduced by others.  Finally, software patents pose a constant threat to the existence ofany free program.  We wish to make sure that a company cannoteffectively restrict the users of a free program by obtaining arestrictive license from a patent holder.  Therefore, we insist thatany patent license obtained for a version of the library must beconsistent with the full freedom of use specified in this license.  Most GNU software, including some libraries, is covered by theordinary GNU General Public License.  This license, the GNU LesserGeneral Public License, applies to certain designated libraries, andis quite different from the ordinary General Public License.  We usethis license for certain libraries in order to permit linking thoselibraries into non-free programs.  When a program is linked with a library, whether statically or usinga shared library, the combination of the two is legally speaking acombined work, a derivative of the original library.  The ordinaryGeneral Public License therefore permits such linking only if theentire combination fits its criteria of freedom.  The Lesser GeneralPublic License permits more lax criteria for linking other code withthe library.  We call this license the "Lesser" General Public License because itdoes Less to protect the user''s freedom than the ordinary GeneralPublic License.  It also provides other free software developers Lessof an advantage over competing non-free programs.  These disadvantagesare the reason we use the ordinary General Public License for manylibraries.  However, the Lesser license provides advantages in certainspecial circumstances.  For example, on rare occasions, there may be a special need toencourage the widest possible use of a certain library, so that it becomesa de-facto standard.  To achieve this, non-free programs must beallowed to use the library.  A more frequent case is that a freelibrary does the same job as widely used non-free libraries.  In thiscase, there is little to gain by limiting the free library to freesoftware only, so we use the Lesser General Public License.  In other cases, permission to use a particular library in non-freeprograms enables a greater number of people to use a large body offree software.  For example, permission to use the GNU C Library innon-free programs enables many more people to use the whole GNUoperating system, as well as its variant, the GNU/Linux operatingsystem.  Although the Lesser General Public License is Less protective of theusers'' freedom, it does ensure that the user of a program that islinked with the Library has the freedom and the wherewithal to runthat program using a modified version of the Library.  The precise terms and conditions for copying, distribution andmodification follow.  Pay close attention to the difference between a"work based on the library" and a "work that uses the library".  Theformer contains code derived from the library, whereas the latter mustbe combined with the library in order to run.				  GNU LESSER GENERAL PUBLIC LICENSE   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION  0. This License Agreement applies to any software library or otherprogram which contains a notice placed by the copyright holder orother authorized party saying it may be distributed under the terms ofthis Lesser General Public License (also called "this License").Each licensee is addressed as "you".  A "library" means a collection of software functions and/or dataprepared so as to be conveniently linked with application programs(which use some of those functions and data) to form executables.  The "Library", below, refers to any such software library or workwhich has been distributed under these terms.  A "work based on theLibrary" means either the Library or any derivative work undercopyright law: that is to say, a work containing the Library or aportion of it, either verbatim or with modifications and/or translatedstraightforwardly into another language.  (Hereinafter, translation isincluded without limitation in the term "modification".)  "Source code" for a work means the preferred form of the work formaking modifications to it.  For a library, complete source code meansall the source code for all modules it contains, plus any associatedinterface definition files, plus the scripts used to control compilationand installation of the library.  Activities other than copying, distribution and modification are notcovered by this License; they are outside its scope.  The act ofrunning a program using the Library is not restricted, and output fromsuch a program is covered only if its contents constitute a work basedon the Library (independent of the use of the Library in a tool forwriting it).  Whether that is true depends on what the Library doesand what the program that uses the Library does.    1. You may copy and distribute verbatim copies of the Library''scomplete source code as you receive it, in any medium, provided thatyou conspicuously and appropriately publish on each copy anappropriate copyright notice and disclaimer of warranty; keep intactall the notices that refer to this License and to the absence of anywarranty; and distribute a copy of this License along with theLibrary.  You may charge a fee for the physical act of transferring a copy,and you may at your option offer warranty protection in exchange for afee.  2. You may modify your copy or copies of the Library or any portionof it, thus forming a work based on the Library, and copy anddistribute such modifications or work under the terms of Section 1above, provided that you also meet all of these conditions:	a) The modified work must itself be a software library.	b) You must cause the files modified to carry prominent notices	stating that you changed the files and the date of any change.	c) You must cause the whole of the work to be licensed at no	charge to all third parties under the terms of this License.	d) If a facility in the modified Library refers to a function or a	table of data to be supplied by an application program that uses	the facility, other than as an argument passed when the facility	is invoked, then you must make a good faith effort to ensure that,	in the event an application does not supply such function or	table, the facility still operates, and performs whatever part of	its purpose remains meaningful.	(For example, a function in a library to compute square roots has	a purpose that is entirely well-defined independent of the	application.  Therefore, Subsection 2d requires that any	application-supplied function or table used by this function must	be optional: if the application does not supply it, the square	root function must still compute square roots.)These requirements apply to the modified work as a whole.  Ifidentifiable sections of that work are not derived from the Library,and can be reasonably considered independent and separate works inthemselves, then this License, and its terms, do not apply to thosesections when you distribute them as separate works.  But when youdistribute the same sections as part of a whole which is a work basedon the Library, the distribution of the whole must be on the terms ofthis License, whose permissions for other licensees extend to theentire whole, and thus to each and every part regardless of who wroteit.Thus, it is not the intent of this section to claim rights or contestyour rights to work written entirely by you; rather, the intent is toexercise the right to control the distribution of derivative orcollective works based on the Library.In addition, mere aggregation of another work not based on the Librarywith the Library (or with a work based on the Library) on a volume ofa storage or distribution medium does not bring the other work underthe scope of this License.  3. You may opt to apply the terms of the ordinary GNU General PublicLicense instead of this License to a given copy of the Library.  To dothis, you must alter all the notices that refer to this License, sothat they refer to the ordinary GNU General Public License, version 2,instead of to this License.  (If a newer version than version 2 of theordinary GNU General Public License has appeared, then you can specifythat version instead if you wish.)  Do not make any other change inthese notices.  Once this change is made in a given copy, it is irreversible forthat copy, so the ordinary GNU General Public License applies to allsubsequent copies and derivative works made from that copy.  This option is useful when you wish to copy part of the code ofthe Library into a program that is not a library.  4. You may copy and distribute the Library (or a portion orderivative of it, under Section 2) in object code or executable formunder the terms of Sections 1 and 2 above provided that you accompanyit with the complete corresponding machine-readable source code, whichmust be distributed under the terms of Sections 1 and 2 above on amedium customarily used for software interchange.  If distribution of object code is made by offering access to copyfrom a designated place, then offering equivalent access to copy thesource code from the same place satisfies the requirement todistribute the source code, even though third parties are notcompelled to copy the source along with the object code.  5. A program that contains no derivative of any portion of theLibrary, but is designed to work with the Library by being compiled orlinked with it, is called a "work that uses the Library".  Such awork, in isolation, is not a derivative work of the Library, andtherefore falls outside the scope of this License.  However, linking a "work that uses the Library" with the Librarycreates an executable that is a derivative of the Library (because itcontains portions of the Library), rather than a "work that uses thelibrary".  The executable is therefore covered by this License.Section 6 states terms for distribution of such executables.  When a "work that uses the Library" uses material from a header filethat is part of the Library, the object code for the work may be aderivative work of the Library even though the source code is not.Whether this is true is especially significant if the work can belinked without the Library, or if the work is itself a library.  Thethreshold for this to be true is not precisely defined by law.  If such an object file uses only numerical parameters, datastructure layouts and accessors, and small macros and small inlinefunctions (ten lines or less in length), then the use of the objectfile is unrestricted, regardless of whether it is legally a derivativework.  (Executables containing this object code plus portions of theLibrary will still fall under Section 6.)  Otherwise, if the work is a derivative of the Library, you maydistribute the object code for the work under the terms of Section 6.Any executables containing that work also fall under Section 6,whether or not they are linked directly with the Library itself.  6. As an exception to the Sections above, you may also combine orlink a "work that uses the Library" with the Library to produce awork containing portions of the Library, and distribute that workunder terms of your choice, provided that the terms permitmodification of the work for the customer''s own use and reverseengineering for debugging such modifications.  You must give prominent notice with each copy of the work that theLibrary is used in it and that the Library and its use are covered bythis License.  You must supply a copy of this License.  If the workduring execution displays copyright notices, you must include thecopyright notice for the Library among them, as well as a referencedirecting the user to the copy of this License.  Also, you must do oneof these things:	a) Accompany the work with the complete corresponding	machine-readable source code for the Library including whatever	changes were used in the work (which must be distributed under	Sections 1 and 2 above); and, if the work is an executable linked	with the Library, with the complete machine-readable "work that	uses the Library", as object code and/or source code, so that the	user can modify the Library and then relink to produce a modified	executable containing the modified Library.  (It is understood	that the user who changes the contents of definitions files in the	Library will not necessarily be able to recompile the application	to use the modified definitions.)	b) Use a suitable shared library mechanism for linking with the	Library.  A suitable mechanism is one that (1) uses at run time a	copy of the library already present on the user''s computer system,	rather than copying library functions into the executable, and (2)	will operate properly with a modified version of the library, if	the user installs one, as long as the modified version is	interface-compatible with the version that the work was made with.	c) Accompany the work with a written offer, valid for at	least three years, to give the same user the materials	specified in Subsection 6a, above, for a charge no more	than the cost of performing this distribution.	d) If distribution of the work is made by offering access to copy	from a designated place, offer equivalent access to copy the above	specified materials from the same place.	e) Verify that the user has already received a copy of these	materials or that you have already sent this user a copy.  For an executable, the required form of the "work that uses theLibrary" must include any data and utility programs needed forreproducing the executable from it.  However, as a special exception,the materials to be distributed need not include anything that isnormally distributed (in either source or binary form) with the majorcomponents (compiler, kernel, and so on) of the operating system onwhich the executable runs, unless that component itself accompaniesthe executable.  It may happen that this requirement contradicts the licenserestrictions of other proprietary libraries that do not normallyaccompany the operating system.  Such a contradiction means you cannotuse both them and the Library together in an executable that youdistribute.  7. You may place library facilities that are a work based on theLibrary side-by-side in a single library together with other libraryfacilities not covered by this License, and distribute such a combinedlibrary, provided that the separate distribution of the work based onthe Library and of the other library facilities is otherwisepermitted, and provided that you do these two things:	a) Accompany the combined library with a copy of the same work	based on the Library, uncombined with any other library	facilities.  This must be distributed under the terms of the	Sections above.	b) Give prominent notice with the combined library of the fact	that part of it is a work based on the Library, and explaining	where to find the accompanying uncombined form of the same work.  8. You may not copy, modify, sublicense, link with, or distributethe Library except as expressly provided under this License.  Anyattempt otherwise to copy, modify, sublicense, link with, ordistribute the Library is void, and will automatically terminate yourrights under this License.  However, parties who have received copies,or rights, from you under this License will not have their licensesterminated so long as such parties remain in full compliance.  9. You are not required to accept this License, since you have notsigned it.  However, nothing else grants you permission to modify ordistribute the Library or its derivative works.  These actions areprohibited by law if you do not accept this License.  Therefore, bymodifying or distributing the Library (or any work based on theLibrary), you indicate your acceptance of this License to do so, andall its terms and conditions for copying, distributing or modifyingthe Library or works based on it.  10. Each time you redistribute the Library (or any work based on theLibrary), the recipient automatically receives a license from theoriginal licensor to copy, distribute, link with or modify the Librarysubject to these terms and conditions.  You may not impose any furtherrestrictions on the recipients'' exercise of the rights granted herein.You are not responsible for enforcing compliance by third parties withthis License.  11. If, as a consequence of a court judgment or allegation of patentinfringement or for any other reason (not limited to patent issues),conditions are imposed on you (whether by court order, agreement orotherwise) that contradict the conditions of this License, they do notexcuse you from the conditions of this License.  If you cannotdistribute so as to satisfy simultaneously your obligations under thisLicense and any other pertinent obligations, then as a consequence youmay not distribute the Library at all.  For example, if a patentlicense would not permit royalty-free redistribution of the Library byall those who receive copies directly or indirectly through you, thenthe only way you could satisfy both it and this License would be torefrain entirely from distribution of the Library.If any portion of this section is held invalid or unenforceable under anyparticular circumstance, the balance of the section is intended to apply,and the section as a whole is intended to apply in other circumstances.It is not the purpose of this section to induce you to infringe anypatents or other property right claims or to contest validity of anysuch claims; this section has the sole purpose of protecting theintegrity of the free software distribution system which isimplemented by public license practices.  Many people have madegenerous contributions to the wide range of software distributedthrough that system in reliance on consistent application of thatsystem; it is up to the author/donor to decide if he or she is willingto distribute software through any other system and a licensee cannotimpose that choice.This section is intended to make thoroughly clear what is believed tobe a consequence of the rest of this License.  12. If the distribution and/or use of the Library is restricted incertain countries either by patents or by copyrighted interfaces, theoriginal copyright holder who places the Library under this License may addan explicit geographical distribution limitation excluding those countries,so that distribution is permitted only in or among countries not thusexcluded.  In such case, this License incorporates the limitation as ifwritten in the body of this License.  13. The Free Software Foundation may publish revised and/or newversions of the Lesser General Public License from time to time.Such new versions will be similar in spirit to the present version,but may differ in detail to address new problems or concerns.Each version is given a distinguishing version number.  If the Libraryspecifies a version number of this License which applies to it and"any later version", you have the option of following the terms andconditions either of that version or of any later version published bythe Free Software Foundation.  If the Library does not specify alicense version number, you may choose any version ever published bythe Free Software Foundation.  14. If you wish to incorporate parts of the Library into other freeprograms whose distribution conditions are incompatible with these,write to the author to ask for permission.  For software which iscopyrighted by the Free Software Foundation, write to the FreeSoftware Foundation; we sometimes make exceptions for this.  Ourdecision will be guided by the two goals of preserving the free statusof all derivatives of our free software and of promoting the sharingand reuse of software generally.							NO WARRANTY  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NOWARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OROTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANYKIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THEIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULARPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THELIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUMETHE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO INWRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFYAND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOUFOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL ORCONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THELIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEINGRENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR AFAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IFSUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCHDAMAGES.					 END OF TERMS AND CONDITIONS'</body><body package="PostgreSQLDriver">notices"^a StringThe notices which apply to this library."^'	This library is free software; you can redistribute it and/or	modify it under the terms of the GNU Lesser General Public	License as published by the Free Software Foundation; either	version 2.1 of the License, or (at your option) any later version.	This library is distributed in the hope that it will be useful,	but WITHOUT ANY WARRANTY; without even the implied warranty of	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU	Lesser General Public License for more details.	You should have received a copy of the GNU Lesser General Public	License along with this library; if not, write to the Free Software	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA'</body><body package="PostgreSQLDriver">versionName	"^a String 	I return the name of this version of the library."	^'1.0 023'</body></methods><methods><class-id>PostgreSQLDriverLicense</class-id> <category>printing</category><body package="PostgreSQLDriver">printOn: aStream 	"^self 	I write the combination of the copyright, notices and the license itself to aStream."	aStream nextPutAll: self libraryName.	aStream nextPutAll: ' version '.	aStream nextPutAll: self versionName; cr.	aStream nextPutAll: self copyright.	aStream nextPutAll: self notices.	aStream nextPutAll: self license.	^self</body></methods><methods><class-id>PostgreSQLDriverLicense class</class-id> <category>accessing</category><body package="PostgreSQLDriver">license	"^a PostgreSQLDriverLicense 	I return my singleton instance."	TheLicense isNil ifTrue: [TheLicense := self new].	^TheLicense</body></methods><methods><class-id>PostgreSQLFunction</class-id> <category>private</category><body package="PostgreSQLDriver">argumentTypes	"^a Array 	I the array of arguments types oids. The oids identify the argument types that must be submitted 	(in order) when calling the function I represent. The field I'm interested in is of type 30:oidarray. 	This is just a space sepparated string of integer values, which are the oids of the types."	argumentTypes isNil		ifTrue: 			[| argumentTypeStream |			argumentTypeStream := (self databaseRow fields at: 3) bytes asString readStream.			argumentTypes := OrderedCollection new.			[argumentTypeStream atEnd]				whileFalse: [argumentTypes add: (argumentTypeStream upTo: Character space) asNumber].			argumentTypes := argumentTypes asArray].	^argumentTypes</body><body package="PostgreSQLDriver">nameFromRow	"^a StringI return my name from the database row which describes me."	^ (self databaseRow fields at: 2) asString asSymbol</body><body package="PostgreSQLDriver">objectIdFromRow	"^an IntegerI return my oid from the database row which describes me."	^self databaseRow fields first asString asNumber</body><body package="PostgreSQLDriver">returnType	"^an Integer 	I return the oid of the return type of the function I represent."	^(self databaseRow fields at: 4) asString asNumber</body></methods><methods><class-id>ConnectionParameterSet</class-id> <category>accessing</category><body package="PostgreSQLDriver">additionalArguments	additionalArguments isNil ifTrue: [additionalArguments := String new].	^additionalArguments</body><body package="PostgreSQLDriver">additionalArguments: aValue 	additionalArguments := aValue</body><body package="PostgreSQLDriver">databaseName	^databaseName</body><body package="PostgreSQLDriver">databaseName: aValue	databaseName := aValue</body><body package="PostgreSQLDriver">debuggingTTY	debuggingTTY isNil ifTrue: [debuggingTTY := String new].	^debuggingTTY</body><body package="PostgreSQLDriver">debuggingTTY: aValue	debuggingTTY := aValue</body><body package="PostgreSQLDriver">host	^host</body><body package="PostgreSQLDriver">host: aValue	host := aValue</body><body package="PostgreSQLDriver">password	"^a StringI return the password used to authenticate a user with the name self&gt;&gt;userName.  By default, this is an empty string."	password isNil ifTrue: [password := String new].	^password</body><body package="PostgreSQLDriver">password: aValue	password := aValue</body><body package="PostgreSQLDriver">port	^port</body><body package="PostgreSQLDriver">port: aValue	port := aValue</body><body package="PostgreSQLDriver">userName	^userName</body><body package="PostgreSQLDriver">userName: aValue	userName := aValue</body></methods><methods><class-id>ConnectionParameterSet</class-id> <category>license</category><body package="PostgreSQLDriver">license	"^a License 	I return the license under which this software is made available."	^PostgreSQLDriverLicense license</body></methods><methods><class-id>PostgreSQLDataTypeTable</class-id> <category>initialize-release</category><body package="PostgreSQLDriver">for: aConnection 	"^ PostgreSQLDataTypeTable 	I initialize myself to represent the data types defined in the database accessible via aConnection."	| result |	result := (aConnection executeQuery: 'select oid, typname from pg_type') first.	result rows		do: 			[:aRow | 			| dataType |			dataType := PostgreSQLDataType from: aRow.			self byObjectId at: dataType objectId put: dataType].	^self</body></methods><methods><class-id>PostgreSQLMessage</class-id> <category>testing</category><body package="PostgreSQLDriver">isCompletedResponse	"^a Boolean 	I return true only if I'm a CompletedResponse message. By default, I return false."	^false</body><body package="PostgreSQLDriver">isCursorResponse	"^a Boolean 	I return true only if I'm a CursorResponse message. By default, I return false."	^false</body><body package="PostgreSQLDriver">isReadyForQuery	"^a Boolean 	I return true only if I'm a ReadyForQuery message. By default, I return false."	^false</body><body package="PostgreSQLDriver">isRow	"^a Boolean 	I return true only if I'm a Row message. By default, I return false."	^false</body><body package="PostgreSQLDriver">isRowDescription	"^a Boolean 	I return true only if I'm a RowDescription message. By default, I return false."	^false</body></methods><methods><class-id>PostgreSQLMessage</class-id> <category>license</category><body package="PostgreSQLDriver">license	"^a License 	I return the license under which this software is made available."	^PostgreSQLDriverLicense license</body></methods><methods><class-id>PostgreSQLMessage</class-id> <category>printing</category><body package="PostgreSQLDriver">printOn: aStream 	"^self 	I write a string representation of myself to aStream. This string is intended to 	aid developers, and is not a critical part of the library."	aStream nextPutAll: self class name.	^self</body></methods><methods><class-id>PostgreSQLMessage class</class-id> <category>instance creation</category><body package="PostgreSQLDriver">readFrom: aStream for: aConnectionContext	"^a PostgreSQLMessage 	I return a new instance of one of my subclasses. I have to read the first few bytes from the stream 	to determine which of my subclasses the new message will be an instance of. Once I have created 	the new message instance, I inform it of aMessage (which may be nil)."	| messageIdentification |	messageIdentification := (ByteValue size: 1 readFrom: aStream for: aConnectionContext) value first asCharacter.	^(self subclassesByMessageIdentificationCode at: messageIdentification ifAbsent: [PostgreSQLUnsupportedFeature raise])		readMessageBodyFrom: aStream for: aConnectionContext</body><body package="PostgreSQLDriver">readMessageBodyFrom: aStream for: aConnectionContext	"^a PostgreSQLMessageI return a new instance of myself with my body being read from aStream."	^self new readFrom: aStream for: aConnectionContext</body></methods><methods><class-id>PostgreSQLMessage class</class-id> <category>private</category><body package="PostgreSQLDriver">subclassesByMessageIdentificationCode	subclassesByMessageIdentificationCode isNil 		ifTrue: 			[subclassesByMessageIdentificationCode := IdentityDictionary new: 5.			subclassesByMessageIdentificationCode at: $C put: CompletedResponseMessage.			subclassesByMessageIdentificationCode at: $D put: AsciiRowMessage.			subclassesByMessageIdentificationCode at: $E put: ErrorResponseMessage.			subclassesByMessageIdentificationCode at: $I put: EmptyQueryResponseMessage.			subclassesByMessageIdentificationCode at: $K put: BackendKeyDataMessage.			subclassesByMessageIdentificationCode at: $N put: NoticeResponseMessage.			subclassesByMessageIdentificationCode at: $P put: CursorResponseMessage.			subclassesByMessageIdentificationCode at: $R put: RMessage.			subclassesByMessageIdentificationCode at: $T put: RowDescriptionMessage.			subclassesByMessageIdentificationCode at: $V put: FunctionResponse.			subclassesByMessageIdentificationCode at: $Z put: ReadyForQueryMessage].	^subclassesByMessageIdentificationCode</body></methods><methods><class-id>PostgreSQLBackendMessage</class-id> <category>services</category><body package="PostgreSQLDriver">finalizeStartupFor: aConnection 	"^self 	I've been received from the back end in response to a startup packet, 	and now the connection wants me to finalize the startup process. 	The actions that have to be taken depend upon exactly what kind of 	message I am. By default I throw an exception, because I don't know 	what to do - my smarter subclasses will override this method."	PostgreSQLUnexpectedMessage raise.	^self</body></methods><methods><class-id>PostgreSQLBackendMessage</class-id> <category>initialize-release</category><body package="PostgreSQLDriver">readFrom: aStream 	"^self 	I read my body from aStream. My subclasses must implement this."	^self subclassResponsibility</body><body package="PostgreSQLDriver">readFrom: aStream for: aContextParent 	"^self 	I initailize myself by reading my body from a stream. I note the context, and read my representation from aStream."	self contextParent: aContextParent.	^self readFrom: aStream</body><body package="PostgreSQLDriver">resultFor: aQueryResult 	"^self 	Ths is where a message gets a chance to follow up immediately 	after being read from the backend. By default I just return myself, 	but my subclasses may override this."	^self</body></methods><methods><class-id>PostgreSQLBackendMessage</class-id> <category>printing</category><body package="PostgreSQLDriver">printOn: aStream 	"^self 	I return a string representation of myself. This string is intended to 	aid developers, and is not a critical part of the library."	aStream nextPutAll: '&lt;&lt;&lt;&lt;&lt;'; tab.	super printOn: aStream.	aStream cr.	^self</body></methods><methods><class-id>ReadyForQueryMessage</class-id> <category>initialize-release</category><body package="PostgreSQLDriver">readFrom: aStream 	"^a ReadyForQueryMessage 	I initialize myself which as the response from the backend giving notice that the 	backend is ready to receive query or function calls."	^self</body></methods><methods><class-id>ReadyForQueryMessage</class-id> <category>testing</category><body package="PostgreSQLDriver">isReadyForQuery	"^a Boolean 	I return true only if I'm a ReadyForQuery message - which I am!"	^true</body></methods><methods><class-id>ReadyForQueryMessage</class-id> <category>services</category><body package="PostgreSQLDriver">finalizeStartupFor: aConnection 	"^selfI've been received from the back end in response to a startup packet, and now the connection wants me to finalize the startup process. By sending me, the backend indicated it was ready to receive queries and function calls.  I'm the last point in the startup process and I just return myself."	^self</body><body package="PostgreSQLDriver">resultFor: aMessage 	"^a Message 	I return the result for a message. I represent an initication from the backend that it is ready for the 	next query, which indicates that there are no more results for aMessage. I just return myself."	^self</body></methods><methods><class-id>ReadyForQueryMessage class</class-id> <category>instance creation</category><body package="PostgreSQLDriver">readMessageBodyFrom: aStream 	"^a ReadyForQueryMessage 	I return a new instance of myself which is the response from the backend giving notice that the 	backend is ready to receive query or function calls."	^self new</body></methods><methods><class-id>FunctionResponse</class-id> <category>services</category><body package="PostgreSQLDriver">resultFor: aResult 	"^self 	I let my result know about me, and I flush out the ReadyForQuery message."	| nextMessage |	aResult functionResponse: self.	nextMessage := aResult readStream next.	nextMessage isReadyForQuery ifFalse: [PostgreSQLUnexpectedMessage raise].	^self</body></methods><methods><class-id>FunctionResponse</class-id> <category>printing</category><body package="PostgreSQLDriver">printOn: aStream 	"^self 	I return a string representation of myself. In addition to information 	printed by my superclass ..."	super printOn: aStream.	aStream nextPutAll: 'Result value: ' , self value bytes printString; cr.	^self</body></methods><methods><class-id>FunctionResponse</class-id> <category>accessing</category><body package="PostgreSQLDriver">value	"^a ByteValue 	I return the value returned by a function call.	My subclasses must implement this."	^self subclassResponsibility</body></methods><methods><class-id>FunctionResponse class</class-id> <category>instance creation</category><body package="PostgreSQLDriver">readMessageBodyFrom: aStream for: aConnectionContext 	"^an FunctionResponse 	I return a new instance of one of my subclasses. It has already been 	determined (probably by my superclass) that the message emerging 	from the stream is a Function Response of some kind. The next byte 	from the stream will determine if this is a FunctionResultResponse 	or a FunctionVoidResponse. If the next byte is a 'G' it's a 'result, if 	it's a '0', it's a 'void."	| responseType |	responseType := (ByteValue 				size: 1				readFrom: aStream				for: aConnectionContext) valueAsString.	responseType = 'G' 		ifTrue: 			[^FunctionResultResponse readResultBodyFrom: aStream				inTheContextOf: aConnectionContext].	responseType = '0' 		ifTrue: 			[^FunctionVoidResponse readResultBodyFrom: aStream				inTheContextOf: aConnectionContext].	^PostgreSQLUnsupportedFeature raise</body><body package="PostgreSQLDriver">readResultBodyFrom: aStream inTheContextOf: aMessage 	"^an FunctionResponse 	The body of the response is processed. My subclasses must implement this."	^self subclassResponsibility</body></methods><methods><class-id>BackendKeyDataMessage</class-id> <category>initialize-release</category><body package="PostgreSQLDriver">readFrom: aStream 	"^self 	I initialize myself to know the pid and secret key of the backend process."	processID := (IntValue				size: 32				readFrom: aStream				for: self) value.	secretKey := (IntValue				size: 32				readFrom: aStream				for: self) value.	^self</body></methods><methods><class-id>BackendKeyDataMessage</class-id> <category>accessing</category><body package="PostgreSQLDriver">processID	^processID</body><body package="PostgreSQLDriver">secretKey	^secretKey</body></methods><methods><class-id>BackendKeyDataMessage</class-id> <category>services</category><body package="PostgreSQLDriver">finalizeStartupFor: aMessageFlow 	"^self 	I've been received from the back end in response to a startup packet, 	and now aMessageFlow wants me to finalize the startup process. 	Once I've created myself successfully, I know the process ID and 	secret key of the backend process. Because this information is useful 	to the connection, I tell the connection of aMessageFlow about 	myself The connection will hold on to me as long as needed. There 	are more messages before the connection is finaly ready so I read 	the next one and had off the finalization to it."	aMessageFlow connection backendKeyData: self.	aMessageFlow readStream next finalizeStartupFor: aMessageFlow.	^self</body></methods><methods><class-id>BackendKeyDataMessage</class-id> <category>printing</category><body package="PostgreSQLDriver">printOn: aStream 	"^self 	I return a string representation of myself. This string is intended to 	aid developers, and is not a critical part of the library."	super printOn: aStream.	aStream nextPutAll: 'Process ID: ', self processID printString; cr.	aStream nextPutAll: 'Secret Key: ', self secretKey printString; cr.	^self</body></methods><methods><class-id>EmptyQueryResponseMessage</class-id> <category>initialize-release</category><body package="PostgreSQLDriver">readFrom: aStream 	"^self 	I initialize myself as an empty query response. This means reading the 	'unused' string that forms a part of the response, and that's about it."	StringValue readFrom: aStream for: self.	^self</body></methods><methods><class-id>EmptyQueryResponseMessage</class-id> <category>services</category><body package="PostgreSQLDriver">resultFor: aQuery 	"^a Message 	I return the result for a message. I represent acknowlegement of an 	empty query. I just return 	myself, but before I do I must make sure 	that there are no more interesting messages waiting - I expect that 	the next message from the server will be 'ReadyForQuery'."	| nextResult |	nextResult := aQuery readStream next resultFor: aQuery.	nextResult isReadyForQuery ifFalse: [PostgreSQLUnexpectedMessage raise].	^self</body></methods><methods><class-id>ErrorResponseMessage</class-id> <category>initialize-release</category><body package="PostgreSQLDriver">readFrom: aStream 	"^self 	I initialize myself with the message associated with the error response 	I represent."	errorMessage := (StringValue readFrom: aStream for: self) value.	^self</body></methods><methods><class-id>ErrorResponseMessage</class-id> <category>printing</category><body package="PostgreSQLDriver">printOn: aStream 	"^self 	I return a string representation of myself. I get my superclass 	behavior to do it's thing, then I write out the error message. Error 	messages seem to end with a &gt;&gt;cr, so I don't bother writing one of 	my own."	super printOn: aStream.	aStream nextPutAll: 'Error message: ' , self errorMessage.	^self</body></methods><methods><class-id>ErrorResponseMessage</class-id> <category>services</category><body package="PostgreSQLDriver">finalizeStartupFor: aConnection 	"^self 	I've been received from the back end in response to a startup packet. 	This is bad news - it means that an error occured during startup, 	and the connection will not become active. I throw an exception to 	that effect."	PostgreSQLErrorResponse raiseSignal: errorMessage.	^self</body><body package="PostgreSQLDriver">resultFor: aQueryResult 	"^a Message 	The key result of my arrival is that an exception is thrown. Bifore 	throwing the exception I try and read the next ready for query 	message to clear the inbound message stream. If I get an 	StreamError exception trying to read the next message I just ignore 	it - the connection is probably broken because of the exception I 	represent."	| nextMessage |	NativeExceptionContext		for: 			[nextMessage := aQueryResult readStream next.			nextMessage isReadyForQuery ifFalse: [PostgreSQLUnexpectedMessage raise]]		on: StreamError		do: [:exception | ].	PostgreSQLErrorResponse raiseSignal: errorMessage.	^nextMessage resultFor: aQueryResult</body></methods><methods><class-id>ErrorResponseMessage</class-id> <category>accessing</category><body package="PostgreSQLDriver">errorMessage	"^a String 	I return the string which is the textual form of the error response I 	represent."	^errorMessage</body></methods><methods><class-id>FunctionVoidResponse</class-id> <category>accessing</category><body package="PostgreSQLDriver">value	"^nil 	I'm a void response, and so have no value."	^nil</body></methods><methods><class-id>FunctionVoidResponse class</class-id> <category>instance creation</category><body package="PostgreSQLDriver">readResultBodyFrom: aStream inTheContextOf: aMessage 	"^an FunctionResponse 	The body of the response is processed. My subclasses must 	implement this."	self notYetImplemented.	^self</body></methods><methods><class-id>RMessage</class-id> <category>services</category><body package="PostgreSQLDriver">finalizeStartupFor: aConnection 	"^selfI finalize the startup process for a connection.  I have been received in response to a startup packet, and now the connection is asking me to finsih the job og getting the connection going.  The steps are subclass specific, so this method must be overridden by my subclasses."	^self subclassResponsibility</body></methods><methods><class-id>RMessage</class-id> <category>initialize-release</category><body package="PostgreSQLDriver">readAuthenticationDetailFrom: aStream for: aConnectionContext 	"^self or an exceptionNot all of my subclasses are supported yet.  The default behavior at this point is to throw an unsupported exception and give up, my more capable subclasses will override this with useful behavior."	^PostgreSQLUnsupportedFeature raise</body></methods><methods><class-id>RMessage class</class-id> <category>instance creation</category><body package="PostgreSQLDriver">readAuthenticationDetailFrom: aStream for: aConnectionContext 	"My instances represent a request from the backend for particular kind of authentication.  My subclass instances do the right thing."	^self new readAuthenticationDetailFrom: aStream for: aConnectionContext</body><body package="PostgreSQLDriver">readMessageBodyFrom: aStream for: aConnectionContext 	"^an RMessage 	I return a new instance of one of my subclasses. It has already been 	determined (probably by my superclass) that the message emerging from 	the stream is an 'R' message. R messages are defined in the protocol spec, 	and are all to do with the back end response to a startup packet. I'll 	determine which particular R message this is by looking at the next few 	bytes. Then I'll pass this request to the appropriate subclass to take it from 	there."	| authenticationResponse |	authenticationResponse := (IntValue 				size: 32				readFrom: aStream				for: aConnectionContext) value.	^(self subclassesByAuthenticationCode at: authenticationResponse) 		readAuthenticationDetailFrom: aStream		for: aConnectionContext</body></methods><methods><class-id>RMessage class</class-id> <category>private</category><body package="PostgreSQLDriver">subclassesByAuthenticationCode	"^an IdentityDictionaryI return a dictionary of my subclasses indexed by their authentication code as returned by the back end."	subclassesByAuthenticationCode isNil 		ifTrue: 			[subclassesByAuthenticationCode := IdentityDictionary new: 5.			subclassesByAuthenticationCode at: 0 put: AuthenticationOKMessage.			subclassesByAuthenticationCode at: 1 put: AuthenticationKerberosV4Message.			subclassesByAuthenticationCode at: 2 put: AuthenticationKerberosV5Message.			subclassesByAuthenticationCode at: 3				put: AuthenticationUnencryptedPasswordMessage.			subclassesByAuthenticationCode at: 4				put: AuthenticationEncryptedPasswordMessage.			subclassesByAuthenticationCode at: 5 put: AuthenticationMD5PasswordMessage].	^subclassesByAuthenticationCode</body></methods><methods><class-id>AuthenticationOKMessage</class-id> <category>services</category><body package="PostgreSQLDriver">finalizeStartupFor: aMessageFlow 	"^self 	I finalize the startup process for aMessageFlow. I have been received 	in response to a startup packet, and now aMessageFlow is asking me 	to finsih the job of getting the connection going. I represent the 	authentication OK message, so authentication is all done now. Next, 	the postmaster hands off to a separate backend process. More 	messages are on the way, so I read them and hand off the 	finalization to them."	aMessageFlow readStream next finalizeStartupFor: aMessageFlow.	^self</body></methods><methods><class-id>AuthenticationOKMessage</class-id> <category>initialize-release</category><body package="PostgreSQLDriver">readAuthenticationDetailFrom: aStream for: aConnectionContext 	"^selfI record my context and return myself.  That's it."	self contextParent: aConnectionContext.	^self</body></methods><methods><class-id>AuthenticationMD5PasswordMessage</class-id> <category>initialize-release</category><body package="PostgreSQLDriver">readAuthenticationDetailFrom: aStream for: aConnectionContext 	"^self 	I record my context and the 'salt' which I use to encrypt the password."	self contextParent: aConnectionContext.	salt := (ByteValue				size: 4				readFrom: aStream				for: self) value.	^self</body></methods><methods><class-id>AuthenticationMD5PasswordMessage</class-id> <category>emitting</category><body package="PostgreSQLDriver">finalizeStartupFor: aStartupMessageFlow 	"^self I represent the MD5 Password Request from the backend. The backend is challenging the connection request and wants an MD% encoded password in response. I create a PasswordPacket for aStartupMessageFlow and send that to the backend. I then read the next response from the backend and delegate further processing to it."	aStartupMessageFlow writeStream nextPut: (PasswordPacket for: self).	aStartupMessageFlow readStream next 		finalizeStartupFor: aStartupMessageFlow.	^self</body></methods><methods><class-id>AuthenticationMD5PasswordMessage</class-id> <category>encoding</category><body package="PostgreSQLDriver">digestFrom: bytes 	"^a ByteArrayPostgreSQL uses the following method for producing an MD5 digest:	1. Get the MD5 digest for the bytes.  This yields a 16 byte digest.	2. Convert the digest into a 32 character hex string (e.g. 0a2b3c...)		Note: the letters in the hex string *must* be lower case!	3. Convert the hex string back to bytes yeilding a 32 byte array."	| hash hexString |	hash := NativeMD5Digest byteHash: bytes.	hexString := (ByteValue 				size: hash size				value: hash				for: self) asHexString 				asLowercase.	^(StringValue value: hexString for: self) bytes</body><body package="PostgreSQLDriver">passwordBytes	"^ByteValue 	I return a ByteArray that contains the MD5 encoded password for my 	connection. I use StringValue instances to handle the strings in case they 	use multi-byte characters."	| passwordBytes usernameBytes staticStringAsBytes firstDigest secondDigest |	passwordBytes := (StringValue value: self connection parameters password				for: self) bytes.	usernameBytes := (StringValue value: self connection parameters userName				for: self) bytes.	firstDigest := self digestFrom: passwordBytes , usernameBytes.	secondDigest := self digestFrom: firstDigest , self salt.	staticStringAsBytes := (StringValue value: 'md5' for: self) bytes.	^staticStringAsBytes , secondDigest , #[0]</body></methods><methods><class-id>AuthenticationMD5PasswordMessage</class-id> <category>accessing</category><body package="PostgreSQLDriver">salt	"^a ByteArrayI return the 'salt' that was supplied by the backend.  The salt just makes it a bit harder to break into a postgreSQL backend by adding a random element to the encoding.  It's like this:  if someone knows my name, and I'm dead lazy and use a simple word (e.g. 'password') as my password, someone could just generate a whole load of MD5 encodings and try them one at a time until they get in, masquerading as me.  If we add in the 4 bytes of 'salt' from the back end, this simple brute-force crack is denied.  There you go.  See also self&gt;&gt;passwordBytes"	^salt</body></methods><methods><class-id>AsciiRowMessage</class-id> <category>initialize-release</category><body package="PostgreSQLDriver">readFrom: aStream 	"^self 	I initialize myself to know nullFieldBitMap and the fields themselves."	| bitMap |	bitMap := BitMapValue				size: self numberOfFields				readFrom: aStream				for: self.	1 to: self numberOfFields do: [:fieldNumber | (bitMap at: fieldNumber)			== 1 ifTrue: [self fields at: fieldNumber put: (AsciiField readFrom: aStream for: self)]].	^self</body></methods><methods><class-id>AsciiRowMessage</class-id> <category>accessing</category><body package="PostgreSQLDriver">fields	"^an Array 	I return my array of fields. This is a sparsely poulated represention of the row, where null database 	values are represented by nil."	fields isNil ifTrue: [fields := Array new: self numberOfFields].	^fields</body><body package="PostgreSQLDriver">result	"^a PostgreSQLQueryResult 	I return the result of which I represent a single row.  As it happens, my contextParent is a PostgreSQLQueryResult, so I return that."	^self contextParent</body></methods><methods><class-id>AsciiRowMessage</class-id> <category>testing</category><body package="PostgreSQLDriver">isRow	"^a Boolean 	I return true only if I'm a Row message. I return true."	^true</body></methods><methods><class-id>AsciiRowMessage</class-id> <category>services</category><body package="PostgreSQLDriver">numberOfFields	"^an Integer 	I return the number of fields (columns) in the row I represent. I get this information from the result of 	which I am a part."	^self result rowDescription numberOfFields</body><body package="PostgreSQLDriver">typeOfColumn: aColumnIndex 	"^a Symbol 	I return the type of data in aColumnIndex."	^self result typeOfColumn: aColumnIndex</body></methods><methods><class-id>AsciiRowMessage</class-id> <category>printing</category><body package="PostgreSQLDriver">printOn: aStream 	"^self 	I write a representation of myself to aStream. In addition to 	information printed by my superclass, I write details of my fields."	super printOn: aStream.	self fields inject: 1		into: 			[:fieldNumber :aField | 			aStream nextPutAll: 'Field #' , fieldNumber printString , ': '.			aField printOn: aStream.			aStream cr.			fieldNumber + 1].	^self</body></methods><methods><class-id>PostgreSQLFrontendMessage</class-id> <category>emitting</category><body package="PostgreSQLDriver">writeTo: aStream 	"^self 	I write myself to aStream. I write out my values according to the 	spec."	^self subclassResponsibility</body></methods><methods><class-id>PostgreSQLFrontendMessage</class-id> <category>printing</category><body package="PostgreSQLDriver">printMessageBodyOn: aStream 	"^self 	I write a human readable representation of the message I represent 	to aStream. By default, I write in exactly the same form that I send 	to the back end. My subclasses may override this for legibility."	self writeTo: aStream.	^self</body><body package="PostgreSQLDriver">printOn: aStream 	"^self 	I return a string representation of myself. This string is intended to 	aid developers, and is not a critical part of the library."	aStream nextPutAll: '&gt;&gt;&gt;&gt;&gt;'; tab.	super printOn: aStream.	aStream cr.	^self</body></methods><methods><class-id>PostgreSQLFrontendMessage</class-id> <category>initialize-release</category><body package="PostgreSQLDriver">for: aContextParent 	"^a PostgreSQLFrontendMessage subclassI return a new instance of myself within the context of aConnectionContext which is probably a message flow of some kind."	self contextParent: aContextParent.	^self</body></methods><methods><class-id>PostgreSQLFrontendMessage class</class-id> <category>instance creation</category><body package="PostgreSQLDriver">for: aContextParent 	"^a PostgreSQLFrontendMessage subclass 	I return a new instance of myself within the context of aContextParent."	^self basicNew for: aContextParent</body><body package="PostgreSQLDriver">new	"^selfMy instances should not be created in this way."	^self shouldNotImplement</body></methods><methods><class-id>QueryMessage</class-id> <category>accessing</category><body package="PostgreSQLDriver">queryString	"^a String 	I return the string containing the query I am to send to the server."	queryString isNil ifTrue: [queryString := String new].	^queryString</body><body package="PostgreSQLDriver">queryString: aString 	"^self 	I record the string containing the query I am to send to the server."	queryString := aString.	^self</body></methods><methods><class-id>QueryMessage</class-id> <category>emitting</category><body package="PostgreSQLDriver">writeTo: aStream 	"^self 	I write myself to aStream. I write out my values according to the spec."	(ByteValue size: 1 value: 'Q' asByteArray for: self)		writeTo: aStream.	(StringValue value: self queryString for: self)		writeTo: aStream.	aStream flush.	^self</body></methods><methods><class-id>QueryMessage</class-id> <category>printing</category><body package="PostgreSQLDriver">printOn: aStream 	"^self 	I return a string representation of myself. This string is intended to 	aid developers, and is not a critical part of the library."	super printOn: aStream.	queryString printOn: aStream.	aStream cr.	^self</body></methods><methods><class-id>TerminateMessage</class-id> <category>emitting</category><body package="PostgreSQLDriver">writeTo: aStream 	"^self 	I write myself to aStream. I write out my values according to the spec."	(ByteValue		size: 1		value: 'X' asByteArray		for: self)		writeTo: aStream.	aStream flush.	^self</body></methods><methods><class-id>StartupPacket</class-id> <category>accessing</category><body package="PostgreSQLDriver">additionalArguments	"^a LimStringValue 	I return a LimStringValue of length 64 containing any additional arguments 	to be passed to the back end."	additionalArguments isNil ifTrue: [additionalArguments := LimStringValue					size: 64					value: self connection parameters additionalArguments					for: self].	^additionalArguments</body><body package="PostgreSQLDriver">databaseName	"^a LimStringValue 	I return a LimStringValue of length 64 containing the name of the database I 	represent a connection startup packet for."	databaseName isNil ifTrue: [databaseName := LimStringValue					size: 64					value: self connection parameters databaseName					for: self].	^databaseName</body><body package="PostgreSQLDriver">debuggingTTY	"^a LimStringValue 	I return a LimStringValue of length 64 containing the debugging TTYl 	argument to be passed to the back end."	debuggingTTY isNil ifTrue: [debuggingTTY := LimStringValue					size: 64					value: self connection parameters debuggingTTY					for: self].	^debuggingTTY</body><body package="PostgreSQLDriver">packetSize	"^an IntValue 	I return an Int value with a size of 32 bits and a value of 296, as per the front-end/back-end protocol 	2.0 spec."	packetSize isNil ifTrue: [packetSize := IntValue size: 32 value: 296 for: self].	^packetSize</body><body package="PostgreSQLDriver">protocolVersionNumber	"^an IntValue 	I return an IntValue of 32 bits with the value containing the protocol 	version number with the major part of the number in the first 16 	bits, and the minor part of the number in the second 16 bits. I 	currently implement version 2.0 of the protocol, so the value is (2 	**(16 + 1)) + 0."	protocolVersionNumber isNil		ifTrue: 			[| majorVersionNumber minorVersionNumber versionCode |			majorVersionNumber := 2.			minorVersionNumber := 0.			versionCode := (majorVersionNumber bitShift: 16)						+ minorVersionNumber.			protocolVersionNumber := IntValue size: 32 value: versionCode for: self].	^protocolVersionNumber</body><body package="PostgreSQLDriver">userName	"^a LimString 	I return a LimString with a size of 32 and a value of the name of the user 	this startup packet is a connection attempt for."	userName isNil ifTrue: [userName := LimStringValue					size: 32					value: self connection parameters userName					for: self].	^userName</body></methods><methods><class-id>StartupPacket</class-id> <category>emitting</category><body package="PostgreSQLDriver">writeTo: aStream 	"^self 	I write myself to aStream. I write out my values according to the 	spec. Note that for the 64 byte blank 'unused' chunk I send an 	empty LimString."	self packetSize writeTo: aStream.	self protocolVersionNumber writeTo: aStream.	self databaseName writeTo: aStream.	self userName writeTo: aStream.	self additionalArguments writeTo: aStream.	(LimStringValue size: 64 value: String new for: self)		writeTo: aStream.	self debuggingTTY writeTo: aStream.	aStream flush.	^self</body></methods><methods><class-id>StartupPacket</class-id> <category>printing</category><body package="PostgreSQLDriver">printOn: aStream 	"^self 	I return a string representation of myself. This string is intended to 	aid developers, and is not a critical part of the library."	super printOn: aStream.	aStream nextPutAll: 'Packet size: ' , self packetSize value printString; cr.	aStream nextPutAll: 'Protocol version number: ' , self protocolVersionNumber bytes printString; cr.	aStream nextPutAll: 'Database name: ' , self databaseName value printString; cr.	aStream nextPutAll: 'User name: ' , self userName value printString; cr.	aStream nextPutAll: 'Additional arguments: ' , self additionalArguments value printString; cr.	aStream nextPutAll: 'Debugging TTY: ' , self debuggingTTY value printString; cr.	^self</body></methods><methods><class-id>FunctionCallPacket</class-id> <category>accessing</category><body package="PostgreSQLDriver">addArgument: aPacketValue 	"^self 	I add aPacketValue to my collection of arguments."	self arguments add: aPacketValue.	^self</body><body package="PostgreSQLDriver">function	"^self 	I return the function that I represent the invokation of."	^function</body><body package="PostgreSQLDriver">function: aFunction 	"^self 	I record the function that I represent the invokation of."	function := aFunction.	^self</body></methods><methods><class-id>FunctionCallPacket</class-id> <category>emitting</category><body package="PostgreSQLDriver">writeArgumentsTo: aStream 	"^self 	I write my arguments to aStream. This involves first writing out the number of 	arguments followed by a pair of values for each argument. The pair of 	values is the size of the argument, followed by 	the bytes in the argument 	itself."	(IntValue		size: 32		value: self arguments size		for: self)		writeTo: aStream.	self arguments		do: 			[:anArgument | 			(IntValue				size: 32				value: anArgument bytes size				for: self)				writeTo: aStream.			anArgument writeTo: aStream].	^self</body><body package="PostgreSQLDriver">writeTo: aStream 	"^self 	I write myself to aStream. I write out my values according to the spec."	(ByteValue		size: 1		value: 'F' asByteArray		for: self)		writeTo: aStream.	(StringValue value: '' for: self)		writeTo: aStream.	(IntValue		size: 32		value: self function objectId		for: self)		writeTo: aStream.	self writeArgumentsTo: aStream.	aStream flush.	^self</body></methods><methods><class-id>FunctionCallPacket</class-id> <category>private</category><body package="PostgreSQLDriver">arguments	"^an OrderedCollection 	I return my collection of arguments. They must all be message values."	arguments isNil ifTrue: [arguments := OrderedCollection new].	^arguments</body></methods><methods><class-id>FunctionCallPacket</class-id> <category>printing</category><body package="PostgreSQLDriver">printOn: aStream 	"^self 	I return a string representation of myself. This string is intended to 	aid developers, and is not a critical part of the library."	super printOn: aStream.	aStream nextPutAll: 'Function: '.	self function printOn: aStream.	aStream cr.	self arguments inject: 1		into: 			[:argumentNumber :anArgument | 			aStream nextPutAll: 'Field #' , argumentNumber printString , ': '.			anArgument bytes printOn: aStream.			aStream cr.			argumentNumber + 1].	^self</body></methods><methods><class-id>PasswordPacket</class-id> <category>accessing</category><body package="PostgreSQLDriver">packetSize	"^an IntValue 	I return an Int value with a size of 32 bits and a value of the size of 	my the packet I represent. The packet size, therefore, is 4 + 	&lt;password length&gt; + 1. The final 1 is the null termination in the 	password string."	packetSize isNil ifTrue: [packetSize := IntValue					size: 32					value: 4 + self passwordBytes bytes size					for: self].	^packetSize</body><body package="PostgreSQLDriver">passwordBytes	"^a ByteArray 	I return a ByteArray which contains the encoded password for my 	connection."	passwordBytes isNil		ifTrue: 			[| rawPasswordBytes |			rawPasswordBytes := self contextParent passwordBytes.			passwordBytes := ByteValue						size: rawPasswordBytes size						value: rawPasswordBytes						for: self].	^passwordBytes</body></methods><methods><class-id>PasswordPacket</class-id> <category>emitting</category><body package="PostgreSQLDriver">writeTo: aStream 	"^self 	I write myself to aStream."	self packetSize writeTo: aStream.	self passwordBytes writeTo: aStream.	aStream flush.	^self</body></methods><methods><class-id>PasswordPacket</class-id> <category>printing</category><body package="PostgreSQLDriver">printOn: aStream 	"^self 	I return a string representation of myself. This string is intended to 	aid developers, and is not a critical part of the library."	super printOn: aStream.	aStream nextPutAll: 'Packet size: ' , self packetSize value printString; cr.	aStream nextPutAll: 'Password: ' , self passwordBytes asString printString; cr.	^self</body></methods><methods><class-id>AuthenticationUnencryptedPasswordMessage</class-id> <category>emitting</category><body package="PostgreSQLDriver">finalizeStartupFor: aStartupMessageFlow 	"^self 	I represent the Unencrypted Password Request from the backend. 	The backend is challenging the connection request and wants a 	plain text password in response. I create a PasswordPacket and send that 	to the backend. I then read the next response from the backend and 	delegate further processing to it."	aStartupMessageFlow writeStream nextPut: (PasswordPacket for: self).	aStartupMessageFlow readStream next finalizeStartupFor: aStartupMessageFlow.	^self</body></methods><methods><class-id>AuthenticationUnencryptedPasswordMessage</class-id> <category>encoding</category><body package="PostgreSQLDriver">passwordBytes	"^ByteValueI return a ByteArray that contains unencrypted password."	^(StringValue value: self connection parameters password for: self) bytes 		, #[0]</body></methods><methods><class-id>AuthenticationUnencryptedPasswordMessage</class-id> <category>initialize-release</category><body package="PostgreSQLDriver">readAuthenticationDetailFrom: aStream for: aConnectionContext 	"^selfI record my context and return myself.  That's it."	self contextParent: aConnectionContext.	^self</body></methods><methods><class-id>CursorResponseMessage</class-id> <category>accessing</category><body package="PostgreSQLDriver">cursorName	"^a String 	I return the name of the cursor I represent."	^cursorName asString</body></methods><methods><class-id>CursorResponseMessage</class-id> <category>initialize-release</category><body package="PostgreSQLDriver">readFrom: aStream 	"^self 	I initialize myself as a cursor response. I read the cursor name from 	aStream."	cursorName := (StringValue readFrom: aStream for: self) value.	^self</body></methods><methods><class-id>CursorResponseMessage</class-id> <category>testing</category><body package="PostgreSQLDriver">isCursorResponse	"^a Boolean 	I return true only if I'm a CursorResponse message. I return true."	^true</body></methods><methods><class-id>CursorResponseMessage</class-id> <category>services</category><body package="PostgreSQLDriver">resultFor: aQueryResult 	"^a Message I return the result for a message. I represent a cursor response and that means that I'm followed by a row description. Once I get the row description I read the row data until I read a CompletedResponse message, and finally a ReadyForQuery. Looks like this needs some re-factoring, eh?**Due to a change in the fontend-backend protocol version 0 2 0 0, I must check to see if I another CursorResponseMessage follows right after the one that led to my creation.  If there is, I take the last one as being the 'correct' one."	| nextMessage |	"PostgreSQLConnection uglyMethod."	nextMessage := aQueryResult readStream next.	[nextMessage class == self class] whileTrue: 			[cursorName := nextMessage cursorName.			nextMessage := aQueryResult readStream next].	aQueryResult cursorResponse: self.	nextMessage := nextMessage resultFor: aQueryResult.	nextMessage isRowDescription 		ifTrue: 			[aQueryResult rowDescription: nextMessage.			nextMessage := (aQueryResult readStream nextInTheContextOf: aQueryResult) 						resultFor: aQueryResult.			[nextMessage isRow] whileTrue: 					[aQueryResult rows add: nextMessage.					nextMessage := (aQueryResult readStream nextInTheContextOf: aQueryResult) 								resultFor: aQueryResult]].	nextMessage isCompletedResponse 		ifFalse: [PostgreSQLUnexpectedMessage raise].	aQueryResult addCompletedResponse: nextMessage.	^self</body></methods><methods><class-id>CursorResponseMessage</class-id> <category>printing</category><body package="PostgreSQLDriver">printOn: aStream 	"^self 	I return a string representation of myself. In addition to information printed by my superclass, I print 	out my cursor name."	super printOn: aStream.	aStream nextPutAll: 'Cursor name: ' , self cursorName; cr.	^self</body></methods><methods><class-id>RowDescriptionMessage</class-id> <category>initialize-release</category><body package="PostgreSQLDriver">readFrom: aStream 	"^self 	I initialize myself as a row description response. I read the number of fields 	and all the field descriptions from aStream."	numberOfFields := (IntValue				size: 16				readFrom: aStream				for: self) value.	numberOfFields timesRepeat: [self fieldDescriptions add: (FieldDescription readFrom: aStream for: self)].	^self</body></methods><methods><class-id>RowDescriptionMessage</class-id> <category>accessing</category><body package="PostgreSQLDriver">fieldDescriptions	"^an OrderedCollection 	I return my collection of field descriptions."	fieldDescriptions isNil ifTrue: [fieldDescriptions := OrderedCollection new].	^fieldDescriptions</body><body package="PostgreSQLDriver">numberOfFields	"^an Integer 	I return the number of field descriptions I have."	^numberOfFields</body></methods><methods><class-id>RowDescriptionMessage</class-id> <category>testing</category><body package="PostgreSQLDriver">isRowDescription	"^a Boolean 	I return true only if I'm a RowDescription message. I return true."	^true</body></methods><methods><class-id>RowDescriptionMessage</class-id> <category>printing</category><body package="PostgreSQLDriver">printOn: aStream 	"^self 	I return a string representation of myself. In addition to information printed by my superclass, I print 	out the number of fields and the field descriptions."	super printOn: aStream.	aStream nextPutAll: 'Number of fields: ' , self numberOfFields printString; cr.	fieldDescriptions		do: 			[:aFieldDescription | 			aFieldDescription printOn: aStream.			aStream cr].	^self</body></methods><methods><class-id>FunctionResultResponse</class-id> <category>initialize-release</category><body package="PostgreSQLDriver">readFrom: aStream 	"^an FunctionResponse 	I initialize my value by reading from aStream. First I read the size of the 	value, then the value itself, and finally I read a trailing '0' character."	| resultSize |	resultSize := (IntValue				size: 32				readFrom: aStream				for: self) value.	value := ByteValue				size: resultSize				readFrom: aStream				for: self.	ByteValue		size: 1		readFrom: aStream		for: self.	^self</body></methods><methods><class-id>FunctionResultResponse</class-id> <category>accessing</category><body package="PostgreSQLDriver">value	"^a ByteValue 	I return the value returned by a function call."	^value</body></methods><methods><class-id>FunctionResultResponse class</class-id> <category>instance creation</category><body package="PostgreSQLDriver">readResultBodyFrom: aStream inTheContextOf: aResult 	"^an FunctionResponse 	I create a new instance of myself and get it to initialize itself from the next bytes from aStream."	^self new readFrom: aStream for: aResult</body></methods><methods><class-id>NoticeResponseMessage</class-id> <category>initialize-release</category><body package="PostgreSQLDriver">readFrom: aStream 	"^a Message 	I initialize myself to the message associated with the error response 	I represent. See &gt;&gt;resultFor: to see what happend next..."	message := (StringValue readFrom: aStream for: self) value.	^self</body></methods><methods><class-id>NoticeResponseMessage</class-id> <category>accessing</category><body package="PostgreSQLDriver">message	"^a String 	I return the message from the Notice Response I represent."	^message</body></methods><methods><class-id>NoticeResponseMessage</class-id> <category>printing</category><body package="PostgreSQLDriver">printOn: aStream 	"^self 	I return a string representation of myself. I get my superclass 	behavior to do it's thing, then I write out the error message. 	Messages seem to end with a &gt;&gt;cr, so I don't bother writing one of 	my own."	super printOn: aStream.	aStream nextPutAll: 'Message: ' , self message.	^self</body></methods><methods><class-id>NoticeResponseMessage</class-id> <category>services</category><body package="PostgreSQLDriver">resultFor: aQueryResult 	"^a Message 	The key result of my arrival is that a proceedable exception is 	thrown. Once that's out of the way, I resume reading messages from 	the input stream."	| exception |	exception := PostgreSQLNoticeResponse new.	exception messageText: self message.	exception parameter: self.	exception raise.	^aQueryResult readStream next resultFor: aQueryResult</body></methods><methods><class-id>PostgreSQLAbstractCompletedResponseMessage</class-id> <category>accessing</category><body package="PostgreSQLDriver">commandTag	"^a String 	I return the command tag in the form I received it from the backend."	^commandTag</body></methods><methods><class-id>PostgreSQLAbstractCompletedResponseMessage</class-id> <category>initialize-release</category><body package="PostgreSQLDriver">readFrom: aStream 	"^self 	I get my command tag from my class, so I'm not expecetd to read ir myself.  This is therefore a no-op."	^self</body><body package="PostgreSQLDriver">withCommandTag: aString 	"^self 	I initialize myself as a complete response message. I read the command tag 	from aStream."	commandTag := aString.	^self</body></methods><methods><class-id>PostgreSQLAbstractCompletedResponseMessage</class-id> <category>printing</category><body package="PostgreSQLDriver">printOn: aStream 	"^self 	I return a string representation of myself. In addition to information printed by my superclass, I print 	out my command tag."	super printOn: aStream.	aStream nextPutAll: 'Command tag: ' , self commandTag; cr.	^self</body></methods><methods><class-id>PostgreSQLAbstractCompletedResponseMessage</class-id> <category>testing</category><body package="PostgreSQLDriver">isCompletedResponse	"^a Boolean 	I return true only if I'm a CompletedResponse message.  I return true."	^true</body></methods><methods><class-id>PostgreSQLAbstractCompletedResponseMessage</class-id> <category>services</category><body package="PostgreSQLDriver">resultFor: aResultQuery 	"^a Message 	The message I represent marks the end of the response from the 	backend for a given query. I just return myself."	aResultQuery addCompletedResponse: self.	^self</body></methods><methods><class-id>PostgreSQLAbstractCompletedResponseMessage class</class-id> <category>instance creation</category><body package="PostgreSQLDriver">readMessageBodyFrom: aStream for: aConnectionContext 	"^a Completed Response of some kind 	I return a new instance of one of my subclasses. It has already been 	determined (probably by my superclass) that the message emerging 	from the stream is a CompletedResponse of some kind. I read the command 	tag from aStream and pass that on to the approprpriate one of my 	subclasses."	| commandTag |	commandTag := (StringValue readFrom: aStream for: aConnectionContext) value.	^('INSERT*' match: commandTag)		ifTrue: [CompletedInsertResponseMessage new withCommandTag: commandTag]		ifFalse: [CompletedResponseMessage new withCommandTag: commandTag]</body></methods><methods><class-id>CompletedResponseMessage</class-id> <category>initialize-release</category><body package="PostgreSQLDriver">withCommandTag: aString 	"^self 	I initialize myself as a complete response message. I read the command tag 	from aStream.	** Note this version of the method is not really needed (my superclass implements this), but	because of the order StORE loads things, and because when we load the PostgreSQL drivers	from StORE we are performing brain surgery on ourselves this implementation is required.  This 	method can be deleted in future versions, but for those loading from StORE on top of 1.0 023,	this method really is needed."	commandTag := aString.	^self</body></methods><methods><class-id>PostgreSQLNoticeResponse</class-id> <category>testing</category><body package="PostgreSQLDriver">isNoticeResponse	"^a Boolean 	I return true if I am a notice response, otherwise, I return false.  I am a notice response, so I return true."	^true</body></methods><methods><class-id>PostgreSQLNoticeResponse class</class-id> <category>testing</category><body package="PostgreSQLDriver">mayResume	"^true 	My instances are all notification responses, which mean that they 	are reporting interesting, rather than critical things. This means it's 	always OK to resume if one of my instances it thrown."	^true</body></methods><methods><class-id>PostgreSQLMessageWriteStream</class-id> <category>accessing</category><body package="PostgreSQLDriver">nextPut: aMessage 	"^self 	First I log aMessage, then I write the binary form of aMessage to my 	underlying stream."	self log: aMessage. 	aMessage writeTo: self underlyingStream.	^self</body></methods><methods><class-id>PostgreSQLMessageWriteStream</class-id> <category>private</category><body package="PostgreSQLDriver">underlyingStream	"^a Stream 	I return my underlying write stream."	underlyingStream isNil ifTrue: [underlyingStream := self connection socketSession writeStream binary].	^underlyingStream</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>NativeError</name><environment>Smalltalk</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PostgreSQLVWCompatibility</category><attributes><package>PostgreSQLVWCompatibility</package></attributes></class></st-source>