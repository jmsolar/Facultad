<?xml version="1.0"?><st-source><!-- Name: PostgreSQLMonitorComment: ©Bruce Badger 2001 - 2004. Licensed under the LGPL.  This is an experimental UI for monitoring PostgreSQL connections.Please send your comments to bbadger@openskills.com.  Thanks.DbIdentifier: OSSYD001DbTrace: 2205DevelopmentPrerequisites: #(#(#package 'FileSelectionDialog' '') #(#any 'StoreForPostgreSQL' ''))PackageName: PostgreSQLMonitorParcel: #('PostgreSQLMonitor')PrerequisiteParcels: #(#('FileSelectionDialog' '') #('StoreForPostgreSQL' ''))PrintStringCache: (1.3 014,bbadger)Version: 1.3 014Date: 8:03:36 pm November 4, 2004 --><time-stamp>From VisualWorks® NonCommercial, 7.2 of November 3, 2003 on November 4, 2004 at 8:03:36 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>PostgreSQLMessagesView</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent receivedMessage sentMessage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PostgreSQLMonitor</category><attributes><package>PostgreSQLMonitor</package></attributes></class><class><name>PostgreSQLConnectionMonitor</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>monitoredConnection connectionDescription messageView </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PostgreSQLMonitor</category><attributes><package>PostgreSQLMonitor</package></attributes></class><class><name>PostgreSQLNextMessageDialog</name><environment>Smalltalk</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>messageText debugRequested proceedRequested </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIApplications-New</category><attributes><package>PostgreSQLMonitor</package></attributes></class><class><name>MonitoredPostgreSQLConnection</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PostgreSQLMonitor</category><attributes><package>PostgreSQLMonitor</package></attributes></class><class><name>PostgreSQLConnectionList</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connectionList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PostgreSQLMonitor</category><attributes><package>PostgreSQLMonitor</package></attributes></class><class><name>PostgreSQLMessagesControlView</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent showMessages singleStep messageView </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PostgreSQLMonitor</category><attributes><package>PostgreSQLMonitor</package></attributes></class><methods><class-id>PostgreSQLMessagesView</class-id> <category>private</category><body package="PostgreSQLMonitor">ceaseMessageDisplay	"^selfI stop logging the messages for mt subject connection."	self connection writeStream loggingBlock: nil.	self connection readStream loggingBlock: nil.	self inboundMessage value: ''.	self outboundMessage value: ''.	self parent disableSingleSteppingOption.	self parent singleStep value: false.	^self</body><body package="PostgreSQLMonitor">commenceMessageDisplay	"^self 	I commence the display of messages for the connection I represent."	self connection writeStream loggingBlock: self outboundLoggingBlock.	self connection readStream loggingBlock: self inboundLoggingBlock.	self parent enableSingleSteppingOption.	^self</body><body package="PostgreSQLMonitor">inboundLoggingBlock	"^a BlockClosure 	I return the block I hand to a connection to get the chance to process messages comming back from the PostgreSQL backend."	^[:aMessage | self showInboundMessage: aMessage]</body><body package="PostgreSQLMonitor">outboundLoggingBlock	"^a BlockClosure 	I return the block I hand to a connection to get the chance to process messages going to the PostgreSQL backend."	^[:aMessage | self showOutboundMessage: aMessage]</body><body package="PostgreSQLMonitor">showInboundMessage: aMessage 	"^self 	I display a textual representation of this inbound message."	self inboundMessage 		value: self inboundMessage value , (String with: Character cr) 				, aMessage displayString.	^self</body><body package="PostgreSQLMonitor">showOutboundMessage: aMessage 	"^self 	I display a textual representation of this outbound message.  Then I hand off control to my parent which may want to delay sending this message."	self inboundMessage value: ''.	self outboundMessage value: aMessage displayString.	self parent getPermissionToSend: aMessage.	^self</body></methods><methods><class-id>PostgreSQLMessagesView</class-id> <category>services</category><body package="PostgreSQLMonitor">connection	"^a PostgreSQLConnectionI return the connection whose messages I monitor."	^self monitoredConnection connection</body><body package="PostgreSQLMonitor">monitoredConnection	"^a MonitoredPostgreSQLConnection 	I return the wrapper object for the connection whose messages I monitor."	^self parent monitoredConnection</body><body package="PostgreSQLMonitor">parent	"an ApplicationModel 	I return my parent. My parent knows all kinds of contextual stuff like what 	connection I'm monitoring the messages for, and wether I should single step 	through outbound messages or not."	^parent</body></methods><methods><class-id>PostgreSQLMessagesView</class-id> <category>aspects</category><body package="PostgreSQLMonitor">inboundMessage	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^receivedMessage isNil 		ifTrue: [receivedMessage := String new asValue]		ifFalse: [receivedMessage]</body><body package="PostgreSQLMonitor">outboundMessage	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^sentMessage isNil 		ifTrue: [sentMessage := String new asValue]		ifFalse: [sentMessage]</body></methods><methods><class-id>PostgreSQLMessagesView</class-id> <category>initialize-release</category><body package="PostgreSQLMonitor">initializeFor: aParent 	"^selfI just make a note of my parent.  I need to know my parent so I can get hold of contextual information, such at the connection I'm controlling the messages for."	parent := aParent.	^self</body><body package="PostgreSQLMonitor">release	"^selfI release my grasp on the connection."	super release.	self ceaseMessageDisplay.	^self</body></methods><methods><class-id>PostgreSQLMessagesView</class-id> <category>actions</category><body package="PostgreSQLMonitor">showMessages: aBoolean 	"^self 	I'm being asked to either commence or cease displaying the messages 	passing between this image and the PostgreSQL backend via the 	connection my parent is monitoring."	aBoolean		ifTrue: [self commenceMessageDisplay]		ifFalse: [self ceaseMessageDisplay].	^self</body></methods><methods><class-id>PostgreSQLConnectionMonitor</class-id> <category>aspects</category><body package="PostgreSQLMonitor">connectionDescription	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^connectionDescription isNil		ifTrue:			[connectionDescription := String new asValue]		ifFalse:			[connectionDescription]</body></methods><methods><class-id>PostgreSQLConnectionMonitor</class-id> <category>accessing</category><body package="PostgreSQLMonitor">messageControlView	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^messageView isNil 		ifTrue: [messageView := PostgreSQLMessagesControlView new]		ifFalse: [messageView]</body><body package="PostgreSQLMonitor">monitoredConnection	"^a MonitoredPostgreSQLConnectionI return the monitored connection whose details I'm presenting."	^monitoredConnection</body></methods><methods><class-id>PostgreSQLConnectionMonitor</class-id> <category>interface closing</category><body package="PostgreSQLMonitor">noticeOfWindowClose: aWindow 	"^self	Time to close.  I make sure I'm completely detached from the connection."	super noticeOfWindowClose: aWindow.	self messageControlView release.	^self</body></methods><methods><class-id>PostgreSQLConnectionMonitor</class-id> <category>initialize-release</category><body package="PostgreSQLMonitor">on: aMonitoredPostgreSQLConnection 	"^a PostgreSQLConnectionMonitorI initialize myself to be able to present information about aMonitoredPostgreSQLConnection."	monitoredConnection := aMonitoredPostgreSQLConnection.	^self</body><body package="PostgreSQLMonitor">preBuildWith: aBuilder 	"^self 	I populate widgets with the initial low-cost information about the 	connection."	super preBuildWith: aBuilder.	self connectionDescription value: self monitoredConnection displayString.	self messageControlView initializeFor: self.	^self</body></methods><methods><class-id>PostgreSQLConnectionMonitor class</class-id> <category>instance creation</category><body package="PostgreSQLMonitor">openOn: aMonitoredPostgreSQLConnection 	"^a PostgreSQLConnectionMonitorI return an new instance if myself which presents information about aMonitoredPostgreSQLConnection."	| newMe |	newMe := self new on: aMonitoredPostgreSQLConnection.	newMe open.	^newMe</body></methods><methods><class-id>PostgreSQLNextMessageDialog</class-id> <category>accessing</category><body package="PostgreSQLMonitor">debugRequested	"^a BooleanI return true if the user has requested a debugger be opened, otherwise false."	debugRequested isNil ifTrue: [debugRequested := false].	^debugRequested</body><body package="PostgreSQLMonitor">debugRequested: aBoolean 	"^selfI record wether the user has requested a debugger be opened or not."	debugRequested := aBoolean.	^self</body><body package="PostgreSQLMonitor">proceedRequested	"^a BooleanI return true if the user has requested that we proceed without further stepping."	proceedRequested isNil ifTrue: [proceedRequested := false].	^proceedRequested</body><body package="PostgreSQLMonitor">proceedRequested: aBoolean 	"^selfI record wether the user has requested that we proceed without further stepping."	proceedRequested := aBoolean.	^self</body></methods><methods><class-id>PostgreSQLNextMessageDialog</class-id> <category>actions</category><body package="PostgreSQLMonitor">doDebug	"This stub method was generated by UIDefiner"	self debugRequested: true.	^self closeRequest</body><body package="PostgreSQLMonitor">doProceed	self proceedRequested: true.	^self closeRequest</body><body package="PostgreSQLMonitor">doStep	"^selfThe user has requested to send the message.  This is the default action, so I just close myself."	^self closeRequest</body></methods><methods><class-id>PostgreSQLNextMessageDialog</class-id> <category>aspects</category><body package="PostgreSQLMonitor">messageText	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^messageText isNil		ifTrue:			[messageText := String new asValue]		ifFalse:			[messageText]</body></methods><methods><class-id>PostgreSQLNextMessageDialog</class-id> <category>initialize-release</category><body package="PostgreSQLMonitor">on: aMessage 	"^selfI initilaize myself to present aMessage to the user."	self messageText value: aMessage displayString.	^self</body></methods><methods><class-id>PostgreSQLNextMessageDialog class</class-id> <category>instance creation</category><body package="PostgreSQLMonitor">openOn: aMessage 	"^a PostgreSQLNextMessageDialogI return an instance of myself which is close, but has done it's job of presenting aMessage to a user and getting their OK to send it to the PostgreSQL backend, or to open a debugger."	| newMe |	newMe := self new.	newMe on: aMessage.	newMe open.	^newMe</body></methods><methods><class-id>MonitoredPostgreSQLConnection</class-id> <category>accessing</category><body package="PostgreSQLMonitor">connection	"^a PostgreSQLConnectionI return the connection I represent."	^connection</body></methods><methods><class-id>MonitoredPostgreSQLConnection</class-id> <category>initialize-release</category><body package="PostgreSQLMonitor">on: aPostgreSQLConnection 	"^self 	I initialize myself to represent aPostgreSQLConnection in the context of the 	connection monitor."	connection := aPostgreSQLConnection.	^self</body></methods><methods><class-id>MonitoredPostgreSQLConnection</class-id> <category>printing</category><body package="PostgreSQLMonitor">displayString	"^a String 	I return a String representation of the connection I represent."	| parameters outputStream |	parameters := self connection parameters.	outputStream := String new writeStream.	outputStream		nextPutAll: parameters userName;		nextPut: $@;		nextPutAll: parameters host;		nextPut: $:;		nextPutAll: parameters port printString;		nextPut: $_;		nextPutAll: parameters databaseName.	self connection backendKeyData notNil 		ifTrue: 			[outputStream				nextPutAll: ' {Server PID: ';				nextPutAll: self connection backendKeyData processID printString;				nextPutAll: '}'].	^outputStream contents</body></methods><methods><class-id>MonitoredPostgreSQLConnection class</class-id> <category>instance creation</category><body package="PostgreSQLMonitor">on: aConnection 	"^a MonitoredPostgreSQLConnectionI create and return a new instance of myself initialized to represent aConnection for monitoring purposes."	^self new on: aConnection</body></methods><methods><class-id>PostgreSQLConnectionList</class-id> <category>aspects</category><body package="PostgreSQLMonitor">connectionList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^connectionList isNil		ifTrue:			[connectionList := SelectionInList new]		ifFalse:			[connectionList]</body></methods><methods><class-id>PostgreSQLConnectionList</class-id> <category>actions</category><body package="PostgreSQLMonitor">doBrowsePundlesUpdatedInLast5Days	"^selfI read connecton profiles from an XMLish file nominated by the user and add them to the list shown in the StORE login dialog."	| start end |	start := Timestamp new fromDate: (Date today subtractDays: 5).	end := Timestamp new fromDate: (Date today addDays: 1).	Store.PublishedPundlesTool 		openOnBundles: ((Store.Bundle allBundles select: 					[:each | 					(Timestamp fromSeconds: each timeStamp + each class timeOffset) 						between: start						and: end]) 				collect: [:each | each name]) asSet		packages: ((Store.Package allPackages select: 					[:each | 					(Timestamp fromSeconds: each timeStamp + each class timeOffset) 						between: start						and: end]) 				collect: [:each | each name]) asSet		title: ('Pundles changed between &lt;1p&gt; and &lt;2p&gt;' expandMacrosWith: start				with: end).	^self</body><body package="PostgreSQLMonitor">doClose	"This stub method was generated by UIDefiner"	^self closeRequest</body><body package="PostgreSQLMonitor">doCloseConnection	"^self 	I open an inspector on the currently selected connection (if any)."	| currentlySelectedConnection |	currentlySelectedConnection := self connectionList selection.	currentlySelectedConnection notNil 		ifTrue: [currentlySelectedConnection connection close].	self refreshConnectionList.	^self</body><body package="PostgreSQLMonitor">doInspect	"^self 	I open an inspector on the currently selected connection (if any)."	| currentlySelectedConnection |	currentlySelectedConnection := self connectionList selection.	currentlySelectedConnection notNil 		ifTrue: [currentlySelectedConnection connection inspect].	^self</body><body package="PostgreSQLMonitor">doLoadStOREProfiles	"^selfI read connecton profiles from an XMLish file nominated by the user and add them to the list shown in the StORE login dialog."	| filename readStream profiles |	filename := self targetFilename.	(filename isNil or: [filename exists not]) ifTrue: [^self].	readStream := filename readStream.	profiles := self class readProfilesFrom: readStream.	readStream close.	Store.ConnectionDialog profiles addAll: profiles.	^self</body><body package="PostgreSQLMonitor">doSaveStOREProfilesAs	"^selfI write out the current connecton profiles (the ones you see when logging into StORE) to a file nominated by the user."	| filename writeStream |	filename := self targetFilename.	filename isNil ifTrue: [^self].	writeStream := filename writeStream.	self class writeCurrentProfilesTo: writeStream.	writeStream close.	^self</body><body package="PostgreSQLMonitor">openConnectionMonitor	"^self 	I open a new PostgreSQLConnectionMonitor on the currently selected 	connection (if any)."	| currentlySelectedConnection |	currentlySelectedConnection := self connectionList selection.	currentlySelectedConnection notNil 		ifTrue: [PostgreSQLConnectionMonitor openOn: currentlySelectedConnection].	^self</body></methods><methods><class-id>PostgreSQLConnectionList</class-id> <category>private</category><body package="PostgreSQLMonitor">refreshConnectionList	"^self 	I find out what connections exist, create a 	MonitoredPostgreSQLConnection for each, and add them to the list."	| activeConnections |	activeConnections := PostgreSQLConnection activeConnections 				select: [:aConnection | aConnection isActive].	self connectionList 		list: (activeConnections 				collect: [:aConnection | MonitoredPostgreSQLConnection on: aConnection]) 					asList.	^self</body><body package="PostgreSQLMonitor">targetFilename	"^a Filename or nilI return the user selected target filename."	| filenameString |	filenameString := FileSelectionDialog 				allowDirectoryResult: false				allowFileResult: true				initialDirectory: nil				defaultTail: 'StORE-profiles.xml'				masks: #('*ml' '*').	^filenameString isNil 		ifTrue: [nil]		ifFalse: [Filename named: filenameString]</body></methods><methods><class-id>PostgreSQLConnectionList</class-id> <category>initialize-release</category><body package="PostgreSQLMonitor">preBuildWith: aBuilder 	"^self 	I get the initial list of PostgreSQL connections and add them to the 	connection list."	super preBuildWith: aBuilder.	self refreshConnectionList.	^self</body></methods><methods><class-id>PostgreSQLConnectionList class</class-id> <category>StORE profiles</category><body package="PostgreSQLMonitor">readProfilesFrom: aStream 	"^an OrderedCollection	I read StORE connection profiles from aStream and return them in an OrderedCollection."	"|stream| stream := String new writeStream.	PostgreSQLConnectionList writeCurrentProfilesTo: stream.	PostgreSQLConnectionList readProfilesFrom: (stream contents readStream)"	| profiles |	profiles := OrderedCollection new.	aStream throughAll: '&lt;StORE Profile&gt;'.	[aStream atEnd] whileFalse: 			[| newProfile |			newProfile := Store.ConnectionProfile new.			aStream throughAll: '&lt;name&gt;'.			newProfile name: (aStream upToAll: '&lt;/name&gt;').			aStream throughAll: '&lt;driverClassName&gt;'.			newProfile driverClassName: (aStream upToAll: '&lt;/driverClassName&gt;').			aStream throughAll: '&lt;environment&gt;'.			newProfile environment: (aStream upToAll: '&lt;/environment&gt;').			aStream throughAll: '&lt;userName&gt;'.			newProfile userName: (aStream upToAll: '&lt;/userName&gt;').			aStream throughAll: '&lt;password&gt;'.			newProfile password: (aStream upToAll: '&lt;/password&gt;').			aStream throughAll: '&lt;tableOwner&gt;'.			newProfile tableOwner: (aStream upToAll: '&lt;/tableOwner&gt;').			newProfile tableOwner = 'nil' ifTrue: [newProfile tableOwner: nil].			profiles add: newProfile.			aStream throughAll: '&lt;StORE Profile&gt;'].	^profiles</body><body package="PostgreSQLMonitor">writeCurrentProfilesTo: aStream 	"^self 	I write the current StORE profiles to aStream in an XMLish fasion."	"|stream| stream := String new writeStream. PostgreSQLConnectionList writeCurrentProfilesTo: stream. stream"	aStream		nextPutAll: '&lt;StORE Profile set&gt;';		cr.	Store.ConnectionDialog profiles do: 			[:aProfile | 			aStream				nextPutAll: '&lt;StORE Profile&gt;';				cr.			aStream				nextPutAll: '&lt;name&gt;';				nextPutAll: aProfile name;				nextPutAll: '&lt;/name&gt;';				cr.			aStream				nextPutAll: '&lt;driverClassName&gt;';				nextPutAll: aProfile driverClassName;				nextPutAll: '&lt;/driverClassName&gt;';				cr.			aStream				nextPutAll: '&lt;environment&gt;';				nextPutAll: aProfile environment;				nextPutAll: '&lt;/environment&gt;';				cr.			aStream				nextPutAll: '&lt;userName&gt;';				nextPutAll: aProfile userName;				nextPutAll: '&lt;/userName&gt;';				cr.			aStream				nextPutAll: '&lt;password&gt;';				nextPutAll: aProfile password;				nextPutAll: '&lt;/password&gt;';				cr.			aStream				nextPutAll: '&lt;tableOwner&gt;';				nextPutAll: aProfile tableOwner printString;				nextPutAll: '&lt;/tableOwner&gt;';				cr.			aStream				nextPutAll: '&lt;/StORE Profile&gt;';				cr].	aStream		nextPutAll: '&lt;/StORE Profile set&gt;';		cr.	^self</body></methods><methods><class-id>PostgreSQLMessagesControlView</class-id> <category>private-enable/disable</category><body package="PostgreSQLMonitor">disableSingleStepCheckBox	(self builder componentAt: #singleStepCheckBox) disable.	^self</body><body package="PostgreSQLMonitor">enableSingleStepCheckBox	(self builder componentAt: #singleStepCheckBox) enable.	^self</body></methods><methods><class-id>PostgreSQLMessagesControlView</class-id> <category>services</category><body package="PostgreSQLMonitor">disableSingleSteppingOption	"^self 	My message view has ceased showing messages, and is asking me to 	disallow the user the option of single stepping through the messages. I 	simply disable the single step check box."	self disableSingleStepCheckBox.	^self</body><body package="PostgreSQLMonitor">enableSingleSteppingOption	"^selfMy message view has started showing messages, and is asking me to allow the user the option of single stepping through the messages.  I simply enable the single step check box."	self enableSingleStepCheckBox.	^self</body><body package="PostgreSQLMonitor">getPermissionToSend: aMessage 	"^selfWe must be in single step mode, and my message view must have just displayed a new outbound message.  I need to get permission from the user to release this message to the PostgreSQL server, and I must also give the user the chance to open a debugger to see *why* this particular message is being sent by an application.  I do all this via the PostgreSQLNextMessageDialog."	| nextMessageDialog |	self singleStep value ifFalse: [^self].	nextMessageDialog := PostgreSQLNextMessageDialog openOn: aMessage.	nextMessageDialog debugRequested ifTrue: [self halt].	nextMessageDialog proceedRequested ifTrue: [self singleStep value: false].	^self</body></methods><methods><class-id>PostgreSQLMessagesControlView</class-id> <category>actions</category><body package="PostgreSQLMonitor">doShowMessagesChanged	"^self 	The 'show messages' check box has been changed. I delegate this to the 	messages view so it can start/stop it's display of messages as appropriate."	self messageView showMessages: self showMessages value.	^self</body></methods><methods><class-id>PostgreSQLMessagesControlView</class-id> <category>initialize-release</category><body package="PostgreSQLMonitor">initializeFor: aParent 	"^selfI just make a note of my parent.  I need to know my parent so I can get hold of contextual information, such at the connection I'm controlling the messages for."	parent := aParent.	^self</body><body package="PostgreSQLMonitor">preBuildWith: aBuilder 	"^self 	I get hold of my parent.  I need this to find what connection I'm controlling messages for,."	super preBuildWith: aBuilder.	self messageView initializeFor: self.	^self</body><body package="PostgreSQLMonitor">release	"^self 	I release my grasp on the connection."	super release.	self messageView release.	^self</body></methods><methods><class-id>PostgreSQLMessagesControlView</class-id> <category>accessing</category><body package="PostgreSQLMonitor">messageView	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^messageView isNil		ifTrue:			[messageView := PostgreSQLMessagesView new]		ifFalse:			[messageView]</body><body package="PostgreSQLMonitor">monitoredConnection	"^a MonitoredPostgreSQLConnection 	I return the wrapper object for the connection whose messages I monitor."	^self parent monitoredConnection</body><body package="PostgreSQLMonitor">parent	"an ApplicationModel 	I return my parent. My parent knows all kinds of contextual stuff like what 	connection I'm monitoring the messages for."	^parent</body></methods><methods><class-id>PostgreSQLMessagesControlView</class-id> <category>aspects</category><body package="PostgreSQLMonitor">showMessages	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^showMessages isNil		ifTrue:			[showMessages := false asValue]		ifFalse:			[showMessages]</body><body package="PostgreSQLMonitor">singleStep	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^singleStep isNil		ifTrue:			[singleStep := false asValue]		ifFalse:			[singleStep]</body></methods><methods><class-id>PostgreSQLMessagesView class</class-id> <category>interface specs</category><body package="PostgreSQLMonitor">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 1600 1200 ) 			#bounds: #(#{Graphics.Rectangle} 512 553 1065 905 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 30 0 -10 1 -5 0.5 ) 					#name: #TextEditor1 					#model: #outboundMessage 					#tabable: false 					#isReadOnly: true 					#tabRequiresControl: false ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 10 0 5 0.5 ) 					#name: #Label2 					#label: 'Received:' ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 25 0.5 -10 1 -10 1 ) 					#name: #TextEditor2 					#model: #inboundMessage 					#tabable: false 					#isReadOnly: true 					#tabRequiresControl: false ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 8 0 0 0.5 -8 1 5 0.5 ) 					#name: #ResizingSplitter1 					#flags: 8 					#horizontal: true 					#minAboveSize: 40 					#minBelowSize: 40 					#aboveWidgets: '#TextEditor1' 					#belowWidgets: '#Label2 #TextEditor2' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 10 ) 					#name: #Label1 					#label: 'Sending:' ) ) ) )</body></methods><methods><class-id>PostgreSQLConnectionMonitor class</class-id> <category>resources</category><body package="PostgreSQLMonitor">menu	"MenuEditor new openOnClass: self andSelector: #menu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: '&amp;File' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'E&amp;xit' 							#value: #closeRequest ) ) #(1 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>PostgreSQLConnectionMonitor class</class-id> <category>interface specs</category><body package="PostgreSQLMonitor">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #sizeType #specifiedSize #positionType #screenCenter #openType #advanced ) 			#label: 'PostgreSQL Connection Monitor' 			#min: #(#{Core.Point} 537 349 ) 			#max: #(#{Core.Point} 1600 1200 ) 			#bounds: #(#{Graphics.Rectangle} 694 591 1231 940 ) 			#flags: 4 			#menu: #menu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 90 0 10 0 -10 1 31 0 ) 					#name: #InputField1 					#flags: 0 					#model: #connectionDescription 					#tabable: false 					#isReadOnly: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.Rectangle} 10 10 83 31 ) 					#name: #Label1 					#label: 'Connection:' ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 40 0 0 1 0 1 ) 					#name: #Subcanvas1 					#flags: 0 					#majorKey: #{PostgreSQLMessagesControlView} 					#minorKey: #windowSpec 					#clientKey: #messageControlView ) ) ) )</body></methods><methods><class-id>PostgreSQLNextMessageDialog class</class-id> <category>interface specs</category><body package="PostgreSQLMonitor">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #sizeType #specifiedSize #positionType #screenCenter #openType #advanced ) 			#label: 'Next Message' 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 1600 1200 ) 			#bounds: #(#{Graphics.Rectangle} 645 614 1129 829 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 30 0 -10 1 -45 1 ) 					#name: #MessageText 					#model: #messageText 					#tabable: false 					#isReadOnly: true 					#tabRequiresControl: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 6 6 ) 					#name: #Label1 					#label: 'The following message is the next to be sent to the PostgreSQL backend:' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -275 1 -35 1 -190 1 -5 1 ) 					#name: #StepButton 					#model: #doStep 					#helpText: 'Send this message now' 					#label: 'Step' 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -183 1 -35 1 -98 1 -5 1 ) 					#name: #DebugButton 					#model: #doDebug 					#helpText: 'Open a debugger' 					#label: 'Debug' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 -35 1 -5 1 -5 1 ) 					#name: #ProceedButton 					#model: #doProceed 					#helpText: 'Continue without single stepping' 					#label: 'Proceed' 					#isDefault: false 					#defaultable: true ) ) ) )</body></methods><methods><class-id>PostgreSQLConnectionList class</class-id> <category>interface specs</category><body package="PostgreSQLMonitor">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #sizeType #specifiedSize #positionType #screenCenter #openType #advanced ) 			#label: 'PostgreSQL Connection List' 			#min: #(#{Core.Point} 291 166 ) 			#max: #(#{Core.Point} 1600 1200 ) 			#bounds: #(#{Graphics.Rectangle} 512 384 876 550 ) 			#flags: 4 			#menu: #menu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 30 0 -5 1 -40 1 ) 					#name: #connectionList 					#model: #connectionList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #openConnectionMonitor ) 					#selectionType: #highlight ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 5 5 ) 					#name: #Label1 					#label: 'Active Connections:' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -60 1 -35 1 -5 1 -5 1 ) 					#name: #CloseButton 					#model: #doClose 					#label: 'Close' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>PostgreSQLConnectionList class</class-id> <category>resources</category><body package="PostgreSQLMonitor">ioIcon	"UIMaskEditor new openOnClass: self andSelector: #ioIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 32@32 depth: 1 bitsPerPixel: 1 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 2) at: 1 put: Graphics.ColorValue blue; at: 2 put: Graphics.ColorValue white; yourself)) usingBits: #[255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 253 255 255 255 252 255 255 255 253 127 255 255 253 191 255 255 253 223 0 0 1 239 127 255 255 247 127 255 255 251 0 0 0 1 255 255 255 255 0 0 0 1 191 255 255 253 223 255 255 253 239 0 0 1 247 127 255 255 251 127 255 255 253 127 255 255 254 127 255 255 255 127 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255])</body><body package="PostgreSQLMonitor">menu	"MenuEditor new openOnClass: self andSelector: #menu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: '&amp;File' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '&amp;Refresh' 							#value: #refreshConnectionList 							#shortcutKeyCharacter: #F5 							#shortcutModifiers: 0 ) 						#(#{UI.MenuItem} 							#rawLabel: 'E&amp;xit' 							#value: #doClose ) ) #(1 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: '&amp;StORE' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Browse new stuff' 							#value: #doBrowsePundlesUpdatedInLast5Days ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Connection Profiles' 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: '&amp;Load...' 										#value: #doLoadStOREProfiles ) 									#(#{UI.MenuItem} 										#rawLabel: '&amp;Save As...' 										#value: #doSaveStOREProfilesAs ) ) #(2 ) nil ) ) ) #(2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: '&amp;Connection' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '&amp;Monitor' 							#value: #openConnectionMonitor ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Inspect' 							#value: #doInspect ) 						#(#{UI.MenuItem} 							#rawLabel: '&amp;Close' 							#value: #doCloseConnection ) ) #(3 ) nil ) ) ) #(3 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>PostgreSQLMessagesControlView class</class-id> <category>interface specs</category><body package="PostgreSQLMonitor">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #sizeType #specifiedSize #positionType #screenCenter #openType #advanced ) 			#label: 'Unlabeled Canvas' 			#min: #(#{Core.Point} 553 352 ) 			#max: #(#{Core.Point} 1600 1200 ) 			#bounds: #(#{Graphics.Rectangle} 515 470 1068 822 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 10 0 -10 1 -10 1 ) 					#name: #GroupBox2 					#label: 'Messages:' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 40 40 ) 					#name: #CheckBox1 					#model: #showMessages 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #doShowMessagesChanged ) 					#helpText: 'Show messages exchanged with backend.' 					#label: 'Show' ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 60 0 -10 1 -10 1 ) 					#name: #Subcanvas1 					#flags: 0 					#majorKey: #{PostgreSQLMessagesView} 					#minorKey: #windowSpec 					#clientKey: #messageView ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 122 40 ) 					#name: #singleStepCheckBox 					#flags: 32 					#model: #singleStep 					#helpText: 'Wait before sending each message' 					#label: 'Single Step' ) ) ) )</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>PostgreSQL</category><body package="PostgreSQLMonitor">definePostgreSQLSubMenu	"Define a sub-menu for PostgreSQL tools."	&lt;submenu: 'PostgreSQL'		nameKey: #PostgreSQL		menu: #(#menuBar #tools)		position: 30.01&gt;</body><body package="PostgreSQLMonitor">openPostgreSQLConnectionList	&lt;menuItem: 'PostgreSQL Connection List' icon: nil		nameKey: nil		menu: #(#menuBar #tools #PostgreSQL) 		position: 10.04&gt;	PostgreSQLConnectionList open</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector toolDock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class></st-source>