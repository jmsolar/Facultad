<?xml version="1.0"?><st-source><!-- Name: PostgreSQLEXDIComment: ©Bruce Badger 2000 - 2004. Licensed under the LGPL.The VisualWorks PostgreSQL EXDI interface allows access to PostgreSQL databases from VisualWorks in just the same way as access is provided for a Sybase or Oracle database from VisualWorks.Installing the libraries    * Have a look at the project home page.    * Get the latest version of the libraries from SourceForge .    * Uncompress the .tgz file into your working directory (or somwhere else on your parcel path).        From a clean 5i image (I'm now working in a 5i.2NC image) load the PostgreSQLEXDI parcel,       this will load everything else you need. That's it. Now you just need a PostgreSQL database        to connect to (the project home page has some tips that may help get you going).    * Have a look at the two test classes (PostgreSQLTest and PostgreSQLEXDITest) to see       examples of what works so far. It's a good idea to run all of the tests in these classes (just       run the respective >>test method on the class side) to check that everything is installed OK.    * Try using the Ad Hoc SQL tool. From the VisualWorks launcher choose Database>Ad Hoc SQL.       Note that the environment string format is {mycomputer:port}_{db name}        (e.g. 192.168.10.3:5432_storedb). The default host is localhost and the default port is 5432. Try        the query: select * from pg_class.Current limitations    * Limited authentication support. Clear text passwords only.    * Documentation is very limited - but with your help, it will get better.Using Database Connect for PostgreSQLThis part of the documentation is intended to mirror the database connect for Oracle/Sybase etc. documentation that comes with VisualWorks. As you can see, this has some way to go! Feel free to contribute.Data Conversion and BindingWhen receiving data from the database, all data returned by the PostgreSQL EXDI is converted into instances of Smalltalk classes. These conversions are summarized in the table below. Although abstract classes are used to simplify the table, the object holding the data is always an instance of a concrete class.BLOBsUsing PostgreSQL BLOBs are not treated as regular data types, and can not simply be included in SQL statements. PostgreSQL allows BLOBs to be manipulated through function calls. Each BLOB has a unique oid allocated by the function used to create it in the database. It is the oid of a blob which may be placed in a field and manipulated using regular SQL.The PostgreSQL EXDI tries to hide the complexities of dealing with function calls, but the technique currently employed results in the creation of a new BLOB in the database every time a BLOB is included in an SQL statement. For example, if you store a sound in a table, and then update that sound (replacing the old sound), the old sound BLOB will still exist in the database, but will not be refered to; in a Smalltalk image it would be subject to garbage collection, but PostgreSQL does not have garbage collection.To avoid old and unused BLOBs building up in a database, you must add database trigers (or some such thing) to remove old BLOBs from the database.- - Please send your comments to bbadger@openskills.com.  Thanks.DbIdentifier: OSSYD001DbTrace: 2207DevelopmentPrerequisites: #(#(#any 'Base64Encoding' '') #(#any 'Database' '') #(#any 'PostgreSQLDriver' '') #(#any 'PostgreSQLLogging' ''))HideSource: falsePackageName: PostgreSQLEXDIPackageName:: PostgreSQLEXDIParcel: #('PostgreSQLEXDI')PrerequisiteParcels: #(#('Base64Encoding' '') #('Database' '') #('PostgreSQLDriver' '') #('PostgreSQLLogging' ''))PrintStringCache: (1.3 014,bbadger)SaveSource: trueVersion: 1.3 014Date: 8:03:26 pm November 4, 2004 --><time-stamp>From VisualWorks® NonCommercial, 7.2 of November 3, 2003 on November 4, 2004 at 8:03:26 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>PostgreSQLEXDIException</name><environment>Smalltalk</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQLEXDI</package></attributes></class><comment><class-id>PostgreSQLEXDIException</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>PostgreSQLEXDISession</name><environment>Smalltalk</environment><super>Database.ExternalDatabaseSession</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rowStream currentPostgresRow noticeResponsesAreSuppressed resultList translationsFromPostgres </inst-vars><class-inst-vars>translationsFromPostgres </class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQLEXDI</package></attributes></class><comment><class-id>PostgreSQLEXDISession</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	rowStream	&lt;ClassOfVariable&gt;	description of variable's function	currentPostgresRow	&lt;ClassOfVariable&gt;	description of variable's function	noticeResponsesAreSuppressed	&lt;ClassOfVariable&gt;	description of variable's function	resultList	&lt;ClassOfVariable&gt;	description of variable's function	translationsFromPostgres	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>PostgreSQLEXDIColumnDescription</name><environment>Smalltalk</environment><super>Database.ExternalDatabaseColumnDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQLEXDI</package></attributes></class><comment><class-id>PostgreSQLEXDIColumnDescription</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>PostgreSQLEXDIBLOBManipulationOutsideTransaction</name><environment>Smalltalk</environment><super>PostgreSQLEXDIException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQLEXDI</package></attributes></class><comment><class-id>PostgreSQLEXDIBLOBManipulationOutsideTransaction</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>PostgreSQLEXDITest</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>identity nameString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQLEXDI</package></attributes></class><comment><class-id>PostgreSQLEXDITest</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	identity	&lt;ClassOfVariable&gt;	description of variable's function	nameString	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>PostgreSQLEXDIConnection</name><environment>Smalltalk</environment><super>Database.ExternalDatabaseConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>environmentParameters connection parameterSet </inst-vars><class-inst-vars>storeBroker traceLog </class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQLEXDI</package></attributes></class><comment><class-id>PostgreSQLEXDIConnection</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	environmentParameters	&lt;ClassOfVariable&gt;	description of variable's function	connection	&lt;ClassOfVariable&gt;	description of variable's function	parameterSet	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>PostgreSQLEXDIBLOB</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>byteArray </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQLEXDI</package></attributes></class><comment><class-id>PostgreSQLEXDIBLOB</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	byteArray	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>PostgreSQLEXDIFieldValue</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>object string </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQLEXDI</package></attributes></class><comment><class-id>PostgreSQLEXDIFieldValue</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	object	&lt;ClassOfVariable&gt;	description of variable's function	string	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>PostgreSQLEXDIBLOBValue</name><environment>Smalltalk</environment><super>PostgreSQLEXDIFieldValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>oid </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQLEXDI</package></attributes></class><comment><class-id>PostgreSQLEXDIBLOBValue</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	oid	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>PostgreSQLEXDIStringValue</name><environment>Smalltalk</environment><super>PostgreSQLEXDIFieldValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQLEXDI</package></attributes></class><comment><class-id>PostgreSQLEXDIStringValue</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>PostgreSQLEXDIByteArrayValue</name><environment>Smalltalk</environment><super>PostgreSQLEXDIFieldValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQLEXDI</package></attributes></class><comment><class-id>PostgreSQLEXDIByteArrayValue</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	oid	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>PostgreSQLEXDIFieldValueFunctionCallRequest</name><environment>Smalltalk</environment><super>PostgreSQLEXDIException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQLEXDI</package></attributes></class><comment><class-id>PostgreSQLEXDIFieldValueFunctionCallRequest</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>PostgreSQLEXDITransaction</name><environment>Smalltalk</environment><super>Database.ExternalDatabaseTransaction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQLEXDI</package></attributes></class><comment><class-id>PostgreSQLEXDITransaction</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>PostgreSQLEXDIFieldValueException</name><environment>Smalltalk</environment><super>PostgreSQLEXDIException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQLEXDI</package></attributes></class><comment><class-id>PostgreSQLEXDIFieldValueException</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>PostgreSQLEXDIEnvironmentString</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>environmentString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQLEXDI</package></attributes></class><comment><class-id>PostgreSQLEXDIEnvironmentString</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	environmentString	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>PostgreSQLEXDIError</name><environment>Smalltalk</environment><super>Database.ExternalDatabaseError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQLEXDI</package></attributes></class><comment><class-id>PostgreSQLEXDIError</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>PostgreSQLEXDINullValue</name><environment>Smalltalk</environment><super>PostgreSQLEXDIFieldValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>nullValue </class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQLEXDI</package></attributes></class><comment><class-id>PostgreSQLEXDINullValue</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><methods><class-id>PostgreSQLEXDIException</class-id> <category>license</category><body package="PostgreSQLEXDI">license	"^a License 	I return the license under which this software is made available."	^PostgreSQLDriverLicense license</body></methods><methods><class-id>PostgreSQLEXDISession</class-id> <category>accessing</category><body package="PostgreSQLEXDI">currentPostgresRow	^currentPostgresRow</body><body package="PostgreSQLEXDI">currentPostgresRow: aRow 	currentPostgresRow := aRow.	^self</body><body package="PostgreSQLEXDI">noticeResponsesAreSuppressed	"^a Boolean 	I return true if notice responses (thrown as exceptions by the driver layer) are to be suppressed, 	otherwise, I return false. If the notices are suppressed, this EXDI interface just proceeds through 	them. If they are not suppressed, the exceptions just pass through the EXDI layer, and must be 	handled by the EXDI client. I default to suppressing the notice responses."	noticeResponsesAreSuppressed isNil ifTrue: [noticeResponsesAreSuppressed := true].	^noticeResponsesAreSuppressed</body><body package="PostgreSQLEXDI">queryResult	"^ a PostgreSQLQueryResultList 	I return the result(s) of the query. A single query can include a number of SQL queries all in the one 	query string. For this reason, aPostgreSQLQueryResultList can hold many results. Each of these 	results can be obtained by repeatedly sending &gt;&gt;answer to the session (me)."	^resultList first</body><body package="PostgreSQLEXDI">resultList: aPostgreSQLQueryResultList 	"^self 	I record the result of the query. c.f. self&gt;&gt;result"	resultList := aPostgreSQLQueryResultList</body><body package="PostgreSQLEXDI">rowStream	"^a ReadStream 	I return a stream on the collection of rows 	in my result."	rowStream isNil ifTrue: [rowStream := self queryResult rows readStream].	^rowStream</body></methods><methods><class-id>PostgreSQLEXDISession</class-id> <category>private-library calls</category><body package="PostgreSQLEXDI">acquireExternal	"^self 	This is a no-op for now"	^self</body></methods><methods><class-id>PostgreSQLEXDISession</class-id> <category>private-execution</category><body package="PostgreSQLEXDI">cancelExternal	"^self 	This is a no-op for me at the moment."	^self</body><body package="PostgreSQLEXDI">dismissExternal	"^self 	This is a no-op for me at the moment."	^self</body><body package="PostgreSQLEXDI">executeExternal	"^self 	Execute the prepared query."	| queryMessage |	queryMessage := self connection connection newQuery.	queryMessage queryString: self query.	[self resultList: queryMessage execute]		on: PostgreSQLException do: 		[:exception | 		| error |		exception isNoticeResponse			ifTrue: [self noticeResponsesAreSuppressed					ifTrue: [exception resume]					ifFalse: [exception pass]]			ifFalse: 				[error := PostgreSQLEXDIError new.				error dbmsErrorString: exception messageText.				self connection class externalDatabaseErrorSignal raiseWith: (Array with: error)]].	^self</body><body package="PostgreSQLEXDI">readyExternal	"Answer whether or not the dbms has 	processed the SQL statement . For now, it's 	aways a yes (true)."	^true</body><body package="PostgreSQLEXDI">resultsExternal	"^a Boolean 	I return true if there are any results available, otherwise I return false. I know that there are results if 	a row description has been returned by PostgreSQL."	^self queryResult rowDescription notNil</body></methods><methods><class-id>PostgreSQLEXDISession</class-id> <category>private-binding</category><body package="PostgreSQLEXDI">bindExternal	"^self 	I blend the &gt;&gt;bindVariables with the &gt;&gt;queryFragments to form a viable SQL query string. I convert 	the variables to string values acceptable to PostgreSQL as appropriate. Some more complex values 	(I'm thinking of ByteArrays and BLOBs here) require that functions be called in the back end server. 	Processing these complex values results in an exception being thrown in order to have some action 	taken in the context of this session - i.e. calling a function. Once the action has completed, the 	exception may be resumed, and the binding can proceed."	| queryStream |	queryStream := WriteStream on: (String new: 255).	queryStream nextPutAll: queryFragments first.	[2		to: queryFragments size		by: 2		do: 			[:index | 			| bindMarker value |			bindMarker := queryFragments at: index.			value := PostgreSQLEXDIFieldValue forObject: (self inBindInputAt: bindMarker).			value writeStringTo: queryStream.			queryStream nextPutAll: (queryFragments at: index + 1)]]		on: PostgreSQLEXDIFieldValueFunctionCallRequest		do: 			[:exception | 			exception parameter callFunctionInTheContextOf: self.			exception resume].	query := queryStream contents.	^self</body><body package="PostgreSQLEXDI">prepareExternal	"^self 	This is a no-op for now"	^self</body></methods><methods><class-id>PostgreSQLEXDISession</class-id> <category>private-answer set</category><body package="PostgreSQLEXDI">advanceExternal	"^a row-like-thing or nil 	Advance the current row. If blockFactor is supported, this may entail fetching many rows but doing 	it infrequently. If there are no more rows, answer nil. Otherwise, answering self is sufficient."	self currentPostgresRow: (self rowStream atEnd			ifTrue: [nil]			ifFalse: [self rowStream next]).	^self currentPostgresRow</body><body package="PostgreSQLEXDI">allocateRowBufferExternal: aColumn 	"^self 	I return an object describing space allocated 	for holding one column's 	worth of 	information as returned by the dbms api. 	The driver is responsible 	for defining the 	structure of the object returned. Space is 	already allocated. I just return nil."	^nil</body><body package="PostgreSQLEXDI">answerStreamDismissed	"^self 	The EXDI has decided to explicitly dismiss the stream resources for this session. I take the que to 	drop my stream and external results. The Oracle EXDI mapping also overrides this method, so that 	gives this approach some credibility."	super answerStreamDismissed.	self resultList: nil.	self resetRowStream.	^self</body><body package="PostgreSQLEXDI">cancelAnswerSetExternal	"^self 	Cancel any resources associated with the current answer set. This is a no-op for now."	^self</body><body package="PostgreSQLEXDI">getColumnDescriptionExternal: aColumn 	| fieldDescription result |	result := self queryResult.	^(result rowDescription notNil and: [aColumn &lt;= result rowDescription fieldDescriptions size])		ifTrue: 			[fieldDescription := result rowDescription fieldDescriptions at: aColumn.			self connection class columnDescriptionClass for: fieldDescription]		ifFalse: [nil]</body><body package="PostgreSQLEXDI">getFieldExternal: aColumn 	"^an Object 	I return the value in aColumn translated per the EDXI rules. The object may be nil."	| field columnTypeName |	field := self currentPostgresRow fields at: aColumn.	field isNil ifTrue: [^nil].	columnTypeName := self currentPostgresRow typeOfColumn: aColumn.	^self valueFrom: field asString ofType: columnTypeName</body><body package="PostgreSQLEXDI">hasAnswerSetExternal	"^a Boolean 	I return true if there are any results available, otherwise I return false. I know that there are results if 	a row description has been returned by PostgreSQL."	^self queryResult rowDescription notNil</body><body package="PostgreSQLEXDI">moreResultsExternal	^false</body></methods><methods><class-id>PostgreSQLEXDISession</class-id> <category>private</category><body package="PostgreSQLEXDI">noticeResponsesAreSuppressed: aBoolean 	"^a Boolean 	I record wether notice responses are suppressed or not. See self&gt;&gt;noticeResponsesAreSuppressed."	noticeResponsesAreSuppressed := aBoolean.	^self</body><body package="PostgreSQLEXDI">resetRowStream	"^self 	*PRIVATE*	I reset my rowStream to nil. This is done when EXDI chooses to dismiss the external resources used 	by a session/"	rowStream := nil.	^self</body><body package="PostgreSQLEXDI">translationsFromPostgres	"^an IdentityDictionary 	I return my session specific disctionary of translation blocks. Because different session may wish 	to translate thinfs differently, the blocks must be local to the session."	translationsFromPostgres isNil ifTrue: [translationsFromPostgres := self class translationsFromPostgres copy].	^translationsFromPostgres</body><body package="PostgreSQLEXDI">valueFrom: aString ofType: aSymbol 	"^an Object 	I translate aString into something more useful on the basis of aSymbol."	| translationBlock |	translationBlock := self translationsFromPostgres at: aSymbol				ifAbsent: [^aString].	^translationBlock value: self value: aString readStream</body></methods><methods><class-id>PostgreSQLEXDISession</class-id> <category>license</category><body package="PostgreSQLEXDI">license	"^a License 	I return the license under which this software is made available."	^PostgreSQLDriverLicense license</body></methods><methods><class-id>PostgreSQLEXDISession</class-id> <category>services</category><body package="PostgreSQLEXDI">passNoticeResponses	"^self 	I pass notice responses on to the EXDI client. See self&gt;&gt;noticeResponsesAreSuppressed."	self noticeResponsesAreSuppressed: false.	^self</body><body package="PostgreSQLEXDI">suppressNoticeResponses	"^self 	I suppress notice responses. See self&gt;&gt;noticeResponsesAreSuppressed."	self noticeResponsesAreSuppressed: true.	^self</body></methods><methods><class-id>PostgreSQLEXDISession</class-id> <category>data processing</category><body package="PostgreSQLEXDI">cancel	"Interrupt the processing of the prepared SQL text or stored procedure.	Note that this method has been added to allow PostgreSQLTest class&gt;&gt;test15 to work.	Changed at the suggestion of Chris Lopeman of CDL -Object Link Inc."	^self isPrepared ifTrue: [self] ifFalse: [super cancel]</body><body package="PostgreSQLEXDI">isPrepared	"Answer true if the receiver has prepared SQL.	Note that this method has been added to allow PostgreSQLTest class&gt;&gt;test15 to work.	Changed at the suggestion of Chris Lopeman of CDL -Object Link Inc."	^self state == #prepared</body><body package="PostgreSQLEXDI">rowCount	"Answer an Integer representing the number of rows affected by the previous query.	Valid only after the query has been answered.	You can uncomment the implementation below, if you like, but it's not accurate and	may be worse than useless.  Making this work correctly *is* on the list of things	to do.	Note that PostgreSQLEXDITest class&gt;&gt;test08 has been modified to not use &gt;&gt;rowCount for now."	"^self queryResult rows size"	^PostgreSQLEXDIException 		raiseSignal: 'Sorry, &gt;&gt;rowCount is not implemented yet for PostgreSQL'</body></methods><methods><class-id>PostgreSQLEXDISession class</class-id> <category>accessing</category><body package="PostgreSQLEXDI">connectionClass	"^ PostgreSQLEXDIConnection class 	I return the PostgreSQL connection class."	^PostgreSQLEXDIConnection</body></methods><methods><class-id>PostgreSQLEXDISession class</class-id> <category>value translation</category><body package="PostgreSQLEXDI">resetTranslationsFromPostgres	"^self 	I reset my dictionary of translations. This is really only a developers tool. It's needed to pick up new 	implementations of the translation blocks which would otherwise be cached."	"PostgreSQLEXDISession resetTranslationsFromPostgres"	translationsFromPostgres := nil.	^self</body><body package="PostgreSQLEXDI">translationsFromPostgres	"^an IdentityDictionary 	I return my dictionary of translations keyed by PostgreSQL data type. I delegate this to my class."	translationsFromPostgres isNil ifTrue: [translationsFromPostgres := self buildTranslationsFromPostgres].	^translationsFromPostgres</body></methods><methods><class-id>PostgreSQLEXDISession class</class-id> <category>value translation private</category><body package="PostgreSQLEXDI">buildTranslationsFromPostgres	"^an IdentityDictionary 	I return a dictionary of blocks keyed on the PostgreSQL data type symbol."	| translations |	translations := IdentityDictionary new.	translations at: #bool put: [:aSession :aStream | aStream next == $t].	translations at: #box put: self fromBoxBlock.	translations at: #bpchar put: [:aSession :aStream | aStream contents].	translations at: #bytea put: [:aSession :aStream | self byteaFrom: aStream for: aSession].	translations at: #char put: [:aSession :aStream | aStream contents].	translations at: #cidr put: [:aSession :aStream | aStream contents].	translations at: #circle put: self fromCircleBlock.	translations at: #date put: self fromDateBlock.	translations at: #float4 put: self fromFloatBlock.	translations at: #float8 put: self fromFloatBlock.	translations at: #inet put: [:aSession :aStream | aStream contents].	translations at: #integer put: [:aSession :aStream | aStream asNumber].	translations at: #int2 put: [:aSession :aStream | aStream contents asNumber].	translations at: #int4 put: [:aSession :aStream | aStream contents asNumber].	translations at: #int8 put: [:aSession :aStream | aStream contents asNumber].	translations at: #interval put: self fromIntervalBlock.	translations at: #lseg put: self fromLineSegmentBlock.	translations at: #macaddr put: [:aSession :aStream | aStream contents].	translations at: #name put: [:aSession :aStream | aStream contents].	translations at: #numeric put: [:aSession :aStream | (aStream contents , 's') asNumber].	translations at: #oid put: [:aSession :aStream | aStream contents asNumber].	translations at: #path put: self fromPathBlock.	translations at: #point put: self fromPointBlock.	translations at: #polygon put: self fromPathBlock.	translations at: #regproc put: [:aSession :aStream | aStream contents].	translations at: #text put: [:aSession :aStream | aStream contents].	translations at: #time put: self fromTimeBlock.	translations at: #timestamp put: self fromTimestampBlock.	translations at: #varchar put: [:aSession :aStream | aStream contents].	^translations</body><body package="PostgreSQLEXDI">byteaFrom: aStream for: aSession 	"^a ByteArray 	I return a ByteArray created from the contents of aStream in the context of aSession."	| readStream decodedString |	readStream := Base64EncodingReadStream onStream: aStream.	decodedString := readStream upToEnd.	^decodedString</body><body package="PostgreSQLEXDI">fromBoxBlock	"^a Block 	I return the block that can pull a Rectangle from a stream, where that stream contains a string in the 	form defined for the PostgreSQL type 'box'. The block returns a Rectangle."	^	[:aSession :aStream | 	| originPoint cornerPoint |	originPoint := self fromPointBlock value: aSession value: (aStream upTo: $)) readStream.	cornerPoint := self fromPointBlock value: aSession value: (aStream upTo: $]) readStream.	Rectangle origin: originPoint corner: cornerPoint]</body><body package="PostgreSQLEXDI">fromCircleBlock	"^a Block 	I return the block that can pull a Circle from a stream, where that stream contains a string in the 	form defined for the PostgreSQL type 'circle'. The block returns a Circle."	^	[:aSession :aStream | 	| center radius |	aStream upTo: $&lt;.	center := self fromPointBlock value: aSession value: (aStream upTo: $)) readStream.	aStream upTo: $,.	radius := (aStream upTo: $&gt;) asNumber.	Circle center: center radius: radius]</body><body package="PostgreSQLEXDI">fromDateBlock	"^a Block 	I return the block that can pull a Date from a stream, where that stream contains a string in the 	form defined for the PostgreSQL type 'date'. The block returns a Date."	^	[:aSession :aStream | 	| year monthIndex day |	year := (aStream upTo: $-) asNumber.	monthIndex := (aStream upTo: $-) asNumber.	day := aStream upToEnd asNumber.	Date		newDay: day		monthNumber: monthIndex		year: year]</body><body package="PostgreSQLEXDI">fromFloatBlock	"^a Block 	I return the block that can pull a Double from a stream, where that stream contains a string in the 	form defined for the PostgreSQL types 'float4' and 'float8'. The block returns a Double."	^[:aSession :aStream | (aStream contents , 'd') asNumber]</body><body package="PostgreSQLEXDI">fromIntervalBlock	"^a Block 	I return the block that can pull an interval from a stream, where that stream contains a string in the 	form defined for the PostgreSQL type 'interval'. The block returns the integer number of seconds in 	the 	interval."	^	[:aSession :aStream | 	| totalSeconds |	totalSeconds := (aStream upTo: $ ) asNumber * 86400.	totalSeconds := totalSeconds + ((aStream upTo: $:) asNumber * 3600).	totalSeconds := totalSeconds + ((aStream upTo: $:) asNumber * 60).	totalSeconds + aStream upToEnd asNumber]</body><body package="PostgreSQLEXDI">fromLineSegmentBlock	"^a Block 	I return the block that can pull a LineSegment from a stream, where that stream contains a string in 	the form defined for the PostgreSQL type 'lseg'. The block returns a LineSegment."	^	[:aSession :aStream | 	| start end |	aStream upTo: $[.	start := self fromPointBlock value: aSession value: (aStream upTo: $,) readStream.	end := self fromPointBlock value: aSession value: (aStream upTo: $]) readStream.	LineSegment from: start to: end]</body><body package="PostgreSQLEXDI">fromPathBlock	"^a Block 	I return the block that can pull a Polyline from a stream, where that stream contains a string in the 	form defined for the PostgreSQL type 'path'. The block returns a Polyline. The format of the string is 	'((x,y),(x,y) ...)' for closed paths, and '[(x,y),(x,y) ...]' for open paths. I don't really care because I 	make them both onto a Polyline."	^	[:aSession :aStream | 	| vertices |	vertices := OrderedCollection new.	aStream skip: 1.	aStream upTo: $(.	[aStream atEnd]		whileFalse: 			[aStream skip: -1.			vertices add: (self fromPointBlock value: aSession value: (aStream upTo: $)) readStream).			aStream upTo: $(].	Polyline vertices: vertices asArray]</body><body package="PostgreSQLEXDI">fromPointBlock	"^a Block 	I return the block that can pull a Point from a stream, where that stream contains a string in the form 	defined for the PostgreSQL type 'point'."	^	[:aSession :aStream | 	| x y |	aStream upTo: $(.	x := (aStream upTo: $,) asNumber.	y := (aStream upTo: $)) asNumber.	Point x: x y: y]</body><body package="PostgreSQLEXDI">fromTimeBlock	"^a Block 	I return the block that can pull a Time from a stream, where that stream contains a string in the 	form defined for the PostgreSQL type 'time'. The block returns a Time."	^[:aSession :aStream | Time readFrom: aStream]</body><body package="PostgreSQLEXDI">fromTimestampBlock	"^a Block 	I return the block that can pull a Timestamp from a stream, where that stream contains a string in 	the 	form defined for the PostgreSQL type 'timestamp'. The block returns a Timestamp."	^	[:aSession :aStream | 	| date time milliseconds |	date := self fromDateBlock value: aSession value: (aStream upTo: $ ) readStream.	time := self fromTimeBlock value: aSession value: (aStream upTo: $-) readStream.	milliseconds := aStream upToEnd asNumber.	(Timestamp fromDate: date andTime: time)		millisecond: milliseconds]</body></methods><methods><class-id>PostgreSQLEXDIColumnDescription</class-id> <category>initialize-release</category><body package="PostgreSQLEXDI">for: aFieldDescription 	"^self	I initialize myself to represent aFieldDescription.""		index: aColumn;"		self name: aFieldDescription name.		self maxColumnConstraint: aFieldDescription typeSize."		type: (self connection class columnDescriptionClass getType: column type);		scale: column decimalPlaces;		precision: nil;		nullable: column isNotNull not;"		^self</body></methods><methods><class-id>PostgreSQLEXDIColumnDescription</class-id> <category>license</category><body package="PostgreSQLEXDI">license	"^a License 	I return the license under which this software is made available."	^PostgreSQLDriverLicense license</body></methods><methods><class-id>PostgreSQLEXDIColumnDescription class</class-id> <category>instance creation</category><body package="PostgreSQLEXDI">for: aFieldDescription 	"^a PostgreSQLEXDIColumnDescription 	I return a new instance of myself to 	represent aFieldDescription."	^self new for: aFieldDescription</body></methods><methods><class-id>PostgreSQLEXDITest</class-id> <category>accessing</category><body package="PostgreSQLEXDI">identity	"^an Integer 	I return my identity. This value means nothing really, it's just something for me to hold onto for 	testing purposes."	^identity</body><body package="PostgreSQLEXDI">identity: anInteger 	"^self 	I record my identity. c.f self&gt;&gt;identity."	identity := anInteger.	^self</body><body package="PostgreSQLEXDI">nameString	"^a String 	I return my name string. This value means nothing really, it's just something for me to hold onto for 	testing purposes."	^nameString</body><body package="PostgreSQLEXDI">namestring	"^a String 	This is the version of the nameString method that is send by the EXDI when I use 'AS' to specify the column name as 'nameString' - the case is lost.  See self class test16.."	^self nameString</body><body package="PostgreSQLEXDI">nameString: aString 	"^self 	I record my name string. c.f. self&gt;&gt;nameString."	nameString := aString.	^self</body><body package="PostgreSQLEXDI">namestring: aString 	"^self 	This is the version of the nameString method that is send by the EXDI when I use 'AS' to specify the column name as 'nameString' - the case is lost.  See self class test16.."	^self nameString: aString</body></methods><methods><class-id>PostgreSQLEXDITest</class-id> <category>initialize-release</category><body package="PostgreSQLEXDI">withIdentity: anInteger andNameString: aString 	"^self 	I initialize myself. I'm just a victim for use in tests, and do not represent a test."	self identity: anInteger.	self nameString: aString.	^self</body></methods><methods><class-id>PostgreSQLEXDITest</class-id> <category>license</category><body package="PostgreSQLEXDI">license	"^a License 	I return the license under which this software is made available."	^PostgreSQLDriverLicense license</body></methods><methods><class-id>PostgreSQLEXDITest</class-id> <category>comparing</category><body package="PostgreSQLEXDI">= anOther 	"^a Boolean 	I return true is anOther is the equivalent of me, otherwise I return false.."	^self identity = anOther identity and: [self nameString = anOther nameString]</body><body package="PostgreSQLEXDI">hash	"^an Integer 	I return my hash value."	^self identity hash + self nameString hash</body></methods><methods><class-id>PostgreSQLEXDITest class</class-id> <category>testing</category><body package="PostgreSQLEXDI">test	"^self 	I run through all of the tests. I also run the driver tests, just to be 	sure."	"self test"	PostgreSQLLoggingTesting test.	self test01.	self test02.	self test03.	self test04.	self test05.	self test06.	self test07.	self test08.	self test09.	self test10.	self test11.	self test12.	self test13.	self test14.	self test15.	self test16.	self test20.	self test21.	self test22.	self test30.	self test31.	self test32.	self test33.	^PostgreSQLTest messageLog contents</body><body package="PostgreSQLEXDI">test01	"^self 	Using the EXDI, I connect to a PostgreSQL database and then disconnect."	"self test01"	| connection |	connection := PostgreSQLEXDIConnection new.	connection		username: self testUsernameString;		password: self testPasswordString;		environment: self testEnvironmentString.	connection connect.	connection disconnect.	^self</body><body package="PostgreSQLEXDI">test02	"^self 	I create a 'logical' environment called e-test and use that to connect. Then, at the end, I remove the 	logical mapping again."	"self test02"	| connection |	PostgreSQLEXDIConnection addLogical: 'e-test'		environment: self testEnvironmentString.	connection := PostgreSQLEXDIConnection new.	connection		username: self testUsernameString;		password: self testPasswordString;		environment: 'e-test'.	connection connect.	connection disconnect.	PostgreSQLEXDIConnection removeLogical: 'e-test'.	^self</body><body package="PostgreSQLEXDI">test03	"^self 	I create a 'logical' environment called e-test and then make that the default connection for the 	PostgresEXDI connection. Then I connect without specifying an environment string. At the end, I 	remove the	logical mapping again."	"self test03"	| connection |	PostgreSQLEXDIConnection addLogical: 'e-test'		environment: self testEnvironmentString.	PostgreSQLEXDIConnection defaultEnvironment: 'e-test'.	connection := PostgreSQLEXDIConnection new.	connection		username: self testUsernameString;		password: self testPasswordString.	connection connect.	connection disconnect.	PostgreSQLEXDIConnection defaultEnvironment: nil.	PostgreSQLEXDIConnection removeLogical: 'e-test'.	^self</body><body package="PostgreSQLEXDI">test04	"^self 	I create a 'logical' environment called e-test and then make that the default connection for the 	PostgresEXDI connection, I also make PostgreSQLEXDIConnection the default connection. Then I 	connect without specifying an environment string. At the end, I 	remove the	logical mapping again."	"self test04"	| connection |	PostgreSQLEXDIConnection addLogical: 'e-test'		environment: self testEnvironmentString.	PostgreSQLEXDIConnection defaultEnvironment: 'e-test'.	ExternalDatabaseConnection defaultConnection: #PostgreSQLEXDIConnection.	connection := PostgreSQLEXDIConnection new.	connection		username: self testUsernameString;		password: self testPasswordString.	connection connect.	connection disconnect.	ExternalDatabaseConnection defaultConnection: nil.	PostgreSQLEXDIConnection defaultEnvironment: nil.	PostgreSQLEXDIConnection removeLogical: 'e-test'.	^self</body><body package="PostgreSQLEXDI">test05	"^self 	I use the default test connection and run a really simple query. I don't process the answer."	"self test05"	| connection session |	connection := self testConnection.	session := connection getSession.	session prepare: 'select 3 + 4;'.	session execute.	session answer.	connection disconnect.	^self</body><body package="PostgreSQLEXDI">test06	"^self 	I'll test variables in queries."	"self test06"	| connection session |	connection := self testConnection.	session := connection getSession.	[session prepare: 'drop table exdiTest06'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	session prepare: 'create table exdiTest06 (name varchar(30), phone varchar(20))'.	session execute.	session := connection getSession.	session prepare: 'INSERT INTO exdiTest06 (name, phone) VALUES(?, ?)'.	#(#('Curly' 'x47') #('Moe' 'x29') #('Larry' 'x83')) do: [:entry | session bindInput: entry; execute; answer].	session := connection getSession.	session prepare: 'drop table exdiTest06'.	session execute.	connection disconnect.	^self</body><body package="PostgreSQLEXDI">test07	"^self 	I make a table with every possible data type, populate it and then get a row from it. This is all to test 	data type conversion from the PostgreSQL for to the EXDI specified form."	"self test07"	| connection session |	connection := self testConnection.	session := connection getSession.	[session prepare: 'drop table exdiTest07'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	session prepare: 'create table exdiTest07 (	textField		text,	varcharField		varchar(4),	charField		char(4),	integerField		integer,	int2Field		int2,	int8Field		int8,	oidField			oid,	numericField	numeric(6,2),	floatField		float,	float4Field		float4,	dateField		date,	timeField		time,	timestampField	timestamp without time zone,	intervalField		interval,	boolField		bool,	pointField		point,	lsegField		lseg,	pathField		path,	boxField		box,	circleField		circle,	polygonField	polygon,	inetField		inet,	cidrField		cidr,	macaddrField	macaddr)'.	session execute.	session := connection getSession.	session prepare: 'insert into exdiTest07(	textField,	varcharField,	charField,	integerField,	int2Field,	int8Field,	oidField,	numericField,	floatField,	float4Field,	dateField,	timeField,	timestampField,	intervalField,	boolField,	pointField,	lsegField,	pathField,	boxField,	circleField,	polygonField,	inetField,	cidrField,	macaddrField)values (	''Text value'',	''VC1'',	''C4'',	1234,	2468,	1248,	1357,	123.45,	0.1234,	123456.78,	''07-09-2000'',	''14:53:42'',	''07-09-2000 14:54:55'',	''4 05:00:30'',	''true'',	''(2,7)'',	''[(0,0),(1,3)]'',	''((0,0),(3,0),(4,5),(1,6))'',	''(1,1),(3,3)'',	''&lt;(1,2),60&gt;'',	''((3,1),(3,3),(1,0))'',	''192.168.1.12'',	''172.20.90.0/24'',	''0:50:4:1d:f6:db'')'; execute.	connection class externalDatabaseErrorSignal handle: [:ex | Dialog warn: ex parameter first dbmsErrorString]		do: 			[| answer rows |			session prepare: 'select * from exdiTest07'; execute.			rows := OrderedCollection new.			[(answer := session answer) == #noMoreAnswers]				whileFalse: [rows := rows , answer upToEnd].			(rows first collect: [:x | x class name])				= #(#ByteString #ByteString #ByteString #SmallInteger #SmallInteger #SmallInteger #SmallInteger #FixedPoint #Double #Double #Date #Time #Timestamp #SmallInteger #True #Point #LineSegment #Polyline #Rectangle #Circle #Polyline #ByteString #ByteString #ByteString) ifFalse: [Exception raiseSignal: 'Test07 - failed']].	connection disconnect.	^self</body><body package="PostgreSQLEXDI">test08	"^self 	I test getting retults back. After populating the database, I make several consecutive queries.	NOTE: this test also uses &gt;&gt;rowCount, but since this is broken, the call has been commented out for now."	"self test08"	| connection session |	connection := self testConnection.	session := connection getSession.		[session		prepare: 'drop table exdiTest08';		execute] 			on: connection class externalDatabaseErrorSignal			do: [:e | ].	session 		prepare: 'create table exdiTest08 (name varchar(30), phone varchar(20))'.	session execute.	session answer.	session := connection getSession.	session prepare: 'INSERT INTO exdiTest08 (name, phone) VALUES(?, ?)'.	#(#('Curly' 'x47') #('Moe' 'x29') #('Larry' 'x83')) do: 			[:entry | 			session				bindInput: entry;				execute;				answer].	session := connection getSession.	session prepare: 'select * from exdiTest08'.	session execute.	connection class externalDatabaseErrorSignal 		handle: [:ex | Dialog warn: ex parameter first dbmsErrorString]		do: 			[| answer rows totalRows |			rows := OrderedCollection new.			totalRows := 0.			[(answer := session answer) == #noMoreAnswers] whileFalse: 					["totalRows := totalRows + session rowCount."					rows := rows , answer upToEnd].			rows asArray = #(#('Curly' 'x47') #('Moe' 'x29') #('Larry' 'x83')) 				ifFalse: [Exception raiseSignal: 'Test08 - failed']].	session := connection getSession.	session prepare: 'select * from exdiTest08 where name like ''%r%'' '.	session execute.	connection class externalDatabaseErrorSignal 		handle: [:ex | Dialog warn: ex parameter first dbmsErrorString]		do: 			[| answer rows |			rows := OrderedCollection new.			[(answer := session answer) == #noMoreAnswers] 				whileFalse: [rows := rows , answer upToEnd].			rows asArray = #(#('Curly' 'x47') #('Larry' 'x83')) 				ifFalse: [Exception raiseSignal: 'Test08 - failed']].	session := connection getSession.	session prepare: 'drop table exdiTest08'.	session execute.	connection disconnect.	^self</body><body package="PostgreSQLEXDI">test09	"^self 	I'll test transactions."	"self test09"	| connection session |	self initializeTestDatabase.	connection := self testConnection.	session := connection getSession.	session prepare: 'INSERT INTO task (name) VALUES(''test09a'')'; execute; answer.	connection begin.	session prepare: 'INSERT INTO task (name) VALUES(''test09b'')'; execute; answer.	connection commit.	connection begin.	session prepare: 'INSERT INTO task (name) VALUES(''test09c'')'; execute; answer.	connection rollback.	session prepare: 'INSERT INTO task (name) VALUES(''test09d'')'; execute; answer.	connection begin.	session prepare: 'INSERT INTO task (name) VALUES(''test09e'')'; execute; answer.	session prepare: 'INSERT INTO task (name) VALUES(''test09f'' )'; execute; answer.	connection rollback.	session prepare: 'INSERT INTO task (name) VALUES(''test09g'')'; execute; answer.	connection class externalDatabaseErrorSignal handle: [:ex | Dialog warn: ex parameter first dbmsErrorString]		do: 			[| answer rows |			session prepare: 'select * from task where name like ''test09%'' '; execute.			rows := OrderedCollection new.			[(answer := session answer) == #noMoreAnswers]				whileFalse: [rows := rows , answer upToEnd].			rows asArray = #(#('test09a') #('test09b') #('test09d') #('test09g')) ifFalse: [Exception raiseSignal: 'Test09 - failed']].	connection disconnect.	^self</body><body package="PostgreSQLEXDI">test10	"^self 	I'll test binding real objects to the query input and output."	"self test10"	| connection session testObjects |	connection := self testConnection.	session := connection getSession.	[session prepare: 'drop table exdiTest10'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	session prepare: 'create table exdiTest10 (identity integer, nameStringtext);'; execute.	testObjects := OrderedCollection new.	testObjects add: (self withIdentity: 1 andNameString: 'exdiTest10a').	testObjects add: (self withIdentity: 2 andNameString: 'exdiTest10b').	testObjects add: (self withIdentity: 3 andNameString: 'exdiTest10c').	testObjects add: (self withIdentity: 4 andNameString: 'exdiTest10d').	session prepare: 'INSERT INTO exdiTest10 (identity, nameString)VALUES(:identity, :nameString)'.	testObjects do: [:entry | session bindInput: entry; execute; answer].	connection class externalDatabaseErrorSignal handle: [:ex | Dialog warn: ex parameter first dbmsErrorString]		do: 			[| answer results |			session prepare: 'select * from exdiTest10 order by identity'.			session bindOutput: self new; execute.			results := OrderedCollection new.			[(answer := session answer) == #noMoreAnswers]				whileFalse: [results := results , answer upToEnd].			results = testObjects ifFalse: [Exception raiseSignal: 'Test09 -failed']].	connection disconnect.	^self</body><body package="PostgreSQLEXDI">test11	"^self 	I'll test binding real objects to the query input and output and in 	addition, I use a serial column type to assign the identity."	"self test11"	| connection session testObjects |	connection := self testConnection.	session := connection getSession.		[session		prepare: 'drop table exdiTest11';		execute] 			on: connection class externalDatabaseErrorSignal			do: [:e | ].		[session		prepare: 'drop sequence exditest11_identity_seq';		execute] 			on: connection class externalDatabaseErrorSignal			do: [:e | ].	session		prepare: 'create table exdiTest11 (identity serial, nameString text);';		execute.	testObjects := OrderedCollection new.	testObjects add: (self withIdentity: nil andNameString: 'exdiTest11a').	testObjects add: (self withIdentity: nil andNameString: 'exdiTest11b').	testObjects add: (self withIdentity: nil andNameString: 'exdiTest11c').	testObjects add: (self withIdentity: nil andNameString: 'exdiTest11d').	session 		prepare: 'INSERT INTO exdiTest11 (nameString) VALUES (:nameString)'.	testObjects do: 			[:entry | 			session				bindInput: entry;				execute;				answer].	connection class externalDatabaseErrorSignal 		handle: [:ex | Dialog warn: ex parameter first dbmsErrorString]		do: 			[| answer results |			session prepare: 'select * from exdiTest11 order by identity'.			session				bindOutput: self new;				execute.			results := OrderedCollection new.			[(answer := session answer) == #noMoreAnswers] 				whileFalse: [results := results , answer upToEnd].			testObjects := OrderedCollection new.			testObjects add: (self withIdentity: 1 andNameString: 'exdiTest11a').			testObjects add: (self withIdentity: 2 andNameString: 'exdiTest11b').			testObjects add: (self withIdentity: 3 andNameString: 'exdiTest11c').			testObjects add: (self withIdentity: 4 andNameString: 'exdiTest11d').			results = testObjects ifFalse: [Exception raiseSignal: 'Test09 - failed']].	connection disconnect.	^self</body><body package="PostgreSQLEXDI">test12	"^self 	I'll test binding real objects to the query input and output and in 	addition, I use a serial column type to assign the identity."	"self test12"	| connection session testObjects |	connection := self testConnection.	session := connection getSession.	[session prepare: 'drop table exdiTest12'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	[session prepare: 'drop sequence exditest12_identity_seq'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	session prepare: 'create table exdiTest12 (identity serial, nameStringtext);'; execute.	testObjects := OrderedCollection new.	testObjects add: (self withIdentity: nil andNameString: 'exdiTest12a').	testObjects add: (self withIdentity: nil andNameString: 'exdiTest12b').	testObjects add: (self withIdentity: nil andNameString: 'exdiTest12c').	testObjects add: (self withIdentity: nil andNameString: 'exdiTest12d').	session prepare: 'INSERT INTO exdiTest12 (nameString) VALUES(:nameString)'.	session bindOutput: self new.	testObjects do: [:entry | session bindInput: entry; execute; answer].	connection class externalDatabaseErrorSignal handle: [:ex | Dialog warn: ex parameter first dbmsErrorString]		do: 			[| answer results |			session prepare: 'select * from exdiTest12 order by identity'.			session bindOutput: self new; execute.			results := OrderedCollection new.			[(answer := session answer) == #noMoreAnswers]				whileFalse: [results := results , answer upToEnd].			testObjects := OrderedCollection new.			testObjects add: (self withIdentity: 1 andNameString: 'exdiTest12a').			testObjects add: (self withIdentity: 2 andNameString: 'exdiTest12b').			testObjects add: (self withIdentity: 3 andNameString: 'exdiTest12c').			testObjects add: (self withIdentity: 4 andNameString: 'exdiTest12d').			results = testObjects ifFalse: [Exception raiseSignal: 'Test09 -failed']].	connection disconnect.	^self</body><body package="PostgreSQLEXDI">test13	"^self 	I test using special characters in strings (e.g. $\)."	"self test13"	| connection session testObjects |	connection := self testConnection.	session := connection getSession.	[session prepare: 'drop table exdiTest13'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	[session prepare: 'drop sequence exditest13_identity_seq'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	session prepare: 'create table exdiTest13 (identity serial, nameStringtext);'; execute.	testObjects := OrderedCollection new.	testObjects add: (self withIdentity: nil andNameString: '\exdiTest13a\\\').	testObjects add: (self withIdentity: nil andNameString: '\exdiTest13b\\\').	testObjects add: (self withIdentity: nil andNameString: '\exdiTest13c\\\').	testObjects add: (self withIdentity: nil andNameString: '\exdiTest13d\\\').	session prepare: 'INSERT INTO exdiTest13 (nameString) VALUES(:nameString)'.	session bindOutput: self new.	testObjects do: [:entry | session bindInput: entry; execute; answer].	connection class externalDatabaseErrorSignal handle: [:ex | Dialog warn: ex parameter first dbmsErrorString]		do: 			[| answer results |			session prepare: 'select * from exdiTest13 order by identity'.			session bindOutput: self new; execute.			results := OrderedCollection new.			[(answer := session answer) == #noMoreAnswers]				whileFalse: [results := results , answer upToEnd].			testObjects := OrderedCollection new.			testObjects add: (self withIdentity: 1 andNameString: '\exdiTest13a\\\').			testObjects add: (self withIdentity: 2 andNameString: '\exdiTest13b\\\').			testObjects add: (self withIdentity: 3 andNameString: '\exdiTest13c\\\').			testObjects add: (self withIdentity: 4 andNameString: '\exdiTest13d\\\').			results = testObjects ifFalse: [Exception raiseSignal: 'Test09 -failed']].	connection disconnect.	^self</body><body package="PostgreSQLEXDI">test14	"^self 	I test logging. I set logging on, and then run &gt;&gt;test06.."	"self test14"	PostgreSQLEXDIConnection traceCollector: Transcript.	PostgreSQLEXDIConnection traceLevel: 3.	self test06.	PostgreSQLEXDIConnection traceLevel: 0.	^self</body><body package="PostgreSQLEXDI">test15	"^self 	Test a senario devised by Chris Lopeman.  In his words (BTW, I hope the BOOM is gone):	Well I am sure that bunch of rambling did not help you understand the problem so	here's a quick way to produce it.  Without the patch of course:		1) open a connection.		2) prepare a query		3) begin a transaction		4) execute the query		5) BOOM!!!!"	"self test15"	| connection session query |	self initializeTestDatabase.	connection := self testConnection.	session := connection getSession.	query := session prepare: 'INSERT INTO task (name) VALUES(''test15'')'.	connection begin.	query execute; answer.	connection rollback.	connection disconnect.	^self</body><body package="PostgreSQLEXDI">test16	"^self Test a senario devised by Coen De Roover who said:When I try to use named output binding with the PostgreSQLEXDI that is included inVW 7.1, I get (in the following code snippet) a 'Message not understoodexception: #p_login' with zero arguments, while the code was supposed tocall the 'p_login: aLogin' setter method. "	"It seems that the EXDI layer demands that an accessor be there, even if all you want to do is assign the value.  so in the above, you'd need &gt;&gt;p_login *and* &gt;&gt;p_login:.  Also, it seems that case is not preserved between the select statement 'AS' and sending the message - i.e. in this case 'namestring' is the selector used instead of 'nameString'."	"self test16"	| connection session result |	self initializeTestDatabase.	connection := self testConnection.	session := connection getSession.	session 		prepare: 'SELECT name AS nameString FROM assignee WHERE name LIKE ?'.	session bindInput: #('Bob').	session bindOutputNamed: self new.	session execute.	result := session answer upToEnd.	connection disconnect.	^result</body><body package="PostgreSQLEXDI">test17	"^self 	Jay O'Connor found that the following query would not work with the EXDI + PostgreSQL:		insert into exdiTest17 (val1, val2 ) values ('What\'s the problem?', 'val2 String')	Taking out either the escaped quote, or the question mark from the first value stops	the problem happening.	Jay thinks this is a bug in ExternalDatabaseSession&gt;&gt;setupQuery:"	"self test17"	| connection session |	connection := self testConnection.	session := connection getSession.		[session		prepare: 'drop table exdiTest17';		execute] 			on: connection class externalDatabaseErrorSignal			do: [:e | ].	session 		prepare: 'create table exdiTest17 (	val1		varchar(100),	val2		varchar(100))'.	session execute.	session := connection getSession.	session		prepare: 'insert	into exdiTest17 (val1, val2 )	values (''What\''s the problem?'', ''val2 String'')';		execute.	connection class externalDatabaseErrorSignal 		handle: [:ex | Dialog warn: ex parameter first dbmsErrorString]		do: 			[| answer rows |			session				prepare: 'select * from exdiTest17';				execute.			rows := OrderedCollection new.			[(answer := session answer) == #noMoreAnswers] 				whileFalse: [rows := rows , answer upToEnd].			(rows first collect: [:x | x class name]) = #(#ByteString #ByteString) 				ifFalse: [Exception raiseSignal: 'Test07 - failed']].	connection disconnect.	^self</body><body package="PostgreSQLEXDI">test20	"^self 	I test handling notice responses. I create two tables, each with a prmary key specified as part of the 	'create table'. This causes PostgreSQL to raise a notice response indicating that the primary key 	clause forced the creation of an index in the database. For the first table, I allow the session to 	suppress the notice response, but for the second call I ask the session to pass on these notice 	response exceptions."	"self test20"	| connection session noticeDetected |	noticeDetected := false.	self initializeTestDatabase.	connection := self testConnection.	session := connection getSession.	[session prepare: 'drop table exdiTest20a'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	[session prepare: 'drop table exdiTest20b'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	session prepare: 'create table exdiTest20a (id int, name varchar(30), phone varchar(20),							PRIMARY KEY(id))'.	session execute.	session passNoticeResponses.	session prepare: 'create table exdiTest20b (id int, name varchar(30), phone varchar(20),							PRIMARY KEY(id))'.	[session execute] on: PostgreSQLNoticeResponse do: [:exception | exception isNoticeResponse			ifTrue: 				[noticeDetected := true.				exception resume]			ifFalse: [exception pass]].	session suppressNoticeResponses.	session prepare: 'INSERT INTO exdiTest20a (id, name, phone) VALUES(?, ?, ?)'.	#(#(1 'Curly' 'x47') #(2 'Moe' 'x29') #(3 'Larry' 'x83')) do: [:entry | session bindInput: entry; execute; answer].	session prepare: 'INSERT INTO exdiTest20b (id, name, phone) VALUES(?, ?, ?)'.	#(#(1 'Curly' 'x47') #(2 'Moe' 'x29') #(3 'Larry' 'x83')) do: [:entry | session bindInput: entry; execute; answer].	session prepare: 'drop table exdiTest20a'.	session execute.	session prepare: 'drop table exdiTest20b'.	session execute.	connection disconnect.	noticeDetected ifFalse: [self halt: 'test20 failed - a notice exception should have been handled.'].	^self</body><body package="PostgreSQLEXDI">test21	"^self 	I test the use of database rules. I create two tables. The first is a data table, and the second is a log 	table. I create a rule that makes an entry in the log table every time a row in the data table is 	updated."	"self test21"	| connection session rows answer |	connection := self testConnection.	session := connection getSession.	session passNoticeResponses.	[session prepare: 'drop table exdiTest21data'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	[session prepare: 'drop table exdiTest21log'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	[session prepare: 'drop rule exdiTest21data_update'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	session prepare: 'create table exdiTest21data (id int, name text, phone varchar(21))'.	session execute.	session prepare: 'create table exdiTest21log (oldName text, newName text)'.	session execute.	session prepare: '			create rule exdiTest21data_update as on update to exdiTest21data			do insert into exdiTest21log (oldName, newName ) values (old.name, new.name);'.	session execute.	session prepare: 'INSERT INTO exdiTest21data (id, name, phone) VALUES(?, ?, ?)'.	#(#(1 'Curly' 'x47') #(2 'Moe' 'x29') #(3 'Larry' 'x83')) do: [:entry | session bindInput: entry; execute].	session prepare: 'update exdiTest21data set name = ''Harry'' where name = ''Larry'';'.	session execute.	session prepare: 'select oldname, newname from exdiTest21log where oldname = ''Larry'';'.	session execute.	rows := OrderedCollection new.	[(answer := session answer) == #noMoreAnswers]		whileFalse: [rows := rows , answer upToEnd].	rows asArray = #(#('Larry' 'Harry')) ifFalse: [Exception raiseSignal: 'Test21 - failed'].	connection disconnect.	^self</body><body package="PostgreSQLEXDI">test22	"^self 	I test the use of database rules calling functions. As with test 21, I create two tables. The first is a 	data table, and the second is a log 	table. I create a rule that makes an entry in the log table every 	time a row in the data table is updated. The extra twist here is that I call a function as well."	"self test22"	| connection session rows answer |	connection := self testConnection.	session := connection getSession.	session passNoticeResponses.	[session prepare: 'drop table exdiTest22data'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	[session prepare: 'drop table exdiTest22log'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	[session prepare: 'drop rule exdiTest22data_update'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	session prepare: 'create table exdiTest22data (id int, name text, phone varchar(22))'.	session execute.	session prepare: 'create table exdiTest22log (oldName text, newName text, attime timestamp)'.	session execute.	session prepare: '			create rule exdiTest22data_update as on update to exdiTest22data			do insert into exdiTest22log (oldName, newName, attime ) values (old.name, new.name, now());'.	session execute.	session prepare: 'INSERT INTO exdiTest22data (id, name, phone) VALUES(?, ?, ?)'.	#(#(1 'Curly' 'x47') #(2 'Moe' 'x29') #(3 'Larry' 'x83')) do: [:entry | session bindInput: entry; execute].	session prepare: 'update exdiTest22data set name = ''Harry'' where name = ''Larry'';'.	session execute.	session prepare: 'select oldname, newname from exdiTest22log where oldname = ''Larry'';'.	session execute.	rows := OrderedCollection new.	[(answer := session answer) == #noMoreAnswers]		whileFalse: [rows := rows , answer upToEnd].	rows asArray = #(#('Larry' 'Harry')) ifFalse: [Exception raiseSignal: 'Test22 - failed'].	connection disconnect.	^self</body><body package="PostgreSQLEXDI">test30	"^self 	I test handling blobs. I create a table with an oid column, and then I execute some SQL to add a blob 	into that column. Under the covers, the exdi interface must spot the fact that this is an attempt to 	write a blob, and must first call a function to store the binary data, and put the oid of that blob into 	the oid column in place of the blob itself. 	Without blob-removal rules, this test will add three new blobs to the database every time it's run."	"self test30"	| connection session testBlob values rows answer |	connection := self testConnection.	session := connection getSession.	[session prepare: 'drop table exdiTest30'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	[session prepare: 'drop rule exdiTest30_update'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	session prepare: 'create table exdiTest30 (name varchar(30), blobdata oid )'.	session execute.	session prepare: '			create rule exdiTest30_update as on update to exdiTest30			do select lo_unlink(old.blobdata) from exdiTest30;'.	session execute.	testBlob := PostgreSQLEXDIBLOB on: (ByteArray withAll: (0 to: 200)).	connection begin.	session prepare: 'INSERT INTO exdiTest30 (name, blobdata) VALUES(?, ?)'.	values := OrderedCollection new.	values add: (Array with: 'Curly' with: testBlob).	values add: (Array with: 'Moe' with: testBlob).	values add: (Array with: 'Larry' with: testBlob).	values do: [:entry | session bindInput: entry; execute; answer].	connection commit.	session prepare: 'select name from exdiTest30 order by name '; execute.	rows := OrderedCollection new.	[(answer := session answer) == #noMoreAnswers]		whileFalse: [rows := rows , answer upToEnd].	rows asArray = #(#('Curly') #('Larry') #('Moe')) ifFalse: [Exception raiseSignal: 'Test30 - failed'].	session prepare: 'select name, blobdata from exdiTest30 order by name '; execute.	rows := OrderedCollection new.	[(answer := session answer) == #noMoreAnswers]		whileFalse: [rows := rows , answer upToEnd].	rows do: [:aRow | (aRow at: 2) isInteger ifFalse: [Exception raiseSignal: 'Test30 - failed']].	session := connection getSession.	session prepare: 'drop table exdiTest30'.	session execute.	connection disconnect.	^self</body><body package="PostgreSQLEXDI">test31	"^self 	*** Can be changed *** 	I re-create a situation where the answer of a query differs between the first and second time it's 	executed. The problem was caused by a blob handling bug in the StORE mapping. This method can 	be extended to test other things."	"self test31"	| connection session testBlob values rows answer |	connection := self testConnection.	session := connection getSession.	[session prepare: 'drop table exdiTest31'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	[session prepare: 'drop rule exdiTest31_update'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	session prepare: 'create table exdiTest31 (number int4, name varchar(31), blobdata oid )'.	session execute.	session prepare: '			create rule exdiTest31_update as on update to exdiTest31			do select lo_unlink(old.blobdata) from exdiTest31;'.	session execute.	testBlob := PostgreSQLEXDIBLOB on: (ByteArray withAll: (0 to: 200)).	connection begin.	session prepare: 'INSERT INTO exdiTest31 (number, name, blobdata) VALUES(?, ?, ?)'.	values := OrderedCollection new.	values add: (Array			with: 1001			with: 'Curly'			with: testBlob).	values add: (Array			with: 1002			with: 'Moe'			with: testBlob).	values add: (Array			with: 1003			with: 'Larry'			with: testBlob).	values do: [:entry | session bindInput: entry; execute; answer].	connection commit.	session prepare: 'select name from exdiTest31 order by number '; execute.	rows := OrderedCollection new.	[(answer := session answer) == #noMoreAnswers]		whileFalse: [rows := rows , answer upToEnd].	rows asArray = #(#('Curly') #('Moe') #('Larry')) ifFalse: [Exception raiseSignal: 'Test31 - failed'].	session prepare: 'select name, blobdata from exdiTest31 order by name '; execute.	rows := OrderedCollection new.	[(answer := session answer) == #noMoreAnswers]		whileFalse: [rows := rows , answer upToEnd].	rows do: [:aRow | (aRow at: 2) isInteger ifFalse: [Exception raiseSignal: 'Test31 - failed']].	session := connection getSession.	session prepare: 'drop table exdiTest31'.	session execute.	connection disconnect.	^self</body><body package="PostgreSQLEXDI">test32	"^self 	I insert three smallish (256 bytes) byte arrays into a table. This just makes sure that the translation 	to/from the database works OK."	"self test32"	| connection session testBlob values rows answer testBlobStream |	connection := self testConnection.	session := connection getSession.	[session prepare: 'drop table exdiTest32'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	session prepare: 'create table exdiTest32 (number int4,  bytes bytea )'; execute.	testBlobStream := ByteArray new writeStream.	testBlobStream nextPutAll: (0 to: 255).	testBlob := testBlobStream contents.	connection begin.	session prepare: 'INSERT INTO exdiTest32 (number, bytes) VALUES( ?, ?)'.	values := OrderedCollection new.	values add: (Array with: 1001 with: testBlob).	values add: (Array with: 1002 with: testBlob).	values add: (Array with: 1003 with: testBlob).	values do: [:entry | session bindInput: entry; execute; answer].	connection commit.	session prepare: 'select bytes from exdiTest32 order by number '; execute.	rows := OrderedCollection new.	[(answer := session answer) == #noMoreAnswers]		whileFalse: [rows := rows , answer upToEnd].	rows do: [:aRow | aRow first = testBlob ifFalse: [Exception raiseSignal: 'Test32 - failed']].	session := connection getSession.	session prepare: 'drop table exdiTest32'.	session execute.	connection disconnect.	^self</body><body package="PostgreSQLEXDI">test33	"^self 	I insert a single very large (&gt;8k) byte array into a table. This should 	force the creation of multiple byte array framgments.	This test may 	become interesting for future versions of PostgreSQL which can 	handle tuples &gt; 8Kb."	"self test33"	| connection session testBlob values rows answer testBlobStream |	self notYetImplemented.	connection := self testConnection.	session := connection getSession.	[session prepare: 'drop table exdiTest33'; execute]		on: connection class externalDatabaseErrorSignal do: [:e | ].	session prepare: 'create table exdiTest33 (number int4,  bytes bytea )'; execute.	testBlobStream := (ByteArray new: 9000) writeStream.	33 timesRepeat: [testBlobStream nextPutAll: (0 to: 255)].	testBlob := testBlobStream contents.	connection begin.	session prepare: 'INSERT INTO exdiTest33 (number, bytes) VALUES( ?, ?)'.	values := OrderedCollection new.	values add: (Array with: 1001 with: testBlob).	values add: (Array with: 1002 with: testBlob).	values add: (Array with: 1003 with: testBlob).	values do: [:entry | session bindInput: entry; execute; answer].	connection commit.	session prepare: 'select bytes from exdiTest33 order by number '; execute.	rows := OrderedCollection new.	[(answer := session answer) == #noMoreAnswers]		whileFalse: [rows := rows , answer upToEnd].	rows do: [:aRow | aRow first = testBlob ifFalse: [Exception raiseSignal: 'Test33 - failed']].	session := connection getSession.	session prepare: 'drop table exdiTest33'.	session execute.	connection disconnect.	^self</body></methods><methods><class-id>PostgreSQLEXDITest class</class-id> <category>services</category><body package="PostgreSQLEXDI">initializeTestDatabase	"^self 	I initialize the test database using a &gt;&gt;testConnection. I create and populate three tables in the 	database."	"self initializeTestDatabase"	| connection |	connection := self testConnection.	self initializeTestSchemaUsing: connection.	self initializeTestDataUsing: connection.	connection disconnect.	^self</body><body package="PostgreSQLEXDI">initializeTestDataUsing: aConnection 	"^self 	I populate the test database via aConnection."	| session |	session := aConnection getSession.	session prepare: 'INSERT INTO task (name) VALUES(?)'.	#(#('Admin') #('Vacation') #('Project A') #('Project B') #('Project C') #('Project D')) do: [:entry | session bindInput: entry; execute; answer].	session prepare: 'INSERT INTO assignee (name) VALUES(?)'.	#(#('Development') #('QA') #('Bill') #('Bert') #('Bob') #('Barry')) do: [:entry | session bindInput: entry; execute; answer].^self</body><body package="PostgreSQLEXDI">initializeTestSchemaUsing: aConnection 	"^self 	I initialize the test schema using aConnection. I do not populate the schema."	|  session |	session := aConnection getSession.	[session prepare: 'drop table task'; execute] on: aConnection class externalDatabaseErrorSignal do: [:e|].	[session prepare: 'drop table assignee'; execute] on: aConnection class externalDatabaseErrorSignal do: [:e|].	[session prepare: 'drop table assignment'; execute] on: aConnection class externalDatabaseErrorSignal do: [:e|].	session prepare: 'create table task (name varchar(30))'; execute.	session prepare: 'create table assignee (name varchar(30))'; execute.	session prepare: 'create table assignment (task oid, assignee oid)'; execute.	^self</body><body package="PostgreSQLEXDI">testConnection	| connection |	connection := PostgreSQLEXDIConnection new.	connection		username: self testUsernameString;		password: self testPasswordString;		environment: self testEnvironmentString.	connection connect.	^connection</body><body package="PostgreSQLEXDI">testEnvironmentString	"^a String 	I return the connection environment string to use for all tests. I compose this from &gt;&gt;testHost and 	&gt;&gt;testDatabaseName from the PostgreSQLTest class."	^PostgreSQLTest testHost , '_' , PostgreSQLTest testDatabaseName</body><body package="PostgreSQLEXDI">testPasswordString	"^a String 	I return the password I'll use for testing.  I delegate this to the PostgreSQLTest class"	^PostgreSQLTest testPassword</body><body package="PostgreSQLEXDI">testUsernameString	"^a String 	I return the username I'll use for all tests.  I delegate this to the PostgreSQLTest class"	^PostgreSQLTest testUserName</body></methods><methods><class-id>PostgreSQLEXDITest class</class-id> <category>instance creation</category><body package="PostgreSQLEXDI">withIdentity: anInteger andNameString: aString 	"^aPostgreSQLEXDITest 	I return an instance of myself. This new instance is just a victim for use in tests, and does not 	represent a test."	^self new withIdentity: anInteger andNameString: aString</body></methods><methods><class-id>PostgreSQLEXDIConnection</class-id> <category>accessing</category><body package="PostgreSQLEXDI">connection	^connection</body><body package="PostgreSQLEXDI">environment	"^a String 	I return my environment string. This specifies where the target database service is, and how to get 	to it. Typically this means database name, host and port number. If the environment is nil, I initialize 	to the default environment as known to my class."	super environment isNil ifTrue: [self environment: self class defaultEnvironment].	^super environment</body><body package="PostgreSQLEXDI">environment: aString 	"^self 	I override my superclass behaviour to make the 'map logical' stuff work. The thing is, it's in the 	VisualWorks EXDI manual, but the EXDI implementation seems to just ignore it - good grief!"	super environment: (self class mapLogical: aString).	^self</body><body package="PostgreSQLEXDI">environmentParameters	"^a PostgreSQLEXDIEnvironmentString 	I return an environment string structure which knows how to get the host name, port number and 	database name out of a raw envionment string."	environmentParameters isNil ifTrue: [environmentParameters := PostgreSQLEXDIEnvironmentString on: self environment].	^environmentParameters</body><body package="PostgreSQLEXDI">parameterSet	"^a ParameterSet 	I return a parameter set based on the values 	given when I was created."	parameterSet isNil		ifTrue: 			[parameterSet := ConnectionParameterSet new.			parameterSet				host: self hostName;				port: self portNumber;				databaseName: self databaseName;				userName: self username;				password: self password].	^parameterSet</body></methods><methods><class-id>PostgreSQLEXDIConnection</class-id> <category>private</category><body package="PostgreSQLEXDI">databaseName	"^a String 	I return the name of the database I represent a connection to."	^self environmentParameters databaseName</body><body package="PostgreSQLEXDI">hostName	"^a String 	I return the hostname of the machine running the postgresql backend. If the user has not specified a 	host name, the default is 'localhost'."	| userSpecifiedHostName |	userSpecifiedHostName := self environmentParameters hostName.	^userSpecifiedHostName isNil		ifTrue: ['localhost']		ifFalse: [userSpecifiedHostName]</body><body package="PostgreSQLEXDI">portNumber	"^an Integer 	I return the port number that the server is running on. If the user has not specified a port number, I 	use the default for PostgreSQL which is 5432."	| userSpecifiedPortNumber |	userSpecifiedPortNumber := self environmentParameters portNumber.	^userSpecifiedPortNumber isNil		ifTrue: [5432]		ifFalse: [userSpecifiedPortNumber]</body></methods><methods><class-id>PostgreSQLEXDIConnection</class-id> <category>license</category><body package="PostgreSQLEXDI">license	"^a License 	I return the license under which this software is made available."	^PostgreSQLDriverLicense license</body></methods><methods><class-id>PostgreSQLEXDIConnection</class-id> <category>private-library calls</category><body package="PostgreSQLEXDI">acquireExternal	"^self 	Acquire the external resources. VW3.0 implementation."	connection := PostgreSQLConnection using: self parameterSet.	^self</body><body package="PostgreSQLEXDI">acquireExternal: aPassword 	"^self 	Acquire the external resources. VW5i implementation."	self parameterSet password: aPassword.	^self acquireExternal</body><body package="PostgreSQLEXDI">beginExternal	"^self 	I perform my superclass actions, then I start the transaction using 'begin'. I could have used 'begin 	transaction' or 'begin work' but the backend would just ignore the second word, so why bother sending 	it?	Note that this method did use 'each disconnect' for each participant which broke PostgreSQLTest class&gt;&gt;test15.	Changed to 'each cancel' at the suggestion of Chris Lopeman of CDL -Object Link Inc."	super beginExternal.	self participantsDo: [:each | each cancel].	(self getSession)		prepare: 'begin';		execute;		answer;		disconnect.	^self</body><body package="PostgreSQLEXDI">commitExternal	"^self 	I perform my superclass actions and check that it's really OK to commit. Then I commit the 	transaction using 'commit'. I could have used 'commit transaction' or 'commit work' but the backend 	would just ignore the second word, so why bother sending it?	Note that this method did use 'each disconnect' for each participant which broke PostgreSQLTest class&gt;&gt;test15.	Changed to 'each cancel' at the suggestion of Chris Lopeman of CDL -Object Link Inc."	super commitExternal ifFalse: [^self].	self participantsDo: [:each | each cancel].	(self getSession)		prepare: 'commit';		execute;		answer;		disconnect.	^self</body><body package="PostgreSQLEXDI">dismissExternal	"^self 	I close the connection."	self connection close</body><body package="PostgreSQLEXDI">rollbackExternal	"^self 	I perform my superclass actions and check that it's really OK to rollback. Then I rollback the 	transaction using 'rollback'. I could have used 'rollback transaction' or 'rollback work' but the backend 	would just ignore the second word, so why bother sending it?	Note that this method did use 'each disconnect' for each participant which broke PostgreSQLTest class&gt;&gt;test15.	Changed to 'each cancel' at the suggestion of Chris Lopeman of CDL -Object Link Inc."	super rollbackExternal ifFalse: [^self].	self participantsDo: [:each | each cancel].	(self getSession)		prepare: 'rollback';		execute;		answer;		disconnect</body></methods><methods><class-id>PostgreSQLEXDIConnection</class-id> <category>services</category><body package="PostgreSQLEXDI">encoding	"^a SymbolThis is just a convinience method for getting the string encoding to the used by my underlying connection."	^self connection stringEncodingName</body><body package="PostgreSQLEXDI">encoding: aSymbol 	"^selfThis is just a convinience method for setting the string encoding to the used by my underlying connection."	^self connection encoding: aSymbol</body></methods><methods><class-id>PostgreSQLEXDIConnection class</class-id> <category>accessing</category><body package="PostgreSQLEXDI">columnDescriptionClass	^PostgreSQLEXDIColumnDescription</body><body package="PostgreSQLEXDI">kind	"^a Symbol 	I return a symbol representing the type ofDMBS the I provide services for. That would be 	PostgreSQL databases for me."	^#PostgreSQL</body><body package="PostgreSQLEXDI">sessionClass	^PostgreSQLEXDISession</body><body package="PostgreSQLEXDI">storeBroker	"^a Class 	I return the class of the Store Broker I am to work with. In order for this to be useful, it must have 	been initialized by an external entity (the Store broker itself when loaded?)."	^storeBroker</body><body package="PostgreSQLEXDI">storeBroker: aClass 	"^self 	I record the class of the Store Broker I am to work with."	storeBroker := aClass.	^self</body><body package="PostgreSQLEXDI">version	"^aString 	I return a String which identifies the version of the EXDI layer I'm 	using. For some reason, my superclass implementation does *not* 	return a String. This looks like a bug."	^super version asString , (String with: Character cr) , 'PostgreSQL EXDI layer ' , PostgreSQLDriverLicense license versionName</body></methods><methods><class-id>PostgreSQLEXDIConnection class</class-id> <category>activation</category><body package="PostgreSQLEXDI">pause	"Direct this driver (or all drivers if receiver is ExternalDatabaseConnection) to 	indefinitely suspend operations. I don't take any special action to pause, so this is a no-op for me."	^self</body></methods><methods><class-id>PostgreSQLEXDIConnection class</class-id> <category>private-activation</category><body package="PostgreSQLEXDI">install	"Direct this driver (or all drivers if receiver is ExternalDatabaseConnection) to 	take the necessary steps for returning from a snapshot. Notify dependents 	when fully installed so that appropriate action may be taken."	^self</body></methods><methods><class-id>PostgreSQLEXDIConnection class</class-id> <category>private-accessing</category><body package="PostgreSQLEXDI">transactionClass	"a Class 	I return the class to be used for transaction objects associated with my instances. In this case, 	that's the PostgreSQLTransaction class"	^PostgreSQLEXDITransaction</body></methods><methods><class-id>PostgreSQLEXDIConnection class</class-id> <category>tracing</category><body package="PostgreSQLEXDI">traceLevel: newTraceLevel 	"^self 	I set the level of tracing that is enabled for this class to anInteger. I 	get my superclass to do it's thing, then I set the PostgreSQL logging 	facilities to do the right thing. This method is rather horrible and 	procedural - please let me know if you think of a better way of 	doing this."	super traceLevel: newTraceLevel.	(self traceCollector isNil or: [newTraceLevel isZero])		ifTrue: [traceLog notNil				ifTrue: 					[traceLog close.					traceLog := nil.					^self]].	traceLog isNil ifTrue: [traceLog := PostgreSQLConnectionLog logEverythingTo: self traceCollector].	^self</body></methods><methods><class-id>PostgreSQLEXDIConnection class</class-id> <category>signal constants</category><body package="PostgreSQLEXDI">externalDatabaseErrorSignal	"^PostgreSQLError	I answer the most general external database error signal. Because I work 	with ANSI exceptions this is a subclass of Exception rather than an 	instance of Signal. Note that there is a more general exception class (i.e. 	PostgreSQLException) but not all exceptions are errors (e.g. a 	PostgreSQLNoticeResponse), hence PostgreSQLError being returned here."	^PostgreSQLError</body></methods><methods><class-id>PostgreSQLEXDIBLOB</class-id> <category>initialize-release</category><body package="PostgreSQLEXDI">on: aByteArray 	"^self 	I initialize myself to represent aByteArray as a Binary Large OBject ( a BLOB)."	byteArray := aByteArray.	^self</body></methods><methods><class-id>PostgreSQLEXDIBLOB</class-id> <category>accessing</category><body package="PostgreSQLEXDI">byteArray	"^a ByteArray 	I return the ByteArray I represent."	^byteArray</body></methods><methods><class-id>PostgreSQLEXDIBLOB class</class-id> <category>instance creation</category><body package="PostgreSQLEXDI">on: aByteArray 	"^a PostgreSQLEXDIBLOB 	I return a new instance of myself which represents aByteArray as a Binary Large OBject ( a BLOB)."	^self new on: aByteArray</body></methods><methods><class-id>PostgreSQLEXDIFieldValue</class-id> <category>initialize-release</category><body package="PostgreSQLEXDI">onObject: anObject 	"^self 	Iinitialize myself to represent anObject."	object := anObject.	^self</body></methods><methods><class-id>PostgreSQLEXDIFieldValue</class-id> <category>accessing</category><body package="PostgreSQLEXDI">object	"^an Object 	I return my object. If it's nil, I try and make it from my string value."	object isNil ifTrue: [object := self objectFromString].	^object</body><body package="PostgreSQLEXDI">string	"^a String	I return my string representation. If it's nil, I try and make it from my object value."	string isNil ifTrue: [string := self stringFromObject].	^string</body></methods><methods><class-id>PostgreSQLEXDIFieldValue</class-id> <category>private</category><body package="PostgreSQLEXDI">objectFromString	"^an Object 	My subclasses must implement this."	^self subclassResponsibility</body><body package="PostgreSQLEXDI">stringFromObject	"^a String 	My subclasses must implement this."	^self subclassResponsibility</body></methods><methods><class-id>PostgreSQLEXDIFieldValue</class-id> <category>emitting</category><body package="PostgreSQLEXDI">writeStringTo: aStream 	"^self 	I simply write my string value to aStream."	aStream nextPutAll: self string.	^self</body></methods><methods><class-id>PostgreSQLEXDIFieldValue</class-id> <category>license</category><body package="PostgreSQLEXDI">license	"^a License 	I return the license under which this software is made available."	^PostgreSQLDriverLicense license</body></methods><methods><class-id>PostgreSQLEXDIFieldValue class</class-id> <category>private</category><body package="PostgreSQLEXDI">canHandle: anObject 	"^a Boolean 	I return true if my instances can handle this kind of objects, otherwise I return false."	^self subclassResponsibility</body><body package="PostgreSQLEXDI">onObject: anObject 	"^a PostgreSQLEXDIFieldValue 	I return an instance of myself to represent anObject. My subclasses may override this method (I'm 	thinking of the cass which handles nil)."	^self new onObject: anObject</body></methods><methods><class-id>PostgreSQLEXDIFieldValue class</class-id> <category>instance creation</category><body package="PostgreSQLEXDI">forObject: anObject 	"^a PostgreSQLEXDIFieldValue 	I return an instance of one of my subclasses. I ask each of them if they can represent anObject, 	and the first one to say yes get's it. If none of my subclasses are interested, I throw an exception."	| volunteerClass |	volunteerClass := self subclasses detect: [:aSubclass | aSubclass canHandle: anObject]				ifNone: [PostgreSQLEXDIFieldValueException raiseSignal: 'Unable to map object to value.'].	^volunteerClass onObject: anObject</body></methods><methods><class-id>PostgreSQLEXDIBLOBValue</class-id> <category>private</category><body package="PostgreSQLEXDI">callFunctionInTheContextOf: aSession 	"^self 	I decide what actions I have to take to get the blob I represent correctly represented on the server, 	and then I make a note of the oid of the blob. I make sure that we are in a transaction - if we're not, 	I throw a non-proceedable exception. 	This is a *very* crude implementation which is intended to just get things going. Note that a new blob 	is created regardless of whether this is an insert or update action. Also note that the deletion of a row 	will not delete a BLOB it's referring to. Triggers must be added to tables containing blobs to remove 	old/stale BLOBs."	| connection functionCall result oidValue blobDescriptorValue |	aSession connection inTransactionMode 		ifFalse: [PostgreSQLEXDIBLOBManipulationOutsideTransaction raiseSignal].	connection := aSession connection connection.	functionCall := connection newFunctionCall.	functionCall 		function: (connection functionTable objectWithName: #lo_creat).	functionCall 		addArgument: (ByteValue size: 4 value: #[0 6 0 0] asByteArray for: functionCall).	result := functionCall execute.	oidValue := result functionResponse value asIntValue.	functionCall := connection newFunctionCall.	functionCall function: (connection functionTable objectWithName: #lo_open).	functionCall addArgument: oidValue.	functionCall 		addArgument: (ByteValue size: 4 value: #[0 6 0 0] asByteArray for: functionCall).	result := functionCall execute.	blobDescriptorValue := result functionResponse value asIntValue.	functionCall := connection newFunctionCall.	functionCall function: (connection functionTable objectWithName: #lowrite).	functionCall addArgument: blobDescriptorValue.	functionCall 		addArgument: (ByteValue size: self object byteArray size value: self object byteArray  for: functionCall).	result := functionCall execute.	functionCall := connection newFunctionCall.	functionCall 		function: (connection functionTable objectWithName: #lo_close).	functionCall addArgument: blobDescriptorValue.	result := functionCall execute.	self oid: oidValue value.	^self</body><body package="PostgreSQLEXDI">oid	"^an Integer 	I return the oid of the blob I represent."	^oid</body><body package="PostgreSQLEXDI">oid: anInteger 	"^self 	I record the oid of the blob I represent."	oid := anInteger.	^self</body><body package="PostgreSQLEXDI">stringFromObject	"^a String 	My string value is the string form of the integer which is the oid of the BLOB I represent. This is a 	non-trivial matter. I must submit several fuction calls to the PostgreSQL back end which create &amp; 	update the blob. By myself, I can't see the database; I need to get hold of the database connection. 	To acieve this, I throw an exception which is caught by the session. The session in turn then sends 	me the &gt;&gt;callFunctionInTheContextOf: with itself as the argument. This enables me to get hold of 	the connection and call the appropriate blob functions on the back end.  I then return control to 	the session, which in turn resumes the exception returning control here. Finally I take the oid of the 	blob and return it's value as a string. Phew!! 	NOTE: This way of handling blobs results in a new BLOB for every update. It is very important that 	database triggers are used to remove old blobs from the database when a row containing BLOB 	references is updated or deleted."	PostgreSQLEXDIFieldValueFunctionCallRequest signalWith: self.	^self oid printString</body></methods><methods><class-id>PostgreSQLEXDIBLOBValue class</class-id> <category>private</category><body package="PostgreSQLEXDI">canHandle: anObject 	"^a Boolean 	I only handle PostgreSQLEXDIBLOBs. If anObject is a PostgreSQLEXDIBLOB I return true, otherwise 	I return false."	^anObject isKindOf: PostgreSQLEXDIBLOB</body></methods><methods><class-id>PostgreSQLEXDIStringValue</class-id> <category>private</category><body package="PostgreSQLEXDI">stringFromObject	"^a String 	This is a rather crude implementation for now."	| rawStream refinedStream obj|	obj := object.	self object isSymbol ifTrue:[ obj := object asString].	rawStream := obj printString readStream.	refinedStream := String new writeStream.	[rawStream atEnd]		whileFalse: 			[| character |			character := rawStream next.			character = $\ ifTrue: [refinedStream nextPut: $\].			refinedStream nextPut: character].	^refinedStream contents</body></methods><methods><class-id>PostgreSQLEXDIStringValue class</class-id> <category>private</category><body package="PostgreSQLEXDI">canHandle: anObject 	"^a Boolean 	I my instances can handle most things by getting their &gt;&gt;printString, but they can't handle nil or 	BLOBs (ByteArray). So, I return true unless an object is nil or a ByteArray."	^anObject notNil and: [(anObject isKindOf: ByteArray) not and: [(anObject isKindOf: PostgreSQLEXDIBLOB) not]]</body></methods><methods><class-id>PostgreSQLEXDIByteArrayValue</class-id> <category>private</category><body package="PostgreSQLEXDI">stringFromObject	"^a String 	ByteArrays can be stored in PostgreSQL fields of type bytea, but they must be Base 64 encoded 	first. This encoding makes the byte array about 30% longer but in return it means that the data can 	be stored on the target row rather than in a separate BLOB."	| writeStream |	writeStream := Base64EncodingWriteStream on: (String new: ((self object size) * (3 / 2)) rounded).	writeStream disableLineBreaks.	writeStream nextPutAll: self object.	writeStream close.	^writeStream contents printString</body></methods><methods><class-id>PostgreSQLEXDIByteArrayValue class</class-id> <category>private</category><body package="PostgreSQLEXDI">canHandle: anObject 	"^a Boolean 	I only handle ByteArrays. If anObject is a ByteArray I return true, otherwise I return false."	^anObject isKindOf: ByteArray</body></methods><methods><class-id>PostgreSQLEXDITransaction</class-id> <category>license</category><body package="PostgreSQLEXDI">license	"^a License 	I return the license under which this software is made available."	^PostgreSQLDriverLicense license</body></methods><methods><class-id>PostgreSQLEXDITransaction</class-id> <category>private-library calls</category><body package="PostgreSQLEXDI">beginExternal	"^self 	Transactions are connection related not session related for PostgreSQL, so I just return myself."	^self</body><body package="PostgreSQLEXDI">commitExternal	"^self 	Transactions are connection related not session related for PostgreSQL, so I just return myself."	^self</body><body package="PostgreSQLEXDI">rollbackExternal	"^self 	Transactions are connection related not session related for PostgreSQL, so I just return myself."	^self</body></methods><methods><class-id>PostgreSQLEXDITransaction class</class-id> <category>accessing</category><body package="PostgreSQLEXDI">connectionClass	^PostgreSQLEXDIConnection</body></methods><methods><class-id>PostgreSQLEXDIEnvironmentString</class-id> <category>accessing</category><body package="PostgreSQLEXDI">environmentString	"^a String 	I return the raw environment string."	^environmentString</body></methods><methods><class-id>PostgreSQLEXDIEnvironmentString</class-id> <category>initialize-release</category><body package="PostgreSQLEXDI">on: aString 	"^self 	I initialize myself to represent the values encoded in aString, which is presumed 	to be an environment string as described in the EXDI manual."	environmentString := aString.	^self</body></methods><methods><class-id>PostgreSQLEXDIEnvironmentString</class-id> <category>private</category><body package="PostgreSQLEXDI">hostAndPort	"^a String 	I return the combined host:port number string if it exists in the environment string, otherwise, I return 	nil."	^(self environmentString includes: $_)		ifTrue: [self environmentString copyUpTo: $_]		ifFalse: [nil]</body></methods><methods><class-id>PostgreSQLEXDIEnvironmentString</class-id> <category>license</category><body package="PostgreSQLEXDI">license	"^a License 	I return the license under which this software is made available."	^PostgreSQLDriverLicense license</body></methods><methods><class-id>PostgreSQLEXDIEnvironmentString</class-id> <category>services</category><body package="PostgreSQLEXDI">databaseName	"^aString 	I return a string which is the database name as specified in the environment string I represent. I will 	return nil if no database name is specified."	^self environmentString isNil		ifTrue: [nil]		ifFalse: [(self environmentString includes: $_)				ifTrue: [self environmentString copyFrom: (self environmentString indexOf: $_)							+ 1 to: self environmentString size]				ifFalse: [self environmentString]]</body><body package="PostgreSQLEXDI">hostName	"^aString 	I return a string which is the host name as specified in the environment string I represent. I will return 	nil if no host name is specified."	^self hostAndPort isNil		ifTrue: [nil]		ifFalse: [(self hostAndPort includes: $:)				ifTrue: [self hostAndPort copyUpTo: $:]				ifFalse: [self hostAndPort ]]</body><body package="PostgreSQLEXDI">portNumber	"^anInteger 	I return an Integer which is the port number as specified in the environment string I represent. I will 	return nil if no port number is specified."	| hostAndPort |	hostAndPort := self hostAndPort.	^hostAndPort isNil		ifTrue: [nil]		ifFalse: [(hostAndPort includes: $:)				ifTrue: [(hostAndPort copyFrom: (hostAndPort indexOf: $:)							+ 1 to: hostAndPort size) asNumber]				ifFalse: [nil]]</body></methods><methods><class-id>PostgreSQLEXDIEnvironmentString class</class-id> <category>instance creation</category><body package="PostgreSQLEXDI">on: aString 	"^a PostgreSQLEXDIEnvironmentString 	I return a new instance of myself which represents the values encoded in aString, which is presumed 	to be an environment string as described in the EXDI manual."	^self new on: aString</body></methods><methods><class-id>PostgreSQLEXDINullValue</class-id> <category>private</category><body package="PostgreSQLEXDI">stringFromObject	"^a String 	My string value is always NULL."	^'NULL'</body></methods><methods><class-id>PostgreSQLEXDINullValue class</class-id> <category>private</category><body package="PostgreSQLEXDI">canHandle: anObject 	"^a Boolean 	I return true if my instances can handle this kind of objects, otherwise I return false."	^anObject isNil</body><body package="PostgreSQLEXDI">onObject: anObject 	"^a PostgreSQLEXDIFieldValue 	I return my singleton instance."	nullValue isNil ifTrue: [nullValue := self new onObject: anObject].	^nullValue</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ExternalDatabaseColumnDescription</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name index type length precision scale nullable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>ExternalDatabaseError</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dbmsErrorCode dbmsErrorString osErrorCode osErrorString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>ExternalDatabaseConnection</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transaction username password environment transactionCoordinator cachedSession isolationLevel </inst-vars><class-inst-vars>environmentMap xif xifMap </class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>ExternalDatabaseSession</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection query queryFragments bindInput bindTemplate bindOutput useNamedOutputBinding bindValues resultTemplate allocateForEachRow blockFactor numColumns columnDescriptions rowAdaptors rowBuffersHolder bufferIndex answerStream currentRow </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>ExternalDatabaseTransaction</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>memberCountHolder remainingCountHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>Exception</name><environment>Core</environment><super>Core.GenericException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>