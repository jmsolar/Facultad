<?xml version="1.0"?><st-source><!-- Name: PostgreSQLVWCompatibilityComment: ©Bruce Badger 2000 - 2004. Licensed under the LGPL.This package contains the classes that make up the PostgreSQL mapping layer.  The objective is to absorb the dialect specific issues here, and have the main part of the library use (for example) PostgreSQLException context, rather than the VisualWorks or GemStone equivalents.You *must* have this package loaded to use the PostgrSQL driver.VisualWorks is currently the development environment, and the library has been ported to GemStone and Squeak.- - Please send your comments to bbadger@openskills.com.  Thanks.DbIdentifier: OSSYD001DbTrace: 2211DevelopmentPrerequisites: #(#(#any 'MD5' ''))PackageName: PostgreSQLVWCompatibilityParcel: #('PostgreSQLVWCompatibility')PrerequisiteParcels: #(#('MD5' ''))PrintStringCache: (1.3 014,bbadger)Version: 1.3 014Date: 8:03:10 pm November 4, 2004 --><time-stamp>From VisualWorks® NonCommercial, 7.2 of November 3, 2003 on November 4, 2004 at 8:03:10 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>NativeTimestamp</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>timestamp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PostgreSQLVWCompatibility</category><attributes><package>PostgreSQLVWCompatibility</package></attributes></class><class><name>NativeExceptionContext</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PostgreSQLVWCompatibility</category><attributes><package>PostgreSQLVWCompatibility</package></attributes></class><class><name>NativeError</name><environment>Smalltalk</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PostgreSQLVWCompatibility</category><attributes><package>PostgreSQLVWCompatibility</package></attributes></class><class><name>NativeCodeForSqueak</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PostgreSQLVWCompatibility</category><attributes><package>PostgreSQLVWCompatibility</package></attributes></class><class><name>NativeCodeForGemStone</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PostgreSQLVWCompatibility</category><attributes><package>PostgreSQLVWCompatibility</package></attributes></class><class><name>NativeEnvironment</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PostgreSQLVWCompatibility</category><attributes><package>PostgreSQLVWCompatibility</package></attributes></class><class><name>NativeMD5Digest</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>currentMD5Class </class-inst-vars><imports></imports><category>PostgreSQLVWCompatibility</category><attributes><package>PostgreSQLVWCompatibility</package></attributes></class><class><name>NativeSocketSession</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>externalConnection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PostgreSQLVWCompatibility</category><attributes><package>PostgreSQLVWCompatibility</package></attributes></class><class><name>NativeWeakArray</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PostgreSQLVWCompatibility</category><attributes><package>PostgreSQLVWCompatibility</package></attributes></class><methods><class-id>NativeTimestamp</class-id> <category>printing</category><body package="PostgreSQLVWCompatibility">printOn: aStream 	"^self 	I delegate this to my underlying timestamp."	self timestamp printOn: aStream.	^self</body></methods><methods><class-id>NativeTimestamp</class-id> <category>initialize-release</category><body package="PostgreSQLVWCompatibility">on: aTimestamp 	"^self"	timestamp := aTimestamp.	^self</body></methods><methods><class-id>NativeTimestamp</class-id> <category>accessing</category><body package="PostgreSQLVWCompatibility">timestamp	"^a Timestamp 	I return my underlying timestamp."	^timestamp</body></methods><methods><class-id>NativeTimestamp class</class-id> <category>instance creation</category><body package="PostgreSQLVWCompatibility">now	"^a PortableTimestamp 	I return a new instance of myself which represents a particular point 	in time (date, time &amp; timezone)."	^self new on: Timestamp now</body></methods><methods><class-id>NativeExceptionContext class</class-id> <category>instance creation</category><body package="PostgreSQLVWCompatibility">for: aBlock on: anException do: exceptionBlock 	"^an Object 	I return the result of evaluating aBlock. In VisualWorks and other 	Smalltalks which are ANSI compliant, I delegate to aBlock."	^aBlock on: anException do: exceptionBlock</body></methods><methods><class-id>NativeExceptionContext class</class-id> <category>native exceptions</category><body package="PostgreSQLVWCompatibility">brokenPipeException	"I return the exception that get's thrown when a socket connection gets 	broken. This is used in PostgreSQLConnection&gt;&gt;close."	^OsTransferFaultError</body></methods><methods><class-id>NativeCodeForSqueak class</class-id> <category>read me</category><body package="PostgreSQLVWCompatibility">readMe"^a StringI return the string which is the readme for porting the drivers to Squeak."^' How to port the PostgreSQL driver to Squeak from VW 71. Load a version of the PostgreSQL library from StORE which contains a version of the PostgreSQL VW Compatibility package with the class NativeCodeForSqueak.2. Load the FileOut30 parcel.  This adds the ability for VisualWorks to fileout stuff in a Squeak-friendly form.3. From the VisualWorks Launcher, choose System&gt;Settings.  Then select the "File-out Type" tab, select the "VW 3.0 compatible source cose" radio button and hit accept.  You can close the settings window now, too.4.  Create the Squeak compatibility file-out.  You can do this by browsing the class side of  the class NativeCodeForSqueak, and evaluating the statement in the comment of the allClasses method.  This will make a file called squeak-compatibility.st in the current directory.5. File-out the PostgreSQLDriver package to the local directory.6. On Linux/Unix platforms you may need to run the command unix2dos on both of the files.  If you don''t do this you may not be able to file-in the code to Squeak.7. Start a Squeak image and file in the compatibility .st file and the PostgreSQL drive .st file. That should be it.  You can test out the driver by running through the methods on the class side of the PostgreSQLTest class.Have fun.'</body></methods><methods><class-id>NativeCodeForSqueak class</class-id> <category>code strings</category><body package="PostgreSQLVWCompatibility">allClasses"^a StringReturn the string which is the .st file content for all the compatibility classes in Squeak.""(Filename named: 'squeak-compatibility.st') writeStream nextPutAll: self allClasses; close"^'Error subclass: #NativeError	instanceVariableNames: ''parameter ''	classVariableNames: ''''	poolDictionaries: ''''	category: ''Database-PostgreSQL-Compatibility''!!NativeError methodsFor: ''accessing'' stamp: ''BB 11/20/2002 21:51''!parameter	^parameter! !!NativeError methodsFor: ''accessing'' stamp: ''BB 11/20/2002 21:51''!parameter: anObject	parameter := anObject.	^self! !!NativeError methodsFor: ''exceptionSignaler'' stamp: ''BB 11/20/2002 21:54''!raise	^self signal! !!NativeError methodsFor: ''exceptionDescription'' stamp: ''BB 11/20/2002 22:01''!isResumable	^self mayResume! !!NativeError methodsFor: ''exceptionDescription'' stamp: ''BB 11/20/2002 22:46''!mayResume	^self class mayResume! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!NativeError class	instanceVariableNames: ''''!!NativeError class methodsFor: ''instance creation'' stamp: ''BB 11/20/2002 21:46''!raise	"Signal the occurrence of an exceptional condition."	^ self signal! !!NativeError class methodsFor: ''instance creation'' stamp: ''BB 11/20/2002 21:47''!raiseSignal: aString	"Signal the occurrence of an exceptional condition."	^ self signal: aString! !!NativeError class methodsFor: ''testing'' stamp: ''BB 11/20/2002 22:45''!mayResume	"my subclasses may override this."	^false! !Object subclass: #NativeExceptionContext	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	category: ''Database-PostgreSQL-Compatibility''!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!NativeExceptionContext class	instanceVariableNames: ''''!!NativeExceptionContext class methodsFor: ''native exceptions'' stamp: ''BB 11/20/2002 21:35''!brokenPipeException	"I return the exception that get''s thrown when a socket connection gets 	broken. This is used in PostgreSQLConnection&gt;&gt;close."	^Error! !!NativeExceptionContext class methodsFor: ''instance creation'' stamp: ''BB 11/20/2002 21:33''!for: aBlock on: anException do: exceptionBlock 	"^an Object 	I return the result of evaluating aBlock. In VisualWorks and other 	Smalltalks which are ANSI compliant, I delegate to aBlock."	^aBlock on: anException do: exceptionBlock! !Object subclass: #NativeSocketSession	instanceVariableNames: ''socket readStream writeStream ''	classVariableNames: ''''	poolDictionaries: ''''	category: ''Database-PostgreSQL-Compatibility''!!NativeSocketSession methodsFor: ''testing'' stamp: ''BB 11/21/2002 17:07''!isActive	"^a Boolean 	I return true if I''m still actively connected, otherwise false."	^ self socket isConnected ! !!NativeSocketSession methodsFor: ''services'' stamp: ''BB 11/8/2002 21:14''!close	self socket closeAndDestroy! !!NativeSocketSession methodsFor: ''accessing'' stamp: ''BB 11/8/2002 21:06''!readStream	"^a NativeSocketSessionReadStream	I return the stream through which 	bytes may be read from my underlying socket."	readStream isNil ifTrue: [readStream _ NativeSocketSessionReadStream for: self].	^ readStream! !!NativeSocketSession methodsFor: ''accessing'' stamp: ''BB 11/8/2002 21:03''!socket	"^ self 	I return my underlying Socket."	^ socket! !!NativeSocketSession methodsFor: ''accessing'' stamp: ''BB 11/8/2002 21:11''!writeStream	"^a NativeSocketSessionWriteStream  	I return the stream through which bytes may be written from my 	underlying socket."	writeStream isNil ifTrue: [writeStream _ NativeSocketSessionWriteStream for: self].	^ writeStream! !!NativeSocketSession methodsFor: ''initialise-release'' stamp: ''BB 11/8/2002 20:36''!openOnHost: hostName port: portNumber 	"^a NativeSocketSession  	I initialize myself as a session on a socket connected to portNumber  	on hostName."	| hostAddress |	Socket initializeNetwork.	socket _ Socket newTCP.	hostAddress _ NetNameResolver addressForName: hostName.	socket connectTo: hostAddress port: portNumber.	socket waitForConnectionUntil: Socket standardDeadline.	^self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!NativeSocketSession class	instanceVariableNames: ''''!!NativeSocketSession class methodsFor: ''instance creation'' stamp: ''BB 11/7/2002 12:32''!openOnHost: hostName port: portNumber 	"^a NativeSocketSession 	I return a new instance of myself which represents a session on a 	socket."	^self new openOnHost: hostName port: portNumber! !Object subclass: #NativeSocketSessionStream	instanceVariableNames: ''socketSession ''	classVariableNames: ''''	poolDictionaries: ''''	category: ''Database-PostgreSQL-Compatibility''!!NativeSocketSessionStream methodsFor: ''services'' stamp: ''BB 11/8/2002 21:37''!binary	"^selfI set myself to be a binary stream. As this seems to be the default 	for GemStone sockets, this is a no-op here."	^ self! !!NativeSocketSessionStream methodsFor: ''initialize-release'' stamp: ''BB 11/8/2002 21:36''!for: aNativeSocketSession 	"^a NativeSocketSessionStream 	I return a new instance of myself which will be a read or write stream 	dedicated to aSocketSession."	socketSession _ aNativeSocketSession! !!NativeSocketSessionStream methodsFor: ''accessing'' stamp: ''BB 11/8/2002 21:33''!socketSession	"^a NativeSocketSession 	I return the socket session for which I am a stream."	^ socketSession! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!NativeSocketSessionStream class	instanceVariableNames: ''''!!NativeSocketSessionStream class methodsFor: ''instance creation'' stamp: ''BB 11/8/2002 21:26''!for: aSocketSession 	"^a NativeSocketSessionStream 	I return a new instance of myself which will be a read or write stream 	dedicated to aSocketSession."	^ self new for: aSocketSession! !NativeSocketSessionStream subclass: #NativeSocketSessionReadStream	instanceVariableNames: ''readBuffer bufferStream ''	classVariableNames: ''''	poolDictionaries: ''''	category: ''Database-PostgreSQL-Compatibility''!!NativeSocketSessionReadStream methodsFor: ''accessing'' stamp: ''BB 11/21/2002 16:59''!next	"^a Byte 	I read the next byte from my underlying socket. The bytes 	are buffered in my readBuffer."	|  socket numberOfBytesRead |	(bufferStream isNil or: [bufferStream atEnd])		ifTrue: [socket _ self socketSession socket.			socket waitForDataUntil: (Socket deadlineSecs: 10).			numberOfBytesRead _ socket receiveDataInto: self readBuffer.			bufferStream _ ReadStream						on: self readBuffer						from: 1						to: numberOfBytesRead].	^ bufferStream next! !!NativeSocketSessionReadStream methodsFor: ''accessing'' stamp: ''BB 11/21/2002 16:34''!next: requestedNumberOfBytes 	"^a ByteArray	I read the next anInteger bytes from my underlying socket."	| bytes |	bytes _ ByteArray new: requestedNumberOfBytes.	1 to: requestedNumberOfBytes do: [:byteIndex|		bytes at: byteIndex put: self next].	^ bytes! !!NativeSocketSessionReadStream methodsFor: ''accessing'' stamp: ''BB 11/21/2002 15:56''!upTo: anObject 	"^a ByteArray 	I return a ByteArray which contains the contents of my underlying 	socket from the current position up to the occurance of anObject. I do 	not include the instance of anObject in the returned ByteArray."	| targetStream element |	targetStream _ WriteStream on: (ByteArray new: 64).	[element _ (self next: 1) first.	element == anObject]		whileFalse: [targetStream nextPut: element].	^ targetStream contents! !!NativeSocketSessionReadStream methodsFor: ''private'' stamp: ''BB 11/21/2002 17:03''!readBuffer	"^a ByteArray	I return the ByteArray which will be re-used as the target for	bytes being read from the underlying socket."	readBuffer isNil ifTrue: [readBuffer := ByteArray new: 512].	^readBuffer! !NativeSocketSessionStream subclass: #NativeSocketSessionWriteStream	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	category: ''Database-PostgreSQL-Compatibility''!!NativeSocketSessionWriteStream methodsFor: ''services'' stamp: ''BB 11/8/2002 21:48''!flush	"^selfI ensure that all the bytes written to me so far really have been 	physically written.This seems to be a no-op with GsSocket."	^ self! !!NativeSocketSessionWriteStream methodsFor: ''services'' stamp: ''BB 11/8/2002 21:55''!nextPutAll: aByteArray 	"^self  	I write the bytes in aByteArray to the socket of my socket session."	self socketSession socket sendData: aByteArray.	^self! !Object subclass: #NativeWeakArray	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	category: ''Database-PostgreSQL-Compatibility''!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!NativeWeakArray class	instanceVariableNames: ''''!!NativeWeakArray class methodsFor: ''as yet unclassified'' stamp: ''BB 11/6/2002 08:29''!new: anInteger 	"^a WeakArray 	I don''t return an instance of myself, I return a real WeakArray."	^WeakArray new: anInteger! !!NativeWeakArray class methodsFor: ''as yet unclassified'' stamp: ''BB 11/8/2002 22:00''!withAll: aCollection 	"^a WeakArray 	I don''t return an instance of myself at all. I return a real Weak array."	^WeakArray withAll: aCollection asArray! !'</body></methods><methods><class-id>NativeCodeForGemStone class</class-id> <category>code strings</category><body package="PostgreSQLVWCompatibility">allClasses"^a StringI return the string which is the source code for the GemStone compatibility classes.""(Filename named: 'gemstone-compatibility.gs') writeStream nextPutAll: self allClasses; close"^'!! From ! GEMSTONE: 5.1.4, Wed Feb 17 15:03:33 1999; IMAGE: GemStone v5.1 kernel classes filein completed at 17/02/1999 15:18:15! GemStone v5.1 kernel classes filein of stripped sources completed at 17/02/1999 15:40:57! ! On October 13, 2002, 3:42:48 am!!! SymbolDictionary ''PostgreSQL_Compatibility''!run| symList newDict |symList := System myUserProfile symbolList.symList do: [ :element |    (element includesKey: #PostgreSQL_Compatibility)        ifTrue: [ ^element ]].newDict := SymbolDictionary new.newDict at: #PostgreSQL_Compatibility put: newDict.System myUserProfile insertDictionary: newDict at: 1.^newDict%doit(Object subclass: ''NativeEnvironment''  instVarNames: #()  classVars: #( SignalDictionary)  classInstVars: #()  poolDictionaries: #[]  inDictionary: PostgreSQL_Compatibility  constraints: #[]  instancesInvariant: false  isModifiable: true).%doit(Object subclass: ''NativeError''  instVarNames: #( arguments)  classVars: #( Exceptions SignalDictionary)  classInstVars: #()  poolDictionaries: #[]  inDictionary: PostgreSQL_Compatibility  constraints: #[]  instancesInvariant: false  isModifiable: true).%doit(NativeError subclass: ''NativeAnyGemStoneError''  instVarNames: #()  classVars: #()  classInstVars: #()  poolDictionaries: #[]  inDictionary: PostgreSQL_Compatibility  constraints: #[]  instancesInvariant: false  isModifiable: true).%doit(NativeError subclass: ''StreamError''  instVarNames: #()  classVars: #()  classInstVars: #()  poolDictionaries: #[]  inDictionary: PostgreSQL_Compatibility  constraints: #[]  instancesInvariant: false  isModifiable: true).%doit(Object subclass: ''NativeExceptionContext''  instVarNames: #()  classVars: #()  classInstVars: #()  poolDictionaries: #[]  inDictionary: PostgreSQL_Compatibility  constraints: #[]  instancesInvariant: false  isModifiable: true).%doit(Object subclass: ''NativeSocketSession''  instVarNames: #( gsSocket readStream writeStream)  classVars: #()  classInstVars: #()  poolDictionaries: #[]  inDictionary: PostgreSQL_Compatibility  constraints: #[]  instancesInvariant: false  isModifiable: true).%doit(Object subclass: ''NativeSocketSessionStream''  instVarNames: #( socketSession)  classVars: #()  classInstVars: #()  poolDictionaries: #[]  inDictionary: PostgreSQL_Compatibility  constraints: #[]  instancesInvariant: false  isModifiable: true).%doit(NativeSocketSessionStream subclass: ''NativeSocketSessionReadStream''  instVarNames: #()  classVars: #()  classInstVars: #()  poolDictionaries: #[]  inDictionary: PostgreSQL_Compatibility  constraints: #[]  instancesInvariant: false  isModifiable: true).%doit(NativeSocketSessionStream subclass: ''NativeSocketSessionWriteStream''  instVarNames: #()  classVars: #()  classInstVars: #()  poolDictionaries: #[]  inDictionary: PostgreSQL_Compatibility  constraints: #[]  instancesInvariant: false  isModifiable: true).%doit(Object subclass: ''NativeTimestamp''  instVarNames: #( timestamp)  classVars: #()  classInstVars: #()  poolDictionaries: #[]  inDictionary: PostgreSQL_Compatibility  constraints: #[]  instancesInvariant: false  isModifiable: true).%doit(Object subclass: ''NativeWeakArray''  instVarNames: #()  classVars: #()  classInstVars: #()  poolDictionaries: #[]  inDictionary: PostgreSQL_Compatibility  constraints: #[]  instancesInvariant: false  isModifiable: true).%doitNativeEnvironment immediateInvariant.%doitNativeError immediateInvariant.%doitNativeAnyGemStoneError immediateInvariant.%doitStreamError immediateInvariant.%doitNativeExceptionContext immediateInvariant.%doitNativeSocketSession immediateInvariant.%doitNativeSocketSessionStream immediateInvariant.%doitNativeSocketSessionReadStream immediateInvariant.%doitNativeSocketSessionWriteStream immediateInvariant.%doitNativeTimestamp immediateInvariant.%doitNativeWeakArray immediateInvariant.%! Remove existing behavior from NativeEnvironmentdoitNativeEnvironment removeAllMethods.NativeEnvironment class removeAllMethods.%! ------------------- Class methods for NativeEnvironmentcategory: ''testing''classmethod: NativeEnvironmentisGemStone	^true%category: ''testing''classmethod: NativeEnvironmentisVisualWorks	^false%! ------------------- Instance methods for NativeEnvironment! Remove existing behavior from NativeErrordoitNativeError removeAllMethods.NativeError class removeAllMethods.%! ------------------- Class methods for NativeErrorcategory: ''accessing''classmethod: NativeErrorexceptionCategory"^a LanguageDictionaryI return the LanguageDictionary which defines the category of exception I represent.  This is *yet another* layer in the GemStone exception indirection game.  By default all my suclasses have a nil category."^nil%category: ''accessing''classmethod: NativeErrorexceptions"^an OrderedCollectionI return an ordered collection of exceptiosn.  This is the definitive collection of exceptions.  The position of an exception in this collection determines it''s signal number.  This technique saves me from having to statically allocate signal numbers to exception classes."Exceptions isNil ifTrue: [Exceptions := OrderedCollection new].^Exceptions%category: ''accessing''classmethod: NativeErrorsignalDictionary"^a signal dictionaryI return the default signal dictionary for my subclasses.  This may be overriden if necessary."	SignalDictionary isNil ifTrue: [SignalDictionary := self initializedSignalDictionary].	^SignalDictionary%category: ''accessing''classmethod: NativeErrorsignalNumber"^an IntegerEvery exception has a signal number.  I have avoided statically allocating these, and assign them as needed, so the signal number for an exception is just the positon it appears in my collection of exceptions, which is in turn the order in which the exceptions have been raised."	^self exceptions indexOf: self ifAbsent:		[self ensurePresenceInSignalDictionary.			self signalNumber]%category: ''private-initialization''classmethod: NativeErrorensurePresenceInSignalDictionary"^selfI make sure that there is an entry for me in the signals dictionary.  If there isn''t, I create one.  First I make an entry in the exceptions collection as this gives me an error number - with this I can make the correct entry in the signal dictionary."|messages|(self exceptions includesIdentical: self) ifTrue: [^self].self exceptions add: self.messages := (self signalDictionary at: #English) asOrderedCollection.messages add: self messageSpecification.self signalDictionary at: #English put: messages asArray.^self%category: ''private-initialization''classmethod: NativeErrorinitializedSignalDictionary"^a SymbolDictionaryI make an initialized signal dictionary for my subclasses.  For now, I only add English messages."|signalDictionary|signalDictionary := SymbolDictionary new.signalDictionary at: #English put: (Array new).^signalDictionary%category: ''private-initialization''classmethod: NativeErrormessageSpecification"^an ArrayI return the message my specification specification.  By default this is #(1) which means that when raised I have a single argument.   My subclasses may override this. "^#(1)%category: ''raising''classmethod: NativeErrorraiseSignal: aString"^a NativeErrorI raise an exception.  Here in GemStone (until ANSI exceptions) we have to signal exceptions using System&gt;&gt;signal ..."	self ensurePresenceInSignalDictionary.	^System		signal: self signalNumber		args: (Array with: aString)		signalDictionary: self signalDictionary%! ------------------- Instance methods for NativeErrorcategory: ''accessing''method: NativeErrorarguments"^an ArrayI return the arguments for the exception I represent."	arguments isNil ifTrue: [arguments := Array new].	^arguments%category: ''accessing''method: NativeErrorarguments: anArray"^selfI should record the arguments here, just in case"	arguments := anArray.	^self%category: ''accessing''method: NativeErrorexceptionCategory^self class exceptionCategory%category: ''accessing''method: NativeErrorhandler: aHandler"^selfI should record the handler here, just in case"	^self%category: ''accessing''method: NativeErrormessageText	"^a String 	I return the text of the error message."	self arguments size &gt; 0		ifTrue: [self arguments size &gt; 1				ifTrue: [^self arguments at: 2]				ifFalse: [^self arguments at: 1]]		ifFalse: [^String new]%category: ''accessing''method: NativeErrorsignalNumber^self class signalNumber%category: ''license''method: NativeErrorlicense	"^a License 	This software is licenced under the LGPL."	^nil%category: ''services''method: NativeErrorresume"^selfThis has no meaning with GemStone exceptions.  I just return myself."	^self%category: ''testing''method: NativeErrorisNoticeResponse	"^a Boolean 	I return true if I am a notice response, otherwise, I return false. By default, I return false."	^false%! Remove existing behavior from NativeAnyGemStoneErrordoitNativeAnyGemStoneError removeAllMethods.NativeAnyGemStoneError class removeAllMethods.%! ------------------- Class methods for NativeAnyGemStoneErrorcategory: ''accessing''classmethod: NativeAnyGemStoneErrorsignalNumber"^an IntegerI return my unique GemStone signal number."	^nil%! ------------------- Instance methods for NativeAnyGemStoneError! Remove existing behavior from StreamErrordoitStreamError removeAllMethods.StreamError class removeAllMethods.%! ------------------- Class methods for StreamErrorcategory: ''accessing''classmethod: StreamErrorsignalNumber"^an IntegerI return my unique GemStone signal number."	^5%! ------------------- Instance methods for StreamError! Remove existing behavior from NativeExceptionContextdoitNativeExceptionContext removeAllMethods.NativeExceptionContext class removeAllMethods.%! ------------------- Class methods for NativeExceptionContextcategory: ''initialization''classmethod: NativeExceptionContextinitializeSignalDictionary|englishMessages errors|englishMessages := Array new: 10.englishMessages at: 1 put: #(''Eeek!'').errors := SymbolDictionary new.errors at: #English put: englishMessages.System signal: 1 args: #() signalDictionary: errors.^self%category: ''instance creation''classmethod: NativeExceptionContextfor: aBlock on: anExceptionClass do: exceptionBlock"^an ObjectI return the result of evaluating aBlock. In GemStone, an ''Exception'' is the handler of exceptions"Exception	category:	anExceptionClass exceptionCategory			number:		anExceptionClass signalNumber			do:			[:exceptionHandler :category :signalNumber :exceptionArguments | |anException|							anException := anExceptionClass new.							anException handler: exceptionHandler.							anException arguments: exceptionArguments.							exceptionBlock value: anException].^aBlock value%category: ''native exceptions''classmethod: NativeExceptionContextbrokenPipeException	"I return the exception that get''s thrown when a socket connection gets 	broken. This is used in PostgreSQLConnection&gt;&gt;close."	^NativeAnyGemStoneError%! ------------------- Instance methods for NativeExceptionContext! Remove existing behavior from NativeSocketSessiondoitNativeSocketSession removeAllMethods.NativeSocketSession class removeAllMethods.%! ------------------- Class methods for NativeSocketSessioncategory: ''instance creation''classmethod: NativeSocketSessionopenOnHost: hostName port: portNumber"^a NativeSocketSessionI return a new instance of myself which represents a session on a socket."	^self new openOnHost: hostName port: portNumber%! ------------------- Instance methods for NativeSocketSessioncategory: ''accessing''method: NativeSocketSessiongsSocket"^a GsSocketI return my underlying GsSocket."	^gsSocket%category: ''accessing''method: NativeSocketSessionreadStream"^a NativeSocketSessionReadStreamI return the stream through which bytes may be read from my underlying socket."	readStream isNil ifTrue: [readStream := NativeSocketSessionReadStream for: self].	^readStream%category: ''accessing''method: NativeSocketSessionwriteStream"^a NativeSocketSessionWriteStreamI return the stream through which bytes may be written from my underlying socket."	writeStream isNil ifTrue: [writeStream := NativeSocketSessionWriteStream for: self].	^writeStream%category: ''initialize-release''method: NativeSocketSessionopenOnHost: hostName port: portNumber"^a NativeSocketSessionI initialize myself as a session on a socket connected to portNumber on hostName."gsSocket := GsSocket new.self gsSocket connectTo: 5432 on: ''localhost'' .^self%category: ''services''method: NativeSocketSessionclose	self gsSocket close%category: ''testing''method: NativeSocketSessionisActive"^a BooleanI return true if I''m still actively connected, otherwise false."^self gsSocket isActive%! Remove existing behavior from NativeSocketSessionStreamdoitNativeSocketSessionStream removeAllMethods.NativeSocketSessionStream class removeAllMethods.%! ------------------- Class methods for NativeSocketSessionStreamcategory: ''instance creation''classmethod: NativeSocketSessionStreamfor: aSocketSession"^a NativeSocketSessionStreamI return a new instance of myself which will be a read or write stream dedicated to aSocketSession."	^self new for: aSocketSession%! ------------------- Instance methods for NativeSocketSessionStreamcategory: ''accessing''method: NativeSocketSessionStreamsocketSession"^a SocketSessionI return the socket session for which I am a stream."	^socketSession%category: ''initialize-release''method: NativeSocketSessionStreamfor: aSocketSession"^a NativeSocketSessionStreamI return a new instance of myself which will be a read or write stream dedicated to aSocketSession."	socketSession := aSocketSession.	^self%category: ''services''method: NativeSocketSessionStreambinary"^selfI set myself to be a binary stream.  As this seems to be the default for GemStone sockets, this is a no-op here."	^self%! Remove existing behavior from NativeSocketSessionReadStreamdoitNativeSocketSessionReadStream removeAllMethods.NativeSocketSessionReadStream class removeAllMethods.%! ------------------- Class methods for NativeSocketSessionReadStream! ------------------- Instance methods for NativeSocketSessionReadStreamcategory: ''accessing''method: NativeSocketSessionReadStreamnext: anInteger"^a ByteArrayI read the next anInteger bytes from my underlying socket.Fixed by Steve Wart to work under Windows where there were issues with the GemStone socket not getting the requested number of bytes in the first call.  See the comment in GsSocket&gt;&gt;readString: for details."| bytes|bytes := ByteArray new.[bytes size &lt; anInteger]whileTrue: [bytes addAll: (self socketSession gsSocket read: (anInteger-bytes size)) asByteArray].^bytes%category: ''accessing''method: NativeSocketSessionReadStreamupTo: anObject"^a ByteArrayI return a ByteArray which contains the contents of my underlying socket from the current position up to the for occurance of anObject.  I do not include the instance of anObject in the returned ByteArray."	| targetStream element |	targetStream := WriteStream on: (ByteArray new: 64).	[element := (self next: 1) first.	element == anObject]		whileFalse: [targetStream nextPut: element].	^targetStream contents%! Remove existing behavior from NativeSocketSessionWriteStreamdoitNativeSocketSessionWriteStream removeAllMethods.NativeSocketSessionWriteStream class removeAllMethods.%! ------------------- Class methods for NativeSocketSessionWriteStream! ------------------- Instance methods for NativeSocketSessionWriteStreamcategory: ''services''method: NativeSocketSessionWriteStreamflush"^selfI ensure that all the bytes written to me so far really have been physically written.This seems to be a no-op with GsSocket."	^self%category: ''services''method: NativeSocketSessionWriteStreamnextPutAll: aByteArray"^selfI write the bytes in aByteArray to the socket of my socket session."	self socketSession gsSocket writeWillNotBlock		ifTrue: [self socketSession gsSocket write: aByteArray].	^self%! Remove existing behavior from NativeTimestampdoitNativeTimestamp removeAllMethods.NativeTimestamp class removeAllMethods.%! ------------------- Class methods for NativeTimestampcategory: ''instance creation''classmethod: NativeTimestampnow^self new on: Time now%! ------------------- Instance methods for NativeTimestampcategory: ''accessing''method: NativeTimestamptimestamp	"^a Timestamp 	I return my underlying timestamp."	^timestamp%category: ''initialize-release''method: NativeTimestampon: aTimestamp 	"^self"	timestamp := aTimestamp.	^self%category: ''printing''method: NativeTimestampprintOn: aStream 	"^self 	I delegate this to my underlying timestamp."	self timestamp printOn: aStream.	^self%! Remove existing behavior from NativeWeakArraydoitNativeWeakArray removeAllMethods.NativeWeakArray class removeAllMethods.%! ------------------- Class methods for NativeWeakArraycategory: ''instance creation''classmethod: NativeWeakArraynew: anInteger 	"^a WeakArray 	I don''t return an instance of myself, I return an Array -  until I can think of a better GemStone alternative."	^Array new: anInteger%category: ''instance creation''classmethod: NativeWeakArraywithAll: aCollection 	"^a WeakArray 	I don''t return an instance of myself at all. I return an Array -  until I can think of a better GemStone alternative."	^Array withAll: aCollection%! ------------------- Instance methods for NativeWeakArray'</body></methods><methods><class-id>NativeEnvironment class</class-id> <category>testing</category><body package="PostgreSQLVWCompatibility">isGemStone	^false</body><body package="PostgreSQLVWCompatibility">isVisualWorks	^true</body></methods><methods><class-id>NativeMD5Digest class</class-id> <category>encoding</category><body package="PostgreSQLVWCompatibility">byteHash: bytes 	"^a ByteArray	Just return the digest for bytes by delegating to  the MD5 class."	^self currentMD5Class byteHash: bytes</body><body package="PostgreSQLVWCompatibility">currentMD5Class	"^a Class	Return the MD5 class to be used in this environment.  The MD5 class was moved ."	"NativeMD5Digest currentMD5Class"	currentMD5Class isNil 		ifTrue: 			[currentMD5Class := 'Security.MD5' asQualifiedReference 						ifDefinedDo: [:theClass | theClass]						elseDo: ['Net.MD5' asQualifiedReference value]].	^currentMD5Class</body></methods><methods><class-id>NativeSocketSession</class-id> <category>services</category><body package="PostgreSQLVWCompatibility">close	self externalConnection close.	^self</body></methods><methods><class-id>NativeSocketSession</class-id> <category>accessing</category><body package="PostgreSQLVWCompatibility">externalConnection	"^an ExternalConnection 	I return an external connection. This represents the connection to 	the back end, and makes two streams available, one for reading 	from the back end, and one for writing to the back end. Both streams 	must be set to operate in binary mode"	^externalConnection</body><body package="PostgreSQLVWCompatibility">readStream	"^a ReadStream 	I return the stream through which bytes may be read from my 	underlying socket."	^self externalConnection readStream</body><body package="PostgreSQLVWCompatibility">writeStream	"^a WriteStream	I return the stream through which bytes may be read from my 	underlying socket."	^self externalConnection writeStream</body></methods><methods><class-id>NativeSocketSession</class-id> <category>testing</category><body package="PostgreSQLVWCompatibility">isActive	"^a Boolean 	I return true if I'm still actively connected, otherwise false."	^self externalConnection isActive</body></methods><methods><class-id>NativeSocketSession</class-id> <category>initialize-release</category><body package="PostgreSQLVWCompatibility">openOnHost: hostName port: portNumber 	"^a NativeSocketSession 	I initialize myself as a session on a socket connected to portNumber 	on hostName."	| socket |	socket := SocketAccessor newTCPclientToHost: hostName port: portNumber.	externalConnection := ExternalConnection ioAccessor: socket.	^self</body></methods><methods><class-id>NativeSocketSession class</class-id> <category>instance creation</category><body package="PostgreSQLVWCompatibility">openOnHost: hostName port: portNumber 	"^a NativeSocketSession 	I return a new instance of myself which represents a session on a 	socket."	^self new openOnHost: hostName port: portNumber</body></methods><methods><class-id>NativeWeakArray class</class-id> <category>instanceCreation</category><body package="PostgreSQLVWCompatibility">new: anInteger 	"^a WeakArray 	I don't return an instance of myself, I return a real WeakArray."	^WeakArray new: anInteger</body><body package="PostgreSQLVWCompatibility">withAll: aCollection 	"^a WeakArray 	I don't return an instance of myself at all. I return a real Weak array."	^WeakArray withAll: aCollection</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>