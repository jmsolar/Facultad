<?xml version="1.0"?><st-source><!-- Name: Base64EncodingComment: ©Bruce Badger 2000 - 2004. Licensed under the LGPL.This package implements Base64 Encode as defined in RFC 1341.  See the class methods of Base64EncodingStreamTest for tests and examples.The following excerpt from RFC 1341 defines Base64 encoding.5.2 Base64 Content-Transfer-EncodingThe Base64 Content-Transfer-Encoding is designed to represent arbitrary sequences of octets in a form that is not humanly readable. The encoding and decoding algorithms are simple, but the encoded data are consistently only about 33 percent larger than the unencoded data. This encoding is based on the one used in Privacy Enhanced Mail applications, as defined in RFC 1113. The base64 encoding is adapted from RFC 1113, with one change: base64 eliminates the "*" mechanism for embedded clear text.A 65-character subset of US-ASCII is used, enabling 6 bits to be represented per printable character. (The extra 65th character, "=", is used to signify a special processing function.)NOTE: This subset has the important property that it is represented identically in all versions of ISO 646, including US ASCII, and all characters in the subset are also represented identically in all versions of EBCDIC. Other popular encodings, such as the encoding used by the UUENCODE utility and the base85 encoding specified as part of Level 2 PostScript, do not share these properties, and thus do not fulfill the portability requirements a binary transport encoding for mail must meet.The encoding process represents 24-bit groups of input bits as output strings of 4 encoded characters. Proceeding from left to right, a 24-bit input group is formed by concatenating 3 8-bit input groups. These 24 bits are then treated as 4 concatenated 6-bit groups, each of which is translated into a single digit in the base64 alphabet. When encoding a bit stream via the base64 encoding, the bit stream must be presumed to be ordered with the most- significant-bit first. That is, the first bit in the stream will be the high-order bit in the first byte, and the eighth bit will be the low-order bit in the first byte, and so on.Each 6-bit group is used as an index into an array of 64 printable characters. The character referenced by the index is placed in the output string. These characters, identified in Table 1, below, are selected so as to be universally representable, and the set excludes characters with particular significance to SMTP (e.g., ".", "CR", "LF") and to the encapsulation boundaries defined in this document (e.g., "-").Table 1: The Base64 Alphabet Value Encoding Value Encoding Value Encoding Value Encoding0 A 	17 R 	34 i 	51 z1 B 		18 S 	35 j 	52 02 C 	19 T 	36 k 	53 13 D 	20 U 	37 l 	54 24 E 		21 V 	38 m 	55 35 F 		22 W 	39 n 	56 46 G 	23 X 	40 o 	57 57 H 	24 Y 	41 p 	58 68 I 		25 Z 	42 q 	59 79 J 		26 a 	43 r 	60 810 K 	27 b 	44 s 	61 911 L 	28 c 	45 t 	62 +12 M 	29 d 	46 u 	63 /13 N 	30 e 	47 v14 O 	31 f 	48 w 	(pad) =15 P 	32 g 	49 x16 Q 	33 h 	50 yThe output stream (encoded bytes) must be represented in lines of no more than 76 characters each. All line breaks or other characters not found in Table 1 must be ignored by decoding software. In base64 data, characters other than those in Table 1, line breaks, and other white space probably indicate a transmission error, about which a warning message or even a message rejection might be appropriate under some circumstances.Special processing is performed if fewer than 24 bits are available at the end of the data being encoded. A full encoding quantum is always completed at the end of a body. When fewer than 24 input bits are available in an input group, zero bits are added (on the right) to form an integral number of 6-bit groups. Output character positions which are not required to represent actual input data are set to the character "=". Since all base64 input is an integral number of octets, only the following cases can arise: (1) the final quantum of encoding input is an integral multiple of 24 bits; here, the final unit of encoded output will be an integral multiple of 4 characters with no "=" padding, (2) the final quantum of encoding input is exactly 8 bits; here, the final unit of encoded output will be two characters followed by two "=" padding characters, or (3) the final quantum of encoding input is exactly 16 bits; here, the final unit of encoded output will be three characters followed by one "=" padding character.Care must be taken to use the proper octets for line breaks if base64 encoding is applied directly to text material that has not been converted to canonical form. In particular, text line breaks should be converted into CRLF sequences prior to base64 encoding. The important thing to note is that this may be done directly by the encoder rather than in a prior canonicalization step in some implementations.NOTE: There is no need to worry about quoting apparent encapsulation boundaries within base64-encoded parts of multipart entities because no hyphen characters are used in the base64 encoding.- - Please send your comments to bbadger@openskills.com.  Thanks.DbIdentifier: OSSYD001DbTrace: 2208HideSource: falsePackageName: Base64EncodingParcel: #('Base64Encoding')PrintStringCache: (1.3 014,bbadger)SaveSource: trueVersion: 1.3 014Date: 8:03:22 pm November 4, 2004 --><time-stamp>From VisualWorks® NonCommercial, 7.2 of November 3, 2003 on November 4, 2004 at 8:03:22 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>Base64EncodingStreamTest</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Base64 Encoding</category><attributes><package>Base64Encoding</package></attributes></class><comment><class-id>Base64EncodingStreamTest</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:</body></comment><class><name>Base64EncodingStream</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>underlyingStream octetIndex octetArray </inst-vars><class-inst-vars>characterEncodingTable characterDecodingTable </class-inst-vars><imports></imports><category>Database-PostgreSQL-Base64 Encoding</category><attributes><package>Base64Encoding</package></attributes></class><comment><class-id>Base64EncodingStream</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	underlyingStream	&lt;ClassOfVariable&gt;	description of variable's function	octetIndex	&lt;ClassOfVariable&gt;	description of variable's function	octetArray	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>Base64EncodingWriteStream</name><environment>Smalltalk</environment><super>Base64EncodingStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>linePosition lineBreaksEnabled </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Base64 Encoding</category><attributes><package>Base64Encoding</package></attributes></class><comment><class-id>Base64EncodingWriteStream</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	linePosition	&lt;ClassOfVariable&gt;	description of variable's function	lineBreaksEnabled	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><class><name>Base64EncodingReadStream</name><environment>Smalltalk</environment><super>Base64EncodingStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nextOctetArray </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-Base64 Encoding</category><attributes><package>Base64Encoding</package></attributes></class><comment><class-id>Base64EncodingReadStream</class-id><body>Copyright © 2000  Bruce Badger. All Rights Reserved.Instance Variables:	nextOctetArray	&lt;ClassOfVariable&gt;	description of variable's function</body></comment><methods><class-id>Base64EncodingStreamTest class</class-id> <category>testing</category><body package="Base64Encoding">test	"^self 	I just run through all my tests."	"self test"	self test01.	self test02.	self test03.	self test04.	^self</body><body package="Base64Encoding">test01	"^self 	I create a byte array with every possible byte value and then write that to a String through a 	Base64EncodingWriteStream."	"self test01"	| sourceBytes writeStream resultingString expectedResult |	sourceBytes := ByteArray withAll: (0 to: 255).	writeStream := Base64EncodingWriteStream on: String new.	writeStream nextPutAll: sourceBytes.	writeStream close.	resultingString := writeStream contents.	expectedResult := (ByteArray fromPackedString: 'PTEEP4E7TTYBY6MIP5E/SDQALD=D^DERQV!MUTYRVU!GP&amp;-!Q7!7YD!(NF]IT4%*R$MU[T)9Y7AKZWM3SEL4]$5DQW%M^%D1S&amp;)#M@4JS5Q/M5ADLB-PLDIBTV-NQUIUV$!SQV1KT3A8S%Q+NUEUU$)TU$YVU5X1ZE)W[GQ#VEX5Y%%GQ&amp;%YL%I,V&amp;5$[6EW\GI"Q3E5X#MB^@4JX69NLFQXV#M%RF06YSM8NVY.J4E''VT-DZD%WQ6 4ZT))[7UMZ%$6TF-JQ5M+MUMV[GA%VV5Z\VI.R#I%[#YCZF=1S6-0XVE.\T--\P4J\SY9]GI1J7]3X$-:]D1WL''P7ZSU5\''T8]&amp;H6K7]MRDM7NEQF^GM&amp;RW%#\$1:SSMO^#%DT#A4TET1YFIXL$9.XSH9^&amp;P3]B=''MFULZ 4JMT=X[ST+Z''@6]WY3M6T7]#!PRG$8K5P1NWY&amp;MB-&amp;\#\/TCL+K7\=OP@a') asString.	resultingString = expectedResult ifFalse: [Error raiseSignal: 'test01 failed'].	^self</body><body package="Base64Encoding">test02	"^self 	I create a byte array with every possible byte value and then write that to a String through a 	Base64EncodingWriteStream. Then I read it back through a Base64EncodingReadStream"	"self test02"	| sourceBytes writeStream encodedString readStream decodedString |	sourceBytes := ByteArray withAll: (0 to: 255).	writeStream := Base64EncodingWriteStream on: String new.	writeStream nextPutAll: sourceBytes.	writeStream close.	encodedString := writeStream contents.	readStream := Base64EncodingReadStream on: encodedString.	decodedString := readStream upToEnd.	decodedString = sourceBytes ifFalse: [Error raiseSignal: 'test02 failed'].	^self</body><body package="Base64Encoding">test03	"^self 	I encode the byte array without line breaks, then I decode it."	"self test03"	| sourceBytes writeStream encodedString readStream decodedString |	sourceBytes := ByteArray withAll: (0 to: 255).	writeStream := Base64EncodingWriteStream on: String new.	writeStream disableLineBreaks.	writeStream nextPutAll: sourceBytes.	writeStream close.	encodedString := writeStream contents.	readStream := Base64EncodingReadStream on: encodedString.	decodedString := readStream upToEnd.	decodedString = sourceBytes ifFalse: [Error raiseSignal: 'test03 failed'].	^self</body><body package="Base64Encoding">test04	"^self 	I encode and decode byte arrays of varying lengths to check boundary conditions."	"self test04"	| sourceBytes writeStream encodedString readStream decodedString |	0 to: 255		do: 			[:endByte | 			sourceBytes := ByteArray withAll: (0 to: endByte).			writeStream := Base64EncodingWriteStream on: String new.			writeStream disableLineBreaks.			writeStream nextPutAll: sourceBytes.			writeStream close.			encodedString := writeStream contents.			readStream := Base64EncodingReadStream on: encodedString.			decodedString := readStream upToEnd.			decodedString = sourceBytes ifFalse: [Error raiseSignal: 'test04 failed']].	^self</body></methods><methods><class-id>Base64EncodingStream</class-id> <category>private</category><body package="Base64Encoding">characterDecodingTable	"^an Array 	I return the table I use the decode. c.f self class&gt;&gt;characterDecodingTable."	^self class characterDecodingTable</body><body package="Base64Encoding">characterEncodingTable	"^an Array 	I return the array of character encodings. c.f self class&gt;&gt;characterEncodingTable."	^self class characterEncodingTable</body><body package="Base64Encoding">octetArray	"^an Array 	I return the Array which will hold the sets of three octets that are processed into 4 output characters, or vica-versa. 	I laziliy initialize this to an Array of size 3."	octetArray isNil ifTrue: [octetArray := Array new: 3].	^octetArray</body><body package="Base64Encoding">octetIndex	"^an Integer 	I return the index that will be assigned to the next octed (byte) that is written to me. For every three 	octets I read/write, I read/write four characters. I lazily initialize to 1, since the first byte read/written will be the first octet of the first trio."	octetIndex isNil ifTrue: [octetIndex := 1].	^octetIndex</body><body package="Base64Encoding">octetIndex: anInteger 	"^self 	I record the index that will be assigned to the next octed (byte) that is read/written to me. c.f. 	self&gt;&gt;octetIndex"	octetIndex := anInteger.	^self</body><body package="Base64Encoding">underlyingStream	"^a Stream 	I return my underlying stream.  This is the stream of encoded data."	^underlyingStream</body><body package="Base64Encoding">underlyingStream: aStream 	"^self 	I record my underlying stream. c.f. self&gt;&gt;underlyingStream."	underlyingStream := aStream.	^self</body></methods><methods><class-id>Base64EncodingStream</class-id> <category>initialize-release</category><body package="Base64Encoding">onStream: aStream 	"^self 	I initialize myself to emit encoded data to aStream."	self underlyingStream: aStream.	^self</body></methods><methods><class-id>Base64EncodingStream class</class-id> <category>instanceCreation</category><body package="Base64Encoding">onStream: aStream 	"^a Base64EncodingStream 	I return a new instance of one of my subclasses that will either encoded or decode using the Base 64 scheme."	^self new onStream: aStream</body></methods><methods><class-id>Base64EncodingStream class</class-id> <category>private</category><body package="Base64Encoding">characterDecodingTable	"^an Array 	I return the table I use to decode. This is a sparsely populated table which enable the decoding 	algiorthm to use the integer value of an encoded charater as an index, with the value being the Base 	64 integer value of that character."	| characterValue |	characterDecodingTable isNil ifFalse: [^characterDecodingTable].	characterDecodingTable := Array new: 256.	1 to: self characterEncodingTable size		do: 			[:encodedValue | 			characterValue := (characterEncodingTable at: encodedValue) asInteger.			characterDecodingTable at: characterValue put: encodedValue - 1].	^characterDecodingTable</body><body package="Base64Encoding">characterEncodingTable	"^an Array 	I return the array of character encodings. This contains the characters A-Z, a-z, 0-9, + and / in 	positions 1 through to 64 repsctively."	characterEncodingTable notNil ifTrue: [^characterEncodingTable].	characterEncodingTable := OrderedCollection new.	characterEncodingTable addAll: (($A asInteger to: $Z asInteger) 				collect: [:anInteger | anInteger asCharacter]).	characterEncodingTable addAll: (($a asInteger to: $z asInteger) 				collect: [:anInteger | anInteger asCharacter]).	characterEncodingTable addAll: (($0 asInteger to: $9 asInteger) 				collect: [:anInteger | anInteger asCharacter]).	characterEncodingTable add: $+.	characterEncodingTable add: $/.	characterEncodingTable := characterEncodingTable asArray.	^characterEncodingTable</body></methods><methods><class-id>Base64EncodingWriteStream</class-id> <category>status</category><body package="Base64Encoding">close	"^self 	This closes the stream for further writing, and causes the last part of the encoding to occur. Before 	this happens, the written stream does not contain a valid Base 64 encoded string.	Checking that the underlying stream responds to &gt;&gt;close is important for GemStone as not all GemStone	streams respond to &gt;&gt;close, and the explicit test is different too (&gt;&gt;isExternal in GS, &gt;&gt;isExternalStream in VW)"	self emitClosingCharacters.	(self underlyingStream respondsTo: #close) 		ifTrue: [self underlyingStream close].	^self</body></methods><methods><class-id>Base64EncodingWriteStream</class-id> <category>accessing</category><body package="Base64Encoding">contents	"^a String 	I return the contects of my underlying stream. Note that this will only be a valid encoded string if 	&gt;&gt;close has already been sent to me."	^self underlyingStream contents</body><body package="Base64Encoding">disableLineBreaks	"^self 	I record the fact that line breaks are *not* to be generated."	self lineBreaksEnabled: false.	^self</body><body package="Base64Encoding">enableLineBreaks	"^self 	I record the fact that line breaks are to be generated."	self lineBreaksEnabled: true.	^self</body><body package="Base64Encoding">lineBreaksEnabled	"^a Boolean 	I return a boolean which indicate wether line breaks are to be generated after the 76th character of 	each line. I default to true because that's how it's supposed to be according to the book I read!"	lineBreaksEnabled isNil ifTrue: [self lineBreaksEnabled: true].	^lineBreaksEnabled</body><body package="Base64Encoding">nextPut: aByte 	"^a Byte 	I write the encoded form of aByte to my underlying stream. I do this in batches of three input bytes 	(octets)."	self octetArray at: self octetIndex put: aByte.	self octetIndex &gt;= 3		ifTrue: 			[self emitEncodedCharacters.			self octetIndex: 1]		ifFalse: [self octetIndex: self octetIndex + 1].	^aByte</body><body package="Base64Encoding">nextPutAll: aCollection 	"^a Collection 	I take each element of aCollection (assumed to be a collection of bytes) and 'write' it to my 	underlying stream after encoding it. I really just delegate this to self&gt;&gt;nextPut: one byte at a time."	aCollection do: [:aByte | self nextPut: aByte].	^aCollection</body></methods><methods><class-id>Base64EncodingWriteStream</class-id> <category>private - emitting</category><body package="Base64Encoding">emitClosingCharacters	"^self 	I write out the closing characters for this encoding. I must write out either zero or four characters as 	follows. If I am currently at the start of a new octet triplet, then I need take no action. All the bytes 	have been written out as characters. If one octet has been written to me, I must convert that (which 	will make two characters) and write out two $= characters to make up the four outgoing characters. If 	two octets have been written to me, I convert them and write out a single $= at the end."	self octetIndex = 1 ifTrue: [^self].	self octetIndex = 2 		ifTrue: 			[self octetArray at: 2 put: 0.			self emitEncodedCharacter1.			self emitEncodedCharacter2.			self underlyingStream nextPut: $=]		ifFalse: 			[self octetArray at: 3 put: 0.			self emitEncodedCharacter1.			self emitEncodedCharacter2.			self emitEncodedCharacter3].	self underlyingStream nextPut: $=.	^self</body><body package="Base64Encoding">emitCRLF	"^self 	I write the &lt;cr&gt; and &lt;lf&gt; characters to my underlying stream These mark the end of each 76 	character line."	self lineBreaksEnabled		ifTrue: 			[self underlyingStream nextPut: Character cr.			self underlyingStream nextPut: Character lf].	^self</body><body package="Base64Encoding">emitEncodedCharacter1	"^self 	I emit the first of the four character set based on the trio of input octets. I take the first six bits of 	the first octet and make that the value of the first character, which I write to my underlying stream."	| characterIndex |	characterIndex := ((self octetArray first)				bitAnd: 2r11111100)				bitShift: -2.	self underlyingStream nextPut: (self characterEncodingTable at: characterIndex + 1).	^self</body><body package="Base64Encoding">emitEncodedCharacter2	"^self 	I emit the second of the four character set based on the trio of input octets. I take the last two bits 	of the first octet and the first 4 bits of the second octet and make that the value of the second 	character, which I write to my underlying stream."	| characterIndex |	characterIndex := ((self octetArray first)				bitAnd: 2r00000011)				bitShift: 4.	characterIndex := characterIndex bitOr: (((self octetArray at: 2)					bitAnd: 2r11110000)					bitShift: -4).	self underlyingStream nextPut: (self characterEncodingTable at: characterIndex + 1).	^self</body><body package="Base64Encoding">emitEncodedCharacter3	"^self 	I emit the third of the four character set based on the trio of input octets. I take the last 4 bits of the 	second octet and the first 2 bits of the third octet and make that the value of the second character, 	which I write to my underlying stream."	| characterIndex |	characterIndex := ((self octetArray at: 2)				bitAnd: 2r00001111)				bitShift: 2.	characterIndex := characterIndex bitOr: (((self octetArray at: 3)					bitAnd: 2r11000000)					bitShift: -6).	self underlyingStream nextPut: (self characterEncodingTable at: characterIndex + 1).	^self</body><body package="Base64Encoding">emitEncodedCharacter4	"^self 	I emit the last of the four character set based on the trio of input octets. I take the last six bits of 	the third octet and make that the value of the first character, which I write to my underlying stream."	| characterIndex |	characterIndex := (self octetArray at: 3)				bitAnd: 2r00111111.	self underlyingStream nextPut: (self characterEncodingTable at: characterIndex + 1).	^self</body><body package="Base64Encoding">emitEncodedCharacters	"^self 	I write the three octets in my octetArray to my underlying stream as four characters. This is the 	business part of the encoding operation. I got the rules for doing this from page 52 of 'Programming 	Internet Email', a book from O'Reilly by David Wood."	self emitEncodedCharacter1.	self emitEncodedCharacter2.	self emitEncodedCharacter3.	self emitEncodedCharacter4.	self linePosition: self linePosition + 4.	self linePosition &gt;= 76		ifTrue: 			[self emitCRLF.			self linePosition: nil].	^self</body></methods><methods><class-id>Base64EncodingWriteStream</class-id> <category>private</category><body package="Base64Encoding">lineBreaksEnabled: aBoolean 	"^self 	I record a boolean which indicate wether line breaks are to be generated after the 76th character of 	each line. c.f. self&gt;&gt;lineBreaksEnabled."	lineBreaksEnabled := aBoolean.	^self</body><body package="Base64Encoding">linePosition	"^an Integer 	I return the current position on the output line. According to the spec, the encoded character stream 	should be divided into 76 character long 'lines'. This aspect of the spec comes from the fact that 	this encoding was originaly intended for email, so it was nicer to have the encoded stream broken 	into lines. Each line will be sepparated by &lt;cr&gt;&lt;lf&gt; characters. I lazily initialize this to zero."	linePosition isNil ifTrue: [linePosition := 0].	^linePosition</body><body package="Base64Encoding">linePosition: anInteger 	"^self 	I record the index that will be assigned to the next octed (byte) that is written to me. c.f. 	self&gt;&gt;octetIndex."	linePosition := anInteger.	^self</body></methods><methods><class-id>Base64EncodingWriteStream class</class-id> <category>instanceCreation</category><body package="Base64Encoding">on: aCollection 	"^a Base64EncodingStream 	I return a new instance of one of my subclasses which either encodes or decodes the contents of 	aCollection. I wrap this collection in another stream and delegate this to self&gt;&gt;onStream:"	^self onStream: (WriteStream on: aCollection)</body></methods><methods><class-id>Base64EncodingReadStream</class-id> <category>accessing</category><body package="Base64Encoding">atEnd	"^a Boolean 	I return true if I've reached the end, otherwise false."	^self peek isNil</body><body package="Base64Encoding">next	"^a Byte (an Integer between 0 &amp; 255) 	I return the next octet (byte) from my underlying encoded stream. I decode the octets from the 	source stream in bunches of threes, have a look at &gt;&gt;incrementOctetIndex to see how I move from 	one octet to the next. See &gt;&gt;makeNextOctetArrayCurrent to see how I decode the next four 	source characters to make a bunch of three octets."	| targetOctet |	targetOctet := self octetArray at: self octetIndex.	self incrementOctetIndex.	^targetOctet</body><body package="Base64Encoding">peek	"^a Byte or nil 	I return the byte that will be returned the next time &gt;&gt;next is sent, or nil. If we are at the end of the 	octet stream I'll return nil."	^self octetArray at: self octetIndex</body><body package="Base64Encoding">upToEnd	"^a ByteArray	I return a byteArray which contains the decoded elements from the current position	to the end of stream."	| newStream |	newStream := WriteStream on: (ByteArray new).	[self atEnd] whileFalse: [newStream nextPut: self next].	^newStream contents</body></methods><methods><class-id>Base64EncodingReadStream</class-id> <category>private</category><body package="Base64Encoding">addOctet1To: anArray from: encodedQuad	"^self 	I decode octet 1 from the encodedQuad (four character string)."	anArray at: 1 put: (((encodedQuad first)			bitShift: 2)			bitOr: (((encodedQuad at: 2)					bitAnd: 2r00110000)					bitShift: -4)).	^self</body><body package="Base64Encoding">addOctet2To: anArray from: encodedQuad	"^self 	I decode octet 2 from the encodedQuad (four character string)."	| decodedOctet |	 decodedOctet := (encodedQuad at: 3) isNil		ifTrue: [nil]		ifFalse: [(((encodedQuad at: 2)							bitAnd: 2r00001111)							bitShift: 4)							bitOr: (((encodedQuad at: 3)									bitAnd: 2r00111100)									bitShift: -2)].	anArray at: 2 put: decodedOctet.	^self</body><body package="Base64Encoding">addOctet3To: anArray from: encodedQuad	"^self 	I decode octet 3 from the encodedQuad (four character string)."	| decodedOctet |	decodedOctet := (encodedQuad at: 4) isNil		ifTrue: [nil]		ifFalse: [(((encodedQuad at: 3)						bitAnd: 2r00000011)						bitShift: 6)						bitOr: (((encodedQuad at: 4)								bitAnd: 2r00111111)								bitShift: 0)].	anArray at: 3 put: decodedOctet.	^self</body><body package="Base64Encoding">codesForCharacters: aString 	"^a ByteArray 	I return an array of 4 integers, one for each of the characters in aString. I use the 	characterDecodingTable for this."	^aString asArray collect: [:aCharacter| self characterDecodingTable at: aCharacter asInteger]</body><body package="Base64Encoding">incrementOctetIndex	"^self 	I increment the octet index. If we're currently at octet 3, we go back to octet 1, which will force the 	next quad to be read from the encoded stream when the next element is read from me."	self octetIndex &lt; 3		ifTrue: [self octetIndex: self octetIndex + 1]		ifFalse: 			[self makeNextOctetArrayCurrent.			self octetIndex: 1]</body><body package="Base64Encoding">makeNextOctetArrayCurrent	"^self 	I make the next octet triplet current, leaving the next array as nil."	octetArray := self nextOctetArray.	nextOctetArray := nil.	^self</body><body package="Base64Encoding">nextOctetArray	"^an Array 	I return the next set of three octets in an Array. At the end of the stream of octets the next array 	will contain one or more nil entries."	nextOctetArray isNil ifTrue: [nextOctetArray := self readNextOctetArray].	^nextOctetArray</body><body package="Base64Encoding">octetArray	"^an Array 	I return the Array which will hold the sets of three octets that are processed into 4 output characters, 	or vica-versa."	octetArray isNil ifTrue: [self makeNextOctetArrayCurrent].	^octetArray</body><body package="Base64Encoding">readNextOctetArray	"^an Array 	I return an Array with the next three octets decoded from the next four 	characters 	taken from my underlying stream. If I encounter $= characters or the end of 	the underlying stream I 	make nil entries in the new Array which indicate that atEnd has been 	reached."	| encodedQuad newOctetTriplet |	newOctetTriplet := Array new: 3.	self underlyingStream atEnd		ifFalse: 			[self skipNewlineCharacters.			encodedQuad := self codesForCharacters: (self underlyingStream next: 4).			self addOctet1To: newOctetTriplet from: encodedQuad.			self addOctet2To: newOctetTriplet from: encodedQuad.			self addOctet3To: newOctetTriplet from: encodedQuad].	^newOctetTriplet</body><body package="Base64Encoding">skipNewlineCharacters	"^self 	I skip over any new line characters . I tolerate either cr, or cr/lf."	self underlyingStream peek == Character cr		ifTrue: 			[underlyingStream skip: 1.			self underlyingStream peek == Character lf ifTrue: [underlyingStream skip: 1]].	^self</body></methods><methods><class-id>Base64EncodingReadStream class</class-id> <category>instanceCreation</category><body package="Base64Encoding">on: aCollection 	"^a Base64EncodingReadStream 	I return a new instance of one of my subclasses which either encodes or decodes the contents of 	aCollection. I wrap this collection in another stream and delegate this to self&gt;&gt;onStream:"	^self onStream: aCollection readStream</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class></st-source>