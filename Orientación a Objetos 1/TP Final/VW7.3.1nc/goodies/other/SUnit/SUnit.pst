<?xml version="1.0"?><st-source><!-- Name: SUnitHideSource: falseParcel: #('SUnit')PrerequisiteParcels: #(#('SUnitPreload' ''))SaveSource: trueVersion: Camp Smalltalk 3.1 RC2Date: 8:13:37 am March 22, 2003 --><time-stamp>From VisualWorksÂ®, Release 7 of June 14, 2002 on March 22, 2003 at 8:13:37 am</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>TestResource</name><environment>XProgramming.SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name description </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>SUnit</category></class><class><name>TestCase</name><environment>XProgramming.SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category></class><comment><class-id>XProgramming.SUnit.TestCase</class-id><body>A TestCase is a Command representing the future running of a test case. Create one with the class method #selector: aSymbol, passing the name of the method to be run when the test case runs.When you discover a new fixture, subclass TestCase, declare instance variables for the objects in the fixture, override #setUp to initialize the variables, and possibly override# tearDown to deallocate any external resources allocated in #setUp.When you are writing a test case method, send #assert: aBoolean when you want to check for an expected value. For example, you might say "self assert: socket isOpen" to test whether or not a socket is open at a point in a test.</body></comment><class><name>TestResult</name><environment>XProgramming.SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>failures errors passed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category></class><comment><class-id>XProgramming.SUnit.TestResult</class-id><body>This is a Collecting Parameter for the running of a bunch of tests. TestResult is an interesting object to subclass or substitute. #runCase: is the external protocol you need to reproduce. Kent has seen TestResults that recorded coverage information and that sent email when they were done.</body></comment><class><name>TestSuite</name><environment>XProgramming.SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tests resources name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category></class><comment><class-id>XProgramming.SUnit.TestSuite</class-id><body>This is a Composite of Tests, either TestCases or other TestSuites. The common protocol is #run: aTestResult and the dependencies protocol</body></comment><methods><class-id>XProgramming.SUnit.TestResource</class-id> <category>Accessing</category><body>description	description isNil		ifTrue: [^''].	^description			</body><body>description: aString	description := aString			</body><body>name	name isNil		ifTrue: [^self printString].	^name			</body><body>name: aString	name := aString			</body><body>resources	^self class resources			</body></methods><methods><class-id>XProgramming.SUnit.TestResource</class-id> <category>Init / Release</category><body>initialize	self setUp			</body></methods><methods><class-id>XProgramming.SUnit.TestResource</class-id> <category>Testing</category><body>isAvailable	"override to provide information on the	readiness of the resource"		^true			</body><body>isUnavailable	"override to provide information on the	readiness of the resource"		^self isAvailable not			</body></methods><methods><class-id>XProgramming.SUnit.TestResource</class-id> <category>Printing</category><body>printOn: aStream	aStream nextPutAll: self class printString			</body></methods><methods><class-id>XProgramming.SUnit.TestResource</class-id> <category>Running</category><body>setUp	"Does nothing. Subclasses should override this	to initialize their resource"			</body><body>signalInitializationError	^self class signalInitializationError			</body><body>tearDown	"Does nothing. Subclasses should override this	to tear down their resource"			</body></methods><methods><class-id>XProgramming.SUnit.TestResource class</class-id> <category>Accessing</category><body>current	current isNil		ifTrue: [current := self new].	^current			</body><body>current: aTestResource	current := aTestResource			</body><body>resources	^#()			</body></methods><methods><class-id>XProgramming.SUnit.TestResource class</class-id> <category>Testing</category><body>isAbstract	"Override to true if a TestResource subclass is Abstract and should not have	TestCase instances built from it"	^self name = #TestResource			</body><body>isAvailable	^self current notNil and: [self current isAvailable]			</body><body>isUnavailable	^self isAvailable not			</body></methods><methods><class-id>XProgramming.SUnit.TestResource class</class-id> <category>Creation</category><body>new	^super new initialize			</body><body>reset	current notNil ifTrue: [		[current tearDown] ensure: [			current := nil]]			</body><body>signalInitializationError	^TestResult signalErrorWith: 'Resource ' , self name , ' could not be initialized'			</body></methods><methods><class-id>XProgramming.SUnit.TestCase</class-id> <category>Dependencies</category><body>addDependentToHierachy: anObject 	"an empty method. for Composite compability with TestSuite"			</body><body>removeDependentFromHierachy: anObject 	"an empty method. for Composite compability with TestSuite"			</body></methods><methods><class-id>XProgramming.SUnit.TestCase</class-id> <category>Accessing</category><body>assert: aBoolean	aBoolean ifFalse: [self signalFailure: 'Assertion failed']			</body><body>assert: aBoolean description: aString	aBoolean ifFalse: [		self logFailure: aString.		TestResult failure sunitSignalWith: aString]			</body><body>assert: aBoolean description: aString resumable: resumableBoolean 	| exception |	aBoolean		ifFalse: 			[self logFailure: aString.			exception := resumableBoolean						ifTrue: [TestResult resumableFailure]						ifFalse: [TestResult failure].			exception sunitSignalWith: aString]			</body><body>deny: aBoolean	self assert: aBoolean not			</body><body>deny: aBoolean description: aString	self assert: aBoolean not description: aString			</body><body>deny: aBoolean description: aString resumable: resumableBoolean 	self		assert: aBoolean not		description: aString		resumable: resumableBoolean			</body><body>resources	| allResources resourceQueue |	allResources := Set new.	resourceQueue := OrderedCollection new.	resourceQueue addAll: self class resources.	[resourceQueue isEmpty] whileFalse: [		| next |		next := resourceQueue removeFirst.		allResources add: next.		resourceQueue addAll: next resources].	^allResources			</body><body>selector	^testSelector			</body><body>should: aBlock	self assert: aBlock value			</body><body>should: aBlock description: aString	self assert: aBlock value description: aString			</body><body>should: aBlock raise: anExceptionalEvent 	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent)			</body><body>should: aBlock raise: anExceptionalEvent description: aString 	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent)		description: aString			</body><body>shouldnt: aBlock	self deny: aBlock value			</body><body>shouldnt: aBlock description: aString	self deny: aBlock value description: aString			</body><body>shouldnt: aBlock raise: anExceptionalEvent 	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not			</body><body>shouldnt: aBlock raise: anExceptionalEvent description: aString 	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not 		description: aString			</body><body>signalFailure: aString	TestResult failure sunitSignalWith: aString			</body></methods><methods><class-id>XProgramming.SUnit.TestCase</class-id> <category>Running</category><body>debug	self resources do: [:res | 		res isAvailable ifFalse: [^res signalInitializationError]].	[(self class selector: testSelector) runCase] 		sunitEnsure: [self resources do: [:each | each reset]]			</body><body>debugAsFailure	| semaphore |	semaphore := Semaphore new.	self resources do: [:res | 		res isAvailable ifFalse: [^res signalInitializationError]].	[semaphore wait. self resources do: [:each | each reset]] fork.	(self class selector: testSelector) runCaseAsFailure: semaphore.			</body><body>failureLog	^SUnitNameResolver defaultLogDevice</body><body>isLogging	"By default, we're not logging failures. If you override this in 	a subclass, make sure that you override #failureLog"	^false			</body><body>logFailure: aString	self isLogging ifTrue: [		self failureLog 			cr; 			nextPutAll: aString; 			flush]			</body><body>openDebuggerOnFailingTestMethod	"SUnit has halted one step in front of the failing test method. Step over the 'self halt' and 	 send into 'self perform: testSelector' to see the failure from the beginning"	self		halt;		performTest			</body><body>run	| result |	result := TestResult new.	self run: result.	^result			</body><body>run: aResult	aResult runCase: self			</body><body>runCase	[self setUp.	self performTest] sunitEnsure: [self tearDown]			</body><body>runCaseAsFailure: aSemaphore	[self setUp.	self openDebuggerOnFailingTestMethod] sunitEnsure: [		self tearDown.		aSemaphore signal]			</body><body>setUp			</body><body>tearDown			</body></methods><methods><class-id>XProgramming.SUnit.TestCase</class-id> <category>Private</category><body>executeShould: aBlock inScopeOf: anExceptionalEvent 	^[aBlock value. 	false] sunitOn: anExceptionalEvent		do: [:ex | ex sunitExitWith: true]			</body><body>performTest	self perform: testSelector sunitAsSymbol			</body><body>setTestSelector: aSymbol	testSelector := aSymbol			</body></methods><methods><class-id>XProgramming.SUnit.TestCase</class-id> <category>Printing</category><body>printOn: aStream	aStream		nextPutAll: self class printString;		nextPutAll: '&gt;&gt;#';		nextPutAll: testSelector			</body></methods><methods><class-id>XProgramming.SUnit.TestCase class</class-id> <category>Accessing</category><body>allTestSelectors	^self sunitAllSelectors select: [:each | 'test*' sunitMatch: each]			</body><body>resources	^#()			</body><body>sunitVersion	^'3.1'</body><body>testSelectors	^self sunitSelectors select: [:each | 'test*' sunitMatch: each]			</body></methods><methods><class-id>XProgramming.SUnit.TestCase class</class-id> <category>Building Suites</category><body>buildSuite	| suite |	^self isAbstract		ifTrue: 			[suite := self suiteClass named: self name asString.			self allSubclasses 				do: [:each | each isAbstract ifFalse: [suite addTest: each buildSuiteFromSelectors]].			suite]		ifFalse: [self buildSuiteFromSelectors]			</body><body>buildSuiteFromAllSelectors	^self buildSuiteFromMethods: self allTestSelectors			</body><body>buildSuiteFromLocalSelectors	^self buildSuiteFromMethods: self testSelectors			</body><body>buildSuiteFromMethods: testMethods	^testMethods		inject: (self suiteClass named: self name asString)		into: [:suite :selector |			suite				addTest: (self selector: selector);				yourself]			</body><body>buildSuiteFromSelectors	^self shouldInheritSelectors		ifTrue: [self buildSuiteFromAllSelectors]		ifFalse: [self buildSuiteFromLocalSelectors]			</body><body>suiteClass	^TestSuite			</body></methods><methods><class-id>XProgramming.SUnit.TestCase class</class-id> <category>Instance Creation</category><body>debug: aSymbol	^(self selector: aSymbol) debug			</body><body>run: aSymbol	^(self selector: aSymbol) run			</body><body>selector: aSymbol	^self new setTestSelector: aSymbol			</body><body>suite	^self buildSuite			</body></methods><methods><class-id>XProgramming.SUnit.TestCase class</class-id> <category>Testing</category><body>isAbstract	"Override to true if a TestCase subclass is Abstract and should not have	TestCase instances built from it"	^self sunitName = #TestCase</body><body>shouldInheritSelectors	"I should inherit from an Abstract superclass but not from a concrete one by default, unless I have no testSelectors in which case I must be expecting to inherit them from my superclass.  If a test case with selectors wants to inherit selectors from a concrete superclass, override this to true in that subclass."	^self superclass isAbstract		or: [self testSelectors isEmpty]"$QA Ignore:Sends system method(superclass)$"			</body></methods><methods><class-id>XProgramming.SUnit.TestResult</class-id> <category>Accessing</category><body>correctCount	"depreciated - use #passedCount"	^self passedCount			</body><body>defects	^OrderedCollection new		addAll: self errors;		addAll: self failures; yourself			</body><body>errorCount	^self errors size			</body><body>errors	errors isNil		ifTrue: [errors := OrderedCollection new].	^errors			</body><body>failureCount	^self failures size			</body><body>failures	failures isNil		ifTrue: [failures := Set new].	^failures			</body><body>passed	passed isNil		ifTrue: [passed := OrderedCollection new].	^passed			</body><body>passedCount	^self passed size			</body><body>runCount	^self passedCount + self failureCount + self errorCount			</body><body>tests	^(OrderedCollection new: self runCount)		addAll: self passed;		addAll: self errors;		addAll: self failures;		yourself</body></methods><methods><class-id>XProgramming.SUnit.TestResult</class-id> <category>Testing</category><body>hasErrors	^self errors size &gt; 0			</body><body>hasFailures	^self failures size &gt; 0			</body><body>hasPassed	^self hasErrors not and: [self hasFailures not]			</body><body>isError: aTestCase	^self errors includes: aTestCase			</body><body>isFailure: aTestCase	^self failures includes: aTestCase			</body><body>isPassed: aTestCase	^self passed includes: aTestCase			</body></methods><methods><class-id>XProgramming.SUnit.TestResult</class-id> <category>Init / Release</category><body>initialize			</body></methods><methods><class-id>XProgramming.SUnit.TestResult</class-id> <category>Printing</category><body>printOn: aStream	aStream		nextPutAll: self runCount printString;		nextPutAll: ' run, ';		nextPutAll: self correctCount printString;		nextPutAll: ' passed, ';		nextPutAll: self failureCount printString;		nextPutAll: ' failed, ';		nextPutAll: self errorCount printString;		nextPutAll: ' error'.	self errorCount ~= 1		ifTrue: [aStream nextPut: $s]			</body></methods><methods><class-id>XProgramming.SUnit.TestResult</class-id> <category>Running</category><body>runCase: aTestCase	| testCasePassed |	testCasePassed :=		[			[				aTestCase runCase.				true]					sunitOn: self class failure					do: [:signal |						self failures add: aTestCase.						signal sunitExitWith: false]]							sunitOn: self class error							do: [:signal |								self errors add: aTestCase.								signal sunitExitWith: false].	testCasePassed		ifTrue: [self passed add: aTestCase]			</body></methods><methods><class-id>XProgramming.SUnit.TestResult class</class-id> <category>Exceptions</category><body>error	^self exError			</body><body>exError	^SUnitNameResolver errorObject			</body><body>failure	^TestFailure			</body><body>resumableFailure	^ResumableTestFailure			</body><body>signalErrorWith: aString 	self error sunitSignalWith: aString			</body><body>signalFailureWith: aString 	self failure sunitSignalWith: aString			</body></methods><methods><class-id>XProgramming.SUnit.TestResult class</class-id> <category>Init / Release</category><body>new	^super new initialize			</body></methods><methods><class-id>XProgramming.SUnit.TestSuite</class-id> <category>Dependencies</category><body>addDependentToHierachy: anObject	self sunitAddDependent: anObject.	self tests do: [ :each | each addDependentToHierachy: anObject]			</body><body>removeDependentFromHierachy: anObject	self sunitRemoveDependent: anObject.	self tests do: [ :each | each removeDependentFromHierachy: anObject]			</body></methods><methods><class-id>XProgramming.SUnit.TestSuite</class-id> <category>Accessing</category><body>addTest: aTest	self tests add: aTest			</body><body>addTests: aCollection 	aCollection do: [:eachTest | self addTest: eachTest]			</body><body>defaultResources	^self tests 		inject: Set new		into: [:coll :testCase | 			coll				addAll: testCase resources;				yourself]			</body><body>name	^name			</body><body>name: aString	name := aString			</body><body>resources	resources isNil ifTrue: [resources := self defaultResources].	^resources			</body><body>resources: anObject	resources := anObject			</body><body>tests	tests isNil ifTrue: [tests := OrderedCollection new].	^tests			</body></methods><methods><class-id>XProgramming.SUnit.TestSuite</class-id> <category>Running</category><body>run	| result | 	result := TestResult new.	self resources do: [ :res |		res isAvailable ifFalse: [^res signalInitializationError]].	[self run: result] sunitEnsure: [self resources do: [:each | each reset]].	^result			</body><body>run: aResult 	self tests do: [:each | 		self sunitChanged: each.		each run: aResult]			</body></methods><methods><class-id>XProgramming.SUnit.TestSuite class</class-id> <category>Creation</category><body>named: aString	^self new		name: aString;		yourself			</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category></class></st-source>