<?xml version="1.0"?><st-source><!-- Name: SmaCC RuntimeComment: This package is part of the Smalltalk Compiler-Compiler (SmaCC) written by John Brant and Don Roberts. It contains the runtime part of SmaCC. All parsers created using SmaCC will need this code. If you want more information about SmaCC, visit http://www.refactory.com/Software/SmaCC/. - - - - - - - - - - - - - - - - - - - - - - - - -Copyright (c) 2002-2003 John Brant, Don RobertsPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.DbIdentifier: storeDbTrace: 3686DevelopmentPrerequisites: #(#(#any 'Refactory' ''))PackageName: SmaCC RuntimeParcel: #('SmaCC Runtime')PrerequisiteParcels: #(#('Refactory' ''))PrintStringCache: (1.68,brant)Date: 6:37:35 am October 13, 2003 --><time-stamp>From VisualWorksÂ® NonCommercial, Pre-Release 7.2 (oct03.1) of October 6, 2003 on October 13, 2003 at 6:37:35 am</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>SmaCC</name><environment>Refactory</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>SmaCC Runtime</category><attributes><package>SmaCC Runtime</package></attributes></name-space><class><name>SmaCCLineNumberStream</name><environment>Refactory.SmaCC</environment><super>Core.PeekableStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourceStream previousWasCR eolPositions lastPosition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Runtime</category><attributes><package>SmaCC Runtime</package></attributes></class><class><name>SmaCCParser</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scanner currentToken errorToken stateStack nodeStack </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Runtime</category><attributes><package>SmaCC Runtime</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCParser</class-id><body>SmaCCParser is an abstract class that defines most of the parsing actions. Subclasses will define methods that specify their transitions and reduction actions. These are normally defined automatically when compiling the parser.Subclasses must implement the following messages:	accessing		emptySymbolTokenId		reduceTable		transitionTableInstance Variables:	currentToken	&lt;SmaCCToken&gt;	the token last returned by the scanner that has not been shifted (reduce actions leave the current token alone)	nodeStack	&lt;OrderedCollection&gt;	collection of items on stack. These items are specific to the parser and can be any object. 	scanner	&lt;SmaCCScanner&gt;	our scanner	stateStack	&lt;OrderedCollection of: Integer&gt;	the stack of states for our parser (standard LR state stack)</body></comment><class><name>SmaCCParserError</name><environment>Refactory.SmaCC</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Runtime</category><attributes><package>SmaCC Runtime</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCParserError</class-id><body>SmaCCParserException is the exception raised when a parsing error occurs. The description of the exception will be the error message and the parameter of the exception is the parser. With this information, you can insert a custom error message in your text view that you are parsing. For example, in VisualWorks, the following code will insert an error message into your text view:	textController insertAndSelect: ex description , ' -&gt;' at: ex parameter position</body></comment><class><name>SmaCCToken</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>start id value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Runtime</category><attributes><package>SmaCC Runtime</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCToken</class-id><body>SmaCCTokens are used as the interface objects between scanner and parser. They hold the string that was scanned and its position information. Also, included in the token is its id. The id specifies what type of token it is.Instance Variables:	id	&lt;Array of: Integer&gt;	the list of possible token types this represents. There can be overlapping tokens, so we list all of the id here. The default parser only looks at the first id, but we can redefine this behavior in a subclass to look at all possibilities until we find a valid token.	start	&lt;Integer&gt;	the starting position of the token in the original input	value	&lt;Object&gt;	the value of our token (normally a string, but could be anything)</body></comment><class><name>SmaCCScanner</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream start matchActions matchEnd currentCharacter outputStream lastOutputStreamMatchPosition lastMatchWasEmpty returnMatchBlock </inst-vars><class-inst-vars>keywordMap </class-inst-vars><imports></imports><category>SmaCC Runtime</category><attributes><package>SmaCC Runtime</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCScanner</class-id><body>SmaCCScanner is an abstract class that represents a scanner for the parser. The scanner converts its string input into SmaCCToken objects that the parser then uses for its parsing.Subclasses must implement the following messages:	accessing		scanForTokenInstance Variables:	currentCharacter	&lt;Character&gt;	the current character we are scanning	lastMatchWasEmpty	&lt;Boolean&gt;	was our last scanning match an empty string -- don't allow two empty matches in a row	lastOutputStreamMatchPosition	&lt;Integer&gt;	the position in the outputStream of the last match	matchActions	&lt;Array | Symbol&gt;	the actions for the last match (a symbol means that the action should be performed on the scanner)	matchEnd	&lt;Integer&gt;	the position of the last match in the stream (our input stream)	outputStream	&lt;PositionableStream&gt;	the matched characters go in this stream. After a match is made, we take this stream's contents and create a token object.	returnMatchBlock	&lt;BlockClosure&gt;	when we match a token evaluate this block with the token (hack to return from multiple levels)	start	&lt;Integer&gt;	the starting position of a match in the stream	stream	&lt;Stream&gt;	our input</body></comment><methods><class-id>Refactory.SmaCC.SmaCCLineNumberStream</class-id> <category>testing</category><body package="SmaCC Runtime">atEnd	^sourceStream atEnd</body><body package="SmaCC Runtime">isReadable	^sourceStream isReadable</body><body package="SmaCC Runtime">isWritable	^sourceStream isWritable</body></methods><methods><class-id>Refactory.SmaCC.SmaCCLineNumberStream</class-id> <category>accessing</category><body package="SmaCC Runtime">columnNumber	^self columnNumberFor: self position</body><body package="SmaCC Runtime">columnNumberFor: anInteger 	^anInteger - (eolPositions at: (self lineNumberFor: anInteger)) + 1</body><body package="SmaCC Runtime">contents	^sourceStream contents</body><body package="SmaCC Runtime">flush	^sourceStream flush</body><body package="SmaCC Runtime">lineNumber	^self lineNumberFor: self position</body><body package="SmaCC Runtime">lineNumberFor: anInteger	| index start stop pos |	pos := anInteger.	pos &gt;= eolPositions last ifTrue: [^eolPositions size].	start := 1.	stop := eolPositions size.	[start + 1 &lt; stop] whileTrue: 			[index := (start + stop) // 2.			(eolPositions at: index) &lt;= pos 				ifTrue: [start := index]				ifFalse: [stop := index]].	^start</body><body package="SmaCC Runtime">next	| character streamPosition |	character := sourceStream next.	streamPosition := sourceStream position.	streamPosition - 1 &gt;= lastPosition 		ifTrue: 			[lastPosition := streamPosition.			character == Character cr 				ifTrue: 					[eolPositions add: lastPosition.					previousWasCR := true]				ifFalse: 					[character == Character lf 						ifTrue: 							[previousWasCR 								ifTrue: [eolPositions at: eolPositions size put: lastPosition]								ifFalse: [eolPositions add: lastPosition]].					previousWasCR := false]].	^character</body><body package="SmaCC Runtime">nextPut: anObject 	^sourceStream nextPut: anObject</body><body package="SmaCC Runtime">peek	^sourceStream peek</body><body package="SmaCC Runtime">position	^sourceStream position</body><body package="SmaCC Runtime">position: anInteger 	anInteger &gt; lastPosition 		ifTrue: 			[sourceStream position: lastPosition.			[sourceStream position &lt; anInteger and: [sourceStream atEnd not]] 				whileTrue: [self next]]		ifFalse: [sourceStream position: anInteger]</body><body package="SmaCC Runtime">skip: anInteger	^self position: self position + anInteger</body></methods><methods><class-id>Refactory.SmaCC.SmaCCLineNumberStream</class-id> <category>error handling</category><body package="SmaCC Runtime">doesNotUnderstand: aMessage 	^sourceStream perform: aMessage selector withArguments: aMessage arguments</body></methods><methods><class-id>Refactory.SmaCC.SmaCCLineNumberStream</class-id> <category>initialize-release</category><body package="SmaCC Runtime">on: aReadStream 	sourceStream := aReadStream.	eolPositions := OrderedCollection with: aReadStream position.	lastPosition := aReadStream position.	previousWasCR := false</body></methods><methods><class-id>Refactory.SmaCC.SmaCCLineNumberStream class</class-id> <category>instance creation</category><body package="SmaCC Runtime">on: aReadStream 	^(self basicNew)		on: aReadStream;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParser</class-id> <category>private</category><body package="SmaCC Runtime">acceptAction	^0</body><body package="SmaCC Runtime">actionFor: aSymbolIndex 	^self actionForState: self currentState and: aSymbolIndex</body><body package="SmaCC Runtime">actionForCurrentToken	^self actionFor: currentToken id first</body><body package="SmaCC Runtime">actionForState: stateIndex and: aSymbolIndex 	| index row |	row := self transitionTable at: stateIndex.	^(row at: 1) == 0 		ifTrue: 			[index := self 						binarySearchIn: row						for: aSymbolIndex						size: 2.			index == 0 				ifTrue: [^self errorAction]				ifFalse: [^((row at: 2) bitShift: 8) + (row at: 3)]]		ifFalse: 			[index := self 						binarySearchIn: row						for: aSymbolIndex						size: 4.			index == 0 				ifTrue: [^self errorAction]				ifFalse: [^((row at: index - 2) bitShift: 8) + (row at: index - 1)]]</body><body package="SmaCC Runtime">actionMask	^2r11</body><body package="SmaCC Runtime">binarySearchIn: aRow for: aSymbolIndex size: step 	| start mid length high low midItem stop |	high := aSymbolIndex bitShift: -8.	low := aSymbolIndex bitAnd: 16rFF.	start := 4.	stop := aRow size - 1.	length := (stop - start) // step.	[length &gt; 4] whileTrue: 			[length := length bitShift: -1.			mid := length * step + start.			midItem := aRow at: mid.			((midItem == high and: [(aRow at: mid + 1) &lt;= low]) or: [midItem &lt; high]) 				ifTrue: [start := mid]				ifFalse: [stop := mid]].	[start &lt;= stop] whileTrue: 			[((aRow at: start) == high and: [(aRow at: start + 1) == low]) 				ifTrue: [^start].			start := start + step].	^0</body><body package="SmaCC Runtime">currentState	^stateStack last</body><body package="SmaCC Runtime">errorAction	^3</body><body package="SmaCC Runtime">findErrorHandlerIfNoneUseErrorNumber: anInteger 	| handlerStates index startingErrorToken newStack |	handlerStates := self errorHandlerStates reverse.	startingErrorToken := currentToken.		[index := (1 to: handlerStates size) detect: 					[:each | 					| state |					state := handlerStates at: each.					state ~= 0 and: 							[newStack := stateStack copyFrom: 1 to: handlerStates size - each + 1.							newStack add: state.							self willShift: newStack]]				ifNone: [nil].	index isNil] 			whileTrue: 				[self dismissErrorToken.				self isEOFToken 					ifTrue: 						[currentToken := startingErrorToken.						self reportError: anInteger]].	index - 1 timesRepeat: [self dismissStackTopForErrorRecovery].	stateStack addLast: (handlerStates at: index).	nodeStack addLast: startingErrorToken</body><body package="SmaCC Runtime">getNextToken	currentToken isNil ifTrue: [currentToken := scanner next]</body><body package="SmaCC Runtime">performParsingLoop	| action actionType |		[self getNextToken.	action := self actionForCurrentToken.	action = self acceptAction] 			whileFalse: 				[actionType := action bitAnd: self actionMask.				action := action bitShift: -2.				actionType == self shiftAction 					ifTrue: [self shift: action]					ifFalse: 						[actionType == self reduceAction 							ifTrue: [self reduce: action]							ifFalse: [self handleError: action]]].	self checkForErrors</body><body package="SmaCC Runtime">performReduceMethod: aSymbol with: items 	^aSymbol last == $: 		ifTrue: [self perform: aSymbol with: items]		ifFalse: [self perform: aSymbol]</body><body package="SmaCC Runtime">reduce: anInteger 	| reduceEntry items size |	reduceEntry := self reduceTable at: anInteger.	items := OrderedCollection new: (size := reduceEntry at: 2).	size timesRepeat: 			[items addFirst: nodeStack removeLast.			stateStack removeLast].	nodeStack add: (self performReduceMethod: (reduceEntry at: 3) with: items).	stateStack add: ((self actionFor: (reduceEntry at: 1)) bitShift: -2)</body><body package="SmaCC Runtime">reduceAction	^2r10</body><body package="SmaCC Runtime">reduceFor: aCollection 	| newCollection item |	(aCollection allSatisfy: [:each | each class ~~ OrderedCollection]) 		ifTrue: [^aCollection].	aCollection first class == OrderedCollection 		ifTrue: 			[newCollection := aCollection first.			2 to: aCollection size				do: 					[:i | 					item := aCollection at: i.					item class = OrderedCollection 						ifTrue: [newCollection addAll: item]						ifFalse: [newCollection add: item]].			^newCollection].	newCollection := OrderedCollection new.	aCollection do: 			[:each | 			each class == OrderedCollection 				ifTrue: [newCollection addAll: each]				ifFalse: [newCollection add: each]].	^newCollection</body><body package="SmaCC Runtime">setDefaultStartingStateIfNone	stateStack isNil 		ifTrue: [self setStartingState: self class defaultStartingState]</body><body package="SmaCC Runtime">shift: stateIndex 	stateStack add: stateIndex.	nodeStack add: currentToken.	currentToken := nil</body><body package="SmaCC Runtime">shiftAction	^2r01</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParser</class-id> <category>accessing</category><body package="SmaCC Runtime">emptySymbolTokenId	^scanner emptySymbolTokenId</body><body package="SmaCC Runtime">errorTable	^#()</body><body package="SmaCC Runtime">errorTokenId	^scanner errorTokenId</body><body package="SmaCC Runtime">parse	self setDefaultStartingStateIfNone.	self performParsingLoop.	^nodeStack last</body><body package="SmaCC Runtime">position	^currentToken isNil 		ifTrue: [scanner position]		ifFalse: [currentToken startPosition]</body><body package="SmaCC Runtime">reduceTable	^self subclassResponsibility</body><body package="SmaCC Runtime">transitionTable	^self subclassResponsibility</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParser</class-id> <category>initialize-release</category><body package="SmaCC Runtime">initialize	nodeStack := OrderedCollection new</body><body package="SmaCC Runtime">scanner: aScanner 	scanner := aScanner</body><body package="SmaCC Runtime">setStartingState: startingState 	stateStack := OrderedCollection with: startingState</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParser</class-id> <category>testing</category><body package="SmaCC Runtime">isEOFToken	^currentToken id first = self emptySymbolTokenId</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParser</class-id> <category>private-error handling</category><body package="SmaCC Runtime">checkForErrors	"If we have an error correction installed, we might have handled the errors. If we did, we don't 	want to return the result, so we raise a final exception that can't be proceeded."	errorToken isNil ifTrue: [^self].	currentToken := errorToken.	self reportErrorMessage: 'Token not expected'</body><body package="SmaCC Runtime">dismissErrorToken	currentToken := nil.	self getNextToken</body><body package="SmaCC Runtime">dismissStackTopForErrorRecovery	stateStack removeLast.	^nodeStack removeLast</body><body package="SmaCC Runtime">errorHandlerStates	^stateStack collect: 			[:each | 			| action |			action := self actionForState: each and: self errorTokenId.			(action bitAnd: self actionMask) = 1 				ifTrue: [action bitShift: -2]				ifFalse: [0]]</body><body package="SmaCC Runtime">handleError: anInteger 	errorToken isNil ifTrue: [errorToken := currentToken].	(self isEOFToken or: [self hasErrorHandler not]) 		ifTrue: [self reportError: anInteger].	self findErrorHandlerIfNoneUseErrorNumber: anInteger</body><body package="SmaCC Runtime">hasErrorHandler	^self errorHandlerStates anySatisfy: [:each | each ~~ 0]</body><body package="SmaCC Runtime">reportError: anInteger 	self reportErrorMessage: (anInteger = 0 				ifTrue: ['Token not expected']				ifFalse: [self errorTable at: anInteger])</body><body package="SmaCC Runtime">reportErrorMessage: aString 	SmaCCParserError raiseWith: self errorString: aString</body><body package="SmaCC Runtime">willShift: potentialStateStack 	| action compoundAction reduceEntry size |	compoundAction := self actionForState: potentialStateStack last				and: currentToken id first.	action := compoundAction bitAnd: self actionMask.	action == self shiftAction ifTrue: [^true].	action == self reduceAction 		ifTrue: 			[reduceEntry := self reduceTable at: (compoundAction bitShift: -2).			size := reduceEntry at: 2.			size timesRepeat: [potentialStateStack removeLast].			potentialStateStack 				add: ((self actionForState: potentialStateStack last						and: (reduceEntry at: 1)) bitShift: -2).			^self willShift: potentialStateStack].	^false</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParser</class-id> <category>standard reduction rules</category><body package="SmaCC Runtime">liftFirstValue: aCollection 	^aCollection first</body><body package="SmaCC Runtime">liftLastValue: aCollection 	^aCollection last</body><body package="SmaCC Runtime">liftSecondValue: aCollection 	^aCollection at: 2</body><body package="SmaCC Runtime">nil	^nil</body><body package="SmaCC Runtime">stringValue: anOrderedCollection 	^anOrderedCollection first value</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParser class</class-id> <category>instance creation</category><body package="SmaCC Runtime">new	^(super new)		initialize;		yourself</body><body package="SmaCC Runtime">on: aStream 	| parser scanner |	scanner := self scannerClass on: aStream.	parser := self new.	parser scanner: scanner.	^parser</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParser class</class-id> <category>accessing</category><body package="SmaCC Runtime">parse: aString 	^self parse: aString startingAt: self defaultStartingState</body><body package="SmaCC Runtime">parse: aString onError: aBlock 	^[self parse: aString] on: SmaCCParserError		do: [:ex | ex return: (aBlock value: ex description value: ex parameter position)]</body><body package="SmaCC Runtime">parse: aString startingAt: anInteger 	^self parseStream: (ReadStream on: aString) startingAt: anInteger</body><body package="SmaCC Runtime">parse: aString startingAt: anInteger onError: aBlock 	^[self parse: aString startingAt: anInteger] on: SmaCCParserError		do: [:ex | ex return: (aBlock value: ex description value: ex parameter position)]</body><body package="SmaCC Runtime">parseStream: aStream 	^self parseStream: aStream startingAt: self defaultStartingState</body><body package="SmaCC Runtime">parseStream: aStream onError: aBlock 	^[self parseStream: aStream] on: SmaCCParserError		do: [:ex | ex return: (aBlock value: ex description value: ex parameter position)]</body><body package="SmaCC Runtime">parseStream: aStream startingAt: anInteger 	| parser |	parser := self on: aStream.	parser setStartingState: anInteger.	^parser parse</body><body package="SmaCC Runtime">parseStream: aStream startingAt: anInteger onError: aBlock 	^[self parseStream: aStream startingAt: anInteger] 		on: SmaCCParserError		do: [:ex | ex return: (aBlock value: ex description value: ex parameter position)]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCParser class</class-id> <category>private</category><body package="SmaCC Runtime">defaultStartingState	^1</body><body package="SmaCC Runtime">scannerClass	^self subclassResponsibility</body></methods><methods><class-id>Refactory.SmaCC.SmaCCToken</class-id> <category>accessing</category><body package="SmaCC Runtime">id	^id</body><body package="SmaCC Runtime">startPosition	^start + 1</body><body package="SmaCC Runtime">stopPosition	^start + value size</body><body package="SmaCC Runtime">value	^value</body></methods><methods><class-id>Refactory.SmaCC.SmaCCToken</class-id> <category>initialize-release</category><body package="SmaCC Runtime">value: anObject start: startPositionInteger id: anInteger 	value := anObject.	start := startPositionInteger.	id := anInteger</body></methods><methods><class-id>Refactory.SmaCC.SmaCCToken</class-id> <category>printing</category><body package="SmaCC Runtime">printOn: aStream 	aStream		nextPut: ${;		nextPutAll: self value;		nextPut: $(;		nextPutAll: self startPosition printString;		nextPut: $,;		nextPutAll: self stopPosition printString;		nextPut: $,;		nextPutAll: self id printString;		nextPutAll: ')}'</body></methods><methods><class-id>Refactory.SmaCC.SmaCCToken class</class-id> <category>instance creation</category><body package="SmaCC Runtime">value: aString start: anInteger id: anObject 	^(self new)		value: aString			start: anInteger			id: anObject;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScanner</class-id> <category>private</category><body package="SmaCC Runtime">checkForKeyword: aString 	| stateMap action |	action := matchActions isSymbol 				ifTrue: [matchActions]				ifFalse: [matchActions first].	stateMap := self class keywordMap at: action ifAbsent: [nil].	stateMap isNil ifTrue: [^self].	matchActions := stateMap at: (self keywordFor: aString)				ifAbsent: [matchActions].	matchActions isInteger 		ifTrue: [matchActions := Array with: matchActions with: action]</body><body package="SmaCC Runtime">checkForValidMatch	matchActions isNil ifTrue: [self scannerError]</body><body package="SmaCC Runtime">createTokenFor: string 	| token |	token := self tokenClass 				value: string				start: start				id: matchActions.	outputStream reset.	^token</body><body package="SmaCC Runtime">initialBufferSize	^128</body><body package="SmaCC Runtime">recordAndReportMatch: aCollection 	^self		recordMatch: aCollection;		reportLastMatch</body><body package="SmaCC Runtime">recordMatch: aCollection 	matchActions := aCollection.	matchEnd := stream position.	lastOutputStreamMatchPosition := outputStream position</body><body package="SmaCC Runtime">reportLastMatch	"The scanner has found the end of a token and must report it"	| string token |	self checkForValidMatch.	self resetOutputToLastMatch.	stream position: matchEnd.	string := outputStream contents.	self checkForKeyword: string.	token := matchActions isSymbol 				ifTrue: [self perform: matchActions]				ifFalse: [self createTokenFor: string].	matchActions := nil.	^token</body><body package="SmaCC Runtime">resetOutputToLastMatch	outputStream position: lastOutputStreamMatchPosition.	lastOutputStreamMatchPosition == 0 		ifTrue: 			[lastMatchWasEmpty ifTrue: [self scannerError].			lastMatchWasEmpty := true]		ifFalse: [lastMatchWasEmpty := false]</body><body package="SmaCC Runtime">resetScanner	start := stream position.	outputStream reset.	lastOutputStreamMatchPosition := 0</body><body package="SmaCC Runtime">scannerError	(stream atEnd and: [start == stream position]) 		ifTrue: 			[returnMatchBlock value: (self tokenClass 						value: ''						start: stream position						id: (Array with: self emptySymbolTokenId))].	stream position: start.	returnMatchBlock value: (self tokenClass 				value: (String with: stream next)				start: start				id: #(0))</body><body package="SmaCC Runtime">step	stream atEnd ifTrue: [^returnMatchBlock value: self reportLastMatch].	currentCharacter := stream next.	outputStream nextPut: currentCharacter</body><body package="SmaCC Runtime">tokenClass	^SmaCCToken</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScanner</class-id> <category>accessing</category><body package="SmaCC Runtime">contents	| writeStream token |	writeStream := WriteStream with: Array new.	[self atEnd] whileFalse: 			[token := self next.			token notNil ifTrue: [writeStream nextPut: token]].	^writeStream contents</body><body package="SmaCC Runtime">emptySymbolTokenId	^self subclassResponsibility</body><body package="SmaCC Runtime">errorTokenId	^self subclassResponsibility</body><body package="SmaCC Runtime">lineNumber	"This requires the stream to be a line number stream (see the #needsLineNumbers class method)."	^stream lineNumber</body><body package="SmaCC Runtime">next	self resetScanner.	returnMatchBlock := [:match | ^match].	^self scanForToken</body><body package="SmaCC Runtime">position	^stream position</body><body package="SmaCC Runtime">position: anInteger	^stream position: anInteger</body><body package="SmaCC Runtime">scanForToken	^self subclassResponsibility</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScanner</class-id> <category>private-utility</category><body package="SmaCC Runtime">keywordFor: aString 	"Subclasses can override this to ignore case"	^aString</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScanner</class-id> <category>initialize-release</category><body package="SmaCC Runtime">initialize	outputStream := WriteStream on: (String new: self initialBufferSize).	lastMatchWasEmpty := true</body><body package="SmaCC Runtime">on: aStream 	stream := aStream.	start := stream position</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScanner</class-id> <category>testing</category><body package="SmaCC Runtime">atEnd	^stream atEnd</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScanner</class-id> <category>default token handling</category><body package="SmaCC Runtime">comment	"In case someone wants to record the comments"	^self whitespace</body><body package="SmaCC Runtime">whitespace	"By default, eat the whitespace"	self resetScanner.	^self scanForToken</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScanner class</class-id> <category>instance creation</category><body package="SmaCC Runtime">new	^(super new)		initialize;		yourself</body><body package="SmaCC Runtime">on: aStream 	^(self new)		on: (self needsLineNumbers 					ifTrue: [SmaCCLineNumberStream on: aStream]					ifFalse: [aStream]);		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScanner class</class-id> <category>accessing</category><body package="SmaCC Runtime">keywordMap	keywordMap isNil ifTrue: [self initializeKeywordMap].	^keywordMap</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScanner class</class-id> <category>testing</category><body package="SmaCC Runtime">needsLineNumbers	"Redefine to return true, if you need line number information"	^false</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScanner class</class-id> <category>class initialization</category><body package="SmaCC Runtime">initialize	self initializeKeywordMap</body><body package="SmaCC Runtime">initializeKeywordMap	keywordMap := Dictionary new</body></methods><initialize><class-id>Refactory.SmaCC.SmaCCScanner</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>PeekableStream</name><environment>Core</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>