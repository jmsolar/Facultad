<?xml version="1.0"?><st-source><!-- Name: SmaCC TestsComment: This package is part of the Smalltalk Compiler-Compiler (SmaCC) written by John Brant and Don Roberts. It contains some simple tests for SmaCC. If you wish to port SmaCC or if you want to verify you installation of SmaCC, then these may be useful to you. Under VisualWorks, these tests require loading the MethodWrappers package (http://www.refactory.com/Software/MethodWrappers/).If you want more information about SmaCC, visit http://www.refactory.com/Software/SmaCC/. - - - - - - - - - - - - - - - - - - - - - - - - -Copyright (c) 2002-2003 John Brant, Don RobertsPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.DbIdentifier: storeDbTrace: 3683DevelopmentPrerequisites: #(#(#any 'Method Wrapper Base' '') #(#any 'SmaCC Development' '') #(#any 'SUnit' ''))PackageName: SmaCC TestsParcel: #('SmaCC Tests')PrerequisiteParcels: #(#('Method Wrapper Base' '') #('SmaCC Development' '') #('SUnit' ''))PrintStringCache: (1.49,brant)Date: 6:37:51 am October 13, 2003 --><time-stamp>From VisualWorksÂ® NonCommercial, Pre-Release 7.2 (oct03.1) of October 6, 2003 on October 13, 2003 at 6:37:51 am</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>TestParser</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Tests</category><attributes><package>SmaCC Tests</package></attributes></class><class><name>TestScanner</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Tests</category><attributes><package>SmaCC Tests</package></attributes></class><class><name>ParserGeneratorTest</name><environment>Refactory.SmaCC</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>wrappers </inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Wrappers.*			</imports><category>SmaCC Tests</category><attributes><package>SmaCC Tests</package></attributes></class><class><name>LineNumberStreamTest</name><environment>Refactory.SmaCC</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Tests</category><attributes><package>SmaCC Tests</package></attributes></class><methods><class-id>Refactory.SmaCC.ParserGeneratorTest</class-id> <category>private</category><body package="SmaCC Tests">isInterestedIn: anObject 	^anObject = TestParser or: 			[anObject = TestParser class 				or: [anObject = TestScanner or: [anObject = TestScanner class]]]</body><body package="SmaCC Tests">methodWrapperReturn: anObject 	"This doesn't run any unwind blocks so don't put any between the wrapper reception of the message and this method."	| context |	context := thisContext.	[context notNil and: [context method class ~= BlockMethodWrapper]] 		whileTrue: [context := context sender].	thisContext unwindUpTo: context.	context resumeWith: anObject</body><body package="SmaCC Tests">removeAllSelectorsFrom: class 	class selectors do: [:each | class removeSelector: each]</body><body package="SmaCC Tests">supportsUnicodeStrings	^	[String with: (Character value: 16rFF00).	true] on: Error			do: [:ex | ex return: false]</body><body package="SmaCC Tests">unwrapCompilationMethods	self		removeAllSelectorsFrom: TestParser;		removeAllSelectorsFrom: TestParser class;		removeAllSelectorsFrom: TestScanner;		removeAllSelectorsFrom: TestScanner class.	wrappers do: [:each | each uninstall]</body><body package="SmaCC Tests">wrapCompilationMethods	| wrapper |	wrappers := OrderedCollection new.	wrapper := Refactory.Wrappers.BlockMethodWrapper 				on: #compile:classified:notifying:				inClass: ClassDescription.	wrapper beforeBlock: 			[:receiver :args | 			(self isInterestedIn: receiver) 				ifTrue: 					[self 						methodWrapperReturn: ((Behavior 								compiledMethodAt: #compile:notifying:ifFail:) valueWithReceiver: receiver									arguments: (Array 											with: args first											with: nil											with: [self methodWrapperReturn: nil]))]].	wrappers add: wrapper.	wrapper := Refactory.Wrappers.BlockMethodWrapper on: #removeSelector:				inClass: ClassDescription.	wrapper beforeBlock: 			[:receiver :args | 			(self isInterestedIn: receiver) 				ifTrue: 					[self methodWrapperReturn: ((Behavior compiledMethodAt: #removeSelector:) 								valueWithReceiver: receiver								arguments: args)]].	wrappers add: wrapper.	wrappers do: [:each | each install]</body></methods><methods><class-id>Refactory.SmaCC.ParserGeneratorTest</class-id> <category>initialize-release</category><body package="SmaCC Tests">setUp	super setUp.	self wrapCompilationMethods</body><body package="SmaCC Tests">tearDown	self unwrapCompilationMethods.	super tearDown</body></methods><methods><class-id>Refactory.SmaCC.ParserGeneratorTest</class-id> <category>testing</category><body package="SmaCC Tests">expressionParserString	^'%left "+" "-" ;%left "*" "/" ;%right "^" ;Expression: Expression ''first'' "+" Expression ''last'' {first + last}	| Expression "-" Expression {''1'' - ''3''}	| Expression "*" Expression {''1'' * ''3''}	| Expression "/" Expression {''1'' / ''3''}	| Expression "^" Expression {''1'' raisedTo: ''3''} 	| "(" Expression ")" {''2''}	| &lt;number&gt; {''1'' value asNumber};'</body><body package="SmaCC Tests">expressionScannerString	^'&lt;number&gt;	:	[0-9]+ (\. [0-9]+) ? ;&lt;whitespace&gt;	:	\s+;'</body><body package="SmaCC Tests">testBadCharacterBlock	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	self should: 			[parserCompiler buildScanner: '&lt;foo&gt; : [a-] ;' andParser: 'Start : &lt;foo&gt;;'.			parserCompiler compileInto: TestScanner andParser: TestParser]		raise: SmaCCParserError</body><body package="SmaCC Tests">testBadSmalltalkBlock	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	self should: 			[parserCompiler buildScanner: '&lt;foo&gt; : foo ;' andParser: 'Start : &lt;foo&gt; {self printOn: };'.			parserCompiler compileInto: TestScanner andParser: TestParser]		raise: SmaCCParserError</body><body package="SmaCC Tests">testBraceRepeatToken	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler 		buildScanner: '&lt;LETTER&gt; : [a-zA-Z_] ;						&lt;DIGIT&gt; : [0-9] ;						&lt;IDENTIFIER&gt;: &lt;LETTER&gt; (&lt;LETTER&gt;|&lt;DIGIT&gt;)*	;						&lt;whitespace&gt;: \s+	;'		andParser: 'begin : &lt;%&lt;IDENTIFIER&gt;%&gt;;'.	parserCompiler compileInto: TestScanner andParser: TestParser.	parserCompiler		compileItemSetsComment;		compileSymbolComment.	self 		assert: ((TestParser parse: 'a b c') collect: [:each | each value]) asArray 				= #('a' 'b' 'c').	self assert: (TestParser parse: '') size = 0</body><body package="SmaCC Tests">testBracketOptionalToken	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler 		buildScanner: '&lt;LETTER&gt; : [a-zA-Z_] ;						&lt;DIGIT&gt; : [0-9] ;						&lt;IDENTIFIER&gt;: &lt;LETTER&gt; (&lt;LETTER&gt;|&lt;DIGIT&gt;)*	;						&lt;whitespace&gt;: \s+	;'		andParser: 'begin : &lt;IDENTIFIER&gt; [":"] begin {''1'' value , ''3''} | &lt;IDENTIFIER&gt; {''1'' value};'.	parserCompiler compileInto: TestScanner andParser: TestParser.	parserCompiler		compileDefinitionComments;		compileItemSetsComment;		compileSymbolComment.	self assert: (TestParser parse: 'a b : c') = 'abc'</body><body package="SmaCC Tests">testCrLf	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler buildScanner: '&lt;a&gt; : \r? \n | \r ;'		andParser: 'A : &lt;a&gt; {true};'.	parserCompiler compileInto: TestScanner andParser: TestParser.	self 		assert: (TestParser parse: (String with: Character cr with: Character lf)).	self 		should: [TestParser parse: (String with: Character cr with: Character cr)]		raise: SmaCCParserError</body><body package="SmaCC Tests">testErrors	| parserCompiler position |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler buildScanner: self expressionScannerString		andParser: self expressionParserString.	parserCompiler compileInto: TestScanner andParser: TestParser.	TestParser parse: '+3*4' onError: [:str :pos | position := pos].	self assert: position = 1.	TestParser parseStream: (ReadStream on: '1+a+4')		onError: [:str :pos | position := pos].	self assert: position = 3</body><body package="SmaCC Tests">testErrorToken	| parserCompiler countingBlock |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler buildScanner: '&lt;name&gt; : [a-zA-Z]+; &lt;whitespace&gt;: \s+;'		andParser: '%left "+"; Expression : &lt;name&gt; | Expression "+" Expression {[Notification signal] on: Error do: [:ex | ex return: (Notification raise)]} | error "+" Expression ;'.	parserCompiler compileInto: TestScanner andParser: TestParser.	countingBlock := 			[:each | 			| count |			count := 0.						[[TestParser parse: each] on: Notification				do: 					[:ex | 					count := count + 1.					[ex resume] on: Error						do: 							[:ex1 | 							ex isResumable: true.							ex1 retry]]] 					on: SmaCCParserError					do: [:ex | ex return].			count].	#(#('a + b + c' 2) #('+ a + b + c' 2) #('a + b +' 1) #('a + 1 / 2 + b + c + 3' 2) #('1 + 1 / 2 + b + c + 3' 1)) 		do: [:each | self assert: (countingBlock value: each first) = each last]</body><body package="SmaCC Tests">testExpressions	#(#LR1 #LALR1) do: 			[:each | 			| parserCompiler |			parserCompiler := SmaCCGrammarCompiler new.			parserCompiler grammar type: each.			parserCompiler buildScanner: self expressionScannerString				andParser: self expressionParserString.			parserCompiler compileInto: TestScanner andParser: TestParser.			self assert: (TestParser parse: '2 + 3 * 4 / 5 ^ 3 ^ 2') 						= (2 + (3 * 4 / (5 raisedTo: (3 raisedTo: 2)))).			self assert: (TestParser parse: '1.0*2/3+4.0^2^3+3') 						= (1.0 * 2 / 3 + (4.0 raisedTo: (2 raisedTo: 3)) + 3).			self assert: (TestParser parse: '(((1 + 2) * 3) ^ 2) ^ 3') 						= (((1 + 2) * 3 raisedTo: 2) raisedTo: 3)]</body><body package="SmaCC Tests">testIgnoreCaseKeywords	| parserCompiler case |	case := SmaCCGrammar ignoreCase.	SmaCCGrammar ignoreCase: true.		[parserCompiler := SmaCCGrammarCompiler new.	parserCompiler 		buildScanner: '&lt;identifier&gt; : [a-z_]+ ; &lt;whitespace&gt; : \s+ ;'		andParser: 'Start ::= "Foo" {true} | &lt;identifier&gt; &lt;identifier&gt; {false};'.	parserCompiler compileInto: TestScanner andParser: TestParser.	self assert: (TestParser parse: 'FOo').	self deny: (TestParser parse: 'FoObAr ASDS')] 			ensure: [SmaCCGrammar ignoreCase: case]</body><body package="SmaCC Tests">testInvertedCharactersBlock	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler 		buildScanner: '&lt;A&gt; : a{1,3} ;						&lt;ID&gt; : [^a]+ ;						&lt;comment&gt; : \s+ ;'		andParser: 'begin : {0} | begin &lt;A&gt; {''1'' + 1} | begin &lt;ID&gt; {''1'' - 1};'.	parserCompiler compileInto: TestScanner andParser: TestParser.	self assert: (TestParser parse: 'aa') = 1.	self assert: (TestParser parse: 'aaaa') = 2.	self assert: (TestParser parse: 'a bab') = 0</body><body package="SmaCC Tests">testKeywords	| parserCompiler size case |	size := SmaCCGrammar maximumCharacterValue.	case := SmaCCGrammar ignoreCase.	SmaCCGrammar ignoreCase: true.	self supportsUnicodeStrings 		ifTrue: [SmaCCGrammar maximumCharacterValue: (2 raisedTo: 16) - 1].		[parserCompiler := SmaCCGrammarCompiler new.	parserCompiler buildScanner: '' andParser: 'Start ::= "Foo" "bar";'.	parserCompiler compileInto: TestScanner andParser: TestParser.	TestParser parse: 'FoObAr'] 			ensure: 				[SmaCCGrammar					ignoreCase: case;					maximumCharacterValue: size]</body><body package="SmaCC Tests">testLALRErrorHandler	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler buildScanner: '&lt;whitespace&gt; : \s+ ;'		andParser: 'Start : Foo "]" Foo ")";					Foo : "a" Bar ;					Bar : "b" | error ;'.	parserCompiler compileInto: TestScanner andParser: TestParser.	self should: [TestParser parse: 'a ] a b )'] raise: SmaCCParserError.	self should: [TestParser parse: 'a ) a b )'] raise: SmaCCParserError.	self should: [TestParser parse: 'a b ] a  ]'] raise: SmaCCParserError</body><body package="SmaCC Tests">testMultipleStartingPositions	| parserCompiler position |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler buildScanner: '&lt;name&gt; : \w+;'		andParser: '%start plus ;					multiply: plus "*" plus {true};					plus: &lt;name&gt; {false} | &lt;name&gt; "+" &lt;name&gt; {false};'.	parserCompiler compileInto: TestScanner andParser: TestParser.	self assert: (TestParser parse: 'a*a').	self assert: (TestParser parse: 'a+a*a').	self should: [TestParser parse: 'a+a'] raise: SmaCCParserError.	self 		deny: (TestParser parse: 'a+a' startingAt: TestParser startingStateForplus).	TestParser 		parse: 'a*a'		startingAt: TestParser startingStateForplus		onError: [:str :pos | position := pos].	self assert: position = 2</body><body package="SmaCC Tests">testNonAssociativeTokens	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler 		buildScanner: '&lt;IDENTIFIER&gt; : \w+ ; &lt;whitespace&gt; : \s+ ;'		andParser: '%left "and" ;					%nonassoc "=" "&lt;=";					%left "+" ;					expr : expr "=" expr {true} | expr "&lt;=" expr {true} | expr "and" expr {true} | expr "+" expr {true} | &lt;IDENTIFIER&gt; {true};'.	parserCompiler compileInto: TestScanner andParser: TestParser.	self should: [TestParser parse: 'a=b=c'] raise: SmaCCParserError.	self should: [TestParser parse: 'a=b&lt;=c'] raise: SmaCCParserError.	self should: [TestParser parse: 'a=b+c=d'] raise: SmaCCParserError.	self assert: (TestParser parse: 'a=b and c=d')</body><body package="SmaCC Tests">testOptionalToken	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler 		buildScanner: '&lt;LETTER&gt; : [a-zA-Z_] ;						&lt;DIGIT&gt; : [0-9] ;						&lt;IDENTIFIER&gt;: &lt;LETTER&gt; (&lt;LETTER&gt;|&lt;DIGIT&gt;)*	;						&lt;whitespace&gt;: \s+	;'		andParser: 'begin : &lt;IDENTIFIER&gt; ":" ? begin {''1'' value , ''3''} | &lt;IDENTIFIER&gt; {''1'' value};'.	parserCompiler compileInto: TestScanner andParser: TestParser.	parserCompiler		compileItemSetsComment;		compileSymbolComment.	self assert: (TestParser parse: 'a b : c') = 'abc'</body><body package="SmaCC Tests">testParenthesesOptionalToken	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler 		buildScanner: '&lt;LETTER&gt; : [a-zA-Z_] ;						&lt;DIGIT&gt; : [0-9] ;						&lt;IDENTIFIER&gt;: &lt;LETTER&gt; (&lt;LETTER&gt;|&lt;DIGIT&gt;)*	;						&lt;whitespace&gt;: \s+	;'		andParser: 'begin : &lt;IDENTIFIER&gt; (":" | "|") begin {''1'' value , ''3''} | &lt;IDENTIFIER&gt; {''1'' value};'.	parserCompiler compileInto: TestScanner andParser: TestParser.	parserCompiler		compileItemSetsComment;		compileSymbolComment.	self assert: (TestParser parse: 'a | b : c') = 'abc'</body><body package="SmaCC Tests">testPriority	| parserCompiler |	TestScanner 		compile: 'all ^self recordAndReportMatch: (Array with: self allId)'.	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler buildScanner: '&lt;a&gt; : \{ | \&lt; \% ;						&lt;all&gt; : .;'		andParser: '%id &lt;all&gt; &lt;a&gt;;  begin : A {true}							| All {false};					A : &lt;a&gt; ;					All: &lt;all&gt;;'.	parserCompiler compileInto: TestScanner andParser: TestParser.	self assert: (TestParser parse: '{').	self assert: (TestParser parse: '&lt;%').	self deny: (TestParser parse: '}')</body><body package="SmaCC Tests">testRecursiveRule	#(#LR1 #LALR1) do: 			[:each | 			| parserCompiler |			parserCompiler := SmaCCGrammarCompiler new.			parserCompiler grammar type: each.			parserCompiler buildScanner: self expressionScannerString				andParser: 'Test: Test1 Recursive;							Test1: &lt;number&gt; {''1'' value};							Recursive: | Recursive "|" &lt;number&gt; {''1'' add: ''3'' value; yourself};'.			parserCompiler compileInto: TestScanner andParser: TestParser.			self 				assert: ((parserCompiler grammar nonTerminalSymbolNamed: 'Recursive') 						firstTerminals 							includes: (parserCompiler grammar keywordTerminalNamed: '"|"')).			self 				assert: (TestParser parse: '2|3|4') = (OrderedCollection 								with: '2'								with: '3'								with: '4')]</body><body package="SmaCC Tests">testReduceReduceConflict	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler buildScanner: '&lt;letter&gt; : \w ;						&lt;whitespace&gt;: \s+	;'		andParser: 'begin : Foo &lt;letter&gt; {true} | Bar &lt;letter&gt; {false};					Foo :  ;					Bar : ;'.	self 		assert: (			[parserCompiler compileInto: TestScanner andParser: TestParser.			false] 					on: SmaCCCompilationNotification					do: 						[:ex | 						('*Reduce/Reduce*' match: ex messageText) 							ifTrue: [ex return: true]							ifFalse: [ex resume: nil]])</body><body package="SmaCC Tests">testReduceRules	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler buildScanner: '					&lt;char&gt; : [a-zA-Z] ; 					&lt;ws&gt; : \s ;'		andParser: '				Start ::= Chars {#liftFirstValue:};				Chars : WS A WS {#liftSecondValue:};				A : WS WS C {#liftLastValue:} | C WS {#liftLastValue:};				WS : &lt;ws&gt; {#nil};				C : &lt;char&gt; {#stringValue:};'.	parserCompiler compileInto: TestScanner andParser: TestParser.	self assert: (TestParser parse: ' a  ') = nil.	self assert: (TestParser parse: '   a ') = 'a'</body><body package="SmaCC Tests">testRepeatingCharactersBlock	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler 		buildScanner: '&lt;A&gt; : a{1,3} ;						&lt;ID&gt; : \w+ ;						&lt;whitespace&gt; : \s+ ;'		andParser: 'begin : {true} | begin &lt;A&gt; {''1''} | begin &lt;ID&gt; {false};'.	parserCompiler compileInto: TestScanner andParser: TestParser.	self assert: (TestParser parse: 'aa').	self deny: (TestParser parse: 'aaaa')</body><body package="SmaCC Tests">testRepeatMultipleToken	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler 		buildScanner: '&lt;LETTER&gt; : [a-zA-Z_] ;						&lt;DIGIT&gt; : [0-9] ;						&lt;IDENTIFIER&gt;: &lt;LETTER&gt; (&lt;LETTER&gt;|&lt;DIGIT&gt;){1,2}	;						&lt;whitespace&gt;: \s+	;'		andParser: 'begin : &lt;IDENTIFIER&gt; + ;'.	parserCompiler compileInto: TestScanner andParser: TestParser.	parserCompiler		compileItemSetsComment;		compileSymbolComment.	self 		assert: ((TestParser parse: 'a1 bb c44') collect: [:each | each value]) 				asArray = #('a1' 'bb' 'c44').	self 		assert: ((TestParser parse: 'aaaaa') collect: [:each | each value]) asArray 				= #('aaa' 'aa').	self should: [TestParser parse: ''] raise: SmaCCParserError</body><body package="SmaCC Tests">testRepeatToken	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler 		buildScanner: '&lt;LETTER&gt; : [a-zA-Z_] ;						&lt;DIGIT&gt; : [0-9] ;						&lt;IDENTIFIER&gt;: &lt;LETTER&gt; (&lt;LETTER&gt;|&lt;DIGIT&gt;)*	;						&lt;whitespace&gt;: \s+	;'		andParser: 'begin : &lt;IDENTIFIER&gt; * ;'.	parserCompiler compileInto: TestScanner andParser: TestParser.	parserCompiler		compileItemSetsComment;		compileSymbolComment.	self 		assert: ((TestParser parse: 'a b c') collect: [:each | each value]) asArray 				= #('a' 'b' 'c').	self assert: (TestParser parse: '') size = 0</body><body package="SmaCC Tests">testReuseCompositeToken	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler 		buildScanner: '&lt;LETTERDIGIT&gt; : [a-zA-Z_] \d ;						&lt;AAorBB&gt; :  aa | bb;						&lt;IDENTIFIER&gt;: &lt;LETTERDIGIT&gt; | &lt;AAorBB&gt;	;						&lt;whitespace&gt;: \s+	;'		andParser: 'begin : &lt;IDENTIFIER&gt; begin {false} | &lt;IDENTIFIER&gt; {true};'.	parserCompiler compileInto: TestScanner andParser: TestParser.	self should: [TestParser parse: '2'] raise: SmaCCParserError.	self assert: (TestParser parse: 'aa').	self assert: (TestParser parse: 'bb').	self assert: (TestParser parse: 'a4').	self should: [TestParser parse: 'ab'] raise: SmaCCParserError.	self should: [TestParser parse: '4b'] raise: SmaCCParserError</body><body package="SmaCC Tests">testReuseSimpleToken	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler 		buildScanner: '&lt;LETTER&gt; : [a-zA-Z_\\] ;						&lt;DIGIT&gt; : [0-9] ;						&lt;IDENTIFIER&gt;: &lt;LETTER&gt; (&lt;LETTER&gt;|&lt;DIGIT&gt;)*	;						&lt;whitespace&gt;: \s+	;'		andParser: 'begin : &lt;IDENTIFIER&gt; begin {false} | &lt;IDENTIFIER&gt; {true};'.	parserCompiler compileInto: TestScanner andParser: TestParser.	self should: [TestParser parse: '2'] raise: SmaCCParserError.	self assert: (TestParser parse: '\')</body><body package="SmaCC Tests">testSimple	| parserCompiler |	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler buildScanner: '&lt;a&gt; : a ;' andParser: 'begin : &lt;a&gt; {true};'.	parserCompiler compileInto: TestScanner andParser: TestParser.	self should: [TestParser parse: '2'] raise: SmaCCParserError.	self assert: (TestParser parse: 'a')</body><body package="SmaCC Tests">testSpecialCharacters	| parserCompiler |	[String with: (Character value: 16rFF00)] on: Error do: [:ex | ^self].	"Unicode characters not supported"	parserCompiler := SmaCCGrammarCompiler new.	parserCompiler buildScanner: '&lt;name&gt; : \x3g \x20 \xFF \xFF1 \xFF00 \cC;'		andParser: 'begin ::= &lt;name&gt; {true};'.	parserCompiler compileInto: TestScanner andParser: TestParser.	self assert: (TestParser 				parse: (String withAll: (#(3 103 16r20 16rFF 16rFF1 16rFF00 2) 								collect: [:each | Character value: each])))</body></methods><methods><class-id>Refactory.SmaCC.LineNumberStreamTest</class-id> <category>tests</category><body package="SmaCC Tests">testCRLFLines	| stream |	stream := SmaCCLineNumberStream 				on: (ReadStream on: (self addCRLFsTo: '1234\1234\1234\1234')).	1 to: 4		do:			[:each | 			self assert: stream lineNumber = each.			4 timesRepeat: [self assert: stream columnNumber = (stream next asInteger - $0 asInteger)].			stream upTo: Character lf]</body><body package="SmaCC Tests">testCRLines	| stream |	stream := SmaCCLineNumberStream 				on: (ReadStream on: (self addCRsTo: '1234\1234\1234\1234')).	1 to: 4		do:			[:each | 			self assert: stream lineNumber = each.			4 timesRepeat: [self assert: stream columnNumber = (stream next asInteger - $0 asInteger)].			stream upTo: Character cr]</body><body package="SmaCC Tests">testEmptyLines	| stream |	stream := SmaCCLineNumberStream 				on: (ReadStream on: (self addCRsTo: '\\\')).	1 to: 4		do: 			[:each | 			self assert: stream lineNumber = each.			stream upTo: Character cr]</body><body package="SmaCC Tests">testForwardPositionCRLFLines	| stream |	stream := SmaCCLineNumberStream 				on: (ReadStream on: (self addCRLFsTo: '1\2\3\4')).	stream position: 3.	self assert: stream lineNumber = 2.	self assert: stream columnNumber = 1</body><body package="SmaCC Tests">testLFLines	| stream |	stream := SmaCCLineNumberStream 				on: (ReadStream on: (self addLFsTo: '1234\1234\1234\1234')).	1 to: 4		do: 			[:each | 			self assert: stream lineNumber = each.			4 timesRepeat: [self assert: stream columnNumber = (stream next asInteger - $0 asInteger)].			stream upTo: Character lf]</body><body package="SmaCC Tests">testNoLines	| stream index |	stream := SmaCCLineNumberStream on: (ReadStream on: 'this is a test').	self assert: stream lineNumber = 1.	index := 1.	stream do: 			[:each | 			self assert: stream lineNumber = 1.			index := index + 1.			self assert: stream columnNumber = index]</body><body package="SmaCC Tests">testPositionCRLFLines	| stream |	stream := SmaCCLineNumberStream 				on: (ReadStream on: (self addCRLFsTo: '1\2\3\4')).	self assert: stream lineNumber = 1.	stream upTo: $5.	self assert: stream lineNumber = 4.	stream position: 0.	self assert: stream lineNumber = 1.	self assert: stream columnNumber = 1.	stream position: 3.	self assert: stream lineNumber = 2.	self assert: stream columnNumber = 1</body><body package="SmaCC Tests">testPositionCRLines	| stream |	stream := SmaCCLineNumberStream 				on: (ReadStream on: (self addCRsTo: '1\2\3\4')).	self assert: stream lineNumber = 1.	stream upTo: $5.	self assert: stream lineNumber = 4.	stream skip: -1.	self assert: stream lineNumber = 4.	self assert: stream columnNumber = 1.	stream position: 0.	self assert: stream lineNumber = 1.	self assert: stream columnNumber = 1.	stream position: 2.	self assert: stream lineNumber = 2.	self assert: stream columnNumber = 1</body></methods><methods><class-id>Refactory.SmaCC.LineNumberStreamTest</class-id> <category>private</category><body package="SmaCC Tests">addCRLFsTo: aString 	^aString copyReplaceAll: '\'		with: (String with: Character cr with: Character lf)</body><body package="SmaCC Tests">addCRsTo: aString 	^aString copyReplaceAll: '\' with: (String with: Character cr)</body><body package="SmaCC Tests">addLFsTo: aString 	^aString copyReplaceAll: '\' with: (String with: Character lf)</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>SmaCCParser</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scanner currentToken errorToken stateStack nodeStack </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Runtime</category><attributes><package>SmaCC Runtime</package></attributes></class><class><name>TestCase</name><environment>XProgramming.SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class><class><name>SmaCCScanner</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream start matchActions matchEnd currentCharacter outputStream lastOutputStreamMatchPosition lastMatchWasEmpty returnMatchBlock </inst-vars><class-inst-vars>keywordMap </class-inst-vars><imports></imports><category>SmaCC Runtime</category><attributes><package>SmaCC Runtime</package></attributes></class></st-source>