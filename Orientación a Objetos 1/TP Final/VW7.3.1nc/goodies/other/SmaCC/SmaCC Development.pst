<?xml version="1.0"?><st-source><!-- Name: SmaCC DevelopmentComment: This package is part of the Smalltalk Compiler-Compiler (SmaCC) written by John Brant and Don Roberts. It contains the classes used to create a new parser. It is only needed when developing parsers. While these classes can be used directly, it is suggested that you use the GUI in the SmaCC Development UI package to create your parsers. If you wish to use the code directly, you can browse the code in the SmaCC Tests for examples. If you want more information about SmaCC, visit http://www.refactory.com/Software/SmaCC/. - - - - - - - - - - - - - - - - - - - - - - - - -Copyright (c) 2002-2003 John Brant, Don RobertsPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.DbIdentifier: storeDbTrace: 3685DevelopmentPrerequisites: #(#(#any 'SmaCC Runtime' '') #(#any 'RBParser' ''))PackageName: SmaCC DevelopmentParcel: #('SmaCC Development')PrerequisiteParcels: #(#('SmaCC Runtime' '') #('RBParser' ''))PrintStringCache: (1.105,brant)Pre-Unload Block: 	[:package | package definedClasses do: [:each | (each canUnderstand: #releaseObjects) ifTrue: [each releaseObjects]]]Date: 6:37:39 am October 13, 2003 --><time-stamp>From VisualWorksÂ® NonCommercial, Pre-Release 7.2 (oct03.1) of October 6, 2003 on October 13, 2003 at 6:37:39 am</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SmaCCScannerCompiler</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>grammar scannerClass scannerDefinitionString </inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			</imports><category>SmaCC Parser Generator</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCScannerCompiler</class-id><body>SmaCCScannerCompiler represents the compiler for the scanner part of the parser.Instance Variables:	grammar	&lt;SmaCCGrammar&gt;	the grammar that defines the scanner	scannerClass	&lt;RBAbstractClass&gt;	the class to compile the scanner into	scannerDefinitionString	&lt;String&gt;	the string that defines the scanner</body></comment><class><name>SmaCCSymbol</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name precedence firstItems </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Parser Generator</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCSymbol</class-id><body>SmaCCSymbol is an abstract class that represents a symbol in the grammar.Subclasses must implement the following messages:	accessing		calculateFirstTerminals	testing		isTerminalInstance Variables:	firstItems	&lt;Collection of: SmaCCTerminalSymbol&gt;	the first terminals that can be produced from us	name	&lt;String&gt;	our name	precedence	&lt;Integer&gt;	our precedence (in case of shift/reduce conflicts)</body></comment><class><name>SmaCCTerminalSymbol</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCSymbol</super><private>false</private><indexed-type>none</indexed-type><inst-vars>regularExpression createIdMethod </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Parser Generator</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCTerminalSymbol</class-id><body>SmaCCTerminalSymbol represents a terminal symbol in our grammar.Instance Variables:	createIdMethod	&lt;Boolean&gt;	should we create a symbolNameId method for this symbol.	regularExpression	&lt;SmaCCRegularExpression&gt;	our regular expression that we must match for this terminal symbol</body></comment><class><name>SmaCCGrammarParser</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>grammar </inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			</imports><category>SmaCC Parser Generator</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCGrammarParser</class-id><body>SmaCCGrammarParser is a parser for grammars.Instance Variables:	grammar	&lt;SmaCCGrammar&gt;	the grammar we are producing</body></comment><class><name>SmaCCEdge</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>toNode characters </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Scanner Generator</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCEdge</class-id><body>SmaCCEdge represents a transition in a Finite Automata (directed graph). It is labeled with the characters (possibly none, indicating an epsilon transition) that cause the transition.Instance Variables:	characters	&lt;SortedCollection of: Character&gt;	The characters that cause the transition. Note that there are no duplicates and all characters are sorted.	toNode	&lt;SmaCCNode&gt;	The node that this is transitioning to.</body></comment><class><name>SmaCCGrammar</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type shiftReduceTable symbols tokens otherStartingSymbols </inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			</imports><category>SmaCC Parser Generator</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCGrammar</class-id><body>SmaCCGrammar represents a LR(1) or a LALR(1) grammar.Instance Variables:	otherStartingSymbols	&lt;Collection of: SmaCCSymbol&gt;	other starting productions. The first production in the grammar is the defaulting starting position, but this can list other starting positions.	shiftReduceTable	&lt;Dictionary key: SmaCCSymbol value: SmaCCAction class&gt;	when we have a shift/reduce conflict how should we handle it. This table contains the left/right associative rules. Left is a reduce action and right is a shift action.	symbols	&lt;OrderedCollection of: SmaCCSymbol&gt;	all symbols in our grammar -- includes both terminal and non-terminal	tokens	&lt;Dictionary key: String value: SmaCCRegularExpressionNode&gt;	the tokens for our scanner	type	&lt;Symbol&gt;	the type of grammar (LALR1 or LR1)</body></comment><class><name>SmaCCScannerParser</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tokens </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Scanner Generator</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCScannerParser</class-id><body>SmaCCScannerParser is the parser for the scanner definition.Instance Variables:	tokens	&lt;Dictionary key: String value: SmaCCRegularExpressionNode&gt;	the tokens that are parsed</body></comment><class><name>SmaCCItemSet</name><environment>Refactory.SmaCC</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Parser Generator</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCItemSet</class-id><body>SmaCCItemSet represents a LALR(1) or a LR(1) item set.Instance Variables:	type	&lt;Symbol&gt;	#LALR1 or #LR1</body></comment><class><name>SmaCCNode</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transitions action id </inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			</imports><category>SmaCC Scanner Generator</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCNode</class-id><body>SmaCCNode is a node in a directed graph.Instance Variables:	action	&lt;SequenceableCollection&gt;	a collection of integers or a symbol. This contains the action to be performed when we match and can't find a longer match.	id	&lt;Integer&gt;	a unique number that allows us to sort the nodes	transitions	&lt;Collection of: SmaCCEdge&gt;	our transitions</body></comment><class><name>SmaCCCompilationNotification</name><environment>Refactory.SmaCC</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Parser Generator</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCCompilationNotification</class-id><body>SmaCCCompilationNotification is a notification that is raised when we discover a problem with the parser. For example, a shift/reduce conflict will raise this notification.</body></comment><class><name>SmaCCScannerScanner</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Scanner Generator</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCScannerScanner</class-id><body>SmaCCScannerScanner is the scanner for the scanner definition</body></comment><class><name>SmaCCAction</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Parser Generator</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCAction</class-id><body>SmaCCAction is an abstract class that represents an action in the LR parsing table.Subclasses must implement the following messages:	accessing		id</body></comment><class><name>SmaCCReduceAction</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCAction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>symbol rhs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Parser Generator</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCReduceAction</class-id><body>SmaCCReduceAction represents a reduce action in our parser's table.Instance Variables:	rhs	&lt;SmaCCRHS&gt;	the rhs that is being reduced	symbol	&lt;SmaCCNonTerminalSymbol&gt;	the symbol that has the rhs</body></comment><class><name>SmaCCShiftAction</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCAction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Parser Generator</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCShiftAction</class-id><body>SmaCCShiftAction represents a shift action in the parser's tables.</body></comment><class><name>SmaCCAcceptAction</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCAction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Parser Generator</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCAcceptAction</class-id><body>SmaCCAcceptAction represents an accept action in the parser (i.e., we have parsed a valid string).</body></comment><class><name>SmaCCRejectAction</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCAction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Parser Generator</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCRejectAction</class-id><body>SmaCCRejectAction represents a reject action in the parsing tables.</body></comment><class><name>SmaCCRHS</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collection reduceAction variableNames </inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			</imports><category>SmaCC Parser Generator</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCRHS</class-id><body>SmaCCRHS represents the right hand side of the production.Instance variables:	collection	&lt;OrderedCollection of: SmaCCSymbol&gt; the collection of symbols that represent the rhs	grammar &lt;SmaCCGrammar&gt; the grammar that the production is in	variableNames	&lt;Dictionary key: String value: Integer&gt;	the name of each symbol in the rhs. These names can be used in the {} code blocks.</body></comment><class><name>SmaCCGrammarCompiler</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>shiftTable itemSets startingStateMap actions parserClass parserDefinitionString scannerCompiler grammar model </inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.*			</imports><category>SmaCC Parser Generator</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCGrammarCompiler</class-id><body>SmaCCGrammarCompiler compiles a SmaCCGrammar.Instance Variables:	actions	&lt;Array&gt;	the action table for the parser. It contains the action (shift/reduce/accept/reject) for each possible state/symbol pair	grammar	&lt;SmaCCGrammar&gt;	our grammar	itemSets	&lt;SequenceableCollection of: SmaCCItemSet&gt;	the item sets for our grammar	model	&lt;RBNameSpace&gt;	where we are compiling our changes into	parserClass	&lt;RBAbstractClass&gt;	the parser class for our changes	parserDefinitionString	&lt;String&gt;	the definition of our parser	scannerCompiler	&lt;SmaCCScannerCompiler&gt;	a compiler for the scanner	shiftTable	&lt;Dictionary key: (Array with: Integer with: SmaCCSymbol) value: Integer&gt;	a table mapping a state/symbol pair to the new state that is aquired by shifting the symbol	startingStateMap	&lt;Dictionary key: SmaCCSymbol value: Integer&gt;	the state for SmaCCSymbol's starting item set</body></comment><class><name>SmaCCRegularExpressionNode</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>action position </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Scanner Generator</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCRegularExpressionNode</class-id><body>SmaCCRegularExpressionNode represents a regular expression. The scanner is represented by a regular expression. These are the initial objects created in producing the scanner. From these nodes, we create a directed graph and then we compile the graph.Subclasses must implement the following messages:	accessing		possibleMatchesSize	private		asNFAStartingWith:		possibleMatchesDo:on:Instance Variables:	action	&lt;SequenceableCollection&gt;	the actions to be performed when we find a match	position	&lt;Integer&gt;	the position of the RE in the scanner. If we have multiple matches, we prefer the ones listed first.</body></comment><class><name>SmaCCCharacterRENode</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCRegularExpressionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>characters </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Scanner Generator</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCCharacterRENode</class-id><body>SmaCCCharacterRENode represents a regular expression that matches one of a set of characters.Instance Variables:	characters	&lt;SortedCollection of: Character&gt;	The characters that this node can accept. Note that there are no duplicates and all characters are sorted.</body></comment><class><name>SmaCCRepeatingRENode</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCRegularExpressionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>node minimumMatches maximumMatches </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Scanner Generator</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCRepeatingRENode</class-id><body>SmaCCRepeatingRENode represents a repeating node in a regular expression.Instance Variables:	maximumMatches	&lt;Integer&gt;	the minimum number of matches required	minimumMatches	&lt;Integer&gt;	the maximum number of matches allowed. An infinite amount of matches is represented by (SmaCCRepeatingRENode finiteInfinity).	node	&lt;SmaCCRegularExpressionNode&gt;	what we need to match</body></comment><class><name>SmaCCSequenceRENode</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCRegularExpressionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nodes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Scanner Generator</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCSequenceRENode</class-id><body>SmaCCSequenceRENode represents a regular expression that is made up of several other regular expressions concatenated together.Instance Variables:	nodes	&lt;Collection of: SmaCCRegularExpressionNode&gt;	our children nodes in left-to-right order</body></comment><class><name>SmaCCNonTerminalSymbol</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCSymbol</super><private>false</private><indexed-type>none</indexed-type><inst-vars>productions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Parser Generator</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCNonTerminalSymbol</class-id><body>SmaCCNonTerminalSymbol represents a non-terminal symbol in our grammar.Instance Variables:	productions	&lt;SequenceableCollection of: SmaCCRHS&gt;	our rhs' for the symbol</body></comment><class><name>SmaCCStartingSymbol</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCNonTerminalSymbol</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Parser Generator</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCStartingSymbol</class-id><body>SmaCCStartingSymbol is the starting symbol in the grammar. A grammar can only have one starting symbol, but it can have may different starting item sets.</body></comment><class><name>SmaCCLR1Item</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rhs symbol location followers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Parser Generator</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCLR1Item</class-id><body>SmaCCLR1Item represents an item in a SmaCCItemSet.Instance Variables:	followers	&lt;SmaCCSymbolSet&gt;	all possible symbols that can follow this production in this state	location	&lt;Integer&gt;	the position in the rhs of the production we are at	rhs	&lt;SmaCCRHS&gt;	the rhs of the production	symbol	&lt;SmaCCSymbol&gt;	the symbol for the production</body></comment><class><name>SmaCCOrRENode</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCRegularExpressionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nodes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Scanner Generator</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCOrRENode</class-id><body>SmaCCOrRENode is a SmaCCRegularExpressionNode that represents an alternative.Instance Variables:	nodes	&lt;Collection of: SmaCCRegularExpressionNode&gt;	our possible choices</body></comment><class><name>SmaCCGrammarScanner</name><environment>Refactory.SmaCC</environment><super>Refactory.SmaCC.SmaCCScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Parser Generator</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCGrammarScanner</class-id><body>SmaCCGrammarScanner is the scanner for the grammar parser</body></comment><class><name>SmaCCSymbolSet</name><environment>Refactory.SmaCC</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>symbols components </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Parser Generator</category><attributes><package>SmaCC Development</package></attributes></class><comment><class-id>Refactory.SmaCC.SmaCCSymbolSet</class-id><body>SmaCCSymbolSet represents a set of follow symbols in the LALR(1) item sets.Instance Variables:	components	&lt;Collection of: SmaCCSymbolSet&gt;	other SmaCCSymbolSets that we depend on, we include all items in these sets also	symbols	&lt;Collection of: SmaCCTerminalSymbol&gt;	our follow symbols</body></comment><shared-variable><name>Reject</name><environment>Refactory.SmaCC.SmaCCRejectAction</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>SmaCC Development</package></attributes></shared-variable><shared-variable><name>SentinelSymbol</name><environment>Refactory.SmaCC.SmaCCSymbol</environment><private>false</private><constant>false</constant><category>variables</category><attributes><package>SmaCC Development</package></attributes></shared-variable><shared-variable><name>EmptySymbol</name><environment>Refactory.SmaCC.SmaCCSymbol</environment><private>false</private><constant>false</constant><category>variables</category><attributes><package>SmaCC Development</package></attributes></shared-variable><shared-variable><name>ErrorSymbol</name><environment>Refactory.SmaCC.SmaCCSymbol</environment><private>false</private><constant>false</constant><category>variables</category><attributes><package>SmaCC Development</package></attributes></shared-variable><shared-variable><name>IsExpressions</name><environment>Refactory.SmaCC.SmaCCEdge</environment><private>true</private><constant>false</constant><category>compiling</category><attributes><package>SmaCC Development</package></attributes></shared-variable><shared-variable><name>Shift</name><environment>Refactory.SmaCC.SmaCCShiftAction</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>SmaCC Development</package></attributes></shared-variable><shared-variable><name>MaximumCharacterValue</name><environment>Refactory.SmaCC.SmaCCGrammar</environment><private>false</private><constant>false</constant><category>SmaCC Development</category><initializer>255</initializer><attributes><package>SmaCC Development</package></attributes></shared-variable><shared-variable><name>IgnoreCase</name><environment>Refactory.SmaCC.SmaCCGrammar</environment><private>false</private><constant>false</constant><category>SmaCC Development</category><initializer>false</initializer><attributes><package>SmaCC Development</package></attributes></shared-variable><shared-variable><name>MaxSubNodesInMethod</name><environment>Refactory.SmaCC.SmaCCNode</environment><private>false</private><constant>false</constant><category>variables</category><attributes><package>SmaCC Development</package></attributes></shared-variable><shared-variable><name>NextId</name><environment>Refactory.SmaCC.SmaCCNode</environment><private>false</private><constant>false</constant><category>variables</category><attributes><package>SmaCC Development</package></attributes></shared-variable><methods><class-id>Refactory.SmaCC.SmaCCScannerCompiler</class-id> <category>compiling-scanner</category><body package="SmaCC Development">addActionsForSymbols	| selectorMap |	selectorMap := Dictionary new.	(1 to: self symbols size) with: self symbols		do: 			[:index :each | 			each regularExpression ifNotNil: 					[:eachRegex | 					(self scannerActionFor: each name) 						ifNotNil: [:selector | selectorMap at: index put: selector].					eachRegex action: index].			each createIdMethod ifTrue: [self compileTokenIdMethodFor: each]].	^selectorMap</body><body package="SmaCC Development">addSpecialSymbols	grammar tokens keysDo: 			[:each | 			(self scannerActionFor: each) notNil 				ifTrue: [grammar terminalSymbolNamed: each]]</body><body package="SmaCC Development">compileEmptySymbolTokenId	| stream |	stream := WriteStream on: (String new: 100).	stream		nextPutAll: 'emptySymbolTokenId';		cr;		tab;		nextPutAll: '^';		nextPutAll: (self symbols indexOf: SmaCCSymbol empty) printString.	self scannerClass compile: stream contents classified: #'generated-tokens'</body><body package="SmaCC Development">compileErrorSymbolTokenId	| stream |	stream := WriteStream on: (String new: 100).	stream		nextPutAll: 'errorTokenId';		cr;		tab;		nextPutAll: '^';		nextPutAll: (self symbols indexOf: SmaCCSymbol error) printString.	self scannerClass compile: stream contents classified: #'generated-tokens'</body><body package="SmaCC Development">compileKeywordInitializerUsing: aDictionary selectorMap: selectorMapDictionary 	| stream dataStream |	aDictionary isEmpty ifTrue: [^self].	stream := WriteStream on: String new.	stream nextPutAll: 'initializeKeywordMap'.	stream nextPutAll: ' keywordMap :=  Dictionary new. '.	dataStream := WriteStream on: Array new.	aDictionary keysAndValuesDo: 			[:key :value | 			value keys asSortedCollection do: 					[:each | 					dataStream nextPut: (Array 								with: (selectorMapDictionary at: key ifAbsent: [key])								with: each								with: (selectorMapDictionary at: (value at: each) ifAbsent: [value at: each]))]].	stream		nextPutAll: '#(';		cr.	dataStream contents do: 			[:each | 			stream nextPutAll: '#('.			each do: [:item | item storeOn: stream] separatedBy: [stream nextPut: $ ].			stream nextPut: $)]		separatedBy: [stream cr].	stream nextPut: $).	stream 		nextPutAll: ' do: [:each | (keywordMap at: each first ifAbsentPut: [Dictionary new]) at: (each at: 2) put: each last]. ^keywordMap'.	scannerClass metaclass 		compile: (RBParser parseMethod: stream contents) formattedCode		classified: #'generated-initialization'</body><body package="SmaCC Development">compileScanner	| regex selectorMap regexPartition dfa keywordmap |	regex := nil.	self addSpecialSymbols.	grammar 		symbols: (self symbols asSortedCollection: 					[:a :b | 					| aRegex bRegex |					aRegex := a regularExpression.					bRegex := b regularExpression.					bRegex isNil or: 							[aRegex notNil 								and: [(aRegex position ifNil: [0]) &lt; (bRegex position ifNil: [0])]]]).	selectorMap := self addActionsForSymbols.	regexPartition := self regularExpressionsPartitionedByIsKeyword.	regex := self generalRegexesFrom: regexPartition.	dfa := regex asDFA.	keywordmap := Dictionary new.	(regexPartition at: true ifAbsent: [#()]) do: 			[:each | 			| action strings newAction |			strings := each possibleMatches.			1 to: strings size				do: 					[:i | 					newAction := dfa simulate: (ReadStream on: (strings at: i)).					i = 1 						ifTrue: [action := newAction]						ifFalse: [action = newAction ifFalse: [action := nil]]].			action isNil 				ifTrue: [regex := regex | each]				ifFalse: 					[action do: 							[:state | 							strings do: 									[:string | 									(keywordmap at: state ifAbsentPut: [Dictionary new]) at: string										put: each action]]]].	self compileKeywordInitializerUsing: keywordmap selectorMap: selectorMap.	regex asDFA compileInto: scannerClass usingSelectorMap: selectorMap.	self compileEmptySymbolTokenId.	self compileErrorSymbolTokenId.	SmaCCGrammar ignoreCase 		ifTrue: 			[scannerClass compile: 'keywordFor: aString 	^aString asUppercase'				classified: #'generated-scanner']</body><body package="SmaCC Development">compileScannerDefinitionComment	| stream |	stream := WriteStream on: (String new: 1000).	stream		nextPutAll: 'scannerDefinitionComment';		cr;		cr;		tab;		nextPut: $";		nextPutAll: (scannerDefinitionString copyReplaceAll: '"' with: '""');		nextPut: $".	self scannerClass metaclass compile: stream contents		classified: #'generated-comments'</body><body package="SmaCC Development">compileTokenIdMethodFor: aTerminalSymbol 	| stream |	stream := WriteStream on: (String new: 1000).	stream		nextPutAll: (aTerminalSymbol name copyFrom: 2					to: aTerminalSymbol name size - 1);		nextPutAll: 'Id';		cr;		tab;		nextPutAll: '^';		nextPutAll: (self symbols indexOf: aTerminalSymbol) printString.	scannerClass compile: stream contents classified: #'generated-tokens'</body><body package="SmaCC Development">generalRegexesFrom: regexPartition 	| regexs combinedRegex |	regexs := regexPartition at: false ifAbsent: [regexPartition at: true].	combinedRegex := regexs first.	2 to: regexs size		do: [:i | combinedRegex := combinedRegex | (regexs at: i)].	^combinedRegex</body><body package="SmaCC Development">regularExpressionsPartitionedByIsKeyword	| regexPartition |	regexPartition := Dictionary new.	self symbols do: 			[:each | 			each regularExpression ifNotNil: 					[:regex | 					(regexPartition at: regex isKeywordLiteral						ifAbsentPut: [OrderedCollection new]) add: regex]].	^regexPartition</body><body package="SmaCC Development">scannerActionFor: aString 	| selector |	aString size &gt; 2 ifFalse: [^nil].	selector := (aString copyFrom: 2 to: aString size - 1) asSymbol.	^((scannerClass definesMethod: selector) 		and: [(Object canUnderstand: selector) not and: [selector numArgs = 0]]) 			ifTrue: [selector]			ifFalse: [nil]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScannerCompiler</class-id> <category>initialize-release</category><body package="SmaCC Development">grammar: aGrammar	grammar := aGrammar</body><body package="SmaCC Development">parseTokens	grammar tokens: (SmaCCScannerParser parse: scannerDefinitionString)</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScannerCompiler</class-id> <category>accessing</category><body package="SmaCC Development">scannerClass	^scannerClass</body><body package="SmaCC Development">scannerClass: anObject	scannerClass := anObject</body><body package="SmaCC Development">scannerDefinitionString: aString	scannerDefinitionString := aString</body><body package="SmaCC Development">symbols	^grammar symbols</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSymbol</class-id> <category>accessing</category><body package="SmaCC Development">calculateFirstTerminals	^self subclassResponsibility</body><body package="SmaCC Development">createIdMethod	^false</body><body package="SmaCC Development">firstTerminals	^firstItems</body><body package="SmaCC Development">isEmptySymbol	^self = self class empty</body><body package="SmaCC Development">name	^name</body><body package="SmaCC Development">precedence	^precedence</body><body package="SmaCC Development">precedence: anInteger	precedence := anInteger</body><body package="SmaCC Development">productionsDo: aBlock</body><body package="SmaCC Development">regularExpression	^nil</body><body package="SmaCC Development">size	^0</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSymbol</class-id> <category>testing</category><body package="SmaCC Development">isStartingSymbol	^false</body><body package="SmaCC Development">isTerminal	^self subclassResponsibility</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSymbol</class-id> <category>printing</category><body package="SmaCC Development">printOn: aStream 	aStream nextPutAll: name</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSymbol</class-id> <category>initialize-release</category><body package="SmaCC Development">name: aString 	name := aString.	firstItems := Set new</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSymbol class</class-id> <category>instance creation</category><body package="SmaCC Development">empty	EmptySymbol isNil 		ifTrue: [EmptySymbol := SmaCCTerminalSymbol name: 'E O F'].	^EmptySymbol</body><body package="SmaCC Development">error	ErrorSymbol isNil 		ifTrue: [ErrorSymbol := SmaCCTerminalSymbol name: 'error'].	^ErrorSymbol</body><body package="SmaCC Development">name: aString 	^(self new)		name: aString;		yourself</body><body package="SmaCC Development">releaseObjects	EmptySymbol := nil.	SentinelSymbol := nil.	ErrorSymbol := nil</body><body package="SmaCC Development">sentinel	SentinelSymbol isNil 		ifTrue: [SentinelSymbol := SmaCCTerminalSymbol name: 'S e n t i n e l'].	^SentinelSymbol</body></methods><methods><class-id>Refactory.SmaCC.SmaCCTerminalSymbol</class-id> <category>accessing</category><body package="SmaCC Development">createIdMethod	^createIdMethod</body><body package="SmaCC Development">createIdMethod: aBoolean	createIdMethod := aBoolean</body><body package="SmaCC Development">regularExpression	^regularExpression</body><body package="SmaCC Development">regularExpression: aScannerNode	regularExpression := aScannerNode</body></methods><methods><class-id>Refactory.SmaCC.SmaCCTerminalSymbol</class-id> <category>testing</category><body package="SmaCC Development">isTerminal	^true</body></methods><methods><class-id>Refactory.SmaCC.SmaCCTerminalSymbol</class-id> <category>initialize-release</category><body package="SmaCC Development">name: aString 	super name: aString.	firstItems add: self.	createIdMethod := false</body></methods><methods><class-id>Refactory.SmaCC.SmaCCTerminalSymbol</class-id> <category>private</category><body package="SmaCC Development">calculateFirstTerminals	^false</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammarParser</class-id> <category>generated-reduction actions</category><body package="SmaCC Development">reduceActionForFile1: nodes 	^grammar		addEmptySymbol;		yourself</body><body package="SmaCC Development">reduceActionForIdMethodLine1: nodes 	(nodes at: 2) do: [:each | grammar makeTokenIdMethodFor: each].	^nil</body><body package="SmaCC Development">reduceActionForIdTokens1: nodes 	^OrderedCollection with: (nodes at: 1) value</body><body package="SmaCC Development">reduceActionForIdTokens2: nodes 	^(nodes at: 1)		add: (nodes at: 2) value;		yourself</body><body package="SmaCC Development">reduceActionForLeftLine1: nodes 	(nodes at: 2) do: 			[:each | 			grammar				leftPrecedenceFor: each;				setOperatorPrecedenceFor: each to: scanner lineNumber].	^nil</body><body package="SmaCC Development">reduceActionForNonAssociativeLine1: nodes 	(nodes at: 2) do: 			[:each | 			grammar				nonAssociativePrecedenceFor: each;				setOperatorPrecedenceFor: each to: scanner lineNumber].	^nil</body><body package="SmaCC Development">reduceActionForParserRule1: nodes 	^nodes at: 1</body><body package="SmaCC Development">reduceActionForParserRule2: nodes 	^self verifyCodeToken: (nodes at: 2) for: (nodes at: 1)</body><body package="SmaCC Development">reduceActionForParserRules1: nodes 	^(nodes at: 1)		add: (nodes at: 3);		yourself</body><body package="SmaCC Development">reduceActionForProductionRule1: nodes 	| symbol |	symbol := grammar nonTerminalSymbolNamed: (nodes at: 1) value.	(nodes at: 3) do: [:each | symbol addProduction: each].	^symbol</body><body package="SmaCC Development">reduceActionForRightLine1: nodes 	(nodes at: 2) do: 			[:each | 			grammar				rightPrecedenceFor: each;				setOperatorPrecedenceFor: each to: scanner lineNumber].	^nil</body><body package="SmaCC Development">reduceActionForRule1: nodes 	grammar setStartSymbolIfNone: (nodes at: 1).	^nil</body><body package="SmaCC Development">reduceActionForSimpleTerm1: nodes 	^SmaCCRHS new</body><body package="SmaCC Development">reduceActionForSimpleTerm2: nodes 	^(nodes at: 1)		add: (nodes at: 2);		yourself</body><body package="SmaCC Development">reduceActionForSimpleTerm3: nodes 	^(nodes at: 1)		add: (grammar makeOptionalSymbolFor: (nodes at: 2));		yourself</body><body package="SmaCC Development">reduceActionForSimpleTerm4: nodes 	^(nodes at: 1)		add: (grammar makeRepeatSymbolFor: (nodes at: 2));		yourself</body><body package="SmaCC Development">reduceActionForSimpleTerm5: nodes 	^(nodes at: 1)		add: (grammar makeRepeatMultipleSymbolFor: (nodes at: 2));		yourself</body><body package="SmaCC Development">reduceActionForSimpleTerms1: nodes 	^OrderedCollection with: (nodes at: 1)</body><body package="SmaCC Development">reduceActionForSimpleTerms2: nodes 	^(nodes at: 1)		add: (nodes at: 3);		yourself</body><body package="SmaCC Development">reduceActionForStartingTokens1: nodes 	^grammar 		addStartingSymbol: (grammar nonTerminalSymbolNamed: (nodes at: 1) value)</body><body package="SmaCC Development">reduceActionForStartingTokens2: nodes 	^grammar 		addStartingSymbol: (grammar nonTerminalSymbolNamed: (nodes at: 2) value)</body><body package="SmaCC Development">reduceActionForTerm1: nodes 	^grammar keywordTerminalNamed: (nodes at: 1) value</body><body package="SmaCC Development">reduceActionForTerm2: nodes 	^grammar terminalSymbolNamed: (nodes at: 1) value		ifAbsent: 			[currentToken := nodes at: 1.			self reportErrorMessage: 'Token not specified']</body><body package="SmaCC Development">reduceActionForTerm3: nodes 	^grammar nonTerminalSymbolNamed: (nodes at: 1) value</body><body package="SmaCC Development">reduceActionForTerm4: nodes 	^SmaCCSymbol error</body><body package="SmaCC Development">reduceActionForTerm5: nodes 	^grammar makeGroupFor: (nodes at: 2)</body><body package="SmaCC Development">reduceActionForTerm6: nodes 	^grammar makeRepeatSymbolFor: (grammar makeGroupFor: (nodes at: 2))</body><body package="SmaCC Development">reduceActionForTerm7: nodes 	^grammar makeOptionalSymbolFor: (grammar makeGroupFor: (nodes at: 2))</body><body package="SmaCC Development">reduceActionForTerms1: nodes 	^SmaCCRHS new</body><body package="SmaCC Development">reduceActionForTerms2: nodes 	^(nodes at: 1)		add: (nodes at: 2);		yourself</body><body package="SmaCC Development">reduceActionForTerms3: nodes 	^(nodes at: 1)		add: (nodes at: 2);		nameLastItem: ((nodes at: 3) value copyFrom: 2					to: (nodes at: 3) value size - 1);		yourself</body><body package="SmaCC Development">reduceActionForTerms4: nodes 	^(nodes at: 1)		add: (grammar makeOptionalSymbolFor: (nodes at: 2));		yourself</body><body package="SmaCC Development">reduceActionForTerms5: nodes 	^(nodes at: 1)		add: (grammar makeOptionalSymbolFor: (nodes at: 2));		nameLastItem: ((nodes at: 4) value copyFrom: 2					to: (nodes at: 4) value size - 1);		yourself</body><body package="SmaCC Development">reduceActionForTerms6: nodes 	^(nodes at: 1)		add: (grammar makeRepeatSymbolFor: (nodes at: 2));		yourself</body><body package="SmaCC Development">reduceActionForTerms7: nodes 	^(nodes at: 1)		add: (grammar makeRepeatSymbolFor: (nodes at: 2));		nameLastItem: ((nodes at: 4) value copyFrom: 2					to: (nodes at: 4) value size - 1);		yourself</body><body package="SmaCC Development">reduceActionForTerms8: nodes 	^(nodes at: 1)		add: (grammar makeRepeatMultipleSymbolFor: (nodes at: 2));		yourself</body><body package="SmaCC Development">reduceActionForTerms9: nodes 	^(nodes at: 1)		add: (grammar makeRepeatMultipleSymbolFor: (nodes at: 2));		nameLastItem: ((nodes at: 4) value copyFrom: 2					to: (nodes at: 4) value size - 1);		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammarParser</class-id> <category>accessing</category><body package="SmaCC Development">grammar	^grammar</body><body package="SmaCC Development">grammar: aGrammar	grammar := aGrammar</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammarParser</class-id> <category>initialize-release</category><body package="SmaCC Development">initialize	super initialize.	grammar := SmaCCGrammar new</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammarParser</class-id> <category>private</category><body package="SmaCC Development">verifyCodeToken: codeToken for: aRHS 	| code |	code := codeToken value copyFrom: 2 to: codeToken value size - 1.	RBParser parseExpression: code		onError: 			[:string :position | 			currentToken := nil.			scanner position: codeToken startPosition + position.			self reportErrorMessage: string].	aRHS reduceAction: code.	^aRHS</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammarParser</class-id> <category>generated-tables</category><body package="SmaCC Development">reduceTable	^#(#(26 3 #reduceActionForIdMethodLine1:)#(27 3 #reduceFor:)#(28 1 #reduceFor:)#(28 2 #reduceFor:)#(29 1 #reduceActionForIdTokens1:)#(29 2 #reduceActionForIdTokens2:)#(30 1 #reduceActionForStartingTokens1:)#(30 2 #reduceActionForStartingTokens2:)#(31 3 #reduceActionForNonAssociativeLine1:)#(32 1 #reduceActionForTerm1:)#(32 1 #reduceActionForTerm2:)#(32 1 #reduceActionForTerm3:)#(32 1 #reduceActionForTerm4:)#(32 3 #reduceActionForTerm5:)#(32 3 #reduceActionForTerm6:)#(32 3 #reduceActionForTerm7:)#(33 1 #reduceFor:)#(34 4 #reduceActionForProductionRule1:)#(35 3 #reduceActionForParserRules1:)#(35 1 #reduceFor:)#(36 1 #reduceActionForParserRule1:)#(36 2 #reduceActionForParserRule2:)#(37 0 #reduceActionForTerms1:)#(37 2 #reduceActionForTerms2:)#(37 3 #reduceActionForTerms3:)#(37 3 #reduceActionForTerms4:)#(37 4 #reduceActionForTerms5:)#(37 3 #reduceActionForTerms6:)#(37 4 #reduceActionForTerms7:)#(37 3 #reduceActionForTerms8:)#(37 4 #reduceActionForTerms9:)#(38 3 #reduceActionForRightLine1:)#(39 1 #reduceActionForRule1:)#(39 1 #reduceFor:)#(39 1 #reduceFor:)#(39 1 #reduceFor:)#(39 1 #reduceFor:)#(39 1 #reduceFor:)#(40 1 #reduceActionForFile1:)#(41 1 #reduceActionForSimpleTerms1:)#(41 3 #reduceActionForSimpleTerms2:)#(42 0 #reduceActionForSimpleTerm1:)#(42 2 #reduceActionForSimpleTerm2:)#(42 3 #reduceActionForSimpleTerm3:)#(42 3 #reduceActionForSimpleTerm4:)#(42 3 #reduceActionForSimpleTerm5:)#(45 1 #reduceFor:)#(45 2 #reduceFor:)#(46 3 #reduceActionForLeftLine1:))</body><body package="SmaCC Development">transitionTable	^#(#[1 0 9 0 3 0 13 0 4 0 17 0 5 0 21 0 6 0 25 0 8 0 29 0 20 0 33 0 26 0 37 0 27 0 41 0 31 0 45 0 34 0 49 0 38 0 53 0 39 0 57 0 40 0 61 0 45 0 65 0 46]#[1 0 69 0 20 0 73 0 30]#[1 0 77 0 19 0 81 0 29]#[1 0 85 0 10 0 89 0 12 0 93 0 16 0 97 0 17 0 101 0 19 0 105 0 20 0 109 0 21 0 113 0 28 0 117 0 32]#[1 0 85 0 10 0 89 0 12 0 93 0 16 0 97 0 17 0 101 0 19 0 105 0 20 0 109 0 21 0 121 0 28 0 117 0 32]#[1 0 85 0 10 0 89 0 12 0 93 0 16 0 97 0 17 0 101 0 19 0 105 0 20 0 109 0 21 0 125 0 28 0 117 0 32]#[0 0 129 0 25]#[0 0 150 0 3 0 4 0 5 0 6 0 8 0 20 0 43]#[0 0 154 0 3 0 4 0 5 0 6 0 8 0 20 0 43]#[0 0 146 0 3 0 4 0 5 0 6 0 8 0 20 0 43]#[0 0 134 0 3 0 4 0 5 0 6 0 8 0 20 0 43]#[0 0 142 0 3 0 4 0 5 0 6 0 8 0 20 0 43]#[0 0 190 0 3 0 4 0 5 0 6 0 8 0 20 0 43]#[0 0 0 0 43]#[1 0 9 0 3 0 13 0 4 0 17 0 5 0 21 0 6 0 25 0 8 0 29 0 20 0 33 0 26 0 37 0 27 0 41 0 31 0 45 0 34 0 49 0 38 0 133 0 39 0 158 0 43 0 65 0 46]#[0 0 138 0 3 0 4 0 5 0 6 0 8 0 20 0 43]#[0 0 30 0 7 0 20]#[1 0 137 0 7 0 141 0 20]#[0 0 22 0 7 0 19]#[1 0 145 0 7 0 149 0 19]#[1 0 170 0 9 0 170 0 10 0 170 0 12 0 170 0 13 0 170 0 16 0 170 0 17 0 170 0 19 0 170 0 20 0 170 0 21 0 153 0 41 0 157 0 42]#[1 0 170 0 2 0 170 0 9 0 170 0 10 0 170 0 12 0 170 0 16 0 170 0 17 0 170 0 19 0 170 0 20 0 170 0 21 0 161 0 41 0 157 0 42]#[0 0 54 0 1 0 2 0 7 0 9 0 10 0 11 0 12 0 13 0 14 0 15 0 16 0 17 0 19 0 20 0 21 0 23 0 24]#[1 0 170 0 9 0 170 0 10 0 170 0 12 0 170 0 14 0 170 0 16 0 170 0 17 0 170 0 19 0 170 0 20 0 170 0 21 0 165 0 41 0 157 0 42]#[0 0 46 0 1 0 2 0 7 0 9 0 10 0 11 0 12 0 13 0 14 0 15 0 16 0 17 0 19 0 20 0 21 0 23 0 24]#[0 0 50 0 1 0 2 0 7 0 9 0 10 0 11 0 12 0 13 0 14 0 15 0 16 0 17 0 19 0 20 0 21 0 23 0 24]#[0 0 42 0 1 0 2 0 7 0 9 0 10 0 11 0 12 0 13 0 14 0 15 0 16 0 17 0 19 0 20 0 21 0 23 0 24]#[1 0 169 0 7 0 85 0 10 0 89 0 12 0 93 0 16 0 97 0 17 0 101 0 19 0 105 0 20 0 109 0 21 0 173 0 32]#[0 0 14 0 7 0 10 0 12 0 16 0 17 0 19 0 20 0 21]#[1 0 177 0 7 0 85 0 10 0 89 0 12 0 93 0 16 0 97 0 17 0 101 0 19 0 105 0 20 0 109 0 21 0 173 0 32]#[1 0 181 0 7 0 85 0 10 0 89 0 12 0 93 0 16 0 97 0 17 0 101 0 19 0 105 0 20 0 109 0 21 0 173 0 32]#[1 0 94 0 7 0 94 0 9 0 94 0 10 0 94 0 12 0 94 0 16 0 94 0 17 0 94 0 19 0 94 0 20 0 94 0 21 0 94 0 23 0 185 0 35 0 189 0 36 0 193 0 37]#[0 0 194 0 3 0 4 0 5 0 6 0 8 0 20 0 43]#[0 0 10 0 3 0 4 0 5 0 6 0 8 0 20 0 43]#[0 0 34 0 7 0 20]#[0 0 6 0 3 0 4 0 5 0 6 0 8 0 20 0 43]#[0 0 26 0 7 0 19]#[1 0 197 0 9 0 201 0 13]#[1 0 162 0 2 0 162 0 9 0 85 0 10 0 89 0 12 0 162 0 13 0 162 0 14 0 93 0 16 0 97 0 17 0 101 0 19 0 105 0 20 0 109 0 21 0 205 0 32]#[1 0 209 0 2 0 197 0 9]#[1 0 197 0 9 0 213 0 14]#[0 0 38 0 3 0 4 0 5 0 6 0 8 0 20 0 43]#[0 0 18 0 7 0 10 0 12 0 16 0 17 0 19 0 20 0 21]#[0 0 130 0 3 0 4 0 5 0 6 0 8 0 20 0 43]#[0 0 198 0 3 0 4 0 5 0 6 0 8 0 20 0 43]#[1 0 217 0 7 0 221 0 9]#[0 0 82 0 7 0 9]#[1 0 86 0 7 0 86 0 9 0 85 0 10 0 89 0 12 0 93 0 16 0 97 0 17 0 101 0 19 0 105 0 20 0 109 0 21 0 225 0 23 0 229 0 32]#[1 0 170 0 2 0 170 0 9 0 170 0 10 0 170 0 12 0 170 0 13 0 170 0 14 0 170 0 16 0 170 0 17 0 170 0 19 0 170 0 20 0 170 0 21 0 233 0 42]#[0 0 62 0 1 0 2 0 7 0 9 0 10 0 11 0 12 0 13 0 14 0 15 0 16 0 17 0 19 0 20 0 21 0 23 0 24]#[1 0 237 0 1 0 174 0 2 0 174 0 9 0 174 0 10 0 241 0 11 0 174 0 12 0 174 0 13 0 174 0 14 0 245 0 15 0 174 0 16 0 174 0 17 0 174 0 19 0 174 0 20 0 174 0 21]#[0 0 66 0 1 0 2 0 7 0 9 0 10 0 11 0 12 0 13 0 14 0 15 0 16 0 17 0 19 0 20 0 21 0 23 0 24]#[0 0 58 0 1 0 2 0 7 0 9 0 10 0 11 0 12 0 13 0 14 0 15 0 16 0 17 0 19 0 20 0 21 0 23 0 24]#[0 0 74 0 3 0 4 0 5 0 6 0 8 0 20 0 43]#[1 0 94 0 7 0 94 0 9 0 94 0 10 0 94 0 12 0 94 0 16 0 94 0 17 0 94 0 19 0 94 0 20 0 94 0 21 0 94 0 23 0 249 0 36 0 193 0 37]#[0 0 90 0 7 0 9]#[1 0 253 0 1 0 98 0 7 0 98 0 9 0 98 0 10 1 1 0 11 0 98 0 12 1 5 0 15 0 98 0 16 0 98 0 17 0 98 0 19 0 98 0 20 0 98 0 21 0 98 0 23 1 9 0 24]#[1 0 166 0 2 0 166 0 9 0 85 0 10 0 89 0 12 0 166 0 13 0 166 0 14 0 93 0 16 0 97 0 17 0 101 0 19 0 105 0 20 0 109 0 21 0 205 0 32]#[0 0 178 0 2 0 9 0 10 0 12 0 13 0 14 0 16 0 17 0 19 0 20 0 21]#[0 0 182 0 2 0 9 0 10 0 12 0 13 0 14 0 16 0 17 0 19 0 20 0 21]#[0 0 186 0 2 0 9 0 10 0 12 0 13 0 14 0 16 0 17 0 19 0 20 0 21]#[0 0 78 0 7 0 9]#[1 0 106 0 7 0 106 0 9 0 106 0 10 0 106 0 12 0 106 0 16 0 106 0 17 0 106 0 19 0 106 0 20 0 106 0 21 0 106 0 23 1 13 0 24]#[1 0 114 0 7 0 114 0 9 0 114 0 10 0 114 0 12 0 114 0 16 0 114 0 17 0 114 0 19 0 114 0 20 0 114 0 21 0 114 0 23 1 17 0 24]#[1 0 122 0 7 0 122 0 9 0 122 0 10 0 122 0 12 0 122 0 16 0 122 0 17 0 122 0 19 0 122 0 20 0 122 0 21 0 122 0 23 1 21 0 24]#[0 0 102 0 7 0 9 0 10 0 12 0 16 0 17 0 19 0 20 0 21 0 23]#[0 0 110 0 7 0 9 0 10 0 12 0 16 0 17 0 19 0 20 0 21 0 23]#[0 0 118 0 7 0 9 0 10 0 12 0 16 0 17 0 19 0 20 0 21 0 23]#[0 0 126 0 7 0 9 0 10 0 12 0 16 0 17 0 19 0 20 0 21 0 23])</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammarParser class</class-id> <category>generated-starting states</category><body package="SmaCC Development">startingStateForFile	^1</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammarParser class</class-id> <category>generated-accessing</category><body package="SmaCC Development">scannerClass	^SmaCCGrammarScanner</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammarParser class</class-id> <category>generated-comments</category><body package="SmaCC Development">parserDefinitionComment	"File:	Parser {grammar addEmptySymbol; yourself};Parser:	Rule	| Parser Rule ;Rule : ProductionRule {grammar setStartSymbolIfNone: '1'. nil}	| LeftLine 	| RightLine 	| NonAssociativeLine	| IdMethodLine	| StartLine ;LeftLine:	""%left"" TokenList 'tokens' "";"" { tokens do: [:each | grammar leftPrecedenceFor: each; setOperatorPrecedenceFor: each to: scanner lineNumber]. nil };RightLine:	""%right"" TokenList 'tokens' "";"" { tokens do: [:each | grammar rightPrecedenceFor: each; setOperatorPrecedenceFor: each to: scanner lineNumber]. nil };NonAssociativeLine: ""%nonassoc"" TokenList 'tokens' "";"" { tokens do: [:each | grammar nonAssociativePrecedenceFor: each; setOperatorPrecedenceFor: each to: scanner lineNumber]. nil };IdMethodLine: ""%id"" IdTokens 'tokens' "";"" {tokens do: [:each | grammar makeTokenIdMethodFor: each]. nil};StartLine: ""%start"" StartingTokens "";"";IdTokens: &lt;tokenname&gt; {OrderedCollection with: '1' value}	| IdTokens &lt;tokenname&gt; {'1' add: '2' value; yourself};TokenList:	Term	| TokenList Term	;StartingTokens: &lt;symbolname&gt; 'symbol' {grammar addStartingSymbol: (grammar nonTerminalSymbolNamed: symbol value)}	| StartingTokens &lt;symbolname&gt; 'symbol' {grammar addStartingSymbol: (grammar nonTerminalSymbolNamed: symbol value)};ProductionRule: &lt;symbolname&gt; &lt;production&gt; ParserRules "";"" {| symbol | symbol := grammar nonTerminalSymbolNamed: '1' value. '3' do: [:each | symbol addProduction: each]. symbol};ParserRules:	ParserRules ""|"" ParserRule {'1' add: '3'; yourself}	| ParserRule	 ;ParserRule : Terms 'rhs' {rhs}	| Terms 'rhs' &lt;code&gt; 'code' {self verifyCodeToken: code for: rhs} ;Terms :	{SmaCCRHS new}	| Terms 'rhs' Term 'term'	{rhs add: term; yourself}		| Terms 'rhs' Term 'term' &lt;variablename&gt; 'variableNameToken'	{rhs add: term; nameLastItem: (variableNameToken value copyFrom: 2 to: variableNameToken value size - 1); yourself}		| Terms 'rhs' Term 'term' ""?"" {rhs add: (grammar makeOptionalSymbolFor: term); yourself}	| Terms 'rhs' Term 'term' ""?"" &lt;variablename&gt; 'variableNameToken' {rhs add: (grammar makeOptionalSymbolFor: term); nameLastItem: (variableNameToken value copyFrom: 2 to: variableNameToken value size - 1); yourself}		| Terms 'rhs' Term 'term' ""*"" {rhs add: (grammar makeRepeatSymbolFor: term); yourself}	| Terms 'rhs' Term 'term' ""*"" &lt;variablename&gt; 'variableNameToken' {rhs add: (grammar makeRepeatSymbolFor: term); nameLastItem: (variableNameToken value copyFrom: 2 to: variableNameToken value size - 1); yourself}			| Terms 'rhs' Term 'term' ""+"" {rhs add: (grammar makeRepeatMultipleSymbolFor: term); yourself}	| Terms 'rhs' Term 'term' ""+"" &lt;variablename&gt; 'variableNameToken' {rhs add: (grammar makeRepeatMultipleSymbolFor: term); nameLastItem: (variableNameToken value copyFrom: 2 to: variableNameToken value size - 1); yourself}	;Term:	&lt;keyword&gt; {grammar keywordTerminalNamed: '1' value}	| &lt;tokenname&gt; {grammar terminalSymbolNamed: '1' value ifAbsent: [currentToken := '1'. self reportErrorMessage: 'Token not specified']}	| &lt;symbolname&gt; {grammar nonTerminalSymbolNamed: '1' value}	| ""error"" {SmaCCSymbol error}	| ""("" SimpleTerms "")"" {grammar makeGroupFor: '2'}	| ""&lt;%"" SimpleTerms ""%&gt;"" {grammar makeRepeatSymbolFor: (grammar makeGroupFor: '2')}	| ""["" SimpleTerms ""]"" {grammar makeOptionalSymbolFor: (grammar makeGroupFor: '2')};SimpleTerms :	SimpleTerm {OrderedCollection with: '1'}	| SimpleTerms 'terms' ""|"" SimpleTerm 'term' {terms add: term; yourself};SimpleTerm :	{ SmaCCRHS new }	| SimpleTerm 'rhs' Term 'term' {rhs add: term; yourself} 	| SimpleTerm 'rhs' Term 'term' ""?"" {rhs add: (grammar makeOptionalSymbolFor: term); yourself}	| SimpleTerm 'rhs' Term 'term' ""*"" {rhs add: (grammar makeRepeatSymbolFor: term); yourself}	| SimpleTerm 'rhs' Term 'term' ""+"" {rhs add: (grammar makeRepeatMultipleSymbolFor: term); yourself}	;"</body></methods><methods><class-id>Refactory.SmaCC.SmaCCEdge</class-id> <category>testing</category><body package="SmaCC Development">conflictsWith: anEdge 	^characters anySatisfy: [:each | anEdge characters includes: each]</body><body package="SmaCC Development">does: aString includeCharacter: aCharacter 	| start stop mid |	start := 1.	stop := aString size.	stop = 0 ifTrue: [^false].		[mid := (start + stop) // 2.	mid = start] whileFalse: 				[(aString at: mid) asInteger &lt; aCharacter asInteger 					ifTrue: [start := mid]					ifFalse: [stop := mid]].	^(aString at: start) = aCharacter or: [(aString at: stop) = aCharacter]</body><body package="SmaCC Development">includesCharacter: aCharacter 	^self does: characters includeCharacter: aCharacter</body><body package="SmaCC Development">isEmpty	^characters isEmpty</body><body package="SmaCC Development">isEpsilonTransition	^characters isNil</body></methods><methods><class-id>Refactory.SmaCC.SmaCCEdge</class-id> <category>accessing</category><body package="SmaCC Development">mergeWith: anEdge 	characters := String withAll: ((characters , anEdge characters) asSet 						asSortedCollection: [:a :b | a asInteger &lt; b asInteger])</body><body package="SmaCC Development">to	^toNode</body></methods><methods><class-id>Refactory.SmaCC.SmaCCEdge</class-id> <category>compiling</category><body package="SmaCC Development">closestIsExpression	"Attempts to find the #is selector that most closely matches the character set that this edge transitions on."	| expressions closest |	expressions := IsExpressions keys 				select: [:each | each allSatisfy: [:ch | self includesCharacter: ch]].	expressions isEmpty ifTrue: [^nil].	closest := IsExpressions 				at: (expressions asSortedCollection: [:a :b | a size &gt; b size]) first.	(self minMaxPairsWithout: closest) size 		&lt;= (self minMaxPairsWithout: nil) size ifFalse: [^nil].	^closest</body><body package="SmaCC Development">expression	| stream isSelector |	stream := WriteStream on: (String new: 128).	stream nextPut: $(.	characters size = SmaCCGrammar maximumCharacterValue 		ifTrue: [self outputInvertedMatchOn: stream]		ifFalse: 			[isSelector := self outputClosestIsMethodOn: stream.			self outputExpressionOn: stream without: isSelector].	stream nextPut: $).	^stream contents</body><body package="SmaCC Development">minMaxPairsWithout: aSelector 	"Converts a list of characters into a collection of pairs representing the minimum and maximum of each sequence.	The list is first filtered to include only those characters that fail aSelector."	| start last pairs charsLeft |	charsLeft := aSelector isNil 				ifTrue: [characters]				ifFalse: [characters reject: [:ch | ch perform: aSelector]].	pairs := OrderedCollection new.	charsLeft isEmpty ifTrue: [^pairs].	last := charsLeft first.	start := nil.	charsLeft do: 			[:each | 			last asInteger + 1 = each asInteger 				ifFalse: 					[start notNil ifTrue: [pairs add: (Array with: start with: last)].					start := each].			last := each].	pairs add: (Array with: start with: last).	^pairs</body><body package="SmaCC Development">outputClosestIsMethodOn: stream 	| expr |	expr := self closestIsExpression.	expr isNil ifFalse: [stream nextPutAll: 'currentCharacter ' , expr].	^expr</body><body package="SmaCC Development">outputExpressionFor: aPair on: stream 	aPair first = aPair last 		ifTrue: [^self outputMatchSingleCharacter: aPair first on: stream].	aPair first = (Character value: 0) 		ifTrue: [^self outputMatchLessThan: aPair last on: stream].	aPair last = (Character value: SmaCCGrammar maximumCharacterValue) 		ifTrue: [^self outputMatchGreaterThan: aPair first on: stream].	self outputMatchRange: aPair on: stream</body><body package="SmaCC Development">outputExpressionOn: aStream without: aSelector 	| pairs |	pairs := self minMaxPairsWithout: aSelector.	pairs isEmpty ifTrue: [^self].	aSelector notNil ifTrue: [aStream nextPutAll: ' or: ['].	pairs do: [:each | self outputExpressionFor: each on: aStream]		separatedBy: [aStream nextPutAll: ' or: ['].	aStream next: pairs size - 1 put: $].	aSelector notNil ifTrue: [aStream nextPut: $]]</body><body package="SmaCC Development">outputInvertedMatchOn: aStream 	| char |	char := Character value: ((0 to: SmaCCGrammar maximumCharacterValue) 						detect: [:each | (characters includes: (Character value: each)) not]).	aStream		nextPutAll: 'currentCharacter ~~ ';		nextPutAll: char storeString</body><body package="SmaCC Development">outputMatchGreaterThan: aCharacter on: stream 	stream		nextPutAll: 'currentCharacter &gt;= ';		nextPutAll: aCharacter storeString</body><body package="SmaCC Development">outputMatchLessThan: aCharacter on: stream 	stream		nextPutAll: 'currentCharacter &lt;= ';		nextPutAll: aCharacter storeString</body><body package="SmaCC Development">outputMatchRange: aPair on: stream 	stream		nextPutAll: '(currentCharacter between: ';		nextPutAll: aPair first storeString;		nextPutAll: ' and: ';		nextPutAll: aPair last storeString;		nextPutAll: ')'</body><body package="SmaCC Development">outputMatchSingleCharacter: aCharacter on: stream 	stream		nextPutAll: 'currentCharacter == ';		nextPutAll: aCharacter storeString</body></methods><methods><class-id>Refactory.SmaCC.SmaCCEdge</class-id> <category>private</category><body package="SmaCC Development">characters	^characters</body><body package="SmaCC Development">removeCharacters: aCollection 	characters := characters 				reject: [:each | self does: aCollection includeCharacter: each]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCEdge</class-id> <category>comparing</category><body package="SmaCC Development">&lt;= anEdge 	^self to id &lt;= anEdge to id</body><body package="SmaCC Development">= anEdge 	self class = anEdge class ifFalse: [^false].	^self to = anEdge to and: [self characters = anEdge characters]</body><body package="SmaCC Development">hash	^(self to hash bitShift: 14) bitXor: characters hash</body></methods><methods><class-id>Refactory.SmaCC.SmaCCEdge</class-id> <category>initialize-release</category><body package="SmaCC Development">to: aNode on: aStringOrNil 	toNode := aNode.	characters := aStringOrNil</body></methods><methods><class-id>Refactory.SmaCC.SmaCCEdge</class-id> <category>printing</category><body package="SmaCC Development">printOn: aStream 	aStream		nextPutAll: '---';		nextPutAll: (characters ifNil: ['""']);		nextPutAll: '---&gt;';		nextPutAll: toNode printString</body></methods><methods><class-id>Refactory.SmaCC.SmaCCEdge class</class-id> <category>instance creation</category><body package="SmaCC Development">to: aNode on: aStringOrNil 	| edge |	edge := self new.	edge to: aNode on: aStringOrNil.	^edge</body></methods><methods><class-id>Refactory.SmaCC.SmaCCEdge class</class-id> <category>class initialization</category><body package="SmaCC Development">generateCharacterSetFor: aSelector 	| stream |	stream := WriteStream on: String new.	0 to: SmaCCGrammar maximumCharacterValue		do: 			[:i | 			| ch |			ch := Character value: i.			(ch perform: aSelector) ifTrue: [stream nextPut: ch]].	^stream contents</body><body package="SmaCC Development">initializeIsExpressions	"Creates a map from sets of characters to selectors that start with 'is' on Character. This allows generated scanners to take	full advantage of selectors that are already implemented on Character"	| selectors |	IsExpressions := Dictionary new.	selectors := Character selectors select: 					[:each | 					('is*' match: each) 						and: [each numArgs = 0 and: [(each at: 3) isUppercase]]].	selectors do: 			[:sel | 			| string |			string := self generateCharacterSetFor: sel.			string isEmpty ifFalse: [IsExpressions at: string put: sel]]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammar</class-id> <category>accessing</category><body package="SmaCC Development">addEmptySymbol	self addSymbol: SmaCCSymbol empty.	self addSymbol: SmaCCSymbol error</body><body package="SmaCC Development">addStartingSymbol: aSymbol 	(otherStartingSymbols includes: aSymbol) 		ifFalse: [otherStartingSymbols add: aSymbol]</body><body package="SmaCC Development">allStartingSymbols	"Return all starting symbols with the default starting symbol listed first."	| startingSymbols default |	default := self startSymbol.	startingSymbols := otherStartingSymbols copy.	startingSymbols remove: default ifAbsent: [].	startingSymbols := startingSymbols collect: 					[:each | 					(SmaCCStartingSymbol name: 'B e g i n' , each name)						addProduction: ((SmaCCRHS new)									add: each;									yourself);						yourself].	startingSymbols addFirst: default.	^startingSymbols</body><body package="SmaCC Development">emptySymbols	^self symbols select: [:each | each isTerminal not and: [each isEmpty]]</body><body package="SmaCC Development">initialItemSetFor: aSymbol 	^(aSymbol asLRItemSet)		type: type;		yourself</body><body package="SmaCC Development">makeGroupFor: aRHSCollection 	| symbol name |	name := aRHSCollection inject: ''				into: [:sum :each | sum , ' | ' , each printString].	symbol := self nonTerminalSymbolNamed: 'Group: ' , name.	symbol isEmpty 		ifTrue: 			[(aRHSCollection allSatisfy: [:each | each size = 1]) 				ifTrue: [aRHSCollection do: [:each | each reduceAction: '''1''']].			aRHSCollection do: [:each | symbol addProduction: each]].	^symbol</body><body package="SmaCC Development">makeOptionalSymbolFor: aSymbol 	| symbol |	symbol := self nonTerminalSymbolNamed: 'Optional: ' , aSymbol printString.	symbol isEmpty 		ifTrue: 			[symbol				addProduction: ((SmaCCRHS new)							reduceAction: 'nil';							yourself);				addProduction: ((SmaCCRHS new)							add: aSymbol;							reduceAction: '''1''';							yourself)].	^symbol</body><body package="SmaCC Development">makeRepeatMultipleSymbolFor: aSymbol 	| symbol |	symbol := self 				nonTerminalSymbolNamed: 'Repeat Multiple: ' , aSymbol printString.	symbol isEmpty 		ifTrue: 			[symbol				addProduction: ((SmaCCRHS new)							add: aSymbol;							reduceAction: 'OrderedCollection with: ''1''';							yourself);				addProduction: ((SmaCCRHS new)							add: symbol;							add: aSymbol;							reduceAction: '''1'' add: ''2''; yourself';							yourself)].	^symbol</body><body package="SmaCC Development">makeRepeatSymbolFor: aSymbol 	| symbol |	symbol := self nonTerminalSymbolNamed: 'Repeat: ' , aSymbol printString.	symbol isEmpty 		ifTrue: 			[symbol				addProduction: ((SmaCCRHS new)							reduceAction: 'OrderedCollection new';							yourself);				addProduction: ((SmaCCRHS new)							add: symbol;							add: aSymbol;							reduceAction: '''1'' add: ''2''; yourself';							yourself)].	^symbol</body><body package="SmaCC Development">makeTokenIdMethodFor: aString 	| token |	token := (tokens includesKey: aString) 				ifTrue: [self terminalSymbolNamed: aString]				ifFalse: 					[symbols detect: [:each | each name = aString]						ifNone: [symbols add: (SmaCCTerminalSymbol name: aString)]].	token createIdMethod: true</body><body package="SmaCC Development">preferredActionFor: aGrammarSymbol 	^shiftReduceTable at: aGrammarSymbol ifAbsent: [nil]</body><body package="SmaCC Development">setStartSymbolIfNone: aGrammarSymbol 	| startSymbol |	self startSymbol notNil ifTrue: [^self].	startSymbol := SmaCCStartingSymbol name: 'B e g i n'.	self addSymbol: startSymbol.	startSymbol addProduction: ((SmaCCRHS new)				add: aGrammarSymbol;				yourself)</body><body package="SmaCC Development">startSymbol	^symbols detect: [:each | each isStartingSymbol] ifNone: [nil]</body><body package="SmaCC Development">tokens	^tokens</body><body package="SmaCC Development">unusedSymbols	| nonTerminals problemSymbols todo symbol |	nonTerminals := self symbols reject: [:each | each isTerminal].	problemSymbols := nonTerminals asSet.	problemSymbols remove: self startSymbol.	todo := OrderedCollection with: self startSymbol.	[todo isEmpty] whileFalse: 			[symbol := todo removeFirst.			symbol productionsDo: 					[:rhs | 					rhs do: 							[:each | 							each isTerminal 								ifFalse: 									[(problemSymbols includes: each) 										ifTrue: 											[todo add: each.											problemSymbols remove: each]]]]].	^problemSymbols</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammar</class-id> <category>initialize-release</category><body package="SmaCC Development">initialize	type := #LALR1.	symbols := OrderedCollection new.	shiftReduceTable := Dictionary new.	otherStartingSymbols := OrderedCollection new</body><body package="SmaCC Development">tokens: aCollection	tokens := aCollection</body><body package="SmaCC Development">type: aSymbol	type := aSymbol</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammar</class-id> <category>private</category><body package="SmaCC Development">addSymbol: aGrammarSymbol 	^symbols add: aGrammarSymbol</body><body package="SmaCC Development">calculateFirstSets	| changed |	changed := true.	[changed] whileTrue: 			[changed := false.			self symbols 				do: [:each | changed := changed | each calculateFirstTerminals]]</body><body package="SmaCC Development">keywordTerminalNamed: aString 	^symbols detect: [:each | each name = aString]		ifNone: 			[symbols addFirst: ((SmaCCTerminalSymbol name: aString)						regularExpression: (((aString copyFrom: 2 to: aString size - 1) 									copyReplaceAll: '""'									with: '"') inject: nil										into: 											[:sum :each | 											sum isNil 												ifTrue: [SmaCCCharacterRENode characters: (String with: each)]												ifFalse: [sum , (SmaCCCharacterRENode characters: (String with: each))]]);						yourself)]</body><body package="SmaCC Development">nonTerminalSymbolNamed: aString 	^symbols detect: [:each | each name = aString]		ifNone: [self addSymbol: (SmaCCNonTerminalSymbol name: aString)]</body><body package="SmaCC Development">reduceTableIndexFor: aGrammarSymbol rhs: aRHS 	| index |	index := 0.	self symbols do: 			[:each | 			each = aGrammarSymbol ifTrue: [^index + (each positionOf: aRHS)].			index := index + each size].	^0</body><body package="SmaCC Development">symbols	^symbols</body><body package="SmaCC Development">symbols: aCollection	symbols := aCollection</body><body package="SmaCC Development">terminalSymbolNamed: aString 	^symbols detect: [:each | each name = aString]		ifNone: 			[symbols add: ((SmaCCTerminalSymbol name: aString)						regularExpression: (tokens at: aString);						yourself)]</body><body package="SmaCC Development">terminalSymbolNamed: aString ifAbsent: aBlock 	^symbols detect: [:each | each name = aString]		ifNone: 			[symbols add: ((SmaCCTerminalSymbol name: aString)						regularExpression: (tokens at: aString ifAbsent: [^aBlock value]);						yourself)]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammar</class-id> <category>precedence</category><body package="SmaCC Development">leftPrecedenceFor: aGrammarSymbol 	shiftReduceTable at: aGrammarSymbol put: SmaCCReduceAction</body><body package="SmaCC Development">nonAssociativePrecedenceFor: aGrammarSymbol 	shiftReduceTable at: aGrammarSymbol put: SmaCCRejectAction</body><body package="SmaCC Development">rightPrecedenceFor: aGrammarSymbol 	shiftReduceTable at: aGrammarSymbol put: SmaCCShiftAction</body><body package="SmaCC Development">setOperatorPrecedenceFor: aGrammarSymbol to: anInteger	aGrammarSymbol precedence: anInteger</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammar class</class-id> <category>accessing</category><body package="SmaCC Development">ignoreCase	^IgnoreCase</body><body package="SmaCC Development">ignoreCase: aBoolean 	IgnoreCase := aBoolean</body><body package="SmaCC Development">maximumCharacterValue	^MaximumCharacterValue</body><body package="SmaCC Development">maximumCharacterValue: anInteger 	MaximumCharacterValue := anInteger.	SmaCCEdge initializeIsExpressions</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammar class</class-id> <category>instance creation</category><body package="SmaCC Development">new	^(super new)		initialize;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammar class</class-id> <category>class initialization</category><body package="SmaCC Development">initialize	IgnoreCase := false.	self maximumCharacterValue: 255</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScannerParser</class-id> <category>generated-reduction actions</category><body package="SmaCC Development">reduceActionForFile1: nodes 	^tokens</body><body package="SmaCC Development">reduceActionForFile2: nodes 	^tokens</body><body package="SmaCC Development">reduceActionForRegex1: nodes 	^nodes at: 1</body><body package="SmaCC Development">reduceActionForRegex2: nodes 	^(nodes at: 1) | (nodes at: 3)</body><body package="SmaCC Development">reduceActionForRegex3: nodes 	^(nodes at: 1) , (nodes at: 2)</body><body package="SmaCC Development">reduceActionForRegexTerm10: nodes 	| readStream start stop |	readStream := ReadStream 				on: ((nodes at: 2) value copyFrom: 2 to: (nodes at: 2) value size - 1).	start := readStream upTo: $,.	stop := readStream upToEnd.	^(nodes at: 1) 		repeatFor: (start isEmpty ifTrue: [0] ifFalse: [start asNumber])		to: (stop isEmpty ifTrue: [1 bitShift: 31] ifFalse: [stop asNumber])</body><body package="SmaCC Development">reduceActionForRegexTerm1: nodes 	^SmaCCCharacterRENode characters: (nodes at: 1) value</body><body package="SmaCC Development">reduceActionForRegexTerm2: nodes 	^SmaCCCharacterRENode characters: self allCharacters</body><body package="SmaCC Development">reduceActionForRegexTerm3: nodes 	^self nodeFor: (ReadStream 				on: ((nodes at: 1) value copyFrom: 2 to: (nodes at: 1) value size))</body><body package="SmaCC Development">reduceActionForRegexTerm4: nodes 	^nodes at: 2</body><body package="SmaCC Development">reduceActionForRegexTerm5: nodes 	^SmaCCCharacterRENode 		characters: (self parseCharacterBlock: (nodes at: 1))</body><body package="SmaCC Development">reduceActionForRegexTerm6: nodes 	^(tokens at: (nodes at: 1) value) copy</body><body package="SmaCC Development">reduceActionForRegexTerm7: nodes 	^(nodes at: 1) repeat</body><body package="SmaCC Development">reduceActionForRegexTerm8: nodes 	^(nodes at: 1) repeatForAtLeast: 1</body><body package="SmaCC Development">reduceActionForRegexTerm9: nodes 	^(nodes at: 1) repeatFor: 0 to: 1</body><body package="SmaCC Development">reduceActionForRule1: nodes 	(nodes at: 3) position: (nodes at: 1) startPosition.	tokens at: (nodes at: 1) value put: (nodes at: 3).	^nil</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScannerParser</class-id> <category>private</category><body package="SmaCC Development">allCharacters	^String withAll: ((0 to: SmaCCGrammar maximumCharacterValue) 				collect: [:each | Character value: each])</body><body package="SmaCC Development">charactersFor: aStream in: aToken 	| characters char endCharacters |	aStream atEnd ifTrue: [self reportCharacterBlockErrorForToken: aToken].	char := aStream next.	characters := char == $\ 				ifTrue: [(self nodeFor: aStream) characters]				ifFalse: [OrderedCollection with: char].	(characters size = 1 and: [aStream peekFor: $-]) ifFalse: [^characters].	endCharacters := self charactersFor: aStream in: aToken.	endCharacters size &gt; 1 		ifTrue: [self reportCharacterBlockErrorForToken: aToken].	^(characters first asInteger to: endCharacters first asInteger) 		collect: [:each | Character value: each]</body><body package="SmaCC Development">nodeFor: aStream 	| block char value count |	char := aStream next.	char == $f 		ifTrue: 			[^SmaCCCharacterRENode characters: (String with: (Character value: 12))].	char == $n 		ifTrue: 			[^SmaCCCharacterRENode characters: (String with: (Character value: 10))].	char == $r 		ifTrue: 			[^SmaCCCharacterRENode characters: (String with: (Character value: 13))].	char == $t ifTrue: [^SmaCCCharacterRENode characters: '	'].	char == $v 		ifTrue: 			[^SmaCCCharacterRENode characters: (String with: (Character value: 11))].	char == $c 		ifTrue: 			[^SmaCCCharacterRENode characters: (String 						with: (Character value: aStream next asInteger - $A asInteger))].	char == $x 		ifTrue: 			[count := value := 0.						[aStream atEnd not and: 					[count &lt; 4 and: 							[char := aStream peek.							(char between: $0 and: $9) 								or: [(char between: $A and: $F) or: [char between: $a and: $f]]]]] 					whileTrue: 						[count := count + 1.						value := value * 16 + aStream next digitValue].			^SmaCCCharacterRENode characters: (String with: (Character value: value))].	char == $d ifTrue: [block := [:each | each between: $0 and: $9]].	char == $D ifTrue: [block := [:each | (each between: $0 and: $9) not]].	char == $s 		ifTrue: [block := [:each | #[9 10 11 12 13 32] includes: each asInteger]].	char == $S 		ifTrue: 			[block := [:each | (#[9 10 11 12 13 32] includes: each asInteger) not]].	char == $w 		ifTrue: 			[block := 					[:each | 					(each between: $a and: $z) or: 							[(each between: $A and: $Z) 								or: [(each between: $0 and: $9) or: [each == $_]]]]].	char == $W 		ifTrue: 			[block := 					[:each | 					((each between: $a and: $z) or: 							[(each between: $A and: $Z) 								or: [(each between: $0 and: $9) or: [each == $_]]]) 						not]].	block isNil 		ifTrue: [^SmaCCCharacterRENode characters: (String with: char)].	^SmaCCCharacterRENode 		characters: (String withAll: (self allCharacters select: block))</body><body package="SmaCC Development">parseCharacterBlock: aToken 	| characters aStream invert |	aStream := ReadStream 				on: (aToken value copyFrom: 2 to: aToken value size - 1).	characters := OrderedCollection new.	invert := aStream peekFor: $^.	[aStream atEnd] 		whileFalse: [characters addAll: (self charactersFor: aStream in: aToken)].	^String withAll: (invert 				ifTrue: [self allCharacters reject: [:each | characters includes: each]]				ifFalse: [characters])</body><body package="SmaCC Development">reportCharacterBlockErrorForToken: aToken 	currentToken := aToken.	self reportErrorMessage: 'Invalid character block'</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScannerParser</class-id> <category>initialize-release</category><body package="SmaCC Development">initialize	super initialize.	tokens := Dictionary new</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScannerParser</class-id> <category>generated-tables</category><body package="SmaCC Development">reduceTable	^#(#(17 1 #reduceFor:)#(18 1 #reduceActionForFile1:)#(18 0 #reduceActionForFile2:)#(19 1 #reduceActionForRegex1:)#(19 3 #reduceActionForRegex2:)#(19 2 #reduceActionForRegex3:)#(20 1 #reduceActionForRegexTerm1:)#(20 1 #reduceActionForRegexTerm2:)#(20 1 #reduceActionForRegexTerm3:)#(20 3 #reduceActionForRegexTerm4:)#(20 1 #reduceActionForRegexTerm5:)#(20 1 #reduceActionForRegexTerm6:)#(20 2 #reduceActionForRegexTerm7:)#(20 2 #reduceActionForRegexTerm8:)#(20 2 #reduceActionForRegexTerm9:)#(20 2 #reduceActionForRegexTerm10:)#(23 2 #reduceFor:)#(23 3 #reduceFor:)#(24 3 #reduceActionForRule1:))</body><body package="SmaCC Development">transitionTable	^#(#[1 0 9 0 12 0 13 0 18 0 14 0 21 0 17 0 23 0 21 0 24]#[0 0 25 0 6]#[0 0 0 0 21]#[1 0 9 0 12 0 10 0 21 0 29 0 24]#[0 0 33 0 7]#[1 0 37 0 2 0 41 0 9 0 45 0 10 0 49 0 12 0 53 0 15 0 57 0 16 0 61 0 19 0 65 0 20]#[0 0 69 0 7]#[0 0 70 0 12 0 21]#[1 0 37 0 2 0 41 0 9 0 45 0 10 0 49 0 12 0 53 0 15 0 57 0 16 0 73 0 19 0 65 0 20]#[0 0 38 0 1 0 2 0 3 0 4 0 5 0 7 0 8 0 9 0 10 0 12 0 14 0 15 0 16]#[0 0 46 0 1 0 2 0 3 0 4 0 5 0 7 0 8 0 9 0 10 0 12 0 14 0 15 0 16]#[0 0 50 0 1 0 2 0 3 0 4 0 5 0 7 0 8 0 9 0 10 0 12 0 14 0 15 0 16]#[0 0 30 0 1 0 2 0 3 0 4 0 5 0 7 0 8 0 9 0 10 0 12 0 14 0 15 0 16]#[0 0 34 0 1 0 2 0 3 0 4 0 5 0 7 0 8 0 9 0 10 0 12 0 14 0 15 0 16]#[1 0 37 0 2 0 77 0 3 0 78 0 7 0 41 0 9 0 45 0 10 0 49 0 12 0 53 0 15 0 57 0 16 0 81 0 20]#[1 0 18 0 1 0 18 0 2 0 18 0 3 0 85 0 4 0 89 0 5 0 18 0 7 0 93 0 8 0 18 0 9 0 18 0 10 0 18 0 12 0 97 0 14 0 18 0 15 0 18 0 16]#[0 0 74 0 12 0 21]#[1 0 101 0 1 0 37 0 2 0 77 0 3 0 41 0 9 0 45 0 10 0 49 0 12 0 53 0 15 0 57 0 16 0 81 0 20]#[1 0 37 0 2 0 41 0 9 0 45 0 10 0 49 0 12 0 53 0 15 0 57 0 16 0 105 0 19 0 65 0 20]#[1 0 26 0 1 0 26 0 2 0 26 0 3 0 85 0 4 0 89 0 5 0 26 0 7 0 93 0 8 0 26 0 9 0 26 0 10 0 26 0 12 0 97 0 14 0 26 0 15 0 26 0 16]#[0 0 54 0 1 0 2 0 3 0 4 0 5 0 7 0 8 0 9 0 10 0 12 0 14 0 15 0 16]#[0 0 58 0 1 0 2 0 3 0 4 0 5 0 7 0 8 0 9 0 10 0 12 0 14 0 15 0 16]#[0 0 62 0 1 0 2 0 3 0 4 0 5 0 7 0 8 0 9 0 10 0 12 0 14 0 15 0 16]#[0 0 66 0 1 0 2 0 3 0 4 0 5 0 7 0 8 0 9 0 10 0 12 0 14 0 15 0 16]#[0 0 42 0 1 0 2 0 3 0 4 0 5 0 7 0 8 0 9 0 10 0 12 0 14 0 15 0 16]#[1 0 22 0 1 0 37 0 2 0 22 0 3 0 22 0 7 0 41 0 9 0 45 0 10 0 49 0 12 0 53 0 15 0 57 0 16 0 81 0 20])</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScannerParser class</class-id> <category>generated-starting states</category><body package="SmaCC Development">startingStateForFile	^1</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScannerParser class</class-id> <category>generated-accessing</category><body package="SmaCC Development">scannerClass	^SmaCCScannerScanner</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScannerParser class</class-id> <category>generated-comments</category><body package="SmaCC Development">parserDefinitionComment	"%left	""|"";%left ""("" &lt;character&gt; &lt;backslashcharacter&gt; &lt;characterblock&gt; &lt;anycharacter&gt; &lt;tokenname&gt;;%left ""*"" ""+"" ""?"" &lt;repeat&gt; ;File: Rules	 {tokens} 	|  {tokens};Rules: Rule "";""	| Rules Rule "";"" ;Rule: &lt;tokenname&gt; "":"" Regex {'3' position: '1' startPosition. tokens at: '1' value put: '3'. nil};Regex: RegexTerm {'1'}	| Regex ""|"" Regex {'1' | '3'}	| Regex RegexTerm {'1' , '2'};RegexTerm:	&lt;character&gt; {SmaCCCharacterRENode characters: '1' value}	| &lt;anycharacter&gt; {SmaCCCharacterRENode characters: self allCharacters}	| &lt;backslashcharacter&gt; {self nodeFor: (ReadStream on: ('1' value copyFrom: 2 to: '1' value size))} 	| ""("" Regex "")"" {'2'}	| &lt;characterblock&gt; {SmaCCCharacterRENode characters: (self parseCharacterBlock: '1')}	| &lt;tokenname&gt; {(tokens at: '1' value) copy}	| RegexTerm ""*""	{'1' repeat}	| RegexTerm ""+"" {'1' repeatForAtLeast: 1}	| RegexTerm ""?"" {'1' repeatFor: 0 to: 1}	| RegexTerm &lt;repeat&gt; {| readStream start stop | 					readStream := ReadStream on: ('2' value copyFrom: 2 to: '2' value size - 1). 					start := readStream upTo: $,. 					stop := readStream upToEnd.					'1' repeatFor: (start isEmpty ifTrue: [0] ifFalse: [start asNumber]) to: (stop isEmpty ifTrue: [(1 bitShift: 31)] ifFalse: [stop asNumber])} ;"</body></methods><methods><class-id>Refactory.SmaCC.SmaCCItemSet</class-id> <category>initialize-release</category><body package="SmaCC Development">initialize	(self class superclass canUnderstand: #initialize) 		ifTrue: [super initialize].	type := #LALR1</body><body package="SmaCC Development">type: aSymbol 	type := aSymbol</body></methods><methods><class-id>Refactory.SmaCC.SmaCCItemSet</class-id> <category>comparing</category><body package="SmaCC Development">= anItemSet 	self class = anItemSet class 		ifTrue: 			[type == #LALR1				ifTrue: [^self isLALREqualTo: anItemSet]				ifFalse: [^self isLREqualTo: anItemSet]].	^false</body><body package="SmaCC Development">hash	^self inject: self class hash into: [:sum :each | sum bitXor: each hash]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCItemSet</class-id> <category>accessing</category><body package="SmaCC Development">action: aGrammarSymbol prefer: aClass 	| action actionItem eachAction |	action := SmaCCRejectAction new.	self do: 			[:each | 			eachAction := each action: aGrammarSymbol.			action class = SmaCCRejectAction 				ifTrue: 					[action := eachAction.					actionItem := each]				ifFalse: 					[(eachAction = action or: [eachAction class = SmaCCRejectAction]) 						ifFalse: 							[eachAction class = SmaCCShiftAction | (action class = SmaCCShiftAction) 								ifTrue: 									["Shift/Reduce conflict -- check precedence"									(aGrammarSymbol precedence isNil 										or: [each precedence isNil or: [actionItem precedence isNil]]) 											ifTrue: 												["No precedence, choose shift"												eachAction class = SmaCCShiftAction 													ifTrue: 														[self 															raiseXReduceNotification: each															with: actionItem															type: 'Shift/Reduce Conflict'.														action := eachAction.														actionItem := each]													ifFalse: 														[self 															raiseXReduceNotification: actionItem															with: each															type: 'Shift/Reduce Conflict']]											ifFalse: 												[(each precedence &gt; actionItem precedence 													or: [each precedence = actionItem precedence and: [eachAction class = aClass]]) 														ifTrue: 															[self 																raiseXReduceNotification: each																with: actionItem																type: 'Shift/Reduce Conflict (handled by precedence rules)'.															action := eachAction.															actionItem := each]														ifFalse: 															[(each precedence = actionItem precedence and: [SmaCCRejectAction = aClass]) 																ifTrue: 																	[self 																		raiseXReduceNotificationWithNoPreferredItem: actionItem																		with: each																		type: 'Shift/Reduce Conflict (handled by precedence rules)'.																	^aClass new]																ifFalse: 																	[self 																		raiseXReduceNotification: actionItem																		with: each																		type: 'Shift/Reduce Conflict (handled by precedence rules)']]]]								ifFalse: 									["Reduce/Reduce conflict -- just pick one and proceed"									self 										raiseXReduceNotification: actionItem										with: each										type: 'Reduce/Reduce Conflict']]]].	^action</body><body package="SmaCC Development">mergeWith: anItemSet 	self == anItemSet ifTrue: [^self].	anItemSet do: [:each | self add: each]</body><body package="SmaCC Development">moveOn: aGrammarSymbol 	| anItemSet |	anItemSet := self class new.	anItemSet type: type.	self 		do: [:each | each nextSymbol == aGrammarSymbol ifTrue: [anItemSet add: each moveNext]].	^anItemSet</body><body package="SmaCC Development">raiseXReduceNotification: preferredItem with: otherItem type: aString 	| stream |	stream := WriteStream on: (String new: 200).	stream		nextPutAll: preferredItem printString;		nextPutAll: '	*****';		cr;		nextPutAll: otherItem printString.	SmaCCCompilationNotification raiseRequestWith: stream contents		errorString: aString</body><body package="SmaCC Development">raiseXReduceNotificationWithNoPreferredItem: firstItem with: secondItem type: aString 	| stream |	stream := WriteStream on: (String new: 200).	stream		nextPutAll: firstItem printString;		cr;		nextPutAll: secondItem printString.	SmaCCCompilationNotification raiseRequestWith: stream contents		errorString: aString</body></methods><methods><class-id>Refactory.SmaCC.SmaCCItemSet</class-id> <category>copying</category><body package="SmaCC Development">copyEmpty: aSize 	^(super copyEmpty: aSize)		type: type;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCItemSet</class-id> <category>testing</category><body package="SmaCC Development">isLALREqualTo: anItemSet 	^anItemSet size = self size 		and: [self allSatisfy: [:each | anItemSet includes: each]]</body><body package="SmaCC Development">isLREqualTo: anItemSet 	^anItemSet size = self size and: 			[self allSatisfy: 					[:each | 					| item |					(item := anItemSet itemFor: each) notNil and: [each isLR1EqualTo: item]]]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCItemSet</class-id> <category>private</category><body package="SmaCC Development">itemFor: anObject 	^self basicAt: (self findElementOrNil: anObject)</body><body package="SmaCC Development">performClosureOn: aLR1Item 	| nextSymbol rest first followers |	nextSymbol := aLR1Item nextSymbol.	nextSymbol isTerminal ifTrue: [^self].	rest := aLR1Item rest.	first := rest firstTerminals.	followers := SmaCCSymbolSet new.	(first includes: SmaCCSymbol empty) 		ifTrue: 			[first remove: SmaCCSymbol empty.			followers baseOn: aLR1Item followers].	followers addAll: first.	nextSymbol productionsDo: 			[:each | 			self add: (SmaCCLR1Item 						symbol: nextSymbol						rhs: each						follow: followers)]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCItemSet</class-id> <category>adding</category><body package="SmaCC Development">add: aLR1Item 	| index item |	aLR1Item == nil ifTrue: [^aLR1Item].	index := self findElementOrNil: aLR1Item.	item := self basicAt: index.	item == nil 		ifTrue: 			[self atNewIndex: index put: aLR1Item.			self performClosureOn: aLR1Item]		ifFalse: [item mergeWith: aLR1Item].	^aLR1Item</body></methods><methods><class-id>Refactory.SmaCC.SmaCCItemSet</class-id> <category>printing</category><body package="SmaCC Development">printOn: aStream 	self do: 			[:each | 			aStream				tab;				nextPutAll: each printString;				cr]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCItemSet class</class-id> <category>instance creation</category><body package="SmaCC Development">new: anInteger 	^(super new: anInteger)		initialize;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNode</class-id> <category>private</category><body package="SmaCC Development">action	^action</body><body package="SmaCC Development">addActions: aCollection 	aCollection isNil ifTrue: [^self].	action isNil 		ifTrue: 			[action := aCollection copy.			^self].	action isSymbol ifTrue: [^self].	aCollection isSymbol ifTrue: [^action := aCollection].	aCollection 		do: [:each | (action includes: each) ifFalse: [action add: each]]</body><body package="SmaCC Development">allCharacterTransitions: aSet into: aNode 	| index each |	(aSet includes: self) ifTrue: [^#()].	aSet add: self.	aNode addActions: action.	index := 1.	[index &lt;= transitions size] whileTrue: 			[each := transitions at: index.			index := index + 1.			each isEpsilonTransition 				ifTrue: [each to allCharacterTransitions: aSet into: aNode]				ifFalse: 					[(aNode transitions includes: each) 						ifFalse: [aNode transitions add: each copy]]]</body><body package="SmaCC Development">allCharacterTransitionsAndActionsInto: aNode 	| seen |	seen := Set new.	self allCharacterTransitions: seen into: aNode</body><body package="SmaCC Development">allStates	| nodes |	nodes := Set new.	self allStatesInto: nodes.	^nodes</body><body package="SmaCC Development">allStatesInto: aSet 	(aSet includes: self) ifTrue: [^self].	aSet add: self.	transitions do: [:each | each to allStatesInto: aSet]</body><body package="SmaCC Development">asDFA: aSet merged: aDictionary 	| newTransitions |	(aSet includes: self) ifTrue: [^self].	aSet add: self.	newTransitions := OrderedCollection new: transitions size.	transitions do: 			[:each | 			| existingEdges new |			new := each copy.			existingEdges := newTransitions select: [:edge | edge conflictsWith: each].			existingEdges do: 					[:existing | 					| node newChars existingChars chars |					node := aDictionary 								at: (SortedCollection with: existing to id with: new to id) asArray								ifAbsentPut: 									[node := self class new.									node transitions: ((Set 												withAll: (existing to transitions collect: [:edge | edge copy]))												addAll: (new to transitions collect: [:edge | edge copy]);												yourself).									node mergeCharacterTransitions.									node addActions: existing to action.									node addActions: new to action.									node].					newChars := new characters.					chars := newChars select: [:char | existing includesCharacter: char].					chars notEmpty 						ifTrue: [newTransitions addFirst: (SmaCCEdge to: node on: chars)].					existingChars := existing characters.					existing removeCharacters: newChars.					new removeCharacters: existingChars.					existing isEmpty ifTrue: [newTransitions remove: existing]].			new isEmpty ifFalse: [newTransitions add: new]].	self transitions: newTransitions.	transitions do: [:each | each to asDFA: aSet merged: aDictionary]</body><body package="SmaCC Development">asNFAWithoutEpsilonTransitions	| seen node |	node := self class new.	self allCharacterTransitionsAndActionsInto: node.	seen := Set new.	node asNFAWithoutEpsilonTransitions: seen.	seen := Set new.	node removeEpsilonTransitions: seen.	node cleanUp.	^node</body><body package="SmaCC Development">asNFAWithoutEpsilonTransitions: aSet 	| index each |	(aSet includes: self) ifTrue: [^self].	aSet add: self.	index := 1.	[index &lt;= transitions size] whileTrue: 			[each := transitions at: index.			index := index + 1.			each isEpsilonTransition 				ifTrue: [each to allCharacterTransitionsAndActionsInto: self]				ifFalse: [each to asNFAWithoutEpsilonTransitions: aSet]]</body><body package="SmaCC Development">cleanUp	self removeDuplicateNodes.	self mergeAllTransitions</body><body package="SmaCC Development">id	^id</body><body package="SmaCC Development">mergeAllTransitions	| nodes |	nodes := self allStates.	nodes do: [:each | each mergeCharacterTransitions]</body><body package="SmaCC Development">mergeCharacterTransitions	| toMap |	toMap := Dictionary new.	transitions copy do: 			[:each | 			(toMap includesKey: each to) 				ifTrue: 					[(toMap at: each to) mergeWith: each.					transitions remove: each]				ifFalse: [toMap at: each to put: each]]</body><body package="SmaCC Development">mergeWith: aSmaCCNode 	id := aSmaCCNode id.	transitions := aSmaCCNode transitions.	action := aSmaCCNode action</body><body package="SmaCC Development">removeDuplicateEdges	self transitions: transitions asSet asSortedCollection</body><body package="SmaCC Development">removeDuplicateNodes	| nodes |		[nodes := self allStates.	nodes do: 			[:each | 			each				mergeCharacterTransitions;				removeDuplicateEdges].	self removeDuplicateNodes: nodes] 			whileTrue</body><body package="SmaCC Development">removeDuplicateNodes: aCollection 	| merged nodePartition |	merged := false.	nodePartition := Dictionary new.	aCollection do: 			[:each | 			(nodePartition at: (Array with: each transitions size with: each action)				ifAbsentPut: [OrderedCollection new]) add: each].	nodePartition do: 			[:each | 			| seen |			seen := OrderedCollection new.			each do: 					[:node | 					| existingNode |					existingNode := seen 								detect: [:otherNode | otherNode transitionsMatch: node]								ifNone: [nil].					existingNode isNil 						ifTrue: [seen add: node]						ifFalse: 							[merged := true.							node mergeWith: existingNode]]].	^merged</body><body package="SmaCC Development">removeEpsilonTransitions: aSet 	(aSet includes: self) ifTrue: [^self].	aSet add: self.	transitions copy 		do: [:each | each isEpsilonTransition ifTrue: [transitions remove: each]].	transitions do: [:each | each to removeEpsilonTransitions: aSet]</body><body package="SmaCC Development">transitions	^transitions</body><body package="SmaCC Development">transitions: aCollection 	transitions size to: 1		by: -1		do: [:i | transitions removeAtIndex: i].	aCollection do: [:each | transitions add: each]</body><body package="SmaCC Development">transitionsMatch: aNode 	^aNode transitions allSatisfy: 			[:each | 			(transitions includes: each) or: 					[each to = aNode and: 							[each characters 								= (transitions detect: [:edge | edge to = self] ifNone: [^false]) 										characters]]]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNode</class-id> <category>compiling</category><body package="SmaCC Development">asStatement: methodMap usingSelectorMap: aDictionary forClass: aClass 	| stream |	stream := WriteStream on: (String new: 128).	self hasSimpleLoop ifTrue: [stream nextPut: $[].	self writeMatchingCodeOn: stream usingSelectorMap: aDictionary.	(self sortedTransitionsFor: aClass) do: 			[:each | 			each to = self 				ifTrue: 					[stream						nextPutAll: each expression;						nextPut: $];						nextPutAll: ' whileTrue.';						cr]				ifFalse: 					[stream						nextPutAll: each expression;						nextPutAll: ' ifTrue: ['.					stream						nextPutAll: (methodMap at: each to									ifAbsentPut: 										[each to 											asStatement: methodMap											usingSelectorMap: aDictionary											forClass: aClass]);						nextPutAll: '].';						cr]].	(transitions notEmpty or: [action isNil]) 		ifTrue: 			[stream				nextPutAll: '^self reportLastMatch';				cr].	^stream contents</body><body package="SmaCC Development">compileInto: aClass usingSelectorMap: aDictionary 	| methodNodes methodMap index |	methodNodes := self statesToMakeIntoMethods.	methodMap := self methodNameMapFor: methodNodes.	index := 0.	methodNodes do: 			[:each | 			| stream |			stream := WriteStream on: (String new: 1000).			stream				nextPutAll: (each = self 							ifTrue: ['scanForToken']							ifFalse: ['scan' , (index := index + 1) printString]);				cr.			stream nextPutAll: (each 						asStatement: methodMap						usingSelectorMap: aDictionary						forClass: aClass).			aClass 				compile: (self optimizedParseTreeFor: stream contents) formattedCode				classified: #'generated-scanner']</body><body package="SmaCC Development">methodNameMapFor: methodNodes 	| index methodMap |	methodMap := Dictionary new.	index := 0.	methodNodes do: 			[:value | 			methodMap at: value				put: (value = self 						ifTrue: ['^self scanForToken']						ifFalse: ['^self scan' , (index := index + 1) printString])].	^methodMap</body><body package="SmaCC Development">needsSeparateMethod	^self allStates size &gt; MaxSubNodesInMethod</body><body package="SmaCC Development">optimizationRewriter	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter		replace: 'Core.Character' with: 'Character';		replace: '`@.Stmts1.				[`@.Stmts2.				currentCharacter ~~ `#l] whileTrue.				currentCharacter == `#l ifTrue: [`@.Stmts3].				`@.Stmts4'			with: '`@.Stmts1.				[`@.Stmts2.				currentCharacter ~~ `#l] whileTrue.				`@.Stmts3';		replaceMethod: '`name							`@.Stmts1.							`@a ifTrue: [`@.Stmts2.									^self `name].							`@.Stmts3'			with: '`name				[`@.Stmts1.				`@a] whileTrue: [`@.Stmts2].				`@.Stmts3';		replace: '`@.Stmts1.				currentCharacter isLiteral ifTrue: [`@.Stmts2].				`@.Stmts3'			with: '`@.Stmts1.				`@.Stmts2';		replace: '``@.Stmts1.				(`@a ifTrue: [``@.Stmts2]) `{:node :dictionary | | index myStatements |						index := node parent statements indexOf: node.						myStatements := node parent statements.						dictionary at: #size put: ``@.Stmts2 size - (myStatements size - index).						index ~~  myStatements size and: [``@.Stmts2 size &gt;= (myStatements size - index) and: [							(index + 1 to: myStatements size) allSatisfy: [:each | 								(myStatements at: each) = (``@.Stmts2 at: ``@.Stmts2 size - (myStatements size - each))]]]						}.				``@.Stmts3'			with: '``@.Stmts1.				`{:dictionary | RBMessageNode receiver: `@a selector: #ifTrue: arguments: (Array with: (RBBlockNode body: (RBSequenceNode statements: (``@.Stmts2 copyFrom: 1 to: (dictionary at: #size)))))}.				``@.Stmts3';		replace: '`@.Stmts1.				`.Stmt.				`@.Stmts.				`@a ifTrue: [self step. `.Stmt. `@.Stmts].				`@.Stmts2'			with: '`@.Stmts1.				`@a ifTrue: [self step].				`.Stmt.				`@.Stmts.				`@.Stmts2'.	^rewriter</body><body package="SmaCC Development">optimizedParseTreeFor: aString 	| tree rewriter |	tree := RBParser parseMethod: aString.	rewriter := self optimizationRewriter.	[rewriter executeTree: tree] whileTrue: [tree := rewriter tree].	^tree</body><body package="SmaCC Development">sortedTransitionsFor: aClass 	| frequencies |	frequencies := ((aClass realItem) ifNil: [SmaCCScanner]) frequencyTable.	^transitions asSortedCollection: 			[:a :b | 			| aFrequency bFrequency |			aFrequency := a characters inject: 0						into: [:sum :each | sum + (frequencies at: each asInteger \\ frequencies size + 1)].			bFrequency := b characters inject: 0						into: [:sum :each | sum + (frequencies at: each asInteger \\ frequencies size + 1)].			aFrequency &gt; bFrequency 				or: [aFrequency = bFrequency and: [a characters first &lt; b characters first]]]</body><body package="SmaCC Development">statesToMakeIntoMethods	| allStates incoming |	allStates := self allStates.	incoming := Dictionary new.	allStates do: 			[:each | 			each transitions do: 					[:edge | 					each ~= edge to 						ifTrue: [(incoming at: edge to ifAbsentPut: [Set new]) add: each]]].	^(allStates asOrderedCollection select: 			[:each | 			self = each or: 					[each isTerminalNode not and: 							[(incoming at: each ifAbsent: [#()]) size &gt; 1 								or: [each needsSeparateMethod]]]]) 		asSortedCollection: [:a :b | a id &lt; b id]</body><body package="SmaCC Development">writeMatchingCodeOn: aStream usingSelectorMap: aDictionary 	| matchedItem |	action size &gt; 0 		ifTrue: 			[matchedItem := aDictionary at: action first ifAbsent: [action asArray].			aStream nextPutAll: (transitions isEmpty 						ifTrue: ['^self recordAndReportMatch:']						ifFalse: ['self recordMatch: ']).			matchedItem isSymbol 				ifTrue: [aStream nextPutAll: matchedItem storeString]				ifFalse: 					[aStream nextPutAll: '#('.					matchedItem do: [:each | aStream nextPutAll: each storeString]						separatedBy: [aStream nextPut: $ ].					aStream nextPut: $)].			aStream				nextPut: $.;				cr].	transitions notEmpty 		ifTrue: 			[aStream				nextPutAll: 'self step.';				cr]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNode</class-id> <category>initialize-release</category><body package="SmaCC Development">action: anObject 	anObject isNil ifTrue: [^self].	action := anObject isSymbol 				ifTrue: [anObject]				ifFalse: [SortedCollection with: anObject]</body><body package="SmaCC Development">initialize	id := NextId := NextId + 1.	transitions := SortedCollection new</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNode</class-id> <category>testing</category><body package="SmaCC Development">hasSimpleLoop	^transitions anySatisfy: [:each | each to = self]</body><body package="SmaCC Development">isTerminalNode	^transitions isEmpty or: [transitions size = 1 and: [self hasSimpleLoop]]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNode</class-id> <category>edges</category><body package="SmaCC Development">addEdgeTo: endNode 	transitions add: (SmaCCEdge to: endNode on: nil)</body><body package="SmaCC Development">addEdgeTo: endNode on: characterCollection 	transitions add: (SmaCCEdge to: endNode on: characterCollection)</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNode</class-id> <category>printing</category><body package="SmaCC Development">printOn: aStream 	aStream		nextPutAll: self class name;		nextPut: $(;		nextPutAll: id printString;		nextPut: $)</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNode</class-id> <category>comparing</category><body package="SmaCC Development">= anObject 	^self class = anObject class and: [self id = anObject id]</body><body package="SmaCC Development">hash	^id bitShift: 4</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNode</class-id> <category>converting</category><body package="SmaCC Development">asDFA	self asDFA: Set new merged: Dictionary new.	self removeDuplicateNodes.	^self</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNode</class-id> <category>simulating</category><body package="SmaCC Development">simulate: aStream 	| char |	aStream atEnd ifTrue: [^action].	char := aStream next.	transitions 		do: [:each | (each characters includes: char) ifTrue: [^each to simulate: aStream]].	^nil</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNode class</class-id> <category>instance creation</category><body package="SmaCC Development">new	^(super new)		initialize;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNode class</class-id> <category>class initialization</category><body package="SmaCC Development">initialize	NextId := 0.	MaxSubNodesInMethod := 20</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNode class</class-id> <category>accessing</category><body package="SmaCC Development">maxSubNodesInMethod	^MaxSubNodesInMethod</body><body package="SmaCC Development">maxSubNodesInMethod: anInteger	MaxSubNodesInMethod := anInteger</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScannerScanner</class-id> <category>generated-scanner</category><body package="SmaCC Development">scan1		[self step.	currentCharacter &lt;= $[ or: [currentCharacter &gt;= $^]] whileTrue.	currentCharacter == $\ ifTrue: [^self scan2].	currentCharacter == $] ifTrue: [^self recordAndReportMatch: #(10)].	^self reportLastMatch</body><body package="SmaCC Development">scan2	self step.	(currentCharacter &lt;= $b 		or: [(currentCharacter between: $d and: $w) or: [currentCharacter &gt;= $y]]) 			ifTrue: [^self scan1].	currentCharacter == $c 		ifTrue: 			[self step.			(currentCharacter between: $A and: $Z) ifTrue: [^self scan1].			^self reportLastMatch].	currentCharacter == $x 		ifTrue: 			[self step.			(currentCharacter isDigit or: 					[(currentCharacter between: $A and: $F) 						or: [currentCharacter between: $a and: $f]]) 				ifTrue: [^self scan1]].	^self reportLastMatch</body><body package="SmaCC Development">scanForToken	self step.	(currentCharacter &lt;= Character backspace or: 			[currentCharacter == Character newPage or: 					[(currentCharacter between: (Character value: 14) and: (Character value: 31)) 						or: 							[(currentCharacter between: $! and: $") or: 									[(currentCharacter between: $$ and: $') or: 											[(currentCharacter between: $) and: $-) or: 													[(currentCharacter between: $/ and: $;) or: 															[(currentCharacter between: $= and: $Z) 																or: [(currentCharacter between: $] and: $z) or: [currentCharacter &gt;= $|]]]]]]]]]) 		ifTrue: [^self recordAndReportMatch: #(15)].	((currentCharacter between: Character tab and: (Character value: 11)) or: 			[currentCharacter == Character cr or: [currentCharacter == Character space]]) 		ifTrue: 			[			[self recordMatch: #whitespace.			self step.			(currentCharacter between: Character tab and: (Character value: 11)) or: 					[currentCharacter == Character cr or: [currentCharacter == Character space]]] 					whileTrue.			^self reportLastMatch].	currentCharacter == $# 		ifTrue: 			[self recordMatch: #comment.			self step.			(currentCharacter &lt;= Character tab or: 					[(currentCharacter between: (Character value: 11) and: Character newPage) 						or: [currentCharacter &gt;= (Character value: 14)]]) 				ifTrue: 					[					[self recordMatch: #comment.					self step.					currentCharacter &lt;= Character tab or: 							[(currentCharacter between: (Character value: 11) and: Character newPage) 								or: [currentCharacter &gt;= (Character value: 14)]]] 							whileTrue].			^self reportLastMatch].	currentCharacter == $( ifTrue: [^self recordAndReportMatch: #(2)].	currentCharacter == $. ifTrue: [^self recordAndReportMatch: #(16)].	currentCharacter == $&lt; 		ifTrue: 			[self recordMatch: #(15).			self step.			(currentCharacter isAlphabetic or: [currentCharacter == $_]) 				ifTrue: 					[					[self step.					currentCharacter isAlphaNumeric or: [currentCharacter == $_]] 							whileTrue.					currentCharacter == $&gt; ifTrue: [^self recordAndReportMatch: #(12)]].			^self reportLastMatch].	currentCharacter == $[ 		ifTrue: 			[self step.			(currentCharacter &lt;= $[ or: [currentCharacter &gt;= $^]) 				ifTrue: [^self scan1].			currentCharacter == $\ ifTrue: [^self scan2].			^self reportLastMatch].	currentCharacter == $\ 		ifTrue: 			[self step.			(currentCharacter &lt;= $b 				or: [(currentCharacter between: $d and: $w) or: [currentCharacter &gt;= $y]]) 					ifTrue: [^self recordAndReportMatch: #(9)].			currentCharacter == $c 				ifTrue: 					[self step.					(currentCharacter between: $A and: $Z) 						ifTrue: [^self recordAndReportMatch: #(9)].					^self reportLastMatch].			currentCharacter == $x 				ifTrue: 					[self step.					(currentCharacter isDigit or: 							[(currentCharacter between: $A and: $F) 								or: [currentCharacter between: $a and: $f]]) 						ifTrue: 							[self recordMatch: #(9).							self step.							(currentCharacter isDigit or: 									[(currentCharacter between: $A and: $F) 										or: [currentCharacter between: $a and: $f]]) 								ifTrue: 									[self recordMatch: #(9).									self step.									(currentCharacter isDigit or: 											[(currentCharacter between: $A and: $F) 												or: [currentCharacter between: $a and: $f]]) 										ifTrue: 											[self recordMatch: #(9).											self step.											(currentCharacter isDigit or: 													[(currentCharacter between: $A and: $F) 														or: [currentCharacter between: $a and: $f]]) 												ifTrue: [^self recordAndReportMatch: #(9)].											^self reportLastMatch]].							^self reportLastMatch]].			^self reportLastMatch].	currentCharacter == ${ 		ifTrue: 			[			[self step.			currentCharacter isDigit] whileTrue.			currentCharacter == $, 				ifTrue: 					[					[self step.					currentCharacter isDigit] whileTrue.					currentCharacter == $} ifTrue: [^self recordAndReportMatch: #(14)].					^self reportLastMatch]].	^self reportLastMatch</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScannerScanner</class-id> <category>generated-tokens</category><body package="SmaCC Development">emptySymbolTokenId	^21</body><body package="SmaCC Development">errorTokenId	^22</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScannerScanner class</class-id> <category>generated-comments</category><body package="SmaCC Development">scannerDefinitionComment	"&lt;backslashcharacter&gt;	:	\\ [^cx] | \\ c [A-Z] | \\ x [0-9A-Fa-f]{1,4} ;&lt;characterblock&gt;	: \[ ([^\]\\] | &lt;backslashcharacter&gt; )+ \] ;&lt;whitespace&gt;	:	[\ \t\v\r\n]+ ;&lt;tokenname&gt;	:	\&lt; [a-zA-Z_] \w* \&gt; ;&lt;comment&gt;	:	\# [^\r\n]* ;&lt;repeat&gt;	:	\{ [0-9]* \, [0-9]* \} ;&lt;character&gt;	:	[^\ \t\v\\\r\n\{\(\[\.] ; &lt;anycharacter&gt;	: \. ;"</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScannerScanner class</class-id> <category>generated-initialization</category><body package="SmaCC Development">initializeKeywordMap	keywordMap := Dictionary new.	#(#(15 ')' 1) #(15 '*' 4) #(15 '+' 5) #(15 ':' 6) #(15 ';' 7) #(15 '?' 8) #(15 '|' 3)) 		do: 			[:each | 			(keywordMap at: each first ifAbsentPut: [Dictionary new]) at: (each at: 2)				put: each last].	^keywordMap</body></methods><methods><class-id>Refactory.SmaCC.SmaCCAction</class-id> <category>testing</category><body package="SmaCC Development">isReduce	^false</body><body package="SmaCC Development">isShift	^false</body></methods><methods><class-id>Refactory.SmaCC.SmaCCAction</class-id> <category>accessing</category><body package="SmaCC Development">id	^self subclassResponsibility</body></methods><methods><class-id>Refactory.SmaCC.SmaCCReduceAction</class-id> <category>accessing</category><body package="SmaCC Development">id	^2r10</body><body package="SmaCC Development">rhs	^rhs</body><body package="SmaCC Development">size	^rhs size</body><body package="SmaCC Development">symbol	^symbol</body></methods><methods><class-id>Refactory.SmaCC.SmaCCReduceAction</class-id> <category>initialize-release</category><body package="SmaCC Development">symbol: aSymbol rhs: aRHS	rhs := aRHS.	symbol := aSymbol</body></methods><methods><class-id>Refactory.SmaCC.SmaCCReduceAction</class-id> <category>testing</category><body package="SmaCC Development">isReduce	^true</body></methods><methods><class-id>Refactory.SmaCC.SmaCCReduceAction class</class-id> <category>instance creation</category><body package="SmaCC Development">symbol: aSymbol rhs: aRHS	^self new symbol: aSymbol rhs: aRHS</body></methods><methods><class-id>Refactory.SmaCC.SmaCCShiftAction</class-id> <category>accessing</category><body package="SmaCC Development">id	^2r01</body></methods><methods><class-id>Refactory.SmaCC.SmaCCShiftAction</class-id> <category>testing</category><body package="SmaCC Development">isShift	^true</body></methods><methods><class-id>Refactory.SmaCC.SmaCCShiftAction class</class-id> <category>instance creation</category><body package="SmaCC Development">new	^Shift</body></methods><methods><class-id>Refactory.SmaCC.SmaCCShiftAction class</class-id> <category>class initialization</category><body package="SmaCC Development">initialize	Shift := self basicNew</body><body package="SmaCC Development">releaseObjects	Shift := nil</body></methods><methods><class-id>Refactory.SmaCC.SmaCCAcceptAction</class-id> <category>accessing</category><body package="SmaCC Development">id	^2r00</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRejectAction</class-id> <category>accessing</category><body package="SmaCC Development">id	^2r11</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRejectAction class</class-id> <category>instance creation</category><body package="SmaCC Development">new	^Reject</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRejectAction class</class-id> <category>class initialization</category><body package="SmaCC Development">initialize	Reject := self basicNew</body><body package="SmaCC Development">releaseObjects	Reject := nil</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRHS</class-id> <category>private</category><body package="SmaCC Development">collection	^collection</body><body package="SmaCC Development">defaultReduceAction	^#reduceFor:</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRHS</class-id> <category>accessing</category><body package="SmaCC Development">add: aGrammarSymbol 	collection add: aGrammarSymbol</body><body package="SmaCC Development">at: anInteger 	^collection at: anInteger</body><body package="SmaCC Development">do: aBlock	collection do: aBlock</body><body package="SmaCC Development">firstTerminals	| items |	collection isEmpty ifTrue: [^Set with: SmaCCSymbol empty].	items := Set new.	1 to: collection size		do: 			[:index | 			items addAll: (collection at: index) firstTerminals.			(items includes: SmaCCSymbol empty) 				ifTrue: [index &lt; collection size ifTrue: [items remove: SmaCCSymbol empty]]				ifFalse: [^items]].	^items</body><body package="SmaCC Development">nameLastItem: aString 	variableNames at: aString put: collection size</body><body package="SmaCC Development">reduceAction	^reduceAction</body><body package="SmaCC Development">reduceAction: anObject	reduceAction := anObject</body><body package="SmaCC Development">size	^collection size</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRHS</class-id> <category>reduction table</category><body package="SmaCC Development">compileSourceFor: aGrammarSymbol in: aClass 	| action rewriter parseTree methodName |	action := self reduceAction.	action isNil ifTrue: [^self defaultReduceAction].	parseTree := RBParser parseExpression: action				onError: 					[:s :p | 					SmaCCCompilationNotification 						raiseRequestWith: aGrammarSymbol name , ' : ' , self printString 								, '\\' withCRs , action						errorString: 'Invalid Smalltalk code in reduction rule'.					^self defaultReduceAction].	(parseTree isLiteral and: 			[parseTree value isSymbol and: 					[parseTree value numArgs &lt;= 1 and: [aClass definesMethod: parseTree value]]]) 		ifTrue: [^parseTree value].	rewriter := self parseTreeRewriter.	rewriter executeTree: parseTree.	parseTree := rewriter tree.	methodName := ('reduceActionFor' 				, (self safeMethodNameFor: aGrammarSymbol) 					, (aGrammarSymbol positionOf: self) printString , ':') 				asSymbol.	parseTree isSequence 		ifFalse: [parseTree := RBSequenceNode statements: (Array with: parseTree)].	parseTree := RBMethodNode 				selector: methodName				arguments: (Array with: (RBVariableNode named: 'nodes'))				body: parseTree.	parseTree addReturn.	aClass compile: parseTree formattedCode		classified: 'generated-reduction actions'.	^methodName</body><body package="SmaCC Development">parseTreeRewriter	| rewriter |	rewriter := ParseTreeRewriter new.	1 to: self size		do: 			[:i | 			rewriter replace: i printString storeString				with: '(nodes at: ' , i printString , ')'].	variableNames keysAndValuesDo: 			[:key :value | 			rewriter replace: key with: '(nodes at: ' , value printString , ')'].	^rewriter</body><body package="SmaCC Development">safeMethodNameFor: aGrammarSymbol 	^aGrammarSymbol printString 		collect: [:each | each isAlphaNumeric ifTrue: [each] ifFalse: [$_]]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRHS</class-id> <category>initialize-release</category><body package="SmaCC Development">initialize	collection := OrderedCollection new.	reduceAction := nil.	variableNames := Dictionary new</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRHS</class-id> <category>printing</category><body package="SmaCC Development">printOn: aStream 	^collection do: [:each | each printOn: aStream]		separatedBy: [aStream space]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRHS</class-id> <category>comparing</category><body package="SmaCC Development">= aRHS 	^self class = aRHS class and: [collection = aRHS collection]</body><body package="SmaCC Development">hash	^self class hash bitXor: (collection hash bitShift: 14)</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRHS class</class-id> <category>instance creation</category><body package="SmaCC Development">new	^(super new)		initialize;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammarCompiler</class-id> <category>compiling</category><body package="SmaCC Development">changes	^model changes</body><body package="SmaCC Development">compileChanges	RefactoryChangeManager instance performChange: self changes.	scannerCompiler scannerClass realItem 		ifNotNil: [:each | each initializeKeywordMap]</body><body package="SmaCC Development">compileDefinitionComments	scannerCompiler compileScannerDefinitionComment.	self compileParserDefinitionComment</body><body package="SmaCC Development">compileInto: sClass andParser: pClass 	self scannerClass: sClass.	self parserClass: pClass.	self createChanges.	self compileChanges</body><body package="SmaCC Development">compileItemSetsComment	| stream |	stream := WriteStream on: (String new: 1000).	stream		nextPutAll: 'itemSetsComment';		cr;		cr;		tab;		nextPut: $";		cr.	(1 to: itemSets size) with: itemSets		do: 			[:index :each | 			stream				nextPutAll: index printString;				nextPutAll: (each printString copyReplaceAll: '"' with: '""');				cr].	stream nextPut: $".	self parserClass metaclass compile: stream contents		classified: #'generated-comments'</body><body package="SmaCC Development">compileParser	self compileTransitionTable.	self compileStartingStateIds.	self compileReductionTable.	self compileScannerClassIntoParser</body><body package="SmaCC Development">compileParserDefinitionComment	| stream |	stream := WriteStream on: (String new: 1000).	stream		nextPutAll: 'parserDefinitionComment';		cr;		cr;		tab;		nextPut: $";		nextPutAll: (parserDefinitionString copyReplaceAll: '"'					with: '""');		nextPut: $".	parserClass metaclass compile: stream contents		classified: #'generated-comments'</body><body package="SmaCC Development">compileReductionTable	| stream |	stream := WriteStream on: (String new: 1000).	stream		nextPutAll: 'reduceTable';		cr;		tab;		nextPutAll: '^#(';		cr.	self reduceTable do: 			[:each | 			stream nextPutAll: '#('.			each do: [:e | stream nextPutAll: e storeString]				separatedBy: [stream space].			stream				nextPut: $);				cr].	stream nextPut: $).	parserClass compile: stream contents classified: #'generated-tables'</body><body package="SmaCC Development">compileScannerClassIntoParser	| stream |	stream := WriteStream on: (String new: 1000).	stream		nextPutAll: 'scannerClass';		cr;		tab;		nextPutAll: '^';		nextPutAll: (self parserClass environment 					= scannerCompiler scannerClass environment 						ifTrue: [scannerCompiler scannerClass name]						ifFalse: [scannerCompiler scannerClass fullName]).	self parserClass metaclass compile: stream contents		classified: #'generated-accessing'</body><body package="SmaCC Development">compileStartingStateIds	startingStateMap keysAndValuesDo: 			[:symbol :position | 			| stream |			stream := WriteStream on: (String new: 1000).			stream				nextPutAll: 'startingStateFor';				nextPutAll: symbol compileName;				cr;				tab;				nextPutAll: '^';				nextPutAll: position printString.			parserClass metaclass compile: stream contents				classified: #'generated-starting states']</body><body package="SmaCC Development">compileSymbolComment	| stream |	stream := WriteStream on: (String new: 1000).	stream		nextPutAll: 'symbolComment';		cr;		cr;		tab;		nextPut: $";		cr.	(1 to: scannerCompiler symbols size) with: scannerCompiler symbols		do: 			[:index :each | 			stream				nextPutAll: index printString;				nextPutAll: '. ';				nextPutAll: (each printString copyReplaceAll: '"' with: '""');				cr].	stream nextPut: $".	self parserClass metaclass compile: stream contents		classified: #'generated-comments'</body><body package="SmaCC Development">compileTransitionTable	| stream |	stream := WriteStream on: (String new: 1000).	stream		nextPutAll: 'transitionTable';		cr;		tab;		nextPutAll: '^#(';		cr.	self transitionTable do: 			[:each | 			stream nextPutAll: '#['.			each do: [:byte | stream nextPutAll: byte printString]				separatedBy: [stream nextPut: $ ].			stream				nextPut: $];				cr].	stream nextPut: $).	parserClass compile: stream contents classified: #'generated-tables'</body><body package="SmaCC Development">createChanges	self removeOldMethods.	self checkForEmptySymbols.	self checkForUnusedSymbols.	scannerCompiler compileScanner.	self compileParser</body><body package="SmaCC Development">defineClass: aString asSubclassOf: aBehavior 	| path name namespace |	path := OrderedCollection withAll: aString asQualifiedReference path.	name := path removeLast.	namespace := model smalltalkNameSpace.	namespace := path inject: namespace				into: 					[:sum :each | 					| item |					item := sum itemFor: each.					item isNil 						ifTrue: 							[sum defineNameSpace: sum fullName , ' defineNameSpace: #' , each 										, ' private: false imports: ''''	category: ''SmaCC Generated Scanner/Parser'''.							item := sum itemFor: each].					item].	model 		defineClass: namespace fullName , ' defineClass: #' , name 				, ' superclass: #{' , aBehavior fullName 				, '} indexedType: #none private: false instanceVariableNames: '''' classInstanceVariableNames: '''' imports: '''' category: ''SmaCC Generated Scanner/Parser'''.	^namespace itemFor: name</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammarCompiler</class-id> <category>initialize-release</category><body package="SmaCC Development">buildScanner: scannerString andParser: parserString 	| parser |	scannerCompiler grammar: self grammar.	scannerCompiler scannerDefinitionString: scannerString.	parserDefinitionString := parserString.	scannerCompiler parseTokens.	parser := SmaCCGrammarParser on: (ReadStream on: parserString).	parser grammar: grammar.	parser parse</body><body package="SmaCC Development">initialize	scannerCompiler := SmaCCScannerCompiler new.	model := (RBRootNameSpace new)				description: 'Compile Scanner/Parser';				yourself.	startingStateMap := Dictionary new</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammarCompiler</class-id> <category>private</category><body package="SmaCC Development">checkForEmptySymbols	| problemSymbols stream |	problemSymbols := grammar emptySymbols.	problemSymbols isEmpty ifTrue: [^self].	stream := WriteStream on: String new.	problemSymbols do: [:each | stream nextPutAll: each printString]		separatedBy: [stream space].	SmaCCCompilationNotification raiseRequestWith: stream contents		errorString: 'Missing non-terminal productions'</body><body package="SmaCC Development">checkForUnusedSymbols	| problemSymbols stream |	problemSymbols := grammar unusedSymbols.	problemSymbols isEmpty ifTrue: [^self].	stream := WriteStream on: String new.	problemSymbols do: [:each | stream nextPutAll: each printString]		separatedBy: [stream space].	SmaCCCompilationNotification raiseRequestWith: stream contents		errorString: 'Unused non-terminal symbols'</body><body package="SmaCC Development">removeOldMethods	self		removeOldMethodsFrom: scannerCompiler scannerClass;		removeOldMethodsFrom: scannerCompiler scannerClass metaclass;		removeOldMethodsFrom: parserClass;		removeOldMethodsFrom: parserClass metaclass</body><body package="SmaCC Development">removeOldMethodsFrom: aRBClass 	(aRBClass selectors select: 			[:each | 			(aRBClass protocolsFor: each) 				allSatisfy: [:protocol | protocol notNil and: ['generated*' match: protocol]]]) 		do: [:each | aRBClass removeMethod: each]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammarCompiler</class-id> <category>action table</category><body package="SmaCC Development">actionForState: anInteger on: aGrammarSymbol 	| action newStateIndex |	action := (itemSets at: anInteger) action: aGrammarSymbol				prefer: (grammar preferredActionFor: aGrammarSymbol).	action isShift 		ifTrue: 			[newStateIndex := shiftTable 						at: (Array with: anInteger with: aGrammarSymbol).			^(newStateIndex bitShift: 2) + action id].	action isReduce 		ifTrue: 			[^((grammar reduceTableIndexFor: action symbol rhs: action rhs) 				bitShift: 2) + action id].	^action id</body><body package="SmaCC Development">compressTable: table 	^table collect: 			[:row | 			| stream uniqueItems |			stream := WriteStream on: ByteArray new.			uniqueItems := (row asSet)						remove: 3 ifAbsent: [];						asArray.			uniqueItems size = 1 				ifTrue: 					[stream nextPut: 0.					stream						nextPut: (uniqueItems first bitShift: -8);						nextPut: (uniqueItems first bitAnd: 16rFF).					(1 to: row size) with: row						do: 							[:index :each | 							each ~= 3 								ifTrue: 									[stream										nextPut: (index bitShift: -8);										nextPut: (index bitAnd: 16rFF)]]]				ifFalse: 					[stream nextPut: 1.					(1 to: row size) with: row						do: 							[:index :each | 							each ~= 3 								ifTrue: 									[stream										nextPut: (each bitShift: -8);										nextPut: (each bitAnd: 16rFF);										nextPut: (index bitShift: -8);										nextPut: (index bitAnd: 16rFF)]]].			stream contents]</body><body package="SmaCC Development">createItemSets	| itemSet newState index |	startingStateMap := Dictionary new.	grammar calculateFirstSets.	itemSets := OrderedCollection new.	grammar allStartingSymbols do: 			[:each | 			itemSets add: (grammar initialItemSetFor: each).			startingStateMap at: each put: itemSets size].	shiftTable := Dictionary new.	index := 1.	[index &lt;= itemSets size] whileTrue: 			[itemSet := itemSets at: index.			grammar symbols do: 					[:each | 					newState := itemSet moveOn: each.					newState notEmpty 						ifTrue: 							[shiftTable at: (Array with: index with: each)								put: (self indexOfState: newState)]].			index := index + 1]</body><body package="SmaCC Development">createTransitionTable	| table |	table := OrderedCollection new.	(1 to: itemSets size) with: itemSets		do: 			[:index :each | 			table add: ((1 to: scannerCompiler symbols size) 						collect: [:i | self actionForState: index on: (scannerCompiler symbols at: i)])].	actions := self compressTable: table</body><body package="SmaCC Development">indexOfState: newState 	| newStateIndex |	newStateIndex := itemSets indexOf: newState.	newStateIndex = 0 		ifTrue: 			[itemSets add: newState.			newStateIndex := itemSets size]		ifFalse: [(itemSets at: newStateIndex) mergeWith: newState].	^newStateIndex</body><body package="SmaCC Development">transitionTable	actions isNil 		ifTrue: 			[self createItemSets.			self createTransitionTable].	^actions</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammarCompiler</class-id> <category>accessing</category><body package="SmaCC Development">grammar	^grammar isNil ifTrue: [grammar := SmaCCGrammar new] ifFalse: [grammar]</body><body package="SmaCC Development">parserClass	^parserClass</body><body package="SmaCC Development">parserClass: aClassOrString 	(aClassOrString isKindOf: Behavior) 		ifTrue: [parserClass := model classFor: aClassOrString]		ifFalse: 			[parserClass := model referencedItem: aClassOrString.			parserClass isNil 				ifTrue: [parserClass := self defineClass: aClassOrString asSubclassOf: SmaCCParser]]</body><body package="SmaCC Development">scannerClass: aClassOrString 	(aClassOrString isKindOf: Behavior) 		ifTrue: [scannerCompiler scannerClass: (model classFor: aClassOrString)]		ifFalse: 			[scannerCompiler scannerClass: (model referencedItem: aClassOrString).			scannerCompiler scannerClass isNil 				ifTrue: 					[scannerCompiler 						scannerClass: (self defineClass: aClassOrString asSubclassOf: SmaCCScanner)]]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammarCompiler</class-id> <category>reduction table</category><body package="SmaCC Development">reduceTable	| table |	table := OrderedCollection new.	scannerCompiler symbols do: 			[:each | 			each isTerminal 				ifFalse: 					[each productionsDo: 							[:rhs | 							table add: (Array 										with: (scannerCompiler symbols indexOf: each)										with: rhs size										with: (rhs compileSourceFor: each in: parserClass))]]].	^table</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammarCompiler class</class-id> <category>instance creation</category><body package="SmaCC Development">new	^self basicNew initialize</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRegularExpressionNode</class-id> <category>accessing</category><body package="SmaCC Development">, aScannerNode 	^SmaCCSequenceRENode nodes: (OrderedCollection with: self with: aScannerNode)</body><body package="SmaCC Development">position	^position</body><body package="SmaCC Development">position: anInteger	position := anInteger</body><body package="SmaCC Development">possibleMatches	| matches |	matches := OrderedCollection new.	self possibleMatchesDo: [:each | matches add: each].	^matches</body><body package="SmaCC Development">possibleMatchesDo: aBlock 	| stream |	stream := WriteStream on: String new.	self possibleMatchesDo: [aBlock value: stream contents] on: stream</body><body package="SmaCC Development">possibleMatchesSize	^self subclassResponsibility</body><body package="SmaCC Development">repeat	^SmaCCRepeatingRENode component: self</body><body package="SmaCC Development">repeatFor: minimum to: maximum 	^SmaCCRepeatingRENode 		component: self		minimum: minimum		maximum: maximum</body><body package="SmaCC Development">repeatForAtLeast: minimum 	^SmaCCRepeatingRENode component: self minimum: minimum</body><body package="SmaCC Development">| aScannerNode 	^SmaCCOrRENode nodes: (OrderedCollection with: self with: aScannerNode)</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRegularExpressionNode</class-id> <category>initialize-release</category><body package="SmaCC Development">action	^action</body><body package="SmaCC Development">action: aString	action := aString</body><body package="SmaCC Development">initialize</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRegularExpressionNode</class-id> <category>private</category><body package="SmaCC Development">asNFAStartingWith: startNode 	^self subclassResponsibility</body><body package="SmaCC Development">possibleMatchesDo: aBlock on: aStream 	self subclassResponsibility</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRegularExpressionNode</class-id> <category>converting</category><body package="SmaCC Development">asDFA	| startNode |	startNode := SmaCCNode new.	self asNFAStartingWith: startNode.	^startNode asNFAWithoutEpsilonTransitions asDFA</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRegularExpressionNode</class-id> <category>testing</category><body package="SmaCC Development">isKeywordLiteral	^self possibleMatchesSize &lt; 50</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRegularExpressionNode class</class-id> <category>instance creation</category><body package="SmaCC Development">new	^(super new)		initialize;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCharacterRENode</class-id> <category>printing</category><body package="SmaCC Development">printCharacter: aCharacter on: aStream 	(aCharacter asInteger between: 32 and: 126) 		ifTrue: [^aStream nextPut: aCharacter].	aStream nextPutAll: '\x'.	aCharacter asInteger 		printOn: aStream		paddedWith: $0		to: 2		base: 16</body><body package="SmaCC Development">printOn: aStream 	| allCharacters |	characters size = 1 		ifTrue: [^self printCharacter: characters first on: aStream].	aStream nextPut: $[.	allCharacters := characters.	characters size &gt; 128 		ifTrue: 			[aStream nextPut: $^.			allCharacters := ((0 to: SmaCCGrammar maximumCharacterValue) 						collect: [:each | Character value: each]) 							reject: [:each | characters includes: each]].	allCharacters do: [:each | self printCharacter: each on: aStream].	aStream nextPut: $]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCharacterRENode</class-id> <category>private</category><body package="SmaCC Development">asNFAStartingWith: startNode 	| endNode |	endNode := SmaCCNode new.	endNode action: action.	startNode addEdgeTo: endNode on: characters.	^endNode</body><body package="SmaCC Development">characters	^characters</body><body package="SmaCC Development">matchingCharacters	^SmaCCGrammar ignoreCase 		ifTrue: [characters reject: [:each | each isLowercase]]		ifFalse: [characters]</body><body package="SmaCC Development">possibleMatchesDo: aBlock on: aStream 	self matchingCharacters do: 			[:each | 			aStream nextPut: each.			aBlock value.			aStream skip: -1]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCharacterRENode</class-id> <category>testing</category><body package="SmaCC Development">canMergeWith: aScannerNode 	^self class = aScannerNode class and: 			[characters notNil 				and: [aScannerNode characters notNil and: [self action = aScannerNode action]]]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCharacterRENode</class-id> <category>initialize-release</category><body package="SmaCC Development">characters: aString 	characters := aString</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCharacterRENode</class-id> <category>accessing</category><body package="SmaCC Development">possibleMatchesSize	^self matchingCharacters size</body><body package="SmaCC Development">| aScannerNode 	(self canMergeWith: aScannerNode) ifFalse: [^super | aScannerNode].	characters := String 				withAll: ((characters , aScannerNode characters) asSet 						asSortedCollection: [:a :b | a asInteger &lt; b asInteger]).	^self</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCharacterRENode class</class-id> <category>instance creation</category><body package="SmaCC Development">characters: aString 	^(self new)		characters: (self sortedCharactersFor: aString);		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCCharacterRENode class</class-id> <category>private</category><body package="SmaCC Development">sortedCharactersFor: aString 	| characters stream |	SmaCCGrammar ignoreCase 		ifTrue: 			[stream := WriteStream on: String new.			aString do: 					[:each | 					stream						nextPut: each asUppercase;						nextPut: each asLowercase]]		ifFalse: 			[stream := WriteStream on: (String new: aString size).			stream nextPutAll: aString].	characters := stream contents 				asSortedCollection: [:a :b | a asInteger &lt; b asInteger].	stream := WriteStream on: String new.	characters inject: nil		into: 			[:sum :each | 			sum = each ifFalse: [stream nextPut: each].			each].	^stream contents</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRepeatingRENode</class-id> <category>private</category><body package="SmaCC Development">asNFAStartingWith: startNode 	| endNode start |	endNode := SmaCCNode new.	endNode action: action.	start := startNode.	minimumMatches timesRepeat: [start := node asNFAStartingWith: start].	start addEdgeTo: endNode.	maximumMatches &lt; self class finiteInfinity 		ifTrue: 			[maximumMatches - minimumMatches timesRepeat: 					[start := node asNFAStartingWith: start.					start addEdgeTo: endNode]]		ifFalse: [(node asNFAStartingWith: start) addEdgeTo: start].	^endNode</body><body package="SmaCC Development">possibleMatchesDo: aBlock on: aStream 	self 		possibleMatchesDo: aBlock		on: aStream		startingAt: 1</body><body package="SmaCC Development">possibleMatchesDo: aBlock on: aStream startingAt: anInteger 	(anInteger between: minimumMatches and: maximumMatches) 		ifTrue: [aBlock value].	anInteger = maximumMatches 		ifTrue: [node possibleMatchesDo: aBlock on: aStream]		ifFalse: 			[node possibleMatchesDo: 					[self 						possibleMatchesDo: aBlock						on: aStream						startingAt: anInteger + 1]				on: aStream]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRepeatingRENode</class-id> <category>accessing</category><body package="SmaCC Development">possibleMatchesSize	^node possibleMatchesSize * (maximumMatches - minimumMatches + 1)</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRepeatingRENode</class-id> <category>initialize-release</category><body package="SmaCC Development">component: aScannerNode minimum: minInteger maximum: maxInteger 	node := aScannerNode.	minimumMatches := minInteger.	maximumMatches := maxInteger</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRepeatingRENode</class-id> <category>printing</category><body package="SmaCC Development">printOn: aStream 	node printOn: aStream.	maximumMatches = (1 bitShift: 31) 		ifTrue: 			[minimumMatches = 0 ifTrue: [^aStream nextPut: $*].			minimumMatches = 1 ifTrue: [^aStream nextPut: $+].			^aStream				nextPut: ${;				nextPutAll: minimumMatches printString;				nextPutAll: ',}'].	aStream		nextPut: ${;		nextPutAll: minimumMatches printString;		nextPut: $,;		nextPutAll: maximumMatches printString;		nextPut: $}</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRepeatingRENode class</class-id> <category>instance creation</category><body package="SmaCC Development">component: aScannerNode 	^self component: aScannerNode minimum: 0</body><body package="SmaCC Development">component: aScannerNode minimum: anInteger 	^self 		component: aScannerNode		minimum: anInteger		maximum: self finiteInfinity</body><body package="SmaCC Development">component: aScannerNode minimum: minInteger maximum: maxInteger 	^(self new)		component: aScannerNode			minimum: minInteger			maximum: maxInteger;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCRepeatingRENode class</class-id> <category>constants</category><body package="SmaCC Development">finiteInfinity	"The number that we consider to be 'infinite'"	^2147483648</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSequenceRENode</class-id> <category>copying</category><body package="SmaCC Development">postCopy	super postCopy.	nodes := nodes copy</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSequenceRENode</class-id> <category>private</category><body package="SmaCC Development">asNFAStartingWith: startNode 	| endNode |	endNode := SmaCCNode new.	endNode action: action.	(nodes inject: startNode into: [:sum :each | each asNFAStartingWith: sum]) 		addEdgeTo: endNode.	^endNode</body><body package="SmaCC Development">possibleMatchesDo: aBlock on: aStream 	self 		possibleMatchesDo: aBlock		on: aStream		startingAt: 1</body><body package="SmaCC Development">possibleMatchesDo: aBlock on: aStream startingAt: anInteger 	| node |	node := nodes at: anInteger.	nodes size = anInteger 		ifTrue: [node possibleMatchesDo: aBlock on: aStream]		ifFalse: 			[node possibleMatchesDo: 					[self 						possibleMatchesDo: aBlock						on: aStream						startingAt: anInteger + 1]				on: aStream]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSequenceRENode</class-id> <category>accessing</category><body package="SmaCC Development">, aScannerNode 	self action = aScannerNode action ifFalse: [^super , aScannerNode].	nodes add: aScannerNode.	^self</body><body package="SmaCC Development">possibleMatchesSize	^nodes inject: 1 into: [:sum :each | sum * each possibleMatchesSize]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSequenceRENode</class-id> <category>initialize-release</category><body package="SmaCC Development">nodes: aCollection 	nodes := aCollection</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSequenceRENode</class-id> <category>printing</category><body package="SmaCC Development">printOn: aStream 	nodes do: [:each | each printOn: aStream] separatedBy: [aStream space]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSequenceRENode class</class-id> <category>instance creation</category><body package="SmaCC Development">nodes: aCollection 	^(self new)		nodes: aCollection;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNonTerminalSymbol</class-id> <category>accessing</category><body package="SmaCC Development">addProduction: aRHS	productions add: aRHS</body><body package="SmaCC Development">calculateFirstTerminals	| initialSize |	initialSize := firstItems size.	productions isEmpty 		ifTrue: [firstItems add: self class empty]		ifFalse: [productions do: [:each | firstItems addAll: each firstTerminals]].	^initialSize ~= firstItems size</body><body package="SmaCC Development">positionOf: aRHS 	^productions indexOf: aRHS</body><body package="SmaCC Development">productionsDo: aBlock 	productions do: aBlock</body><body package="SmaCC Development">size	^productions size</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNonTerminalSymbol</class-id> <category>testing</category><body package="SmaCC Development">isEmpty	^productions isEmpty</body><body package="SmaCC Development">isTerminal	^false</body></methods><methods><class-id>Refactory.SmaCC.SmaCCNonTerminalSymbol</class-id> <category>initialize-release</category><body package="SmaCC Development">name: aString 	super name: aString.	productions := OrderedCollection new</body></methods><methods><class-id>Refactory.SmaCC.SmaCCStartingSymbol</class-id> <category>accessing</category><body package="SmaCC Development">asLRItemSet	| itemSet |	itemSet := SmaCCItemSet new.	productions do: 			[:each | 			itemSet add: (SmaCCLR1Item 						symbol: self						rhs: each						follow: ((SmaCCSymbolSet new)								add: self class empty;								yourself))].	^itemSet</body><body package="SmaCC Development">compileName	^(productions first at: 1) name</body></methods><methods><class-id>Refactory.SmaCC.SmaCCStartingSymbol</class-id> <category>testing</category><body package="SmaCC Development">isStartingSymbol	^true</body></methods><methods><class-id>Refactory.SmaCC.SmaCCLR1Item</class-id> <category>initialize-release</category><body package="SmaCC Development">followers: aSymbolSet 	followers := aSymbolSet</body><body package="SmaCC Development">location: anInteger 	location := anInteger</body><body package="SmaCC Development">symbol: productionGrammarSymbol rhs: aRHS follow: aSymbolCollection 	symbol := productionGrammarSymbol.	rhs := aRHS.	location := 1.	followers := aSymbolCollection</body></methods><methods><class-id>Refactory.SmaCC.SmaCCLR1Item</class-id> <category>accessing</category><body package="SmaCC Development">action: aGrammarSymbol 	location &gt; rhs size 		ifTrue: 			[(symbol isStartingSymbol and: [aGrammarSymbol isEmptySymbol]) 				ifTrue: [^SmaCCAcceptAction new].			(followers includes: aGrammarSymbol) 				ifTrue: [^SmaCCReduceAction symbol: symbol rhs: rhs]]		ifFalse: [(rhs at: location) = aGrammarSymbol ifTrue: [^SmaCCShiftAction new]].	^SmaCCRejectAction new</body><body package="SmaCC Development">followers	^followers</body><body package="SmaCC Development">mergeWith: aLRItem 	followers mergeWith: aLRItem followers</body><body package="SmaCC Development">moveNext	^(self copy)		followers: (followers class basedOn: followers);		location: location + 1;		yourself</body><body package="SmaCC Development">nextSymbol	^location &gt; rhs size 		ifTrue: [SmaCCSymbol sentinel]		ifFalse: [rhs at: location]</body><body package="SmaCC Development">precedence	"If we don't have a precedence, then assume we are the lowest precedence (which will cause a shift action)."	| max |	max := -1.	rhs do: [:each | max := max max: (each precedence ifNil: [max])].	^max</body><body package="SmaCC Development">rest	| newRHS |	newRHS := SmaCCRHS new.	location + 1 to: rhs size do: [:each | newRHS add: (rhs at: each)].	^newRHS</body></methods><methods><class-id>Refactory.SmaCC.SmaCCLR1Item</class-id> <category>private</category><body package="SmaCC Development">location	^location</body><body package="SmaCC Development">rhs	^rhs</body><body package="SmaCC Development">symbol	^symbol</body></methods><methods><class-id>Refactory.SmaCC.SmaCCLR1Item</class-id> <category>comparing</category><body package="SmaCC Development">= anItem 	^self class == anItem class and: 			[location = anItem location 				and: [rhs == anItem rhs and: [symbol == anItem symbol]]]</body><body package="SmaCC Development">hash	^(symbol identityHash bitXor: (location bitShift: 14)) 		bitXor: rhs identityHash</body></methods><methods><class-id>Refactory.SmaCC.SmaCCLR1Item</class-id> <category>testing</category><body package="SmaCC Development">isLR1EqualTo: aLRItem 	^self followers size = aLRItem followers size 		and: [self followers allSatisfy: [:each | aLRItem followers includes: each]]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCLR1Item</class-id> <category>printing</category><body package="SmaCC Development">printOn: aStream 	| i |	aStream		nextPut: $[;		nextPutAll: symbol printString;		nextPutAll: ' :'.	i := 1.	rhs do: 			[:each | 			i = location ifTrue: [aStream nextPutAll: ' . '].			aStream				space;				nextPutAll: each printString.			i := i + 1].	location &gt; rhs size ifTrue: [aStream nextPutAll: ' . '].	aStream nextPut: $;.	followers printOn: aStream.	aStream nextPut: $]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCLR1Item class</class-id> <category>instance creation</category><body package="SmaCC Development">symbol: productionGrammarSymbol rhs: aRHS follow: aGrammarSymbolCollection 	^(self new)		symbol: productionGrammarSymbol			rhs: aRHS			follow: aGrammarSymbolCollection;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCOrRENode</class-id> <category>accessing</category><body package="SmaCC Development">possibleMatchesSize	^nodes inject: 0 into: [:sum :each | sum + each possibleMatchesSize]</body><body package="SmaCC Development">| aScannerNode 	self action = aScannerNode action ifFalse: [^super | aScannerNode].	nodes add: aScannerNode.	^self</body></methods><methods><class-id>Refactory.SmaCC.SmaCCOrRENode</class-id> <category>initialize-release</category><body package="SmaCC Development">nodes: aCollection 	nodes := aCollection</body></methods><methods><class-id>Refactory.SmaCC.SmaCCOrRENode</class-id> <category>private</category><body package="SmaCC Development">asNFAStartingWith: startNode 	| endNode |	endNode := SmaCCNode new.	endNode action: action.	nodes do: 			[:each | 			| componentStart |			componentStart := SmaCCNode new.			startNode addEdgeTo: componentStart.			(each asNFAStartingWith: componentStart) addEdgeTo: endNode].	^endNode</body><body package="SmaCC Development">possibleMatchesDo: aBlock on: aStream 	nodes do: 			[:each | 			| pos |			pos := aStream position.			each possibleMatchesDo: aBlock on: aStream.			aStream position: pos]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCOrRENode</class-id> <category>printing</category><body package="SmaCC Development">printOn: aStream 	aStream nextPut: $(.	nodes do: [:each | each printOn: aStream]		separatedBy: [aStream nextPutAll: ' | '].	aStream nextPut: $)</body></methods><methods><class-id>Refactory.SmaCC.SmaCCOrRENode</class-id> <category>copying</category><body package="SmaCC Development">postCopy	super postCopy.	nodes := nodes copy</body></methods><methods><class-id>Refactory.SmaCC.SmaCCOrRENode class</class-id> <category>instance creation</category><body package="SmaCC Development">nodes: aCollection 	^(self new)		nodes: aCollection;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammarScanner</class-id> <category>generated-scanner</category><body package="SmaCC Development">scan1		[	[self step.	currentCharacter ~~ $"] whileTrue.	self recordMatch: #(21).	self step.	currentCharacter == $"] 			whileTrue: [].	^self reportLastMatch</body><body package="SmaCC Development">scan2	self step.	currentCharacter == $&gt; ifTrue: [^self recordAndReportMatch: #(13)].	currentCharacter == $i 		ifTrue: 			[self step.			currentCharacter == $d ifTrue: [^self recordAndReportMatch: #(4)].			^self reportLastMatch].	currentCharacter == $l 		ifTrue: 			[self step.			currentCharacter == $e 				ifTrue: 					[self step.					currentCharacter == $f 						ifTrue: 							[self step.							currentCharacter == $t ifTrue: [^self recordAndReportMatch: #(8)].							^self reportLastMatch]].			^self reportLastMatch].	currentCharacter == $n 		ifTrue: 			[self step.			currentCharacter == $o 				ifTrue: 					[self step.					currentCharacter == $n 						ifTrue: 							[self step.							currentCharacter == $a 								ifTrue: 									[self step.									currentCharacter == $s 										ifTrue: 											[self step.											currentCharacter == $s 												ifTrue: 													[self step.													currentCharacter == $o 														ifTrue: 															[self step.															currentCharacter == $c ifTrue: [^self recordAndReportMatch: #(5)].															^self reportLastMatch]].											^self reportLastMatch]].							^self reportLastMatch]].			^self reportLastMatch].	currentCharacter == $r 		ifTrue: 			[self step.			currentCharacter == $i 				ifTrue: 					[self step.					currentCharacter == $g 						ifTrue: 							[self step.							currentCharacter == $h 								ifTrue: 									[self step.									currentCharacter == $t ifTrue: [^self recordAndReportMatch: #(6)]].							^self reportLastMatch]].			^self reportLastMatch].	currentCharacter == $s 		ifTrue: 			[self step.			currentCharacter == $t 				ifTrue: 					[self step.					currentCharacter == $a 						ifTrue: 							[self step.							currentCharacter == $r 								ifTrue: 									[self step.									currentCharacter == $t ifTrue: [^self recordAndReportMatch: #(3)].									^self reportLastMatch]].					^self reportLastMatch]].	^self reportLastMatch</body><body package="SmaCC Development">scanForToken	self step.	(currentCharacter isAlphabetic or: [currentCharacter == $_]) 		ifTrue: 			[			[self recordMatch: #(20).			self step.			currentCharacter isAlphaNumeric or: [currentCharacter == $_]] 					whileTrue.			^self reportLastMatch].	((currentCharacter between: Character tab and: Character cr) 		or: [currentCharacter == Character space]) 			ifTrue: 				[				[self recordMatch: #whitespace.				self step.				(currentCharacter between: Character tab and: Character cr) 					or: [currentCharacter == Character space]] 						whileTrue.				^self reportLastMatch].	currentCharacter == $" ifTrue: [^self scan1].	currentCharacter == $# 		ifTrue: 			[			[self recordMatch: #comment.			self step.			currentCharacter &lt;= Character tab or: 					[(currentCharacter between: (Character value: 11) and: Character newPage) 						or: [currentCharacter &gt;= (Character value: 14)]]] 					whileTrue.			^self reportLastMatch].	currentCharacter == $% ifTrue: [^self scan2].	currentCharacter == $' 		ifTrue: 			[self step.			(currentCharacter isAlphabetic or: [currentCharacter == $_]) 				ifTrue: 					[					[self step.					currentCharacter isAlphaNumeric or: [currentCharacter == $_]] 							whileTrue.					currentCharacter == $' ifTrue: [^self recordAndReportMatch: #(24)]].			^self reportLastMatch].	currentCharacter == $( ifTrue: [^self recordAndReportMatch: #(17)].	currentCharacter == $) ifTrue: [^self recordAndReportMatch: #(14)].	currentCharacter == $* ifTrue: [^self recordAndReportMatch: #(11)].	currentCharacter == $+ ifTrue: [^self recordAndReportMatch: #(15)].	currentCharacter == $: 		ifTrue: 			[self recordMatch: #(25).			self step.			currentCharacter == $: 				ifTrue: 					[self step.					currentCharacter == $= ifTrue: [^self recordAndReportMatch: #(25)]].			^self reportLastMatch].	currentCharacter == $; ifTrue: [^self recordAndReportMatch: #(7)].	currentCharacter == $&lt; 		ifTrue: 			[self step.			(currentCharacter isAlphabetic or: [currentCharacter == $_]) 				ifTrue: 					[					[self step.					currentCharacter isAlphaNumeric or: [currentCharacter == $_]] 							whileTrue.					currentCharacter == $&gt; ifTrue: [^self recordAndReportMatch: #(19)].					^self reportLastMatch].			currentCharacter == $% ifTrue: [^self recordAndReportMatch: #(10)].			^self reportLastMatch].	currentCharacter == $? ifTrue: [^self recordAndReportMatch: #(1)].	currentCharacter == $[ ifTrue: [^self recordAndReportMatch: #(12)].	currentCharacter == $] ifTrue: [^self recordAndReportMatch: #(2)].	currentCharacter == ${ 		ifTrue: 			[self step.			currentCharacter ~~ $} 				ifTrue: 					[					[self step.					currentCharacter ~~ $}] whileTrue.					^self recordAndReportMatch: #(23)].			^self reportLastMatch].	currentCharacter == $| ifTrue: [^self recordAndReportMatch: #(9)].	^self reportLastMatch</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammarScanner</class-id> <category>generated-tokens</category><body package="SmaCC Development">emptySymbolTokenId	^43</body><body package="SmaCC Development">errorTokenId	^44</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammarScanner class</class-id> <category>testing</category><body package="SmaCC Development">needsLineNumbers	^true</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammarScanner class</class-id> <category>generated-comments</category><body package="SmaCC Development">scannerDefinitionComment	"&lt;name&gt; : [a-zA-Z_] \w* ;&lt;whitespace&gt;	:	\s+ ;&lt;tokenname&gt;	:	\&lt; &lt;name&gt; \&gt; ;&lt;symbolname&gt;	:	&lt;name&gt;	 ;&lt;keyword&gt;	:	(\"" [^\""]* \"") + ;&lt;comment&gt;	:	\# [^\r\n]* ;&lt;code&gt;:	\{ [^\}]+ \} ;&lt;variablename&gt; :	\' &lt;name&gt; \' ;&lt;production&gt; : \: (\: \=)? ;"</body></methods><methods><class-id>Refactory.SmaCC.SmaCCGrammarScanner class</class-id> <category>generated-initialization</category><body package="SmaCC Development">initializeKeywordMap	keywordMap := Dictionary new.	#(#(20 'error' 16)) do: 			[:each | 			(keywordMap at: each first ifAbsentPut: [Dictionary new]) at: (each at: 2)				put: each last].	^keywordMap</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSymbolSet</class-id> <category>testing</category><body package="SmaCC Development">allSatisfy: aBlock 	^symbols allSatisfy: aBlock</body><body package="SmaCC Development">includes: aSymbol 	^symbols includes: aSymbol</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSymbolSet</class-id> <category>private</category><body package="SmaCC Development">addComponent: each 	(each = self or: [components includes: each]) ifTrue: [^self].	components add: each.	each addDependent: self.	self addAll: each symbols</body><body package="SmaCC Development">addComponentsFrom: aSymbolSet 	aSymbolSet components do: [:each | self addComponent: each]</body><body package="SmaCC Development">components	^components</body><body package="SmaCC Development">symbols	^symbols</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSymbolSet</class-id> <category>updating</category><body package="SmaCC Development">update: anAspectSymbol with: aParameter from: aSender 	(components includes: aSender) ifTrue: [self addAll: aSender symbols]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSymbolSet</class-id> <category>accessing</category><body package="SmaCC Development">add: aSymbol 	(symbols includes: aSymbol) ifTrue: [^self].	symbols add: aSymbol.	self changed</body><body package="SmaCC Development">addAll: aCollection 	| oldSize |	oldSize := symbols size.	symbols addAll: aCollection.	oldSize ~= symbols size ifTrue: [self changed]</body><body package="SmaCC Development">baseOn: aSymbolSet 	self addComponent: aSymbolSet.	self addAll: aSymbolSet symbols</body><body package="SmaCC Development">mergeWith: aSymbolSet 	self addAll: aSymbolSet symbols.	self addComponentsFrom: aSymbolSet</body><body package="SmaCC Development">size	^symbols size</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSymbolSet</class-id> <category>initialize-release</category><body package="SmaCC Development">initialize	symbols := Set new.	components := Set new</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSymbolSet</class-id> <category>printing</category><body package="SmaCC Development">printOn: aStream 	symbols do: [:each | aStream nextPutAll: each printString]		separatedBy: [aStream space]</body></methods><methods><class-id>Refactory.SmaCC.SmaCCSymbolSet class</class-id> <category>instance creation</category><body package="SmaCC Development">basedOn: aSymbolSet 	^(self new)		baseOn: aSymbolSet;		yourself</body><body package="SmaCC Development">new	^(super new)		initialize;		yourself</body></methods><methods><class-id>Refactory.SmaCC.SmaCCScanner class</class-id> <category>accessing</category><body package="SmaCC Development">frequencyTable	^#(1)</body></methods><initialize><class-id>Refactory.SmaCC.SmaCCGrammar</class-id></initialize><initialize><class-id>Refactory.SmaCC.SmaCCNode</class-id></initialize><initialize><class-id>Refactory.SmaCC.SmaCCShiftAction</class-id></initialize><initialize><class-id>Refactory.SmaCC.SmaCCRejectAction</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Notification</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>SmaCCParser</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scanner currentToken errorToken stateStack nodeStack </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmaCC Runtime</category><attributes><package>SmaCC Runtime</package></attributes></class><class><name>Set</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>tally </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>SmaCCScanner</name><environment>Refactory.SmaCC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream start matchActions matchEnd currentCharacter outputStream lastOutputStreamMatchPosition lastMatchWasEmpty returnMatchBlock </inst-vars><class-inst-vars>keywordMap </class-inst-vars><imports></imports><category>SmaCC Runtime</category><attributes><package>SmaCC Runtime</package></attributes></class></st-source>