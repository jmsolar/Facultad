<?xml version="1.0"?><st-source><!-- Name: MIMENotice: Copyright © 2005-1999 Cincom Systems, Inc.  All Rights Reserved.Comment: MIMESupport provides a framework that allow you to manipulate (parse, decode) internet mail messages.DbIdentifier: bear73DbTrace: 53247DevelopmentPrerequisites: #(#(#any 'NetClientBase' '') #(#any 'NetConfigTool' ''))PackageName: MIMEParcel: #('MIME')ParcelName: MIMEPrerequisiteParcels: #(#('NetClientBase' '') #('NetConfigTool' ''))PrintStringCache: (7.4  0,tkogan)Version: 7.3.1Date: 6:44:53 pm April 10, 2005 --><time-stamp>From VisualWorks®, 7.3.1 of April 10, 2005 on April 10, 2005 at 6:44:53 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>HeaderField</name><environment>Net</environment><super>Net.MessageElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.HeaderField</class-id><body>This class represents header fields in RFC822 and MIME messages. Related RFCs are	rfc822	- ftp://uu.net/inet/rfc/rfc822.Z	rfc2045	rfc2046	rfc2047	rfc2048	rfc2183Each field has name and value. The general syntax of RFC822 fields is	name: value&lt;CrLf&gt;Fields can occupy more than one line using line folding techniques. Values can be structured or unstructured. Unstructured value is considered to be text (RFC822 defines text as any sequence terminated by CrLf,but MIME specifies how non-ASCII characters can be encoded into text, so there is some decodinginvolved when text lexems are parsed or composed. This class provides enough logic to processunstructured fields. Its subclasses implement structure fields.Structured fields have defined syntax. For each structured field a subclass of HeaderField is createdto capture its syntax and semantics. Many fields share common syntax (i.e. address fields in RFC822,date and version fields across a number of protocols. All fields with the same syntax can be handledwith  one class unless semantical differences justify in troduction of a separate class.Fields are responsible for parsing themselves from a stream and composing (writing) themselveson stream. Parsing is done with a help of a scanner which has interface of RFC822Scanner. Fields specific to protocols derived from RFC822 use specialized scanners that support protocol-specific syntax. A field can parse itself from a string, stream or RFC822 scanner. Examples:	ContentTypeField fromLine: 'content-type: text/html'	HeaderField readFrom: 'content-type: text/html' readStream	HeaderField parse: (RFC822Scanner on: 'content-type: text/html' readStream)Internally, string is wrapped in a stream, stream is wrapped in RFC822 scanner. Parsing is invoked by calling parse:.Parsing and composing is always done on the instance side; class methods create new instanceand invoke instance side method to complete parsing. The only processing done on the class sideis reading field name and finding proper header field class for specified field name (field factory).Note: the current factory scheme is based on scanning subclasses and might need a little more workbecause each protocol may need its own field factory. Currently a subclass implements class method#fieldNames that answers an array of field types that this class recognizes.Each field also stores its source. This is significant for mail protocol because allows to reproduce fieldsverbatim if a message containing the field is to be resent, forwarded, etc. RFC822 and other standards strongly advise from any rewriting of message fields if it is not absolutely necessary. Source is stored ininherited instance variable source which is a stream; the source is the stream's contents. Subclasses maydisable storing source. See MessageElement for more details.Typically fields are built not by MimeEntity itself, but rather by MessageBuilder. MessageBuilder decides whether to store source in a field. One other application of storing source -- if a message is read from mail file containing multiple message, a builder stores StreamSegment as method source. This way each message element knows its exact location in the file and fields can be changed and written back to the file in place one-by-one. Stamp (unfortunately) depends on this capability.Instance Variables:	name	&lt;String&gt;	description of variable's functionClass Variables:	FieldsRegistry	&lt;IdentityDictionary&gt;	 used to store field factory bindings;</body></comment><class><name>MessageHeader</name><environment>Net</environment><super>Net.MessageElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>registry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MessageHeader</class-id><body>I represent header fields in rfc822 messages. RFC822 messages may have repeated fields, order of fieldappearance is significant, and there are manadatory rules that certain fields should precede all otherfields. This class encapsulates all this logicFields are represented by an instance of OrderedMultiValuedDictionary to preserve order of field appearance.Value at a key is always an ordered collection of values. Each occurrence of the field adds anotherelement to this collection. When a field is removed and its value is an empty collection, the wholeentry is removed.Usually, when fields are parsed from a message, their sequence is already correct. If fields are added dynamically, some fields may appear in the wrong order, so part of preparing a message for transportis re-arranging fields to ensure correct sequence</body></comment><class><name>StructuredHeaderField</name><environment>Net</environment><super>Net.HeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.StructuredHeaderField</class-id><body>This class is an abstract class for all structured fields. Each specific structured field type has to implement its own parsing by overriding #parse: method. This class only provides some utility method to help parse some common constructs such as parameters.Instance Variables:	comment	&lt;String&gt;	</body></comment><class><name>MailScanner</name><environment>Net</environment><super>Net.SimpleScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MailScanner</class-id><body>This class is an abstract class for all mail-related scanners. It provides some common printing methods for lexical types that are used by all subclasses -- atom, text, quoted text</body></comment><class><name>RFC822Scanner</name><environment>Net</environment><super>Net.MailScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.RFC822Scanner</class-id><body>This class performs scanning/parsing of rfc822 messages. It implements scanning routines for rfc822 lexical types (see 'multi-character scans') and general tokenization logic. Shared Variables:	AtomMask	&lt;Integer&gt;  Mask for rfc822 Atoms	CommentMask	&lt;Integer&gt;  Mask for rfc822 Comments ()	DomainTextMask	&lt;Integer&gt;  Mask for rfc822 Domain Text	HeaderNameDelimiterChar	&lt;Character&gt;  $:	HeaderNameMask	&lt;Integer&gt;  Mask for rfc822 header field names	QuotedPairChar	&lt;Character&gt;  $\	QuotedPairMask	&lt;Integer&gt;  Mask for rfc822 quoted-pair (\x)	QuotedTextMask	&lt;Integer&gt;  Mask for rfc822 quoted-text	SimpleTimeZones	&lt;Dictionary key: ?type? value: ?type?&gt;  comment	TextMask	&lt;Integer&gt;  Mask for rfc822 text	TokenMask	&lt;Integer&gt;  Mask for rfc822 tokens</body></comment><class><name>CollectionField</name><environment>Net</environment><super>Net.StructuredHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>separator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.CollectionField</class-id><body>CollectionField is super class for header fields which value is collection.Instance Variables:	separator	&lt;Symbol&gt;	fields  separator</body></comment><class><name>MimeEncodedWordCoDec</name><environment>Net</environment><super>Net.SimpleScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MimeEncodedWordCoDec</class-id><body>This class encodes and decodes Mime encoded words. These may occur in header fields of Mime entities. Mime (rfc2047) defines encoding for the following lexical elements: comments, text and phrase. So when each of them is read from a stream, it has to be decoded according to its lexical type by invoking an appropriate method on an instance of MimeEncodedWordCoDec.</body></comment><class><name>ParsingSimpleBodyError</name><environment>Net</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MIME</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.ParsingSimpleBodyError</class-id><body>ParsingSimpleBodyError is raised when any error is detected while parsing the message body. The exception parameter holds the original error.</body></comment><class><name>MimeEntity</name><environment>Net</environment><super>Net.MessageElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>header builder headerCharset </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MimeEntity</class-id><body>I represent Mime entity as defined by RFC2045. Mime entities form a basis for mail messages and HTTP. A Mime entity is basically and object that has header and a body. Header consists of fields each of which has a name and (potentially complex) value. A body can be either a simple or multipart body. Simple body has contents, which is either a string, or byte array. Multipart body consists of multiple parts, each of which is a Mime entity in itself.Header fields describe entity contents or provide additional information. Header fields are represented by hierarchy of classes starting at HeaderFields. Some fields have known structure and syntax, the rest are considered to be just a text field. Mime defines a few standard fields, they all start with content-*. The most important field is content-type field. It defines type of information that entity represents (see rfc2045 for details). MimeEntity provides methods to access/set aspects of content-type field:	type		(default 'text')	subtype		('plain')	contentType (=type/subtype	default 'text/plain')	charset		(default charset from parent entity (RFC822Message/HttpEntity) or if the parent is nil - 'iso-8859-1')	boundary	(default nil, should be specified for multipart entities)	headerCharset (default nil, is used to encode header fields that have non ASCII characters)Other notable fields include content-length (contentLength) and content-disposition (fileName).Fields may occur more than once and sometimes have to occur in particular sequence. MimeEntity allows multiple fields with the same name and remembers field order. There are various methods that allow to manipulate fields.Methods are provide to access and travers entity body and parts. Mime entity allows to add and remove parts. An entity is created as a simple entity by default. As parts are added, it will mutate itself into multipart entity transparently. It is also possible to convert multiupart entity back into a single-part one, merging fields in the process.MimeEntity also supports Visitor patterns. Nodes can be traversed by an outside visitor. This allows to put domain- and application-specific logic into the visitor and create visitors specific to Mail, HTTP, etc. See hierarchy of MessageVisitorInstance Variables:	header	&lt;MessageHeader&gt;  Message header contains header fields	builder	&lt;MessageBuilder&gt;  Message builder -- used to construct message and perform tasks on the messageShared Variables:	EditorRegistry	&lt;Dictionary key: String value: ApplicationModel&gt;  Viewers keyed by content-type</body></comment><class><name>MessageDispatcher</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MessageDispatcher</class-id><body>This class is an abstract superclass for all classes that traverse structure of RFC822, Mime, HTTP,etc. messages. Subclasses perform tasks such as controlling building (parsing) of a message,printing, searching, etc. Structure traversing is implemented via visitor pattern. Visitor pattern(GoF, p 331-344) allows to separate concerns and tasks from the hierarchical message structure.Thus, we can employ different strategies while building a message depending on the usagecontext such as parsing only to a certain depth, caching data in memory vs. storing pointersto real external streams, parsing external bodies as just text vs. actually accessing remote dataand others. Similarly, we can do some very sophisticated searches and data mining inside complexmessages, develop nice printing mechanisms, message transformation schemes (answers, forwarding, etc).Visitor implements method 	visit: element		^element acceptVisit: selfElement in turns double-dispatches this message back to the visitor. Usually method invoked dependson the nature of the element. This allows visitor to do different things as different elements arevisited. For example	HeaderField&gt;&gt;acceptVisit: aVisitor		aVisitor acceptHeaderField: selfAll double-dispatch methods are im the category 	visiting -- double dispatchingInstance Variables:</body></comment><class><name>MessageParser</name><environment>Net</environment><super>Net.MessageDispatcher</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MessageParser</class-id><body>This class parses Mime entities. It is responsible for parsing elements of the entity and notifying MessageBuildHandler who actually contructs the message. This division of labor is designed so that different policies can be implemented on the builder level. For example, we may choose to process some parts of the message as they are decoded without waiting for the whole message to be fully parsed; we may choose to create different entities to represent parsed entity (MimeEntity vs. MailMessage) depending on what would we expect to do with the message, etc.Being a subclass of MessageDispatcher, MessageParser 'walks' message being parsed and executes callbacks to its message builder when it arrives at certain points in the message. It also expects certain data to come from the builder. Specifically, it expects the builder to answer an instance of message header for #startEntity: callback and tp answer an instance of MimeEntity in response to #endHeader: callback.</body></comment><class><name>ValueWithParams</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>params separators value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.ValueWithParams</class-id><body>ValueWithParams parses, composes and holds values for header fields that have value and parameters.  Instance Variables:	params	&lt;Dictionary&gt;	filed parameters	separators	&lt;SequenceableCollection&gt;	field separators	value	&lt;String&gt;	parameter  valueFor example, Content-Type field  content := "Content-Type" ":" type "/" subtype             *(";" parameter)             ; Matching of media type and subtype             ; is ALWAYS case-insensitive.  parameter := attribute "=" value  value := token / quoted-stringIf while parsing parameter value non-ASCII characters would be detected the parser is going to raise NonASCIIFieldParamException. If there is no handler for this exception the parameter value will be set to stream bytes.</body></comment><class><name>MimeMessageBody</name><environment>Net</environment><super>Net.MessageElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MimeMessageBody</class-id><body>This represents is an abstract class for Mime message bodies. Message bodies can be simple or multi-part. Mail messages can be complex and deeply nested and their parts can be very large. In many cases wemay not need contents of one or more message parts, so it makes sense not to parse messages toodeep and only read data in memory when we actually need it. For this reason Parsing and value initialization is done lazily. Source stream is remembered so that parsing can be done at any time.Messages can also have external parts where data can be retrieved from external source via FTP or other means. Because streams are a universal mean of accessing external resources, storing source stream also encapsulates part access logic.Instance Variables:	value	&lt;String or SequencableCollection&gt;	body contents</body></comment><class><name>MultipartBody</name><environment>Net</environment><super>Net.MimeMessageBody</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MultipartBody</class-id><body>This class represents multi-part MIME message bodies. Multi-part bodies containone or more body parts, each preceded by a boundary delimiter line,and the last one followed by a closing boundary delimiter line.After its boundary delimiter line, each body part then consists of aheader area, a blank line, and a body area.  Thus a body part issimilar to an RFC 822 message in syntax, but different in meaning.This class is responsible for parsing body structure from source streamand composing body structure to output stream. It parses out individual entities and lets entities parse themselves. Value of multi-part body is an array ofMime entities. Value (and hence parsing) is initialized lazily.Multi-part bodies are defined in section 5.1 of RFC2046 (ftp://ftp.uu.net/inet/rfc/rfc2046.Z).See documentation method for more details.An example of multi-part message:     From: Nathaniel Borenstein &lt;nsb@bellcore.com&gt;     To: Ned Freed &lt;ned@innosoft.com&gt;     Date: Sun, 21 Mar 1993 23:56:48 -0800 (PST)     Subject: Sample message     MIME-Version: 1.0     Content-type: multipart/mixed; boundary="simple boundary"     This is the preamble.  It is to be ignored, though it     is a handy place for composition agents to include an     explanatory note to non-MIME conformant readers.     --simple boundary     This is implicitly typed plain US-ASCII text.     It does NOT end with a linebreak.     --simple boundary     Content-type: text/plain; charset=us-ascii     This is explicitly typed plain US-ASCII text.     It DOES end with a linebreak.     --simple boundary--     This is the epilogue.  It is also to be ignored.</body></comment><class><name>NetworkEntityDescriptor</name><environment>Net</environment><super>Net.MessageElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>alias comment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.NetworkEntityDescriptor</class-id><body>This class is an abstract class for mailbox address and mail group address descriptors as defined in RFC822. All addresses may have an address part and alias part. Address part defines the actual networ address while alias is a human-readable name associated with the address.Main purpose of descriptors is to be able to parse and compose address string into indivudual components, check syntax, provide canonical value and decode non-ascii characters in alias.While address syntax is defined in rfc822, the individual tokens (namely, phrase representing alias) are further developed in Mime (rfc2048) to provide for non-ascii characters. Therefore, message is parsed using rfc822 syntactic rules including rfc822 character table. Once parsed, individual lexical tokens are scanned using Mime rules.Subclasses must implement the following messages:	printing	printCanonicalValueOn:Instance Variables:	alias	&lt;OrderedCollection&gt;  Collection of words comprising alias. Access alias using #aliasString	comment	&lt;String&gt;  Comment string if present as part of the address</body></comment><class><name>MailGroupDescriptor</name><environment>Net</environment><super>Net.NetworkEntityDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>addresses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MailGroupDescriptor</class-id><body>This class represents mail group specification as defined in rfc822. It is capable of parsing and composing group specs to/from a stream and provides access to group components. A group spec may be parsed from a source stream, or created by invoking mutator methods and then written on a stream. Mime-encoded fields are handled transparentlyExamples:    Reply-To: The Committee: Jones@Host.Net,                                     Smith@Other.Org,                                     Doe@Somewhere-Else;    Reply-To :  Sam.Irving@Reg.Organization       :  George Jones &lt;Group@Some-Reg.An-Org&gt;,          Al.Neuman@MAD.Publisher       :  Important folk:            Tom Softwood &lt;Balsa@Tree.Root&gt;,            "Sam Irving"@Other-Host;,          Standard Distribution:                   /main/davis/people/standard@Other-Host,                   "&lt;Jones&gt;standard.dist.3"@Tops-20-Host&gt;;Group syntax from rfc822 is given below     group       =  phrase ":" [#mailbox] ";"     mailbox     =  addr-spec                    ; simple address                 /  phrase route-addr            ; name &amp; addr-spec     route-addr  =  "&lt;" [route] addr-spec "&gt;"     route       =  1#("@" domain) ":"           ; path-relative     addr-spec   =  local-part "@" domain        ; global address     local-part  =  word *("." word)             ; uninterpreted                                                 ; case-preserved     domain      =  sub-domain *("." sub-domain)     sub-domain  =  domain-ref / domain-literal     domain-ref  =  atom                         ; symbolic referenceInstance Variables:	addresses	&lt;SequencableCollection&gt;  Collection of NetworkAddressDescriptors constituting group</body></comment><class><name>NetworkAddressDescriptor</name><environment>Net</environment><super>Net.NetworkEntityDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>domain localPart route </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.NetworkAddressDescriptor</class-id><body>This class represents RFC822 network addresses. An address may have address part, alias and comment. Each one is optional. Address syntax from rfc822 is as follows:     address     =  mailbox                      ; one addressee                 /  group                        ; named list     group       =  phrase ":" [#mailbox] ";"     mailbox     =  addr-spec                    ; simple address                 /  phrase route-addr            ; name &amp; addr-spec     route-addr  =  "&lt;" [route] addr-spec "&gt;"     route       =  1#("@" domain) ":"           ; path-relative     addr-spec   =  local-part "@" domain        ; global address     local-part  =  word *("." word)             ; uninterpreted                                                 ; case-preserved     domain      =  sub-domain *("." sub-domain)     sub-domain  =  domain-ref / domain-literal     domain-ref  =  atom                         ; symbolic referenceInstance Variables:	domain	&lt;SequencableCollection of Strings&gt;  Domain parts domainString answers domain string	localPart	&lt;SequencableCollection of Strings&gt;  Parts of local part. localPartString answers string	route	&lt;Collection | EncodedStream | PositionableStream&gt;  Route part of the address. routeString answers route string</body></comment><class><name>NonASCIIFieldParamException</name><environment>Net</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MIME</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.NonASCIIFieldParamException</class-id><body>NonASCIIFieldParamException exception is raised when non-ASCII character is detected in header fields with parameters</body></comment><class><name>MessageHandler</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dispatcher context headerOnly </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MessageHandler</class-id><body>This class is strategy class for MessageDispatcher. When message dispatcher traverses message, it calls back its message handler notifying it where it is in the message. All possible callbacks are declared in 'action callbacks' protocol. Subclasses override these methods to implement such tasks as building, printing and searching of messages.The principle and division of work is largely similar to SAX driver for XML.Because of callback nature, handler usually has to maintain some kind of context. Since messages can be nested, context should reflect this. See methods in 'accessing'.	#context answers global context, which is an IdentityDictionary.	#entityContext answers context of the current entity. new entity context is pushed on the context stack when new entity is visited (#startEntity: callback) and popped when this entity is left (#endEntity: callback).	#entity answers current entity	#level answers nesting level'dispatcher interface' is low-level interface between handler and dispatcher.Instance Variables:	dispatcher	&lt;MessageDispatcher&gt;	my dispatcher. Handler typically initialtes work by invoking dispatcher's method visit:. Dispatcher then executes series of callbacks to the hahdler	context	&lt;IdentityDictionary&gt;	contains context of the work being done (see above)	headerOnly	&lt;Boolean&gt;	if true, dispatcher will stop after processing message header</body></comment><class><name>MessagePrintHandler</name><environment>Net</environment><super>Net.MessageHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MessagePrintHandler</class-id><body>This class implements printing and writing messages on a stream. The message is rendered according to rfc822 syntax rules. 	writeOn: writes message on output stream in full conformance of rfc822 syntax, so it can be used to send message directly to SMTP server without creating intermediate streams. If some constituent entities require content transfer encoding, it is applied dynamically and transfer-encoded output is written directly on output stream with no intermediate buffers created. Header fields are arranged in the order imposed by rfc822.	printOn: is used for printing, so the logic is slightly different to enhance readability of the output. First, nested entities are indented according to their nesting level. Secondly, binary data is not shown and in general on a digest of each entity's contents is displayed.Instance Variables:	stream	&lt;Stream&gt;	output stream</body></comment><class><name>MimeEntityBot</name><environment>Net</environment><super>Net.MessageHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>entityCallback keepSearching </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MimeEntityBot</class-id><body>This class is a 'robot' that can be used to search Mime entities for information and to perform some transformations of Mime entities.Methods in 'enumeration' provide search facilities to find and collect parts matching certain criteria. Searches can be restricted to some level of nesting, which is convenient when searching for message text parts and attachments.Methods in 'tasks' provides facilities to check message structure, add/remove transfer encoding and also to correctly mutate message. Examples include adding part to a simple message which mutates it froma simple message to multi-part message. Another example is dropping all representations of message text except plain text one, which may require to mutate message from multipart/alternative to simple, or replacing multipart/alternative part with a simple part. This class encapsulates all the logistics and complexity involved in these transformations providing easy to use high-level methods.Instance Variables:	keepSearching	&lt;Boolean&gt;  Internal -- set to terminate message traversal	partCallback	&lt;BlockContext&gt;  Internal -- callback when a node is traversed</body></comment><class><name>SinglePartPresenter</name><environment>Net</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model partText title </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.SinglePartPresenter</class-id><body>This class can be used to view simple Mime entitiesInstance Variables:	model	&lt;MimeEntity&gt;  Mime entity being presented	partText	&lt;ValueHolder&gt;  Holds entity's text </body></comment><class><name>ScalarField</name><environment>Net</environment><super>Net.StructuredHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.ScalarField</class-id><body>This class is the superclass for all fields whose value represents a scalar value. Examples are date field, maibox field, version field, etc. So for the date field field's value will be parsed date object, not a string representation of date (field's source would still hold the string representation). Each specific field type should implement method #parse:</body></comment><class><name>MailboxListField</name><environment>Net</environment><super>Net.ScalarField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>addresses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MailboxListField</class-id><body>This class represents field whose value is a list of mailboxes as defined by RFC822. Several fieldtypes in RFC822 messages (from, cc, to, etc) are mailbox list fields. Mailbox specs allows to specify address-spec as well as an alias. MIME allows to encode non-ASCII characters in the alias part.Addresses can be mailbox or mail group addresses.Value of this field is list of addresses (strings). Addresses can be read or set using messages:	addresses	addresses:When setting addresses, caller specified a collection of strings. Each string can be a single address or a sequence of comma-separated addresses. Among other things, this handles non-ascii characters in the alias part of the address. Address strings are always parsed and canonicalized inside. This class uses NetworkAddressDescriptor class to parse and compose address strings.Mailbox list examples:	Gourmets:  Pompous Person &lt;WhoZiWhatZit@Cordon-Bleu&gt;,                Childs@WGBH.Boston, Galloping Gourmet@                ANT.Down-Under (Australian National Television),                Cheapie@Discount-Liquors;,       Cruisers:  Port@Portugal, Jones@SEA;,         Another@Somewhere.SomeOrgThe formal grammar is as follows:     address     =  mailbox                      ; one addressee                 /  group                        ; named list     group       =  phrase ":" [#mailbox] ";"     mailbox     =  addr-spec                    ; simple address                 /  phrase route-addr            ; name &amp; addr-spec     route-addr  =  "&lt;" [route] addr-spec "&gt;"     route       =  1#("@" domain) ":"           ; path-relative     addr-spec   =  local-part "@" domain        ; global address     local-part  =  word *("." word)             ; uninterpreted                                                 ; case-preserved     domain      =  sub-domain *("." sub-domain)     sub-domain  =  domain-ref / domain-literal     domain-ref  =  atom                         ; symbolic reference</body></comment><class><name>VersionField</name><environment>Net</environment><super>Net.ScalarField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.VersionField</class-id><body>This class represents version fields. Version is used in MIME and in HTTP. Version field syntax for MIME messages is as follows:     version := "MIME-Version" ":" 1*DIGIT "." 1*DIGIT     MIME-Version: 1.0</body></comment><class><name>SingleMailboxField</name><environment>Net</environment><super>Net.ScalarField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>address </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.SingleMailboxField</class-id><body>This class represents field whose value is a mailbox-spec as defined by RFC822. Several fieldtypes in RFC822 messages are single mailbox fields. Mailbox allows to specify address-specas well as an alias. MIME allows to encode non-ASCII characters in the alias part.Mailbox examples:	Alfred Neuman &lt;Neuman@BBN-TENEXA&gt;	"George, Ted" &lt;Shared@Group.Arpanet&gt;The formal grammar is as follows:     address     =  mailbox                      ; one addressee                 /  group                        ; named list     group       =  phrase ":" [#mailbox] ";"     mailbox     =  addr-spec                    ; simple address                 /  phrase route-addr            ; name &amp; addr-spec     route-addr  =  "&lt;" [route] addr-spec "&gt;"     route       =  1#("@" domain) ":"           ; path-relative     addr-spec   =  local-part "@" domain        ; global address     local-part  =  word *("." word)             ; uninterpreted                                                 ; case-preserved     domain      =  sub-domain *("." sub-domain)     sub-domain  =  domain-ref / domain-literal     domain-ref  =  atom                         ; symbolic reference</body></comment><class><name>MailPage</name><environment>Net</environment><super>Net.NetSettingsPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>serverListAspect hostSpec </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MailPage</class-id><body>MailPage creates the UI page for the mail server settingsInstance Variables:	hostSpec	&lt;HostSpec&gt;	name of the selected mail server	serverListAspect	&lt;SelectionInList&gt;	mail server list</body></comment><class><name>SimpleBody</name><environment>Net</environment><super>Net.MimeMessageBody</super><private>false</private><indexed-type>none</indexed-type><inst-vars>byteSource </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.SimpleBody</class-id><body>This represents simple message bodies. Simple message body's value is its contents, which is a string. Simple message bodies make no attempt to decode or transform its contents, it is responsibility of higher-level code.Parsing and value initialization is done lazily. Source stream is remembered so that parsing can be done at any time.Instance Variables:	byteSource &lt;Stream of ByteArray&gt; this inst var will be set only for the HTTP messages and only in case when the decompression and decoding is turned off or the body contents is a binary type (See MimeTypeDescriptor class&gt;&gt;defaultMimeTypes). The byteSource will always contain row socket bytes and the source stream will always contain decompressed or decoded ByteString. At the same time either #byteSource or #source has data. Setting #source: to some stream will reset the byteSource to nil. </body></comment><class><name>MimeScanner</name><environment>Net</environment><super>Net.RFC822Scanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MimeScanner</class-id><body>MimeScanner implements Mime encoding rules specified in RFC2047 (Message Header Extensions for Non-Ascii Text). The notation extends RFC822 describing encoding lexical elements text, phrase and word. MimeScanner extends RFC822 scanner. It has the same set of lexems. When either text, phrase or word is scanned, it is scanned using rfc822 syntax but Mime character  table. Once lexem is scanned, then Mime encoding rules for this lexem are applied so that non-ASCII characters can be decoded.</body></comment><class><name>NetworkAddressParser</name><environment>Net</environment><super>Net.RFC822Scanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars>descriptor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.NetworkAddressParser</class-id><body>This class parses string representing mailbox and group addresses and answers a instances of address descriptors -- either NetworkAddressDescriptor or MailGroupDescriptor -- depending on the nature of address. .Instance Variables:	descriptor	&lt;NetwordAddressDescriptor or MailGroupDescriptor&gt;  descriptor to put parsed info in</body></comment><class><name>ValueWithParametersField</name><environment>Net</environment><super>Net.StructuredHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>separators </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.ValueWithParametersField</class-id><body>This class is an  abstract class that provides infrastructure for Mime and HTTP fields that have value and optional parameters. The class defines logic for parsing and composition. Subclasses may perform more detailed parsing of field value. Subclasses also add accessor methods to access specific parameters (such as 'charset' or 'boundary' in content-type field or 'fileName' in content-disposition fieldFor example, the syntax of content-type field as defined in rfc2045 is as follows:  content := "Content-Type" ":" type "/" subtype             *(";" parameter)             ; Matching of media type and subtype             ; is ALWAYS case-insensitive.  parameter := attribute "=" value  value := token / quoted-stringSome of the most important fields, namely content-type and content-disposition types are value with parameters fields.</body></comment><class><name>SingleValueWithParametersField</name><environment>Net</environment><super>Net.ValueWithParametersField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.SingleValueWithParametersField</class-id><body>SingleValueWithParametersField is an abstract class that provides infrastructure for Mime and HTTP fields that have value and an one parameter</body></comment><class><name>ContentTypeField</name><environment>Net</environment><super>Net.SingleValueWithParametersField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.ContentTypeField</class-id><body>This class represents content-type field in MIME and HTTP protocols. RFC2045 implements content-type field syntax defined in RFC2045.The field performs parsing/compisition for content-type field and exposesaccessor methods to access individual components:	contetType ('type/subtype', example 'text/html')	type	subType	charset	boundaryOther parameters can be accessed using #parameterAt:, #parameterAt:put:Syntax (abbreviated) from RFC2045 (ftp.uu.net/inet/rfcs/rfc2045.Z):      content := "Content-Type" ":" type "/" subtype                *(";" parameter)                ; Matching of media type and subtype                ; is ALWAYS case-insensitive.     type := discrete-type / composite-type     discrete-type := "text" / "image" / "audio" / "video" /                      "application" / extension-token     composite-type := "message" / "multipart" / extension-token     parameter := attribute "=" valueInstance Variables:	type	&lt;String&gt;			type as defined above	subtype	&lt;String&gt;			subtype</body></comment><class><name>ContentDispositionField</name><environment>Net</environment><super>Net.SingleValueWithParametersField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.ContentDispositionField</class-id><body>This class represents content-disposition field as defined by RFC2183.Content-disposition field designates Mime entity as 'inline' or ''attachment'. 'Inline' parts can be displayed automatically whereas 'attachments' are located externally and require some action from the user. These can be displayed as iconized images. Content-disposition field also provides fiel name and essential file attributes to help in saving file and determining its Mime type of its contents.Default setting is 'attachment' and can be reset as	Settings defaultContentDisposition: 'inline'.This class provides accessor methods for standard parameters of this field. These methods are also provided in MimeEntity class (category content-disposition)Excerpts from RFC2183:   MIME specifies a standard format for encapsulating multiple pieces of   data into a single Internet message. That document does not address   the issue of presentation styles; it provides a framework for the   interchange of message content, but leaves presentation issues solely   in the hands of mail user agent (MUA) implementors.   Two common ways of presenting multipart electronic messages are as a   main document with a list of separate attachments, and as a single   document with the various parts expanded (displayed) inline. The   display of an attachment is generally construed to require positive   action on the part of the recipient, while inline message components   are displayed automatically when the message is viewed. A mechanism   is needed to allow the sender to transmit this sort of presentational   information to the recipient; the Content-Disposition header provides   this mechanism, allowing each component of a message to be tagged   with an indication of its desired presentation semantics.   Tagging messages in this manner will often be sufficient for basic   message formatting. However, in many cases a more powerful and   flexible approach will be necessary. The definition of such   approaches is beyond the scope of this memo; however, such approaches   can benefit from additional Content-Disposition values and   parameters, to be defined at a later date.   In addition to allowing the sender to specify the presentational   disposition of a message component, it is desirable to allow her to   indicate a default archival disposition; a filename. The optional   "filename" parameter provides for this.  Further, the creation-date,   modification-date, and read-date parameters allow preservation of   those file attributes when the file is transmitted over MIME email.2.  The Content-Disposition Header Field   Content-Disposition is an optional header field. In its absence, the   MUA may use whatever presentation method it deems suitable.   It is desirable to keep the set of possible disposition types small   and well defined, to avoid needless complexity. Even so, evolving   usage will likely require the definition of additional disposition   types or parameters, so the set of disposition values is extensible;   see below.   In the extended BNF notation of [RFC 822], the Content-Disposition   header field is defined as follows:     disposition := "Content-Disposition" ":"                    disposition-type                    *(";" disposition-parm)     disposition-type := "inline"                       / "attachment"                       / extension-token                       ; values are not case-sensitive     disposition-parm := filename-parm                       / creation-date-parm                       / modification-date-parm                       / read-date-parm                       / size-parm                       / parameter     filename-parm := "filename" "=" value     creation-date-parm := "creation-date" "=" quoted-date-time     modification-date-parm := "modification-date" "=" quoted-date-time     read-date-parm := "read-date" "=" quoted-date-time     size-parm := "size" "=" 1*DIGIT     quoted-date-time := quoted-string                      ; contents MUST be an RFC 822 `date-time'                      ; numeric timezones (+HHMM or -HHMM) MUST be used</body></comment><class><name>MessageBuildHandler</name><environment>Net</environment><super>Net.MessageHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>internalStream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MessageBuildHandler</class-id><body>This class is responsible for putting message together from pieces parsed by the message parser. Specifically, this class knows what type of entity to create based on the context (parent entity, content type, etc.) and what to do with message body.The sequence of building message is as follows:	Parser invokes startEntity:. Builder replies with an instance of message header. Message header provides class factory for header fields.	Parser parser fields and invokes endHeader:. Builder constructs appropriate entity based on the header and answers this entity	Parser parses entity's body. If it is multipart entity, the process is nested for body parts</body></comment><class><name>MailBuildHandler</name><environment>Net</environment><super>Net.MessageBuildHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MailBuildHandler</class-id><body>MailBuildHandler builds an instance of  MailMessage </body></comment><class><name>NumericField</name><environment>Net</environment><super>Net.ScalarField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.NumericField</class-id><body>I represent numeric fields such as content-length. My value is a number. String representation of value can be accessed using #asStringExample:	Content-length: 1123Instance Variables:</body></comment><class><name>MimeMultipartEntity</name><environment>Net</environment><super>Net.MimeEntity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MimeMultipartEntity</class-id><body>MimeMultipartEntity represents a MIME multi-part entity</body></comment><class><name>RFC822Message</name><environment>Net</environment><super>Net.MimeMultipartEntity</super><private>false</private><indexed-type>none</indexed-type><inst-vars>date </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.RFC822Message</class-id><body>This class represents top-level RFC822 messages. It adds accessor methods for all fields postulated inrfc822 (to, from, cc, bcc, data, etc.)Instance Variables:	date	&lt;Timestamp&gt;	internal message date</body></comment><class><name>MailMessage</name><environment>Net</environment><super>Net.RFC822Message</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MailMessage</class-id><body>Mail message is a specializationof generic rfc822 and Mime messages. A mail message has text and zero or more attachments. Mail message'stext can have a number of different representations as follows:-Simple message. This message has no attachments and its contents is text of the message. The messageshould have text content type ('text/*'); its subtype defines text formatting ('plain', 'rtf', 'html').-Multipart message. This message has multipart type ('multipart/*'). Multipart message contains zero or moreparts. One of the subparts is the text part. It may be simple or multipart/alternative part.Multipart may contain multiple alternative representations of message text. This is done by enclosingall alternative representations into multipart/alternative part. Mail message itself may be multipart/alternative. In this case the message has no attachments, just alternativerepresentations of its text. Otherwise, top-level message has type multipart/mixed. The first part of this messageis its text part. It is either simple text part, or multipart/alternative part.This class exposes methods to access message text (part) and attachments, etc. and to perform common transformations (add/remove attachment, replace message text, mutate message frommultipart into single part and vice versa) in such a way to preserve message structural consistency. This includes changing and/or mutating message body, fields and contentsMessage text-related methods allow to specify a list of preferences. This is useful when client can display text in morethan one format. Preferences can be specified as array or desired formats i.e. #('html' 'plain' '*'). The defaultis #('plain' '*') MailMessage implements little logic of its own. Most functions are actually performed by an associated 'bot' --a MailMessageBot</body></comment><class><name>MailMessageBot</name><environment>Net</environment><super>Net.MimeEntityBot</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MailMessageBot</class-id><body>This class provides a 'robot' to perform common tasks on mail messages. Mail message is a specializationof generic rfc822 and Mime messages. A mail message has text and zero or more attachments. Mail message'stext can have a number of different representations as follows:-Simple message. This message has no attachments and its contents is text of the message. The messageshould have text content type ('text/*'); its subtype defines text formatting ('plain', 'rtf', 'html').-Multipart message. This message has multipart type ('multipart/*'). Multipart message contains zero or moreparts. One of the subparts is the text part. It may be simple or multipart/alternative part.Multipart may contain multiple alternative representations of message text. This is done by enclosingall alternative representations into multipart/alternative part. Mail message itself may be multipart/alternative. In this case the message has no attachments, just alternativerepresentations of its text. Otherwise, top-level message has type multipart/mixed. The first part of this messageis its text part. It is either simple text part, or multipart/alternative part.This class provides methods to query and scan mail message for its text (part), attachments, etc. and to perform common transformations (add/remove attachment, replace message text, mutate message frommultipart into single part and vice versa) in such a way to preserve message structural consistency. This includes changing and/or mutating message body, fields and contentsText query methods allow to specify a list of preferences. This is useful when client can display text in morethan one format. Preferences can be specified as array or desired formats i.e. #('html' 'plain' '*'). The default is #('plain' '*') </body></comment><class><name>DateField</name><environment>Net</environment><super>Net.ScalarField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.DateField</class-id><body>This class represents date fields as defines in RFC822 and HTTP. Value of the field is an instance of date, not a string. See rfc822 for the exact syntax of datesExample:	HeaderField fromLine: 'Date : Tue, 18 Apr 89 23:29:47 +0900	' 	HeaderField halt; fromLine: 'Date : 26 Aug 76 14:30 EDT' </body></comment><shared-variable><name>HeaderNameMask</name><environment>Net.RFC822Scanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>2048</initializer><attributes><package>MIME</package></attributes></shared-variable><shared-variable><name>DomainTextMask</name><environment>Net.RFC822Scanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>1024</initializer><attributes><package>MIME</package></attributes></shared-variable><shared-variable><name>HeaderNameDelimiterChar</name><environment>Net.RFC822Scanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>$:</initializer><attributes><package>MIME</package></attributes></shared-variable><shared-variable><name>QuotedTextMask</name><environment>Net.RFC822Scanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>4096</initializer><attributes><package>MIME</package></attributes></shared-variable><shared-variable><name>CommentMask</name><environment>Net.RFC822Scanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>512</initializer><attributes><package>MIME</package></attributes></shared-variable><shared-variable><name>TokenMask</name><environment>Net.RFC822Scanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>16384</initializer><attributes><package>MIME</package></attributes></shared-variable><shared-variable><name>QuotedPairChar</name><environment>Net.RFC822Scanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>$\</initializer><attributes><package>MIME</package></attributes></shared-variable><shared-variable><name>TextMask</name><environment>Net.RFC822Scanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>8192</initializer><attributes><package>MIME</package></attributes></shared-variable><shared-variable><name>QuotedPairMask</name><environment>Net.RFC822Scanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>"(QuotedTextMask bitOr: CommentMask)  bitOr: DomainTextMask"</initializer><attributes><package>MIME</package></attributes></shared-variable><shared-variable><name>SimpleTimeZones</name><environment>Net.RFC822Scanner</environment><private>false</private><constant>false</constant><category>masks</category><attributes><package>MIME</package></attributes></shared-variable><shared-variable><name>AtomMask</name><environment>Net.RFC822Scanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>256</initializer><attributes><package>MIME</package></attributes></shared-variable><shared-variable><name>MimeQuotedTextMask</name><environment>Net.MimeScanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>32768</initializer><attributes><package>MIME</package></attributes></shared-variable><shared-variable><name>DefaultContentDisposition</name><environment>Net.ContentDispositionField</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>MIME</package></attributes></shared-variable><shared-variable><name>RemoveContentTransferEncoding</name><environment>Net.MessageBuildHandler</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>MIME</package></attributes></shared-variable><shared-variable><name>DefaultCharsetEncoder</name><environment>Net.SimpleBody</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>MIME</package></attributes></shared-variable><shared-variable><name>FieldsRegistry</name><environment>Net.HeaderField</environment><private>false</private><constant>false</constant><category>registry</category><initializer>Dictionary new: 50</initializer><attributes><package>MIME</package></attributes></shared-variable><shared-variable><name>AvailableEncodings</name><environment>Net.MimeEncodedWordCoDec</environment><private>false</private><constant>false</constant><category>encoding</category><initializer>nil</initializer><attributes><package>MIME</package></attributes></shared-variable><shared-variable><name>EditorRegistry</name><environment>Net.MimeEntity</environment><private>false</private><constant>false</constant><category>editor registry</category><initializer>IdentityDictionary new</initializer><attributes><package>MIME</package></attributes></shared-variable><methods><class-id>Net.HeaderField</class-id> <category>accessing</category><body package="MIME" selector="canMerge">canMerge	^false</body><body package="MIME" selector="canonicalFieldName">canonicalFieldName	| s |	s := name copy.	(s isNil or: [ s isEmpty]) ifTrue: [ ^String new ].	s at: 1 put: s first asUppercase.			" Capitalize first letter "	^ s</body><body package="MIME" selector="canonicalValue">canonicalValue" Override as necessary "	^self value</body><body package="MIME" selector="name">name	^name</body><body package="MIME" selector="name:">name: aString	name := aString</body><body package="MIME" selector="values">values" Multi-valued fields override this method "	^Array with: self value</body><body package="MIME" selector="values:">values: anArray" Multi-valued fields override this method "	anArray size ~= 1 ifTrue: [ ^self error: (#CantSetMultipleValuesInField &lt;&lt; #net &gt;&gt; 'Can''t set multiple values in this field') ].	self value: anArray first</body></methods><methods><class-id>Net.HeaderField</class-id> <category>private</category><body package="MIME" selector="doParse:">doParse: rfc822Stream" Generic parser for unstructured fields. This method is typically overridden for fields with known syntax to do more detailed parsing "	^rfc822Stream skipWhiteSpace; scanText</body></methods><methods><class-id>Net.HeaderField</class-id> <category>printing</category><body package="MIME" selector="printNameOn:">printNameOn: aStream	aStream		nextPutAll: self canonicalFieldName;		nextPut: $: ;		space.</body><body package="MIME" selector="printOn:indent:">printOn: aStream indent: level	super printOn: aStream indent: level.	self 		printNameOn: aStream;		printValueOn: aStream.</body><body package="MIME" selector="printValueOn:">printValueOn: aStream	| val | 	(val := self value) notNil		ifTrue: 			[ (val isKindOf: String) 				ifTrue: [ aStream nextPutAll:  val]				ifFalse: [ val printOn: aStream ] ]</body></methods><methods><class-id>Net.HeaderField</class-id> <category>private-initialize</category><body package="MIME" selector="valueFrom:">valueFrom: aString " Swazoo compatibility"	^self readFrom: aString readStream</body></methods><methods><class-id>Net.HeaderField</class-id> <category>visiting</category><body package="MIME" selector="acceptVisit:with:">acceptVisit: aVisitor  with: argument	^aVisitor acceptHeaderField: self with: argument</body></methods><methods><class-id>Net.HeaderField</class-id> <category>parsing</category><body package="MIME" selector="parse:">parse: rfc822Stream" Generic parser for unstructured fields. Copy everything up to CRLF. Scanner handles end of line rules and answers cr when end of line is seen. Scanner also folds linear white space answering space character in place of &lt;CRLF space+&gt; "	[value := self doParse: rfc822Stream.]		on: Error 		do: [ :ex |  			Transcript cr; show: ((#ErrorParsingMimeHeader &lt;&lt; #net &gt;&gt; 'Error parsing mime header: &lt;1s&gt;  &lt;2s&gt;')			expandMacrosWith: self name			with: ex errorString); cr. 			value := nil ].</body></methods><methods><class-id>Net.HeaderField</class-id> <category>composing</category><body package="MIME" selector="writeOn:">writeOn: aStream	self parent ~~ nil		ifTrue: [ 	self writeOn: aStream encoding: self parent headerCharset ]		ifFalse: [ self printOn: aStream ]</body><body package="MIME" selector="writeOn:encoding:">writeOn: aStream encoding: aString"Encoding should be added to value if needed "	self 		printNameOn: aStream;		writeValueOn: aStream encoding: aString.</body><body package="MIME" selector="writeValueOn:encoding:">writeValueOn: aStream encoding: aString	| val rfcString |	(val := self value) notNil		ifTrue: 			[ rfcString :=  (MimeEncodedWordCoDec shouldBeEncoded: val)				ifTrue: [ (MimeEncodedWordCoDec encodeText: val asBase64Using: aString) ]				ifFalse: [ val ].			aStream nextPutAll: rfcString]</body></methods><methods><class-id>Net.HeaderField class</class-id> <category>parsing</category><body package="MIME" selector="defaultFieldClass">defaultFieldClass	^HeaderField</body><body package="MIME" selector="fieldClassForName:">fieldClassForName: fieldName	^self fieldsRegistry at:  fieldName asLowercase ifAbsent: [self defaultFieldClass].</body><body package="MIME" selector="fieldNames">fieldNames	^#()</body><body package="MIME" selector="fromLine:">fromLine: aString " For compatibility with Swazoo "	^self readFrom: aString readStream</body><body package="MIME" selector="readFieldNameFrom:">readFieldNameFrom: rfc822Stream	| fname |	fname := rfc822Stream scanFieldName. 	rfc822Stream skipWhiteSpace.	^(rfc822Stream atEnd or: [(rfc822Stream peekFor: $:) not])		ifTrue: [ nil ]		ifFalse: [fname asLowercase]</body><body package="MIME" selector="readFrom:">readFrom: aStream 	"Reads and parses message header contents from the message stream; answers an instance of header field"	| fname scanner |	scanner := self scannerOn: aStream.	^(fname := self readFieldNameFrom: scanner) isNil		ifTrue: [nil]		ifFalse: [(self name: fname)				source: aStream;				parse: scanner]</body><body package="MIME" selector="scannerType">scannerType	^MimeScanner</body></methods><methods><class-id>Net.HeaderField class</class-id> <category>instance creation</category><body package="MIME" selector="default">default	^self new</body><body package="MIME" selector="name:">name: aname" Answer new instance of field corresponding to field's name. For now, treat all fields as unstructured "	^(self fieldClassForName: aname) new name: aname; yourself</body><body package="MIME" selector="new">new	^super new initialize</body></methods><methods><class-id>Net.HeaderField class</class-id> <category>class initialization</category><body package="MIME" selector="fieldsRegistry">fieldsRegistry	"(self fieldsRegistry)"	FieldsRegistry isEmpty		ifTrue: [ self registerClassFields].	^FieldsRegistry</body><body package="MIME" selector="initialize">initialize	"(((self initialize)))"	self resetRegistry.</body><body package="MIME" selector="registerClassFields">registerClassFields	HeaderField allSubclasses 		do: [ :cl | 			cl fieldNames do: [ :fname | FieldsRegistry at: fname put: cl ]]</body><body package="MIME" selector="resetRegistry">resetRegistry	FieldsRegistry := Dictionary new: 5.</body></methods><methods><class-id>Net.MessageHeader</class-id> <category>adding</category><body package="MIME" selector="add:">add: field	self register: field.	self fields add: field</body><body package="MIME" selector="add:after:">add: field after: object	self register: field.	self fields add: field after: object</body><body package="MIME" selector="add:afterIndex:">add: field afterIndex: occurrenceIndex	self register: field.	self fields add: field afterIndex: occurrenceIndex</body><body package="MIME" selector="add:before:">add: field before: object	self register: field.	self fields add: field before: object</body><body package="MIME" selector="add:beforeIndex:">add: field beforeIndex: occurrenceIndex	self register: field.	self fields add: field beforeIndex: occurrenceIndex</body><body package="MIME" selector="addAll:">addAll: collectionOfFields 	collectionOfFields do: [:field | self add: field]</body></methods><methods><class-id>Net.MessageHeader</class-id> <category>sorting</category><body package="MIME" selector="arrangeFieldsInOrder:">arrangeFieldsInOrder: anArrayOfFieldNames" Make sure specified fields occur before all other fields in specified order "	value := self fieldsInOrder: anArrayOfFieldNames</body><body package="MIME" selector="fieldsInOrder:">fieldsInOrder: anArrayOfFieldNames" Answer fields sorted such that specified fields occur before all other fields"	| definedFields |	definedFields := OrderedCollection new: self fields size.	anArrayOfFieldNames do: [ :fieldName | definedFields addAll: (self allAt: fieldName)].	definedFields addAll: (self fields reject: [ :fieldx | definedFields includes: fieldx]).	^definedFields</body></methods><methods><class-id>Net.MessageHeader</class-id> <category>accessing</category><body package="MIME" selector="allAt:">allAt: name	^self registry at: name asLowercase ifAbsent: [OrderedCollection new]</body><body package="MIME" selector="at:">at: name	^self at: name at: 1</body><body package="MIME" selector="at:at:">at: name at: occurrenceIndex	^self at: name at: occurrenceIndex ifAbsent: [ nil ]</body><body package="MIME" selector="at:at:ifAbsent:">at: name at: occurrenceIndex ifAbsent: aNiladicBlock	| namedFields |	namedFields := self registry at: name asLowercase ifAbsent: [^aNiladicBlock value ].	^namedFields size &gt;= occurrenceIndex		ifTrue: [namedFields at: occurrenceIndex]		ifFalse: [ aNiladicBlock value ]</body><body package="MIME" selector="at:ifAbsent:">at: name ifAbsent: aNiladicBlock	^self at: name at: 1 ifAbsent: aNiladicBlock</body><body package="MIME" selector="at:ifAbsentPut:">at: name ifAbsentPut: aNiladicBlock 	^self at: name ifAbsent: [self at: name put: aNiladicBlock value]</body><body package="MIME" selector="at:put:">at: name put: field	field name: name.	self 		removeKey: name;		add: field.	^field</body><body package="MIME" selector="fields">fields	^value</body><body package="MIME" selector="fields:">fields: aCollection" Replace all fields with new set of fields "	self initialize; addAll: aCollection</body><body package="MIME" selector="indexOf:">indexOf: field	^self fields indexOf: field</body><body package="MIME" selector="parent:">parent: aMimeEntity	super parent: aMimeEntity.	self fieldsDo: [ :field | field parent: aMimeEntity ].</body></methods><methods><class-id>Net.MessageHeader</class-id> <category>enumerating</category><body package="MIME" selector="fieldsDo:">fieldsDo: aMonadicBlock	self fields do: aMonadicBlock</body></methods><methods><class-id>Net.MessageHeader</class-id> <category>copying</category><body package="MIME" selector="postCopy">postCopy	| oldFields |	oldFields := value.	self initialize.	oldFields do: [ :field | self add: field copy ]</body></methods><methods><class-id>Net.MessageHeader</class-id> <category>private</category><body package="MIME" selector="deregister:">deregister: field 	"Remove field from registry"	| namedFields | 	namedFields := self registry at: field name asLowercase ifAbsent: [^self].	namedFields remove: field.	namedFields isEmpty ifTrue: [self registry removeKey: field name asLowercase]</body><body package="MIME" selector="register:">register: field" Register field in field registry "	field parent: self parent.	(self registry at: field name asLowercase ifAbsentPut: [ OrderedCollection new ]) add: field</body><body package="MIME" selector="registry">registry	^registry</body></methods><methods><class-id>Net.MessageHeader</class-id> <category>removing</category><body package="MIME" selector="remove:">remove: field 	field notNil		ifTrue: 			[self fields remove: field.			self deregister: field]</body><body package="MIME" selector="removeAll:">removeAll: collectionOfFields	collectionOfFields do: [ :field | self remove: field ]</body><body package="MIME" selector="removeAllAt:">removeAllAt: name	self removeAll: (self allAt: name)</body><body package="MIME" selector="removeKey:">removeKey: fieldName	self removeAll: (self allAt: fieldName)</body></methods><methods><class-id>Net.MessageHeader</class-id> <category>composing</category><body package="MIME" selector="writeOn:">writeOn: aStream 	self fields do: [:field | field writeOn: aStream]</body></methods><methods><class-id>Net.MessageHeader</class-id> <category>visiting</category><body package="MIME" selector="acceptVisit:with:">acceptVisit: aVisitor with: argument	^aVisitor acceptMessageHeader: self with: argument</body></methods><methods><class-id>Net.MessageHeader</class-id> <category>initialization</category><body package="MIME" selector="initialize">initialize	registry := Dictionary new: 10.	value := OrderedCollection new: 10.</body></methods><methods><class-id>Net.MessageHeader</class-id> <category>printing</category><body package="MIME" selector="printOn:indent:">printOn: aStream indent: level	aStream 		nextPutAll: self class name, ': ';		nextPutAll: self registry keys printString;		cr</body></methods><methods><class-id>Net.MessageHeader class</class-id> <category>instance creation</category><body package="MIME" selector="newFor:">newFor: aMimeEntity	^self new parent: aMimeEntity</body></methods><methods><class-id>Net.StructuredHeaderField</class-id> <category>accessing</category><body package="MIME" selector="canonicalValue">canonicalValue" Canonical value removes all white space and comments from the source "	^self tokenizedValueFrom: (self scannerOn: self source readStream)</body><body package="MIME" selector="comment">comment	^comment</body><body package="MIME" selector="comment:">comment: aString	comment := aString</body></methods><methods><class-id>Net.StructuredHeaderField</class-id> <category>printing</category><body package="MIME" selector="printCommentOn:">printCommentOn: aStream 	self class scannerType printComment: self comment on: aStream</body><body package="MIME" selector="printStructureOn:">printStructureOn: aStream" Default implementation is the same as inherited. Subclasses can override it "	super printValueOn: aStream.	self printCommentOn: aStream</body><body package="MIME" selector="printValueOn:">printValueOn: aStream	self printStructureOn: aStream</body></methods><methods><class-id>Net.StructuredHeaderField</class-id> <category>private-utility</category><body package="MIME" selector="sanitizeAddress:">sanitizeAddress: addressOrString 	"Make addresses is strings"	^(addressOrString isKindOf: NetworkEntityDescriptor)		ifTrue: [addressOrString printString]		ifFalse: [addressOrString]</body><body package="MIME" selector="sanitizeAddress:encoding:">sanitizeAddress: addressOrString encoding: aString	"Make addresses as strings"	^(addressOrString isKindOf: NetworkEntityDescriptor)		ifTrue: [addressOrString stringWithEncoding: aString ]		ifFalse: 			[MimeEncodedWordCoDec encodeIfRequired: addressOrString using: aString]</body><body package="MIME" selector="tokenize:">tokenize: rfc822Stream 	"Scan field value token by token. Answer an array of tokens"	| result token |	result := (Array new: 2) writeStream.	[rfc822Stream atEnd or: [rfc822Stream peek == Character cr or: [(token := rfc822Stream nextToken) isNil]]]		whileFalse: [result nextPut: token].	^result contents</body><body package="MIME" selector="tokenizedValueFrom:">tokenizedValueFrom: rfc822Stream 	"Scan field value token by token. Answer a string that is a concatenation of all elements in the array. One can view this as a canonicalized field value because this operation eliminates all white space and comments "	| result tokens |	result := (String new: 32) writeStream.	tokens := self tokenize: rfc822Stream.	tokens		do: [:token | token isString				ifTrue: [result nextPutAll: token]				ifFalse: [result nextPut: token]].	^result contents</body></methods><methods><class-id>Net.StructuredHeaderField</class-id> <category>composing</category><body package="MIME" selector="writeCommentOn:encoding:">writeCommentOn: aStream encoding: aString	self comment ~~ nil 		ifTrue: 			[aStream nextPutAll: 				(MimeEncodedWordCoDec 					encodeComment: self comment 					asBase64Using: aString)]</body><body package="MIME" selector="writeStructureOn:encoding:">writeStructureOn: aStream encoding: aString" Default implementation is the same as inherited. Subclasses can override it "	self  printValueOn: aStream.	self writeCommentOn: aStream encoding: aString</body><body package="MIME" selector="writeValueOn:encoding:">writeValueOn: aStream encoding: aString	self writeStructureOn: aStream encoding: aString</body></methods><methods><class-id>Net.MailScanner</class-id> <category>printing</category><body package="MIME" selector="printAtom:on:">printAtom: atom on: stream	self class printAtom: atom on: stream</body><body package="MIME" selector="printQuotedText:on:">printQuotedText: qtext on: stream	self class printQuotedText: qtext on: stream</body><body package="MIME" selector="printText:on:">printText: qtext on: stream	self class printText: qtext on: stream</body></methods><methods><class-id>Net.MailScanner class</class-id> <category>printing</category><body package="MIME" selector="print:on:">print: char on: aStream	aStream nextPut: char</body><body package="MIME" selector="printAll:on:">printAll: aString on: aStream	aStream nextPutAll: aString</body><body package="MIME" selector="printQuotedText:on:">printQuotedText: str on: stream 	"Print word as quoted text"	stream nextPut: $"; nextPutAll: str; nextPut: $"</body><body package="MIME" selector="printText:on:">printText: text on: stream	stream nextPutAll: text</body><body package="MIME" selector="printTokenList:on:">printTokenList: list on: stream	self printTokenList: list on: stream separatedBy: [ stream space ]</body><body package="MIME" selector="printTokenList:on:separatedBy:">printTokenList: list on: stream separatedBy: aBlock 	list do: [:assoc | self printToken: assoc on: stream]		separatedBy: aBlock</body></methods><methods><class-id>Net.RFC822Scanner</class-id> <category>testing</category><body package="MIME" selector="isRFC822Scanner">isRFC822Scanner	^true</body></methods><methods><class-id>Net.RFC822Scanner</class-id> <category>private</category><body package="MIME" selector="next">next	[super next.] 	on: NonASCIICharException 	do: [ :ex | 		hereChar := ex parameter.		self sourceTrailNextPut: hereChar.		classificationMask := QuotedPairMask.		ex return ].	^hereChar</body><body package="MIME" selector="nextRFC822Token">nextRFC822Token	| char |	self skipWhiteSpace.	char := self peek.	char isNil				"end of input"		ifTrue: [tokenType := #doIt.			^token := nil].	char == $( ifTrue: [^self scanComment; nextToken].	char == $" ifTrue: [^self scanQuotedText].	(self specials includes: char)		ifTrue: [tokenType := #special.		" Special character. Make it token value and set token type "				^token := self next.].	(self matchCharacterType: AtomMask)		ifTrue: [^self scanAtom].	tokenType := #doIt.	token := char.	^token</body><body package="MIME" selector="scanCommentOn:">scanCommentOn: streamOrNil 	"scan comment copying on specified stream"	self step ~~ $( ifTrue: [self error: (#UnmatchedComment &lt;&lt; #net &gt;&gt; 'Unmatched comment') ].		" Should never be the case "	token := self				scanUntil: [					((self scanQuotedChar; matchCharacterType: CommentMask)						ifTrue: 							[streamOrNil notNil ifTrue: [streamOrNil nextPut: hereChar].							true]						ifFalse: [hereChar == $(								ifTrue: 									[streamOrNil notNil ifTrue: [streamOrNil space].									self stepBack; scanCommentOn: streamOrNil.									streamOrNil notNil ifTrue: [streamOrNil space].									true]								ifFalse: [false]]) not].	hereChar ~~ $) ifTrue: [ self error: (#UnmatchedComment &lt;&lt; #net &gt;&gt; 'Unmatched comment') ].	^token</body><body package="MIME" selector="shouldFoldLine">shouldFoldLine	"Answers true if next line is to be folded in, that is, if CRLF is followed by at least one white space"	| char |	self atEnd ifTrue: [ ^false ].	char := source peek.	^((self classificationMaskFor: char) anyMask: WhiteSpaceMask)		ifTrue: [self sourceTrailNextPut: source next. true]		ifFalse: [false]</body><body package="MIME" selector="step">step	super step.	self scanEndOfLine.	^hereChar</body></methods><methods><class-id>Net.RFC822Scanner</class-id> <category>tokenization</category><body package="MIME" selector="nextToken">nextToken	^self nextRFC822Token</body><body package="MIME" selector="specials">specials" This method is provided to encapsulate lexical differences between RFC822 on one side, and MIME, HTTP on the other side. MIME definiton of 'tspecials' is the same as the RFC 822 definition of ''specials' with the addition of the three characters &lt;/&gt;, &lt;?&gt;, and &lt;=&gt;, and the removal of &lt;.&gt;. To present uniform tokenization interface, this method is overridden in Mime scanner "	^self class specials</body></methods><methods><class-id>Net.RFC822Scanner</class-id> <category>multi-character scans</category><body package="MIME" selector="scanAtom">scanAtom" atom  =  1*&lt;any CHAR except specials, SPACE and CTLs&gt; "	token := self scanTokenMask: AtomMask.	tokenType := #atom.	^token.</body><body package="MIME" selector="scanComment">scanComment	"collect comment"	| output decComment |	output := saveComments				ifTrue: [(String new: 64) writeStream]				ifFalse: [nil].	self scanCommentOn: output.	output notNil 		ifTrue: [			decComment := MimeEncodedWordCoDec decodeComment: output contents.			currentComment isNil				ifTrue: [currentComment := OrderedCollection with: decComment]				ifFalse: [currentComment add: decComment]]. 	^token</body><body package="MIME" selector="scanDate">scanDate	^self class readDateAndTimeFrom: self asStream</body><body package="MIME" selector="scanDomainText">scanDomainText	"dtext = &lt;any CHAR excluding &lt;[&gt;, &lt;]&gt;, &lt;\&gt; &amp; CR, &amp; including linear-white-space&gt; ; =&gt; may be folded"	token := self				scanToken: [self scanQuotedChar; matchCharacterType: DomainTextMask]				delimitedBy: '[]'				notify: (#MalformedDomainLiteral &lt;&lt; #net &gt;&gt; 'Malformed domain literal').	tokenType := #domainText.	^token</body><body package="MIME" selector="scanEndOfLine">scanEndOfLine	"Note: this will work only for RFC822 but not for HTTP. Needs more design work"	(self matchCharacterType: CRLFMask)		ifTrue: 			[(hereChar == Character cr)				ifTrue: 					[self shouldFoldLine ifTrue: [ 						self hereChar: Character space.						^self]].				"Otherwise we have an end-of-line condition -- set appropriate masks"			classificationMask := (classificationMask maskClear: WhiteSpaceMask)						maskSet: EndOfLineMask]</body><body package="MIME" selector="scanFieldName">scanFieldName	" RFC822, p.9: field-name = 1*&lt;any CHAR excluding CTLs, SPACE and ':'&gt; "	^self scanTokenMask: HeaderNameMask</body><body package="MIME" selector="scanPhrase">scanPhrase	"RFC822: phrase = 1*word ; Sequence of words. At the end of scan the scanner has read the first token after phrase "	^self tokenizeWhile: [#(#quotedText #atom) includes: tokenType]</body><body package="MIME" selector="scanQuotedChar">scanQuotedChar	"Scan possible quoted character. If the current char is $\, read in next character and make it a quoted 	string character"	^(hereChar == QuotedPairChar)		ifTrue: 			[self step.			classificationMask := QuotedPairMask.			true]		ifFalse: [false]</body><body package="MIME" selector="scanQuotedText">scanQuotedText" quoted-string = &lt;""&gt; *(qtext/quoted-pair) &lt;""&gt;; Regular qtext or quoted chars.  qtext    =  &lt;any CHAR excepting &lt;""&gt;, &lt;\&gt; &amp; CR, and including linear-white-space&gt;  ; =&gt; may be folded"	" We are positioned at the first double quote character "	token := self scanToken: [ self scanQuotedChar; matchCharacterType: QuotedTextMask ] delimitedBy: '""' notify: (#UnmatchedQuotedText &lt;&lt; #net &gt;&gt; 'Unmatched quoted text').	tokenType := #quotedText.	^token.</body><body package="MIME" selector="scanText">scanText	"RFC822: text = &lt;Any CHAR, including bare CR &amp; bare LF, but not including CRLF. This is a 'catchall' category and cannot be tokenized. Text is used only to read values of unstructured fields"	^MimeEncodedWordCoDec decodeText: (self scanUntil: [ self matchCharacterType: CRLFMask ])</body><body package="MIME" selector="scanWord">scanWord	self nextToken.	(#(#quotedText #atom) includes: tokenType)			ifFalse: [self error: (#ExpectingWord &lt;&lt; #net &gt;&gt; 'Expecting word')].	^token</body><body package="MIME" selector="skipWhiteSpace">skipWhiteSpace	"It is inefficient because intermediate stream is created. Perhaps refactoring scanWhile: can help"	self scanWhile: [hereChar == $(			ifTrue: 				[self stepBack; scanComment.				true]			ifFalse: [self matchCharacterType: WhiteSpaceMask]]</body></methods><methods><class-id>Net.RFC822Scanner</class-id> <category>converting</category><body package="MIME" selector="phraseAsString:">phraseAsString: phrase	| stream |	stream := (String new: 64) writeStream.	self class printPhrase: phrase on: stream. 	^stream contents.</body></methods><methods><class-id>Net.RFC822Scanner class</class-id> <category>from Network Clients</category><body package="MIME" selector="adjustTime:timezone:">adjustTime: aTimestamp timezone: timezone	| localSeconds timezoneSeconds |	localSeconds := TimeZone default secondsFromGMT .	timezoneSeconds := ('#####' match: timezone)			ifTrue: [ | sec |				sec := ((timezone copyFrom: 2 to: 3) asNumber * 60 + (timezone copyFrom: 4 to: 5) asNumber) * 60.				timezone first = $- ifTrue: [sec negated] ifFalse: [sec]]			ifFalse: [(SimpleTimeZones at: timezone ifAbsent: [nil]) ifNotNil: [ :hrs | "60*60"3600 * hrs ]].	^timezoneSeconds isNil		ifTrue: [aTimestamp]		ifFalse: [Timestamp fromSeconds: (aTimestamp asSeconds - timezoneSeconds + localSeconds)]</body><body package="MIME" selector="correctDateForY2K:">correctDateForY2K: date" Arbitrarily decide that if year is &gt;2050, subtract one century ""RFC 2822Where a two or three digit year occurs in a date, the year is to be   interpreted as follows: If a two digit year is encountered whose   value is between 00 and 49, the year is interpreted by adding 2000,   ending up with a value between 2000 and 2049.  If a two digit year is   encountered with a value between 50 and 99, or any three digit year   is encountered, the year is interpreted by adding 1900. "	date year &gt; 2050 		ifTrue: [date day: date day year: date year - 100].	^date</body><body package="MIME" selector="currentGMTDateAndTime">currentGMTDateAndTime"self  currentGMTDateAndTime"	^TimeZone null		convertGMT: Time secondClock		do:			[:date :seconds |			Array with: date with: (Time fromSeconds: seconds)]</body><body package="MIME" selector="dateAndTimeFrom:">dateAndTimeFrom: aString	"RFC822Scanner dateAndTimeFrom: '6 Dec 88 10:16:08 +0900 (Tuesday)'."	"RFC822Scanner dateAndTimeFrom: '12 Dec 88 10:16:08 +0900 (Tuesday)'."	"RFC822Scanner dateAndTimeFrom: 'Fri, 31 Mar 89 09:13:20 +0900'."	"RFC822Scanner dateAndTimeFrom: 'Tue, 18 Apr 89 23:29:47 +0900'."	"RFC822Scanner dateAndTimeFrom: 'Tue, 23 May 89 13:52:12 JST'."	"RFC822Scanner dateAndTimeFrom: 'Thu, 1 Dec 88 17:13:27 jst'."	"RFC822Scanner dateAndTimeFrom: 'Sat, 15 Jul 95 14:36:22 0900'."	"RFC822Scanner dateAndTimeFrom: '2-Nov-86 10:43:42 PST'."	"RFC822Scanner dateAndTimeFrom: 'Friday, 21-Jul-95 04:04:55 GMT'."	"RFC822Scanner dateAndTimeFrom: 'Jul 10 11:06:40 1995'."	"RFC822Scanner dateAndTimeFrom: 'Jul 10 11:06:40 JST 1995'."	"RFC822Scanner dateAndTimeFrom: 'Mon Jul 10 11:06:40 1995'."	"RFC822Scanner dateAndTimeFrom: 'Mon Jul 10 11:06:40 JST 1995'."	"RFC822Scanner dateAndTimeFrom: '(6 December 1988 10:16:08 am )'."	"RFC822Scanner dateAndTimeFrom: '(12 December 1988 10:16:08 am )'."	"RFC822Scanner dateAndTimeFrom: ''."	| rfcString |	aString size &lt;= 10	"may be illegal format"		ifTrue: [^self currentGMTDateAndTime].	rfcString := self normalizeDateAndTimeString: aString.	^self readDateAndTimeFrom: rfcString readStream</body><body package="MIME" selector="dateStringFrom:">dateStringFrom: aTimestamp	"Return Date dateAndTimeNow in the Unix mail format"	" self dateAndTimeFrom: (Array with: Date today with: Time now) "	| stream temp indx d seconds hours minutes date |	stream := WriteStream on: (String new: 40).	date := aTimestamp asDate.	indx := date weekdayIndex.	d := #(#Mon #Tue #Wed #Thr #Fri #Sat #Sun) at: indx.	stream nextPutAll: d.	stream nextPutAll: ', '.	date printOn: stream format: #(1 2 3 $  2 1).	stream nextPutAll: ((temp := aTimestamp hour) &lt; 10 				ifTrue: [' 0']				ifFalse: [' ']).	temp printOn: stream.	stream nextPutAll: ((temp := aTimestamp minute) &lt; 10 				ifTrue: [':0']				ifFalse: [':']).	temp printOn: stream.	stream nextPutAll: ((temp := aTimestamp second) &lt; 10 				ifTrue: [':0']				ifFalse: [':']).	temp printOn: stream.	seconds := TimeZone default secondsFromGMT .	seconds negative 		ifTrue: [stream nextPutAll: ' -']		ifFalse: [stream nextPutAll: ' +'].	hours := seconds abs // 3600.	hours abs &lt; 10 ifTrue: [stream nextPut: $0].	stream print: hours abs.	minutes := seconds abs \\ 3600 // 60.	minutes abs &lt; 10 ifTrue: [stream nextPut: $0].	stream print: minutes.  	^stream contents</body><body package="MIME" selector="defaultTimeZoneDifference">defaultTimeZoneDifference	^TimeZone default instVarAt: 1</body><body package="MIME" selector="initializeTimeZones">initializeTimeZones	"RFC822Scanner initializeTimeZones."	"Install TimeZone constants."	SimpleTimeZones := Dictionary new.	"Universal Time"	SimpleTimeZones at: 'UT' put: 0.	SimpleTimeZones at: 'GMT' put: 0.	"For North America."	SimpleTimeZones at: 'EST' put: -5.	SimpleTimeZones at: 'EDT' put: -4.	SimpleTimeZones at: 'CST' put: -6.	SimpleTimeZones at: 'CDT' put: -5.	SimpleTimeZones at: 'MST' put: -7.	SimpleTimeZones at: 'MDT' put: -6.	SimpleTimeZones at: 'PST' put: -8.	SimpleTimeZones at: 'PDT' put: -7.	"For Europe."	SimpleTimeZones at: 'BST' put: 0.	SimpleTimeZones at: 'WET' put: 0.	SimpleTimeZones at: 'MET' put: 1.	SimpleTimeZones at: 'EET' put: 2.	"For Japan."	SimpleTimeZones at: 'JST' put: 9</body><body package="MIME" selector="normalizeDateAndTimeString:">normalizeDateAndTimeString: aString	"RFC822 formats"	"RFC822Scanner normalizeDateAndTimeString: '6 Dec 88 10:16:08 +0900 (Tuesday)'."	"RFC822Scanner normalizeDateAndTimeString: 'Tue, 18 Apr 89 23:29:47 +0900'."	"RFC822Scanner normalizeDateAndTimeString: 'Tue, 18 Apr 89 23:29:47 0900'."	"RFC822Scanner normalizeDateAndTimeString: 'Tue, 23 May 89 13:52:12 JST'."	"RFC822Scanner normalizeDateAndTimeString: '2-Nov-86 10:43:42 PST'."	"Other formats"	"RFC822Scanner normalizeDateAndTimeString: 'Jul 10 11:06:40 1995'."	"RFC822Scanner normalizeDateAndTimeString: 'Jul 10 11:06:40 JST 1995'."	"RFC822Scanner normalizeDateAndTimeString: 'Mon Jul 10 11:06:40 1995'."	"RFC822Scanner normalizeDateAndTimeString: 'Mon Jul 10 11:06:40 JST 1995'."	| head tail read str1 str2 write |	aString size &lt; 6 ifTrue: [^aString].	head := aString copyFrom: 1 to: aString size - 5.	(head indexOf: $,) &gt; 0 ifTrue: [^aString].	tail := aString copyFrom: aString size - 4 to: aString size.	read := tail readStream.	(read next = Character space and:	[read next isDigit and:	[read next isDigit and:	[read next isDigit and:	[read next isDigit]]]])		ifFalse: [^aString].	read := head readStream.	str1 := read through: Character space.	str2 := read through: Character space.	(str1 isEmpty or: [str2 isEmpty]) ifTrue: [^aString].	str2 first isDigit		ifFalse:			[str1 := str2.			str2 := read through: Character space.			(str2 isEmpty or: [str2 first isDigit not]) ifTrue: [^aString]].	read atEnd ifTrue: [^aString].	write := WriteStream on: (String new: 32).	write nextPutAll: str2;		nextPutAll: str1;		nextPutAll: (tail copyFrom: 4 to: 5);		space;		nextPutAll: read.	^write contents</body><body package="MIME" selector="readDateAndTimeFrom:">readDateAndTimeFrom: aStream	"date-time	=  [ day ',' ] date time	day			=  'Mon'  / 'Tue' /  'Wed'  / 'Thu'				/  'Fri'  / 'Sat' /  'Sun'"	"RFC822Scanner readDateAndTimeFrom: '6 Dec 88 10:16:08 +0900 (Tuesday)' readStream."	| date time timezone |	"While reviewing AR#44558 we decided if the date field is empty to return nil instead of old implementation ^self currentGMTDateAndTime to be able determine if field is valid or not"	aStream atEnd ifTrue: [^nil].	date := self readDateFrom: aStream.	"time	= hour zone 	hour	= 2DIGIT ':' 2DIGIT [':' 2DIGIT] "	aStream skipSeparators.	time := Time readFrom: aStream.	timezone := self readTimezoneFrom: aStream.	^timezone isEmpty		ifTrue: [Timestamp fromDate: date andTime: time]		ifFalse: 			[self 				adjustTime: (Timestamp fromDate: date andTime: time) 				timezone: timezone].</body><body package="MIME" selector="readDateFrom:">readDateFrom: aStream	"date	=  1*2DIGIT month 2DIGIT	month	=  'Jan'  /  'Feb' /  'Mar'  /  'Apr'			/  'May'  /  'Jun' /  'Jul'  /  'Aug'			/  'Sep'  /  'Oct' /  'Nov'  /  'Dec'"	"RFC822Scanner readDateFrom: '01 Jan 95' readStream."	"RFC822Scanner readDateFrom: '1 Jan 50' readStream."	"RFC822Scanner readDateFrom: '23 Jan 02' readStream."	"RFC822Scanner readDateFrom: '23-Jan-95' readStream."	"RFC822Scanner readDateFrom: 'Jan 23 2095' readStream."	"RFC822Scanner readDateFrom: 'Jan 23 1995' readStream."	| reader position token date yearChunk |	reader := (TimestampPrintPolicy newFor: #rfc822) reader.	position := aStream position.	token := reader getLatinToken: aStream.	(token isString and: [ #('mon' 'tue' 'wed' 'thu' 'thr' 'fri' 'sat' 'sun') includes: token asLowercase])		ifFalse: [ aStream position: position ].	date := reader readDateFrom: aStream.	 aStream skip: -4.	 yearChunk := aStream next: 4.	 (('####' match: yearChunk)		 and: [ (yearChunk copyFrom: 1 to: 4) asNumber = date year ])			  ifFalse: [ self correctDateForY2K: date ].	^date</body><body package="MIME" selector="readTimezoneFrom:">readTimezoneFrom: aStream 	"time	= hour zone 	hour	= 2DIGIT ':' 2DIGIT [':' 2DIGIT] 	zone	= 'UT' / 'GMT' 	/ 'EST' / 'EDT' 	/ 'CST' / 'CDT' 	/ 'MST' / 'MDT' 	/ 'PST' / 'PDT' 	/ 1ALPHA 	/ ( ('+' / '-') 4DIGIT )"	| write char |	aStream skipSeparators.	write := WriteStream on: (String new: 8).	[aStream atEnd		or: 			[char := aStream next.			char isSeparator]]		whileFalse: [write nextPut: char].	^write contents asUppercase.</body></methods><methods><class-id>Net.RFC822Scanner class</class-id> <category>printing</category><body package="MIME" selector="defaultTokenType">defaultTokenType	^#word</body><body package="MIME" selector="printComment:on:">printComment: comment on: stream 	comment notNil ifTrue: [		stream nextPut: $(.		comment			do: 				[:char | 				(self isCommentChar: char)					ifFalse: [stream nextPut: $\].				stream nextPut: char].		stream nextPut: $).	]</body><body package="MIME" selector="printDomain:on:">printDomain: domainx on: stream 	"Domainx is an array of domain segments"	domainx notNil ifTrue: [domainx do: [:word | self printWord: word on: stream]			separatedBy: [stream nextPut: $.]]</body><body package="MIME" selector="printPhrase:on:">printPhrase: phrase on: stream	phrase do: [ :word | stream nextPutAll: word] separatedBy: [ stream space ]</body><body package="MIME" selector="printWord:on:">printWord: str on: stream 	"Print word as either atom or quoted text"	(self shouldBeQuoted: str)		ifTrue: [stream nextPut: $"; nextPutAll: str; nextPut: $"]		ifFalse: [stream nextPutAll: str]</body></methods><methods><class-id>Net.RFC822Scanner class</class-id> <category>class initialization</category><body package="MIME" selector="initClassificationTable">initClassificationTable	super initClassificationTable.	self initClassificationTableWith: HeaderNameMask when:		[:c | c &gt; Character space and: [c ~~ $:]].	self initClassificationTableWith: TextMask when:		[:c | c ~~ Character cr ].	self initClassificationTableWith: AtomMask when:		[:c | c &gt; Character space and: [ (self specials includes: c) not ] ].	self initClassificationTableWith: TokenMask when:		[:c | c &gt; Character space and: [ (self tspecials includes: c) not ] ].	self initClassificationTableWith: QuotedTextMask when:		[:c | c ~~ $" and: [ c ~~ $\ and: [ c ~~ Character cr ]]].	self initClassificationTableWith: DomainTextMask when:		[:c | ('[]\' includes: c) not and: [ c ~~ Character cr ]].	self initClassificationTableWith: CommentMask when:		[:c | c ~~ $( and: [ c ~~ $) and: [ c ~~ $\ and: [ c ~~ Character cr ]]]].</body><body package="MIME" selector="initialize">initialize	" RFC822Scanner initialize "	self initializeConstants; initClassificationTable</body><body package="MIME" selector="initializeConstants">initializeConstants	AtomMask := 256.	CommentMask := 512.	DomainTextMask := 1024.	HeaderNameMask := 2048.	QuotedTextMask := 4096.	TextMask := 8192.	TokenMask := 16384.	QuotedPairMask := (QuotedTextMask bitOr: CommentMask) bitOr: DomainTextMask.	QuotedPairChar := $\.	HeaderNameDelimiterChar := $:.	"Install TimeZone constants."	SimpleTimeZones := Dictionary new.	"Universal Time"	SimpleTimeZones at: 'UT' put: 0.	SimpleTimeZones at: 'GMT' put: 0.	"For North America."	SimpleTimeZones at: 'EST' put: -5.	SimpleTimeZones at: 'EDT' put: -4.	SimpleTimeZones at: 'CST' put: -6.	SimpleTimeZones at: 'CDT' put: -5.	SimpleTimeZones at: 'MST' put: -7.	SimpleTimeZones at: 'MDT' put: -6.	SimpleTimeZones at: 'PST' put: -8.	SimpleTimeZones at: 'PDT' put: -7.	"For Europe."	SimpleTimeZones at: 'BST' put: 0.	SimpleTimeZones at: 'WET' put: 0.	SimpleTimeZones at: 'MET' put: 1.	SimpleTimeZones at: 'EET' put: 2.	"For Japan."	SimpleTimeZones at: 'JST' put: 9</body></methods><methods><class-id>Net.RFC822Scanner class</class-id> <category>character classification</category><body package="MIME" selector="specials">specials	" Note that definition of this set varies from standard to standard, so this method needs to be overridden for specialized parsers " 	^'()&lt;&gt;@,;:\".[]'</body><body package="MIME" selector="tspecials">tspecials	" tspecials in MIME and HTTP. It is derived from RCC822 specials with addition of &lt;/&gt;, &lt;?&gt;, &lt;=&gt; and removal; of &lt;.&gt; " 	^'()&lt;&gt;@,;:\"/[]?='</body></methods><methods><class-id>Net.RFC822Scanner class</class-id> <category>testing</category><body package="MIME" selector="isAtomChar:">isAtomChar: char	^((self classificationMaskFor: char)  bitAnd: AtomMask) ~= 0</body><body package="MIME" selector="isCommentChar:">isCommentChar: char	^[ ((self classificationMaskFor: char) bitAnd: CommentMask) ~= 0	] on: NonASCIICharException	do: [ :ex | true ]</body><body package="MIME" selector="shouldBeQuoted:">shouldBeQuoted: string 		^[(string detect: [:char | (self isAtomChar: char) not] ifNone: [nil]) 		notNil] 			on: NonASCIICharException			do: [:ex | true ]</body></methods><methods><class-id>Net.CollectionField</class-id> <category>accessing</category><body package="MIME" selector="separator">separator	separator isNil 		ifTrue: [ separator := self class defaultSeparator].	^separator</body><body package="MIME" selector="separator:">separator: aSymbol	separator := aSymbol</body><body package="MIME" selector="value">value	^value isNil		ifTrue: [ value := OrderedCollection new]		ifFalse: [value]</body><body package="MIME" selector="value:">value: aStringOrCollection	(aStringOrCollection isKindOf: String)		ifTrue: [ self value add: aStringOrCollection]		ifFalse: [ self value addAll: aStringOrCollection]</body></methods><methods><class-id>Net.CollectionField</class-id> <category>printing</category><body package="MIME" selector="printValueOn:">printValueOn: aStream 	self value  		do: [ :param |  aStream nextPutAll: param ]		separatedBy: [aStream nextPut: self separator].	aStream cr.</body></methods><methods><class-id>Net.CollectionField</class-id> <category>parsing</category><body package="MIME" selector="doParse:">doParse: scanner	| coll stream |	coll := OrderedCollection new. 	stream := (String new: 32) writeStream.	[scanner skipWhiteSpace.	scanner nextToken. 	scanner tokenType = #doIt ]		whileFalse: 			[ scanner token ~~ self separator				ifTrue: 					[scanner 						printToken: scanner token 						tokenType: scanner tokenType 						on: stream].			(scanner atEnd or: [scanner token == self separator])				ifTrue: 					[ coll add: (self parseItem: stream contents).					stream := (String new: 20) writeStream]]. 	stream contents notEmpty ifTrue: [ coll add: (self parseItem: stream contents)].	^coll</body><body package="MIME" selector="parseItem:">parseItem: aString	^aString</body></methods><methods><class-id>Net.CollectionField class</class-id> <category>defaults</category><body package="MIME" selector="defaultSeparator">defaultSeparator	^$,</body></methods><methods><class-id>Net.CollectionField class</class-id> <category>instant creation</category><body package="MIME" selector="name:value:">name: nameString value: stringOrCollection	^( self name: nameString)		value: stringOrCollection;		yourself</body></methods><methods><class-id>Net.CollectionField class</class-id> <category>parsing</category><body package="MIME" selector="fieldNames">fieldNames	^#('accept-encoding' 'allow' 'accept-ranges' 'if-match' 'if-none-match' 'public' 'connection' )</body></methods><methods><class-id>Net.MimeEncodedWordCoDec</class-id> <category>parsing</category><body package="MIME" selector="decode:">decode: word 	^self class decode: word</body><body package="MIME" selector="decodeComment:">decodeComment: text 	| output word params spaces lastParams lastWord |	" First, quick check if we possibly have an encoded word "	(text indexOfSubCollection: '=?' startingAt: 1)		= 0 ifTrue: [^text].	"We suspect there might be an encoded word inside, do the legwork"	self on: text readStream.	output := (String new: text size) writeStream.	spaces := String new.	params := lastWord := nil.		[lastParams := params.	self atEnd]		whileFalse: 			[word := self scanWhile: [(self matchCharacterType: WhiteSpaceMask) not].			params := self class encodingParametersOf: word.			(lastWord notNil and: [params isNil or: [lastParams isNil]])				ifTrue: [output nextPutAll: spaces].			output nextPutAll: (lastWord := self class decode: word using: params).			spaces := self scanWhile: [self matchCharacterType: WhiteSpaceMask]].	^output contents</body><body package="MIME" selector="decodePhrase:">decodePhrase: words	^self class decodePhrase: words</body><body package="MIME" selector="decodeText:">decodeText: text " Decoding of text is similar to decoding of comment, but RFC2047 requires that an encoded word that appears in in *text token MUST be separated from any adjacent encoded word or text by a linear-white-spaceRFC 2047:  When displaying a particular header field that contains multiple 'encoded-word's, any 'linear-white-space' that separates a pair of adjacent 'encoded-word's is ignored.  (This is to allow the use of multiple 'encoded-word's to represent long strings of unencoded text,  without having to separate 'encoded-word's where spaces occur in the  unencoded text.)"	| output word arr spaces |	" First, quick check if we possibly have an encoded word "	(text indexOfSubCollection: '=?' startingAt: 1) = 0 		ifTrue: [^text].		"We suspect there might be an encoded word inside, do the legwork"	self on: text readStream.	output := (String new: text size) writeStream.	spaces := String new.	[self atEnd]		whileFalse: 			[ word := self scanWhile: [(self matchCharacterType: WhiteSpaceMask) not]. 			(arr := self encodingParametersOf: word) == nil				ifTrue: 					[spaces size &gt; 0  ifTrue: [ output nextPutAll: spaces].					output 						nextPutAll: word;						nextPutAll: (self scanWhile: [self matchCharacterType: WhiteSpaceMask]) ]				ifFalse: 					[output nextPutAll: 						( self class							decodeEncodedWord: (arr at: 3)							charset: arr first							encoding: (arr at: 2) ).					spaces := self scanWhile: [self matchCharacterType: WhiteSpaceMask]]]. 	^output contents</body><body package="MIME" selector="encodingParametersOf:">encodingParametersOf: word 	^self class encodingParametersOf: word</body></methods><methods><class-id>Net.MimeEncodedWordCoDec class</class-id> <category>encoding</category><body package="MIME" selector="encode:asBase64Using:">encode: string asBase64Using: wordEncoding	|  quoted |	^self 		getEncodedWordDo: 			[ :stream |			quoted := (String new: 256) writeStream.			MimeScanner 				encode: (string asByteArrayEncoding: wordEncoding) asString readStream 				asBase64To: quoted. 			stream  nextPutAll: quoted contents ]		charset: wordEncoding 		encoding: 'B'</body><body package="MIME" selector="encode:asQuotedPrintableUsing:">encode: string asQuotedPrintableUsing: wordEncoding	| quoted c |	^self 		getEncodedWordDo: 			[ :stream |			quoted := (String new: 256) writeStream.			MimeScanner 				encode: (string asByteArrayEncoding: wordEncoding) asString readStream 				asQuotedPrintableTo: quoted.			quoted :=  quoted contents.			(c := quoted first) = $" ifFalse: [stream nextPut: c].			stream  nextPutAll: (quoted copyFrom: 2 to: quoted size) ]		charset: wordEncoding 		encoding: 'Q'</body><body package="MIME" selector="encodeComment:asBase64Using:">encodeComment: aString asBase64Using: anEncodingString	^'(' , (self encodeText: aString asBase64Using: anEncodingString) , ')'</body><body package="MIME" selector="encodeComment:asQuotedPrintableUsing:">encodeComment: aString asQuotedPrintableUsing: anEncodingString"Encoding *text token separated from any adjacent encoded word or text by a linear-white-space"	| result tokens encodedString |	^self 		encodeIfRequired: aString 		using: anEncodingString		do: 			[ :encoding | 			encodedString := self encode: aString asQuotedPrintableUsing: encoding.			result := (String new: 256) writeStream.			result nextPut: $(.			tokens := encodedString tokensBasedOn: Character space.			tokens do: [ :token |  result nextPutAll: token,  '=20' ].			^(result contents copyFrom: 1 to: result contents size - 3), ')' ]</body><body package="MIME" selector="encodeIfRequired:">encodeIfRequired: string 	^self encodeIfRequired: string using: nil</body><body package="MIME" selector="encodeIfRequired:using:">encodeIfRequired: string using: anEncoding	^self 		encodeIfRequired: string 		using: anEncoding 		do: [ :encoding | self encode: string asQuotedPrintableUsing: encoding]</body><body package="MIME" selector="encodeIfRequired:using:do:">encodeIfRequired: string using: anEncoding do: aBlock	| wordEncoding |	wordEncoding := (anEncoding == nil		ifTrue: [(self findEncodingFor: string) asString]		ifFalse: [ anEncoding ]).	('us-ascii' match: wordEncoding) ifTrue: [ ^string].	^wordEncoding notNil 		ifTrue: [aBlock value: wordEncoding  ]		ifFalse: [string]</body><body package="MIME" selector="encodeText:asBase64Using:">encodeText: aString asBase64Using: anEncodingString"Encoding *text token separated from any adjacent encoded word or text by a linear-white-space"	| result tokens stream contents |	^self 		encodeIfRequired: aString 		using: anEncodingString		do: 			[ :encoding | 			result := (String new: 256) writeStream.			tokens := OrderedCollection new.			aString size &gt; 44				ifTrue: 					[stream := aString readStream.					[stream atEnd ]									whileFalse: 							[ tokens add: ( stream next: 44 ). 							stream position + 44 &gt; aString size								ifTrue: [ tokens add: stream upToEnd]]]				ifFalse: [ tokens add: aString].				tokens 					do: [ :token | 						result nextPutAll: (self encode: token asBase64Using: encoding).						result cr; tab. ].				contents := result contents. 				contents copyFrom: 1 to: contents size - 2. ]</body><body package="MIME" selector="encodeText:asQuotedPrintableUsing:">encodeText: aString asQuotedPrintableUsing: anEncodingString"Encoding *text token separated from any adjacent encoded word or text by a linear-white-space"	| result contents |	^self 		encodeIfRequired: aString 		using: anEncodingString		do: 			[ :encoding | 			result := (String new: 256) writeStream.			aString 				piecesCutWhere: [:each :next | each = Character space ] 				do: [ :each | 					(self encode: each asQuotedPrintableUsing: encoding)						do: [ :ch |							ch ~= Character space								ifTrue: [ result nextPut: ch]								ifFalse: [result nextPutAll: '=20' ]].					result nextPut: Character space]. 			contents := result contents.			contents copyFrom: 1 to: contents size -1  ]</body><body package="MIME" selector="getEncodedWordDo:charset:encoding:">getEncodedWordDo: aBlock charset: charset encoding: aString	| result |	result := (String new: 256)  writeStream. 	result 		nextPutAll: '=?';		nextPutAll: charset;		nextPutAll: '?';		nextPutAll: aString;		nextPutAll: '?'.	aBlock value: result.	result nextPutAll: '?='.	^result contents</body></methods><methods><class-id>Net.MimeEncodedWordCoDec class</class-id> <category>decoding</category><body package="MIME" selector="decode:">decode: word 	^self decode: word using: (self encodingParametersOf: word).</body><body package="MIME" selector="decode:using:">decode: word using: arr 	^arr notNil		ifTrue: [self				decodeEncodedWord: (arr at: 3)				charset: arr first				encoding: (arr at: 2)]		ifFalse: [word]</body><body package="MIME" selector="decodeComment:">decodeComment: commentString	^self new decodeComment: commentString</body><body package="MIME" selector="decodeEncodedWord:charset:encoding:">decodeEncodedWord: contents charset: charset encoding: encodingString	| encoding outStream string | 	encoding := encodingString asLowercase.	(#('b' base64) includes: encoding) 		ifTrue: " Decode into bytes, then impose desired charset encoding on the result "			[outStream := (ByteArray new: contents size * 2 // 3 + 1) writeStream.			MimeScanner decodeBase64From: contents readStream to: outStream.			^(outStream contents 				withEncoding: charset) 				readStream contents].	(#('q' 'quoted-printable') includes: encoding) 		ifTrue: 			["RFC2047 (2) The 8-bit hexadecimal value 20 (e.g., ISO-8859-1 SPACE) may be		       represented as '_' (underscore, ASCII 95.).  "			string := contents copyReplaceAll: '_' with: (String with: (Character value: 16r20)). 			^((MimeScanner decodeQuotedPrintableFrom: string readStream)				asByteArray withEncoding: charset) readStream contents ].	(#('uue' 'uuencode' 'x-uue' 'x-uuencode') includes: encoding)		ifTrue: [^MimeScanner 				decodeUUEncodedFrom: 1				to: contents size				in: contents].	^nil.									" Failed to decode "</body><body package="MIME" selector="decodePhrase:">decodePhrase: words" decode phrase word by word; concatenate decoded words and answer concatenated string "	| output |	output := (String new: words size) writeStream.	self decodePhrase: words printOn: output.	^output contents</body><body package="MIME" selector="decodePhrase:printOn:">decodePhrase: words printOn: stream 	| params lastParams lastWord |	lastWord := nil. 	params := nil.	words do: 		[:word | 			lastParams := params.			params := self encodingParametersOf: word.			(lastWord notNil and: [params isNil or: [lastParams isNil]])				ifTrue: [stream space].			stream nextPutAll: (lastWord := self decode: word using: params)].</body><body package="MIME" selector="decodeText:">decodeText: text 	^self new decodeText: text</body></methods><methods><class-id>Net.MimeEncodedWordCoDec class</class-id> <category>utility</category><body package="MIME" selector="encodingParametersOf:">encodingParametersOf: word 	| mark1 mark2 |	word isEmpty ifTrue: [^nil].	^(word first == $= and: [word last == $= and: 				[(word at: 2) == $? and: [(word at: word size - 1) == $? and: 				[(mark1 := word 	nextIndexOf: $? 	from: 3 to: word size - 2) &gt; 0 and: 				[(mark2 := word 	nextIndexOf: $? 	from: mark1 + 1 to: word size - 2) &gt; (mark1 + 1)]]]]])		ifTrue: [Array 					with: (word copyFrom: 3 to: mark1 - 1) asLowercase					with: (word copyFrom: mark1 + 1 to: mark2 - 1) asLowercase					with:  (word copyFrom: mark2 + 1 to: word size - 2)]		ifFalse: [nil ]</body><body package="MIME" selector="findEncodingFor:">findEncodingFor: aString 	(self shouldBeEncoded: aString) ifFalse: [^'us-ascii'].	AvailableEncodings == nil ifTrue: [ self initilizeAvalibleEncoding].	^AvailableEncodings 		detect: 			[:encoding | 				[aString asByteArrayEncoding: encoding. 				true] on: Error do: [:ex | false]]		ifNone: [].</body><body package="MIME" selector="initilizeAvalibleEncoding">initilizeAvalibleEncoding	AvailableEncodings := ((1 to: 15) collect: [:i | ('iso8859-' , i printString) asSymbol]) asOrderedCollection.	AvailableEncodings 		addFirst: #'us-ascii';		addLast: Locale current defaultEncoding;		addLast: #'utf-8'.	^AvailableEncodings</body></methods><methods><class-id>Net.MimeEncodedWordCoDec class</class-id> <category>testing</category><body package="MIME" selector="shouldBeEncoded:">shouldBeEncoded: aString	^(aString detect: [:char | char asInteger &gt; 128] ifNone: [nil]) ~~ nil</body></methods><methods><class-id>Net.ParsingSimpleBodyError class</class-id> <category>testing</category><body package="MIME" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>transfer encodings</category><body package="MIME" selector="addContentTransferEncoding:">addContentTransferEncoding: encodingNameString" Transfer-encode message. encodingNameString is one of: 'base64', 'quoted-printable', ... "	self contentTransferEncoding: encodingNameString.	self body encodeAs: encodingNameString.</body><body package="MIME" selector="removeContentTransferEncoding">removeContentTransferEncoding	"Transfer-encode message. encodingNameString is one of: 'base64', 'quoted-printable', ..."	self hasContentTransferEncoding		ifTrue: 			[self body decodeAs: self contentTransferEncoding asLowercase.			self removeFieldAt: 'content-transfer-encoding']</body><body package="MIME" selector="transferFieldOrder">transferFieldOrder" Answer fields that should appear in specific order during transfer "	^OrderedCollection new</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>accessing</category><body package="MIME" selector="body">body	^value isNil		ifTrue: [ value := self newBody ]		ifFalse: [ value ]</body><body package="MIME" selector="body:">body: aMessageBody	value := aMessageBody.	aMessageBody parent: self.</body><body package="MIME" selector="boundary">boundary	^self contentTypeField boundary</body><body package="MIME" selector="boundary:">boundary: aString	^self contentTypeField boundary: aString</body><body package="MIME" selector="builder">builder	^self defaultBuilderType new</body><body package="MIME" selector="charset">charset	^self charsetIfNone: 			[ self parent ~~ nil				ifTrue: [	self parent defaultCharset]				ifFalse: [ self defaultCharset] ]</body><body package="MIME" selector="charset:">charset: aName	self isSimple		ifTrue: [ (self getFieldAt: 'content-type') charset: aName ]</body><body package="MIME" selector="charsetIfNone:">charsetIfNone: aBlock	^self contentTypeField charsetIfNone: aBlock</body><body package="MIME" selector="contentEncoding">contentEncoding	"Http header. The message can be sent from HttpBuildHandler while building multipart message"	^nil</body><body package="MIME" selector="contentId">contentId	^self fieldValueAt: 'content-id'</body><body package="MIME" selector="contentId:">contentId: aString	self fieldValueAt: 'content-id' put: aString</body><body package="MIME" selector="contentLength">contentLength	^self fieldValueAt: 'content-length'</body><body package="MIME" selector="contentLength:">contentLength: anInteger	self fieldValueAt: 'content-length' put: anInteger</body><body package="MIME" selector="contentsSpecies">contentsSpecies" Answer ByteArray if I contain bytes, String if I containg character info. Notethat if content transfer encoding is present, it is always String. See also contentTypeSpecies "	^self isBinary		ifTrue: [ ByteArray ]		ifFalse: [ String ]</body><body package="MIME" selector="contentTransferEncoding">contentTransferEncoding	^self fieldValueAt: 'content-transfer-encoding'</body><body package="MIME" selector="contentTransferEncoding:">contentTransferEncoding: encodingNameString	self fieldValueAt: 'content-transfer-encoding'  put: encodingNameString</body><body package="MIME" selector="contentType">contentType	^(self fieldAt: 'content-type' ifAbsent: [ self defaultContentTypeField  ]) contentType</body><body package="MIME" selector="contentType:">contentType: aString	('text/plain' match: aString)		ifTrue: [self  contentType: aString charset: self defaultCharset ]		ifFalse: [self fieldAt: 'content-type' put: (ContentTypeField contentType: aString)]</body><body package="MIME" selector="contentType:charset:">contentType: aString charset: cString	self fieldAt: 'content-type' put: (ContentTypeField contentType: aString charset: cString)</body><body package="MIME" selector="contentTypeEncoding">contentTypeEncoding	" Answer symbolic name of the character encoding for the decoded body of this entity "	^self contentTypeEncodingType</body><body package="MIME" selector="contentTypeEncodingType">contentTypeEncodingType" Answer symbol representing character encoding that we use to decode the body of this entity. This encoding is entirely determined by the current content type field as follows:	If content type is text or multipart, then value of charset parameter is used		content-type: text/plain; charset = iso-8859-1	If no charset is present, default charset encoding is used	If content type is binary, binary encoding is used"	^self isBinaryContentType		ifTrue: [ #binary ]		ifFalse: [self charset notNil					ifTrue: [self charset]					ifFalse: [#default]]</body><body package="MIME" selector="contentTypeField">contentTypeField	^(self fieldAt: 'content-type' ifAbsent: [ self defaultContentTypeField ])</body><body package="MIME" selector="contentTypeSpecies">contentTypeSpecies" Answer ByteArray if my Mime type is binary, String otherwise. See also contentsSpecies "	^self isBinaryContentType		ifTrue: [ ByteArray ]		ifFalse: [ String ]</body><body package="MIME" selector="encoding">encoding	" Answer symbolic name of the character encoding for the body of this entity "	^self encodingType ~~ nil		ifTrue: [ self encodingType ]		ifFalse: [ MimeTypeDescriptor encodingForCharset: #default ]</body><body package="MIME" selector="encodingType">encodingType" Answer symbol representing character encoding that we use to read the body of this entity. This encoding depends on the current content type and content transfer encoding.If transfer encoding is not present, then encoding is determined by content-typefield as follows:	If content type is text or multipart, then value of charset parameter is used		content-type: text/plain; charset = iso-8859-1	If no charset is present, default charset encoding is used	If content type is binary, binary encoding is usedIf transfer encoding is present, default charset encoding is used"	^self isBinary		ifTrue: [ #binary ]		ifFalse: [self charsetIfNone: [#default]]</body><body package="MIME" selector="fields">fields	^self header fields</body><body package="MIME" selector="fields:">fields: aValue	self header fields: aValue</body><body package="MIME" selector="headerCharset">headerCharset"	headerCharset == nil		ifTrue: 			[headerCharset := 				( self charset ~~ nil					ifTrue: [ self charset ]					ifFalse: 						[self parent ~~ nil							ifTrue: [ self parent headerCharset ]							ifFalse: [ MimeTypeDescriptor defaultCharacterSet ]])]."	^headerCharset</body><body package="MIME" selector="headerCharset:">headerCharset: aString	headerCharset := aString</body><body package="MIME" selector="majorType">majorType	^self contentTypeField subtype</body><body package="MIME" selector="mimeType">mimeType	^MimeTypeDescriptor guessFromContentType: self contentType</body><body package="MIME" selector="mimeVersion">mimeVersion	^self fieldValueAt: 'mime-version'</body><body package="MIME" selector="mimeVersion:">mimeVersion: aString	self fieldValueAt: 'mime-version' put: aString</body><body package="MIME" selector="subtype">subtype	^self contentTypeField subtype</body><body package="MIME" selector="type">type	^self contentTypeField type</body><body package="MIME" selector="type:">type: aString	^self contentTypeField type: aString</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>content-disposition</category><body package="MIME" selector="contentDisposition">contentDisposition	^self fieldAt: 'content-disposition' ifAbsent: [nil]</body><body package="MIME" selector="contentDisposition:">contentDisposition: aString" aString should be 'inline' or 'attachment' "	(self getFieldAt: 'content-disposition') disposition: aString</body><body package="MIME" selector="contentDispositionSize">contentDispositionSize	^(self fieldAt: 'content-disposition' ifAbsent: [^nil]) size</body><body package="MIME" selector="contentDispositionSize:">contentDispositionSize: anInteger	(self getFieldAt: 'content-disposition') size: anInteger</body><body package="MIME" selector="fileName">fileName	| headerField f |	headerField := self 					fieldAt: 'content-disposition' 					ifAbsent: [self fieldAt: 'content-type' ifAbsent:[^nil]].	^((f := headerField fileName) isNil or: [ f isEmpty])		ifTrue: [ nil ]		ifFalse: [ f ]</body><body package="MIME" selector="fileName:">fileName: aString	(self getFieldAt: 'content-type')  fileName: aString. "For eudora"	^(self getFieldAt: 'content-disposition') fileName: aString</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>presentation</category><body package="MIME" selector="edit">edit	self editor openWith: self</body><body package="MIME" selector="editor">editor	^ (self class editorTypesAt: self contentType) new</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>testing</category><body package="MIME" selector="canBeDecoded">canBeDecoded	^self contentTransferEncoding isNil</body><body package="MIME" selector="hasBoundary">hasBoundary	^self boundary notNil</body><body package="MIME" selector="hasContentTransferEncoding">hasContentTransferEncoding	^self contentTransferEncoding notNil</body><body package="MIME" selector="isApplication">isApplication	^ self type match: 'application'</body><body package="MIME" selector="isBase64Type">isBase64Type	^self contentTransferEncoding notNil		ifTrue: [ self contentTransferEncoding match: 'base64']		ifFalse: [ false ]</body><body package="MIME" selector="isBinary">isBinary" Answers true if my contents are represented as text or binary. If contenttransfer encoding is present, my contents are text even though this textencodes binary information "	^self isBinaryContentType and: [self hasContentTransferEncoding not]</body><body package="MIME" selector="isBinaryContentType">isBinaryContentType	^self mimeType isBinary</body><body package="MIME" selector="isHtmlText">isHtmlText	^ self isTextContentType and: [self subtype = 'html' ]</body><body package="MIME" selector="isMultipart">isMultipart	^self contentTypeField isMultipart</body><body package="MIME" selector="isMultipartAlternative">isMultipartAlternative	^self contentType match: 'multipart/alternative'</body><body package="MIME" selector="isMultipartMixed">isMultipartMixed	^self contentType match: 'multipart/mixed'</body><body package="MIME" selector="isPlainText">isPlainText	^ self isTextContentType and: [ self subtype = 'plain' ]</body><body package="MIME" selector="isPrintedQuotableType">isPrintedQuotableType	^self contentTransferEncoding notNil		ifTrue: [ self contentTransferEncoding match: 'quoted-printable' ]		ifFalse: [ false ]</body><body package="MIME" selector="isSimple">isSimple	^self isMultipart not</body><body package="MIME" selector="isText">isText" Answers true is message body contains binary data. This method willalways answer true in the presence of content transfer encoding. See alsoisTextContentType "	^ self isBinary not</body><body package="MIME" selector="isTextContentType">isTextContentType" Answers true is message content type corresponds to binary data. See alsoisText "	^ self mimeType isText</body><body package="MIME" selector="needsBoundary">needsBoundary	^self isMultipart and: [self boundary isNil]</body><body package="MIME" selector="needsContentLength">needsContentLength	^false</body><body package="MIME" selector="needsContentTransferEncoding">needsContentTransferEncoding	^self hasContentTransferEncoding not and: [self body needsContentTransferEncoding]</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>copying</category><body package="MIME" selector="postCopy">postCopy	super postCopy.	header := header copy parent: self.	value := value copy parent: self.</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>mutating</category><body package="MIME" selector="replaceFrom:">replaceFrom: replacementPart" Replace your guts from another entity. Copy all the fields into yourselfreplacing your own fields if same name. Replace your own body withthe replacement entity's body "	" Merge fields from the replacement part into the message "	replacementPart fields do: [ :field | self fieldAt: field name put: field ].	self body: replacementPart body</body><body package="MIME" selector="replacePart:with:">replacePart: originalPart with: replacementPart	| index |	index := self parts indexOf: originalPart.	index = 0 ifTrue: [ ^self error: (#OriginalPartNotFound &lt;&lt; #net &gt;&gt; 'Original part not found') ].	self partAt: index put: replacementPart</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>composing</category><body package="MIME" selector="writeContentsOn:">writeContentsOn: anEncodedStream	^self body writeContentsOn: anEncodedStream</body><body package="MIME" selector="writeOn:">writeOn: aStream	self printer writeMessage: self on: aStream</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>printing</category><body package="MIME" selector="displayString">displayString"For presenter to display something useful in place of the entity contents.For text entity this is simply entity contents, but for binary entities only a shortdigest is shown"	| stream |	stream := (String new: 128) writeStream.	self printForDisplayOn: stream.	^stream contents</body><body package="MIME" selector="printer">printer	^self defaultPrinterType new</body><body package="MIME" selector="printForDisplayOn:">printForDisplayOn: stream"For presenter to display something useful in place of the entity contents.For text entity this is simply entity contents, but for binary entities only a shortdigest is shown"	self body printForDisplayOn: stream</body><body package="MIME" selector="printHeaderOn:">printHeaderOn: aStream	self printer printMessageElement: self header on: aStream</body><body package="MIME" selector="printOn:indent:">printOn: aStream indent: level	self printer printMessage: self on: aStream indent: level.</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>defaults</category><body package="MIME" selector="defaultBot">defaultBot	^self defaultBotClass new</body><body package="MIME" selector="defaultBotClass">defaultBotClass	^MimeEntityBot</body><body package="MIME" selector="defaultBuilderType">defaultBuilderType	^self class defaultBuilderType</body><body package="MIME" selector="defaultCharset">defaultCharset	^self class defaultCharset</body><body package="MIME" selector="defaultContentDispositionField">defaultContentDispositionField	^ContentDispositionField default</body><body package="MIME" selector="defaultContentType">defaultContentType" Answer default content type string. Use Mime rules, subclasses may override "	^self parent notNil		ifTrue: [ self parent defaultContentTypeForParts ]		ifFalse: [ MimeTypeDescriptor defaultContentTypeString ]</body><body package="MIME" selector="defaultContentTypeField">defaultContentTypeField" Answer default content-type field "	^ContentTypeField contentType: self defaultContentType charset: self defaultCharset</body><body package="MIME" selector="defaultContentTypeForParts">defaultContentTypeForParts" Answer default content-type field for body parts in multipart message. This method uses Mime rules. It can be overridden, i.e. for HTTP. Mime specifies that the default content-type is text/plain; charset = 'us-ascii' except in multipart/digest entities where the default content-type is message/rfc822 "	^self contentType ~= MimeTypeDescriptor contentTypeMultipartDigest		ifTrue: [ MimeTypeDescriptor defaultContentTypeString ]		ifFalse: [ MimeTypeDescriptor contentTypeMessageRfc822 ]</body><body package="MIME" selector="defaultPrinterType">defaultPrinterType	^self class defaultPrinterType</body><body package="MIME" selector="defaultTransferEncodingName">defaultTransferEncodingName" Answer default transfer encoding for this entity. Somewhat arbitrarily we use quoted-printablefor text entities (which assumes we have largely ASCII-based text, saving space), and base64for everything else (because it is most likely binary data, so base64 is more appropriate "	^self isTextContentType		ifTrue: [ 'quoted-printable' ]		ifFalse: [ 'base64' ]</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>parsing</category><body package="MIME" selector="parse:">parse: rfc822Scanner 	^self builder parse: self from: rfc822Scanner</body><body package="MIME" selector="parseBody:">parseBody: rfc822Scanner 	^self builder parseBody: self from: rfc822Scanner</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>visiting</category><body package="MIME" selector="acceptVisit:with:">acceptVisit: aVisitor with: argument	^aVisitor acceptMimeEntity: self with: argument</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>mime version</category><body package="MIME" selector="addMimeVersion">addMimeVersion	self mimeVersion: '1.0'</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>accessing fields and body parts</category><body package="MIME" selector="fieldValueAt:ifAbsent:">fieldValueAt: fieldName ifAbsent: aBlock	^(self fieldAt: fieldName ifAbsent: [ ^aBlock value ]) value</body><body package="MIME" selector="getFieldAt:">getFieldAt: aString" Make sure we have either field or its stub so we can put real value in it. Default implementationof #default in HeaderField just creates a new instance of the field. Some subclasses overridethis method to provide more specific stub creation "	^self header 		at: aString 		ifAbsentPut: [(HeaderField fieldClassForName: aString) default name: aString].</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>accessing fields</category><body package="MIME" selector="addField:">addField: field	" This method will check if the field exists already; if yes, if it can be merged into the existing field and, if yes, merge it. Otherwise, add as a new field "	" Implement field merge"	self header add: field.</body><body package="MIME" selector="arrangeFieldsInOrder:">arrangeFieldsInOrder: anArrayOfFieldNames	self header arrangeFieldsInOrder: anArrayOfFieldNames</body><body package="MIME" selector="fieldAt:">fieldAt: aString	^self header at: aString</body><body package="MIME" selector="fieldAt:ifAbsent:">fieldAt: aString ifAbsent: aNiladicBlock	^self header at: aString ifAbsent: aNiladicBlock</body><body package="MIME" selector="fieldAt:ifAbsentPut:">fieldAt: aString ifAbsentPut: aNiladicBlock 	^self header at: aString ifAbsentPut: aNiladicBlock</body><body package="MIME" selector="fieldAt:put:">fieldAt: aString put: field	^self header at: aString put: field</body><body package="MIME" selector="fieldsAt:">fieldsAt: aString" Answer all fields with specified names in their order of appearance "	^self header allAt: aString</body><body package="MIME" selector="fieldValueAt:">fieldValueAt: fieldName" Answer value of specified field or nil "	^self fieldValueAt: fieldName ifAbsent: [ nil ]</body><body package="MIME" selector="fieldValueAt:put:">fieldValueAt: fieldName put: aValue" Ensures at least field's placeholder exists and sets field's value "	^(self getFieldAt: fieldName ) value: aValue</body><body package="MIME" selector="fieldValuesAt:">fieldValuesAt: aString" Answer all fields with specified names in their order of appearance "	^(self fieldsAt: aString)		inject: OrderedCollection new into: [ :list :field | list addAll: field values. list ]</body><body package="MIME" selector="getValueFor:">getValueFor: fieldName	^self getValueFor: fieldName ifAbsent: [ nil ]</body><body package="MIME" selector="getValueFor:ifAbsent:">getValueFor: fieldName ifAbsent: aBlock" For compatibility only "	^self fieldValueAt: fieldName ifAbsent: [ ^aBlock value ]</body><body package="MIME" selector="header">header	^header isNil		ifTrue: [ header := self newHeader ]		ifFalse: [ header ]</body><body package="MIME" selector="header:">header: aMessageHeader	header := aMessageHeader.	header parent: self</body><body package="MIME" selector="indexOfField:">indexOfField: aField	^self header indexOf: aField</body><body package="MIME" selector="indexOfFieldNamed:">indexOfFieldNamed: aFieldName	^self header indexOf: (self fieldAt: aFieldName ifAbsent: [^0])</body><body package="MIME" selector="newHeader">newHeader	^MessageHeader newFor: self</body><body package="MIME" selector="removeField:">removeField: aHeaderField" Remove header field "	^self header remove: aHeaderField</body><body package="MIME" selector="removeFieldAt:">removeFieldAt: fieldName" Remove field with specified name "	^self header removeKey: fieldName</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>accessing body parts</category><body package="MIME" selector="addPart:">addPart: part	part parent: self.	self body addPart: part.</body><body package="MIME" selector="contents">contents	^self body value</body><body package="MIME" selector="contents:">contents: aString	^self body value: aString</body><body package="MIME" selector="contentsStream">contentsStream	^self body valueAsStream</body><body package="MIME" selector="decodedContents">decodedContents	^self body decodedValue</body><body package="MIME" selector="decodedContentsWith:">decodedContentsWith: aSymbol	^self body decodedValueWith: aSymbol</body><body package="MIME" selector="indexOfPart:">indexOfPart: aPart	^self parts indexOf: aPart</body><body package="MIME" selector="newBody">newBody	^MimeMessageBody newBodyFor: self</body><body package="MIME" selector="partAt:">partAt: index	^self parts at: index</body><body package="MIME" selector="partAt:put:">partAt: index put: aPart	self parts at: index put: aPart</body><body package="MIME" selector="parts">parts	^ self body parts</body><body package="MIME" selector="removePart:">removePart: aMimeEntity	^self body removePart: aMimeEntity</body><body package="MIME" selector="removePartAt:">removePartAt: index	^self body removePartAt: index</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>private</category><body package="MIME" selector="bot">bot	^self defaultBot</body><body package="MIME" selector="hasByteSource">hasByteSource	^false</body></methods><methods><class-id>Net.MimeEntity class</class-id> <category>constants</category><body package="MIME" selector="contentLengthFieldName">contentLengthFieldName	^'content-length'</body><body package="MIME" selector="contentTypeFieldName">contentTypeFieldName	^'content-type'</body></methods><methods><class-id>Net.MimeEntity class</class-id> <category>presentation</category><body package="MIME" selector="defaultEditorType">defaultEditorType	^SinglePartPresenter</body><body package="MIME" selector="editor">editor</body><body package="MIME" selector="editorTypes">editorTypes	^EditorRegistry</body><body package="MIME" selector="editorTypesAt:">editorTypesAt: aType 	^self editorTypes at: aType ifAbsent: [ self defaultEditorType ]</body></methods><methods><class-id>Net.MimeEntity class</class-id> <category>class initialization</category><body package="MIME" selector="initialize">initialize	"MimeEntity initialize"	(EditorRegistry := Dictionary new)		at: 'text/plain' put: SinglePartPresenter."		at: 'text/html' put: 	"</body></methods><methods><class-id>Net.MimeEntity class</class-id> <category>instance creation</category><body package="MIME" selector="fileName:">fileName: fileNameOrString	" self fileName: 'ftp.st' "	| stream |	stream := fileNameOrString asFilename readStream lineEndTransparent.	^[self source: stream.] ensure: [ stream close ]</body><body package="MIME" selector="mimeTypeForFile:">mimeTypeForFile: fileName	^MimeTypeDescriptor guessFromExtension: fileName asFilename extension</body><body package="MIME" selector="newTextHTML">newTextHTML	" self newTextHTML "	^self new		contentType: MimeTypeDescriptor contentTypeHtml; 		charset: self defaultCharset;		yourself.</body><body package="MIME" selector="newTextPlain">newTextPlain	" self newTextPlain "	^self new		contentType: MimeTypeDescriptor contentTypePlainText; 		charset: self  defaultCharset;		yourself.</body><body package="MIME" selector="source:">source: aStream" Construct new simple Mime entity conaining specified streamExample:	self source: 'ftp.st' asFilename readStream lineEndTransparent "	^self stream: aStream</body><body package="MIME" selector="stream:">stream: aStream" Construct new simple Mime entity containing specified streamExample:	self stream: 'ftp.st' asFilename readStream lineEndTransparent "	| entity |	entity := self new. 	(aStream respondsTo: #fileName) 		ifTrue: [entity fileName: aStream fileName tail;					contentType: (self mimeTypeForFile: aStream fileName)].	^entity		body: (self simpleBody new source: aStream);		yourself</body></methods><methods><class-id>Net.MimeEntity class</class-id> <category>parsing</category><body package="MIME" selector="builder">builder	^self defaultBuilderType new</body><body package="MIME" selector="parse:">parse: rfc822Scanner 	^self builder parse: rfc822Scanner</body><body package="MIME" selector="printer">printer	^self defaultPrinterType new</body><body package="MIME" selector="readFrom:">readFrom: aStream	^self builder readFrom: aStream</body><body package="MIME" selector="readHeaderFrom:">readHeaderFrom: stream	^self builder readHeaderFrom: stream</body><body package="MIME" selector="scannerType">scannerType	^MimeScanner</body></methods><methods><class-id>Net.MimeEntity class</class-id> <category>documentation</category><body package="MIME" selector="syntaxOfMultiPartMimeBodies">syntaxOfMultiPartMimeBodies" From RFC 2046: Media Types                  November 1996   The Content-Type field for multipart entities requires one parameter,   'boundary'. The boundary delimiter line is then defined as a line   consisting entirely of two hyphen characters ($-, decimal value 45)   followed by the boundary parameter value from the Content-Type header   field, optional linear whitespace, and a terminating CRLF.   WARNING TO IMPLEMENTORS:  The grammar for parameters on the Content-   type field is such that it is often necessary to enclose the boundary   parameter values in quotes on the Content-type line.  This is not   always necessary, but never hurts. Implementors should be sure to   study the grammar carefully in order to avoid producing invalid   Content-type fields.  Thus, a typical 'multipart' Content-Type header   field might look like this:     Content-Type: multipart/mixed; boundary=gc0p4Jq0M2Yt08j34c0p   But the following is not valid:     Content-Type: multipart/mixed; boundary=gc0pJq0M:08jU534c0p   (because of the colon) and must instead be represented as     Content-Type: multipart/mixed; boundary=""gc0pJq0M:08jU534c0p""   This Content-Type value indicates that the content consists of one or   more parts, each with a structure that is syntactically identical to   an RFC 822 message, except that the header area is allowed to be   completely empty, and that the parts are each preceded by the line     --gc0pJq0M:08jU534c0p   The boundary delimiter MUST occur at the beginning of a line, i.e.,   following a CRLF, and the initial CRLF is considered to be attached   to the boundary delimiter line rather than part of the preceding   part.  The boundary may be followed by zero or more characters of   linear whitespace. It is then terminated by either another CRLF and   the header fields for the next part, or by two CRLFs, in which case   there are no header fields for the next part.  If no Content-Type   field is present it is assumed to be 'message/rfc822' in a   'multipart/digest' and 'text/plain' otherwise.   NOTE:  The CRLF preceding the boundary delimiter line is conceptually   attached to the boundary so that it is possible to have a part that   does not end with a CRLF (line  break).  Body parts that must be   considered to end with line breaks, therefore, must have two CRLFs   preceding the boundary delimiter line, the first of which is part of   the preceding body part, and the second of which is part of the   encapsulation boundary."</body></methods><methods><class-id>Net.MimeEntity class</class-id> <category>defaults</category><body package="MIME" selector="defaultBuilderType">defaultBuilderType	^MessageBuildHandler</body><body package="MIME" selector="defaultCharset">defaultCharset	^MimeTypeDescriptor iso8859x1</body><body package="MIME" selector="defaultPrinterType">defaultPrinterType	^MessagePrintHandler</body><body package="MIME" selector="simpleBody">simpleBody	^SimpleBody</body></methods><methods><class-id>Net.MessageDispatcher</class-id> <category>accessing</category><body package="MIME" selector="handler">handler	^handler</body><body package="MIME" selector="handler:">handler: aMessageHandler	handler := aMessageHandler</body></methods><methods><class-id>Net.MessageDispatcher</class-id> <category>initialization</category><body package="MIME" selector="initialize">initialize</body></methods><methods><class-id>Net.MessageDispatcher</class-id> <category>actions</category><body package="MIME" selector="action:with:">action: aSymbol with: argument1	^self handler notNil		ifTrue: [self handler action: aSymbol with: argument1]</body><body package="MIME" selector="action:with:with:">action: aSymbol with: argument1 with: argument2	^self handler notNil		ifTrue: [self handler action: aSymbol with: argument1 with: argument2]</body></methods><methods><class-id>Net.MessageDispatcher</class-id> <category>visiting -- double dispatching</category><body package="MIME" selector="acceptHeaderField:with:">acceptHeaderField: aHeaderField with: argument	^aHeaderField</body><body package="MIME" selector="acceptMessageHeader:with:">acceptMessageHeader: aMessageHeader with: argument	[(self action: #startHeader: with: aMessageHeader) 		ifTrue: [aMessageHeader fieldsDo: [ :field | self visit: field ]]]		ensure: [self action: #endHeader: with: aMessageHeader].	^aMessageHeader</body><body package="MIME" selector="acceptMimeEntity:with:">acceptMimeEntity: aMimeEntity  with: argument	[(self action: #startEntity: with: aMimeEntity) ifTrue: 		[self visit: aMimeEntity header;			visit: aMimeEntity body]]		ensure: [self action: #endEntity: with: aMimeEntity].	^aMimeEntity</body><body package="MIME" selector="acceptMultipartBody:with:">acceptMultipartBody: aMultipartBody with: argument	[(self action: #startBody: with: aMultipartBody) 		ifTrue: 			[aMultipartBody parts do: 				[ :part | 					[(self action: #startBodyPart: with: part)						ifTrue: [self visit: part]]				ensure: [self action: #endBodyPart: with: part]]]]		ensure: [self action: #endBody: with: aMultipartBody].	^aMultipartBody</body><body package="MIME" selector="acceptRFC822Entity:with:">acceptRFC822Entity: anRFC822Message with: argument" Default behavior is the same as of RFC822 message's superclass "	^self acceptMimeEntity: anRFC822Message with: argument</body><body package="MIME" selector="acceptSimpleBody:with:">acceptSimpleBody: aSimpleBody  with: argument	| aStream |	[(self action: #startBody: with: aSimpleBody) 		ifTrue: 			[[ aStream := self action: #getSimpleBodyStream: with: aSimpleBody.			self action: #startBodyStream: with: aStream]				ensure: 	[ aStream ~~nil ifTrue: [ aStream close ]]]]		ensure: [self action: #endBody: with: aSimpleBody].	^aSimpleBody</body></methods><methods><class-id>Net.MessageDispatcher</class-id> <category>visiting</category><body package="MIME" selector="visit:">visit: aMessageElement 	self visit: aMessageElement with: nil</body><body package="MIME" selector="visit:with:">visit: aMessageElement with: argument	^aMessageElement notNil 		ifTrue: [aMessageElement acceptVisit: self with: argument]		ifFalse: [nil]</body></methods><methods><class-id>Net.MessageDispatcher class</class-id> <category>instance creation</category><body package="MIME" selector="handler:">handler: aMessageHandler	^self new		handler: aMessageHandler</body><body package="MIME" selector="new">new	^super new initialize</body></methods><methods><class-id>Net.MessageParser</class-id> <category>parsing</category><body package="MIME" selector="parse:">parse: rfc822Scanner	| header entity |	self initialize.	self action: #startEntity: with: nil.	header := self action: #startHeader: with: nil.	self parseHeader: header from: rfc822Scanner.	entity := self action: #endHeader: with: header.	entity source: rfc822Scanner asStream.	self parseBody: entity body from: rfc822Scanner.	^self action: #endEntity: with: entity.</body><body package="MIME" selector="parseBody:from:">parseBody: body from: rfc822Scanner	| outStream  |	(self action: #startBody: with: body)		ifTrue: 			[rfc822Scanner source isInternal				ifTrue:					[outStream := rfc822Scanner source upToEnd asByteArrayEncoding: self encoder.			            rfc822Scanner source:  (outStream withEncoding: self encoder ) readStream.					rfc822Scanner source lineEndCR ].			"After parsing header fields the current position is looking at LF, skip it"			rfc822Scanner peekFor: Character lf. 			body isSimple				ifTrue: [self parseSimpleBody: body from: rfc822Scanner]				ifFalse: 	[self parseMultipartBody: body from: rfc822Scanner].			self action: #endBody: with: body].	^body</body><body package="MIME" selector="parseHeader:from:">parseHeader: header from: rfc822Scanner" Parse all fields. Add fields to specified header "	| field factory newEndPosition lastEndPosition |	lastEndPosition := 1.	newEndPosition := 0.	factory := self handler fieldFactory.	[(rfc822Scanner atEnd 		or: [(rfc822Scanner peekFor: Character cr) or: [rfc822Scanner peekFor: Character lf]]) 				or:[ lastEndPosition == newEndPosition]]		whileFalse: 			[lastEndPosition := rfc822Scanner position. 			self 				scanFieldFrom: rfc822Scanner				do: 	[:fieldStream |  					(field := factory readFrom: fieldStream) notNil 						ifTrue: 							[(field canMerge and: [(header at: field name) notNil])								ifTrue: [ (header at: field name) add: field]								ifFalse: [ header add: field]]].				newEndPosition := rfc822Scanner position. ]. 	^header</body><body package="MIME" selector="parseMultipartBody:from:">parseMultipartBody: aMultipartBody from: rfc82Scanner	" Build multipart body recursively "	aMultipartBody 		scanPartsFrom: rfc82Scanner 		useSourceStream: self useSourceStream		do: [ :sourceStream | | part |			self action: #startBodyPart: with: nil.			part := self parse: (self scannerOn: sourceStream).			self action: #endBodyPart: with: part.			part].</body><body package="MIME" selector="parseSimpleBody:from:">parseSimpleBody: body from: rfc822Scanner 	self action: #startBodyStream:length: with: rfc822Scanner asStream with: body contentLength</body><body package="MIME" selector="scannerOn:">scannerOn: aStream	^self handler scannerOn: aStream</body></methods><methods><class-id>Net.MessageParser</class-id> <category>visiting -- double dispatching</category><body package="MIME" selector="acceptMessageHeader:with:">acceptMessageHeader: aMessageHeader with: rfc822Scanner	[(self action: #startHeader: with: aMessageHeader) 		ifTrue: [self parseHeader: aMessageHeader from: rfc822Scanner]]		ensure: [self action: #endHeader: with: aMessageHeader].	^aMessageHeader</body></methods><methods><class-id>Net.MessageParser</class-id> <category>tasks</category><body package="MIME" selector="parseEntity:from:">parseEntity: aMimeEntity from: rfc822Scanner	| header entity body |		[self initialize.	self action: #startEntity: with: aMimeEntity.	header := aMimeEntity isNil		ifTrue: [MessageHeader new]		ifFalse: [aMimeEntity header].	self visit: header with: rfc822Scanner.	entity := self handler entity.	body := self visit: entity body with: rfc822Scanner]		ensure: [rfc822Scanner close].</body><body package="MIME" selector="readFrom:">readFrom: aStream	^self parse: (self scannerOn: aStream)</body></methods><methods><class-id>Net.MessageParser</class-id> <category>testing</category><body package="MIME" selector="useSourceStream">useSourceStream	^self handler useSourceStream</body></methods><methods><class-id>Net.MessageParser</class-id> <category>private</category><body package="MIME" selector="scanFieldFrom:do:">scanFieldFrom: rfc822Scanner do: aBlock	|  startPos endPos  fieldString fieldStream |	" Scan to the end of the field and stop before terminating CrLf "	startPos := rfc822Scanner position.	fieldString := rfc822Scanner nextLineWithoutTerminator.	endPos := rfc822Scanner position.	fieldStream := self useSourceStream					ifTrue: [ rfc822Scanner asStream from: startPos to: endPos ]					ifFalse: [ fieldString readStream ].	" Parse field using stream segment "	aBlock value: fieldStream.	rfc822Scanner 		position: endPos;		peekFor: Character cr;		peekFor: Character lf.			" Skip through CrLf "</body></methods><methods><class-id>Net.MessageParser</class-id> <category>defaults</category><body package="MIME" selector="encoder">encoder	^#UTF_8</body></methods><methods><class-id>Net.MessageParser class</class-id> <category>instance creation</category><body package="MIME" selector="readFrom:">readFrom: aStream	^self readFrom: aStream builder: self defaultBuilder</body><body package="MIME" selector="readFrom:builder:">readFrom: aStream builder: aMessageBuildHandler	^self new 		handler: aMessageBuildHandler;		readFrom: aStream</body></methods><methods><class-id>Net.MessageParser class</class-id> <category>builders</category><body package="MIME" selector="defaultBuilder">defaultBuilder	^self mailBuilder</body><body package="MIME" selector="mailBuilder">mailBuilder	^MessageBuildHandler new</body></methods><methods><class-id>Net.ValueWithParams</class-id> <category>accessing</category><body package="MIME" selector="groupSeparator">groupSeparator	^self separators last</body><body package="MIME" selector="paramAt:">paramAt: aString	^self paramAt: aString asLowercase ifAbsent: [ nil ]</body><body package="MIME" selector="paramAt:ifAbsent:">paramAt: aString ifAbsent: aBlock	^self params at: aString ifAbsent: [ aBlock value ]</body><body package="MIME" selector="paramAt:put:">paramAt: aName put: aValue	^self params at: aName put: aValue</body><body package="MIME" selector="parametersSeparator">parametersSeparator	^self separators at: 2</body><body package="MIME" selector="params">params	params isNil ifTrue: [ params := Dictionary new].	^params</body><body package="MIME" selector="removeParamAt:">removeParamAt: aName	^self params removeKey: aName ifAbsent: [nil]</body><body package="MIME" selector="separators">separators	^separators</body><body package="MIME" selector="separators:">separators: anArray	separators := anArray</body><body package="MIME" selector="value">value	^value</body><body package="MIME" selector="value:">value: aString	value := aString</body><body package="MIME" selector="valueSeparator">valueSeparator	^self separators first</body></methods><methods><class-id>Net.ValueWithParams</class-id> <category>composing</category><body package="MIME" selector="writeOn:encoding:">writeOn: aStream encoding: aString	self 		writeValueOn: aStream;		writeParamsOn: aStream encoding: aString.</body><body package="MIME" selector="writeParameter:on:encoding:">writeParameter: assoc on: aStream encoding: aString	| rfcString |	self class scannerType			printWord: assoc key on: aStream;			print: $= on: aStream.	assoc value ~~ nil		ifTrue: 			[(MimeEncodedWordCoDec shouldBeEncoded: assoc value)				ifTrue: 					[rfcString := MimeEncodedWordCoDec 									encodeText: assoc value 									asBase64Using: aString. 					aStream nextPut: $"; nextPutAll:  rfcString; nextPut: $" ]				ifFalse: [ self class scannerType printWord: assoc value on: aStream ]]</body><body package="MIME" selector="writeParamsOn:encoding:">writeParamsOn: aStream encoding: aString	(params ~~ nil and: [ params notEmpty])		ifTrue:			[aStream nextPut: self valueSeparator.			params associations				do: [ :assoc | self writeParameter: assoc on: aStream encoding: aString ]				separatedBy: [ aStream nextPut: self parametersSeparator ]]</body><body package="MIME" selector="writeValueOn:">writeValueOn: aStream	self printValueOn: aStream</body></methods><methods><class-id>Net.ValueWithParams</class-id> <category>parsing</category><body package="MIME" selector="addParameterNamed:value:">addParameterNamed: valString value: parString	self params 		at: valString 		put: parString</body><body package="MIME" selector="doParse:">doParse: scanner	" Canonical value removes all white space and comments from the source "	| str |	str := scanner scanUntil: 			[ scanner hereChar == self valueSeparator 				or: [ scanner hereChar == self groupSeparator] ].	^self  tokenizedValueFrom: (self scannerOn: str readStream).</body><body package="MIME" selector="finishParse">finishParse</body><body package="MIME" selector="parse:">parse: scanner	scanner skipWhiteSpace. 	self parseValue: scanner.	scanner atEnd ifTrue: [ ^self]. 	scanner hereChar ~~ self valueSeparator		ifTrue: [ scanner stepBack. ^self ].	self parseParameters: scanner.	self finishParse.</body><body package="MIME" selector="parseParameters:">parseParameters: scanner	| paramName |	scanner atEnd		ifFalse: 			[scanner 				tokenizeList: 					[(paramName := scanner nextToken) notNil						ifTrue:							[scanner skipWhiteSpace.							(self validateNextToken: scanner for: paramName)								ifFalse: [Transcript cr; show: (#DetectedMalformedField &lt;&lt; #net &gt;&gt; 'Detected malformed field:'); cr; show: scanner contents.  ^self ].  							self 								addParameterNamed: paramName asLowercase 								value: (self parseParamValueFrom: scanner) ]]				separatedBy: [scanner token == self parametersSeparator ]]</body><body package="MIME" selector="parseParamValueFrom:">parseParamValueFrom: scanner 	^self 		safelyExecuteParseParamValueFrom: scanner		do: [MimeEncodedWordCoDec decodeText: scanner nextToken]</body><body package="MIME" selector="parseValue:">parseValue: scanner	value := self doParse: scanner.</body><body package="MIME" selector="readFrom:">readFrom: aStream	^self parse: (self scannerOn: aStream)</body><body package="MIME" selector="scannerOn:">scannerOn: aStream	^self class scannerOn: aStream</body></methods><methods><class-id>Net.ValueWithParams</class-id> <category>private-utility</category><body package="MIME" selector="safelyExecuteParseParamValueFrom:do:">safelyExecuteParseParamValueFrom: scanner do: aBlock 	| startPos |	^	[	[startPos := scanner position.	aBlock value] on: Error			do: 				[:ex | 				| string |				scanner position: startPos.				string := scanner upToEnd.				NonASCIIFieldParamException raiseRequestFrom: string]] 			on: NonASCIIFieldParamException			do: [:ex | ex isNested ifTrue: [ex outer] ifFalse: [ex parameter]]</body><body package="MIME" selector="tokenize:">tokenize: rfc822Stream 	"Scan field value token by token. Answer an array of tokens"	| result token |	result := (Array new: 2) writeStream.	[rfc822Stream atEnd or: [rfc822Stream peek == Character cr or: [(token := rfc822Stream nextToken) isNil]]]		whileFalse: [result nextPut: token].	^result contents</body><body package="MIME" selector="tokenizedValueFrom:">tokenizedValueFrom: rfc822Stream 	"Scan field value token by token. Answer a string that is a concatenation of all elements in the array. One can view this as a canonicalized field value because this operation eliminates all white space and comments "	| result tokens |	result := (String new: 20) writeStream.	tokens := self tokenize: rfc822Stream.	tokens		do: [:token | token isString				ifTrue: [result nextPutAll: token]				ifFalse: [result nextPut: token]].	^result contents</body><body package="MIME" selector="validateNextToken:for:">validateNextToken: scanner for: parName	^scanner next == $=</body></methods><methods><class-id>Net.ValueWithParams</class-id> <category>printing</category><body package="MIME" selector="printOn:">printOn: aStream	self printValueOn: aStream.	self params notEmpty 		ifTrue: [ 	self printParamsOn: aStream ]</body><body package="MIME" selector="printParameter:on:">printParameter: assoc on: aStream 	self class scannerType printWord: assoc key on: aStream.	self printParameter: assoc key value: assoc value on: aStream.</body><body package="MIME" selector="printParameter:value:on:">printParameter: name value: anObject on: aStream	anObject isNil ifTrue: [^nil].	self class scannerType print: $= on: aStream.	[self class scannerType printWord: anObject on: aStream	] 	on: NonASCIICharException 		do: [ :ex | aStream nextPut: $"; nextPutAll: anObject; nextPut: $"]</body><body package="MIME" selector="printParamsOn:">printParamsOn: aStream	params notNil		ifTrue:			[aStream nextPut: self valueSeparator.			params associations				do: [ :assoc | self printParameter: assoc on: aStream ]				separatedBy: [ aStream nextPut: self parametersSeparator ]]</body><body package="MIME" selector="printValueOn:">printValueOn: aStream	value ~~ nil		ifTrue: [aStream nextPutAll: self value]</body></methods><methods><class-id>Net.ValueWithParams</class-id> <category>initialize-release</category><body package="MIME" selector="initialize">initialize</body></methods><methods><class-id>Net.ValueWithParams class</class-id> <category>parsing</category><body package="MIME" selector="scannerOn:">scannerOn: aStream 	^(aStream isKindOf: self scannerType)		ifTrue: [aStream]		ifFalse: [self scannerType on: aStream asStream]</body><body package="MIME" selector="scannerType">scannerType	^MimeScanner</body></methods><methods><class-id>Net.ValueWithParams class</class-id> <category>instance creation</category><body package="MIME" selector="new">new	^super new initialize</body><body package="MIME" selector="newWithSeparators:">newWithSeparators: anArray	^self new		separators: anArray;		yourself</body></methods><methods><class-id>Net.MimeMessageBody</class-id> <category>testing</category><body package="MIME" selector="isBinary">isBinary	^self parent isBinary</body><body package="MIME" selector="isBinaryContentType">isBinaryContentType	^self parent isBinaryContentType</body><body package="MIME" selector="isEmpty">isEmpty	^self notEmpty not</body><body package="MIME" selector="isMultipart">isMultipart	^false</body><body package="MIME" selector="isSimple">isSimple	^true</body><body package="MIME" selector="notEmpty">notEmpty	^self size &gt; 0</body></methods><methods><class-id>Net.MimeMessageBody</class-id> <category>accessing</category><body package="MIME" selector="decodedValue">decodedValue	^self value</body><body package="MIME" selector="decodedValueWith:">decodedValueWith: aSymbol	^self value</body><body package="MIME" selector="mimeType">mimeType	^self parent mimeType</body><body package="MIME" selector="partAt:">partAt: anInteger	self subclassResponsibility</body><body package="MIME" selector="removePart:">removePart: aMimeEntity	self subclassResponsibility</body><body package="MIME" selector="removePartAt:">removePartAt: anInteger	self subclassResponsibility</body><body package="MIME" selector="size">size	^ self sourceSize</body><body package="MIME" selector="sourceLineEndConvention">sourceLineEndConvention	^nil</body></methods><methods><class-id>Net.MimeMessageBody</class-id> <category>writing</category><body package="MIME" selector="writeContentsOn:">writeContentsOn: aStream" Write your contents on a stream. Used to save to a file. etc. "	self subclassResponsibility</body></methods><methods><class-id>Net.MimeMessageBody</class-id> <category>printing</category><body package="MIME" selector="conclusion">conclusion	^nil</body><body package="MIME" selector="preamble">preamble	^nil</body><body package="MIME" selector="printForDisplayOn:">printForDisplayOn: aStream	self printOn: aStream</body><body package="MIME" selector="printOn:indent:">printOn: aStream indent: level	self printer printMessageElement: self on: aStream indent: level</body></methods><methods><class-id>Net.MimeMessageBody</class-id> <category>parsing</category><body package="MIME" selector="builder">builder	^self parent notNil		ifTrue: [self parent builder]		ifFalse: [self defaultBuilder]</body><body package="MIME" selector="defaultBuilder">defaultBuilder	^self class defaultBuilder</body><body package="MIME" selector="defaultPrinter">defaultPrinter	^self class defaultPrinter</body><body package="MIME" selector="parse:">parse: scanner</body><body package="MIME" selector="printer">printer	^self parent notNil		ifTrue: [self parent printer]		ifFalse: [self defaultPrinter]</body></methods><methods><class-id>Net.MimeMessageBody class</class-id> <category>instance creation</category><body package="MIME" selector="bodyTypeFor:">bodyTypeFor: aMimeEntity 	^aMimeEntity isMultipart		ifTrue: [MultipartBody]		ifFalse: [aMimeEntity class simpleBody]</body><body package="MIME" selector="newBodyFor:">newBodyFor: aMimeEntity 	^(self bodyTypeFor: aMimeEntity) new		parent: aMimeEntity;		yourself</body><body package="MIME" selector="readFrom:parent:">readFrom: stream parent: aMimeEntity	^(self newBodyFor: aMimeEntity)		readFrom: stream;		yourself</body></methods><methods><class-id>Net.MimeMessageBody class</class-id> <category>parsing</category><body package="MIME" selector="builder">builder	^self defaultBuilder</body><body package="MIME" selector="defaultBuilder">defaultBuilder	^MimeEntity builder</body><body package="MIME" selector="defaultPrinter">defaultPrinter	^MimeEntity printer</body><body package="MIME" selector="printer">printer	^self defaultPrinter</body><body package="MIME" selector="scannerType">scannerType	^MimeScanner</body></methods><methods><class-id>Net.MultipartBody</class-id> <category>accessing</category><body package="MIME" selector="addPart:">addPart: part	self parts add: part</body><body package="MIME" selector="boundary">boundary	^self parent boundary</body><body package="MIME" selector="parent:">parent: aMimeEntity	super parent: aMimeEntity.	" Re-parent all my parts "	self parts do: [ :part | part parent: aMimeEntity ]</body><body package="MIME" selector="partAt:">partAt: anInteger	^self parts at: anInteger</body><body package="MIME" selector="parts">parts	^value</body><body package="MIME" selector="parts:">parts: aCollection	value := aCollection.	value do: [ :part | part parent: self ].</body><body package="MIME" selector="removePart:">removePart: aMimeEntity	self parts remove: aMimeEntity</body><body package="MIME" selector="removePartAt:">removePartAt: anInteger	self parts remove: (self partAt: anInteger)</body></methods><methods><class-id>Net.MultipartBody</class-id> <category>transfer encoding</category><body package="MIME" selector="decodeAs:">decodeAs: encodingName	" Do nothing -- content transfer encoding does not apply to multipart bodies "</body><body package="MIME" selector="encodeAs:">encodeAs: encodingName	" Do nothing -- content transfer encoding does not apply to multipart bodies "</body><body package="MIME" selector="needsContentTransferEncoding">needsContentTransferEncoding	^false</body></methods><methods><class-id>Net.MultipartBody</class-id> <category>initialization</category><body package="MIME" selector="initialize">initialize	self parts: (OrderedCollection new: 4)</body></methods><methods><class-id>Net.MultipartBody</class-id> <category>testing</category><body package="MIME" selector="isMultipart">isMultipart	^true</body><body package="MIME" selector="isSimple">isSimple	^false</body><body package="MIME" selector="notEmpty">notEmpty	^true</body></methods><methods><class-id>Net.MultipartBody</class-id> <category>copying</category><body package="MIME" selector="postCopy">postCopy	super postCopy.	value := value collect: [ :part | part copy ].</body></methods><methods><class-id>Net.MultipartBody</class-id> <category>writing</category><body package="MIME" selector="writeContentsOn:">writeContentsOn: aStream	self shouldNotImplement</body></methods><methods><class-id>Net.MultipartBody</class-id> <category>visiting</category><body package="MIME" selector="acceptVisit:with:">acceptVisit: aVisitor with: argument	^aVisitor acceptMultipartBody: self with: argument</body></methods><methods><class-id>Net.MultipartBody</class-id> <category>constants</category><body package="MIME" selector="boundaryDashes">boundaryDashes	^'--'</body></methods><methods><class-id>Net.MultipartBody</class-id> <category>printing</category><body package="MIME" selector="conclusion">conclusion	^(self boundaryDashes, self boundary, self boundaryDashes) readStream</body><body package="MIME" selector="preamble">preamble	^'This message is in Mime format\\' withCRs readStream</body><body package="MIME" selector="printStructureOn:indent:do:">printStructureOn: aStream indent: level do: aBlock	| boundary |	(boundary := self boundary) isNil					ifTrue: [ boundary := (#NoBoudarySpecified &lt;&lt; #net &gt;&gt; '*** No Boudary Specified!!! ***') ].	self printLine: 'This message is in MIME format.' on: aStream indent: level.	aStream cr.	self parts		do: 			[:part | 			self printLine: '--' ,  boundary on: aStream indent: level.			aBlock value: part.			aStream cr].	self printLine: ('--' ,  boundary, '--') on: aStream indent: level.</body></methods><methods><class-id>Net.MultipartBody</class-id> <category>private -- parsing</category><body package="MIME" selector="doParse:">doParse: scanner	"Parse multi-part body structure "	self 		scanPartsFrom: scanner 		useSourceStream: false		do: [ :sourceStream | | part |			(part := MimeEntity readFrom: sourceStream) notNil				ifTrue: [self addPart: part]].	^self parts</body><body package="MIME" selector="scanPartsFrom:useSourceStream:do:">scanPartsFrom: scanner useSourceStream: aBoolean do: aBlock	"Parse multi-part body structure "	|  boundary | 	boundary := self boundary.	"Skip to the first boundary, ignore text in between"	boundary isNil ifTrue: [^self error: (#MissingBoundaryInMultipartBody &lt;&lt; #net &gt;&gt; 'Missing boundary in multi-part body')].	scanner scanToBoundary: boundary.	scanner atEnd ifTrue: [^self error: (#MissingBoundaryInMultipartBody &lt;&lt; #net &gt;&gt; 'Missing boundary in multi-part body')].	[self		scanToBoundary: boundary		from: scanner asStream		useSourceStream: aBoolean		do: 			[:partStream :lastPart | 			aBlock value: partStream.			lastPart ifTrue: [^self]]] repeat</body><body package="MIME" selector="scanToBoundary:from:useSourceStream:do:">scanToBoundary: boundary from: stream useSourceStream: aBoolean do: aDyadicBlock 	"Scan for specified boundary (RFC2046, p5.1). Answer two-element array. First element is read 	stream on scanned text from current position up to the beginning of the boundary. Second element 	is either #next or #last. #next means the boundary found is not the last one. #last means the 	boundary is the closing boundary for the multi-part body (that is, it looks like '--&lt;boundary&gt;--)"	| pattern partStream startPos isLastPart nextPos savePos lineEnd str |	lineEnd := stream lineEndConvention."The boundary delimiter MUST occur at the beginning of a line, i.e.,   following a CRLF, and the initial CRLF is considered to be attached to the boundary delimiter line rather than part of the preceding part. For internal stream the boundary delimiter can start from CR"	str := (lineEnd = LineEndCR		ifTrue: [String with: Character cr ]		ifFalse: [ String with: Character cr with: Character lf ]).	pattern := str, self boundaryDashes , boundary.	[ stream lineEndTransparent.	partStream := aBoolean				ifTrue: 					[startPos := stream position.					stream skipToAll: pattern.					stream asStream from: startPos to: stream position]				ifFalse: [(stream upToAndSkipThroughAll: pattern) readStream].	"Skip over pattern"	savePos := stream position.	isLastPart := (stream atEnd or: 					[[(stream next: 2) = self boundaryDashes]						on: Stream incompleteNextCountSignal						do: [:ex | ex return: true]])				ifTrue: [true]				ifFalse: 	[stream position: savePos.						false].	"Skip to the end of line"	stream upToAndSkipThroughAll: str.	] ensure: [ stream lineEndConvention: lineEnd ].	nextPos := stream position.	[aDyadicBlock value: partStream value: isLastPart]		ensure: [stream position: nextPos]</body></methods><methods><class-id>Net.MultipartBody class</class-id> <category>documentation</category><body package="MIME" selector="fromRFC2046">fromRFC2046" From RFC2046: Multipurpose Internet Mail Extensions (MIME) Part Two:                              Media Types5.1.  Multipart Media Type   In the case of multipart entities, in which one or more different   sets of data are combined in a single body, a 'multipart' media type   field must appear in the entity's header.  The body must then contain   one or more body parts, each preceded by a boundary delimiter line,   and the last one followed by a closing boundary delimiter line.   After its boundary delimiter line, each body part then consists of a   header area, a blank line, and a body area.  Thus a body part is   similar to an RFC 822 message in syntax, but different in meaning.   A body part is an entity and hence is NOT to be interpreted as   actually being an RFC 822 message.  To begin with, NO header fields   are actually required in body parts.  A body part that starts with a   blank line, therefore, is allowed and is a body part for which all   default values are to be assumed.  In such a case, the absence of a   Content-Type header usually indicates that the corresponding body has   a content-type of 'text/plain; charset=US-ASCII'.   The only header fields that have defined meaning for body parts are   those the names of which begin with 'Content-'.  All other header   fields may be ignored in body parts.  Although they should generally   be retained if at all possible, they may be discarded by gateways if   necessary.  Such other fields are permitted to appear in body parts   but must not be depended on.  'X-' fields may be created for   experimental or private purposes, with the recognition that the   information they contain may be lost at some gateways.   NOTE:  The distinction between an RFC 822 message and a body part is   subtle, but important.  A gateway between Internet and X.400 mail,   for example, must be able to tell the difference between a body part   that contains an image and a body part that contains an encapsulated   message, the body of which is a JPEG image.  In order to represent   the latter, the body part must have 'Content-Type: message/rfc822',   and its body (after the blank line) must be the encapsulated message,   with its own 'Content-Type: image/jpeg' header field.  The use of   similar syntax facilitates the conversion of messages to body parts,   and vice versa, but the distinction between the two must be   understood by implementors.  (For the special case in which parts   actually are messages, a 'digest' subtype is also defined.)   As stated previously, each body part is preceded by a boundary   delimiter line that contains the boundary delimiter.  The boundary   delimiter MUST NOT appear inside any of the encapsulated parts, on a   line by itself or as the prefix of any line.  This implies that it is   crucial that the composing agent be able to choose and specify a   unique boundary parameter value that does not contain the boundary   parameter value of an enclosing multipart as a prefix.   All present and future subtypes of the 'multipart' type must use an   identical syntax.  Subtypes may differ in their semantics, and may   impose additional restrictions on syntax, but must conform to the   required syntax for the 'multipart' type.  This requirement ensures   that all conformant user agents will at least be able to recognize   and separate the parts of any multipart entity, even those of an   unrecognized subtype.   As stated in the definition of the Content-Transfer-Encoding field   [RFC 2045], no encoding other than '7bit', '8bit', or 'binary' is   permitted for entities of type 'multipart'.  The 'multipart' boundary   delimiters and header fields are always represented as 7bit US-ASCII   in any case (though the header fields may encode non-US-ASCII header   text as per RFC 2047) and data within the body parts can be encoded   on a part-by-part basis, with Content-Transfer-Encoding fields for   each appropriate body part.5.1.1.  Common Syntax   This section defines a common syntax for subtypes of 'multipart'.   All subtypes of 'multipart' must use this syntax.  A simple example   of a multipart message also appears in this section.  An example of a   more complex multipart message is given in RFC 2049.   The Content-Type field for multipart entities requires one parameter,   'boundary'. The boundary delimiter line is then defined as a line   consisting entirely of two hyphen characters ('-', decimal value 45)   followed by the boundary parameter value from the Content-Type header   field, optional linear whitespace, and a terminating CRLF.   NOTE:  The hyphens are for rough compatibility with the earlier RFC   934 method of message encapsulation, and for ease of searching for   the boundaries in some implementations.  However, it should be noted   that multipart messages are NOT completely compatible with RFC 934   encapsulations; in particular, they do not obey RFC 934 quoting   conventions for embedded lines that begin with hyphens.  This   mechanism was chosen over the RFC 934 mechanism because the latter   causes lines to grow with each level of quoting.  The combination of   this growth with the fact that SMTP implementations sometimes wrap   long lines made the RFC 934 mechanism unsuitable for use in the event   that deeply-nested multipart structuring is ever desired.   WARNING TO IMPLEMENTORS:  The grammar for parameters on the Content-   type field is such that it is often necessary to enclose the boundary   parameter values in quotes on the Content-type line.  This is not   always necessary, but never hurts. Implementors should be sure to   study the grammar carefully in order to avoid producing invalid   Content-type fields.  Thus, a typical 'multipart' Content-Type header   field might look like this:     Content-Type: multipart/mixed; boundary=gc0p4Jq0M2Yt08j34c0p   But the following is not valid:     Content-Type: multipart/mixed; boundary=gc0pJq0M:08jU534c0p   (because of the colon) and must instead be represented as     Content-Type: multipart/mixed; boundary='gc0pJq0M:08jU534c0p'   This Content-Type value indicates that the content consists of one or   more parts, each with a structure that is syntactically identical to   an RFC 822 message, except that the header area is allowed to be   completely empty, and that the parts are each preceded by the line     --gc0pJq0M:08jU534c0p   The boundary delimiter MUST occur at the beginning of a line, i.e.,   following a CRLF, and the initial CRLF is considered to be attached   to the boundary delimiter line rather than part of the preceding   part.  The boundary may be followed by zero or more characters of   linear whitespace. It is then terminated by either another CRLF and   the header fields for the next part, or by two CRLFs, in which case   there are no header fields for the next part.  If no Content-Type   field is present it is assumed to be 'message/rfc822' in a   'multipart/digest' and 'text/plain' otherwise.   NOTE:  The CRLF preceding the boundary delimiter line is conceptually   attached to the boundary so that it is possible to have a part that   does not end with a CRLF (line  break).  Body parts that must be   considered to end with line breaks, therefore, must have two CRLFs   preceding the boundary delimiter line, the first of which is part of   the preceding body part, and the second of which is part of the   encapsulation boundary.   Boundary delimiters must not appear within the encapsulated material,   and must be no longer than 70 characters, not counting the two   leading hyphens.   The boundary delimiter line following the last body part is a   distinguished delimiter that indicates that no further body parts   will follow.  Such a delimiter line is identical to the previous   delimiter lines, with the addition of two more hyphens after the   boundary parameter value.     --gc0pJq0M:08jU534c0p--   NOTE TO IMPLEMENTORS:  Boundary string comparisons must compare the   boundary value with the beginning of each candidate line.  An exact   match of the entire candidate line is not required; it is sufficient   that the boundary appear in its entirety following the CRLF.   There appears to be room for additional information prior to the   first boundary delimiter line and following the final boundary   delimiter line.  These areas should generally be left blank, and   implementations must ignore anything that appears before the first   boundary delimiter line or after the last one.   NOTE:  These 'preamble' and 'epilogue' areas are generally not used   because of the lack of proper typing of these parts and the lack of   clear semantics for handling these areas at gateways, particularly   X.400 gateways.  However, rather than leaving the preamble area   blank, many MIME implementations have found this to be a convenient   place to insert an explanatory note for recipients who read the   message with pre-MIME software, since such notes will be ignored by   MIME-compliant software.   NOTE:  Because boundary delimiters must not appear in the body parts   being encapsulated, a user agent must exercise care to choose a   unique boundary parameter value.  The boundary parameter value in the   example above could have been the result of an algorithm designed to   produce boundary delimiters with a very low probability of already   existing in the data to be encapsulated without having to prescan the   data.  Alternate algorithms might result in more 'readable' boundary   delimiters for a recipient with an old user agent, but would require   more attention to the possibility that the boundary delimiter might   appear at the beginning of some line in the encapsulated part.  The   simplest boundary delimiter line possible is something like '---',   with a closing boundary delimiter line of '-----'.   As a very simple example, the following multipart message has two   parts, both of them plain text, one of them explicitly typed and one   of them implicitly typed:     From: Nathaniel Borenstein &lt;nsb@bellcore.com&gt;     To: Ned Freed &lt;ned@innosoft.com&gt;     Date: Sun, 21 Mar 1993 23:56:48 -0800 (PST)     Subject: Sample message     MIME-Version: 1.0     Content-type: multipart/mixed; boundary='simple boundary'     This is the preamble.  It is to be ignored, though it     is a handy place for composition agents to include an     explanatory note to non-MIME conformant readers.     --simple boundary     This is implicitly typed plain US-ASCII text.     It does NOT end with a linebreak.     --simple boundary     Content-type: text/plain; charset=us-ascii     This is explicitly typed plain US-ASCII text.     It DOES end with a linebreak.     --simple boundary--     This is the epilogue.  It is also to be ignored.   The use of a media type of 'multipart' in a body part within another   'multipart' entity is explicitly allowed.  In such cases, for obvious   reasons, care must be taken to ensure that each nested 'multipart'   entity uses a different boundary delimiter.  See RFC 2049 for an   example of nested 'multipart' entities.   The use of the 'multipart' media type with only a single body part   may be useful in certain contexts, and is explicitly permitted.   NOTE: Experience has shown that a 'multipart' media type with a   single body part is useful for sending non-text media types.  It has   the advantage of providing the preamble as a place to include   decoding instructions.  In addition, a number of SMTP gateways move   or remove the MIME headers, and a clever MIME decoder can take a good   guess at multipart boundaries even in the absence of the Content-Type   header and thereby successfully decode the message.   The only mandatory global parameter for the 'multipart' media type is   the boundary parameter, which consists of 1 to 70 characters from a   set of characters known to be very robust through mail gateways, and   NOT ending with white space. (If a boundary delimiter line appears to   end with white space, the white space must be presumed to have been   added by a gateway, and must be deleted.)  It is formally specified   by the following BNF:     boundary := 0*69&lt;bchars&gt; bcharsnospace     bchars := bcharsnospace / ' '     bcharsnospace := DIGIT / ALPHA / ''' / '(' / ')' /                      '+' / '_' / ',' / '-' / '.' /                      '/' / ':' / '=' / '?'   Overall, the body of a 'multipart' entity may be specified as   follows:     dash-boundary := '--' boundary                      ; boundary taken from the value of                      ; boundary parameter of the                      ; Content-Type field.     multipart-body := [preamble CRLF]                       dash-boundary transport-padding CRLF                       body-part *encapsulation                       close-delimiter transport-padding                       [CRLF epilogue]     transport-padding := *LWSP-char                          ; Composers MUST NOT generate                          ; non-zero length transport                          ; padding, but receivers MUST                          ; be able to handle padding                          ; added by message transports.     encapsulation := delimiter transport-padding                      CRLF body-part     delimiter := CRLF dash-boundary     close-delimiter := delimiter '--'     preamble := discard-text     epilogue := discard-text     discard-text := *(*text CRLF) *text                     ; May be ignored or discarded.     body-part := MIME-part-headers [CRLF *OCTET]                  ; Lines in a body-part must not start                  ; with the specified dash-boundary and                  ; the delimiter must not appear anywhere                  ; in the body part.  Note that the                  ; semantics of a body-part differ from                  ; the semantics of a message, as                  ; described in the text.     OCTET := &lt;any 0-255 octet value&gt;   IMPORTANT:  The free insertion of linear-white-space and RFC 822   comments between the elements shown in this BNF is NOT allowed since   this BNF does not specify a structured header field.   NOTE:  In certain transport enclaves, RFC 822 restrictions such as   the one that limits bodies to printable US-ASCII characters may not   be in force. (That is, the transport domains may exist that resemble   standard Internet mail transport as specified in RFC 821 and assumed   by RFC 822, but without certain restrictions.) The relaxation of   these restrictions should be construed as locally extending the   definition of bodies, for example to include octets outside of the   US-ASCII range, as long as these extensions are supported by the   transport and adequately documented in the Content- Transfer-Encoding   header field.  However, in no event are headers (either message   headers or body part headers) allowed to contain anything other than   US-ASCII characters.   NOTE:  Conspicuously missing from the 'multipart' type is a notion of   structured, related body parts. It is recommended that those wishing   to provide more structured or integrated multipart messaging   facilities should define subtypes of multipart that are syntactically   identical but define relationships between the various parts. For   example, subtypes of multipart could be defined that include a   distinguished part which in turn is used to specify the relationships   between the other parts, probably referring to them by their   Content-ID field.  Old implementations will not recognize the new   subtype if this approach is used, but will treat it as   multipart/mixed and will thus be able to show the user the parts that   are recognized.5.1.2.  Handling Nested Messages and Multiparts   The 'message/rfc822' subtype defined in a subsequent section of this   document has no terminating condition other than running out of data.   Similarly, an improperly truncated 'multipart' entity may not have   any terminating boundary marker, and can turn up operationally due to   mail system malfunctions.   It is essential that such entities be handled correctly when they are   themselves imbedded inside of another 'multipart' structure.  MIME   implementations are therefore required to recognize outer level   boundary markers at ANY level of inner nesting.  It is not sufficient   to only check for the next expected marker or other terminating   condition."</body></methods><methods><class-id>Net.NetworkEntityDescriptor</class-id> <category>accessing</category><body package="MIME" selector="alias">alias	^alias</body><body package="MIME" selector="alias:">alias: aValue	alias := aValue</body><body package="MIME" selector="comment">comment	^comment</body><body package="MIME" selector="comment:">comment: aValue	comment := aValue</body><body package="MIME" selector="stringWithEncoding:">stringWithEncoding: aString	| stream |	stream := (String new: 256) writeStream.	self writeOn: stream encoding: aString.	^stream contents</body></methods><methods><class-id>Net.NetworkEntityDescriptor</class-id> <category>printing</category><body package="MIME" selector="printAliasOn:">printAliasOn: stream 	alias notNil 		ifTrue: 			[(self scannerType shouldBeQuoted: alias)				ifTrue: [ stream nextPut: $"; nextPutAll: alias; nextPut: $" ]				ifFalse: [stream nextPutAll: alias]].</body><body package="MIME" selector="printCanonicalValueOn:">printCanonicalValueOn: stream	self subclassResponsibility</body><body package="MIME" selector="printCommentOn:">printCommentOn: stream 	comment notNil ifTrue: [		stream nextPut: $(.		comment			do: 				[:char | 				(RFC822Scanner isCommentChar: char)					ifFalse: [stream nextPut: $\].				stream nextPut: char].		stream nextPut: $).	]</body><body package="MIME" selector="printOn:indent:">printOn: stream indent: level	super printOn: stream indent: 0.	self printCanonicalValueOn: stream.	comment notNil ifTrue: [self printCommentOn: stream]</body></methods><methods><class-id>Net.NetworkEntityDescriptor</class-id> <category>parsing</category><body package="MIME" selector="scannerType">scannerType	^self class scannerType</body></methods><methods><class-id>Net.NetworkEntityDescriptor</class-id> <category>composing</category><body package="MIME" selector="writeAliasOn:encoding:">writeAliasOn: stream encoding: aString	"Encoding is required if alias contains non-ASCII chars."	alias notNil 		ifTrue: 			[(MimeEncodedWordCoDec shouldBeEncoded: alias)				ifTrue: [ stream nextPutAll: (MimeEncodedWordCoDec 									encodeText: alias 									asQuotedPrintableUsing: aString)]				ifFalse: 					[(self scannerType shouldBeQuoted: alias) 						ifTrue: [stream nextPut: $"; nextPutAll: alias; nextPut: $"]						ifFalse: [stream nextPutAll: alias]]]</body><body package="MIME" selector="writeCanonicalValueOn:encoding:">writeCanonicalValueOn: stream encoding: aString	self subclassResponsibility</body><body package="MIME" selector="writeCommentOn:encoding:">writeCommentOn: stream encoding: aString	self comment ~~ nil 		ifTrue: 			[stream nextPutAll: 				(MimeEncodedWordCoDec 					encodeComment: self comment 					asBase64Using: aString)]</body><body package="MIME" selector="writeOn:encoding:">writeOn: stream encoding: aString	self writeCanonicalValueOn: stream encoding: aString."	comment notNil ifTrue: [self writeCommentOn: stream encoding: aString] "</body></methods><methods><class-id>Net.NetworkEntityDescriptor</class-id> <category>testing</category><body package="MIME" selector="isAddressDescriptor">isAddressDescriptor	^true</body></methods><methods><class-id>Net.NetworkEntityDescriptor class</class-id> <category>parsing</category><body package="MIME" selector="scannerType">scannerType	^NetworkAddressParser</body></methods><methods><class-id>Net.MailGroupDescriptor</class-id> <category>accessing</category><body package="MIME" selector="addresses">addresses	^addresses</body><body package="MIME" selector="addresses:">addresses: anArray	addresses := anArray</body><body package="MIME" selector="alias">alias	^alias</body><body package="MIME" selector="alias:">alias: aString	alias := aString</body></methods><methods><class-id>Net.MailGroupDescriptor</class-id> <category>initialization</category><body package="MIME" selector="initialize">initialize	addresses := Array new.</body></methods><methods><class-id>Net.MailGroupDescriptor</class-id> <category>composing</category><body package="MIME" selector="writeCanonicalValueOn:encoding:">writeCanonicalValueOn: stream encoding: aString	self writeAliasOn: stream encoding: aString.	self printAddressesOn: stream</body></methods><methods><class-id>Net.MailGroupDescriptor</class-id> <category>printing</category><body package="MIME" selector="printAddressesOn:">printAddressesOn: stream	stream nextPut: $:.	self addresses do: [ :address | address printOn: stream ] separatedBy: [ stream nextPut: $, ].	stream nextPut: $;</body><body package="MIME" selector="printCanonicalValueOn:">printCanonicalValueOn: stream	self printAliasOn: stream.	self printAddressesOn: stream</body></methods><methods><class-id>Net.NetworkAddressDescriptor</class-id> <category>accessing</category><body package="MIME" selector="addressSpecString">addressSpecString	^self printStringSelector: #printAddressSpecOn:</body><body package="MIME" selector="aliasString">aliasString	^self printStringSelector: #printAliasOn:</body><body package="MIME" selector="commentString">commentString	^self printStringSelector: #printCommentOn:</body><body package="MIME" selector="domain">domain	^domain</body><body package="MIME" selector="domain:">domain: aValue	domain := aValue</body><body package="MIME" selector="domainString">domainString	^self printStringSelector: #printDomainOn:</body><body package="MIME" selector="localPart">localPart	^localPart</body><body package="MIME" selector="localPart:">localPart: aValue	localPart := aValue</body><body package="MIME" selector="localPartString">localPartString	^self printStringSelector: #printLocalPartOn:</body><body package="MIME" selector="route">route	^route</body><body package="MIME" selector="route:">route: aValue	route := aValue</body><body package="MIME" selector="routeString">routeString	^self printStringSelector: #printRouteOn:</body></methods><methods><class-id>Net.NetworkAddressDescriptor</class-id> <category>printing</category><body package="MIME" selector="printAddressSpecOn:">printAddressSpecOn: stream 	self hasAddressSpec		ifTrue: 			[self printLocalPartOn: stream.			stream nextPut: $@.			self printDomainOn: stream]		ifFalse:			[(alias notNil and: [ alias notEmpty ]) 				ifTrue: [self scannerType printWord: alias on: stream ]]</body><body package="MIME" selector="printCanonicalValueOn:">printCanonicalValueOn: stream 	alias notNil		ifTrue: 			[self printAliasOn: stream.			self printRouteAddressOn: stream]		ifFalse: [self printAddressSpecOn: stream].</body><body package="MIME" selector="printDomainOn:">printDomainOn: stream	self scannerType printDomain: domain on: stream</body><body package="MIME" selector="printLocalPartOn:">printLocalPartOn: stream 	localPart do: [ :token | self scannerType printWord: token on: stream ] separatedBy: [ stream nextPut: $. ]</body><body package="MIME" selector="printRouteAddressOn:">printRouteAddressOn: stream 	(route notNil or: [self hasAddressSpec])		ifTrue: 			[stream nextPut: $&lt;.			self printRouteOn: stream; printAddressSpecOn: stream.			stream nextPut: $&gt;]</body><body package="MIME" selector="printRouteOn:">printRouteOn: stream 	(route notNil and: [route isEmpty not])		ifTrue: 			[route				do: 					[:domainx | 					stream space; nextPut: $@.					self scannerType printDomain: domainx on: stream.					stream nextPut: $:].			stream space]</body></methods><methods><class-id>Net.NetworkAddressDescriptor</class-id> <category>testing</category><body package="MIME" selector="hasAddressSpec">hasAddressSpec	^localPart notNil and: [localPart isEmpty not and: [domain notNil and: [domain isEmpty not]]]</body></methods><methods><class-id>Net.NetworkAddressDescriptor</class-id> <category>initialization</category><body package="MIME" selector="initialize">initialize	localPart := Array new.</body></methods><methods><class-id>Net.NetworkAddressDescriptor</class-id> <category>private</category><body package="MIME" selector="printStringSelector:">printStringSelector: sel	| stream |	stream := (String new: 64) writeStream.	self perform: sel with: stream.	^stream contents</body></methods><methods><class-id>Net.NetworkAddressDescriptor</class-id> <category>composing</category><body package="MIME" selector="writeCanonicalValueOn:encoding:">writeCanonicalValueOn: stream encoding: aString	alias notNil		ifTrue: 			[self writeAliasOn: stream encoding: aString.			self writeCommentOn: stream encoding: aString.			self printRouteAddressOn: stream]		ifFalse: 	[ self printAddressSpecOn: stream].</body></methods><methods><class-id>Net.NetworkAddressDescriptor class</class-id> <category>utility</category><body package="MIME" selector="addressesFrom:">addressesFrom: stream	"self addressesFrom: 'kyasu@crl.fujixerox.co.jp' readStream."	"self addressesFrom: 'Kazuki Yasumatsu &lt;kyasu@crl.fujixerox.co.jp&gt;' readStream."	"self addressesFrom: 'kyasu@crl.fujixerox.co.jp (Kazuki Yasumatsu)' readStream."	"self addressesFrom: ' kyasu1, kyasu2, Kazuki Yasumatsu &lt;kyasu3&gt;, kyasu4 (Kazuki Yasumatsu)' readStream."	"self addressesFrom: ' foo bar, kyasu1, ,  Kazuki Yasumatsu &lt;kyasu2&gt; &lt;kyasu3&gt; (&lt;foo&gt; (foo bar), bar)' readStream."	^self scannerType addressesFrom: stream asStream</body><body package="MIME" selector="addressFrom:">addressFrom: aStream	"self addressesFrom: 'kyasu@crl.fujixerox.co.jp'."	"self addressesFrom: 'Kazuki Yasumatsu &lt;kyasu@crl.fujixerox.co.jp&gt;'."	"self addressesFrom: 'kyasu@crl.fujixerox.co.jp (Kazuki Yasumatsu)'."	"self addressesFrom: ' kyasu1, kyasu2, Kazuki Yasumatsu &lt;kyasu3&gt;, kyasu4 (Kazuki Yasumatsu)'."	"self addressesFrom: ' foo bar, kyasu1, ,  Kazuki Yasumatsu &lt;kyasu2&gt; &lt;kyasu3&gt; (&lt;foo&gt; (foo bar), bar)'."	^self scannerType addressFrom: aStream</body></methods><methods><class-id>Net.NetworkAddressDescriptor class</class-id> <category>parsing</category><body package="MIME" selector="parser">parser	^self scannerType new</body><body package="MIME" selector="scannerType">scannerType	^NetworkAddressParser</body></methods><methods><class-id>Net.NonASCIIFieldParamException class</class-id> <category>testing</category><body package="MIME" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Net.MessageHandler</class-id> <category>initialization</category><body package="MIME" selector="initialize">initialize	context := IdentityDictionary new.	headerOnly := false.	self initializeEntityContext</body><body package="MIME" selector="initializeEntityContext">initializeEntityContext	self context removeKey: #entityContextList ifAbsent: [ ]</body></methods><methods><class-id>Net.MessageHandler</class-id> <category>private</category><body package="MIME" selector="entityContextList">entityContextList	^self context at: #entityContextList ifAbsentPut: [List new: 1].</body><body package="MIME" selector="popEntityContext">popEntityContext	^self entityContextList removeFirst</body><body package="MIME" selector="pushEntityContext">pushEntityContext	^self entityContextList addFirst: (IdentityDictionary new: 4)</body><body package="MIME" selector="pushEntityContext:">pushEntityContext: aMimeEntity	self pushEntityContext; entity: aMimeEntity</body></methods><methods><class-id>Net.MessageHandler</class-id> <category>accessing</category><body package="MIME" selector="context">context	^context</body><body package="MIME" selector="dispatcher">dispatcher	^dispatcher isNil		ifTrue: [ dispatcher := self defaultDispatcher ]		ifFalse: [ dispatcher ]</body><body package="MIME" selector="dispatcher:">dispatcher: aMessageDispatcher	aMessageDispatcher handler: self.	dispatcher := aMessageDispatcher.</body><body package="MIME" selector="entity">entity	^self entityContext at: #entity ifAbsentPut: [ nil ]</body><body package="MIME" selector="entity:">entity: aMimeEntity	self entityContext at: #entity put: aMimeEntity</body><body package="MIME" selector="entityContext">entityContext	^self entityContextList notEmpty 		ifTrue: [self entityContextList first ]</body><body package="MIME" selector="entityContextAt:ifAbsent:">entityContextAt: aSymbol ifAbsent: aNiladicBlock" Answer specified entity context element. If not found, try global context.This failing, answer result of the niladic block. Normally, the same element should not appear in both entity and global context but it may be convenient in certain scenarios " 	^self entityContext 		at: aSymbol 		ifAbsent: [ self context at: aSymbol ifAbsent: aNiladicBlock ]</body><body package="MIME" selector="entityContextAt:put:">entityContextAt: aSymbol put: anObject	self entityContext at: aSymbol  put: anObject</body><body package="MIME" selector="headerOnly">headerOnly	^headerOnly</body><body package="MIME" selector="headerOnly:">headerOnly: aBoolean	headerOnly := aBoolean</body><body package="MIME" selector="level">level	^self entityContextList size - 1</body><body package="MIME" selector="parentContext">parentContext	^self entityContextList size &gt; 1		ifTrue: [self entityContextList at: 2]		ifFalse: [nil]</body></methods><methods><class-id>Net.MessageHandler</class-id> <category>dispatcher interface</category><body package="MIME" selector="action:with:">action: aSymbol with: argument	^self perform: aSymbol with: argument</body><body package="MIME" selector="action:with:with:">action: aSymbol with: argument with: argument2	^self perform: aSymbol with: argument with: argument2</body><body package="MIME" selector="action:withArguments:">action: aSymbol withArguments: argumentArray	^self perform: aSymbol withArguments: argumentArray</body><body package="MIME" selector="visit:">visit: anObject	self dispatcher visit: anObject</body></methods><methods><class-id>Net.MessageHandler</class-id> <category>action callbacks</category><body package="MIME" selector="endBody:">endBody: aMessageBody	^true</body><body package="MIME" selector="endBodyPart:">endBodyPart: aMimeEntity</body><body package="MIME" selector="endEntity:">endEntity: aMimeEntityOrNil	| entity | 	entity := self entity.	self popEntityContext.	^entity</body><body package="MIME" selector="endHeader:">endHeader: aMessageHeader	^self entity</body><body package="MIME" selector="getSimpleBodyStream:">getSimpleBodyStream: aSimpleBody	^aSimpleBody source</body><body package="MIME" selector="startBody:">startBody: aMimeEntity	^self headerOnly not</body><body package="MIME" selector="startBodyPart:">startBodyPart: aMimeEntity	^true</body><body package="MIME" selector="startBodyStream:">startBodyStream: aStream	^self startBodyStream: aStream length: nil</body><body package="MIME" selector="startBodyStream:length:">startBodyStream: aStream length: anIntegerOrNil</body><body package="MIME" selector="startEntity:">startEntity: aMimeEntityOrNil	self 		pushEntityContext: aMimeEntityOrNil;		entity: aMimeEntityOrNil.	^true</body><body package="MIME" selector="startHeader:">startHeader: aMessageHeader	^true</body></methods><methods><class-id>Net.MessageHandler</class-id> <category>defaults</category><body package="MIME" selector="defaultDispatcher">defaultDispatcher	^self dispatcherClass handler: self</body><body package="MIME" selector="dispatcherClass">dispatcherClass	^MessageDispatcher</body></methods><methods><class-id>Net.MessageHandler</class-id> <category>testing</category><body package="MIME" selector="isRootContext">isRootContext	^self parentContext isNil</body></methods><methods><class-id>Net.MessageHandler class</class-id> <category>instance creation</category><body package="MIME" selector="new">new	^super new initialize</body></methods><methods><class-id>Net.MessagePrintHandler</class-id> <category>accessing</category><body package="MIME" selector="digestMode">digestMode	^self context at: #digestMode ifAbsent: [false]</body><body package="MIME" selector="digestMode:">digestMode: aBoolean	self context at: #digestMode put: aBoolean</body><body package="MIME" selector="fieldStream">fieldStream" field stream is used to convert field values into streams. field stream is reused for performance reasons "	^self context at: #fieldStream ifAbsentPut: [(String new: 256) writeStream]</body><body package="MIME" selector="headerFieldOrder">headerFieldOrder" This method answers a collection of field names that must appear in  the given order before all other fields. This is used to impose correct field sequence for rfc822 messages because rfc822 postulates certain order of fields "	^self entityContext at: #headerFieldOrder ifAbsent: [ OrderedCollection new ]</body><body package="MIME" selector="headerFieldOrder:">headerFieldOrder: anArrayOrFieldNames	^self entityContext at: #headerFieldOrder put: anArrayOrFieldNames</body><body package="MIME" selector="indentation">indentation	^self context at: #indentation ifAbsent: [0]</body><body package="MIME" selector="indentation:">indentation: anInteger	^self context at: #indentation put: anInteger</body><body package="MIME" selector="indentLines">indentLines	^self context at: #indentLines ifAbsent: [false]</body><body package="MIME" selector="indentLines:">indentLines: aBoolean	self context at: #indentLines put: aBoolean</body><body package="MIME" selector="maxLineLength">maxLineLength	^self context at: #maxLineLength ifAbsent: [1024]</body><body package="MIME" selector="maxLineLength:">maxLineLength: anInteger	self context at: #maxLineLength put: anInteger</body><body package="MIME" selector="preferFieldSource">preferFieldSource" Answers true if field's source is preferred to its parsed values, false otherwise. If application resends, routes of forwards messages, all mail protocols strongly advise against and changes in message header fields. These changes are unavoidable if all fields are to be parsed and later composed when a message is resent/forwarded. In this situation a wise approach is to prefer source, so fields are copied to the output exactly the way thay have been received "	^self context at: #preferFieldSource ifAbsent: [false]</body><body package="MIME" selector="preferFieldSource:">preferFieldSource: aBoolean	self context at: #preferFieldSource put: false</body><body package="MIME" selector="stream">stream	^stream</body><body package="MIME" selector="transferEncodingType">transferEncodingType" Answer method of encoding for the body of this entity or nil if no transfer encoding is necessary "	^self entityContext at: #transferEncodingType ifAbsent: [ nil ]</body><body package="MIME" selector="transferEncodingType:">transferEncodingType: aSymbol" Answer method of encoding for the body of this entity or nil if no transfer encoding is necessary "	^self entityContext at: #transferEncodingType put: aSymbol</body><body package="MIME" selector="transferFields">transferFields	^self entityContext at: #transferFields ifAbsentPut: [ OrderedCollection new ]</body><body package="MIME" selector="transferFields:">transferFields: aCollection	self entityContext at: #transferFields put: aCollection</body></methods><methods><class-id>Net.MessagePrintHandler</class-id> <category>printing utilities</category><body package="MIME" selector="cr">cr	self stream cr</body><body package="MIME" selector="printBodyStream:">printBodyStream: aStream	self encode: aStream as: self transferEncodingType</body><body package="MIME" selector="printHeader:">printHeader: aMessageHeader" Print header fields "	| fields |	fields := (aMessageHeader fieldsInOrder: self headerFieldOrder) 				addAll: self transferFields;				yourself.	fields do: [ :field | self printHeaderField: field ]</body><body package="MIME" selector="printLine:">printLine: aString	self tab.	self stream nextPutAll: aString.	self cr</body><body package="MIME" selector="printPreambule:">printPreambule: aMessageBody" Print preamble if any "	| aStream |	(aStream := aMessageBody preamble) notNil			ifTrue: [ aStream linesDo: [:line | self printLine: line ]].	^true</body><body package="MIME" selector="tab">tab	self indentLines ifTrue: [ self stream tab: self level + self indentation ]</body></methods><methods><class-id>Net.MessagePrintHandler</class-id> <category>action callbacks</category><body package="MIME" selector="endBody:">endBody: aMessageBody" Print conclusion if any "" Reset line end convention for the stream for the boundary delimiter if it is multipart body "	stream isInternal ifFalse: [ stream lineEndCRLF ].	self printConclusion: aMessageBody</body><body package="MIME" selector="endBodyPart:">endBodyPart: aMimeEntity	self cr</body><body package="MIME" selector="endHeader:">endHeader: aMessageHeader 	"Print header fields"	[self 		setBoundary: self entity;		headerFieldOrder: self entity transferFieldOrder;		setTransferContext: self entity; 		printHeader: aMessageHeader	]		ensure: [self cr].	^super endHeader: aMessageHeader</body><body package="MIME" selector="getSimpleBodyStream:">getSimpleBodyStream: aSimpleBody	^(self digestMode 		ifTrue: [ aSimpleBody sourceForDigest ]		ifFalse: [self valueStreamFor: aSimpleBody ])</body><body package="MIME" selector="startBody:">startBody: aMessageBody	^(super startBody: aMessageBody)		ifTrue: [self printPreambule: aMessageBody]		ifFalse: [false]</body><body package="MIME" selector="startBodyPart:">startBodyPart: aMimeEntity	self printLine: '--' ,  self entity boundary.	^true</body><body package="MIME" selector="startBodyStream:">startBodyStream: aStream	self digestMode 		ifTrue: [ self printDigestOf: aStream ]		ifFalse: [self printBodyStream: aStream]</body></methods><methods><class-id>Net.MessagePrintHandler</class-id> <category>private</category><body package="MIME" selector="contentTransferEncodingFor:">contentTransferEncodingFor: aMimeEntity	^'base64'</body><body package="MIME" selector="defaultBoundaryFor:">defaultBoundaryFor: aMimeEntity" Compute default boundary for specified Mime entity. Boundary is a string thatcould not occur inside any of the parts. For now just use constant plus a random number "	^'=_STAMPed_MAIL', Random new next printString, '_='</body><body package="MIME" selector="encode:as:">encode: aStream as: encodingName	encodingName isNil		ifTrue: [[aStream atEnd] whileFalse: [stream nextPut: aStream next]].	encodingName = 'base64' 		ifTrue: [MimeScanner encode: aStream asBase64To: stream].	encodingName = 'quoted-printable' 		ifTrue: [MimeScanner encode: aStream asQuotedPrintableTo: stream].</body><body package="MIME" selector="fieldValueAsStreamFor:">fieldValueAsStreamFor: aHeaderField	^(self preferFieldSource and: [aHeaderField source notNil])		ifTrue: [aHeaderField source]		ifFalse: 			[self digestMode				ifTrue: [ aHeaderField printOn: self fieldStream reset ]				ifFalse: [ aHeaderField writeOn: self fieldStream reset ].				self fieldStream contents readStream]</body><body package="MIME" selector="printConclusion:">printConclusion: aMessageBody	| aStream |	(aStream := aMessageBody conclusion) notNil		ifTrue: [aStream linesDo: [:line | self printLine: line ]].</body><body package="MIME" selector="printDigestOf:">printDigestOf: aStream	" Print short digest from source stream onto aStream "	| contents binary fname size position |	binary := self entity hasByteSource.	binary		ifFalse: 			[binary := self entity isBinaryContentType 				or: [(aStream respondsTo: #isBinary) and: [aStream isBinary]]	].	fname := self entity fileName.	size := aStream size.	fname notNil 		ifTrue: [self printLine: '------ from ', fname, ' (', size printString, ' bytes) -----']		ifFalse: [binary ifTrue: [self printLine: '------ (', size printString, ' bytes) -----']].	binary not		ifTrue: 			[ position := aStream position. 				[contents := (aStream nextAvailable: 512). 				aStream atEnd ifFalse: [contents := contents, '...']. 				self printDigestText: contents.				] ensure: [ aStream position: position]			].	(fname notNil and: [binary not]) ifTrue: [self printLine: '---------------------------------------------------']</body><body package="MIME" selector="printDigestText:">printDigestText: aString	aString readStream linesDo: [ :line | self printLine: line ]</body><body package="MIME" selector="printHeaderField:">printHeaderField: aHeaderField" Get string representation of the field, make sure all lines are withing max line length and write all this on output stream. Lines may be folded to fit into max length (cr followed by tab is inserted). Field itself may fold lines, so field's representation is first broken into lines and then each line is folded if necessary. a cr is written at the end even if the field's source did not have cr "	(self fieldValueAsStreamFor: aHeaderField)		linesDo: [ :line | self printLine: line]</body><body package="MIME" selector="setBoundary:">setBoundary: aMimeEntity 	aMimeEntity needsBoundary		ifTrue: [aMimeEntity boundary: (self defaultBoundaryFor: aMimeEntity)].</body><body package="MIME" selector="setStream:">setStream: aStream	stream := aStream</body><body package="MIME" selector="setTransferContext:">setTransferContext: aMimeEntity " Set transfer encoding context for this entity. Transfer encoding logic may depend on the protocol domain (e-mail uses content-transfer-encoding, HTTP uses transfer-codings). We want to avoid producing intermediate results, specifically applying transfer encoding as a separate step. So we collect all the fields inside and apply transfer encoding directly on output stream. This method should be rewritten to use transfer encoding policies, then it will be truly usable across different protocols " 	| contentTransferEncoding |	(self digestMode not and: [aMimeEntity needsContentTransferEncoding])		ifTrue: 			[contentTransferEncoding := self contentTransferEncodingFor: aMimeEntity. 			self transferFields add: (ScalarField contentTransferEncoding: contentTransferEncoding).			self transferEncodingType: contentTransferEncoding]</body><body package="MIME" selector="valueStreamFor:">valueStreamFor: aSimpleBody	^aSimpleBody valueAsStream reset</body></methods><methods><class-id>Net.MessagePrintHandler</class-id> <category>tasks</category><body package="MIME" selector="printMessage:on:">printMessage: aMimeEntity on: aStream	self printMessageElement: aMimeEntity on: aStream indent: 1</body><body package="MIME" selector="printMessage:on:indent:">printMessage: aMimeEntity on: aStream indent: level	^self printMessageElement: aMimeEntity on: aStream indent: level</body><body package="MIME" selector="printMessageElement:on:">printMessageElement: aMessageElement on: aStream	^self printMessageElement: aMessageElement on: aStream indent: 0</body><body package="MIME" selector="printMessageElement:on:indent:">printMessageElement: aMessageElement on: aStream indent: level	self 		digestMode: true;		indentLines: true;		indentation: level;		setStream: aStream;		initializeEntityContext.	aMessageElement parent notNil		ifTrue: [ self pushEntityContext: aMessageElement parent ].	self visit: aMessageElement</body><body package="MIME" selector="writeMessage:on:">writeMessage: aMimeEntity on: aStream	self 		digestMode: false;		indentLines: false;		setStream: aStream;		initializeEntityContext;		visit: aMimeEntity</body><body package="MIME" selector="writeMessageElement:on:">writeMessageElement: aMessageElement on: aStream	self 		digestMode: false;		indentLines: false;		setStream: aStream;		initializeEntityContext;		entity: aMessageElement parent.	aMessageElement parent notNil		ifTrue: [ self pushEntityContext: aMessageElement parent ].	self visit: aMessageElement</body><body package="MIME" selector="writeMessageHeaderFor:on:">writeMessageHeaderFor: aMimeEntity on: aStream	self 		headerOnly: true; 		writeMessage: aMimeEntity on: aStream</body></methods><methods><class-id>Net.MessagePrintHandler class</class-id> <category>instance creation</category><body package="MIME" selector="on:">on: aStream	^self new		setStream: aStream</body><body package="MIME" selector="print:on:">print: message on: aStream	^self printMessage: message on: aStream</body><body package="MIME" selector="print:on:indent:">print: message on: aStream indent: level	^self new 		printMessage: message on: aStream indent: level;		yourself</body><body package="MIME" selector="printMessage:on:">printMessage: message on: aStream	^self new printMessage: message on: aStream</body><body package="MIME" selector="write:on:">write: message on: aStream	^self writeMessage: message on: aStream</body><body package="MIME" selector="writeHeaderFor:on:">writeHeaderFor: message on: aStream	^self writeMessageHeaderFor: message on: aStream</body><body package="MIME" selector="writeMessage:on:">writeMessage: message on: aStream	^self new writeMessage: message on: aStream</body><body package="MIME" selector="writeMessageHeaderFor:on:">writeMessageHeaderFor: message on: aStream	^self new writeMessageHeaderFor: message on: aStream</body></methods><methods><class-id>Net.MimeEntityBot</class-id> <category>enumerating</category><body package="MIME" selector="for:maxDepth:partsDo:">for: aMimeEntity maxDepth: depthLimit partsDo: aBlock	self 		for: aMimeEntity 		partsDo: [: part | self level &lt;= (depthLimit - 1) ifTrue: [aBlock value: part]]</body><body package="MIME" selector="for:partsDetect:ifNone:">for: aMimeEntity partsDetect: aBlock ifNone: exceptionBlock 	self		for: aMimeEntity		partsDo: [:part | (aBlock value: part) ifTrue: [^part]].	^exceptionBlock value</body><body package="MIME" selector="for:partsDo:">for: aMimeEntity partsDo: aBlock	self for: aMimeEntity while: [ true ] partsDo: aBlock</body><body package="MIME" selector="for:while:partsDo:">for: aMimeEntity while: condBlock partsDo: aBlock 	self entityCallback: [:part | condBlock value			ifTrue: [aBlock value: part. true]			ifFalse: [self keepSearching: false. false]].	self traverse: aMimeEntity.	^aMimeEntity</body><body package="MIME" selector="traverse:">traverse: aMimeEntity	self 		initializeEntityContext;		keepSearching: true;		visit: aMimeEntity</body></methods><methods><class-id>Net.MimeEntityBot</class-id> <category>accessing</category><body package="MIME" selector="entityCallback">entityCallback	^entityCallback</body><body package="MIME" selector="entityCallback:">entityCallback: aMonadicBlock	entityCallback := aMonadicBlock</body><body package="MIME" selector="keepSearching">keepSearching	^keepSearching</body><body package="MIME" selector="keepSearching:">keepSearching: aBoolean	keepSearching := aBoolean</body></methods><methods><class-id>Net.MimeEntityBot</class-id> <category>action callbacks</category><body package="MIME" selector="startEntity:">startEntity: aMimeEntityOrNil	^(super startEntity: aMimeEntityOrNil) 		ifTrue: [self entityCallback isNil 			ifTrue: [true]			ifFalse: [self entityCallback value: aMimeEntityOrNil]]		ifFalse: [false]</body></methods><methods><class-id>Net.MimeEntityBot</class-id> <category>tasks</category><body package="MIME" selector="addFileAttachmentFor:fileName:">addFileAttachmentFor: aMessage fileName: aFilename	| part |	aMessage addPart: (part := MimeEntity fileName: aFilename).	^part</body><body package="MIME" selector="applyTransferEncodingTo:">applyTransferEncodingTo: part	self applyTransferEncodingTo: part encodeAs: self defaultEncodingName</body><body package="MIME" selector="applyTransferEncodingTo:encodeAs:">applyTransferEncodingTo: part encodeAs: encodingNameOrNil	| encoding |	encoding := encodingNameOrNil isNil 					ifTrue: [ part defaultTransferEncodingName ]					ifFalse: [encodingNameOrNil].	part addContentTransferEncoding: encoding.</body><body package="MIME" selector="attachmentsFor:">attachmentsFor: aMimeEntity 	^aMimeEntity isMultipart		ifTrue: [ aMimeEntity parts ]		ifFalse: [ OrderedCollection new ]</body><body package="MIME" selector="checkStructure:">checkStructure: aMimeEntity	" Make sure all fields are in order mandated by RFC822 "	self for: aMimeEntity partsDo: 		[ :part | part arrangeFieldsInOrder: aMimeEntity transferFieldOrder ].	aMimeEntity mimeVersion isNil		ifTrue: [aMimeEntity addMimeVersion].	" Make sure all parts have assigned boundaries "	self for: aMimeEntity partsDo: [ :part |		part needsBoundary			ifTrue: [part boundary: (self defaultBoundaryFor: part)]].</body><body package="MIME" selector="defaultBoundaryFor:">defaultBoundaryFor: aMimeEntity" Compute default boundary for specified Mime entity. Boundary is a string thatcould not occur inside any of the parts. For now just use constant plus a random number "	^'=_STAMPed_MAIL', Random new next printString, '_='</body><body package="MIME" selector="defaultEncodingName">defaultEncodingName	^'base64'</body><body package="MIME" selector="makeMultipart:">makeMultipart: rfc822Message" Make single-part mail message a multipart one. Assumption that is madehere: aMimeEntity is a top-level RFC822 message. We create a new Mimeentity to contain message text and Mime fields (content-type, content-length, etc).These fields are removed from the top-level message and new content-type isset. This content type is somewhat arbitrarily set to miltipart/mixed. The messageis then given new miltipart body and new part is added to the body "	| messagePart |	messagePart := self makeSinglepartFrom: rfc822Message.	" Remove non-mime fields from the top-level message "	rfc822Message 		fields: (rfc822Message fields reject: [ :field |  'content*' match: field name ]);		contentType: 'multipart/mixed';		body: MultipartBody new.	messagePart ~~ nil		ifTrue: [ rfc822Message addPart: messagePart].	^rfc822Message</body><body package="MIME" selector="makeSinglepart:textPart:">makeSinglepart: rfc822Message textPart: textPart" Mutate multipart mail message into a single-part one. Assumption that is madehere: rfc822Message is a top-level RFC822 message that has only one part. We create new simple part and copy the part's contents into message contents.We then copy and all the part's fields into the top-level message fields. Simple bodybecomes the top level message's body "	" Merge fields from the part into the message "	textPart fields do: [ :field | rfc822Message addField: field ].	rfc822Message 		body: rfc822Message class simpleBody new;		contents: textPart contents.	^rfc822Message</body><body package="MIME" selector="makeSinglepartFrom:">makeSinglepartFrom: aMimeEntity" Make single-part from mime entity. Return nil if mime entity has empty body and  header fields "	| messagePart chSet |	messagePart := MimeEntity new.	" Copy Mime fields from the message "	aMimeEntity fields 		do: [ :field | 			('content*' match: field name)				ifTrue: [ messagePart addField: field copy] ].	aMimeEntity contents notNil 		ifTrue: [ 	messagePart contents: aMimeEntity contents].	^(messagePart fields isEmpty and: [ messagePart contents == nil ])		ifTrue: [nil]		ifFalse: 			[(chSet := messagePart charset ) ~~ nil ifTrue: [ aMimeEntity charset: chSet ]. 			messagePart fields isEmpty ifTrue: [ messagePart charset: aMimeEntity defaultCharset].			messagePart]</body><body package="MIME" selector="validate:">validate: aMimeEntity " Run sanity checks on an entity "	" 1. Validate structure "	self		for: aMimeEntity		partsDo: [:part | 			part body parent == part ifFalse: [ self error: (#BodyParentIsWrong &lt;&lt; #net &gt;&gt; 'Body parent is wrong') ].			part fields do: [ :field | field parent == part ifFalse: [ self error: (#FieldParentIsWrong &lt;&lt; #net &gt;&gt; 'Field parent is wrong') ]].			part parent notNil 				ifTrue: [ (part parent isMultipart and: [ part parent parts includes: part ])						ifFalse: [self error: (#InvalidMessageStructure &lt;&lt; #net &gt;&gt; 'Invalid message structure') ]].			(part isMultipart 				ifTrue: [ part body isMultipart ]				ifFalse: [ part body isSimple ])					ifFalse: [self error: (#BodyTypeMismatch &lt;&lt; #net &gt;&gt; 'Body type mismatch') ].			part isMultipart 				ifTrue: [part boundary notNil					ifFalse: [self error: (#ShouldHaveBoundary &lt;&lt; #net &gt;&gt; 'Should have boundary') ]].		].</body><body package="MIME" selector="writeContentsOf:on:">writeContentsOf: aMimeEntity on: anEncodedStream	aMimeEntity removeContentTransferEncoding.	aMimeEntity isBinary		ifTrue: [anEncodedStream binary]		ifFalse: [anEncodedStream text].	aMimeEntity writeContentsOn: anEncodedStream.</body></methods><methods><class-id>Net.MimeEntityBot</class-id> <category>initialization</category><body package="MIME" selector="initialize">initialize	super initialize.	keepSearching := true</body></methods><methods><class-id>Net.SinglePartPresenter</class-id> <category>interface opening</category><body package="MIME" selector="openWith:">openWith: mimeEntity 	mimeEntity removeContentTransferEncoding.	model := mimeEntity. 	partText := AspectAdaptor accessWith: #displayString assignWith: #contents:.	partText subject: model.	partText subjectSendsUpdates: false.	self open</body><body package="MIME" selector="postBuildWith:">postBuildWith: aBuilder	| component |	super postBuildWith: aBuilder.	self setLetterBodyKeyboardHookWith: aBuilder.	(component := aBuilder componentAt: #partText) notNil		ifTrue: [ component widget controller autoAccept: false.				aBuilder window application: self; receiveWindowEvents: #(#close #collapse ); 						label: self title. " icon: (self class letterIcon)" ]		ifFalse: [aBuilder window application: self; beMaster. " icon: (self class noMailIcon)"].</body><body package="MIME" selector="setLetterBodyKeyboardHookWith:">setLetterBodyKeyboardHookWith: aBuilder	"Allow keystrokes for text selection and text copying (ctrl-c)."	| component |	(component := aBuilder componentAt: #partText) isNil ifTrue: [^self].	component widget controller keyboardHook:		[ :ev :cntrl |		| meta key hasArrowKey |		meta := ev metaState.		key := ev keyValue.		hasArrowKey := "ArrowKeys includes: key" false.		( (meta == 1 and: [hasArrowKey])		  or: [(meta == 2 and: [key == (Character value: 3)])		  or: [(meta == 3 and: [hasArrowKey])]] )			ifTrue:  [ev]			ifFalse: [nil]]</body></methods><methods><class-id>Net.SinglePartPresenter</class-id> <category>aspects</category><body package="MIME" selector="partText">partText	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^partText isNil		ifTrue:			[partText := Text new asValue]		ifFalse:			[partText]</body></methods><methods><class-id>Net.SinglePartPresenter</class-id> <category>accessing</category><body package="MIME" selector="title">title	^title ifNil: [ String new ]</body><body package="MIME" selector="title:">title: anObject	title := anObject</body></methods><methods><class-id>Net.ScalarField</class-id> <category>parsing</category><body package="MIME" selector="doParse:">doParse: rfc822Stream 	^self tokenizedValueFrom: rfc822Stream</body></methods><methods><class-id>Net.ScalarField class</class-id> <category>instant creation</category><body package="MIME" selector="base64">base64" ScalarField base64 "	^self contentTransferEncoding: 'base64'</body><body package="MIME" selector="contentTransferEncoding:">contentTransferEncoding: encodingName" Answer an instance of this field representing desired content transfer encoding. encodingName is one of 'base64' or 'quoted-printable' "" ScalarField contentTransferEncoding: 'base64' "	^(self name: 'content-transfer-encoding') value: encodingName</body><body package="MIME" selector="quotedPrintable">quotedPrintable" ScalarField quotedPrintable "	^self contentTransferEncoding: 'quoted-printable'</body></methods><methods><class-id>Net.ScalarField class</class-id> <category>parsing</category><body package="MIME" selector="fieldNames">fieldNames	^#('message-id' 'content-id' 'content-transfer-encoding' 'transfer-encoding' 'content-encoding')</body></methods><methods><class-id>Net.MailboxListField</class-id> <category>accessing</category><body package="MIME" selector="addAddress:">addAddress: aString	^self addAddresses: (Array with: aString)</body><body package="MIME" selector="addAddresses:">addAddresses: aCollection	addresses isNil ifTrue: [ addresses := OrderedCollection new].	addresses add: aCollection.	self value addAll: (self sanitize: aCollection)</body><body package="MIME" selector="address">address	^self addresses isEmpty		ifTrue: [nil]		ifFalse: [self addresses first]</body><body package="MIME" selector="address:">address: aString" MailboxListField default address: 'Some person&lt;person@acme.com&gt;' "	self addresses: (OrderedCollection with: aString)</body><body package="MIME" selector="addresses">addresses	^addresses</body><body package="MIME" selector="addresses:">addresses: aCollection	 addresses := aCollection.	self value: (self sanitize: aCollection)</body><body package="MIME" selector="addressesEncodedWith:">addressesEncodedWith: aString	^self addresses collect: [ :addressDesc | addressDesc stringWithEncoding: aString ]</body><body package="MIME" selector="values">values" Multi-valued fields override this method "	^self value</body><body package="MIME" selector="values:">values: anArray" Multi-valued fields override this method "	self value: anArray</body></methods><methods><class-id>Net.MailboxListField</class-id> <category>printing</category><body package="MIME" selector="printAddressesOn:">printAddressesOn: aStream	self class printAddressList: (self sanitize: self addresses) on: aStream</body><body package="MIME" selector="printStructureOn:">printStructureOn: aStream	self printAddressesOn: aStream.</body></methods><methods><class-id>Net.MailboxListField</class-id> <category>private</category><body package="MIME" selector="sanitize:">sanitize: aCollection" Make sure collection of addresses is comprised of strings "	^aCollection collect: [:address | self sanitizeAddress: address]</body><body package="MIME" selector="sanitize:encoding:">sanitize: aCollection encoding: aString" Make sure collection of addresses is comprised of strings "	^aCollection collect: [:address | self sanitizeAddress: address encoding: aString ]</body></methods><methods><class-id>Net.MailboxListField</class-id> <category>initialization</category><body package="MIME" selector="initialize">initialize	super initialize.	value := OrderedCollection new.</body></methods><methods><class-id>Net.MailboxListField</class-id> <category>parsing</category><body package="MIME" selector="doParse:">doParse: rfc822Stream " HeaderField fromLine: 'To       :  George Jones &lt;Group@Some-Reg.An-Org&gt;,                 Al.Neuman@MAD.Publisher' "	| pos |	pos := rfc822Stream position.	addresses :=  [NetworkAddressDescriptor addressesFrom: rfc822Stream]					on: Error					do: [ :ex | 						Array with: 							(NetworkAddressDescriptor new 									comment: (rfc822Stream position: pos; nextLine); 								yourself) ]. 	^(self sanitize: addresses) asOrderedCollection</body></methods><methods><class-id>Net.MailboxListField</class-id> <category>composing</category><body package="MIME" selector="writeAddressesOn:encoding:">writeAddressesOn: aStream encoding: aString	self class printAddressList: (self addressesEncodedWith: aString ) on: aStream</body><body package="MIME" selector="writeStructureOn:encoding:">writeStructureOn: aStream encoding: aString	self writeAddressesOn: aStream encoding: aString.</body></methods><methods><class-id>Net.MailboxListField class</class-id> <category>printing</category><body package="MIME" selector="addressSeparator">addressSeparator	^$,</body><body package="MIME" selector="printAddressList:on:">printAddressList: collection on: aStream	collection do: [:addr | aStream nextPutAll: addr]		separatedBy: [aStream nextPut: self addressSeparator]</body></methods><methods><class-id>Net.MailboxListField class</class-id> <category>parsing</category><body package="MIME" selector="fieldNames">fieldNames	^#('from' 'to' 'reply-to' 'cc' 'bcc' 'resent-reply-to' 'resent-from' 'resent-to' 'resent-cc' 'resent-bcc' )</body></methods><methods><class-id>Net.VersionField</class-id> <category>accessing</category><body package="MIME" selector="majorVersion">majorVersion	^(self parseVersion: self value) first</body><body package="MIME" selector="majorVersion:">majorVersion: numberOrString	| arr |	arr := self parseVersion: self value.	arr at: 1 put: numberOrString.	self versionStringFrom: arr.</body><body package="MIME" selector="minorVersion">minorVersion	^(self parseVersion: self value) last</body><body package="MIME" selector="minorVersion:">minorVersion: numberOrString	| arr |	arr := self parseVersion: self value.	arr at: 2 put: numberOrString.	self versionStringFrom: arr.</body><body package="MIME" selector="version">version	^self value</body><body package="MIME" selector="version:">version: string	self value: string</body><body package="MIME" selector="versionStringFrom:">versionStringFrom: arr	^(arr first printString), $., (arr last printString)</body></methods><methods><class-id>Net.VersionField</class-id> <category>parsing</category><body package="MIME" selector="parseVersion:">parseVersion: string	| arr |	(string isNil or: [ string isEmpty ]) ifTrue: [ ^Array new: 2 ].	arr := string tokensBasedOn: $..	arr size &lt; 2 		ifTrue: [ ^self notify: (#VersionShouldBeSpecifiedAs &lt;&lt; #net &gt;&gt; 'Version should be specified as &lt;major version&gt;.&lt;minor version&gt;')].	^arr</body></methods><methods><class-id>Net.VersionField class</class-id> <category>parsing</category><body package="MIME" selector="fieldNames">fieldNames	^#('mime-version' 'http-version')</body></methods><methods><class-id>Net.SingleMailboxField</class-id> <category>printing</category><body package="MIME" selector="addressString">addressString	^self asString</body><body package="MIME" selector="asString">asString	^self address printString</body></methods><methods><class-id>Net.SingleMailboxField</class-id> <category>accessing</category><body package="MIME" selector="address">address	^address</body><body package="MIME" selector="address:">address: aNetworkAddressDescriptor	address := aNetworkAddressDescriptor.	self value: (self sanitizeAddress: aNetworkAddressDescriptor)</body><body package="MIME" selector="addresses">addresses	^self address</body></methods><methods><class-id>Net.SingleMailboxField</class-id> <category>parsing</category><body package="MIME" selector="doParse:">doParse: rfc822Stream " HeaderField fromLine: 'Sender :		Phil Campbell (The great) &lt;philc@yahoo.com&gt;' "	address := NetworkAddressDescriptor addressFrom: rfc822Stream asStream.	^self sanitizeAddress: address</body></methods><methods><class-id>Net.SingleMailboxField class</class-id> <category>parsing</category><body package="MIME" selector="fieldNames">fieldNames	^#('sender' 'resent-sender' 'return-path' )</body></methods><methods><class-id>Net.MailPage</class-id> <category>actions</category><body package="MIME" selector="accept">accept	self registry resetServers.	self mailServerMenu value menuItems 		do: [ :itemx | self registry updateMailHost: itemx value].	self defaultIncomingServer notNil		ifTrue: [ self registry defaultIncomingHost: self defaultIncomingServer].	self defaultOutgoingServer notNil		ifTrue: [ self registry defaultOutgoingHost: self defaultOutgoingServer].</body><body package="MIME" selector="addIdentity">addIdentity	self  userListOwner addIdentity</body><body package="MIME" selector="disturb">disturb</body><body package="MIME" selector="importSnapshots:">importSnapshots: aCollection	super importSnapshots: aCollection.	self userListOwner reset</body><body package="MIME" selector="mailServerTypeMenuString:">mailServerTypeMenuString: aType	^aType first, ' (', (aType at:2), ')'</body><body package="MIME" selector="okToAddServer">okToAddServer	( self mailServerName value isNil or: [self mailServerName value isEmpty])		ifTrue: [ ^Dialog warn: (#HostNameIsEmpty &lt;&lt; #net &gt;&gt; 'Host name is empty') ].	( self mailServerTypeMenuAspect value isNil or: [ self mailServerTypeMenuAspect value isEmpty])		ifTrue: [ ^Dialog warn: (#HostTypeIsEmpty &lt;&lt; #net &gt;&gt; 'Host type is empty') ].	self removeMenuItemFor: self mailServerName value.	hostSpec := HostSpec new						name: self mailServerName value;						type: self mailServerTypeMenuAspect value;						netUser: self mailUserMenuAspect value;						yourself.	(hostSpec isIncomingTypeMail and: [self defaultIncomingServer isNil])		ifTrue: [self defaultIncomingServer: hostSpec].	(hostSpec isOutgoingTypeMail and: [self defaultOutgoingServer isNil])		ifTrue: [self defaultOutgoingServer: hostSpec].	self mailServerMenu value		addItemLabel: ( self serverAsString: hostSpec ) 		value: hostSpec.		self updateMenuAspects.	manager tickle.</body><body package="MIME" selector="removeServer">removeServer	| it |	self removeMenuItemFor:  self hostSpec name. 	self hostSpec  = self defaultIncomingServer 		ifTrue: 			[ (it := self mailServerMenu value menuItems 					detect: [ :itx | itx value isIncomingTypeMail ] 					ifNone: [nil]) notNil				ifTrue: 					[self defaultIncomingServer: it value.					it label: (self serverAsString: it value)]				ifFalse: [self defaultIncomingServer: nil]].	self hostSpec  = self defaultOutgoingServer 		ifTrue: 			[ (it := self mailServerMenu value menuItems 						detect: [ :itx | itx value isOutgoingTypeMail ] 						ifNone: [nil]) notNil				ifTrue: 					[self defaultOutgoingServer: it value.					it label: (self serverAsString: it value)]				ifFalse: [ self defaultOutgoingServer: nil ]].	self hostSpec: HostSpec new.	self serverListAspect listHolder changed:#value.</body><body package="MIME" selector="reset">reset	self resetUIStateToDefault</body><body package="MIME" selector="resetUIStateToDefault">resetUIStateToDefault	self mailServerMenu value: self initializeFromRegistry.	self serverListAspect listHolder changed:#value.	self mailServerName value: self defaultMailServerName.	self mailServerTypeMenuAspect value: self defaultMailServerTypeMenuAspect.	self mailUserMenuAspect value: self defaultMailUserMenuAspect.</body><body package="MIME" selector="setServerAsDefault">setServerAsDefault	self setAsDefaultServer: self hostSpec.</body></methods><methods><class-id>Net.MailPage</class-id> <category>accessing</category><body package="MIME" selector="defaultIncomingServer">defaultIncomingServer	^self userPreferencesAt: #defaultIncomingServer ifAbsentPut: [ nil ]</body><body package="MIME" selector="defaultIncomingServer:">defaultIncomingServer: aHostSpec	^self userPreferencesAt: #defaultIncomingServer put: aHostSpec</body><body package="MIME" selector="defaultMailServerName">defaultMailServerName	| serv | 	^((serv := self serverList) notEmpty 				ifTrue: [ serv first ]				ifFalse: [ '' ])</body><body package="MIME" selector="defaultMailServerTypeMenuAspect">defaultMailServerTypeMenuAspect	^self mailServerMenu value menuItems notEmpty 		ifTrue: [ self mailServerMenu value menuItems first value type]		ifFalse: 			[self registry supportedMailClients notEmpty				ifTrue: [self registry supportedMailClients first serverType ]				ifFalse: [(String new) ] ]</body><body package="MIME" selector="defaultMailUserMenuAspect">defaultMailUserMenuAspect	^self mailServerMenu value menuItems notEmpty 			ifTrue: [ self mailServerMenu value menuItems first value netUser ]			ifFalse: [ nil  ]</body><body package="MIME" selector="defaultOutgoingServer">defaultOutgoingServer	^self userPreferencesAt: #defaultOutgoingServer ifAbsentPut: [ nil ]</body><body package="MIME" selector="defaultOutgoingServer:">defaultOutgoingServer: aHostSpec	^self userPreferencesAt: #defaultOutgoingServer put: aHostSpec</body><body package="MIME" selector="helpText">helpText	^(#ServerHelp &lt;&lt; #net &gt;&gt; 'You can specify several mail servers.  Typically you will have only a single outgoing mail server, but may have several incoming mail servers, if you receive mail from multiple mail services.To add a server, complete these fields and click Accept: - Name is the server''s fully qualified internet host name or IP address - Type is the server type, either POP3 (incoming), IMAP (incoming), or SMTP (outgoing) - User is a user ID already defined on the Identities page. To define a new user, click Add User... .  Complete the form as described in help for the Identities page.') asString</body><body package="MIME" selector="hostSpec">hostSpec	^hostSpec</body><body package="MIME" selector="hostSpec:">hostSpec: aHostSpec	hostSpec := aHostSpec.	self updateHostValuesFrom: aHostSpec</body><body package="MIME" selector="mailServerMenu">mailServerMenu	^self 		userPreferencesAt: #mailServerMenu  		ifAbsentPut: [self initializeFromRegistry asValue]</body><body package="MIME" selector="mailServerName">mailServerName	^self userPreferencesAt: #mailServerName		ifAbsentPut: [ self defaultMailServerName asValue ]</body><body package="MIME" selector="mailServerTypeMenu">mailServerTypeMenu	| menu | 	menu := Menu new.	self registry supportedMailClients 		do: 	[ :each | 			menu			addItemLabel: ( each serverType, ' ', each description asString)			value: each serverType ].	^menu</body><body package="MIME" selector="mailServerTypeMenuAspect">mailServerTypeMenuAspect	^self userPreferencesAt: #mailServerTypeMenuAspect		ifAbsentPut: [ self defaultMailServerTypeMenuAspect asValue ]</body><body package="MIME" selector="mailUserMenuAspect">mailUserMenuAspect	^self 		userPreferencesAt: #mailUserMenuAspect		ifAbsentPut: [ self defaultMailUserMenuAspect asValue ]</body><body package="MIME" selector="netUserMenu">netUserMenu 	^self userListOwner netUserMenu</body><body package="MIME" selector="selectedServer">selectedServer	^self hostSpec</body><body package="MIME" selector="selectedServer:">selectedServer: aHostSpecString	self enableButtons: aHostSpecString notNil.	aHostSpecString notNil 		ifTrue: [ self hostSpec: (self detectServer: aHostSpecString) ]</body><body package="MIME" selector="serverList">serverList 	^self mailServerMenu value menuItems collect: [ :it | it label ]</body><body package="MIME" selector="serverListAspect">serverListAspect 	serverListAspect isNil		ifTrue: 			[serverListAspect := SelectionInList					adapt: self 					aspect: #selectedServer					list: #serverList					selection: #selectedServer:].	^serverListAspect</body></methods><methods><class-id>Net.MailPage</class-id> <category>interface opening</category><body package="MIME" selector="enableButtons">enableButtons	(self builder componentAt: #acceptButton) widget isEnabled: true.</body><body package="MIME" selector="enableButtons:">enableButtons: aBoolean	self builder isNil ifTrue: [^nil].	#( acceptButton removeButton setAsDefaultButton )		do: [ :each | (self widgetAt: each) isEnabled: aBoolean ].</body><body package="MIME" selector="postBuildWith:">postBuildWith: aBuilder	self serverList notEmpty ifTrue: [self serverListAspect 	selectionIndex: 1 ].	self mailServerName onChangeSend: #enableButtons to: self.	self mailServerTypeMenuAspect onChangeSend: #enableButtons to: self.	self mailUserMenuAspect onChangeSend: #enableButtons to: self.</body></methods><methods><class-id>Net.MailPage</class-id> <category>private</category><body package="MIME" selector="detectServer:">detectServer: aString	| item |	^(item := self 			mailServerMenu value menuItems detect: [ :it | (self serverAsString: it value ) = aString ] 			ifNone: [ nil]) isNil		ifTrue: [ HostSpec new ]		ifFalse: [ item value]</body><body package="MIME" selector="initializeFromRegistry">initializeFromRegistry	| menu | 	menu := Menu new.	self defaultIncomingServer: self registry defaultIncomingHost.	self defaultOutgoingServer: self registry defaultOutgoingHost.	self registry mailServers copy		do: 	[ :each |			menu			addItemLabel: (self serverAsString: each)			value: each  ].	^menu</body><body package="MIME" selector="removeMenuItemFor:">removeMenuItemFor: aSpecHostName	|  item |	(item := self mailServerMenu value menuItems 				detect: [ :itemx | itemx value name = aSpecHostName ] 				ifNone: [ nil ] ) notNil		ifTrue: 			[self mailServerMenu value removeItem: item.			self serverListAspect listHolder changed:#value.			manager tickle].</body><body package="MIME" selector="serverAsString:">serverAsString: aHostSpec	| stream |	stream := String new writeStream.	stream nextPutAll: aHostSpec name.	((self defaultIncomingServer notNil 		and: [ aHostSpec name = self defaultIncomingServer name ])	or: [self defaultOutgoingServer notNil		and: [aHostSpec name = self defaultOutgoingServer name]])		ifTrue: [ aHostSpec printDefaultDescriptionOn: stream ]		ifFalse: [ aHostSpec printDescriptionOn: stream ].	^stream contents</body><body package="MIME" selector="setAsDefaultServer:">setAsDefaultServer: aHostSpec	| host |	host :=  (aHostSpec isNil		ifTrue: 			[ self mailServerMenu value menuItems notEmpty 				ifTrue: [self mailServerMenu menuItems first value]				ifFalse: [nil]]		ifFalse: [ aHostSpec ]).	host isNil ifTrue: [ ^nil ].	host isIncomingTypeMail		ifTrue: [ self defaultIncomingServer: host]		ifFalse: [ self defaultOutgoingServer: host].	self mailServerMenu value menuItems do: 		[ :itemx |  itemx label: ( self serverAsString: itemx value )  ].	self updateMenuAspects.	manager tickle.</body><body package="MIME" selector="updateHostValuesFrom:">updateHostValuesFrom: aHostSpec	self mailServerName value: aHostSpec name.	self mailUserMenuAspect value:  aHostSpec netUser.	self mailServerTypeMenuAspect value:  aHostSpec type.</body><body package="MIME" selector="updateMenuAspects">updateMenuAspects	| selectIndex |	selectIndex := self serverListAspect selectionIndex.	self serverListAspect listHolder changed:#value. 	selectIndex notNil		ifTrue: [ self serverListAspect selectionIndex: selectIndex ]</body></methods><methods><class-id>Net.SimpleBody</class-id> <category>defaults</category><body package="MIME" selector="defaultContentType">defaultContentType	^'text/plain'</body></methods><methods><class-id>Net.SimpleBody</class-id> <category>private -- parsing</category><body package="MIME" selector="doParse:">doParse: rfc822Scanner	^rfc822Scanner contents</body></methods><methods><class-id>Net.SimpleBody</class-id> <category>transfer encoding</category><body package="MIME" selector="decodeAs:">decodeAs: encodingName 	| outStream inStream output lineEndConvention |	(#('base64' 'quoted-printable') includes: encodingName) ifFalse: [ ^self].	inStream := self source reset. 	" This code is messy because actual encoding is done differently now because of 	a few glitches. Should be consolidated shortly "	self source isInternal		ifFalse: [ lineEndConvention := self source lineEndConvention].	[encodingName = 'base64' 		ifTrue:			[outStream := (ByteArray new: inStream size * 2 // 3 + 1) writeStream.			self class scannerType decodeBase64From: inStream to: outStream. 			self source: ((StreamEncoder new: self parent charset) == nil				ifTrue: [ outStream contents readStream ]				ifFalse: [ (outStream contents withEncoding: self parent charset ) readStream ]) ].	encodingName = 'quoted-printable' 		ifTrue: 			[output := (self class scannerType decodeQuotedPrintableFrom: inStream).			self source: ((StreamEncoder new: self encoding) == nil				ifTrue: [ output readStream ]				ifFalse: [ (output asByteArray withEncoding: self parent charset ) readStream]) ]	] ensure: [inStream close].	lineEndConvention ~~ nil		ifTrue: [ self source lineEndConvention: lineEndConvention]		ifFalse: [ self source lineEndCR ].</body><body package="MIME" selector="encodeAs:">encodeAs: encodingName 	| outStream lineEndConvention |	(#('base64' 'quoted-printable') includes: encodingName) ifFalse: [^self].	self source isInternal		ifFalse: [ lineEndConvention := self source lineEndConvention].	outStream := (ByteArray new 					withEncoding: self parent charset )					readWriteStream.	lineEndConvention ~~ nil		ifTrue: [outStream lineEndConvention: lineEndConvention].	self encodeAs: encodingName on: outStream.	outStream reset.	self source: outStream</body><body package="MIME" selector="encodeAs:on:">encodeAs: encodingName on: outStream	| inStream |	[inStream := self valueAsStream.	inStream isNil ifTrue: [^self].	encodingName = 'base64' 		ifTrue: [self class scannerType encode: inStream asBase64To: outStream].	encodingName = 'quoted-printable' 		ifTrue: [self class scannerType encode: inStream asQuotedPrintableTo: outStream]	] 		ensure: [inStream close].</body><body package="MIME" selector="needsContentTransferEncoding">needsContentTransferEncoding	^self class scannerType 			needsTransferEncoding: self valueAsStream mimeType: self mimeType</body></methods><methods><class-id>Net.SimpleBody</class-id> <category>accessing</category><body package="MIME" selector="byteSource">byteSource	^byteSource</body><body package="MIME" selector="byteSource:">byteSource: aByteArrayStream	self setByteSource: aByteArrayStream</body><body package="MIME" selector="byteSourceSize">byteSourceSize	^byteSource isNil		ifTrue: [ 0 ]		ifFalse: [byteSource size]</body><body package="MIME" selector="byteValueAsStream">byteValueAsStream	"The method is used for Http message printing.  Answer stream representing value. If value has been set, make stream out of it. Otherwise just use source stream. Reset the stream before returning. If the source contains non-ASCII chars convert it to an EncodedString."	| stream |	byteSource notNil ifTrue: [ ^byteSource reset ].	^self source == nil		ifTrue: [ByteArray new readStream]		ifFalse: 			[ self source isInternal				ifTrue: 					[stream := EncodedStream								on: ( ReadWriteStream on: (ByteArray new: self source size))								encodedBy: (StreamEncoder new: (self parent charsetIfNone: [#ISO8859_1 ]))  												initializeForMemory.					stream lineEndCRLF.					self source reset.					[ self source atEnd]						whileFalse: [ stream nextPut: self source next ]. 					stream binary; reset ]				ifFalse: 					[" Attachment " 					self source reset ]]</body><body package="MIME" selector="contentLength">contentLength" Answer content length in octets, nil if not known "	^self parent contentLength</body><body package="MIME" selector="contentsSpecies">contentsSpecies	^self parent contentsSpecies</body><body package="MIME" selector="contentTypeEncoding">contentTypeEncoding	" Answer symbolic name of the character encoding for this body "	^self parent notNil		ifTrue: [self parent contentTypeEncoding]		ifFalse: [#default]</body><body package="MIME" selector="contentTypeSpecies">contentTypeSpecies	^self parent contentTypeSpecies</body><body package="MIME" selector="decodedValue">decodedValue	^self decodedValueWith:  self class defaultCharsetEncoder.</body><body package="MIME" selector="decodedValueWith:">decodedValueWith: aSymbol	^self parent canBeDecoded 		ifTrue: 			[self byteSource notNil				ifTrue: [(self byteSource contents withEncoding: aSymbol) readStream contents]				ifFalse: 					[(self source encodedContents asByteArray withEncoding: aSymbol ) 						readStream  						lineEndConvention: self source lineEndConvention; 						contents]]		ifFalse: 			[ self value ]</body><body package="MIME" selector="encoding">encoding	" Answer symbolic name of the character encoding for this body "	^self parent notNil		ifTrue: [self parent encoding]		ifFalse: [#default]</body><body package="MIME" selector="partAt:">partAt: anInteger	self shouldNotImplement</body><body package="MIME" selector="parts">parts	^OrderedCollection new</body><body package="MIME" selector="removePart:">removePart: aMimeEntity	self shouldNotImplement</body><body package="MIME" selector="removePartAt:">removePartAt: anInteger	self shouldNotImplement</body><body package="MIME" selector="size">size	^source notNil		ifTrue: [ self sourceSize ]		ifFalse: [ self byteSourceSize ]</body><body package="MIME" selector="source:">source: aStream	source := aStream.	byteSource := nil</body><body package="MIME" selector="sourceForDigest">sourceForDigest	(source isNil and: [byteSource isNil]) 		ifTrue: [^String new readStream].	^(source isNil		ifTrue: [ byteSource ]		ifFalse: [ source ]) reset</body><body package="MIME" selector="sourceLineEndConvention">sourceLineEndConvention	^self source isNil		ifTrue: [nil]		ifFalse: 			[self source isInternal				ifTrue: [ LineEndCR ]				ifFalse: [ self source lineEndConvention]]</body><body package="MIME" selector="value:">value: anArray	self source: anArray readStream</body><body package="MIME" selector="valueAsStream">valueAsStream	" Answer stream representing value. If value has been set, make stream out of it. Otherwise just use source stream. Reset the stream before returning.	If the source contains non-ASCII chars convert it to an EncodedString."	| encoding contents |	^self source == nil		ifTrue: [String new readStream]		ifFalse: 			[ self source isInternal				ifTrue: 					[contents := self source reset contents.					encoding := self encodingFor:  contents.					encoding ~~ nil						ifTrue: [contents := (contents asByteArrayEncoding: encoding ) asString].					contents readStream]				ifFalse: 					[" Attachment " 					self source reset ]]</body></methods><methods><class-id>Net.SimpleBody</class-id> <category>writing</category><body package="MIME" selector="writeContentsOn:">writeContentsOn: aStream	| sourceStream |	sourceStream := self valueAsStream.	[[sourceStream atEnd] 		whileFalse: 			[aStream nextPut: sourceStream next]]		ensure: [sourceStream close].</body><body package="MIME" selector="writeOn:">writeOn: aStream" Writing can be different from printing. Printing may be indented, abbreviatedand otherwise formatted for readability. Writing is used to actually send message.Default implementation is the same "	self writeContentsOn: aStream</body></methods><methods><class-id>Net.SimpleBody</class-id> <category>visiting</category><body package="MIME" selector="acceptVisit:with:">acceptVisit: aVisitor with: argument	^aVisitor acceptSimpleBody: self with: argument</body></methods><methods><class-id>Net.SimpleBody</class-id> <category>printing</category><body package="MIME" selector="printForDisplayOn:">printForDisplayOn: aStream	self isBinary		ifTrue: [self printOn: aStream]		ifFalse: [self writeOn: aStream]</body></methods><methods><class-id>Net.SimpleBody</class-id> <category>private</category><body package="MIME" selector="encodingFor:">encodingFor: aByteString	^parent charsetIfNone: [MimeEncodedWordCoDec findEncodingFor: aByteString ].</body><body package="MIME" selector="getValue">getValue	^self source isNil		ifTrue: [self getValueFromByteSource]		ifFalse: [[self source reset; contents] ensure: [self source close]]</body><body package="MIME" selector="getValueFromByteSource">getValueFromByteSource	| c encoding |	^byteSource isNil 		ifTrue: [ nil]		ifFalse: 			[c := byteSource reset; contents.			self parent canBeDecoded				ifTrue:					[encoding := self parent charsetIfNone: [nil ].					encoding isNil						ifTrue: [ c ]						ifFalse: [ (c asByteArray withEncoding: encoding ) readStream contents ]]				ifFalse: [ c ]]</body><body package="MIME" selector="setByteSource:">setByteSource: aByteArrayStream	source notNil ifTrue: [ source close. source := nil ].	byteSource := aByteArrayStream</body></methods><methods><class-id>Net.SimpleBody</class-id> <category>mutating</category><body package="MIME" selector="addPart:">addPart: part	(self parent bot		makeMultipart: self parent) 		addPart: part;		yourself</body></methods><methods><class-id>Net.SimpleBody class</class-id> <category>accessing settings</category><body package="MIME" selector="defaultCharsetEncoder">defaultCharsetEncoder	^DefaultCharsetEncoder isNil		ifTrue: [ DefaultCharsetEncoder := self defaultCharsetEncoderValue ]		ifFalse: [ DefaultCharsetEncoder ]</body><body package="MIME" selector="defaultCharsetEncoder:">defaultCharsetEncoder: aString	DefaultCharsetEncoder := aString</body></methods><methods><class-id>Net.SimpleBody class</class-id> <category>defaults</category><body package="MIME" selector="defaultCharsetEncoderValue">defaultCharsetEncoderValue	^Locale current defaultEncoding</body></methods><methods><class-id>Net.MimeScanner</class-id> <category>constants</category><body package="MIME" selector="boundaryDashes">boundaryDashes	^'--'</body></methods><methods><class-id>Net.MimeScanner</class-id> <category>private</category><body package="MIME" selector="nextMimeToken">nextMimeToken	| char |	self skipWhiteSpace.	char := self peek.	char isNil				"end of input"		ifTrue: [tokenType := #doIt.			^token := nil].	char == $( ifTrue: [^self scanComment; nextToken].	char == $" ifTrue: [^self scanQuotedText].	(self specials includes: char)		ifTrue: [tokenType := #special.		" Special character. Make it token value and set token type "				^token := self next.].	(self matchCharacterType: TokenMask)		ifTrue: [^self scanToken].	tokenType := #doIt.	token := char.	^token</body></methods><methods><class-id>Net.MimeScanner</class-id> <category>tokenization</category><body package="MIME" selector="nextToken">nextToken	^self nextMimeToken</body><body package="MIME" selector="specials">specials" This method is provided to encapsulate lexical differences between RFC822 on one side, and MIME, HTTP on the other side. MIME definiton of 'tspecials' is the same as the RFC 822 definition of ''specials' with the addition of the three characters &lt;/&gt;, &lt;?&gt;, and &lt;=&gt;, and the removal of &lt;.&gt;. To present uniform tokenization interface, this method is overridden in Mime scanner "	^self class tspecials</body></methods><methods><class-id>Net.MimeScanner</class-id> <category>multi-character scans</category><body package="MIME" selector="scanQuotedText">scanQuotedText"RFC 2183: `tspecials' and `value' are defined according to RFC 2045. RFC2045 defines     parameter := attribute '=' value     value := token / quoted-string     token := 1*&lt;any (US-ASCII) CHAR except SPACE, CTLs, or tspecials&gt;     tspecials :=  (  ) &lt;  &gt;  @  ,  ;  :  \   /  [ ] ? =     - Must be in quoted-string  to use within parameter values"	" We are positioned at the first double quote character "	token := self scanToken: [ self  matchCharacterType: MimeQuotedTextMask ] delimitedBy: '""' notify: (#UnmatchedQuotedText &lt;&lt; #net &gt;&gt; 'Unmatched quoted text').	tokenType := #quotedText. 	^token.</body><body package="MIME" selector="scanToBoundary:">scanToBoundary: boundary" Scan for specified boundary (RFC2046, p5.1). Answer scanned text from current position up to the beginning of the boundary. Stream is positioned after end of the boundary lineSecond element is either #next or #last. #next means the boundary found is not the last one. #last means the boundary is the closing boundary for the multi-part body (that is, it looks like '--&lt;boundary&gt;--) "	| string |	string := self upToAll: (self boundaryDashes , boundary).	self upTo: Character cr.					" Skip to the end of line "	^string.</body><body package="MIME" selector="scanToken">scanToken" MIME and HTTP: token  =  1*&lt;any CHAR except tspecials, SPACE and CTLs&gt;. That is, 'token' is analogous to RFC822 'atom' except set of Mime's set of tspecials characters includes three more characters as compared to set of 'specials' in RFC822"	token := self scanTokenMask: TokenMask.	tokenType := #token.	^token</body></methods><methods><class-id>Net.MimeScanner</class-id> <category>printing</category><body package="MIME" selector="printPhrase:on:">printPhrase: phrase on: stream	self class printPhrase: phrase on: stream</body></methods><methods><class-id>Net.MimeScanner class</class-id> <category>text encoding/decoding</category><body package="MIME" selector="decodeBase64From:to:">decodeBase64From: inStream to: outStream	"Decode input stream from base64 to output stream. outStream is an encoded stream "	| string |	[inStream atEnd]		whileFalse: 			[(string := inStream upTo: Character cr) notEmpty				ifTrue: [	self decodeBase64From: 1 to: string size in: string on: outStream]].</body><body package="MIME" selector="decodeBase64From:to:in:">decodeBase64From: startIndex to: endIndex in: aString	"Decode aString from startIndex to endIndex in base64."	| codeChars decoder output index cr endChars end limit padding data sz |	codeChars := 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.	decoder := (0 to: 255) collect: [:n| (codeChars indexOf: (n + 1) asCharacter) - 1].	decoder replaceAll: -1 with: 0.	output := (data := ByteString new: endIndex - startIndex * 3 // 4) writeStream.	index := startIndex.	cr := Character cr.	"There is padding at the end of a base64 message if the content is not a multiple of	 3 bytes in length.  The padding is either two ='s to pad-out a trailing byte, 1 = to	 pad out a trailing pair of bytes, or no padding.  Here we count the padding.  After	 processing the message we cut-back by the amount of padding."	end := endIndex min: (sz := aString size).	endChars := codeChars, (String with: $=).	[(endChars includes: (aString at: end))	and: [end = endIndex or: [(aString at: end + 1) = cr]]] whileFalse: [end := end - 1].	limit := end.	padding := 0.	[(aString at: end) == $=] whileTrue: [padding := padding - 1. end := end - 1].	[index &lt;= limit] whileTrue:		[| triple |		triple :=    ((decoder at: (aString at: index     ) asInteger) bitShift: 18)				+ ((decoder at: (aString at: index + 1) asInteger) bitShift: 12)				+ ((decoder at: (aString at: index + 2) asInteger) bitShift:  6)				+  (decoder at: (aString at: index + 3) asInteger).		output nextPut: (Character value: (triple digitAt: 3)).		output nextPut: (Character value: (triple digitAt: 2)).		output nextPut: (Character value: (triple digitAt: 1)).		index := index + 4.		[(index &gt; sz or: [(aString at: index) = cr])		and: [index &lt;= limit]] whileTrue: [index := index + 1]].	padding ~= 0 ifTrue: [output skip: padding].	^data copyFrom: 1 to: output position.</body><body package="MIME" selector="decodeBase64From:to:in:on:">decodeBase64From: startIndex to: endIndex in: aString on: output	"Decode aString from startIndex to endIndex in base64." 	| codeChars decoder index cr endChars end limit padding sz |	codeChars := 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.	decoder := (0 to: 255) collect: [:n| (codeChars indexOf: (n + 1) asCharacter) - 1].	decoder replaceAll: -1 with: 0.	index := startIndex.	cr := Character cr.	"There is padding at the end of a base64 message if the content is not a multiple of	 3 bytes in length.  The padding is either two ='s to pad-out a trailing byte, 1 = to	 pad out a trailing pair of bytes, or no padding.  Here we count the padding.  After	 processing the message we cut-back by the amount of padding."	end := endIndex min: (sz := aString size).	endChars := codeChars, (String with: $=).	[(endChars includes: (aString at: end))	and: [end = endIndex or: [(aString at: end + 1) = cr]]] whileFalse: [end := end - 1].	limit := end.	padding := 0.	[(aString at: end) == $=] whileTrue: [padding := padding - 1. end := end - 1].	[index &lt;= limit] whileTrue:		[| triple |		triple :=    ((decoder at: (aString at: index     ) asInteger) bitShift: 18)				+ ((decoder at: (aString at: index + 1) asInteger) bitShift: 12)				+ ((decoder at: (aString at: index + 2) asInteger) bitShift:  6)				+  (decoder at: (aString at: index + 3) asInteger).		output nextPut: (triple digitAt: 3).		output nextPut: (triple digitAt: 2).		output nextPut: (triple digitAt: 1).		index := index + 4.		[(index &gt; sz or: [(aString at: index) = cr])		and: [index &lt;= limit]] whileTrue: [index := index + 1]].	padding ~= 0 ifTrue: [output skip: padding].	^output</body><body package="MIME" selector="decodeQuotedPrintableFrom:">decodeQuotedPrintableFrom: input	"Decode aString from startIndex to endIndex in quoted-printable."	^self decodeQuotedPrintableFrom: input on: (ByteString new: input size ) writeStream.</body><body package="MIME" selector="decodeQuotedPrintableFrom:on:">decodeQuotedPrintableFrom: inputStream on: outputStream	"Decode aString from startIndex to endIndex in quoted-printable."	|  char n1 n2 |	[inputStream atEnd] whileFalse:		[char := inputStream next.		$= == char			ifTrue:				[('0123456789ABCDEF' includes: (n1 := inputStream next)) 					ifTrue:						[n2 := inputStream next.						outputStream nextPut: ((n1 digitValue bitShift: 4) + n2 digitValue) asCharacter]]					ifFalse: 	[outputStream nextPut: char]].	^outputStream contents</body><body package="MIME" selector="decodeQuotedPrintableFrom:to:in:">decodeQuotedPrintableFrom: startIndex to: endIndex in: aString	"Decode aString from startIndex to endIndex in quoted-printable."	^self decodeQuotedPrintableFrom: (ReadStream on: aString from: startIndex to: endIndex)</body><body package="MIME" selector="decodeUUEncodedFrom:to:in:">decodeUUEncodedFrom: startIndex to: farEndIndex in: aString	"decode aString from startIndex to farEndIndex as uuencode-encoded"	| endIndex i cr space output data |	endIndex := farEndIndex - 2.	[endIndex &lt;= startIndex	or: [(aString at: endIndex + 1) = $e		and: [(aString at: endIndex + 2) = $n		and: [(aString at: endIndex + 3) = $d]]]]		whileFalse:			[endIndex := endIndex - 1].	i := (aString			findString: 'begin'			startingAt: startIndex			ignoreCase: true			useWildcards: false) first.	i = 0 ifTrue: [i := startIndex].	cr := Character cr.	space := Character space asInteger.	output := (data := ByteString new: endIndex - startIndex * 3 // 4) writeStream.	[[i &lt; endIndex	and: [(aString at: i) ~= cr]] whileTrue: [i := i + 1].	i &lt; endIndex] whileTrue:		[| count |		count := (aString at: (i := i + 1)) asInteger - space bitAnd: 8r77.		i := i + 1.		count = 0			ifTrue: [i := endIndex]			ifFalse:				[[count &gt; 0] whileTrue:					[| m n o p |					m := (aString at: i) asInteger - space bitAnd: 8r77.					n := (aString at: i + 1) asInteger - space bitAnd: 8r77.					o :=  (aString at: i + 2) asInteger - space bitAnd: 8r77.					p :=  (aString at: i + 3) asInteger - space bitAnd: 8r77.					count &gt;= 1 ifTrue:						[output nextPut: (Character value: (m bitShift: 2) + (n bitShift: -4)).						count &gt;= 2 ifTrue:							[output nextPut: (Character value: ((n bitShift: 4) + (o bitShift: -2) bitAnd: 16rFF)).							count &gt;= 3 ifTrue:								[output nextPut: (Character value: ((o bitShift: 6) + p bitAnd: 16rFF))]]].					i := i + 4.					count := count - 3]]].	^data copyFrom: 1 to: output position</body><body package="MIME" selector="encode:asBase64To:">encode: inStream asBase64To: outStream	"Encode the input as base64 to outStream."	| codeChars buffer lineLength count end column a b c in convertToByteArray chunkSize temp |	codeChars := 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.	column := 0.	" Ugly code to ensure the the underlying array is bytes "	in := inStream.	[in binary] on: Error do: [ :ex | ex return].	convertToByteArray := in contentsSpecies includesBehavior: String.	lineLength := 76.	chunkSize := (lineLength / 4 * 3) asInteger.	[convertToByteArray		ifTrue: 			[temp := in nextAvailable: chunkSize.			buffer := temp asByteArrayEncoding: temp stringEncoding streamEncodingType.			count := buffer size]		ifFalse:			[buffer := ByteArray new: chunkSize.			count := buffer size.			[in next: buffer size into: buffer startingAt: 1]				on: Stream incompleteNextCountSignal				do: [:ex| count := ex parameter. ex return]].	end := count // 3 * 3.	1 to: end by: 3 do:		[:i|		(column := column + 4) &gt; lineLength ifTrue:			[outStream cr. column := 0].		a := buffer at: i.		b := buffer at: i + 1.		c := buffer at: i + 2.		outStream			nextPut: (codeChars at: (a bitShift: -2) + 1);			nextPut: (codeChars at: (((a bitShift: 4) + (b bitShift: -4)) bitAnd: 16r3F) + 1);			nextPut: (codeChars at: (((b bitShift: 2) + (c bitShift: -6)) bitAnd: 16r3F) + 1);			nextPut: (codeChars at: (c bitAnd: 16r3F) + 1)].	(column := column + 4) &gt; lineLength ifTrue:		[outStream cr. column := 0].	count - end = 1 ifTrue: "one byte left to write"		[a := buffer at: end + 1.		 outStream			nextPut: (codeChars at: (a bitShift: -2) + 1);			nextPut: (codeChars at: ((a bitShift: 4) bitAnd: 16r3F) + 1);			nextPut: $=;			nextPut: $=].	count - end = 2 ifTrue: "two bytes left to write"		[a := buffer at: end + 1.		 b := buffer at: end + 2.		 outStream			nextPut: (codeChars at: (a bitShift: -2) + 1);			nextPut: (codeChars at: (((a bitShift: 4) + (b bitShift: -4)) bitAnd: 16r3F) + 1);			nextPut: (codeChars at: ((b bitShift: 2) bitAnd: 16r3F) + 1);			nextPut: $=].	count &gt; 0] whileTrue</body><body package="MIME" selector="encode:asQuotedPrintableTo:">encode: inStream asQuotedPrintableTo: outStream	"Encode the input as printed-quotable to outStream.  Ensure that leading '.'	 characters are encoded so that mailers which interpret '.' at the beginning	 of line as an end-of-message indicator are not confused by '.'s in the body	 of a message."	| cr tab spaceCode encoder column ch code |	cr := Character cr.	tab := Character tab.	spaceCode := Character space asInteger.	encoder := '0123456789ABCDEF'.	column := 0.	[(ch := inStream next) == nil] whileFalse:		[ch = cr			ifTrue:				[outStream nextPut: cr.				 column := 0]			ifFalse:				[(column := column + 1) &gt;= 76 ifTrue:					[outStream nextPut: $=; nextPut: Character cr. column := 1].				((code := ch asInteger) &lt; 127				  and: 					[						((code &gt;= spaceCode or: [ch == tab])						  and: [ch ~~ $. or: [column &gt; 1]]) 							and: [ ch ~~ $_ ]					]				)					ifTrue:						[outStream nextPut: ch]					ifFalse:						[outStream							nextPut: $=;							nextPut: (encoder at: (code bitShift: -4) + 1);							nextPut: (encoder at: (code bitAnd: 16rF) + 1).						column := column + 2]]]</body></methods><methods><class-id>Net.MimeScanner class</class-id> <category>testing</category><body package="MIME" selector="isTokenChar:">isTokenChar: char	^((self classificationMaskFor: char ) bitAnd: TokenMask) ~= 0</body><body package="MIME" selector="needsTransferEncoding:mimeType:">needsTransferEncoding: aStream mimeType: aMimeTypeDescriptor	"Answer true if the object needs to be transfer-encoded because it contains 	8-bit values or lines are too long, etc. 	For now on, answer true for non-binary streams. Scan character strings looking for 8-bit characters 	and answer true if one is found. Otherwise answer false"	| savePos |	aMimeTypeDescriptor isBinary ifTrue: [ ^true ].	((aStream respondsTo: #isBinary) and: [aStream isBinary])		ifTrue: [^true].	savePos := aStream position.	[aStream reset.	[aStream atEnd]		whileFalse: [aStream next asInteger &gt; 127 ifTrue: [^true]]]		ensure: [aStream position: savePos].	^false</body><body package="MIME" selector="shouldBeQuoted:">shouldBeQuoted: string	^(string detect: [ :char | (self isTokenChar: char) not ] ifNone: [ nil ]) notNil</body></methods><methods><class-id>Net.MimeScanner class</class-id> <category>printing</category><body package="MIME" selector="printPhrase:on:">printPhrase: phrase on: stream	MimeEncodedWordCoDec decodePhrase: phrase printOn: stream</body><body package="MIME" selector="printToken:tokenType:on:">printToken: value tokenType: aSymbol on: stream	aSymbol == #special 		ifTrue: [stream nextPut: value]		ifFalse: 			[aSymbol == #token				ifTrue: [stream nextPutAll: value]				ifFalse: [stream nextPutAll: '"', value, '"' ]]</body></methods><methods><class-id>Net.MimeScanner class</class-id> <category>class initialization</category><body package="MIME" selector="initClassificationTable">initClassificationTable	super initClassificationTable.	self initClassificationTableWith: MimeQuotedTextMask when:		[:c | c ~~ $" and: [ c ~~ Character cr ]].</body><body package="MIME" selector="initialize">initialize	" MimeScanner initialize "	self initializeConstants; initClassificationTable</body><body package="MIME" selector="initializeConstants">initializeConstants	MimeQuotedTextMask := 32768.</body></methods><methods><class-id>Net.NetworkAddressParser</class-id> <category>private</category><body package="MIME" selector="completeScanOfAddressSpecWith:">completeScanOfAddressSpecWith: partial" addr-spec   =  local-part &lt;@&gt; domain        ; global address  local-part = word *(&lt;.&gt; word) ; uninterpreted, case-preserved First local-part token was already scanned; we are now scanning *(&lt;.&gt; word) group and domain part.Partial is an array of tokens already read "	| stream pos |	stream := partial readWriteStream.	stream setToEnd.	self descriptor localPart: (self scanLocalAddressPartTo: stream ).	pos := self position.	self nextRFC822Token == $@ 		ifTrue: [self descriptor domain: self scanDomain]		ifFalse:[self position: pos].</body><body package="MIME" selector="newAddressDescriptor">newAddressDescriptor	^NetworkAddressDescriptor new</body><body package="MIME" selector="parseGroupSpecWith:">parseGroupSpecWith: phrase 	"group = phrase &lt;:&gt; [#mailbox] &lt;;&gt;"	| group mailboxes phrasex comment stream |	mailboxes := self tokenizeList: [self parseAddress]				separatedBy: [token == $,].	self nextRFC822Token == $; ifFalse: [^self notify: (#GroupDescriptorShouldBeTerminated &lt;&lt; #net &gt;&gt; 'Group descriptor should be terminated by &lt;:&gt;')].	group := MailGroupDescriptor new.	" If phrase is non-empty, an alias was specified "	phrasex := phrase isEmpty 				ifTrue: [nil] 				ifFalse: [self phraseAsString: phrase].	comment := currentComment isNil				ifTrue: [nil]				ifFalse: 					[stream := (String new: 64) writeStream.					currentComment do: [:part | stream nextPutAll: part]						separatedBy: [stream space].					stream contents].	group alias: phrasex; addresses: mailboxes; comment: comment.	^group</body><body package="MIME" selector="parseMailboxSpecWith:">parseMailboxSpecWith: phrasex"     address     =  mailbox                      ; one addressee		                 /  group                        ; named list     group       =  phrase &lt;:&gt; [#mailbox] &lt;;&gt;     mailbox     =  addr-spec                    ; simple address                 /  phrase route-addr            ; name &amp; addr-spec     route-addr  =  &lt;&lt;&gt; [route] addr-spec &lt;&gt;&gt;     route       =  1#(&lt;@&gt; domain) &lt;:&gt;           ; path-relative"	| phrase tok local stream comment |	phrase := phrasex. 	tok := self nextRFC822Token.	self descriptor: self newAddressDescriptor.	"Variations of mailbox spec"	tok = $&lt; ifTrue:								"Phil Campbell&lt;philc@acme.com&gt;"		[self stepBack; scanRouteAndAddress]	ifFalse: [		('.@' includes: tok)			ifTrue: 				["These ones should have a non-empty local part to the left of delimiter"				phrase isEmpty ifTrue: [self error: (#InvalidNetworkAddress &lt;&lt; #net &gt;&gt; 'Invalid network address')].				local := Array with: phrase last.				phrase := phrase copyFrom: 1 to: phrase size - 1.	"Extract the part we already scanned"				tok = $. ifTrue:							"phil.campbell.wise@acme.com&gt;"					[self stepBack; completeScanOfAddressSpecWith: local].				tok = $@								"philc@acme.com&gt;"					ifTrue: 						[self descriptor localPart: local.						self descriptor domain: self scanDomain]]				ifFalse: [self stepBack]].	" If phrase is non-empty, an alias was specified "	phrase := phrase isEmpty 				ifTrue: [phrase := nil] 				ifFalse: [self phraseAsString: phrase].	self descriptor alias: phrase.	comment := currentComment == nil				ifTrue: [nil]				ifFalse: 					[stream := (String new: 64) writeStream.					currentComment do: [:part | stream nextPutAll: part]						separatedBy: [stream space].					stream contents].	self descriptor comment: comment.	^self descriptor</body><body package="MIME" selector="scanLocalAddressPartTo:">scanLocalAddressPartTo: stream 	"local-part = word *(&lt;.&gt; word) ; uninterpreted, case-preserved 	Part of local part may have been scanned already, it's in localPart of the descriptor"		self 		tokenizeWhile: [token == $.] 		do: [stream nextPut: self scanWord].	^stream contents</body><body package="MIME" selector="tryScanSubdomain">tryScanSubdomain	self nextRFC822Token.	tokenType = #atom ifTrue: [ ^true ].	(token = $[) ifTrue: [ self stepBack; scanDomainText. ^true ].	^false.</body></methods><methods><class-id>Net.NetworkAddressParser</class-id> <category>accessing</category><body package="MIME" selector="descriptor">descriptor	^descriptor</body><body package="MIME" selector="descriptor:">descriptor: aValue	descriptor := aValue</body></methods><methods><class-id>Net.NetworkAddressParser</class-id> <category>initialize-release</category><body package="MIME" selector="initialize">initialize	super initialize.	descriptor := self newAddressDescriptor</body></methods><methods><class-id>Net.NetworkAddressParser</class-id> <category>public</category><body package="MIME" selector="addressesFrom:">addressesFrom: stream	^(self on: stream) parseAddressesSeparatedBy: $,</body><body package="MIME" selector="parse:">parse: aString 	^self on: aString readStream; parseAddress</body><body package="MIME" selector="parseAddress">parseAddress"     address     =  mailbox                      ; one addressee		                 /  group                        ; named list     group       =  phrase &lt;:&gt; [#mailbox] &lt;;&gt;     mailbox     =  addr-spec                    ; simple address                 /  phrase route-addr            ; name &amp; addr-spec     route-addr  =  &lt;&lt;&gt; [route] addr-spec &lt;&gt;&gt;     route       =  1#(&lt;@&gt; domain) &lt;:&gt;           ; path-relative"	| phrase decodePhrase | 	phrase := self scanPhrase.	(phrase isEmpty and: [self atEnd]) ifTrue: [ ^nil ].  	decodePhrase := Array with: (MimeEncodedWordCoDec decodePhrase: phrase).	^self nextRFC822Token = $: 		ifTrue: [self parseGroupSpecWith: decodePhrase]		ifFalse: [self stepBack; parseMailboxSpecWith: decodePhrase].</body><body package="MIME" selector="parseAddressesSeparatedBy:">parseAddressesSeparatedBy: separatorChar	^self tokenizeList: [self parseAddress]				separatedBy: [token == separatorChar].</body><body package="MIME" selector="scanDomain">scanDomain	"domain = sub-domain *(&lt;.&gt; sub-domain)"	"Answers an array of domain seqments, from least significant to most significant"	^self tokenizeList: [self nextRFC822Token.		tokenType = #atom			ifTrue: [token]			ifFalse: [token = $[					ifTrue: [self stepBack; scanDomainText]					ifFalse: [^self notify: (#InvalidDomainSpecification &lt;&lt; #net &gt;&gt; 'Invalid domain specification')]]]		separatedBy: [token == $.]</body><body package="MIME" selector="scanLocalAddress">scanLocalAddress	"local-part = word *(&lt;.&gt; word) ; uninterpreted, case-preserved"	^self		tokenizeList: 			[self nextRFC822Token.			(#(#quotedText #atom) includes: tokenType)				ifFalse: [^self notify: (#LocalPartcanOnlyIncludeWords &lt;&lt; #net &gt;&gt; 'Local part can only include words')].			token]		separatedBy: [token == $.]</body><body package="MIME" selector="scanRoute">scanRoute	"route = 1#(&lt;@&gt; domain) &lt;:&gt; ; path-relative"	| stream |	stream := (Array new: 2) writeStream.	[self nextRFC822Token == $@]		whileTrue: 			[stream nextPut: self scanDomain.			self nextToken = $: ifFalse: [self error: (#InvalidRouteSpec &lt;&lt; #net &gt;&gt; 'Invalid route spec')]].	stream size = 0 ifTrue: [self error: (#InvalidRouteSpec &lt;&lt; #net &gt;&gt; 'Invalid route spec')].	^stream contents</body><body package="MIME" selector="scanRouteAndAddress">scanRouteAndAddress"     route-addr  =  &lt;&lt;&gt; [route] addr-spec &lt;&gt;&gt;"	self mustMatch: $&lt; notify: (#InvalidRouteAddressSpec &lt;&lt; #net &gt;&gt; 'Invalid route address spec').		self nextRFC822Token == $@ ifTrue: [ self stepBack. self descriptor route: self scanRoute ].	self completeScanOfAddressSpecWith: (Array with: token).	self mustMatch: $&gt; notify: (#InvalidRouteAddressSpec &lt;&lt; #net &gt;&gt; 'Invalid route address spec').</body></methods><methods><class-id>Net.NetworkAddressParser</class-id> <category>converting</category><body package="MIME" selector="phraseAsString:">phraseAsString: phrase	| stream |	stream := (String new: 64) writeStream.	MimeScanner printPhrase: phrase on: stream. 	^stream contents.</body></methods><methods><class-id>Net.NetworkAddressParser class</class-id> <category>utility</category><body package="MIME" selector="addressesFrom:">addressesFrom: stream	"self addressesFrom: 'kyasu@crl.fujixerox.co.jp' readStream."	"self addressesFrom: 'Kazuki Yasumatsu &lt;kyasu@crl.fujixerox.co.jp&gt;' readStream."	"self addressesFrom: 'kyasu@crl.fujixerox.co.jp (Kazuki Yasumatsu)' readStream."	"self addressesFrom: ' kyasu1, kyasu2, Kazuki Yasumatsu &lt;kyasu3&gt;, kyasu4 (Kazuki Yasumatsu)' readStream."	"self addressesFrom: ' foo bar, kyasu1, ,  Kazuki Yasumatsu &lt;kyasu2&gt; &lt;kyasu3&gt; (&lt;foo&gt; (foo bar), bar)' readStream."	^(self on: stream) parseAddressesSeparatedBy: $,</body><body package="MIME" selector="addressFrom:">addressFrom: stream	"self addressFrom: 'kyasu@crl.fujixerox.co.jp'."	"self addressFrom: 'Kazuki Yasumatsu &lt;kyasu@crl.fujixerox.co.jp&gt;'."	"self addressFrom: 'kyasu@crl.fujixerox.co.jp (Kazuki Yasumatsu)'."	^(self on: stream) parseAddress</body></methods><methods><class-id>Net.NetworkAddressParser class</class-id> <category>instance creation</category><body package="MIME" selector="parse:">parse: string	^self new parse: string</body></methods><methods><class-id>Net.ValueWithParametersField</class-id> <category>accessing</category><body package="MIME" selector="canMerge">canMerge	^true</body><body package="MIME" selector="defaultSeparators">defaultSeparators	^self class defaultSeparators</body><body package="MIME" selector="element">element	self first isNil		ifTrue: [ self value add: (ValueWithParams newWithSeparators: self separators)].	^self first</body><body package="MIME" selector="elementParams">elementParams 	^self element params</body><body package="MIME" selector="first">first	^self value first</body><body package="MIME" selector="groupSeparator">groupSeparator	^self separators at: 3</body><body package="MIME" selector="parametersSeparator">parametersSeparator	^self separators at: 2</body><body package="MIME" selector="separators">separators	separators isNil 		ifTrue: [ separators := self defaultSeparators].	^separators</body><body package="MIME" selector="separators:">separators: anArray	separators := anArray</body><body package="MIME" selector="value">value	^value isNil		ifTrue: [ value := OrderedCollection new]		ifFalse: [value]</body><body package="MIME" selector="valueSeparator">valueSeparator	^self separators first</body><body package="MIME" selector="valueWithParamsClass">valueWithParamsClass	^ValueWithParams</body></methods><methods><class-id>Net.ValueWithParametersField</class-id> <category>composing</category><body package="MIME" selector="writeValueOn:encoding:">writeValueOn: aStream encoding: aString	self printValueOn: aStream</body></methods><methods><class-id>Net.ValueWithParametersField</class-id> <category>parsing</category><body package="MIME" selector="doParse:">doParse: scanner	| list |	list := OrderedCollection new: 5.	[scanner atEnd ]		whileFalse: 			[list add: 				((self valueWithParamsClass newWithSeparators: self separators)						readFrom: scanner;						yourself ). 			(scanner atEnd not and: [self groupSeparator ~~ Character space])				ifTrue: 					[scanner skipWhiteSpace. 					(scanner next == self groupSeparator) 						ifFalse: 							[Transcript cr; show: (#DetectedInvalidField &lt;&lt; #net &gt;&gt; 'Detected invalid field:'); cr; show: scanner contents.							scanner upTo: self groupSeparator]]].	^list</body></methods><methods><class-id>Net.ValueWithParametersField</class-id> <category>printing</category><body package="MIME" selector="printValueOn:">printValueOn: aStream 	self value notNil		ifTrue: 			[self value  				do: [ :param |  param printOn: aStream]				separatedBy: [aStream nextPut: self groupSeparator ]]		ifFalse: [ aStream nextPutAll: '' ].	aStream cr.</body></methods><methods><class-id>Net.ValueWithParametersField</class-id> <category>adding</category><body package="MIME" selector="add:">add: aValueWithParametersFields	self value addAll: aValueWithParametersFields value</body></methods><methods><class-id>Net.ValueWithParametersField class</class-id> <category>defaults</category><body package="MIME" selector="defaultSeparators">defaultSeparators	^self subclassResponsibility</body></methods><methods><class-id>Net.ValueWithParametersField class</class-id> <category>instance creation</category><body package="MIME" selector="newWithSeparators:">newWithSeparators: anArray	^self new		separators: anArray;		yourself</body></methods><methods><class-id>Net.SingleValueWithParametersField</class-id> <category>accessing</category><body package="MIME" selector="canMerge">canMerge	^false</body><body package="MIME" selector="localValue">localValue	^self element value</body><body package="MIME" selector="localValue:">localValue: aString	self element value: aString</body><body package="MIME" selector="parameterAt:">parameterAt: aName 	^self element paramAt: aName</body><body package="MIME" selector="parameterAt:ifAbsent:">parameterAt: aName ifAbsent: aBlock	^self element paramAt: aName ifAbsent: [aBlock value]</body><body package="MIME" selector="parameterAt:put:">parameterAt: aName put: aValue	self element paramAt: aName put: aValue</body><body package="MIME" selector="value">value	value isNil 		ifTrue: [ value := OrderedCollection with: (ValueWithParams newWithSeparators: self separators)].	^value</body></methods><methods><class-id>Net.SingleValueWithParametersField</class-id> <category>parsing</category><body package="MIME" selector="parse:">parse: scanner	value := self doParse: scanner.	value size &gt; 1 ifTrue: [ ^scanner notify: (#WrongParametersNumber &lt;&lt; #net &gt;&gt; 'Wrong parameters number').].</body></methods><methods><class-id>Net.SingleValueWithParametersField</class-id> <category>composing</category><body package="MIME" selector="writeValueOn:encoding:">writeValueOn: aStream encoding: aString" Default implementation is the same as inherited. Subclasses can override it "	self value ~~ nil		ifTrue: 			[self value  				do: [ :param |  param writeOn: aStream encoding: aString ]				separatedBy: [aStream nextPut: self groupSeparator].			aStream cr.].</body></methods><methods><class-id>Net.ContentTypeField</class-id> <category>accessing</category><body package="MIME" selector="boundary">boundary	^self parameterAt: 'boundary'</body><body package="MIME" selector="boundary:">boundary: aString	^self parameterAt: 'boundary' put: aString</body><body package="MIME" selector="charset">charset	| charset |	charset := self parameterAt: 'charset' ifAbsent: [nil]. 	^(charset == nil		ifTrue: 			[ ('text*' match: self contentType)				ifTrue: [ self class defaultCharset]				ifFalse: [ nil ]]		ifFalse: [ charset asLowercase ])</body><body package="MIME" selector="charset:">charset: aName	^aName ~~ nil		ifTrue: [self parameterAt: 'charset' put: aName ]		ifFalse: [ nil]</body><body package="MIME" selector="charsetIfNone:">charsetIfNone: aBlock	| v |	v := self parameterAt: 'charset' ifAbsent: [aBlock value].	^v notNil		ifTrue: [ v asLowercase ]		ifFalse: [ nil ]</body><body package="MIME" selector="contentType">contentType	^self localValue</body><body package="MIME" selector="contentType:">contentType: aString	self localValue:  aString</body><body package="MIME" selector="fileName">fileName	^(self parameterAt: 'name' ifAbsent: [^String new ]) asLowercase</body><body package="MIME" selector="fileName:">fileName: aName	^self parameterAt: 'name' put: aName</body><body package="MIME" selector="subtype">subtype	^(self contentType tokensBasedOn: $/) last.</body><body package="MIME" selector="subtype:">subtype: aString	self type: self type subtype: aString.</body><body package="MIME" selector="type">type	^(self contentType tokensBasedOn: $/) first.</body><body package="MIME" selector="type:">type: aString	self type: aString subtype: self subtype</body><body package="MIME" selector="type:subtype:">type: typeString subtype: subtypeString	self  localValue: (typeString, '/', subtypeString)</body></methods><methods><class-id>Net.ContentTypeField</class-id> <category>testing</category><body package="MIME" selector="isMultipart">isMultipart	^self type = 'multipart'</body></methods><methods><class-id>Net.ContentTypeField class</class-id> <category>parsing</category><body package="MIME" selector="fieldNames">fieldNames	^#('content-type')</body></methods><methods><class-id>Net.ContentTypeField class</class-id> <category>instance creation</category><body package="MIME" selector="applicationOctetStream">applicationOctetStream	" self applicationOctetStream "	^self contentType: MimeTypeDescriptor contentTypeApplicationOctetStream</body><body package="MIME" selector="contentType:">contentType: aString	^self contentType: aString charset: nil</body><body package="MIME" selector="contentType:charset:">contentType: aString charset: cString	^self new 		name: 'content-type';		contentType: aString;		charset: cString;		yourself</body><body package="MIME" selector="default">default	^self iso8859x1Default</body><body package="MIME" selector="iso8859x1Default">iso8859x1Default	^self new		name: 'content-type';		contentType: self defaultContentType;		charset: self iso8859x1;		yourself</body><body package="MIME" selector="messageRfc822">messageRfc822	" self messageRfc822 "	^self contentType: MimeTypeDescriptor contentTypeMessageRfc822 charset: self defaultCharset</body><body package="MIME" selector="textPlain">textPlain	" self textPlain "	^self contentType: MimeTypeDescriptor contentTypePlainText charset: self defaultCharset</body><body package="MIME" selector="usAsciiDefault">usAsciiDefault	^self new		name: 'content-type';		contentType: self defaultContentType;		charset: self usAscii;		yourself</body></methods><methods><class-id>Net.ContentTypeField class</class-id> <category>defaults</category><body package="MIME" selector="defaultCharset">defaultCharset	^self iso8859x1</body><body package="MIME" selector="defaultContentType">defaultContentType	^MimeTypeDescriptor defaultContentTypeString</body><body package="MIME" selector="defaultSeparators">defaultSeparators	^#($; $; nil  )</body><body package="MIME" selector="defaultUnsupportedContentType">defaultUnsupportedContentType	^MimeTypeDescriptor defaultUnsupportedContentType</body><body package="MIME" selector="iso8859x1">iso8859x1	^MimeTypeDescriptor iso8859x1</body><body package="MIME" selector="usAscii">usAscii	^MimeTypeDescriptor usAscii</body></methods><methods><class-id>Net.ContentDispositionField</class-id> <category>accessing</category><body package="MIME" selector="disposition">disposition	^self localValue</body><body package="MIME" selector="disposition:">disposition: aString" Disposition should be 'inline' or 'attachment' "	self localValue: aString</body><body package="MIME" selector="fileName">fileName	^self parameterAt: 'filename'</body><body package="MIME" selector="fileName:">fileName: aString	^self parameterAt: 'filename' put: aString</body><body package="MIME" selector="size">size	Integer readFrom: (self parameterAt: 'size' ifAbsent: [^nil]) readStream</body><body package="MIME" selector="size:">size: anInteger	self parameterAt: 'size' put: anInteger printString</body></methods><methods><class-id>Net.ContentDispositionField</class-id> <category>testing</category><body package="MIME" selector="isAttachment">isAttachment" Answer true if content disposition is 'attachments' "	^self disposition asLowercase = 'attachment'</body><body package="MIME" selector="isInline">isInline" Answer true if content disposition is 'inline' "	^self disposition asLowercase = 'inline'</body></methods><methods><class-id>Net.ContentDispositionField class</class-id> <category>parsing</category><body package="MIME" selector="fieldNames">fieldNames	^#('content-disposition')</body></methods><methods><class-id>Net.ContentDispositionField class</class-id> <category>defaults</category><body package="MIME" selector="defaultContentDispositionValue">defaultContentDispositionValue	^#attachment</body><body package="MIME" selector="defaultSeparators">defaultSeparators	^#($; $; nil  )</body></methods><methods><class-id>Net.ContentDispositionField class</class-id> <category>instance creation</category><body package="MIME" selector="default">default	^self fromLine: 'Content-disposition: ', self defaultContentDisposition</body></methods><methods><class-id>Net.ContentDispositionField class</class-id> <category>accessing</category><body package="MIME" selector="defaultContentDisposition">defaultContentDisposition	^DefaultContentDisposition isNil		ifTrue: [ DefaultContentDisposition := self defaultContentDispositionValue]		ifFalse: [DefaultContentDisposition ]</body><body package="MIME" selector="defaultContentDisposition:">defaultContentDisposition: aString	DefaultContentDisposition := aString</body></methods><methods><class-id>Net.MessageBuildHandler</class-id> <category>part factory</category><body package="MIME" selector="createEntityFor:">createEntityFor: aMessageHeader" Add actual logic for message factory "	| entity |	entity := self entityType new		header: aMessageHeader;		yourself.	self entity: entity.	^entity</body><body package="MIME" selector="entityType">entityType	^self isRootContext		ifTrue: [ self defaultRootEntityType]		ifFalse: [self defaultPartEntityType]</body><body package="MIME" selector="scannerOn:">scannerOn: aStream	^self scannerType on: aStream</body></methods><methods><class-id>Net.MessageBuildHandler</class-id> <category>accessing</category><body package="MIME" selector="decodeContents">decodeContents	^self class decodeContents</body><body package="MIME" selector="fieldFactory">fieldFactory" Answer field factory or default field factory if none is specified. Different protocols may have different field factories (i.e. Mime vs. HTTP) "	^self context at: #fieldFactory ifAbsent: [ self defaultFieldFactory ]</body><body package="MIME" selector="fieldFactory:">fieldFactory: anObject" Set field factory. Different protocols may have different field factories (i.e. Mime vs. HTTP). Field factory should respond to messages:	readFrom: 	readNameFrom:	scannerType	fieldClassForName:"	self context at: #fieldFactory put: anObject</body><body package="MIME" selector="initialEntity">initialEntity	^self context at: #initialEntity ifAbsent: [ nil ]</body><body package="MIME" selector="initialEntity:">initialEntity: anObject" Set initial entity. This is used if we start with a known entity to build. It will be assigned as root context's entity during the first entity callback "	self context at: #initialEntity put: anObject</body><body package="MIME" selector="messageHeaderClass">messageHeaderClass" Answer message header class "	^self context at: #messageHeaderClass ifAbsent: [ MessageHeader ]</body><body package="MIME" selector="messageHeaderClass:">messageHeaderClass: aClass" Set message header class "	self context at: #messageHeaderClass put: aClass</body><body package="MIME" selector="scannerType">scannerType	^self context at: #scannerType ifAbsent: [ self defaultScannerType ]</body><body package="MIME" selector="scannerType:">scannerType: aClass	self context at: #scannerType put: aClass</body><body package="MIME" selector="useSourceStream">useSourceStream" This option directs builder to use stream segments pointing to the actualsource stream this message is built from. It is used mainly because ofcompatibility with STAMP, so that we can change message flags stored asextension fields directly in the folder file "	^self context at: #useSourceStream ifAbsent: [ false ]</body><body package="MIME" selector="useSourceStream:">useSourceStream: aBoolean	self context at: #useSourceStream put: aBoolean</body></methods><methods><class-id>Net.MessageBuildHandler</class-id> <category>tasks</category><body package="MIME" selector="build:from:">build: aMimeEntity from: aStream	^self parse: aMimeEntity from: (self scannerOn: aStream)</body><body package="MIME" selector="buildHeaderFor:from:">buildHeaderFor: aMimeEntity from: aStream	^self parseHeaderFor: aMimeEntity from: (self scannerOn: aStream)</body><body package="MIME" selector="parse:">parse: rfc822Scanner	self initializeEntityContext.	internalStream := rfc822Scanner source isInternal.	^self dispatcher parse: rfc822Scanner</body><body package="MIME" selector="parse:from:">parse: aMimeEntity from: rfc822Scanner	^self 		initialEntity: aMimeEntity;		parse: rfc822Scanner</body><body package="MIME" selector="parseBody:from:">parseBody: aMimeEntity from: rfc822Scanner	self initializeEntityContext. 	self startEntity: aMimeEntity. 	internalStream := rfc822Scanner source isInternal.	^self dispatcher parseBody: self entity body from: rfc822Scanner</body><body package="MIME" selector="parseHeader:">parseHeader: rfc822Scanner	^self headerOnly: true; parse: rfc822Scanner</body><body package="MIME" selector="parseHeaderFor:from:">parseHeaderFor: aMimeEntity from: rfc822Scanner	^self 		initialEntity: aMimeEntity;		parseHeader: rfc822Scanner</body><body package="MIME" selector="read:from:">read: aMimeEntity from: aStream	^self parse: aMimeEntity from: (self scannerOn: aStream)</body><body package="MIME" selector="readFrom:">readFrom: aStream	^self parse: (self scannerOn: aStream)</body><body package="MIME" selector="readHeaderFor:from:">readHeaderFor: aMimeEntity from: aStream	^self parseHeaderFor: aMimeEntity from: (self scannerOn: aStream)</body><body package="MIME" selector="readHeaderFrom:">readHeaderFrom: aStream	^self parseHeader: (self scannerOn: aStream)</body></methods><methods><class-id>Net.MessageBuildHandler</class-id> <category>defaults</category><body package="MIME" selector="defaultEncoding">defaultEncoding	^#ISO8859_1</body><body package="MIME" selector="defaultFieldFactory">defaultFieldFactory	^HeaderField</body><body package="MIME" selector="defaultPartEntityType">defaultPartEntityType	^MimeEntity</body><body package="MIME" selector="defaultRootEntityType">defaultRootEntityType	^MimeEntity</body><body package="MIME" selector="defaultScannerType">defaultScannerType	^MimeScanner</body><body package="MIME" selector="dispatcherClass">dispatcherClass	^MessageParser</body></methods><methods><class-id>Net.MessageBuildHandler</class-id> <category>action callbacks</category><body package="MIME" selector="endBody:">endBody: aBody" By now we have accumulated body octets. Remove content transfer encoding and decode body source using current charset "	| lineEndConvention |	(aBody isSimple  and: [self useSourceStream not])		ifTrue: 			[aBody source isInternal				ifFalse: [ lineEndConvention := aBody source lineEndConvention]. 			self removeTransferContextAndDecode: aBody.					lineEndConvention ~~ nil				ifTrue: [ aBody source lineEndConvention: lineEndConvention]].	^true</body><body package="MIME" selector="endBodyPart:">endBodyPart: aMimeEntity	self entity addPart: aMimeEntity</body><body package="MIME" selector="endHeader:">endHeader: aMessageHeader	self entity isNil		ifTrue: [ self createEntityFor: aMessageHeader]		ifFalse: [self entity header: aMessageHeader].	^self entity</body><body package="MIME" selector="startBody:">startBody: aMessageBody	(super startBody: aMessageBody)		ifFalse: [^false].	self openBodyStream: aMessageBody.	^true</body><body package="MIME" selector="startBodyStream:length:">startBodyStream: aStream length: lengthOrNil" Add specified number of bytes from input stream to our source stream.This callback is executed once for mail messages; HTTP messages mayconsist of multiple chunks, each chunk will result in calling this method.Input stream octets should be interpreted using the current encoding of thebody. So the input stream is converted into octets; when the body has been parsed, the bytes are encoded into encoded stream using propoer encoding.This is done in endBody:.Unfortunately, we cannot assume that input stream can be set into binary modebecause we want to be able to handle messages stored in internal streamsor in files (latter case we can't even rely on line end convention being CRLF). So we read input stream as characters in ISO8859-1 (not us-ascii because some malformed messages may containg non-us-ascii characters in the body. "	| counter lineEndConvention |	self useSourceStream 		ifTrue: [counter := lengthOrNil notNil							ifTrue: [aStream position + lengthOrNil - 1]							ifFalse: [aStream size].				self entity body source: (aStream from: aStream position to: counter)]		ifFalse: 			[lineEndConvention := aStream lineEndConvention.			aStream lineEndTransparent.			[self readStream: aStream length: lengthOrNil lineEndConvention: lineEndConvention.			aStream text; lineEndConvention: lineEndConvention ]				on: Error 				do: [ :ex | self handleStartBodyException: ex ]]</body><body package="MIME" selector="startEntity:">startEntity: aMimeEntityOrNil	self pushEntityContext: aMimeEntityOrNil.	(aMimeEntityOrNil isNil and: [self isRootContext and: [self initialEntity notNil]])		ifTrue: [self entity: self initialEntity].	^true</body><body package="MIME" selector="startHeader:">startHeader: aMessageHeaderOrNil 	^aMessageHeaderOrNil isNil		ifTrue: [self messageHeaderClass new]		ifFalse: [aMessageHeaderOrNil]</body></methods><methods><class-id>Net.MessageBuildHandler</class-id> <category>private</category><body package="MIME" selector="handleStartBodyException:">handleStartBodyException: exception	Transcript cr; show: ((#ErrorParsingMimeBody1s &lt;&lt; #net &gt;&gt; 'Error parsing mime body: &lt;1s&gt;')			expandMacrosWith: exception errorString); cr. 	ParsingSimpleBodyError new		messageText: exception messageText;		parameter: exception;		raiseSignal</body><body package="MIME" selector="openBodyStream:">openBodyStream: aMessageBody	(aMessageBody isSimple and: [self useSourceStream not]) 		ifTrue: [aMessageBody source: ((ByteArray new: 1024) withEncoding: self defaultEncoding) writeStream].</body><body package="MIME" selector="readStream:length:lineEndConvention:">readStream: aStream length: lengthOrNil lineEndConvention: lineEndConvention	| binary  counter c aBody |	aBody := self entity body.	binary := aBody isBinary. 	binary 				ifTrue: 			[aBody source binary.			aStream binary]		ifFalse: 	[aBody source lineEndConvention: lineEndConvention].	counter := lengthOrNil. 	[(counter == nil or: [counter &gt; 0]) and: [aStream atEnd not]]			whileTrue: 				[c := aStream next.				binary ifTrue: [c := c asInteger].				aBody source nextPut: c.				counter notNil ifTrue: [counter := counter - 1]].</body><body package="MIME" selector="removeTransferContextAndDecode:">removeTransferContextAndDecode: aBody	(self class removeContentTransferEncoding		and: [ aBody parent contentTransferEncoding ~~ nil 				and: [#('base64' 'quoted-printable') includes: aBody parent contentTransferEncoding asLowercase]])				ifTrue: 					[aBody source: aBody source encodedContents asString readStream.					"Remove content transfer encoding and decode the contents using specified charset" 					aBody parent removeContentTransferEncoding]				ifFalse: 					["Decode the contents using specified charset"  					aBody source:  (aBody source encodedContents withEncoding: aBody parent charset ) readStream].</body></methods><methods><class-id>Net.MessageBuildHandler class</class-id> <category>instance creation</category><body package="MIME" selector="build:from:">build: aMimeEntity from: rfc822Scanner	^self new build: aMimeEntity from: rfc822Scanner</body><body package="MIME" selector="buildHeaderFor:from:">buildHeaderFor: aMimeEntity from: rfc822Scanner	^self new buildHeaderFor: aMimeEntity from: rfc822Scanner</body><body package="MIME" selector="parse:">parse: rfc822Scanner	^self new parse: rfc822Scanner</body><body package="MIME" selector="parse:from:">parse: aMimeEntity from: rfc822Scanner	^self new parse: aMimeEntity from: rfc822Scanner</body><body package="MIME" selector="parseHeader:">parseHeader: rfc822Scanner	^self new parseHeader: rfc822Scanner</body><body package="MIME" selector="parseHeaderFor:from:">parseHeaderFor: aMimeEntity from: rfc822Scanner	^self new parseHeaderFor: aMimeEntity from: rfc822Scanner</body><body package="MIME" selector="read:from:">read: entity from: aStream	^self new read: entity from: aStream</body><body package="MIME" selector="readFrom:">readFrom: aStream	^self new readFrom: aStream</body><body package="MIME" selector="readHeaderFor:from:">readHeaderFor: aMimeEntity from: aStream	^self new readHeaderFor: aMimeEntity from: aStream</body><body package="MIME" selector="readHeaderFrom:">readHeaderFrom: aStream	^self new readHeaderFrom: aStream</body></methods><methods><class-id>Net.MessageBuildHandler class</class-id> <category>accessing settings</category><body package="MIME" selector="removeContentTransferEncoding">removeContentTransferEncoding	^RemoveContentTransferEncoding isNil		ifTrue: [ RemoveContentTransferEncoding := self defaultRemoveContentTransferEncoding ]		ifFalse: [ RemoveContentTransferEncoding ]</body><body package="MIME" selector="removeContentTransferEncoding:">removeContentTransferEncoding: aBoolean	RemoveContentTransferEncoding := aBoolean</body></methods><methods><class-id>Net.MessageBuildHandler class</class-id> <category>defaults</category><body package="MIME" selector="defaultRemoveContentTransferEncoding">defaultRemoveContentTransferEncoding	^false</body></methods><methods><class-id>Net.MailBuildHandler</class-id> <category>defaults</category><body package="MIME" selector="defaultRootEntityType">defaultRootEntityType	^MailMessage</body></methods><methods><class-id>Net.NumericField</class-id> <category>accessing</category><body package="MIME" selector="asString">asString	^self value printString</body></methods><methods><class-id>Net.NumericField</class-id> <category>parsing</category><body package="MIME" selector="doParse:">doParse: rfc822Stream " HeaderField fromLine: 'Content-length : 1024 (This is body length in bytes)' "	rfc822Stream skipWhiteSpace.	^Number readFrom: rfc822Stream asStream</body></methods><methods><class-id>Net.NumericField</class-id> <category>initialization</category><body package="MIME" selector="initialize">initialize	super initialize.	value := 0</body></methods><methods><class-id>Net.NumericField</class-id> <category>printing</category><body package="MIME" selector="printStructureOn:">printStructureOn: aStream	aStream nextPutAll: self asString.	self printCommentOn: aStream</body></methods><methods><class-id>Net.NumericField class</class-id> <category>parsing</category><body package="MIME" selector="fieldNames">fieldNames	^#('content-length' )</body></methods><methods><class-id>Net.NumericField class</class-id> <category>instant creation</category><body package="MIME" selector="contentLength:">contentLength: aNumber" Answer an instance of this field representing content length"	^(self name: 'content-length') value: aNumber</body></methods><methods><class-id>Net.MimeMultipartEntity</class-id> <category>attachments</category><body package="MIME" selector="addFileAttachment:">addFileAttachment: aFilename	^self bot addFileAttachmentFor: self fileName: aFilename</body><body package="MIME" selector="attachmentAt:">attachmentAt: index	^(self bot attachmentsFor: self) at: index</body><body package="MIME" selector="attachmentFiles">attachmentFiles	^self attachments select: [:each | each fileName ~~ nil ]</body><body package="MIME" selector="attachmentFilesAsDictionary">attachmentFilesAsDictionary	| dict |	dict := Dictionary new.	self attachments 		do: [:each | 			each fileName ~~ nil				ifTrue: [ dict at: each fileName put: each value value ]].	^dict</body><body package="MIME" selector="attachmentNames">attachmentNames	"Return a list of attachments file names  (if any)"	| list fn  |	list := OrderedCollection new.	self attachments do: [:ea | (fn := ea fileName) notNil ifTrue: [ list add: fn]].	^list</body><body package="MIME" selector="attachments">attachments	^self bot attachmentsFor: self</body></methods><methods><class-id>Net.MimeMultipartEntity</class-id> <category>utility</category><body package="MIME" selector="saveAttachment:on:">saveAttachment: aMimeEntity on: aStream	^self bot writeContentsOf: aMimeEntity  on: aStream</body><body package="MIME" selector="saveAttachmentAt:on:">saveAttachmentAt: anInteger on: aStream	^self saveAttachment: (self attachmentAt: anInteger)  on: aStream</body></methods><methods><class-id>Net.RFC822Message</class-id> <category>accessing</category><body package="MIME" selector="bcc">bcc	^self getValueFor: 'bcc' ifAbsent: [ OrderedCollection new ]</body><body package="MIME" selector="bcc:">bcc: aStringOrList	self setAddressesAt: 'bcc' to: aStringOrList</body><body package="MIME" selector="cc">cc	^self getValueFor: 'cc' ifAbsent: [ OrderedCollection new ]</body><body package="MIME" selector="cc:">cc: aStringOrList	self setAddressesAt: 'cc' to: aStringOrList</body><body package="MIME" selector="comments">comments	^self getValueFor: 'comments'</body><body package="MIME" selector="date">date	^self fieldValueAt: 'date'</body><body package="MIME" selector="date:">date: aTimestampOrString	(self getFieldAt: 'date') value: aTimestampOrString</body><body package="MIME" selector="destinationAddresses">destinationAddresses" Answer collection of destination addresses. These addresses have been preprocessedto make them good for SMTP transport. This means removing everything but address-spec and encoding alias based on the message charset "	| coll f |	coll := OrderedCollection new.	self destinationFields 		do: [ :fn |  			(f := self fieldAt: fn ifAbsent: [nil]) ~~ nil				ifTrue: [ coll addAll: (f addressesEncodedWith: self headerCharset)]].	^coll</body><body package="MIME" selector="destinationFields">destinationFields" Answer collection of fields that contain message destination addresses "	^#('to' 'cc' 'bcc')</body><body package="MIME" selector="encrypted">encrypted	^self getValueFor: 'encrypted'</body><body package="MIME" selector="from">from	^self getValueFor: 'from' ifAbsent: [ OrderedCollection new ]</body><body package="MIME" selector="from:">from: aStringOrList	self setAddressesAt: 'from' to: aStringOrList</body><body package="MIME" selector="id">id	^self fieldValueAt: 'message-id'</body><body package="MIME" selector="id:">id: aString	(self getFieldAt: 'message-id') value: aString</body><body package="MIME" selector="inReplyTo">inReplyTo	^self getValueFor: 'in-reply-to' ifAbsent: [ OrderedCollection new ]</body><body package="MIME" selector="inReplyTo:">inReplyTo: aStringOrList	self setAddressesAt: 'in-reply-to' to: aStringOrList</body><body package="MIME" selector="keywords">keywords	^self getValueFor:  'keywords'</body><body package="MIME" selector="messageID">messageID	^self getValueFor: 'message-id'</body><body package="MIME" selector="reference">reference	^self getValueFor: 'reference'</body><body package="MIME" selector="replyTo">replyTo	^self getValueFor: 'reply-to' ifAbsent: [ OrderedCollection new ]</body><body package="MIME" selector="replyTo:">replyTo: aStringOrList	self setAddressesAt: 'reply-to' to: aStringOrList</body><body package="MIME" selector="resentBcc">resentBcc	^self getValueFor: 'resent-bcc' ifAbsent: [ OrderedCollection new ]</body><body package="MIME" selector="resentBcc:">resentBcc: aStringOrList	self setAddressesAt: 'resent-bcc' to: aStringOrList</body><body package="MIME" selector="resentCc">resentCc	^self getValueFor: 'resent-cc' ifAbsent: [ OrderedCollection new ]</body><body package="MIME" selector="resentCc:">resentCc: aStringOrList	self setAddressesAt: 'resent-cc' to: aStringOrList</body><body package="MIME" selector="resentDate">resentDate	^self getValueFor: 'resent-date'</body><body package="MIME" selector="resentFrom">resentFrom	^self getValueFor: 'resent-from'</body><body package="MIME" selector="resentFrom:">resentFrom: aStringOrList	self setAddressesAt: 'resent-from' to: aStringOrList</body><body package="MIME" selector="resentMessageID">resentMessageID	^self getValueFor: 'resent-message-id'</body><body package="MIME" selector="resentReplyTo">resentReplyTo	^self getValueFor: 'resent-reply-to'</body><body package="MIME" selector="resentReplyTo:">resentReplyTo: aStringOrList	self setAddressesAt: 'resent-reply-to' to: aStringOrList</body><body package="MIME" selector="resentSender">resentSender	^self getValueFor: 'resent-sender'</body><body package="MIME" selector="resentSender:">resentSender: aStringOrList	self setAddressesAt: 'resent-sender' to: aStringOrList</body><body package="MIME" selector="resentTo">resentTo	^self getValueFor: 'resent-to' ifAbsent: [ OrderedCollection new ]</body><body package="MIME" selector="resentTo:">resentTo: aStringOrList	self setAddressesAt: 'resent-to' to: aStringOrList</body><body package="MIME" selector="returnPath">returnPath	^self getValueFor: 'return-path'</body><body package="MIME" selector="sender">sender	^self getValueFor: 'sender'</body><body package="MIME" selector="setAddressesAt:to:">setAddressesAt: fieldName to: aStringOrList	| addresses |	addresses := self addressesFrom: aStringOrList. 	^(self getFieldAt: fieldName) addresses: addresses</body><body package="MIME" selector="status">status	^self getValueFor: 'status'</body><body package="MIME" selector="subject">subject	^self getValueFor: 'subject'</body><body package="MIME" selector="subject:">subject: aString	^self fieldValueAt: 'subject' put: aString</body><body package="MIME" selector="timestamp">timestamp	^(self fieldAt: 'date' ifAbsent: [^nil]) timestamp</body><body package="MIME" selector="timestamp:">timestamp: aTimestamp	^(self getFieldAt: 'date') timestamp: aTimestamp</body><body package="MIME" selector="to">to	^self getValueFor: 'to' ifAbsent: [ OrderedCollection new ]</body><body package="MIME" selector="to:">to: aStringOrList	self setAddressesAt: 'to' to: aStringOrList</body></methods><methods><class-id>Net.RFC822Message</class-id> <category>transfer encodings</category><body package="MIME" selector="transferFieldOrder">transferFieldOrder" rfc822 recommends field order (if present) to be as follows. Order for remaining fiedls does not matter "	^#('return-path' 'received' 'date' 'from' 'subject' 'sender' 'to' 'cc' 'mime-version' 'content-type' 'content-length' 'content-transfer-encoding' )</body></methods><methods><class-id>Net.RFC822Message</class-id> <category>parsing</category><body package="MIME" selector="addressesFrom:">addressesFrom: aListOrString" RFC822Message new addressesFrom: 'George Jones &lt;Group@Some-Reg.An-Org&gt;,                 Al.Neuman@MAD.Publisher' "	" Canonicalize addresses "	| coll addresses |	coll := aListOrString isString		ifTrue: [ OrderedCollection with: aListOrString]		ifFalse: [ aListOrString ].	addresses := OrderedCollection new.	coll do: 		[ :addr |		addr isString			ifTrue: 				[addresses addAll: 					(NetworkAddressDescriptor addressesFrom: (self scannerOn: addr readStream))]			ifFalse: [addresses add: addr]]. 	^addresses</body></methods><methods><class-id>Net.RFC822Message</class-id> <category>private</category><body package="MIME" selector="encodedStringAt:">encodedStringAt: fieldName	^(self getFieldAt: fieldName) addressesEncodedWith: self headerCharset</body></methods><methods><class-id>Net.RFC822Message class</class-id> <category>defaults</category><body package="MIME" selector="defaultCharset">defaultCharset	^MimeTypeDescriptor usAscii</body></methods><methods><class-id>Net.MailMessage</class-id> <category>accessing</category><body package="MIME" selector="allAlternativeTextFormats">allAlternativeTextFormats" Answer all alternative text representation formats available in this message " 	^(self bot allTextPartsFor: self) collect: [ :each | each subtype ]</body><body package="MIME" selector="allTextParts">allTextParts	^self bot allTextPartsFor: self</body><body package="MIME" selector="bccSendStrings">bccSendStrings	^self encodedStringAt: 'bcc'</body><body package="MIME" selector="ccSendStrings">ccSendStrings	^self encodedStringAt: 'cc'</body><body package="MIME" selector="dateSendString">dateSendString	^self encodedStringAt: 'cc'</body><body package="MIME" selector="fromSendStrings">fromSendStrings	^self encodedStringAt: 'from'</body><body package="MIME" selector="inReplyToSendString">inReplyToSendString	^self encodedStringAt: 'in-reply-to'</body><body package="MIME" selector="replyToSendStrings">replyToSendStrings	^self encodedStringAt: 'reply-to'</body><body package="MIME" selector="resentBccSendStrings">resentBccSendStrings	^self encodedStringAt: 'resent-bcc'</body><body package="MIME" selector="resentCcSendStrings">resentCcSendStrings	^self encodedStringAt: 'resent-cc'</body><body package="MIME" selector="resentFromSendStrings">resentFromSendStrings	^self encodedStringAt: 'resent-from'</body><body package="MIME" selector="resentReplyToSendStrings">resentReplyToSendStrings	^self encodedStringAt: 'resent-reply-to'</body><body package="MIME" selector="resentToSendStrings">resentToSendStrings	^self encodedStringAt: 'resent-to'</body><body package="MIME" selector="subjectSendString">subjectSendString	^self encodedStringAt: 'subject'</body><body package="MIME" selector="text">text	^self bot textFor: self</body><body package="MIME" selector="text:">text: aString	^self bot replaceTextFor: self with: aString</body><body package="MIME" selector="textInPreferenceOrder:">textInPreferenceOrder: preferences	^self bot textFor: self preferences: preferences</body><body package="MIME" selector="textPart">textPart	^self bot textPartFor: self</body><body package="MIME" selector="textPartInPreferenceOrder:">textPartInPreferenceOrder: preferences	^self bot textPartFor: self preferences: preferences</body><body package="MIME" selector="toSendStrings">toSendStrings	^self encodedStringAt: 'to'</body></methods><methods><class-id>Net.MailMessage</class-id> <category>utility</category><body package="MIME" selector="applyTransferEncoding">applyTransferEncoding	^self bot applyTransferEncodingTo: self</body><body package="MIME" selector="checkStructure">checkStructure	^self bot checkStructure: self</body><body package="MIME" selector="prepareForTransport">prepareForTransport	self checkStructure.	self applyTransferEncoding.</body><body package="MIME" selector="replaceTextWith:">replaceTextWith: aString	^self bot replaceTextFor: self with: aString</body><body package="MIME" selector="saveTextOn:">saveTextOn: aStream	^self bot writeContentsOf: self textPart on: aStream</body><body package="MIME" selector="saveTextOn:inPreferenceOrder:">saveTextOn: aStream inPreferenceOrder: preferences	^self bot writeContentsOf: (self textPartInPreferenceOrder: preferences) on: aStream</body></methods><methods><class-id>Net.MailMessage</class-id> <category>composing</category><body package="MIME" selector="writeOn:">writeOn: aStream	self bot checkStructure: self.	super writeOn: aStream</body></methods><methods><class-id>Net.MailMessage</class-id> <category>send</category><body package="MIME" selector="send">send	NetClient defaultOutgoingMailClient			sendMessage:  self</body></methods><methods><class-id>Net.MailMessage</class-id> <category>defaults</category><body package="MIME" selector="defaultBot">defaultBot	^MailMessageBot new</body></methods><methods><class-id>Net.MailMessage class</class-id> <category>defaults</category><body package="MIME" selector="defaultBuilderType">defaultBuilderType	^MailBuildHandler</body></methods><methods><class-id>Net.MailMessageBot</class-id> <category>private</category><body package="MIME" selector="bestMatchFrom:preferences:">bestMatchFrom: coll preferences: prefArray 	| sorted candidates |	^coll isEmpty		ifTrue: [nil]		ifFalse: 			[(prefArray isNil or: [prefArray isEmpty]) ifTrue: [ ^coll first ].			" Then select only those that match at least one condition "			candidates := coll select: [ :candidate | (self indexOf: candidate subtype in: prefArray) &gt; 0 ].			candidates isEmpty ifTrue: [ ^nil ].			sorted := (SortedCollection sortBlock: 				[:x :y | (self indexOf: x subtype in: prefArray) &lt; (self indexOf: y subtype in: prefArray)])				addAll: candidates; 				yourself.				sorted first]</body><body package="MIME" selector="indexOf:in:">indexOf: aString in: seqColl 	1 to: seqColl size 		do: [:idx | ((seqColl at: idx) match: aString) ifTrue: [^idx]].	^0</body></methods><methods><class-id>Net.MailMessageBot</class-id> <category>tasks</category><body package="MIME" selector="allTextPartsFor:">allTextPartsFor: aMailMessage" Answered sequencable collection of all text parts in the message "	^self findTextPartCandidatesFor: aMailMessage.</body><body package="MIME" selector="applyTransferEncodingTo:">applyTransferEncodingTo: aMimeEntity	(self attachmentsFor: aMimeEntity) 		do: [ :attachment | self prepareForTransport: attachment encodeAs: 'base64' ]</body><body package="MIME" selector="attachmentsFor:">attachmentsFor: aMimeEntity 	| textPart attachments |	textPart := self textPartFor: aMimeEntity preferences: nil.	textPart parent isNil ifTrue: [ ^OrderedCollection new ].		" Simple entity -- no attachments "	(textPart parent isMultipartAlternative) ifTrue: [textPart := textPart parent].	textPart == aMimeEntity ifTrue: [ ^OrderedCollection new ].		attachments := OrderedCollection new: 4.	self		for: aMimeEntity		maxDepth: 2		partsDo: [:part | (part ~~ textPart and: [part ~~ aMimeEntity])				ifTrue: [attachments add: part]].	^attachments</body><body package="MIME" selector="findMultipartAlternativeTextPartsFor:">findMultipartAlternativeTextPartsFor: aMimeEntity 	"Answer all text subparts of specified entity "	^aMimeEntity parts select: [:subpart | subpart isTextContentType].</body><body package="MIME" selector="findMultipartMixedTextPartsFor:">findMultipartMixedTextPartsFor: aMimeEntity 	"If my body is multipart/mixed, the first text part is message text. 	Otherwise, the first multipart/alternative part contains alternative 	representations of message text"	| part |	part := aMimeEntity parts detect: [:subpart | subpart isTextContentType]				ifNone: [nil].	^part notNil		ifTrue: [Array with: part]		ifFalse: 	" Try multipart/alternative now "			[part := aMimeEntity parts detect: [:subpart | subpart isMultipartAlternative]						ifNone: [^Array new].			self findMultipartAlternativeTextPartsFor: part]</body><body package="MIME" selector="findTextPartCandidatesFor:">findTextPartCandidatesFor: aMimeEntity 	aMimeEntity isSimple ifTrue: [^Array with: aMimeEntity].	^aMimeEntity isMultipartMixed		ifTrue: [self findMultipartMixedTextPartsFor: aMimeEntity]		ifFalse: [self findMultipartAlternativeTextPartsFor: aMimeEntity]</body><body package="MIME" selector="highLevelTextPartFor:">highLevelTextPartFor: aMimeEntity" Answer part that either text part itself, or its parent if the part is inside multipart/alternative part "	| textPart |	textPart := self textPartFor: aMimeEntity preferences: #('*').	^(textPart isNil or: [textPart parent isNil or: [textPart parent isMultipart not]])		ifTrue: [textPart]		ifFalse: [textPart parent]</body><body package="MIME" selector="prepareForTransport:">prepareForTransport: aMimeEntity	self checkStructure: aMimeEntity.	self applyTransferEncodingTo: aMimeEntity.</body><body package="MIME" selector="prepareForTransport:encodeAs:">prepareForTransport: aMimeEntity encodeAs: encodingName	self for: aMimeEntity partsDo: [ :part |		part hasContentTransferEncoding			ifFalse: [ self applyTransferEncodingTo: part encodeAs: encodingName]].	^aMimeEntity</body><body package="MIME" selector="replaceTextFor:with:">replaceTextFor: aMimeEntity with: aString" Replace text can result in one of three scenarios: 	- For simple part text is this part's contents, so all three of aMimeEntity, textPart and containingPart		are the same. Simply replace part's contents with new text.	- For multipart/mixed entity containg simple text part aMimeEntity and containingPart are the same. 		Simply replace contents of text part	- For multipart/mixed entity containing multipart/alternative text part, containingTextPart is 		multipart/alternative part containing textPart. The transformation replaces this multipart/alternative		part with simple text part "	| partWithText partToReplace |	(partWithText := self textPartFor: aMimeEntity preferences: #('*')) isNil 		ifTrue: [^self error: (#InvalidMessage &lt;&lt; #net &gt;&gt; 'Invalid message')].	" Replace part's text "	partWithText contents: aString.	(partWithText ~~ aMimeEntity and: [partWithText parent isMultipartAlternative])		ifTrue: 			[" If this is first-level multipart message, replace its body with simple body, 			otherwise replace it in its parent with (simple) text part "			partToReplace := partWithText parent.			(aMimeEntity == partToReplace)				ifTrue: [aMimeEntity replaceFrom: partWithText]				ifFalse: [partToReplace parent replacePart: partToReplace with: partWithText ]]</body><body package="MIME" selector="textFor:">textFor: aMimeEntity " Answer default text representation for specified message "	^self textFor: aMimeEntity preferences: #('plain' '*')</body><body package="MIME" selector="textFor:preferences:">textFor: aMimeEntity preferences: anArray" Answer mail message text according to the list of preferences "	| entity |	^(entity := self textPartFor: aMimeEntity preferences: anArray) isNil		ifTrue: [ nil ]		ifFalse: [ entity removeContentTransferEncoding; contents ]</body><body package="MIME" selector="textPartFor:">textPartFor: aMimeEntity " Answer default text part for specified message "	^self textPartFor: aMimeEntity preferences: #('plain' '*')</body><body package="MIME" selector="textPartFor:preferences:">textPartFor: aMimeEntity preferences: anArray " Answer part containing message text according to the list of preferences. The list isthe form of #(bestPref nextBestPref ...). For example #('html' 'plain' '*') "	| candidates |	" First get all candidate text parts "	candidates := self findTextPartCandidatesFor: aMimeEntity.	^self bestMatchFrom: candidates preferences: anArray</body></methods><methods><class-id>Net.DateField</class-id> <category>converting</category><body package="MIME" selector="asDateAndTime">asDateAndTime	^self value</body><body package="MIME" selector="fromDateAndTime:">fromDateAndTime: dateAndTime	^Timestamp fromDate: dateAndTime first andTime: dateAndTime last.</body></methods><methods><class-id>Net.DateField</class-id> <category>accessing</category><body package="MIME" selector="asString">asString	^self dateString</body><body package="MIME" selector="dateString">dateString	^RFC822Scanner dateStringFrom: self value</body><body package="MIME" selector="timestamp">timestamp	^self value</body><body package="MIME" selector="timestamp:">timestamp: aTimestamp	self value: aTimestamp</body><body package="MIME" selector="value:">value: aTimestampOrStringOrArray 	"We allow to set date from either string, timestamp or a two-element array (date, time) "	(aTimestampOrStringOrArray isKindOf: Timestamp)		ifTrue: [value := aTimestampOrStringOrArray]		ifFalse: [aTimestampOrStringOrArray isString				ifTrue: [value := self doParse: (self scannerOn: aTimestampOrStringOrArray readStream)]				ifFalse: [value := self fromDateAndTime: aTimestampOrStringOrArray]]</body></methods><methods><class-id>Net.DateField</class-id> <category>parsing</category><body package="MIME" selector="doParse:">doParse: rfc822Stream " HeaderField fromLine: 'Date : Tue, 18 Apr 89 23:29:47 +0900	' "" HeaderField fromLine: 'Expires : 0' "" HTTP/1.1 clients MUST treat other invalid date formats, especially including the value 0, as in the past (i.e., already expired). That is why the value can be a number :-("	^[(rfc822Stream size - rfc822Stream position) &lt; 5		ifTrue: [ Number readFrom: rfc822Stream asStream]		ifFalse: 			[rfc822Stream scanDate] ] on: Error do: [ :ex | ex return: nil ]</body></methods><methods><class-id>Net.DateField</class-id> <category>printing</category><body package="MIME" selector="printStructureOn:">printStructureOn: aStream	aStream nextPutAll: self printValue.	self printCommentOn: aStream</body><body package="MIME" selector="printValue">printValue	| v |	v := self value.	^( v isKindOf: Number)		ifTrue: [  v printString ]		ifFalse: [ self dateString].</body></methods><methods><class-id>Net.DateField class</class-id> <category>parsing</category><body package="MIME" selector="fieldNames">fieldNames	^#('date' 'expires' 'last-modified' 'retry-after')</body></methods><methods><class-id>Net.DateField class</class-id> <category>instance creation</category><body package="MIME" selector="default">default	^self new value: Timestamp now</body></methods><methods><class-id>Core.TimestampReader</class-id> <category>initialize</category><body package="MIME" selector="rfc822">rfc822	timeSelector := #readLatinTimeFrom:.	dateSelector := #readLatinDateFrom:.	timestampSelector := #readLatinTimestampFrom:.</body></methods><methods><class-id>Net.Settings class</class-id> <category>accessing settings</category><body package="MIME" selector="removeContentTransferEncoding">removeContentTransferEncoding	^MessageBuildHandler removeContentTransferEncoding</body><body package="MIME" selector="removeContentTransferEncoding:">removeContentTransferEncoding: aBoolean	MessageBuildHandler removeContentTransferEncoding: aBoolean</body></methods><methods><class-id>Core.TimestampPrintPolicy</class-id> <category>initialize-release</category><body package="MIME" selector="rfc822">rfc822	"Initialize for the RFC822."	self shortPolicyString: 'd mmm yyyy hh:mm:ss;d mmm yyyy;hh:mm:ss;'.	self longPolicyString: 'd mmm yyyy hh:mm:ss;d mmm yyyy;hh:mm:ss;'.	self policyNamed: #editing putString: 'mm/dd/yyyy h:mm:ss.fff;m/d/yyyy;h:mm:ss am/pm;'.	dateMiniFormat := #dmy.	timeSeparator := $:.	shortWeekdays := #('Mon' 'Tue' 'Wed' 'Thu' 'Fri' 'Sat' 'Sun').	longWeekdays := #('Monday' 'Tuesday' 'Wednesday' 'Thursday' 'Friday' 'Saturday' 'Sunday').	shortMonths := #('Jan' 'Feb' 'Mar' 'Apr' 'May' 'Jun' 'Jul' 'Aug' 'Sep' 'Oct' 'Nov' 'Dec').	longMonths := #('January' 'February' 'March' 'April' 'May' 'June'				'July' 'August' 'September' 'October' 'November' 'December').	shortAmPm := #('a' 'p').	longAmPm := #('am' 'pm')</body></methods><methods><class-id>Net.SinglePartPresenter class</class-id> <category>interface specs</category><body package="MIME" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #SinglePartPresentation #defaultString: 'Single Part Presentation' #catalogID: #net) 			#min: #(#{Core.Point} 20 20 ) 			#bounds: #(#{Graphics.Rectangle} 273 143 823 533 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 6 0 0 1.0 0 1.0 ) 					#name: #partView 					#isOpaque: true 					#model: #partText 					#tabable: true ) ) ) )</body></methods><methods><class-id>Net.MailPage class</class-id> <category>interface specs</category><body package="MIME" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #MailServerList 				#defaultString: 'Mail Server List' 				#catalogID: #net ) 			#min: #(#{Core.Point} 383 350 ) 			#max: #(#{Core.Point} 383 350 ) 			#bounds: #(#{Graphics.Rectangle} 512 384 895 734 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 0.5 ) 					#model: #serverListAspect 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 5 0.5 -100 1 120 0.5 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Host 						#defaultString: 'Host' 						#catalogID: #net ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 50 0.5 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Name 						#defaultString: 'Name:' 						#catalogID: #net ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 110 0.5 0 1 ) 					#name: #user 					#label: 					#(#{Kernel.UserMessage} 						#key: #User 						#defaultString: 'User:' 						#catalogID: #net ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 80 0.5 0 1 ) 					#name: #serverType 					#label: 					#(#{Kernel.UserMessage} 						#key: #Type 						#defaultString: 'Type:' 						#catalogID: #net ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 100 0 25 0.5 -110 1 50 0.5 ) 					#name: #mailServerName 					#model: #mailServerName 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#type: #string ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 100 0 55 0.5 -110 1 80 0.5 ) 					#model: #mailServerTypeMenuAspect 					#menu: #mailServerTypeMenu ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 100 0 85 0.5 -110 1 110 0.5 ) 					#model: #mailUserMenuAspect 					#menu: #netUserMenu ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -92 1 15 0.5 0 0.994778 40 0.5 ) 					#name: #acceptButton 					#model: #okToAddServer 					#label: 					#(#{Kernel.UserMessage} 						#key: #AddNoDots 						#defaultString: 'Add' 						#catalogID: #net ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -92 1 40 0.5 0 0.994778 65 0.5 ) 					#name: #removeButton 					#model: #removeServer 					#label: 					#(#{Kernel.UserMessage} 						#key: #Remove 						#defaultString: 'Remove' 						#catalogID: #net ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -92 1 65 0.5 0 0.994778 90 0.5 ) 					#name: #setAsDefaultButton 					#model: #setServerAsDefault 					#label: 					#(#{Kernel.UserMessage} 						#key: #SetAsDefault 						#defaultString: 'Set As Default' 						#catalogID: #net ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -92 1 90 0.5 0 0.994778 115 0.5 ) 					#model: #addIdentity 					#label: 					#(#{Kernel.UserMessage} 						#key: #AddUser 						#defaultString: 'Add User...' 						#catalogID: #net ) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-netClient</category><body package="MIME" selector="miscellaneous1DefaultContentDisposition">miscellaneous1DefaultContentDisposition	&lt;setting: #(net miscellaneous defaultContentDisposition)&gt;	^((EnumerationSetting 				choices: #(attachment inline)				labels: (Array with: (#attachment &lt;&lt; #net &gt;&gt; 'attachment') with: (#inline &lt;&lt; #net &gt;&gt; 'inline') ))			on: Net.ContentDispositionField aspect: #defaultContentDisposition )		default: Net.ContentDispositionField defaultContentDispositionValue;		label: #defaultContentDisposition &lt;&lt; #net &gt;&gt; 'Default Content Disposition Type';		helpText: #defaultContentDispositionHelpText &lt;&lt; #net &gt;&gt; 'Specifies the default type for bodyparts in multipart mail messages. A bodypart should be marked "inline" if it is intended to be displayed automatically upon display of the message. Bodyparts can be designated "attachment" to indicate that they are separate from the main body of the mail message'</body><body package="MIME" selector="miscellaneous2DefaultCharsetEncoder">miscellaneous2DefaultCharsetEncoder	&lt;setting: #(net miscellaneous defaultCharsetEncoder)&gt;	^(StringSetting on: Net.SimpleBody aspect: #defaultCharsetEncoder )		label: #defaultCharsetEncoder &lt;&lt; #net &gt;&gt; 'Default Charset Encoder';		default: Net.SimpleBody defaultCharsetEncoderValue;		helpText: #defaultCharsetEncoderHelpText &lt;&lt; #net &gt;&gt; 'The charset is used to decode simple body value in #decodedValue method '</body><body package="MIME" selector="miscellaneous3RemoveContentTransferEncoding">miscellaneous3RemoveContentTransferEncoding	&lt;setting: #(net miscellaneous removeContentTransferEncoding)&gt;	^(BooleanSetting on: Net.MessageBuildHandler aspect: #removeContentTransferEncoding )		default: Net.MessageBuildHandler  defaultRemoveContentTransferEncoding;		label: #removeContentTransferEncoding &lt;&lt; #net &gt;&gt; 'Remove ContentTransferEncoding in mail messages';		helpText: #removeContentTransferEncodingrHelpText &lt;&lt; #net &gt;&gt; 'Specifies whether or not remove ContentTransferEncoding while parsing mail messages'</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="MIME" selector="netMailPage">netMailPage	&lt;settingsPage: #(net mail)&gt;	^Net.MailPage new		label: #MailServers &lt;&lt; #labels &gt;&gt; 'Mail Servers';		icon: (ListIconLibrary visualFor: #net)</body><body package="MIME" selector="netMiscellaneousPage">netMiscellaneousPage	&lt;settingsPage: #(net miscellaneous)&gt;	^ModularSettingsPage new		label: #Miscellaneous &lt;&lt; #net &gt;&gt; 'Miscellaneous';		icon: (ListIconLibrary visualFor: #net);		settings: (self settingsWithPrefix: #(net miscellaneous ))</body></methods><initialize><class-id>Net.HeaderField</class-id></initialize><initialize><class-id>Net.RFC822Scanner</class-id></initialize><initialize><class-id>Net.MimeEntity</class-id></initialize><initialize><class-id>Net.MimeScanner</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>TimestampReader</name><environment>Core</environment><super>Core.LocaleSensitiveDataReader</super><private>false</private><indexed-type>none</indexed-type><inst-vars>timeSelector dateSelector timestampSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Internationalization</category><attributes><package>Internationalization</package></attributes></class><class><name>TimestampPrintPolicy</name><environment>Core</environment><super>Core.PrintPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>policies dateMiniFormat timeSeparator shortWeekdays longWeekdays shortMonths longMonths shortAmPm longAmPm </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Internationalization</category><attributes><package>Internationalization</package></attributes></class><class><name>MessageElement</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source parent value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>SimpleScanner</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source hereChar token tokenType saveComments currentComment classificationMask sourceTrailStream </inst-vars><class-inst-vars>classificationTable </class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>NetSettingsPage</name><environment>Net</environment><super>Tools.SettingsManagerPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>userPreferences userListOwner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetConfigTool</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>