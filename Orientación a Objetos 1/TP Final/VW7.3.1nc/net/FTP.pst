<?xml version="1.0"?><st-source><!-- Name: FTPNotice: Copyright © 2005 Cincom Systems, Inc.  All Rights Reserved.Comment: FTPSupport provides a complete File Transfer Protocol client implementation based on RFC959 and RFC1123.DbIdentifier: bear73DbTrace: 53237DevelopmentPrerequisites: #(#(#any 'NetClientBase' '') #(#any 'URISupport' '') #(#any 'NetConfigTool' ''))PackageName: FTPParcel: #('FTP')ParcelName: FTPPrerequisiteParcels: #(#('NetClientBase' '') #('URISupport' '') #('NetConfigTool' ''))PrintStringCache: (7.4  0,tkogan)Version: 7.3.1Date: 6:45:28 pm April 10, 2005 --><time-stamp>From VisualWorks®, 7.3.1 of April 10, 2005 on April 10, 2005 at 6:45:28 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>FTPProtocolInterpreter</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>socket stream passiveServer mutex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-FTP-Support</category><attributes><package>FTP</package></attributes></class><comment><class-id>Net.FTPProtocolInterpreter</class-id><body>FTPProtocolInterpreter communicates with the FTP server via the control and data connection.  It has knowledge of the connection via the socket instance variable.  It also handles server transfers on the stream instance variable.  FTPProtocolInterpreter receives server replies (as an FTPResponse), handles them where appropriate, and passes replies to the FTPClient where appropriate.  Instance Variables:	socket	&lt;SocketAccessor&gt;	socket connection to the serverr	stream	&lt;ExternalReadStream&gt;	transfer stream	passiveServer	&lt;Boolean&gt;	boolean to determine method of transfer	controlReadProcess	&lt;Process&gt;	description of variable's function	dataTransferProcess	&lt;Process&gt;	description of variable's function	abortingProcess	&lt;Process&gt;	description of variable's function	controlPromises	&lt;Dictionary&gt;	description of variable's function	mutex	&lt;Semaphore&gt;	description of variable's functionClass Variables:	CrLf	&lt;ClassOfVariable&gt;	description of variable''s function</body></comment><class><name>FtpPage</name><environment>Net</environment><super>Net.NetSettingsPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>FTP</package></attributes></class><comment><class-id>Net.FtpPage</class-id><body>FtpPage creates Ftp page in VW UI Settings</body></comment><class><name>FTPSocketAccessor</name><environment>Net</environment><super>OS.SocketAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ftpConn callback </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-FTP-Support</category><attributes><package>FTP</package></attributes></class><comment><class-id>Net.FTPSocketAccessor</class-id><body>This class provides additional logic for FTP-based data transfer. FTP data transferinvolves two socket connections -- control and data connections; both should bemonitored during data transfer.Instance Variables:	ftpConn	&lt;FTPClient&gt;	An instance of FTP Client representing the control connection</body></comment><class><name>FTPUser</name><environment>Net</environment><super>Net.NetUser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-FTP-Support</category><attributes><package>FTP</package></attributes></class><comment><class-id>Net.FTPUser</class-id><body>Read the comment for NetUser.  FTPUser adds the account instance variable.  Account is used by the Ftp protocol.  Instance Variables:	account	&lt;String&gt;	holds an account name, where the account is on the ftp server</body></comment><class><name>FtpURL</name><environment>Net</environment><super>Net.URLwithAuthority</super><private>false</private><indexed-type>none</indexed-type><inst-vars>passiveMode user password </inst-vars><class-inst-vars>userAddress </class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>FTP</package></attributes></class><comment><class-id>Net.FtpURL</class-id><body>FtpURL implements FTP URL as defined in RFC2396 (URL). It is responsible for parsing FTP url string and publishes methods providing access to FTP file storages. FtpURL is designed to resemble Filename class, so it implements many of the methods providing directory access and stream creation.Instance Variables:	host	&lt;String&gt;	FTP server host name	port	&lt;Integer&gt;	FTP server port number	user	&lt;String&gt;	User name	password	&lt;String&gt;	Password</body></comment><class><name>FTPClient</name><environment>Net</environment><super>Net.NetClient</super><private>false</private><indexed-type>none</indexed-type><inst-vars>binaryBlockSize transferOffset delayedResponse finalResponse </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-FTP-Support</category><attributes><package>FTP</package></attributes></class><comment><class-id>Net.FTPClient</class-id><body>The combination of FTPClient, FTPProtocolInterpreter, FTPResponse is a complete File Transfer Protocol client implementation based on RFC959 and RFC1123.  FTPClient contains methods to do server transfers and other commands.  File Transfer Protocol is a protocol to enable two remote computers to share their file systems.  This is done with a two connections.  A control connection and a data connection.  The control connection between the client and the maintains synchronization with the use of command-reply structure.  Commands are sent as strings on the control connection.  Each command issued from the client to the server on the control connection returns a reply from the server.  Data connections are used for transfering of files between the file systems.  Note that the data connection may be used in either direction and that the data connection need not exist all of the time.In this client implementation, the client does not have direct knowledge of how its control and data connections are handled.  That is done by FTPProtocolInterpreter.  The FTPClient keeps track of the FTPUser and is the API to the protocol.  The FTP-Restart protocol contains methods for restarting previous FTP transfers which have failed.  This is done with the use of Smalltalk Streams, and not with markers (the way that RFC959 specifies).  Only the defaul modes of transfer (Stream) and structure (File) are used in this implementation.  Instance Variables:	binaryBlockSize	&lt;Number&gt;	holds a Number that determines the amount of bytes transfered at a time	transferOffset	&lt;Number&gt;	used as the server marker at which file transfer should be restarted	delayedResponse &lt;FTPResponse&gt; delayed server response	finalResponse &lt;FTPResponse&gt; final server responseClass Variables:	</body></comment><class><name>MacFTPProtocolInterpreter</name><environment>Net</environment><super>Net.FTPProtocolInterpreter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-FTP-Support</category><attributes><package>FTP</package></attributes></class><comment><class-id>Net.MacFTPProtocolInterpreter</class-id><body>MacFTPProtocolInterpreter implements Macintosh type TCP socket commands</body></comment><class><name>FTPSignal</name><environment>Net</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-FTP-Support</category><attributes><package>FTP</package></attributes></class><comment><class-id>Net.FTPSignal</class-id><body>FTPSignal is the abstract class for all Ftp signals. Instance Variables:</body></comment><class><name>FTPPreliminaryReply</name><environment>Net</environment><super>Net.FTPSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-FTP-Support</category><attributes><package>FTP</package></attributes></class><comment><class-id>Net.FTPPreliminaryReply</class-id><body>FTPPreliminaryReply is signaled when the FTPProtocolInterpreter receives a preliminary reply from the server when the FTPProtocolInterpreter is not expecting a preliminary reply.  Instance Variables:</body></comment><class><name>FTPPermSignal</name><environment>Net</environment><super>Net.FTPSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-FTP-Support</category><attributes><package>FTP</package></attributes></class><comment><class-id>Net.FTPPermSignal</class-id><body>FTPPermSignal is signaled when the FTPProtocolInterpreter receives a permanent error reply from a server.  It is analagous to the Permanent Negative Completion reply documented in the FTPResponse class comment.</body></comment><class><name>FTPNoSocketSignal</name><environment>Net</environment><super>Net.FTPSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-FTP-Support</category><attributes><package>FTP</package></attributes></class><comment><class-id>Net.FTPNoSocketSignal</class-id><body>This exception is signaled if FTP client does not have active socket connection to FTP server at the time of the request. It is application's responsibility to catch this signal. A possible strategy might be to send connect message to FTP client and retry the requestInstance Variables:</body></comment><class><name>FTPTransientReply</name><environment>Net</environment><super>Net.FTPSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-FTP-Support</category><attributes><package>FTP</package></attributes></class><comment><class-id>Net.FTPTransientReply</class-id><body>FTPTransientReply is signaled by the FTPProtocolInterpreter when the command was not accepted by the server and the requested action did not take place.  However, the error condition is temporary and the action may be requested again.Instance Variables:</body></comment><class><name>FTPChallenge</name><environment>Net</environment><super>Net.FTPSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-FTP-Support</category><attributes><package>FTP</package></attributes></class><comment><class-id>Net.FTPChallenge</class-id><body>FTPChallenge is signaled when the FTPProtocolInterpreter discovers that socket is no longer active and is used to restart client connection.  Instance Variables:</body></comment><class><name>FTPResponse</name><environment>Net</environment><super>Net.NetworkResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-FTP-Support</category><attributes><package>FTP</package></attributes></class><comment><class-id>Net.FTPResponse</class-id><body>The File Transfer Protocol defines that each request to the server will have a response.  The response syntax is a three digit number followed by an english message.  Here is an excerpt from RFC959 exlaining the five different types of responses.            1yz   Positive Preliminary reply               The requested action is being initiated; expect another               reply before proceeding with a new command.  (The               user-process sending another command before the               completion reply would be in violation of protocol; but               server-FTP processes should queue any commands that               arrive while a preceding command is in progress.)  This               type of reply can be used to indicate that the command               was accepted and the user-process may now pay attention               to the data connections, for implementations where               simultaneous monitoring is difficult.  The server-FTP               process may send at most, one 1yz reply per command.            2yz   Positive Completion reply               The requested action has been successfully completed.  A               new request may be initiated.            3yz   Positive Intermediate reply               The command has been accepted, but the requested action               is being held in abeyance, pending receipt of further               information.  The user should send another command               specifying this information.  This reply is used in               command sequence groups.            4yz   Transient Negative Completion reply               The command was not accepted and the requested action did               not take place, but the error condition is temporary and               the action may be requested again.  The user should               return to the beginning of the command sequence, if any.               It is difficult to assign a meaning to "transient",               particularly when two distinct sites (Server- and               User-processes) have to agree on the interpretation.               Each reply in the 4yz category might have a slightly               different time value, but the intent is that the               user-process is encouraged to try again.  A rule of thumb               in determining if a reply fits into the 4yz or the 5yz               (Permanent Negative) category is that replies are 4yz if               the commands can be repeated without any change in               command form or in properties of the User or Server               (e.g., the command is spelled the same with the same               arguments used; the user does not change his file access               or user name; the server does not put up a new               implementation.)            5yz   Permanent Negative Completion reply               The command was not accepted and the requested action did               not take place.  The User-process is discouraged from               repeating the exact request (in the same sequence).  Even               some "permanent" error conditions can be corrected, so               the human user may want to direct his User-process to               reinitiate the command sequence by direct action at some               point in the future (e.g., after the spelling has been               changed, or the user has altered his directory status.)         The following function groupings are encoded in the second         digit:            x0z   Syntax - These replies refer to syntax errors,                  syntactically correct commands that don't fit any                  functional category, unimplemented or superfluous                  commands.            x1z   Information -  These are replies to requests for                  information, such as status or help.            x2z   Connections - Replies referring to the control and                  data connections.            x3z   Authentication and accounting - Replies for the login                  process and accounting procedures.            x4z   Unspecified as yet.            x5z   File system - These replies indicate the status of the                  Server file system vis-a-vis the requested transfer or                  other file system action.         The third digit gives a finer gradation of meaning in each of         the function categories, specified by the second digit.  The         list of replies below will illustrate this.  Note that the text         associated with each reply is recommended, rather than         mandatory, and may even change according to the command with         which it is associated.  The reply codes, on the other hand,         must strictly follow the specifications in the last section;         that is, Server implementations should not invent new codes for         situations that are only slightly different from the ones         described here, but rather should adapt codes already defined.Instance Variables:</body></comment><class><name>FTPIntermediateReply</name><environment>Net</environment><super>Net.FTPSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-FTP-Support</category><attributes><package>FTP</package></attributes></class><comment><class-id>Net.FTPIntermediateReply</class-id><body>FTPIntermediateReply is signaled when the FTPProtocolInterpreter receives a intermediate reply from the server.  It is trapped in the FTPClient and used to execute a series of Ftp commands.  Instance Variables:</body></comment><class><name>FTPConnectionSignal</name><environment>Net</environment><super>Net.FTPSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-FTP-Support</category><attributes><package>FTP</package></attributes></class><comment><class-id>Net.FTPConnectionSignal</class-id><body>Signaled when a lack of connection is detected.Instance Variables:</body></comment><shared-variable><name>DefaultPassiveMode</name><environment>Net.FtpURL</environment><private>false</private><constant>false</constant><category>defaults</category><attributes><package>FTP</package></attributes></shared-variable><shared-variable><name>ProtocolErrorSignal</name><environment>Net.FTPProtocolInterpreter</environment><private>true</private><constant>false</constant><category>obsolete</category><initializer>nil</initializer><attributes><package>FTP</package></attributes></shared-variable><shared-variable><name>Resp250</name><environment>Net.FTPProtocolInterpreter</environment><private>true</private><constant>false</constant><category>responses</category><attributes><package>FTP</package></attributes></shared-variable><shared-variable><name>CrLf</name><environment>Net.FTPProtocolInterpreter</environment><private>true</private><constant>false</constant><category>statics</category><initializer>nil</initializer><attributes><package>FTP</package></attributes></shared-variable><shared-variable><name>Resp257</name><environment>Net.FTPProtocolInterpreter</environment><private>true</private><constant>false</constant><category>responses</category><attributes><package>FTP</package></attributes></shared-variable><shared-variable><name>Resp125</name><environment>Net.FTPProtocolInterpreter</environment><private>true</private><constant>false</constant><category>responses</category><attributes><package>FTP</package></attributes></shared-variable><shared-variable><name>Resp331</name><environment>Net.FTPProtocolInterpreter</environment><private>true</private><constant>false</constant><category>responses</category><attributes><package>FTP</package></attributes></shared-variable><shared-variable><name>Resp150</name><environment>Net.FTPProtocolInterpreter</environment><private>true</private><constant>false</constant><category>responses</category><attributes><package>FTP</package></attributes></shared-variable><shared-variable><name>PermErrorSignal</name><environment>Net.FTPProtocolInterpreter</environment><private>true</private><constant>false</constant><category>obsolete</category><initializer>nil</initializer><attributes><package>FTP</package></attributes></shared-variable><shared-variable><name>TempErrorSignal</name><environment>Net.FTPProtocolInterpreter</environment><private>true</private><constant>false</constant><category>obsolete</category><initializer>nil</initializer><attributes><package>FTP</package></attributes></shared-variable><shared-variable><name>Resp227</name><environment>Net.FTPProtocolInterpreter</environment><private>true</private><constant>false</constant><category>responses</category><attributes><package>FTP</package></attributes></shared-variable><shared-variable><name>Resp332</name><environment>Net.FTPProtocolInterpreter</environment><private>true</private><constant>false</constant><category>responses</category><attributes><package>FTP</package></attributes></shared-variable><shared-variable><name>Resp200</name><environment>Net.FTPProtocolInterpreter</environment><private>true</private><constant>false</constant><category>responses</category><attributes><package>FTP</package></attributes></shared-variable><shared-variable><name>ReplyError</name><environment>Net.FTPClient</environment><private>true</private><constant>false</constant><category>obsolete</category><initializer>nil</initializer><attributes><package>FTP</package></attributes></shared-variable><shared-variable><name>DebugLevels</name><environment>Net.FTPClient</environment><private>false</private><constant>false</constant><category>debugging</category><initializer>Core.Set new</initializer><attributes><package>FTP</package></attributes></shared-variable><shared-variable><name>PermError</name><environment>Net.FTPClient</environment><private>true</private><constant>false</constant><category>obsolete</category><initializer>nil</initializer><attributes><package>FTP</package></attributes></shared-variable><shared-variable><name>TempError</name><environment>Net.FTPClient</environment><private>true</private><constant>false</constant><category>obsolete</category><initializer>nil</initializer><attributes><package>FTP</package></attributes></shared-variable><shared-variable><name>ChallengeError</name><environment>Net.FTPClient</environment><private>true</private><constant>false</constant><category>obsolete</category><initializer>nil</initializer><attributes><package>FTP</package></attributes></shared-variable><shared-variable><name>CrLf</name><environment>Net.FTPClient</environment><private>true</private><constant>false</constant><category>statics</category><initializer>nil</initializer><attributes><package>FTP</package></attributes></shared-variable><shared-variable><name>ProtocolError</name><environment>Net.FTPClient</environment><private>true</private><constant>false</constant><category>obsolete</category><initializer>nil</initializer><attributes><package>FTP</package></attributes></shared-variable><shared-variable><name>CrLf</name><environment>Net.MacFTPProtocolInterpreter</environment><private>false</private><constant>false</constant><category>const</category><initializer>Array new: 5</initializer><attributes><package>FTP</package></attributes></shared-variable><methods><class-id>Net.FTPProtocolInterpreter</class-id> <category>connection management</category><body package="FTP" selector="connectToHost:port:">connectToHost: aHostName port: aNumber	self socket:( SocketAccessor				family: SocketAccessor pfInet				type: SocketAccessor sockStream).	self socket connectTo: (IPSocketAddress hostName: aHostName port: aNumber).	self stream: self socket readStream lineEndCRLF.	[self getResponse] on: FTPPreliminaryReply do: [ :ex | ex retry ].	^self</body><body package="FTP" selector="disconnect">disconnect	self closeConnection</body></methods><methods><class-id>Net.FTPProtocolInterpreter</class-id> <category>accessing</category><body package="FTP" selector="closed">closed	^self socket == nil or: [ self socket isActive not ]</body><body package="FTP" selector="mutex">mutex	mutex == nil ifTrue: [mutex := Semaphore forMutualExclusion].	^mutex</body><body package="FTP" selector="passiveServer">passiveServer		^passiveServer</body><body package="FTP" selector="passiveServer:">passiveServer: aBoolean	passiveServer := aBoolean</body><body package="FTP" selector="setServerActive">setServerActive	"Use passive or active mode for data transfers.  With a false argument,	use the normal PORT mode.  With a true argument, use the PASV command and	the server will provide a port on which it is listening."	self passiveServer: false</body><body package="FTP" selector="setServerPassive">setServerPassive	"Use passive or active mode for data transfers.  With a false argument,	use the normal PORT mode.  With a true argument, use the PASV command and	the server will provide a port on which it is listening."	self passiveServer: true</body><body package="FTP" selector="socket">socket 	^socket</body><body package="FTP" selector="socket:">socket: aSocket	socket := aSocket</body><body package="FTP" selector="stream">stream	^stream</body><body package="FTP" selector="stream:">stream: aStream	stream := aStream</body></methods><methods><class-id>Net.FTPProtocolInterpreter</class-id> <category>private</category><body package="FTP" selector="closeConnection">closeConnection	stream notNil ifTrue: [stream close].	socket notNil ifTrue: [socket close]</body><body package="FTP" selector="parseResponse">parseResponse	"get a response"	^FTPResponse readFrom: self stream</body><body package="FTP" selector="privatePollResponse">privatePollResponse" Answer next response if one is waiting, nil otherwise "	^socket notNil 		ifTrue: [(socket readWaitWithTimeoutMs: 0) ifFalse: [self parseResponse]]		ifFalse: [ nil ]</body><body package="FTP" selector="privateResponse">privateResponse	"get a response"	| resp nextResp |	resp := self parseResponse.	[(nextResp := self privatePollResponse) notNil] whileTrue: [resp := nextResp].	^resp</body><body package="FTP" selector="putCommand:">putCommand: aString 	| line |	line := aString , CrLf.	self class log: [((#put1s &lt;&lt; #net &gt;&gt; '*put*  &lt;1s&gt;')			expandMacrosWith: (self sanitize: line))] level: #FTPClient.	self socket isActive			ifFalse: 			[FTPProtocolInterpreter log: [(#ExceptionSocketIsNotActive &lt;&lt; #net &gt;&gt; '*exception* socket is not active')] level: #FTPException.			FTPNoSocketSignal raise ].		[self socket writeWaitWithTimeoutMs: 200 ] 		whileTrue: [self pollResponse].	self socket sendTo: self socket getPeer buffer: line</body><body package="FTP" selector="sanitize:">sanitize: aString 	"Internal"	| s |	s := aString copy.	((s copyFrom: 1 to: (5 min: aString size))		sameAs: 'pass ')		ifTrue: 			[| i |			i := s size.			[i &gt; 5 and: [CrLf includes: (s at: i - 1)]]				whileTrue: [i := i - 1].			s := (s copyFrom: 1 to: 5)						, ((String new: i - 5)								atAllPut: $*) , (s copyFrom: i + 1 to: s size)].	^s</body></methods><methods><class-id>Net.FTPProtocolInterpreter</class-id> <category>protocol commands</category><body package="FTP" selector="abort">abort	"Abort a file transfer "	| line |	self class log: ['*put*  ABOR'] level: #FTPClient.	self mutex critical:		[line := 'ABOR' , CrLf.		self socket			sendTo: self socket getPeer			buffer: line			start: 1			for: line size			flags: SocketAccessor msgOob].	^self getResponse</body><body package="FTP" selector="makeport">makeport	"Create a new socket and send a PORT 	command for it."	| sock resp |	sock := FTPSocketAccessor newTCP.	sock listenFor: 1.	(resp := self sendport: (self socket getName hostAddress) with: sock getName port) isSuccess		ifFalse: [ self class permSignal raiseWith: resp. ].	^sock</body><body package="FTP" selector="pollResponse">pollResponse" Answer next response if one is waiting, nil otherwise "		| resp |	^(resp := self privatePollResponse) notNil		ifTrue: [FTPSignal handleResponse: resp]		ifFalse: [ nil ]</body><body package="FTP" selector="sendCommand:">sendCommand: aString 	"Send a command and return the response. Expect a successful response, if not generate an exception."	^self putCommand: aString; getResponse</body><body package="FTP" selector="sendport:with:">sendport: aHostAddress with: aPort 	"Send a PORT command with the current 	[sic] host and 	the given port number."	| bytes cmd |	bytes := aHostAddress, (ByteArray with: aPort // 256 with: aPort \\ 256).	cmd := 'PORT '.	bytes do: [:byte | cmd := cmd , byte printString]		separatedBy: [cmd := cmd , ','].	^self sendCommand: cmd</body></methods><methods><class-id>Net.FTPProtocolInterpreter</class-id> <category>responses</category><body package="FTP" selector="getResponse">getResponse	"Obtains and answers an instance of FTPResponse "	^FTPSignal handleResponse: self privateResponse</body></methods><methods><class-id>Net.FTPProtocolInterpreter</class-id> <category>initialize-release</category><body package="FTP" selector="initialize">initialize	Settings ftpPassiveMode		ifTrue: [ self setServerPassive]		ifFalse: [self setServerActive].</body></methods><methods><class-id>Net.FTPProtocolInterpreter class</class-id> <category>signals</category><body package="FTP" selector="challengeSignal">challengeSignal	^FTPChallenge</body><body package="FTP" selector="connectionSignal">connectionSignal	^FTPConnectionSignal</body><body package="FTP" selector="intermediateSignal">intermediateSignal	^FTPIntermediateReply</body><body package="FTP" selector="permErrorSignal">permErrorSignal	^FTPPermSignal</body><body package="FTP" selector="permSignal">permSignal	^FTPPermSignal</body><body package="FTP" selector="preliminarySignal">preliminarySignal		^FTPPreliminaryReply</body><body package="FTP" selector="transientErrorSignal">transientErrorSignal	^FTPTransientReply</body></methods><methods><class-id>Net.FTPProtocolInterpreter class</class-id> <category>instance creation</category><body package="FTP" selector="connectToHost:port:">connectToHost: aHostName port: aNumber	^self new connectToHost: aHostName port: aNumber</body><body package="FTP" selector="new">new	^super new initialize</body></methods><methods><class-id>Net.FTPProtocolInterpreter class</class-id> <category>initialization</category><body package="FTP" selector="initialize">initialize	"self initialize"		self initializeSequences.	self initializeSignals.	self registerToDebug</body><body package="FTP" selector="initializeSequences">initializeSequences	CrLf := String with: Character cr with: Character lf.</body><body package="FTP" selector="initializeSignals">initializeSignals	"self initializeSignals"	"unexpected [123]xx reply"	FTPPreliminaryReply		notifierString: (#x1xxReply &lt;&lt; #net &gt;&gt; '1xx reply');		nameClass: self message: #preliminarySignal.	FTPIntermediateReply		notifierString: (#x3xxReply &lt;&lt; #net &gt;&gt; '3xx reply');		nameClass: self message: #intermediateSignal.	FTPTransientReply 		notifierString: (#x4xxError &lt;&lt; #net &gt;&gt; '4xx error');		nameClass: self message: #transientErrorSignal.	FTPPermSignal		notifierString: (#x5xxError &lt;&lt; #net &gt;&gt; '5xx error'); 		nameClass: self message: #permSignal.	FTPChallenge		notifierString: (#needToMakeConnection &lt;&lt; #net &gt;&gt; 'need to make connection'); 		nameClass: self message: #challengeSignal.			FTPConnectionSignal		notifierString: (#needToMakeConnection &lt;&lt; #net &gt;&gt; 'need to make connection'); 		nameClass: self message: #connectionSignal.</body></methods><methods><class-id>Net.FTPProtocolInterpreter class</class-id> <category>debugging</category><body package="FTP" selector="debugLabelsAndValues">debugLabelsAndValues	^OrderedCollection new		add: ((#FTPClientCommands &lt;&lt; #net &gt;&gt; 'FTPClient Commands')-&gt;#FTPClient);		add: ((#FTPResponses &lt;&lt; #net &gt;&gt; 'FTPResponses')-&gt;#FTPResponse);		add: ((#FTPTesting &lt;&lt; #net &gt;&gt; 'FTP Testing')-&gt;#FTPTest);		add: ((#FTPExceptions &lt;&lt; #net &gt;&gt; 'FTPExceptions')-&gt;#FTPException);		yourself</body><body package="FTP" selector="log:level:">log: aString level: aLevel	Tools.LogEnvironment default log: aString level: aLevel</body><body package="FTP" selector="menuItemName">menuItemName	^(#FTPMessages &lt;&lt; #net &gt;&gt; 'FTP Messages')</body><body package="FTP" selector="registerToDebug">registerToDebug	Tools.LogEnvironment default addToDebug: self</body></methods><methods><class-id>Net.FtpPage</class-id> <category>accessing</category><body package="FTP" selector="anonymousLoginPassword">anonymousLoginPassword	^self userPreferencesAt: #anonymousLoginPassword		ifAbsentPut: [self defaultAnonymousLoginPassword asValue ]</body><body package="FTP" selector="defaultAnonymousLoginPassword">defaultAnonymousLoginPassword	| pass val |	val := (pass := self registry anonymousLoginPassword) notNil 				ifTrue: [pass]				ifFalse: [String new].	^(val isEmpty 		and: [self netUserMenu value menuItems notEmpty 			and: [self userListOwner defaultUser notNil ] ])		ifTrue: [self userListOwner defaultUser mailAddress]		ifFalse: [val]</body><body package="FTP" selector="helpText">helpText	^(#FtpSettingsHelp &lt;&lt; #net &gt;&gt; 'FTP Settings set the defaults for anonymous FTP sessions.Use Passive Mode, if checked, causes the server to enter passive mode for the transaction. The then listens for the client to make the connection and initiate the transfer. This is sometimes necessary for clients located behind a firewall.Password (E-mail address): specifies the email address to be used as your password for anonymous FTP connections.  Anonymous FTP sites typically accept "anonymous" as the user name and an email address as the password.') asString</body><body package="FTP" selector="netUserMenu">netUserMenu 	^self userListOwner netUserMenu</body><body package="FTP" selector="usePassiveMode">usePassiveMode	^self 		userPreferencesAt: #usePassiveMode 		ifAbsentPut: [self registry ftpPassiveMode  asValue]</body></methods><methods><class-id>Net.FtpPage</class-id> <category>interface opening</category><body package="FTP" selector="postBuildWith:">postBuildWith: aBuilder	self anonymousLoginPassword onChangeSend: #tickle to: self.	self usePassiveMode onChangeSend: #tickle to: self.</body></methods><methods><class-id>Net.FtpPage</class-id> <category>actions</category><body package="FTP" selector="accept">accept	self registry ftpPassiveMode: self usePassiveMode value.	self registry ftpAnonymousLoginPassword: self anonymousLoginPassword value</body><body package="FTP" selector="importSnapshots:">importSnapshots: aCollection	super importSnapshots: aCollection.	self userListOwner reset</body><body package="FTP" selector="reset">reset	self anonymousLoginPassword value: self defaultAnonymousLoginPassword.	self usePassiveMode value: self registry ftpPassiveMode</body><body package="FTP" selector="resetUIStateToDefault">resetUIStateToDefault	self anonymousLoginPassword value: self defaultAnonymousLoginPassword.	self usePassiveMode value: self registry ftpPassiveModeDefault</body></methods><methods><class-id>Net.FTPSocketAccessor</class-id> <category>accessing</category><body package="FTP" selector="callback">callback	^callback</body><body package="FTP" selector="callback:">callback: aBlock	callback := aBlock</body><body package="FTP" selector="ftpConn">ftpConn	^ftpConn</body><body package="FTP" selector="ftpConn:">ftpConn: aValue	ftpConn := aValue</body></methods><methods><class-id>Net.FTPSocketAccessor</class-id> <category>private</category><body package="FTP" selector="close">close	| res |	super close.	self callback notNil 		ifTrue: 			[[res := callback value]				on: FTPSignal 				do: [:ex | ex return]].	^res</body><body package="FTP" selector="primReadInto:startingAt:for:">primReadInto: buffer startingAt: index for: count 	"buffer is a byte-object, the place where IO is performed. 	index is a SmallInteger, the starting-point in the buffer. 	count is a SmallInteger, the number of bytes to be read."	"Returns a SmallInteger, which is the count of the bytes read."	"WouldBlock is a potential error condition.	Assume that the connection was canceled after 1 second of retries."	|cnt|	cnt := 5.	^[self 		privateReadInto: buffer		startingAt: index		for: count]		on: OsNeedRetryError do: [:ex | cnt := cnt -1.									cnt &gt; 0 ifTrue: [ex restart]											ifFalse: [ex returnWith: 0]]</body><body package="FTP" selector="privateReadInto:startingAt:for:">privateReadInto: buffer startingAt: index for: count 	"buffer is a byte-object, the place where IO is performed. 	index is a SmallInteger, the starting-point in the buffer. 	count is a SmallInteger, the number of bytes to be read."	"Returns a SmallInteger, which is the count of the bytes read."	"WouldBlock is a potential error condition."	&lt;primitive: 679&gt;	(self class restartableError: errorCode)		ifTrue: 			[ftpConn notNil ifTrue: [ftpConn pollResponses].			self readWaitWithTimeoutMs: self readPauseInterval.			^OSErrorHolder needRetrySignal raise].	^self reportErrorProceeding</body></methods><methods><class-id>Net.FTPUser</class-id> <category>accessing</category><body package="FTP" selector="account">account	^account</body><body package="FTP" selector="account:">account: aString	account := aString</body></methods><methods><class-id>Net.FTPUser</class-id> <category>instance creation</category><body package="FTP" selector="createUser:password:account:">createUser: nameString password: passwdString account: acctString	self username: nameString.	self password: passwdString.	self account: acctString.</body></methods><methods><class-id>Net.FTPUser class</class-id> <category>instance creation</category><body package="FTP" selector="createUser:password:account:">createUser: nameString password: passwdString account: acctString	^self new createUser: nameString password: passwdString account: acctString</body></methods><methods><class-id>Net.FtpURL</class-id> <category>private</category><body package="FTP" selector="beCurrentDirectoryFor:with:">beCurrentDirectoryFor: anFtpUrl with: aClient 	" Opportunistic code: try chaging directory using full path. This failed, try segment-by-segment descent "	[aClient setCurrentDirectory: anFtpUrl filePathString] 		on: FTPPermSignal		do: 			[:ex | 			1 to: anFtpUrl path size do: [ :ind | aClient setCurrentDirectory: (anFtpUrl pathAt: ind) ]]</body><body package="FTP" selector="client">client	| effectiveUser effectivePassword client |	user == nil		ifTrue:			[effectiveUser := 'anonymous'.			effectivePassword := self class emailAddress]		ifFalse:			[effectiveUser := user.			effectivePassword := password].	client := FTPClient connectToHost: host port: port.	[client login: effectiveUser passwd: effectivePassword ]		on: FTPChallenge 		do: [ :ex |				(self handleChallenge: ex parameter for: client) 					ifTrue: [ ex return ]					ifFalse: [ ex pass ] ].	self passiveMode ifTrue: [ client setServerPassive ].	^client</body><body package="FTP" selector="copyFromFTP:">copyFromFTP: aURI	"Copied from superclass, but we could eventually optimize this to do server to server transfers."	self writeStreamDo: [:dest |		aURI readStreamDo: [:src :parms |			[src atEnd] whileFalse:				[dest nextPutAll: (src nextAvailable: 1024)]]]</body><body package="FTP" selector="fileDirectoryDo:">fileDirectoryDo: aDyadicBlock 	" Position to current directory and evaluate dyadic block. First argument is canonicalized uri, the second is FTP client used in operations "		| client canonical |	^self safelyExecuteBlock: 		[client := self client.		canonical := self canonicalize.		self 			beCurrentDirectoryFor: canonical directory			with: client.		aDyadicBlock 			value: canonical			value: client]</body><body package="FTP" selector="fileDirectoryDoAndClose:">fileDirectoryDoAndClose: aDyadicBlock 	" Same as fileDirectoryDo: but ensure client is closed at the end "		^self fileDirectoryDo: 		[:canonicalUri :client | 		[aDyadicBlock value: canonicalUri value: client] 			ensure: [client close]]</body><body package="FTP" selector="handleChallenge:for:">handleChallenge: aResponse for: client	| str |	aResponse needAccountForLogin		ifTrue: 			[ (str := Dialog 						request: ((#ProvideLoginAccountFor &lt;&lt; #net &gt;&gt; 'Please, provide login account for &lt;1s&gt;')			expandMacrosWith: client hostName)) isEmpty not				ifTrue: [  client account: str. ^true]].	aResponse needPassword		ifTrue: 			[(str := SimplePasswordDialog new						request: ((#ProvideLoginPasswordFor &lt;&lt; #net &gt;&gt; 'Please, provide login password for &lt;1s&gt;')			expandMacrosWith: client hostName)						initialAnswer: ''						onCancel: []) notNil				ifTrue: [ client pass: str. ^true ]].	^false</body><body package="FTP" selector="indexFor:">indexFor: aClient	| index |	path last = ''		ifTrue: [index := path size-1]		ifFalse: [index := path size].	1 to: index-1 do: [:i | aClient setCurrentDirectory: (self pathAt: i)].	^index</body><body package="FTP" selector="passwordSameAs:">passwordSameAs: aURI	|  p1 p2 |	p1 := self password ifNil: [ String new].	p2 := aURI password ifNil: [ String new].	^p1 = p2 or: [ ('anonymous' match: self user) and: [ p1 match: p2 ]]</body><body package="FTP" selector="printPath:on:">printPath: aPathArray on: str	aPathArray size = 0		ifTrue: [str nextPutAll: '/']		ifFalse: [aPathArray do: [:s | str nextPutAll: '/', s]].</body><body package="FTP" selector="protocolSignals">protocolSignals	^FTPSignal</body><body package="FTP" selector="simpleDirectory">simpleDirectory	^super directory</body><body package="FTP" selector="userSameAs:">userSameAs: aURL	| us1 us2 |	us1 := self user ifNil: [ String new].	us2 := aURL user ifNil: [ String new].	^us1 match: us2</body></methods><methods><class-id>Net.FtpURL</class-id> <category>accessing</category><body package="FTP" selector="asString">asString	| str |	str := (String new: 64) writeStream.	self printProtocolOn: str.	self printUserOn: str.	self printAuthorityOn: str.	^str contents</body><body package="FTP" selector="passiveMode">passiveMode	passiveMode isNil 		ifTrue: [ passiveMode := self class defaultPassiveMode ].	^passiveMode</body><body package="FTP" selector="passiveMode:">passiveMode: aBoolean	passiveMode := aBoolean</body><body package="FTP" selector="password">password	^password</body><body package="FTP" selector="resource">resource	| data |	data := self readStreamDo: [:str :params | str contents].	^XML.InputSource		uri: self		encoding: nil		stream: (data withEncoding: #UTF_8) readStream lineEndTransparent</body><body package="FTP" selector="setServerActive">setServerActive	self passiveMode: false</body><body package="FTP" selector="setServerPassive">setServerPassive	self passiveMode: true</body><body package="FTP" selector="user">user	^user</body></methods><methods><class-id>Net.FtpURL</class-id> <category>stream -- unguarded</category><body package="FTP" selector="appendStream">appendStream	self isDirectory ifTrue: [self error: (#AppendStreamCanntBeOpenedOnDirectory &lt;&lt; #net &gt;&gt; 'An appendStream cannot be opened on a directory')].	^self fileDirectoryDo: [ :canonicalUri :client | client appendBinaryStream: canonicalUri tail]</body><body package="FTP" selector="binaryReadStream">binaryReadStream	^self fileDirectoryDo: [ :canonicalUri :client | client readBinaryStream: canonicalUri tail]</body><body package="FTP" selector="binaryWriteStream">binaryWriteStream	^self fileDirectoryDo: [ :canonicalUri :client | client writeBinaryStream: canonicalUri tail]</body><body package="FTP" selector="envelopeAppendStream">envelopeAppendStream	^self appendStream</body><body package="FTP" selector="envelopeReadStream">envelopeReadStream	^self readStream</body><body package="FTP" selector="envelopeWriteStream">envelopeWriteStream	^self writeStream</body></methods><methods><class-id>Net.FtpURL</class-id> <category>utilities</category><body package="FTP" selector="asFilename">asFilename" Just have this method, please "</body><body package="FTP" selector="contentsOfEntireFile">contentsOfEntireFile	"Answer the contents of the file represented by the receiver."	^self readStreamDo: [ :stream :context | stream contents]</body><body package="FTP" selector="copyTo:">copyTo: aURI	aURI asURI copyFromFTP: self</body><body package="FTP" selector="delete">delete		| isDir |	isDir := self isDirectory.	^isDir 		ifTrue: [self removeDirectory]		ifFalse: [self removeFile]</body><body package="FTP" selector="directory">directory	^self canonicalize simpleDirectory</body><body package="FTP" selector="fastDelete">fastDelete	" This is an opportunistic version of delete that first attempts to delete it as file and only if this fails tries to deleye it as a directory "	[self removeFile]			on: FTPPermSignal		do: [ :ex | self removeDirectory]</body><body package="FTP" selector="fileSize">fileSize	" Try SIZE command first, this failed, try getting file size harder way that requires us to set up transfer "	^self fileDirectoryDoAndClose: 		[:canonicalUri :client | 		[(client fileSize: canonicalUri tail) parse213AsBytes ] 			on: FTPPermSignal			do: [:ex | ex return: (client fileSizeFromTransferSetup: canonicalUri tail)]]</body><body package="FTP" selector="head">head	| p index |	p := (String new: 32) writeStream.	path isEmpty ifTrue: [^''].	self isDirectory 		ifTrue: [index := path size]		ifFalse: [index := path size - 1].	^index &gt; 0		ifTrue:			[1 to: index -1 do: [:i | p nextPutAll: ((self pathAt: i), '/')].			p nextPutAll: (self pathAt: index).			p contents]		ifFalse: [String new]</body><body package="FTP" selector="makeDirectory">makeDirectory		^self fileDirectoryDoAndClose: 		[:canonicalUri :client | client makeDirectory: canonicalUri tail]</body><body package="FTP" selector="modTime">modTime	"Return modification time of fileName."	^self fileDirectoryDoAndClose: 		[:canonicalUri :client | (client modTime: canonicalUri tail) parse213AsTimestamp ]</body><body package="FTP" selector="removeDirectory">removeDirectory		^self fileDirectoryDoAndClose: 		[:canonicalUri :client | client removeDirectory: canonicalUri tail]</body><body package="FTP" selector="removeFile">removeFile		^self fileDirectoryDoAndClose: 		[:canonicalUri :client | client deleteFile: canonicalUri tail]</body></methods><methods><class-id>Net.FtpURL</class-id> <category>printing</category><body package="FTP" selector="directoryPathString">directoryPathString	| stream |	stream := (String new: 64) writeStream.	self printDirectoryPathOn: stream.	^stream contents</body><body package="FTP" selector="filePathString">filePathString	| stream |	stream := (String new: 32) writeStream.	self printPathOn: stream.	^stream contents</body><body package="FTP" selector="printDirectoryPathOn:">printDirectoryPathOn: aStream 		^self directory printPathOn: aStream</body><body package="FTP" selector="printUserOn:">printUserOn: aStream	user == nil ifFalse:		[self class encodeUserPass: user on: aStream.		password == nil ifFalse:			[aStream nextPutAll: ':'.			self class encodeUserPass: password on: aStream].		aStream nextPutAll: '@'].</body></methods><methods><class-id>Net.FtpURL</class-id> <category>stream -- guarded</category><body package="FTP" selector="readStreamDo:">readStreamDo: aBlock 	^self fileDirectoryDoAndClose: 		[:canonicalUri :client | 		client 			readBinaryStream: canonicalUri tail			do: 				[:data | 				aBlock 					value: data					value: (Dictionary new 								at: #MIME 								put: canonicalUri guessMimeType; yourself)]]</body><body package="FTP" selector="writeStreamDo:">writeStreamDo: aBlock 	| res |	^self fileDirectoryDoAndClose: 		[:canonicalUri :client |  		res := client 			writeBinaryStream: canonicalUri tail			do:	aBlock.		(Delay forMilliseconds: 100) wait.		res]</body></methods><methods><class-id>Net.FtpURL</class-id> <category>testing</category><body package="FTP" selector="exists">exists	path isEmpty ifTrue: [^true].	path asSet asArray = #('') ifTrue: [^true].	^self fileDirectoryDoAndClose: 			[:canonicalUri :client | 			client parseDirectoryContents: #()				do: [:dictionary | ((dictionary at: #name) match: self tail) ifTrue: [^true]].			false]</body><body package="FTP" selector="isDirectory">isDirectory	path isEmpty ifTrue: [^true].	path asSet asArray = #('') ifTrue: [^true].	^self fileDirectoryDoAndClose: 			[:canonicalUri :client | 			client parseDirectoryContents: #()				do: 					[:dictionary | 					((dictionary at: #name) match: self tail) ifTrue: [^dictionary at: #isDir]].			false]</body></methods><methods><class-id>Net.FtpURL</class-id> <category>file utilities</category><body package="FTP" selector="canonicalize">canonicalize		^(path size &gt; 0 and: [path last = '']) 		ifTrue: 			[self copy				path: (path copyFrom: 1 to: path size - 1);				yourself]		ifFalse: [self]</body><body package="FTP" selector="directoryContents">directoryContents	| client results basePath canonical |	^self safelyExecuteBlock: 			[client := self client.			results := OrderedCollection new.						[canonical := self canonicalize.			basePath := canonical path.			self beCurrentDirectoryFor: canonical with: client.			client parseDirectoryContents: #()				do: 					[:dictionary | 					| name newPath |					name := dictionary at: #name.					newPath := (dictionary at: #isDir) 								ifTrue: [basePath , (Array with: (canonical escaped: name) with: '')]								ifFalse: [basePath copyWith: (self escaped: name)].					results add: (canonical copy path: newPath)]] 					ensure: [client close].			results]</body></methods><methods><class-id>Net.FtpURL</class-id> <category>resolution</category><body package="FTP" selector="construct:">construct:  aFileComponent	^self canonicalize copy		addComponent: aFileComponent;		yourself</body></methods><methods><class-id>Net.FtpURL</class-id> <category>initialize</category><body package="FTP" selector="parseHost:">parseHost: aHostSpecification 	| fullHost |	fullHost := self parseUserinfo: aHostSpecification.	self parseHostPort: fullHost</body><body package="FTP" selector="parseUserinfo:">parseUserinfo: aHostSpecification 	| idx fullUser fullHost |	(aHostSpecification includes: $@)		ifTrue:			[idx := aHostSpecification lastIndexOf: $@.			fullUser := aHostSpecification copyFrom: 1 to: idx-1.			fullHost := aHostSpecification copyFrom: idx+1 to: aHostSpecification size.			(fullUser includes: $:)				ifTrue:					[idx := fullUser indexOf: $:.					user := self validateUser: (fullUser copyFrom: 1 to: idx-1).					password := self validatePassword: (fullUser copyFrom: idx+1 to: fullUser size)]				ifFalse:					[user := self validateUser: fullUser.					password := nil]]		ifFalse:			[user := nil.			password := nil.			fullHost := aHostSpecification].	^fullHost</body></methods><methods><class-id>Net.FtpURL</class-id> <category>comparing</category><body package="FTP" selector="sameAs:">sameAs: aURI	^(super sameAs: aURI)		and: [ (user isNil and: [ aURI user isNil])				or: [	 (self userSameAs: aURI ) and: [ self passwordSameAs: aURI ]]]</body></methods><methods><class-id>Net.FtpURL class</class-id> <category>class initialization</category><body package="FTP" selector="initialize">initialize	"FtpURL initialize."	(ObjectMemory dependents includes: self) ifFalse:		[ObjectMemory addDependent: self].	DefaultPassiveMode := Settings ftpPassiveMode.</body><body package="FTP" selector="obsolete">obsolete	"Break dependencies"	[ObjectMemory dependents includes: self] whileTrue:		[ObjectMemory removeDependent: self].	^super obsolete</body></methods><methods><class-id>Net.FtpURL class</class-id> <category>accessing</category><body package="FTP" selector="defaultPassiveMode">defaultPassiveMode	^DefaultPassiveMode</body><body package="FTP" selector="defaultPassiveMode:">defaultPassiveMode: aBoolean	DefaultPassiveMode := aBoolean</body><body package="FTP" selector="emailAddress">emailAddress	" self emailAddress "	^userAddress isNil 		ifFalse: [userAddress]		ifTrue: [userAddress := Settings anonymousLoginPassword]</body><body package="FTP" selector="emailAddress:">emailAddress: aString	self userAddress: aString</body><body package="FTP" selector="protocol">protocol	^'ftp'</body><body package="FTP" selector="userAddress">userAddress	^userAddress</body><body package="FTP" selector="userAddress:">userAddress: aString	userAddress := aString</body><body package="FTP" selector="userAllowedChars">userAllowedChars	^self unreservedChar, ';&amp;=+$,'</body></methods><methods><class-id>Net.FtpURL class</class-id> <category>updating</category><body package="FTP" selector="update:with:from:">update: anAspectSymbol with: aParameter from: aSender	"Record snapshot changes to we now whther we're installed or not."	anAspectSymbol == #earlySystemInstallation ifTrue:		[userAddress := nil]</body></methods><methods><class-id>Net.FtpURL class</class-id> <category>private</category><body package="FTP" selector="getAddressFromMailFile">getAddressFromMailFile	^#{MailFile} ifDefinedDo: 		[:mailFile|  | domain |			mailFile installed				ifTrue: 					[domain := mailFile profileAt: 'set' at: 'domain' ifAbsent: [].					domain isNil						ifTrue: [self queryAddress]						ifFalse: [mailFile userName, '@', domain]]				ifFalse: [self queryAddress]]			elseDo: [self queryAddress]</body><body package="FTP" selector="queryAddress">queryAddress	| address |	address := Dialog request: (#WhatIsYourEmailAddress &lt;&lt; #net &gt;&gt; 'What is your email address?').	^address isEmpty		ifTrue: [self error: (#NoEmailAddressSupplied &lt;&lt; #net &gt;&gt; 'No email address supplied'). nil]		ifFalse: [address]</body></methods><methods><class-id>Net.FtpURL class</class-id> <category>encoding/decoding</category><body package="FTP" selector="encodeUserPass:on:">encodeUserPass: aString on: stream	self encode: aString  on: stream allowed: self userAllowedChars</body></methods><methods><class-id>Net.FtpURL class</class-id> <category>defaults</category><body package="FTP" selector="defaultPortNumber">defaultPortNumber	^SocketAccessor IPPORT_FTP</body></methods><methods><class-id>Net.FTPClient</class-id> <category>accessing</category><body package="FTP" selector="binaryBlockSize">binaryBlockSize	^binaryBlockSize</body><body package="FTP" selector="binaryBlockSize:">binaryBlockSize: anInteger	binaryBlockSize := anInteger</body><body package="FTP" selector="userAccount">userAccount	^self user account</body><body package="FTP" selector="userPassword">userPassword	^self user password</body></methods><methods><class-id>Net.FTPClient</class-id> <category>commands</category><body package="FTP" selector="abort">abort"Abort a file transfer. Intercept response 426. This response, if received, actually belongs to the data transfer thread, so we poll next response expecting it to be 226, which is ours.Once found, we make 426 to be the delayed response so that data transfer thread will get it on close, and return "	| nextResp |	^[self clientPI abort]		on: FTPTransientReply		do: [ :ex | ex parameter isTransferAborted					ifTrue: 						[(nextResp := self clientPI getResponse) isTransferCompletion							ifTrue: [delayedResponse := ex parameter. 									FTPProtocolInterpreter log: [((#SetDelayedResponse1s &lt;&lt; #net &gt;&gt; 'Set delayed response &lt;1s&gt;')			expandMacrosWith: delayedResponse code)] level: #FTPResponse.									FTPProtocolInterpreter log: [((#ReturningResponse1s &lt;&lt; #net &gt;&gt; 'Returning response &lt;1s&gt;')			expandMacrosWith: nextResp code)] level: #FTPResponse.									ex return: nextResp ].						" If we didn't find 226, just return this response "						FTPProtocolInterpreter log: [((#ReturningResponse1s &lt;&lt; #net &gt;&gt; 'Returning response &lt;1s&gt;')			expandMacrosWith: ex parameter code)] level: #FTPResponse.						ex return: ex parameter.]					ifFalse: [ ex pass ]]</body><body package="FTP" selector="account:">account: aString	"Send new account name."	^self executeCommand: 'ACCT ' , aString retryChallenge: false</body><body package="FTP" selector="beCurrentDirectory:">beCurrentDirectory: directoryName 	"obsolete"	^self setCurrentDirectory: directoryName</body><body package="FTP" selector="cmdRest:">cmdRest: position	| resp |	^[resp := self executeCommand: 'REST ', position printString. FTPSignal raiseWith: resp]		on: FTPChallenge		do: [:ex | ex parameter needFileInfo					ifTrue: [ex return: resp]					ifFalse: [ex pass]]</body><body package="FTP" selector="cmdUser:">cmdUser: aString 	"Send user"	^self executeCommand: 'USER ' , aString retryChallenge: false</body><body package="FTP" selector="currentWorkingDirectory">currentWorkingDirectory	^self executeSequence: [self executeCommand: 'PWD']</body><body package="FTP" selector="deleteFile:">deleteFile: aFileNameString 	^self executeSequence: [self executeCommand: 'DELE ' , aFileNameString]</body><body package="FTP" selector="fileSize:">fileSize: fileName 	"Return size of fileName."	^self executeSequence: [self executeCommand: 'SIZE ' , fileName]</body><body package="FTP" selector="fileSizeFromTransferSetup:">fileSizeFromTransferSetup: fileName 	"Return size of fileName. Setup transfer to get the remote side to tell us about file size, then promptly close data connection"	| array size accessor |	^self executeSequence: [		self binaryTransfer.		array := self privateStartTransferCmd: 'RETR ', fileName asString.		size := array last.		accessor := array first.		accessor callback: nil.		accessor close.		[self readFinalResponseBlock value] on: FTPSignal do: [ :ex | ex return].		size].</body><body package="FTP" selector="fileStructure">fileStructure	^self structure: $F</body><body package="FTP" selector="help">help	"Return server's default help information."	^self help: nil</body><body package="FTP" selector="help:">help: aString	"ask for specific HELP with the string value, not implemented on all servers."	^self executeSequence: 		[self executeCommand: ('HELP',( aString isString ifTrue: [ ' ',aString] ifFalse:[ '']))]</body><body package="FTP" selector="makeDirectory:">makeDirectory: directoryNameString 	^self executeSequence: [self executeCommand: 'MKD ' , directoryNameString]</body><body package="FTP" selector="mode:">mode: aChar	"This implementation only supports Stream mode"	"S - Stream 	B - Block	C - Compressed"	^self executeSequence: [self executeCommand: 'MODE ' , aChar asSymbol asString]</body><body package="FTP" selector="modTime:">modTime: fileName 	"Return modification time of fileName."	^self executeSequence: [self executeCommand: 'MDTM ' , fileName]</body><body package="FTP" selector="noop">noop	"this is the No Operation command used to check 	the server for a connection and proper response"	^self executeSequence: [self executeCommand: 'NOOP']</body><body package="FTP" selector="pass:">pass: aString 	"Send password"	^ self executeCommand:  'PASS ' , aString retryChallenge: false</body><body package="FTP" selector="presentWorkingDirectory">presentWorkingDirectory	^self executeSequence: [self executeCommand: 'PWD ']</body><body package="FTP" selector="quit">quit	| resp |	self clientPI socket isActive 		ifTrue: [ resp := self executeCommand: 'QUIT'].	self disconnect.	^resp</body><body package="FTP" selector="quote:">quote: aString	^self executeSequence: [self executeCommand: 'QUOTE ', aString]</body><body package="FTP" selector="remoteSystemType">remoteSystemType	^self executeSequence: [self executeCommand: 'SYST ']</body><body package="FTP" selector="removeDirectory:">removeDirectory: directoryNameString 	^self executeSequence: [self executeCommand: 'RMD ' , directoryNameString]</body><body package="FTP" selector="rename:to:">rename: dirOrFileName to: targetName 	"Rename initialFileName to targetFileName.  Where targetFileName is a filename only, not the path"	^self executeSequence: [ 			[self executeCommand: 'RNFR ' , dirOrFileName] 				on: FTPChallenge				do: [:ex | ex parameter needFileInfo					ifTrue: [ex return: (self executeCommand: 'RNTO ' , targetName)]					ifFalse: [ex pass]]]</body><body package="FTP" selector="setCurrentDirectory:">setCurrentDirectory: directoryName 	"Change to the directory named 	directoryName."	| cmd |	cmd := directoryName = '..'				ifTrue: ['CDUP']				ifFalse: ['CWD ' , directoryName].	^self executeSequence: [self executeCommand: cmd]</body><body package="FTP" selector="setRemoteStreamPosition:">setRemoteStreamPosition: position" Set position in remote stream for the next transfer operation. This command should result in 350 response. Anything elese is error "	^[self executeCommand: 'REST ' , position asString] 		on: FTPChallenge		do: [:ex | ex parameter needFileInfo					ifTrue: [ex return]					ifFalse: [ex pass]]</body><body package="FTP" selector="setServerActive">setServerActive	"Use this command in conjunction with a file transfer command 	to set the server to active.  This message must be sent before	each transfer command that requires a passive server."	self clientPI setServerActive.</body><body package="FTP" selector="setServerPassive">setServerPassive	"Use this command in conjunction with a file transfer command 	to set the server to PASV.  This message must be sent before	each transfer command that requires a passive server."	self clientPI setServerPassive.</body><body package="FTP" selector="site:">site: cmdString	"SITE commands are server specific.  Some commands require permission granted	by and administrator.  User the #siteHelp to determine which commands are valid.	Such as the following,	MSG &lt;any message&gt;	Sends a message to the console.	or,	KICK &lt;user handle&gt;	214- Throw a user off."	^self executeSequence: [self executeCommand: 'SITE ', cmdString]</body><body package="FTP" selector="siteHelp">siteHelp	^self help: 'SITE'</body><body package="FTP" selector="stat">stat	^self executeSequence: [self executeCommand: 'STAT']</body><body package="FTP" selector="streamMode">streamMode	"sets the transfer MODE as Stream.  Other possibilites are Bock and Compressed"	^self mode: $S</body><body package="FTP" selector="structure:">structure: aChar	"set the file transfer structure.  This implementation only supports the File Structure"	"F - File	R - Record	P - Page"	^self executeSequence: [self executeCommand: 'STRU ' , aChar asSymbol asString]</body><body package="FTP" selector="transferOffset">transferOffset	^transferOffset</body><body package="FTP" selector="transferOffset:">transferOffset: position	transferOffset := position</body></methods><methods><class-id>Net.FTPClient</class-id> <category>streams -- guarded</category><body package="FTP" selector="appendBinaryStreamCmd:do:">appendBinaryStreamCmd: aString do: aBlock	^self executeSequence: 		[self 			guardedBinaryTransferCmd: aString  			do: [ :ftpAccessor | self stream: ftpAccessor writeStream binary do: aBlock ]]</body><body package="FTP" selector="appendStreamCmd:do:">appendStreamCmd: aString do: aBlock	^self appendBinaryStreamCmd: aString do: aBlock</body><body package="FTP" selector="appendTextStreamCmd:do:">appendTextStreamCmd: aString do: aBlock	^self executeSequence: 		[self 			guardedTextTransferCmd: aString 			do: [ :ftpAccessor | self stream: ftpAccessor writeStream text do: aBlock ]]</body><body package="FTP" selector="readBinaryStream:do:">readBinaryStream: aFileNameString do: aBlock	^self readBinaryStreamCmd: 'RETR ', aFileNameString do: aBlock</body><body package="FTP" selector="readBinaryStreamCmd:do:">readBinaryStreamCmd: aString do: aBlock	^self executeSequence: 		[self 			guardedBinaryTransferCmd: aString 			do: [ :ftpAccessor | 	self stream: ftpAccessor readStream binary do: aBlock ]]</body><body package="FTP" selector="readStream:do:">readStream: aFileNameString do: aBlock	^self readBinaryStream: aFileNameString do: aBlock</body><body package="FTP" selector="readStreamCmd:do:">readStreamCmd: aString do: aBlock	^self readBinaryStreamCmd: aString do: aBlock</body><body package="FTP" selector="readTextStream:do:">readTextStream: aFileNameString do: aBlock	^self readTextStreamCmd: 'RETR ', aFileNameString do: aBlock</body><body package="FTP" selector="readTextStreamCmd:do:">readTextStreamCmd: aString do: aBlock	^self executeSequence: 		[self 			guardedTextTransferCmd: aString 			do: [ :ftpAccessor | 	self stream: ftpAccessor readStream text do: aBlock ]]</body><body package="FTP" selector="writeBinaryStream:do:">writeBinaryStream: aFileNameString do: aBlock	^self writeBinaryStreamCmd: 'STOR ', aFileNameString do: aBlock</body><body package="FTP" selector="writeBinaryStreamCmd:do:">writeBinaryStreamCmd: aString do: aBlock	^self executeSequence: 		[self 			guardedBinaryTransferCmd: aString 			do: [ :ftpAccessor | 	self stream: ftpAccessor writeStream binary do: aBlock ]]</body><body package="FTP" selector="writeStream:do:">writeStream: aFileNameString do: aBlock	^self writeBinaryStream: aFileNameString do: aBlock</body><body package="FTP" selector="writeStreamCmd:do:">writeStreamCmd: aString do: aBlock	^self writeBinaryStreamCmd: aString do: aBlock</body><body package="FTP" selector="writeTextStream:do:">writeTextStream: aFileNameString do: aBlock	^self writeTextStreamCmd: 'STOR ', aFileNameString do: aBlock</body><body package="FTP" selector="writeTextStreamCmd:do:">writeTextStreamCmd: aString do: aBlock	^self executeSequence: 		[self 			guardedTextTransferCmd: aString 			do: [ :ftpAccessor | 	self stream: ftpAccessor writeStream text do: aBlock ]]</body></methods><methods><class-id>Net.FTPClient</class-id> <category>private -- guarded stream setup</category><body package="FTP" selector="guardedBinaryTransferCmd:do:">guardedBinaryTransferCmd: aString do: aBlock 	"Perform guarded binary transfer over data connection. Returns final response. 	This is used for transfers that are done under our control, so we ensure 	that data stream is closed and final data response is read"	^self		binaryTransfer; 		guardedTransferCmd: aString do: aBlock</body><body package="FTP" selector="guardedTextTransferCmd:do:">guardedTextTransferCmd: aString do: aBlock 	"Perform guarded text transfer over data connection. Returns final response. 	This is used for transfers that are done under our control, so we ensure 	that data stream is closed and final data response is read"	^self		textTransfer; 		guardedTransferCmd: aString do: aBlock</body><body package="FTP" selector="guardedTransferCmd:do:">guardedTransferCmd: aString do: aBlock 	"Perform guarded transfer over data connection. Returns result of the block. 	This is used for transfers that are done under our control, so we ensure 	that data stream is closed and final data response is read"	| accessor result |	accessor := self startTransferCmd: aString.	result := [accessor callback: nil.	aBlock value: accessor]		ensure: [accessor close].	finalResponse := self readFinalResponseBlock value.	^result</body><body package="FTP" selector="stream:do:">stream: externalStream do: aBlock	^[ aBlock value: externalStream ] ensure: [ externalStream close ]</body></methods><methods><class-id>Net.FTPClient</class-id> <category>private -- command interface</category><body package="FTP" selector="executeCommand:retryChallenge:">executeCommand: aString retryChallenge: aBoolean" Most command travel though here. If retryChallenge is true and the responseis intermediate reply (3xx), we handle it as a challenge (by sending user name, password, etc.) and then retry the original command. To avoid recursion, user authorisation commands themselves (USER, PASS, ACCT) are sent with no retry on challenge"	^[ self clientPI sendCommand: aString ]		on: FTPChallenge 		do: [ :ex |				FTPProtocolInterpreter log: [ 'FTPChallenge: ', ex messageText ] level: #FTPException.				(self handleChallenge: ex parameter command: aString)					ifTrue: [ aBoolean ifTrue: [ ex retry ]]					ifFalse: [ ex pass ]]</body><body package="FTP" selector="handleChallenge:command:">handleChallenge: aResponse command: aString	aResponse needAccountForLogin		ifTrue: 			[aString = 'ACCT ' ifTrue: [ ^false ]. 			self userAccount notNil 				ifTrue: [ self account: self userAccount. ^true]].	aResponse needPassword		ifTrue: 			[aString = 'PASS ' ifTrue: [ ^false ].  			self userPassword notNil				ifTrue: [ self pass: self userPassword. ^true ]].	^false</body><body package="FTP" selector="privateStartTransferCmd:">privateStartTransferCmd: aString 	"Initiate a transfer over the data connection.  	If the transfer is active, send a port command and the transfer 	command, and accept the connection. If the server is passive, 	send a pasv command, connect to it, and start the transfer 	command.  Return the passiveServer instance variable to false after the operation.	Either way, return the socket for the connection 	and the expected size of the transfer. The expected size 	may be None if it could not be determined."	| conn resp |	delayedResponse := nil.	self clientPI passiveServer		ifTrue: 			[| sockAddress |			sockAddress := (self executeCommand: 'PASV') parse227HostPort.			(conn := FTPSocketAccessor newTCP) connectTo: sockAddress.			transferOffset &gt; 0 ifTrue: [self cmdRest: transferOffset].			resp := self transferCmd: aString		]		ifFalse: 			[| sock counter |			sock := self clientPI makeport.			transferOffset &gt; 0 ifTrue: [self cmdRest: transferOffset].			resp := self transferCmd: aString.			"!!!this didn't work on Macs:				conn := sock accept."			counter := 50.			[conn := sock acceptNonBlock.			conn isNil and: [counter &gt; 0]]				whileTrue: 					[counter := counter - 1.					(Delay forSeconds: 1) wait].			"If no client solicited a connection, give up."			conn isNil 				ifTrue: 					[Transcript show: (#givingUp &lt;&lt; #dialogs &gt;&gt; 'Giving up!') asString; cr.					sock close.					^nil].		].	conn ftpConn: self.	^Array with: conn with: resp parse150Size.</body><body package="FTP" selector="protocolInterpreterClass">protocolInterpreterClass	"Use a special protocolInterpreter on Macintosh, because its socket 	implementation insists on using the right 'write*' primitives for TCP 	connections."	^OSHandle currentOS == #mac		ifTrue: [MacFTPProtocolInterpreter]		ifFalse: [FTPProtocolInterpreter]</body><body package="FTP" selector="startTransferCmd:">startTransferCmd: aString	"Initiate a transfer over the data connection.  Returns 	the socket for the connection."	^(self privateStartTransferCmd: aString ) first</body><body package="FTP" selector="transferCmd:">transferCmd: aString" This one is used to send transfer command (RETR, STOR, STOU, LIST, NLST). The only valid reply is a preliminary reply "	| resp |	^[resp := self clientPI sendCommand: aString. FTPSignal raiseWith: resp ] 		on: FTPPreliminaryReply do:[:ex | ex return: ex parameter ]</body></methods><methods><class-id>Net.FTPClient</class-id> <category>low-level command interface</category><body package="FTP" selector="executeCommand:">executeCommand: aString	^ self executeCommand: aString retryChallenge: true</body><body package="FTP" selector="executeSequence:">executeSequence: aBlock" Catch reply 421 (Server closed control connection. This should helpin most time-out/stale connection situations. There is a small chance of getting this in the middle of a command sequence and this would be bad "	self connectIfClosed.	^[[aBlock value] 		on: FTPTransientReply		do: [ :ex | ex parameter hasConnectionClosed					ifTrue: [ self reconnect.							ex retry ]					ifFalse: [ ex pass ]]]		on: OSErrorHolder peerFaultSignal		do: [ :ex | self reconnect.					ex retry ]</body><body package="FTP" selector="getResponse">getResponse	^self clientPI getResponse</body><body package="FTP" selector="sendCommand:">sendCommand: aString " This is direct passthrough to protocol interpreter. We are not using it,but if somebody needs to send unadited command directly to FTP server,this is the place "	^self clientPI sendCommand: aString</body></methods><methods><class-id>Net.FTPClient</class-id> <category>file and directory utilities</category><body package="FTP" selector="appendBinaryFileNamed:to:">appendBinaryFileNamed: aString to: aDestString 	| file |	^[file := aString asFilename readStream binary.	self 		appendBinaryStreamCmd: 'APPE ', aDestString 		do: [ :stream | self copyFrom: file to: stream blockSize: self binaryBlockSize ].	finalResponse ]		ensure: 	 [file close]</body><body package="FTP" selector="appendFileNamed:to:">appendFileNamed: aString to: aDestString 	^self appendBinaryFileNamed: aString to: aDestString</body><body package="FTP" selector="appendTextFileNamed:to:">appendTextFileNamed: aString to: aDestString 	| file |	^[file := aString asFilename readStream text.	self 		appendTextStreamCmd: 'APPE ', aDestString 		do: [ :stream | self copyFrom: file to: stream ].	finalResponse ]		ensure: 	 [file close]</body><body package="FTP" selector="copyFileNamed:on:">copyFileNamed: remoteFileString on: aBinaryStream" Copy file onto specified binary stream "	^self executeSequence: 		[self readBinaryStreamCmd: 'RETR ', remoteFileString 			do: [ :remoteStream | self copyFrom: remoteStream to: aBinaryStream].		finalResponse ]</body><body package="FTP" selector="copyFrom:toFileNamed:">copyFrom: aBinaryStream toFileNamed: remoteFileString" Copy specified binary stream to remote file "	^self executeSequence: 		[self writeBinaryStreamCmd: 'STOR ', remoteFileString 			do: [ :remoteStream | self copyFrom: aBinaryStream to: remoteStream].		finalResponse]</body><body package="FTP" selector="copyFromFTP:file:toFile:passive:">copyFromFTP: otherServer file: otherFile toFile: myFile passive: aBoolean" Direct file transfer between two servers. Copy file from specified file on otheServer tospecified file on myself. The transfer is setup in such a way that the two servers talkdirectly to each other "	^self executeSequence: 		[otherServer executeSequence:			[aBoolean				ifTrue: [otherServer executeCommand: 'PORT ', (self executeCommand: 'PASV') parse227HostPortString]				ifFalse: [self executeCommand: 'PORT ', (otherServer executeCommand: 'PASV') parse227HostPortString].			self binaryTransfer; transferCmd: 'STOR ', myFile.			otherServer binaryTransfer; transferCmd: 'RETR ', otherFile.			otherServer getResponse.			self getResponse]]</body><body package="FTP" selector="directoryContents:do:">directoryContents: argumentCollection do: aBlock	"List a directory in long form. 	All non-empty arguments before it are concatenated	to the LIST command. (This *should* only be used for 	a pathname.)"	| cmd |	cmd := 'LIST'.	argumentCollection isString 		ifTrue: [cmd := cmd, ' ', argumentCollection] 		ifFalse: [ argumentCollection do: [:each | each isNil ifFalse: [cmd := cmd , ' ' , each]]].	^self lines: cmd do: aBlock</body><body package="FTP" selector="filesInDirectory:do:">filesInDirectory: argumentCollection do: aBlock	"Evaluate block for every filenames in a given directory "	| cmd |	cmd := 'NLST'.	argumentCollection isString 		ifTrue: [cmd := cmd, ' ', argumentCollection] 		ifFalse: [ argumentCollection do: [:each | each isNil ifFalse: [cmd := cmd , ' ' , each]]].	^self lines: cmd do: aBlock</body><body package="FTP" selector="parseDirectoryContents:do:">parseDirectoryContents: argumentCollection do: aBlock 	"List a directory in long form. All non-empty arguments before it are concatenated to the LIST command. (This *should* only be used for a pathname.)"	| cmd attributes |	cmd := 'LIST'.	argumentCollection isString 		ifTrue: [cmd := cmd , ' ' , argumentCollection]		ifFalse: 			[argumentCollection 				do: [:each | each isNil ifFalse: [cmd := cmd , ' ' , each]]].	self lines: cmd		do: 			[:line | 			attributes := self parseDirLine: line.			attributes notNil ifTrue: [aBlock value: attributes]]</body><body package="FTP" selector="retrieveFileNamed:as:">retrieveFileNamed: remoteFileString as: localFileString	| localFileStream |	^self executeSequence: 		[[localFileStream := localFileString asFilename writeStream binary.		self readBinaryStreamCmd: 'RETR ', remoteFileString 			do: [ :remoteStream | self copyFrom: remoteStream to: localFileStream].		finalResponse]		ensure: 	[localFileStream close]]</body><body package="FTP" selector="storeFileNamed:to:">storeFileNamed: localFileString to: remoteFileString	| localFileStream |	^self executeSequence: 		[[localFileStream := localFileString asFilename readStream binary.		self writeBinaryStreamCmd: 'STOR ', remoteFileString 			do: [ :remoteStream | self copyFrom: localFileStream to: remoteStream].		finalResponse]		ensure: 	[localFileStream close]]</body></methods><methods><class-id>Net.FTPClient</class-id> <category>streams -- unguarded</category><body package="FTP" selector="appendBinaryStream:">appendBinaryStream: aFileString	^ self executeSequence: [(self openBinaryTransferCmd: 'APPE ', aFileString) writeStream binary]</body><body package="FTP" selector="appendStream:">appendStream: aFileString	^self appendBinaryStream: aFileString</body><body package="FTP" selector="appendTextStream:">appendTextStream: aFileString	^ self executeSequence: [(self openTextTransferCmd: 'APPE ', aFileString) writeStream lineEndCRLF ]</body><body package="FTP" selector="readBinaryStream:">readBinaryStream: cmd	^ self executeSequence: [(self openBinaryTransferCmd: 'RETR ', cmd) readStream binary]</body><body package="FTP" selector="readStream:">readStream: cmd	^self readBinaryStream: cmd</body><body package="FTP" selector="readStreamCmd:">readStreamCmd: cmd	^self executeSequence: [(self openBinaryTransferCmd: cmd) readStream ]</body><body package="FTP" selector="readTextStream:">readTextStream: cmd	^self executeSequence: [(self openTextTransferCmd: 'RETR ', cmd) readStream lineEndCRLF]</body><body package="FTP" selector="writeBinaryStream:">writeBinaryStream: aFileString	^ self executeSequence: [(self openBinaryTransferCmd: 'STOR ', aFileString) writeStream binary ]</body><body package="FTP" selector="writeStream:">writeStream: aString	^self writeBinaryStream: aString</body><body package="FTP" selector="writeStreamCmd:">writeStreamCmd: cmd	^self executeSequence: [(self openBinaryTransferCmd: cmd) writeStream ]</body><body package="FTP" selector="writeTextStream:">writeTextStream: aFileString	^ self executeSequence: [(self openTextTransferCmd: 'STOR ', aFileString) writeStream lineEndCRLF ]</body></methods><methods><class-id>Net.FTPClient</class-id> <category>private -- unguarded stream setup</category><body package="FTP" selector="openBinaryTransferCmd:">openBinaryTransferCmd: aString 	"Open binary transfer over the data connection. Returns 	socket accessor for the connection.This is used for transfers that are entirely controller by user 	agent. User agent has a responsibility to close data stream. We make sure that when this	happens, the final data response is read"	^self		binaryTransfer;		openTransferCmd: aString</body><body package="FTP" selector="openTextTransferCmd:">openTextTransferCmd: aString 	"Open text transfer over the data connection. Returns 	socket accessor for the connection.This is used for transfers that are entirely controller by user 	agent. User agent has a responsibility to close data stream. We make sure that when this	happens, the final data response is read"	^self		textTransfer;		openTransferCmd: aString</body><body package="FTP" selector="openTransferCmd:">openTransferCmd: aString 	"Open transfer over the data connection. Returns 	socket accessor for the connection.This is used for transfers that are entirely controller by user 	agent. User agent has a responsibility to close data stream. We make sure that when this	happens, the final data response is read"	^(self startTransferCmd: aString)		callback: self readFinalResponseBlock; yourself</body></methods><methods><class-id>Net.FTPClient</class-id> <category>ftp experimental commands</category><body package="FTP" selector="xBeCurrentDirectory:">xBeCurrentDirectory: directoryName 	"Change to the directory named 	directoryName."	^directoryName = '..' 		ifTrue: [self executeCommand: 'XCUP']		ifFalse: [self executeCommand: 'XCWD ' , directoryName]</body><body package="FTP" selector="xCurrentWorkingDirectory">xCurrentWorkingDirectory	^self executeCommand: 'XPWD'</body><body package="FTP" selector="xMakeDirectory:">xMakeDirectory: directoryNameString 	^self executeCommand: 'XMKD ' , directoryNameString</body><body package="FTP" selector="xRemoveDirectory:">xRemoveDirectory: directoryNameString 	^self executeCommand: 'XRMD ' , directoryNameString</body></methods><methods><class-id>Net.FTPClient</class-id> <category>private -- utilities</category><body package="FTP" selector="binaryTransfer">binaryTransfer	^self executeCommand: 'TYPE I'</body><body package="FTP" selector="copyFrom:to:">copyFrom: inputStream to: outputStream	^self copyFrom: inputStream to: outputStream blockSize: self binaryBlockSize</body><body package="FTP" selector="copyFrom:to:blockSize:">copyFrom: inputStream to: outputStream blockSize: blockSize	| data counter |	data := inputStream contentsSpecies new: blockSize.	[ inputStream atEnd ] whileFalse: 		[counter := inputStream nextAvailable: blockSize into: data startingAt: 1.  		outputStream next: counter putAll: data startingAt: 1].</body><body package="FTP" selector="dosAttributesFromStream:">dosAttributesFromStream: aStream 	| attributes date time dirOrSize sizeString |	attributes := Dictionary new.	date := Date readFrom: aStream.	aStream skipSeparators.	time := Time readFrom: aStream.	attributes at: #timestamp put: (Timestamp fromDate: date andTime: time).	dirOrSize := aStream				skipSeparators;				upToSeparator.	(attributes at: #isDir put: dirOrSize = '&lt;DIR&gt;') 		ifFalse: 			[sizeString := dirOrSize copyWithout: $,.			attributes at: #size put: (Integer readFrom: sizeString readStream)].	attributes at: #name		put: (aStream				skipSeparators;				upToEnd).	^attributes</body><body package="FTP" selector="lines:do:">lines: cmd do: aBlock 	"Retrieve data in line mode. Suppress all empty lines. Used by directory listing routines.	The argument is a RETR or LIST command."	^self executeSequence:		[self readTextStreamCmd: cmd do:			[ :remoteStream | 				remoteStream linesDo: [ :line |					FTPProtocolInterpreter log: [ ((#data1s &lt;&lt; #net &gt;&gt; '*data*&lt;1s&gt;')			expandMacrosWith: line) ] level: #FTPResponse.					line isEmpty ifFalse: [aBlock value: line]]]	]</body><body package="FTP" selector="parseDirLine:">parseDirLine: line 	(line size &lt; 3 or: ['total*' match: line]) ifTrue: [^nil].	"Assume the line format is either DOS or Unix.  	If the first two characters are digits, then it's DOS (?)."	^(line first isDigit and: [(line at: 2) isDigit]) 		ifTrue: [self dosAttributesFromStream: line readStream]		ifFalse: [self unixAttributesFromStream: line readStream]</body><body package="FTP" selector="parseDirLine:do:">parseDirLine: line do: aBlock	| isUnix isDir name index parser |	('total*' match: line) ifTrue: [^self].	"Assume it's either Windows or Unix.	If it's Windows, the first two characters must be digits (?)."	isUnix := false.	#('0123456789' '0123456789' ) keysAndValuesDo: [:i :str |		(line size &gt;= i and: [str includes: (line at: i)])			ifFalse: [isUnix := true]].	index := 1.  	parser :=		[index := (index to: line size) detect: [:i | (line at: i) isSeparator] ifNone: [index].		index := (index to: line size) detect: [:i | (line at: i) isSeparator not] ifNone: [index]].	isUnix		ifTrue:			[isDir := line first = $d.			parser value.    "skip permissions"			parser value.    "skip link count"			parser value.    "skip user"			parser value.    "skip group"			parser value.    "skip size"			3 timesRepeat: [parser value].    "skip month, day, and time"			name := line copyFrom: index to: line size]		ifFalse:			[isDir := ('*&lt;DIR&gt;*' match: line).			3 timesRepeat: [parser value].    "skip date, time, dir/size"			name := name := line copyFrom: index to: line size.].	aBlock value: isDir value: name</body><body package="FTP" selector="restoreFrom:do:">restoreFrom: position do: aBlock" This method aids in restoring file transfers from a specified position. This position will cause the server to start transfer operation not at the beginning of the file, but at specified position. This method can be used if a long transfer was interrupted in the middle. The application may then look at how much data was already transferred and restart transfer at thepoint immediately after this data. "	self transferOffset: position.	^aBlock ensure: 		[self transferOffset: 0].</body><body package="FTP" selector="textTransfer">textTransfer	^self executeCommand: 'TYPE A'</body><body package="FTP" selector="unixAttributesFromStream:">unixAttributesFromStream: aStream 	| attributes type month day yearOrTime year time date |	attributes := Dictionary new.	type := aStream next.	attributes		at: #type put: type;		at: #isDir put: type == $d;		at: #permissions put: aStream upToSeparator.	aStream skipSeparators.	attributes		at: #linkCount put: (Integer readFrom: aStream);		at: #user			put: (aStream					skipSeparators;					upToSeparator);		at: #group			put: (aStream					skipSeparators;					upToSeparator).	aStream skipSeparators.	attributes at: #size put: (Integer readFrom: aStream).	month := aStream				skipSeparators;				upToSeparator.	aStream skipSeparators.	day := Integer readFrom: aStream.	yearOrTime := aStream				skipSeparators;				upToSeparator.	(yearOrTime includes: $:) 		ifTrue: 			[year := Date today year.			time := Time readFrom: yearOrTime readStream]		ifFalse: 			[year := Integer readFrom: yearOrTime readStream.			time := Time fromSeconds: 0].	date := Date 				newDay: day				month: month				year: year.	attributes		at: #timestamp put: (Timestamp fromDate: date andTime: time);		at: #name put: aStream upToEnd.	^attributes</body></methods><methods><class-id>Net.FTPClient</class-id> <category>restart</category><body package="FTP" selector="restartRetrieveLocalFile:fromFile:">restartRetrieveLocalFile: localFileNameString fromFile: remoteFileNameString 	"restart retrieve by checking size of local file and transfering only data that has not 	been transferred yet. Useful to recover from transient transfer errors "	| localFilename localFileStream localSize remoteSize |	(localFilename := localFileNameString asFilename) exists not 		ifTrue: [localFilename writeStream close].		" Create file if does not exist yet "		[localFileStream := localFilename appendStream binary setToEnd.	localSize := localFilename fileSize.	remoteSize := [(self fileSize: remoteFileNameString) parse213AsBytes]					on: FTPPermSignal					do: [ :ex | 						ex parameter notImplementedCommand							ifTrue: [	ex return: 0]							ifFalse: [ ex pass] ].	(remoteSize == 0  or: [localSize &lt; remoteSize]) 		ifTrue: [self restoreFrom: localFileStream position					do: [ self copyFileNamed: remoteFileNameString on: localFileStream ]]]		ensure: [localFileStream close]</body><body package="FTP" selector="restartStoreRemoteFile:fromFile:">restartStoreRemoteFile: remoteFileNameString fromFile: localFileNameString 	" restart retrieve by checking size of remote file and transfering only data that has not 	been transferred yet. Useful to recover from transient transfer errors "	| localFilename localFileStream remoteSize |	(localFilename := localFileNameString asFilename) exists not 		ifTrue: [^self error: ((#File1sDoesNotExist &lt;&lt; #net &gt;&gt; 'File &lt;1s&gt; does not exist')			expandMacrosWith: localFileNameString)].	[localFileStream := localFilename readStream binary.	remoteSize := [(self fileSize: remoteFileNameString) parse213AsBytes] 					on: FTPPermSignal					do: [ :ex | 						ex parameter notImplementedCommand							ifTrue: [	ex return: 0]							ifFalse: [ ex pass] ].	localFilename fileSize &gt; remoteSize 		ifTrue: [localFileStream position: remoteSize.				self 					appendBinaryStreamCmd: 'APPE ', remoteFileNameString 					do: [ :remoteStream | self copyFrom: localFileStream to: remoteStream ]]]		ensure: [localFileStream close]</body></methods><methods><class-id>Net.FTPClient</class-id> <category>connection</category><body package="FTP" selector="close">close	self disconnect</body><body package="FTP" selector="connectIfClosed">connectIfClosed	self clientPI closed 		ifTrue: [ self reconnect ]</body><body package="FTP" selector="connectToHost:port:">connectToHost: aString port: aNumber	| port |	(port := aNumber) isNil ifTrue: [ port := self defaultPortNumber ].	super connectToHost: aString port: port</body><body package="FTP" selector="disconnect">disconnect	clientPI notNil ifTrue: [clientPI disconnect].	clientPI := nil</body><body package="FTP" selector="doLogin">doLogin	^self cmdUser: self user username</body><body package="FTP" selector="isConnected">isConnected	^self clientPI closed not</body><body package="FTP" selector="login:passwd:">login: userString passwd: passwdString	self login: userString passwd: passwdString acct: nil</body><body package="FTP" selector="login:passwd:acct:">login: userString passwd: passwdString acct: acctString		^self loginWithUser: (FTPUser createUser: userString password: passwdString account: acctString)</body><body package="FTP" selector="loginToHost:asUser:withPassword:">loginToHost: aHostName asUser: userString withPassword: passwdString	self loginToHost: aHostName asUser: userString withPassword: passwdString withAcct: nil</body><body package="FTP" selector="loginToHost:asUser:withPassword:withAcct:">loginToHost: aHostName asUser: userString withPassword: passwdString withAcct: acctString	^self connectToHost: aHostName; 		login: userString passwd: passwdString acct: acctString.</body><body package="FTP" selector="loginToHost:withUser:">loginToHost: aHostName withUser: anFTPUser	self connectToHost: aHostName; 		loginWithUser: anFTPUser</body><body package="FTP" selector="loginWithUser:">loginWithUser: anFTPUser	self user: anFTPUser.	^self doLogin</body><body package="FTP" selector="reconnect">reconnect	FTPProtocolInterpreter log: [(#reconnect &lt;&lt; #net &gt;&gt; '*reconnect*')] level: #FTPException.	self disconnect;		connect;		doLogin</body></methods><methods><class-id>Net.FTPClient</class-id> <category>initialization-release</category><body package="FTP" selector="initialize">initialize	self binaryBlockSize: self class defaultBinaryBlockSize.	transferOffset := 0.	self portNumber: SocketAccessor IPPORT_FTP.</body></methods><methods><class-id>Net.FTPClient</class-id> <category>ftp accessor callbacks</category><body package="FTP" selector="pollResponses">pollResponses	| resp |	[(resp := self clientPI pollResponse) notNil] 		whileTrue: 			[resp isTransferCompletion 				ifTrue: 					[FTPProtocolInterpreter log: [((#SetDelayedResponse1s &lt;&lt; #net &gt;&gt; 'Set delayed response &lt;1s&gt;')			expandMacrosWith: resp code)] level: #FTPResponse.					delayedResponse := resp.]].	^resp</body><body package="FTP" selector="readFinalResponseBlock">readFinalResponseBlock	| resp |	^[resp := delayedResponse notNil		ifTrue: 			[FTPProtocolInterpreter log: [((#UsingDelayedResp1s &lt;&lt; #net &gt;&gt; 'Using delayed resp &lt;1s&gt;')			expandMacrosWith: delayedResponse code)] level: #FTPResponse.			FTPSignal handleResponse: delayedResponse]		ifFalse: [self clientPI getResponse].	delayedResponse := nil.	self transferOffset: 0. 	resp]</body></methods><methods><class-id>Net.FTPClient class</class-id> <category>instance creation</category><body package="FTP" selector="connectToHost:">connectToHost: aHostname	^self new connectToHost: aHostname</body><body package="FTP" selector="connectToHost:port:">connectToHost: aHostname port: aPort	^self new connectToHost: aHostname port: aPort</body><body package="FTP" selector="loginToHost:asUser:withPassword:">loginToHost: aHostName asUser: userString withPassword: passwdString 	^self loginToHost: aHostName asUser: userString withPassword: passwdString withAcct: nil</body><body package="FTP" selector="loginToHost:asUser:withPassword:withAcct:">loginToHost: aHostName asUser: userString withPassword: passwdString withAcct: acctString	|  conn |	conn := self new.	conn loginToHost: aHostName asUser: userString withPassword: passwdString withAcct: acctString.	^conn</body><body package="FTP" selector="loginToHost:withUser:">loginToHost: aHostName withUser: anFTPUser	| conn  |	conn := self new.	conn loginToHost: aHostName withUser: anFTPUser.	^conn</body><body package="FTP" selector="new">new	^super new initialize</body></methods><methods><class-id>Net.FTPClient class</class-id> <category>constants</category><body package="FTP" selector="description">description	^(#FTPServer &lt;&lt; #net &gt;&gt; 'FTP server') asString</body><body package="FTP" selector="serverType">serverType	^#FTP</body></methods><methods><class-id>Net.FTPClient class</class-id> <category>defaults</category><body package="FTP" selector="defaultBinaryBlockSize">defaultBinaryBlockSize	^4096</body><body package="FTP" selector="defaultPortNumber">defaultPortNumber	^SocketAccessor IPPORT_FTP</body><body package="FTP" selector="ftpAnonymousUser">ftpAnonymousUser	^self netSettings ftpAnonymousUser</body></methods><methods><class-id>Net.MacFTPProtocolInterpreter</class-id> <category>connection management</category><body package="FTP" selector="abort">abort	"Abort a file transfer. Uses out-of-band data. 	Doesn''t follow RFC proceedure to send 	Telnet IP and Synch, 	so maybe this should be changed."	"Macintosh wants propper TCP socket commands, like writeAll:."	| line |	self mutex critical:		[line := 'ABOR' , CrLf.		self socket writeAll: line].	^self getResponse</body></methods><methods><class-id>Net.MacFTPProtocolInterpreter</class-id> <category>private</category><body package="FTP" selector="putCommand:">putCommand: aString 	"Macintosh wants propper TCP socket commands, like writeAll:."	| line |	line := aString , CrLf.	self class log: [((#put1s &lt;&lt; #net &gt;&gt; '*put*  &lt;1s&gt;')			expandMacrosWith: (self sanitize: line))] level: #FTPClient.	self socket isActive 		ifTrue: [self socket writeWait ]		ifFalse: [ 			FTPProtocolInterpreter log: [(#exception &lt;&lt; #net &gt;&gt; '*exception*')] level: #FTPException.			FTPChallenge raise ].	self socket writeAll: line</body></methods><methods><class-id>Net.MacFTPProtocolInterpreter class</class-id> <category>class initialization</category><body package="FTP" selector="initialize">initialize	CrLf := String with: Character cr with: Character lf</body></methods><methods><class-id>Net.FTPSignal</class-id> <category>printing</category><body package="FTP" selector="defaultMessageText">defaultMessageText	^super defaultMessageText, '\(' withCRs, parameter printString, ')'</body></methods><methods><class-id>Net.FTPSignal class</class-id> <category>handling ftp responses</category><body package="FTP" selector="handleResponse:">handleResponse: resp	"trigger exceptions for all responses but 2xx (success) "	resp isSuccess 		ifFalse: [			resp isChallenge ifTrue: [ FTPChallenge signalWith: resp].			resp isPreliminaryReply ifTrue: [ FTPPreliminaryReply signalWith: resp].			resp isTransientError ifTrue: [ FTPTransientReply raiseRequestWith: resp errorString: resp printString].			resp isPermanentError ifTrue: [ FTPPermSignal raiseWith: resp errorString: resp printString]].	^resp</body></methods><methods><class-id>Net.FTPChallenge</class-id> <category>initialize-release</category><body package="FTP" selector="initialize">initialize	super initialize.	messageText := (#PositiveIntermediateReply &lt;&lt; #net &gt;&gt; '3xx Positive Intermediate reply') asString</body></methods><methods><class-id>Net.FTPResponse</class-id> <category>testing</category><body package="FTP" selector="hasConnectionClosed">hasConnectionClosed		^self responseEquals: '421'</body><body package="FTP" selector="isChallenge">isChallenge	^ self isIntermediateReply</body><body package="FTP" selector="isClosedConnection">isClosedConnection	" Last digit = 6 means 'connection closed' "	^(self codeAt: 3) == $6</body><body package="FTP" selector="isError">isError	^self isPermanentError or: [ self isTransientError or: [ self isUnknownError ] ]</body><body package="FTP" selector="isIntermediateReply">isIntermediateReply	"Positive Intermediate reply. The command has been accepted, but the requested action is being held"	^self responseTypeIs: $3</body><body package="FTP" selector="isPermanentError">isPermanentError	^self responseTypeIs: $5</body><body package="FTP" selector="isPreliminaryReply">isPreliminaryReply		^(self responseEquals: '125') or: [ self responseEquals: '150']</body><body package="FTP" selector="isTransferAborted">isTransferAborted" This response is returned when transfer in progress is interrupted by sendingan ABORT command. 	Either thread sending abort or thread performing transfermay receive this response. If this response is seen by ABORT command, it isreturned to the application but exception is suppressed. If data transfer threadsees it, it causes FTPTransientReply exception "	^self responseEquals: '426'</body><body package="FTP" selector="isTransferCompletion">isTransferCompletion	^self code = '226' or: [self code = '250']</body><body package="FTP" selector="isTransientError">isTransientError	^self responseTypeIs: $4</body><body package="FTP" selector="needAccountForLogin">needAccountForLogin		^self responseEquals: '332'</body><body package="FTP" selector="needFileInfo">needFileInfo		^self responseEquals: '350'</body><body package="FTP" selector="needMoreInfo">needMoreInfo	^self isIntermediateReply</body><body package="FTP" selector="needPassword">needPassword		^self responseEquals: '331'</body><body package="FTP" selector="notImplementedCommand">notImplementedCommand		^self responseEquals: '502'</body></methods><methods><class-id>Net.FTPResponse</class-id> <category>parsing</category><body package="FTP" selector="parse150ForReceive">parse150ForReceive	"Parse a 150 response for a RETR request"	"for RETR-  150 Sending ""c:\serv\test2.bmp"" (100150 bytes). Mode STREAM Type BINARY."	"for STOR-  150 Ready to receive ""c:\serv\test4.bmp"". Mode STREAM Type BINARY."		^self message first equivalentTo: $R ignoreCase: true</body><body package="FTP" selector="parse150Size">parse150Size	"Parse a 150 response for a RETR request.	Returns the expected transfer size or nil.  Size	is not guaranteed to be present in the 150 message."	"150 Sending ""c:\serv\test2.bmp"" (100150 bytes). Mode STREAM Type BINARY."	| string |	(string := self parseForStringFrom: $( toEndString: ' bytes') isEmpty ifTrue: [^nil].	^string asNumber</body><body package="FTP" selector="parse213AsBytes">parse213AsBytes	"Parse the '213' response for file size in bytes."	^self code = '213' 		ifTrue: [ self message asNumber ]		ifFalse: [ FTPProtocolInterpreter permSignal raiseWith: self  ]</body><body package="FTP" selector="parse213AsTimestamp">parse213AsTimestamp	"Parse the '213' response for a timestamp represented as YYYYMMDDhhmmss."	| year month day hour minute second |	self code = '213' 		ifFalse: [^FTPProtocolInterpreter permSignal raiseWith: self].	stream := self message readStream.	year := (stream next: 4) asNumber.	month := (stream next: 2) asNumber.	day := (stream next: 2) asNumber.	hour := (stream next: 2) asNumber.	minute := (stream next: 2) asNumber.	second := (stream next: 2) asNumber.	^Timestamp fromDate: (Date 				newDay: day				monthNumber: month				year: year)		andTime: (Time fromSeconds: hour * 3600 + (minute * 60) + second)</body><body package="FTP" selector="parse227HostPort">parse227HostPort	"Parse the '227' response for a PASV request. 	Raise error_proto if it does not contain 	'(h1,h2,h3,h4,p1,p2)' 	Return ('host.addr.as.numbers' , port#) tuple."	| numbers |	numbers := self parse227HostPortString tokensBasedOn: $,.	numbers size ~~ 6 ifTrue: [ FTPProtocolInterpreter permSignal raiseWith: self message].	numbers := numbers collect: [:ea | Integer readFrom: ea readStream ].	^IPSocketAddress hostAddress: (ByteArray withAll: (numbers copyFrom: 1 to: 4)) port: (ByteArray with: (numbers at: 5)			with: (numbers at: 6))</body><body package="FTP" selector="parse227HostPortString">parse227HostPortString	"Parse the '227' response for a PASV request. 	Raise error_proto if it does not contain 	'(h1,h2,h3,h4,p1,p2)' "		| str left right |	code ~= '227' ifTrue: [ FTPProtocolInterpreter permSignal raiseWith: self message].	left := (str := self message)				nextIndexOf: $(				from: 1				to: str size.	left isNil ifTrue: [ FTPProtocolInterpreter permSignal raiseWith: self  message].	right := str				nextIndexOf: $)				from: left + 1				to: str size.	right isNil ifTrue: [ FTPProtocolInterpreter permSignal raiseWith: str].	^(str copyFrom: left + 1 to: right - 1)</body><body package="FTP" selector="parse230">parse230"230 User logged in, proceed.""not done yet"</body><body package="FTP" selector="parse250Dir">parse250Dir 	"Parse the '250' response for a CWD request. 	Returns the directory name in the 250 reply."	code ~= '250' ifTrue: [FTPProtocolInterpreter permSignal raiseWith: self printString].	^self parseForQuotedString</body><body package="FTP" selector="parse257Dir">parse257Dir 	"Parse the '257' response for a MKD or PWD request. 	Returns the directory name in the 250 reply."	code ~= '257' ifTrue: [FTPProtocolInterpreter permSignal raiseWith: self  printString].	^self parseForQuotedString</body><body package="FTP" selector="parseForQuotedString">parseForQuotedString 	"Parse the FTPresponse for the string inside a pair of quotes" 	^self parseForStringFrom: $" to: $"</body><body package="FTP" selector="parseForStringFrom:to:">parseForStringFrom: aChar1 to: aChar2	"Parse the FTPresponse for the string inside a pair of aCharacter"	| str start stop |	str := self message.	start := str findFirst: [:ch | ch == aChar1].	start = 0 ifTrue: [ ^'' ].	stop := str				nextIndexOf: aChar2				from: start + 1				to: str size.	stop = 0 ifTrue: [ ^'' ].	^str copyFrom: start + 1 to: stop - 1	"get rid of characters"</body><body package="FTP" selector="parseForStringFrom:toEndString:">parseForStringFrom: aChar toEndString: aString	"Parse the FTPresponse for the string inside a pair of aCharacter and aString"	| str start stop |	str := self message.	stop := str indexOfSubCollection: aString startingAt: 1. 	stop = 0 ifTrue: [ ^'' ].	start := str				prevIndexOf: aChar				from: stop				to: 1.	start = 0 ifTrue: [ ^'' ].	^str copyFrom: start + 1 to: stop - 1	"get rid of characters"</body></methods><methods><class-id>Net.FTPResponse class</class-id> <category>signals</category><body package="FTP" selector="connectionSignal">connectionSignal	^FTPConnectionSignal</body></methods><methods><class-id>Net.FTPResponse class</class-id> <category>initialize</category><body package="FTP" selector="initialize">initialize	self initializeSignals</body><body package="FTP" selector="initializeSignals">initializeSignals	FTPConnectionSignal		notifierString: (#needToMakeConnection &lt;&lt; #net &gt;&gt; 'need to make connection'); 		nameClass: self message: #connectionSignal.</body></methods><methods><class-id>Net.FtpPage class</class-id> <category>interface specs</category><body package="FTP" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #FTPSettings 				#defaultString: 'FTP Settings' 				#catalogID: #net ) 			#bounds: #(#{Graphics.Rectangle} 512 384 901 656 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 0 0 ) 					#name: #Label1 					#label: 					#(#{Kernel.UserMessage} 						#key: #AnonymousLogin 						#defaultString: 'Anonymous Login' 						#catalogID: #net) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 20 25 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #PasswordEmailAddress 						#defaultString: 'Password (E-mail address):' 						#catalogID: #net ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 20 0 50 0 0 1 75 0 ) 					#model: #anonymousLoginPassword 					#isReadOnly: false ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 20 75 ) 					#model: #usePassiveMode 					#label: 					#(#{Kernel.UserMessage} 						#key: #UsePassiveMode 						#defaultString: 'Use Passive Mode' 						#catalogID: #net ) ) ) ) )</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="FTP" selector="netFtpPage">netFtpPage	&lt;settingsPage: #(net ftp)&gt;	^Net.FtpPage new		label: #FtpSettings &lt;&lt; #labels &gt;&gt; 'FTP';		icon: (ListIconLibrary visualFor: #net)</body></methods><initialize><class-id>Net.FTPProtocolInterpreter</class-id></initialize><initialize><class-id>Net.FtpURL</class-id></initialize><initialize><class-id>Net.MacFTPProtocolInterpreter</class-id></initialize><initialize><class-id>Net.FTPResponse</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>NetworkResponse</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>code messageStream stream </inst-vars><class-inst-vars></class-inst-vars><imports>			Tools.*			</imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>NetSettingsPage</name><environment>Net</environment><super>Tools.SettingsManagerPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>userPreferences userListOwner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetConfigTool</package></attributes></class><class><name>NetClient</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>user hostName portNumber clientPI retries timeout delaySeconds </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>NetUser</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>username password fullName account savePassword mailAddress </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>SocketAccessor</name><environment>OS</environment><super>OS.BlockableIOAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>concreteClass </class-inst-vars><imports></imports><category>OS-Sockets</category><attributes><package>OS-Sockets</package></attributes></class><class><name>URLwithAuthority</name><environment>Net</environment><super>Net.URLwithPath</super><private>false</private><indexed-type>none</indexed-type><inst-vars>host port </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><class><name>Exception</name><environment>Core</environment><super>Core.GenericException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>