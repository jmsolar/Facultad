<?xml version="1.0"?><st-source><!-- Name: POP3Notice: Copyright © 1999, 2000, 2002, 2002, 2001 Cincom Systems, Inc.  All Rights Reserved.Comment: POP3Support provides support for communication with a POP3 Server to retreive internet mail messages.DbIdentifier: bear73DbTrace: 53249DevelopmentPrerequisites: #(#(#any 'Mail' ''))PackageName: POP3Parcel: #('POP3')ParcelName: POP3PrerequisiteParcels: #(#('Mail' ''))PrintStringCache: (7.4  0,tkogan)Version: 7.3.1Date: 6:45:45 pm April 10, 2005 --><time-stamp>From VisualWorks®, 7.3.1 of April 10, 2005 on April 10, 2005 at 6:45:45 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>Pop3Client</name><environment>Net</environment><super>Net.NetClient</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection stream state serverResponse </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Net-POP3-Support</category><attributes><package>POP3</package></attributes></class><comment><class-id>Net.Pop3Client</class-id><body>This class is Pop3 client. It executes Pop3 commands. Because most commands are only valid in certain states, the state variable holds and instance of (subclass of) Pop3State. All commands are delegated to the state which either rejects them as inappropriate in the given state, or calls client back to send the command to Pop3 server.Instance Variables:	host	&lt;String&gt;  Host address	user	&lt;String&gt;  User name	connection	&lt;ExternalConnection&gt;  Socket	stream	&lt;Stream&gt;  Socket stream	state	&lt;Pop3State&gt;  Current state	serverResponse	&lt;String&gt;  comment	retries	&lt;Integer&gt;  commentShared Variables:	CRLF	&lt;String&gt;  comment	DelaySeconds	&lt;Integer&gt;  comment	LastServer	&lt;type&gt;  Last server -- if we don't care	MaxRetries	&lt;Integer&gt;  Max retries before we give up	TerminationOctet	&lt;Character&gt;  comment	TerminationSequence	&lt;String&gt;  comment</body></comment><class><name>Pop3Mailbox</name><environment>Net</environment><super>Net.Mailbox</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-POP3-Support</category><attributes><package>POP3</package></attributes></class><comment><class-id>Net.Pop3Mailbox</class-id><body>Pop3Mailbox provides POP3 mail box support</body></comment><class><name>Pop3State</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-POP3-Support</category><attributes><package>POP3</package></attributes></class><comment><class-id>Net.Pop3State</class-id><body>Superclass for all states. Publishes command signatures, implements them all as invalid for the state</body></comment><class><name>Pop3TransactionState</name><environment>Net</environment><super>Net.Pop3State</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-POP3-Support</category><attributes><package>POP3</package></attributes></class><comment><class-id>Net.Pop3TransactionState</class-id><body>Transaction state is when the user has logged in and authorized himself to Pop3 server. Actual message retrieval/manipulations are valid now</body></comment><class><name>Pop3AuthorizationState</name><environment>Net</environment><super>Net.Pop3State</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-POP3-Support</category><attributes><package>POP3</package></attributes></class><comment><class-id>Net.Pop3AuthorizationState</class-id><body>Pop3 Authorization state is used when the user has to be authorized to Pop3 server. Only autorization commands are valid</body></comment><class><name>Pop3Status</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>messages octets </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-POP3-Support</category><attributes><package>POP3</package></attributes></class><comment><class-id>Net.Pop3Status</class-id><body>Pop3 command statusInstance Variables:	messages	&lt;?type?&gt;  comment	octets	&lt;?type?&gt;  comment</body></comment><class><name>Pop3StateError</name><environment>Net</environment><super>Net.NetClientError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-POP3-Support</category><attributes><package>POP3</package></attributes></class><comment><class-id>Net.Pop3StateError</class-id><body>Signal to be raised for commands taht are invalid in the current state</body></comment><shared-variable><name>CRLF</name><environment>Net.Pop3Client</environment><private>false</private><constant>true</constant><category>local globals</category><initializer>Core.String with: Core.Character cr with: Core.Character lf</initializer><attributes><package>POP3</package></attributes></shared-variable><shared-variable><name>DebugDetail</name><environment>Net.Pop3Client</environment><private>false</private><constant>false</constant><category>debugging</category><initializer>1</initializer><attributes><package>POP3</package></attributes></shared-variable><shared-variable><name>MaxRetries</name><environment>Net.Pop3Client</environment><private>false</private><constant>false</constant><category>connection</category><initializer>5</initializer><attributes><package>POP3</package></attributes></shared-variable><shared-variable><name>DelaySeconds</name><environment>Net.Pop3Client</environment><private>false</private><constant>false</constant><category>connection</category><initializer>10</initializer><attributes><package>POP3</package></attributes></shared-variable><shared-variable><name>DebugLevels</name><environment>Net.Pop3Client</environment><private>false</private><constant>false</constant><category>debugging</category><initializer>Core.Set new</initializer><attributes><package>POP3</package></attributes></shared-variable><shared-variable><name>TerminationOctet</name><environment>Net.Pop3Client</environment><private>false</private><constant>true</constant><category>local globals</category><initializer>Core.Character value: 46</initializer><attributes><package>POP3</package></attributes></shared-variable><shared-variable><name>TerminationSequence</name><environment>Net.Pop3Client</environment><private>false</private><constant>true</constant><category>local globals</category><initializer>Core.String with: (Core.Character value: 46) with: Core.Character cr with: Core.Character lf</initializer><attributes><package>POP3</package></attributes></shared-variable><shared-variable><name>DebugStream</name><environment>Net.Pop3Client</environment><private>false</private><constant>false</constant><category>debugging</category><attributes><package>POP3</package></attributes></shared-variable><shared-variable><name>LastServer</name><environment>Net.Pop3Client</environment><private>false</private><constant>false</constant><category>local globals</category><attributes><package>POP3</package></attributes></shared-variable><shared-variable><name>MaxTransferRate</name><environment>Net.Pop3Mailbox</environment><private>false</private><constant>false</constant><category>debugging</category><initializer>Core.Dictionary new</initializer><attributes><package>POP3</package></attributes></shared-variable><shared-variable><name>MinTransferRate</name><environment>Net.Pop3Mailbox</environment><private>false</private><constant>false</constant><category>debugging</category><initializer>Core.Dictionary new</initializer><attributes><package>POP3</package></attributes></shared-variable><shared-variable><name>LastServer</name><environment>Net.Pop3Mailbox</environment><private>false</private><constant>false</constant><category>local globals</category><attributes><package>POP3</package></attributes></shared-variable><methods><class-id>Net.Pop3Client</class-id> <category>private</category><body package="POP3" selector="createSocket">createSocket	"Return a SocketAccessor instance or nil if a connection can not be made."	retries := self retries.	"Just in case our server is busy, prepare for an error."	^[SocketAccessor newTCPclientToHost: self hostName port: self portNumber]		on: OSErrorHolder peerFaultSignal, OsInaccessibleError		do: 			[:ex | 			(ex getSignal = OSErrorHolder peerFaultSignal			and: [(self handlePeerFaultError: ex)]) ifTrue:				[^nil "Unable to connect to the server."].			ex class = OsInaccessibleError ifTrue:					[^nil "Pop3Server is not accessible."]]</body><body package="POP3" selector="getNextLine">getNextLine	^stream throughAll: CRLF</body><body package="POP3" selector="handlePeerFaultError:">handlePeerFaultError: exception 	"The Pop3Server we are connecting to might be too busy to handle our	connection request.  In this case, delay for a little while and try again.	Once we have hit our connection retry limit, return true to the client so	that it can handle the error as it sees fit."	retries := retries - 1.	retries &gt; 0 ifTrue: 		[(Delay forSeconds: self delaySeconds) wait.		self log: [(#FailedToConnectWillTryMore &lt;&lt; #net &gt;&gt; 'Failed to connect to &lt;1s&gt;. Will try &lt;2p&gt; more times.') expandMacrosWith: self hostName with: retries]			level: #POP3ConnRetries.		exception retry].	^true</body><body package="POP3" selector="retrieveMultiLineResponseDo:">retrieveMultiLineResponseDo: block 	| result |	[result := self getNextLine.	 result isEmpty or: [result = TerminationSequence]] whileFalse: 		[result first = TerminationOctet ifTrue:			[result := result copyFrom: 2 to: result size].		self serverResponse: result.		block value: result]</body><body package="POP3" selector="retrieveMultiLineResponseInto:process:">retrieveMultiLineResponseInto: aStream process: block 	| result |	result := self getNextLine.	[result isEmpty or: [result = TerminationSequence]]		whileFalse: 			[result := result first = TerminationOctet						ifTrue: [result copyFrom: 2 to: result size]						ifFalse: [result].			self serverResponse: result.			aStream nextPutAll: (block value: result).			result := self getNextLine]</body><body package="POP3" selector="sendApopName:digest:">sendApopName: aStringName digest: aStringDigest	self sendCommand: ('APOP ', aStringName, ' ', aStringDigest).	self waitForResponse.	self hasPositiveResponse ifFalse: [^NetClientError signalWith: #apop message: self serverResponse].</body><body package="POP3" selector="sendCommand:">sendCommand: aString 		self log: ['C: &lt;2s&gt; S: &lt;1s&gt;' expandMacrosWith: aString with: self hostName] level: #POP3Client.	stream 		nextPutAll: aString;		nextPutAll: CRLF;		commit.</body><body package="POP3" selector="sendDeleteMessage:">sendDeleteMessage: number 	self sendCommand: ('DELE &lt;1p&gt;' expandMacrosWith: number).	self waitForResponse.	self hasPositiveResponse ifFalse: [^NetClientError raiseSignal: self serverResponse]</body><body package="POP3" selector="sendDeleteMessageIds:">sendDeleteMessageIds: aSequenceOfUniqueIDs	"Delete all messages whose unique ids appear in aSequenceOfUniqueIDs.	 Do so by doing a UIDL list, computing matching message numbers, and	 deleting by message number."	| count map |	count := self sendStat messages.	map := Dictionary new: count * 2.	self sendCommand: 'UIDL'.	self waitForResponse.	self hasPositiveResponse ifFalse: [^NetClientError raiseSignal: self serverResponse].	self retrieveMultiLineResponseDo: 			[:line | | msgnum |			msgnum := Integer readFrom: (ReadStream on: line).			map at: (line copyFrom: (line lastIndexOf: Character space) + 1 to: line size - 2) put: msgnum].	aSequenceOfUniqueIDs do:		[:uid| | msgnum |		((msgnum := map at: uid ifAbsent: []) notNil		and: [self sendCommand: ('DELE &lt;1p&gt;' expandMacrosWith: msgnum).			  self waitForResponse.			  self hasPositiveResponse])			ifFalse: [Transcript cr; nextPutAll: (#failedToDeleteId &lt;&lt; #net &gt;&gt; 'failed to delete id '); nextPutAll: uid; flush]].	^self sendStat messages</body><body package="POP3" selector="sendList">sendList	| messageStatuses |	self sendCommand: 'LIST'.	self waitForResponse.	self hasPositiveResponse ifFalse: [^self].	messageStatuses := OrderedCollection new: 30.	self 		retrieveMultiLineResponseInto: (String new: 256) writeStream 		process: 			[:line | |result|			IncrementNotification signalWith: line size.			result := line tokensBasedOn: Character space.			messageStatuses add: (Pop3Status new				messages: (Number readFrom: (result at: 1) readStream);				octets: (Number readFrom: (result at: 2) readStream);				yourself).			line].	^messageStatuses</body><body package="POP3" selector="sendList:">sendList: messageNumber 	| result |	self sendCommand: ('LIST &lt;1p&gt;' expandMacrosWith: messageNumber).	self waitForResponse.	self hasPositiveResponse ifFalse: [^NetClientError raiseSignal: self serverResponse].	result := self serverResponse tokensBasedOn: Character space.	^Pop3Status new		messages: (Number readFrom: (result at: 2) readStream);		octets: (Number readFrom: (result at: 3) readStream);		yourself</body><body package="POP3" selector="sendNoop">sendNoop	self sendCommand: 'NOOP'.	self waitForResponse.	"It should always be positive"	self hasPositiveResponse ifFalse: [^self].</body><body package="POP3" selector="sendPassword">sendPassword	self sendCommand: ('PASS &lt;1s&gt;' expandMacrosWith: self user password).	self waitForResponse.	self hasPositiveResponse ifFalse: [^NetClientError signalWith: #login message: self serverResponse].</body><body package="POP3" selector="sendQuit">sendQuit	self sendCommand: 'QUIT'.	stream ioConnection isNil ifTrue: [^self].	self waitForResponse.	self hasPositiveResponse ifFalse: [^NetClientError raiseSignal: self serverResponse].	stream close</body><body package="POP3" selector="sendReset">sendReset	self sendCommand: 'RSET'.	self waitForResponse.	"Should never be false"	self hasPositiveResponse ifFalse: [^NetClientError raiseSignal: self serverResponse]</body><body package="POP3" selector="sendRetrieveMessage:">sendRetrieveMessage: number 	| lines size result resultStream |	self sendCommand: ('RETR &lt;1p&gt;' expandMacrosWith: number).	self waitForResponse.	self hasPositiveResponse ifFalse: [^NetClientError raiseSignal: self serverResponse].	lines := LinkedList new.	size := 0.	self retrieveMultiLineResponseDo: 			[:line | | lineSize |			lineSize := line size.			size := size + lineSize - 1.			IncrementNotification signalWith: lineSize.			lines addLast: (LinkValue value: line)].	result := String new: size.	resultStream := result writeStream.	lines do: [:lv| | line | line := lv value. resultStream next: line size - 1 putAll: line startingAt: 1].	(result size ~= size	or: [resultStream position ~= size]) ifTrue:		[self error: (#WrongNumberOfElementsWritten &lt;&lt; #net &gt;&gt; 'wrong number of elements written to resultStream')].	^result</body><body package="POP3" selector="sendRetrieveMessageID:">sendRetrieveMessageID: number	"Return a message's unique id as a String, or nil if the server does not support the UIDL command."	| response |	self sendCommand: ('UIDL &lt;1p&gt;' expandMacrosWith: number).	self waitForResponse.	self hasPositiveResponse ifFalse: [^nil].	^(response := self serverResponse) notEmpty 		ifTrue:			[response copyFrom: (response lastIndexOf: Character space) + 1 to: response size - 2]		ifFalse: [nil]</body><body package="POP3" selector="sendRetrieveMessageLines:">sendRetrieveMessageLines: number	"Return a message as an OrderedCollection of lines with CRLF termination."	| lines count result |	self sendCommand: ('RETR &lt;1p&gt;' expandMacrosWith: number).	self waitForResponse.	self hasPositiveResponse ifFalse: [^NetClientError raiseSignal: self serverResponse].	lines := LinkedList new.	count := 0.	self retrieveMultiLineResponseDo: 		[:line | 		count := count + 1.		IncrementNotification signalWith: line size.		lines addLast: (LinkValue value: line)].	result := OrderedCollection new: count + 10.	lines do: [:lv| result addLast: lv value].	^result</body><body package="POP3" selector="sendStat">sendStat	| result |	self sendCommand: 'STAT'.	self waitForResponse.	"It should always be positive"	self hasPositiveResponse ifFalse: [^self].	result := (serverResponse tokensBasedOn: Character space).	^Pop3Status new		messages: (Number readFrom: (result at: 2) readStream);		octets: (Number readFrom: (result at: 3) readStream);		yourself</body><body package="POP3" selector="sendTop:of:">sendTop: number of: msg	| lines size result resultStream |	self sendCommand: ('TOP &lt;1p&gt; &lt;2p&gt;' expandMacrosWith: msg with: number).	self waitForResponse.	self hasPositiveResponse ifFalse: [^NetClientError raiseSignal: self serverResponse].	lines := LinkedList new.	size := 0.	self retrieveMultiLineResponseDo: 			[:line | | lineSize |			lineSize := line size.			size := size + lineSize - 1.			IncrementNotification signalWith: lineSize.			lines addLast: (LinkValue value: line)].	result := String new: size.	resultStream := result writeStream.	lines do: [:lv| | line | line := lv value. resultStream next: line size - 1 putAll: line startingAt: 1].	(result size ~= size	or: [resultStream position ~= size]) ifTrue:		[self error: (#WrongNumberOfElementsWritten &lt;&lt; #net &gt;&gt; 'wrong number of elements written to resultStream')].	^result</body><body package="POP3" selector="sendUser">sendUser	self sendCommand: ('USER &lt;1s&gt;' expandMacrosWith: self user username).	self waitForResponse.	self hasPositiveResponse ifFalse: [^NetClientError signalWith: #login message: self serverResponse].</body><body package="POP3" selector="serverResponse:">serverResponse: aString	self log: ['S: &lt;2s&gt; R: &lt;1s&gt;' expandMacrosWith: aString with: self hostName] 		level: #POP3ConnServer.	serverResponse := aString</body><body package="POP3" selector="waitForResponse">waitForResponse	| result |	stream ioConnection input readWait.	result := stream throughAll: CRLF.	self serverResponse: result</body></methods><methods><class-id>Net.Pop3Client</class-id> <category>connection</category><body package="POP3" selector="connect">connect	| socket |	self state: Pop3AuthorizationState new.	(socket := self createSocket) isNil ifTrue: [^NetClientError signalWith: #connection].	connection := ExternalConnection new.	connection input: socket; output: socket.	stream := connection readAppendStream.	stream lineEndTransparent.	self waitForResponse</body><body package="POP3" selector="isConnected">isConnected	^connection notNil</body></methods><methods><class-id>Net.Pop3Client</class-id> <category>commands</category><body package="POP3" selector="apop:digest:">apop: aStringName digest: aStringDigest	self state apopName: aStringName digest: aStringDigest for: self.	self hasPositiveResponse ifFalse: [^false].	self state: Pop3TransactionState new.	^true</body><body package="POP3" selector="delete:">delete: message	^self state delete: message for: self</body><body package="POP3" selector="deleteMessageIds:">deleteMessageIds: aCollectionOfUniqueIDs	"Delete all messages which have unique ids in the argument.	 Answer the number of messages remaining on the server."	^self state deleteMessageIds: aCollectionOfUniqueIDs for: self</body><body package="POP3" selector="disconnect">disconnect	self sendQuit.	self state: Pop3State new.	stream := nil</body><body package="POP3" selector="list">list	^self state list: self</body><body package="POP3" selector="list:">list: messageNumber 	^self state list: messageNumber for: self</body><body package="POP3" selector="login">login	self state user: self.	self hasPositiveResponse ifFalse: [^false].	self state pass: self.	self hasPositiveResponse ifFalse: [^false].	self state: Pop3TransactionState new. 	^true</body><body package="POP3" selector="noop">noop	^self state noop: self</body><body package="POP3" selector="quit">quit	self disconnect</body><body package="POP3" selector="reset">reset	^self state reset: self</body><body package="POP3" selector="retrieveMessage:">retrieveMessage: number	^self state retrieveMessage: number for: self</body><body package="POP3" selector="retrieveMessageID:">retrieveMessageID: number	^self state retrieveMessageID: number for: self</body><body package="POP3" selector="retrieveMessageLines:">retrieveMessageLines: number	^self state retrieveMessageLines: number for: self</body><body package="POP3" selector="status">status	^self state stat: self</body><body package="POP3" selector="top:of:">top: lines of: messageID	^self state top: lines of: messageID for: self</body><body package="POP3" selector="uidl:">uidl: aNumber	^self retrieveMessageID: aNumber</body></methods><methods><class-id>Net.Pop3Client</class-id> <category>debugging</category><body package="POP3" selector="log:level:">log: aStringOrBlock level: aLevel	Tools.LogEnvironment default log: aStringOrBlock level: aLevel</body></methods><methods><class-id>Net.Pop3Client</class-id> <category>testing</category><body package="POP3" selector="hasNegativeResponse">hasNegativeResponse	^(self serverResponse indexOfSubCollection: '-ERR' startingAt: 1) &gt; 0</body><body package="POP3" selector="hasPositiveResponse">hasPositiveResponse	^(self serverResponse indexOfSubCollection: '+OK' startingAt: 1) &gt; 0</body><body package="POP3" selector="successful">successful	^self hasPositiveResponse</body></methods><methods><class-id>Net.Pop3Client</class-id> <category>accessing</category><body package="POP3" selector="serverResponse">serverResponse	^serverResponse isNil		ifTrue: [serverResponse := String new]		ifFalse: [serverResponse]</body><body package="POP3" selector="state">state	^state</body><body package="POP3" selector="state:">state: aState 	state := aState</body></methods><methods><class-id>Net.Pop3Client</class-id> <category>initialize-release</category><body package="POP3" selector="initialize">initialize	self state: Pop3State new</body></methods><methods><class-id>Net.Pop3Client class</class-id> <category>constants</category><body package="POP3" selector="description">description	^(#incomingMailServer &lt;&lt; #net &gt;&gt; 'incoming mail server') asString</body><body package="POP3" selector="serverType">serverType	^#POP3</body></methods><methods><class-id>Net.Pop3Client class</class-id> <category>testing</category><body package="POP3" selector="isIncomingMailClient">isIncomingMailClient	^true</body><body package="POP3" selector="isMailClient">isMailClient	^true</body><body package="POP3" selector="isOutgoingMailClient">isOutgoingMailClient	^false</body></methods><methods><class-id>Net.Pop3Client class</class-id> <category>class initialization</category><body package="POP3" selector="initialize">initialize	super initialize.	self registerToDebug.</body><body package="POP3" selector="registerClass">registerClass	self mailRegistry at: self serverType put: self name</body></methods><methods><class-id>Net.Pop3Client class</class-id> <category>private</category><body package="POP3" selector="update:with:from:">update: anAspect with: arguments from: anObject</body></methods><methods><class-id>Net.Pop3Client class</class-id> <category>utilities</category><body package="POP3" selector="messageCount">messageCount	"How many messages are on the server?"	"self messageCount"	| connection |	connection := self promptForConnection.	^[connection status messages]		ensure: [connection disconnect]</body><body package="POP3" selector="promptForConnection">promptForConnection	"Pop3Connection promptForConnection"	| connection user  host |	user := NetUser request.	user isNil ifTrue: [^self].	host := Dialog 		request: 'Pop server on:' 		initialAnswer: (LastServer isNil ifTrue: ['xxxx.com'] ifFalse: [LastServer]) 		onCancel: [^nil].	LastServer := host.	connection := self host: host.	connection user: user.	connection 		connect; 		login.	^connection</body><body package="POP3" selector="showProgress:complete:while:">showProgress: aString complete: anInteger while: aBlock 	"Show a progress indicator window while executing a block of code.	anInteger is the completeness count (ie = 100%).	IncrementNotification is raised to denote progress."	"self  showProgress: 'X' complete: 10000 while: 		[ 10000 timesRepeat: [ IncrementNotification raiseSignal ] ]"	| increment progress pw res |	increment := 1.0 / anInteger. 	progress := 0.0 asValue.	pw := ProgressWidgetView progressOpenOn: progress label: aString asText allBold.	[ [ Cursor wait showWhile: [ res := aBlock value ] ] on: IncrementNotification do:		[ :not | 		progress value: ( progress value + ( not ticks * increment ) ).		not resume.		 ]	] ensure: [ pw closeAndUnschedule ].	^res</body><body package="POP3" selector="timestampFormat">timestampFormat	"This is simply moronic."	|policy|	policy := (OrderedCollection new: 10)		add: #ddd;		add: Character space;		add: #mmm;		add: Character space;		add: #d;		add: Character space;		add: #h;		add: $: ;		add: #mm;		add: Character space;		add: #yyyy;		yourself.	^policy asArray</body></methods><methods><class-id>Net.Pop3Client class</class-id> <category>instance creation</category><body package="POP3" selector="new">new	^super new initialize</body></methods><methods><class-id>Net.Pop3Client class</class-id> <category>defaults</category><body package="POP3" selector="defaultPortNumber">defaultPortNumber	"The default port a Pop3Server will listen on"	^110</body></methods><methods><class-id>Net.Pop3Client class</class-id> <category>debugging</category><body package="POP3" selector="debugLabelsAndValues">debugLabelsAndValues	^(OrderedCollection new)		add: ((#Pop3ClientMessages &lt;&lt; #net &gt;&gt; 'Pop3 Client Messages')-&gt;#POP3Client);		add: (#Pop3ServerMessages &lt;&lt; #net &gt;&gt; 'Pop3 Server Messages')-&gt;#POP3ConnServer;		add: (#Pop3ConnectionRetries &lt;&lt; #net &gt;&gt; 'Pop3 Connection Retries')-&gt;#POP3ConnRetries;		yourself</body><body package="POP3" selector="menuItemName">menuItemName	^(#POP3ClientMessages &lt;&lt; #net &gt;&gt; 'POP3 Client Messages') asString</body></methods><methods><class-id>Net.Pop3Mailbox</class-id> <category>private</category><body package="POP3" selector="clientSpecies">clientSpecies	^Pop3Client</body><body package="POP3" selector="deleteMessageNumbers:">deleteMessageNumbers: aSequenceOfUids	^self connectedDo: [lastMessage := connection deleteMessageIds: aSequenceOfUids]</body><body package="POP3" selector="deliverFrom:to:">deliverFrom: startCount to: messageCount		self log: [(#DownloadingMessages &lt;&lt; #net &gt;&gt; 'Downloading &lt;1p&gt; messages from &lt;2s&gt;') expandMacrosWith: messageCount with: server] level: #IPOP3Download.	messageCount timesRepeat: 		[ | message n milliseconds |		 milliseconds := Time millisecondsToRun: [message := self getMessageNumber: (n := lastMessage + 1)].		 lastMessage := n.		 n - startCount \\ 10 = 0 			ifTrue: 				[self log: [(#DownloadedMessages &lt;&lt; #net &gt;&gt; 'Downloaded &lt;1p&gt; messages from &lt;2s&gt;')expandMacrosWith: n - startCount with: server] 					level: #POP3Download].			self deliver: message.			self debug: [self class processTransferRate: milliseconds ofSize: message size fromServer: server] 				level: #POP3TransferRate.			Processor yield "be nice to other mail polling processes" ]</body><body package="POP3" selector="getMessageNumber:">getMessageNumber: number 	"Get the &lt;number&gt; message from a Pop3 server on connection and return the message as a string."	| lines id  stream |	IncrementNotification raiseSignal. 	lines := connection retrieveMessageLines: number.	id := connection retrieveMessageID: number.	stream := (String new: 512) writeStream.	lines do: [ :each |  stream nextPutAll: (each copyFrom: 1 to: ( each size - 1)) ].	^LetterInTransit new		letterText: stream contents;		uid: id;		server: self server;		serverType: self serverType;		deliveryAction: [self saveSettings: number];		yourself</body></methods><methods><class-id>Net.Pop3Mailbox</class-id> <category>commands</category><body package="POP3" selector="allHeaders">allHeaders	| messageCount |	^self connectedDo: 		[messageCount := connection status messages.		(1 to: messageCount)			collect: 				[:i | 				MailIncrementNotification raiseSignal.				MimeEntity readHeaderFrom: (connection top: 10 of: i) readStream]]</body><body package="POP3" selector="anyNewMail">anyNewMail	"Any new mail to get?"	^self messageCount &gt; lastMessage</body><body package="POP3" selector="getMessage:">getMessage: number 	"Get the &lt;number&gt; message from the Pop3server"	^self safelyExecute: 	[self getMessageNumber: number]</body><body package="POP3" selector="messageCount">messageCount	"How many messages are on the server?"		^self safelyExecute:				[connection status messages].</body></methods><methods><class-id>Net.Pop3Mailbox</class-id> <category>accessing</category><body package="POP3" selector="serverType">serverType	^'POP3'</body></methods><methods><class-id>Net.Pop3Mailbox</class-id> <category>mail delivery</category><body package="POP3" selector="deliverAllMail">deliverAllMail	"Queue up all new messages onto the queue. Clients of this 	method should be aware that the state should be such that there 	is new mail to download."	self safelyExecute:		[|  messageCount |		messageCount := connection status messages.		self deliverFrom: 1 to: messageCount.		self log: [(#DoneDownloaded &lt;&lt; #net &gt;&gt; 'Done; downloaded &lt;1p&gt; messages from &lt;2s&gt;') expandMacrosWith: messageCount with: server]			level: #POP3Download		]</body><body package="POP3" selector="deliverMail">deliverMail	"Queue up a message onto the queue."	| n |	self deliver: (self getMessage: (n := lastMessage + 1)).	lastMessage := n.</body><body package="POP3" selector="deliverNewMail">deliverNewMail	"Queue up all new messages onto the queue. Clients of this 	method should be aware that the state should be such that there 	is new mail to download."	self safelyExecute:		[|   startCount messageCount |		messageCount := connection status messages - (startCount := lastMessage).		self deliverFrom: startCount to: messageCount.		self log: [(#DoneDownloaded &lt;&lt; #net &gt;&gt; 'Done; downloaded &lt;1p&gt; messages from &lt;2s&gt;') expandMacrosWith: (lastMessage - startCount) with: server]			level: #POP3Download		]</body></methods><methods><class-id>Net.Pop3Mailbox class</class-id> <category>debugging</category><body package="POP3" selector="debugLabelsAndValues">debugLabelsAndValues	^OrderedCollection new		add: ((#Pop3MailboxDownloads &lt;&lt; #net &gt;&gt; 'Pop3Mailbox Downloads')-&gt;#POP3Download);		add: ((#Pop3MailboxServerChecking &lt;&lt; #net &gt;&gt; 'Pop3Mailbox Server Checking')-&gt;#POP3Check);		add: ((#Pop3MailboxTransferRate &lt;&lt; #net &gt;&gt; 'Pop3Mailbox Transfer Rate')-&gt;#POP3TransferRate);		yourself</body><body package="POP3" selector="initialize">initialize	self registerToDebug</body><body package="POP3" selector="menuItemName">menuItemName	^(#POP3MailboxMessages &lt;&lt; #net &gt;&gt; 'POP3 Mailbox Messages')</body></methods><methods><class-id>Net.Pop3Mailbox class</class-id> <category>utilities</category><body package="POP3" selector="processTransferRate:ofSize:fromServer:">processTransferRate: milliseconds ofSize: size fromServer: server 	"self processTransferRate: 32 ofSize: 1836 fromServer: 'sulu.cincom.com' "	| bytesPerSecond kiloBytesPerSecond maxTransferRate minTransferRate |	bytesPerSecond := (size / milliseconds) * 1000.	kiloBytesPerSecond := (bytesPerSecond / 1024) asFloat.	maxTransferRate := (MaxTransferRate at: server ifAbsentPut: [0]) max: kiloBytesPerSecond.	maxTransferRate = kiloBytesPerSecond ifTrue: 		[MaxTransferRate at: server put: kiloBytesPerSecond].	minTransferRate := (MinTransferRate at: server ifAbsentPut: [1024*1024]) min: kiloBytesPerSecond.	minTransferRate = kiloBytesPerSecond ifTrue: 		[MinTransferRate at: server put: kiloBytesPerSecond].	self log: [(#TransferRateOfKbps &lt;&lt; #net &gt;&gt; 'Transfer Rate of &lt;1p&gt; Kbps from &lt;2s&gt;. Max: &lt;3p&gt; Min: &lt;4p&gt;') 					expandMacrosWith: kiloBytesPerSecond					with: server					with: maxTransferRate					with: minTransferRate]		level: #POP3TransferRate.</body><body package="POP3" selector="promptForConnection">promptForConnection	"Pop3Mailbox promptForConnection"	| connection user  host |	user := NetUser request.	user isNil ifTrue: [^self].	host := Dialog 		request: (#PopServerOn &lt;&lt; #net &gt;&gt; 'Pop server on:') 		initialAnswer: (LastServer isNil ifTrue: [(#postofficepacbellnet &lt;&lt; #net &gt;&gt; 'xxxx.com')] ifFalse: [LastServer]) 		onCancel: [^nil].	LastServer := host.	connection := Pop3Client host: host.	connection user: user.	^connection</body><body package="POP3" selector="request">request	"Pop3Mailbox request"	| username password  host cancel |	username := (NetUser lastUser isNil					ifTrue: ['']					ifFalse: [NetUser lastUser]) asValue.	password := '' asValue.	host := (LastServer isNil 				ifTrue: [(#postofficepacbellnet &lt;&lt; #net &gt;&gt; 'xxxx.com')] 				ifFalse: [LastServer]) asValue.	cancel := (SimpleDialog initializedFor: nil)				setInitialGap;				addMessage: (#WhatPOP3ServerAndLogin &lt;&lt; #net &gt;&gt; 'What POP3 Server and login?') centered: true;				addGap;				addMessage: (#UsernameC &lt;&lt; #net &gt;&gt; 'Username:') textLine: username boundary: 0.4;				addGap;				addMessage: (#PasswordC &lt;&lt; #net &gt;&gt; 'Password:') textLine: password type: #password boundary: 0.4;				addGap;				addMessage: (#POP3Server &lt;&lt; #net &gt;&gt; 'POP3 Server:') textLine: host boundary: 0.4;				addGap;				addOK: [true];				openDialog;				cancel.	cancel value ifTrue: [^nil].	^self		user:  (NetUser username: username value password: password value)		server: host value</body></methods><methods><class-id>Net.Pop3State</class-id> <category>commands</category><body package="POP3" selector="apopName:digest:for:">apopName: aStringName digest: aStringDigest for: aConnection	Pop3StateError raiseSignal</body><body package="POP3" selector="delete:for:">delete: message for: connection	Pop3StateError raiseSignal</body><body package="POP3" selector="deleteMessageIds:for:">deleteMessageIds: aSequenceOfUniqueIDs for: connection	Pop3StateError raiseSignal</body><body package="POP3" selector="list:for:">list: number for: connection 	Pop3StateError raiseSignal</body><body package="POP3" selector="listMessage:for:">listMessage: number for: connection 	Pop3StateError raiseSignal</body><body package="POP3" selector="noop:">noop: aConnection	Pop3StateError raiseSignal</body><body package="POP3" selector="pass:">pass: aConnection 	Pop3StateError raiseSignal</body><body package="POP3" selector="quit:">quit: aConnection 	aConnection sendQuit</body><body package="POP3" selector="reset:">reset: aConnection	Pop3StateError raiseSignal</body><body package="POP3" selector="retrieveMessage:for:">retrieveMessage: number for: connection 	Pop3StateError raiseSignal</body><body package="POP3" selector="retrieveMessageID:for:">retrieveMessageID: number for: connection	Pop3StateError raiseSignal</body><body package="POP3" selector="retrieveMessageLines:for:">retrieveMessageLines: number for: connection 	Pop3StateError raiseSignal</body><body package="POP3" selector="stat:">stat: aConnection 	Pop3StateError raiseSignal</body><body package="POP3" selector="top:of:for:">top: lines of: msg for: connection	Pop3StateError raiseSignal</body><body package="POP3" selector="user:">user: aConnection 	Pop3StateError raiseSignal</body></methods><methods><class-id>Net.Pop3TransactionState</class-id> <category>commands</category><body package="POP3" selector="delete:for:">delete: message for: connection	^connection sendDeleteMessage: message</body><body package="POP3" selector="deleteMessageIds:for:">deleteMessageIds: aSequenceOfUniqueIDs for: connection	^connection sendDeleteMessageIds: aSequenceOfUniqueIDs</body><body package="POP3" selector="list:">list: aConnection	^aConnection sendList</body><body package="POP3" selector="list:for:">list: number for: connection 	^connection sendList: number</body><body package="POP3" selector="listMessage:for:">listMessage: number for: connection 	^connection sendList: number</body><body package="POP3" selector="noop:">noop: aConnection	^aConnection sendNoop</body><body package="POP3" selector="reset:">reset: connection 	^connection sendReset</body><body package="POP3" selector="retrieveMessage:for:">retrieveMessage: number for: connection 	^connection sendRetrieveMessage: number</body><body package="POP3" selector="retrieveMessageID:for:">retrieveMessageID: number for: connection 	^connection sendRetrieveMessageID: number</body><body package="POP3" selector="retrieveMessageLines:for:">retrieveMessageLines: number for: connection 	^connection sendRetrieveMessageLines: number</body><body package="POP3" selector="stat:">stat: aConnection	^aConnection sendStat</body><body package="POP3" selector="top:of:for:">top: lines of: msg for: connection	^connection sendTop: lines of: msg</body></methods><methods><class-id>Net.Pop3AuthorizationState</class-id> <category>commands</category><body package="POP3" selector="apopName:digest:for:">apopName: aStringName digest: aStringDigest for: aConnection	^aConnection sendApopName: aStringName digest: aStringDigest</body><body package="POP3" selector="pass:">pass: aConnection 	aConnection sendPassword</body><body package="POP3" selector="user:">user: aConnection 	aConnection sendUser</body></methods><methods><class-id>Net.Pop3Status</class-id> <category>accessing</category><body package="POP3" selector="messages">messages	^messages isNil		ifTrue: [messages := 0]		ifFalse: [messages]</body><body package="POP3" selector="messages:">messages: count 	messages := count</body><body package="POP3" selector="octets">octets	^octets isNil		ifTrue: [octets := 0]		ifFalse: [octets]</body><body package="POP3" selector="octets:">octets: count 	octets := count</body></methods><initialize><class-id>Net.Pop3Client</class-id></initialize><initialize><class-id>Net.Pop3Mailbox</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Mailbox</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>user server lastMessage keepMail deleteMail deliveryQueue pollingProcess delaySemaphore sync settingsSync connection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Mail</category><attributes><package>Mail</package></attributes></class><class><name>NetClient</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>user hostName portNumber clientPI retries timeout delaySeconds </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>NetClientError</name><environment>Net</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class></st-source>