<?xml version="1.0"?><st-source><!-- Name: HTTPNotice: Copyright © 1999, 2000, 2002, 2002, 2001 Cincom Systems, Inc.  All Rights Reserved.Comment: HTTP support provides the ability to make connections to servers in order to request resources via the HTTP protocol, which is a superset of MIME.DbIdentifier: bear73DbTrace: 53245DevelopmentPrerequisites: #(#(#any 'MIME' '') #(#any 'NetConfigTool' '') #(#any 'URISupport' '') #(#any 'Compression-ZLib' ''))PackageName: HTTPParcel: #('HTTP')ParcelName: HTTPPrerequisiteParcels: #(#('MIME' '') #('URISupport' '') #('NetConfigTool' '') #('Compression-ZLib' ''))PrintStringCache: (7.4  0,tkogan)Version: 7.3.1Date: 6:45:12 pm April 10, 2005 --><time-stamp>From VisualWorks®, 7.3.1 of April 10, 2005 on April 10, 2005 at 6:45:12 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>CookieAgent</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>registry cacheCookies useCachedCookies enableLimits </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.CookieAgent</class-id><body>CookieAgent provides cookie management during a session with Http requests and responses. Implementation based on RFC2965 and Netscape preliminary specification (http://wp.netscape.com/newsref/std/cookie_spec.html).Instance Variables:	cacheCookies	&lt;Boolean&gt;	specifies whether or not to cache cookies	enableLimits	&lt;Boolean&gt;	specifies whether or not to check registry limits	registry	&lt;Dictionary&gt; cookie registry	useCachedCookies	&lt;Boolean&gt;	specifies whether or not to use cached cookie when a session startsShared variable Registry &lt;Dictionary &gt;  holds cached cookies.How to create cookie fields:"Creating Cookies using Netscape style"header := SetCookieValue netscapeStyleName: 'Customer' value: 'WILE_E_COYOTE'.header 		secure: true;		expires: Timestamp now;		path: '/smalltalk';		domain: 'cincom.com'.'Customer=WILE_E_COYOTE;expires=Mon, 31 Jan 2005 19:36:35 GMT;path=/smalltalk;secure;domain=cincom.com'cookie := CookieField newNetscape.cookie 		addValue: (CookieValue name: 'Customer' value: 'WILE_E_COYOTE');		addValue: ( CookieValue name: 'Part_Number' value: 'Rocket_Launcher_0001');		addValue: ( CookieValue name: 'Shipping' value: 'FedEx'). 'Cookie: Customer=WILE_E_COYOTE;Part_Number=Rocket_Launcher_0001;Shipping=FedEx'"Creating RFC style cookies"cookie := CookieField new.val := cookie addName: 'Customer' value: 'WILE_E_COYOTE'.val 	path: '\acme';	domain: 'foo.com';	port: 8085.val := cookie addName: 'Part_Number' value: 'Rocket_Launcher_0001'.val 	path: '\info';	domain: 'foo1.com'.'Cookie: $version=1;	Customer=WILE_E_COYOTE;$path=\acme;$port="8085";$domain=foo.com;	Part_Number=Rocket_Launcher_0001;$path=\info;$domain=foo1.com'header := SetCookieValue name: 'Customer' value: 'WILE_E_COYOTE'.header 		secure: true;		domain: 'cincom.com';		maxAge: 0;		comment: 'some comments'.'Customer=WILE_E_COYOTE;max-age=0;comment="some comments";domain=cincom.com;version=1;secure'header := SetCookie2Value name: 'Customer' value: 'WILE_E_COYOTE'.header 		secure: true;		domain: 'cincom.com';		maxAge: 0;		comment: 'some comments';		port: (OrderedCollection with: 8080 with: 80).'Customer=WILE_E_COYOTE;secure;comment="some comments";max-age=0;domain=cincom.com;port="8080,80";version=1'</body></comment><class><name>HttpDispatcher</name><environment>Net</environment><super>Net.MessageDispatcher</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpDispatcher</class-id><body>HttpDispatcher is controlling Http message printing</body></comment><class><name>CacheControl</name><environment>Net</environment><super>Net.CollectionField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.CacheControl</class-id><body>CacheControl represents 'cache-control' Http header field. The Cache-Control general-header field is used to specify directives that MUST be obeyed by all caching mechanisms along the request/response chain. Cache-Control   = "Cache-Control" ":" 1#cache-directive	cache-directive = cache-request-directive  | cache-response-directive	cache-request-directive =                            "no-cache" [ "=" &lt;"&gt; 1#field-name &lt;"&gt; ]                          | "no-store"                          | "max-age" "=" delta-seconds                          | "max-stale" [ "=" delta-seconds ]                          | "min-fresh" "=" delta-seconds                          | "only-if-cached"                          | cache-extension	cache-response-directive =                            "public"                          | "private" [ "=" &lt;"&gt; 1#field-name &lt;"&gt; ]                          | "no-cache" [ "=" &lt;"&gt; 1#field-name &lt;"&gt; ]                          | "no-store"                          | "no-transform"                          | "must-revalidate"                          | "proxy-revalidate"                          | "max-age" "=" delta-seconds                          | cache-extensionno-cache  Indicates that all or part of the response message MUST NOT be cached  anywhere. This allows an origin server to prevent caching even by  caches that have been configured to return stale responses to client  requestsNote: Most HTTP/1.0 caches will not recognize or obey this  directive.</body></comment><class><name>HttpProxyExceptions</name><environment>Net</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>httpProxyExceptions parent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpProxyExceptions</class-id><body>A HttpProxyException  provides an user-interface for editing a http proxy exceptions. Instance Variables:	httpProxyExceptions	&lt;String&gt;	proxy exceptions</body></comment><class><name>AcceptHeaderFields</name><environment>Net</environment><super>Net.ValueWithParametersField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.AcceptHeaderFields</class-id><body>AcceptHeaderFields is abstract class for "Accept.." header fields.</body></comment><class><name>HttpException</name><environment>Net</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpException</class-id><body>This class reports errors which are reported by the HTTP server being accessed.Instance Variables:</body></comment><class><name>HttpEntityError</name><environment>Net</environment><super>Net.HttpException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpEntityError</class-id><body>This exception is raised if the error was detected while parsing the http entity. </body></comment><class><name>AcceptCharsetField</name><environment>Net</environment><super>Net.AcceptHeaderFields</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.AcceptCharsetField</class-id><body>AcceptCharsetField represents "Accept-Charset" header field as it described in RFC2616. The Accept-Charset request-header field can be used to indicate what character sets are acceptable for the response. </body></comment><class><name>HttpTimeout</name><environment>Net</environment><super>Net.HttpException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpTimeout</class-id><body>Timeout exception is raised after the time we wait while reading a buffer in HttpSockedAccessor is expired.  Instance Variables:</body></comment><class><name>AuthenticateChallengeField</name><environment>Net</environment><super>Net.ValueWithParametersField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.AuthenticateChallengeField</class-id><body>This class represents the structure of the www-authenticate field as it described in RFC2616. This is a paramterized field with a single value followed by parameters, but it does not follow the usual practise of separating the paramters by semicolons. Instead it uses commas, and does not require a comma before the first (realm) parameter.Instance Variables:	scheme	&lt;String&gt;	name of authentication scheme	realm	&lt;String&gt;	if there are parameters, the first must be realm--this is the realm value.	params	&lt;Dictionary&gt;	additional named parameters</body></comment><class><name>NewCookieSignal</name><environment>Net</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.NewCookieSignal</class-id><body>NewCookieSignal the exception is raised when unknown parameter is detected while parsing cookie fields.</body></comment><class><name>HttpBuildHandler</name><environment>Net</environment><super>Net.MessageBuildHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>options </inst-vars><class-inst-vars></class-inst-vars><imports>			OS.ZLib.*			</imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpBuildHandler</class-id><body>This class adds HTTP-specific logic to deal with chunked message bodies. The logic of this builder is to accumulate all chunks to create a monolithic body and to remove 'transfer-encoding' field when message body is complete. Depending on parsing option the builder writes row socket bytes in to the message body or decompressed and decoded string. See the option description in the HttpClient class comments.</body></comment><class><name>HttpInformationalError</name><environment>Net</environment><super>Net.HttpException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpInformationalError</class-id><body>This class reports http informational errors which are reported by the HTTP server being accessed.1xx: Informational - Request received, continuing processInstance Variables:</body></comment><class><name>HttpClient</name><environment>Net</environment><super>Net.NetClient</super><private>false</private><indexed-type>none</indexed-type><inst-vars>request proxyHost keepAlive useProxyAuthorization connection entityParsingOptions cookieAgent enableCookies protocol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpClient</class-id><body>This client makes http/https connections to servers in order to request resources via HTTP protocol, which is a superset of MIME. The HttpClient creates connection based on URL protocol which can be http or https.  Supports cookie state management.If the Http client receives the https URL protocol and detects that the HTTPS support is not loaded, the client does the following:1. if the URL Settings allows to auto load the HTTPS parcel, the parcel will be loaded and and created SSL connection2. if the URL Settings Https auto load is turned off (default behavior), the HttpClient raises the ComponentNotLoaded exception. The exception is resumable and resuming the exception by default loads the HTTPS parcel.Instance Variables:	request	&lt;HttpRequest&gt;	the HttpRequest object	keepAlive	&lt;aBoolean&gt;	 the variable allows to set persistent connection.	connectionStream	&lt;HttpStreamHandler&gt;	external connection stream handler	proxyHost	&lt;HostSpec&gt; the proxy server 		entityParsingOptions &lt;Dictionary&gt; possible keys: 				#decompressContents - default is true: decompresses the message contents and removes Content-Encoding header field. Currentry supported only gzip compression. Setting the option to false returns the Http message body with row socket stream bytes.				#decodeContents - default is true: decodes the message contents based on the header charset. Default charset is #ISO8859_1. Setting the option to false returns the Http message body with row socket stream bytes.	Connectionconnection stream  is persistent		if  #keepAlive method for the HttpClient instance or request returns  trueconnection stream  is closed after each request		if  #keepAlive method for the HttpClient instance and request returns  falseIf server sends a response with closed connection the HttpClient closes the connection stream but doesn't change the #keepAlive variable.	Error handlingIf user application doesn't provide error handling for HttpClient the HttpClient is going to try handle some exceptions by itself. The exceptions that client can handle are located in the processing category.	Sending chunked request:client := HttpClient new.request := HttpRequest post: 'http://uddi.microsoft.com/inquire'.request transferEncoding:  'chunked'.client 	connectRequest: request 	do:  [ :connection | 		request writeChunkedOn: connection		do: [ request 				writeChunk: stream encodedContents asString  				on: connection ]].Sample how to create cookie fields see in CookieAgent comments	</body></comment><class><name>HttpRequestLine</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method url version prefix path </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpRequestLine</class-id><body>Represents the requst line of Http message.	Request-Line   = Method SP Request-URI SP HTTP-Version CRLFInstance Variables:	method	&lt;String&gt;	the method to be applied to the resource	url	&lt;URI&gt;	the resorce locator 	version	&lt;String&gt;	HTTP protocol version to use</body></comment><class><name>HttpResponseStatusLine</name><environment>Net</environment><super>Net.NetworkResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars>protocol version </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpResponseStatusLine</class-id><body>Represenrs the first line of a HttpResponse message that consists of the protocol version followed by a numeric status code and its associated textual phrase. 	Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLFInstance Variables:	protocol	&lt;String&gt;	Http protocol	version	&lt;String&gt;	Http version#code method returns element is a 3-digit integer result code of the  attempt to understand and satisfy the request. (Status-Code)#message method is return a short textual description of the code (Reason-Phrase)</body></comment><class><name>RegistryLimitationExc</name><environment>Net</environment><super>Net.HttpException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.RegistryLimitationExc</class-id><body>RegistryLimitationExc exception is raised when one of the registry limits was exceeded</body></comment><class><name>HttpNotExtendedError</name><environment>Net</environment><super>Net.HttpException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpNotExtendedError</class-id><body>HttpNotExtendedError reports 510 errors. The server does not support the functionality required to fulfill the request. This is the appropriate response when the server does not recognize the request method and is not capable of supporting it for any resource</body></comment><class><name>HttpEntity</name><environment>Net</environment><super>Net.MimeMultipartEntity</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nextNamespaceId needsContentLength parsingOptions </inst-vars><class-inst-vars></class-inst-vars><imports>			OS.ZLib.*			</imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpEntity</class-id><body>Represents HttpEntity super class. Supports protocol to parse and compose chunked http entity.Instance Variables:	nextNamespaceId &lt;Number&gt; represents two-digit header prefix for extention declaration	parsingOptions &lt;Dictionary&gt; possible keys: 				#decompressContents - default is true: decompresses the message contents and removes Content-Encoding header field. Currentry supported only gzip compression. Setting the option to false returns the Http message body with row socket stream bytes.				#decodeContents - default is true: decodes the message contents based on the header charset. Default charset is #ISO8859_1. Setting the option to false returns the Http message body with row socket stream bytes.API to handle message contens: #byteContents - returns row bytes as ByteArray#contents - retuns decoded message contents based on the message charset as ByteString. If the message was not decompresssed returns row bytes as string.#decompressedContents - returns decompress row bytes if the message includes "Content-Encoding: gzip" header field. The header fields will not be removed and the message contents will not be changed. It will still contain row bytes.#decodedContents - returns decoded message contents based on the message charset encoding. The message contents will not be changed.The 'mandatory extension' category represents implementation of RFC2774 			An HTTP Extention Framework</body></comment><class><name>HttpResponse</name><environment>Net</environment><super>Net.HttpEntity</super><private>false</private><indexed-type>none</indexed-type><inst-vars>statusLine </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpResponse</class-id><body>Represents the responce that a server replies after receiving and interpreting a request message. The first line of a HttpResponse message is the status line.Instance Variables:	statusLine	&lt;HttpStatusLine&gt;	an instance of HttpStatusLine</body></comment><class><name>HttpURL</name><environment>Net</environment><super>Net.URLwithAuthority</super><private>false</private><indexed-type>none</indexed-type><inst-vars>user decompressContents decodeContents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpURL</class-id><body>This URL describes resources accessed using the HTTP protocol.Instance Variables:	user	&lt;NetUser&gt;	an user ID authorized to access the proxy server	decompressContents 	&lt;Boolean&gt; defines whether or not to decompess the reponse contents	decodeContents &lt;Boolean&gt; defines whether or not to decode the response contents</body></comment><class><name>HttpServerError</name><environment>Net</environment><super>Net.HttpException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpServerError</class-id><body>This class reports server errors which are reported by the HTTP server being accessed.5xx: Server Error - The server failed to fulfill an apparently        valid requestInstance Variables:</body></comment><class><name>QuotedPrintRequired</name><environment>Net</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.QuotedPrintRequired</class-id><body>QuotedPrintRequired exception is raised to notify about printing ports for cookie header fields. The syntax requires quotes around the optional port list even if there is only one port number in the port list</body></comment><class><name>HttpSocketAccessor</name><environment>Net</environment><super>OS.SocketAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>time timeout </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpSocketAccessor</class-id><body>This class overrides its superclass to allow timeouts on reads, and also to choose a different kind of IOBuffer (indirectly through its choice of ExternalConnection class).Instance Variables:	time	&lt;Integer&gt;	time of the last successful read, in milliseconds	timeout	&lt;Integer&gt;	how long we should wait while reading a buffer, before assuming the connection died.</body></comment><class><name>AcceptField</name><environment>Net</environment><super>Net.AcceptHeaderFields</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.AcceptField</class-id><body>AcceptField represents "Accept" header field as it described in RFC2616. The Accept request-header field can be used to specify certain media types which are acceptable for the response. Accept headers can be used to indicate that the request is specifically limited to a small set of desired types, as in the case of a request for an in-line image.</body></comment><class><name>HttpStatusLineError</name><environment>Net</environment><super>Net.HttpException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpStatusLineError</class-id><body>HttpStatusLineError is raised if the Http parser read an empty response status line</body></comment><class><name>HttpBuffer</name><environment>Net</environment><super>OS.IOBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bufferPosition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpBuffer</class-id><body>Specialization of IOBuffer to remember position.Instance Variables:	bufferPosition	&lt;Integer&gt;	offset of the buffer in the data stream</body></comment><class><name>HttpStreamHandler</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream </inst-vars><class-inst-vars>encoding </class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpStreamHandler</class-id><body>HttpStreamHandler is a connection stream wrapperInstance Variables:	hostName	&lt;String&gt;	server name to connect	portNumber	&lt;Number&gt;	connection port 	stream	&lt;ExternalReadAppendStream&gt;	external connection stream	timeout	&lt;Number&gt;	timeout</body></comment><class><name>ManOptField</name><environment>Net</environment><super>Net.AcceptHeaderFields</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.ManOptField</class-id><body>ManOptField represents a mandatory field. For example:Man: http://www.copyright.org/rights-management; ns=16</body></comment><class><name>CookieFields</name><environment>Net</environment><super>Net.ValueWithParametersField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.CookieFields</class-id><body>CookieFields is super class for 'Cookie', 'Set-Cookie' and 'Set-Cookie2' header fields. </body></comment><class><name>CookieField</name><environment>Net</environment><super>Net.CookieFields</super><private>false</private><indexed-type>none</indexed-type><inst-vars>version </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.CookieField</class-id><body>CookieField represents 'Cookie' field. Instance Variables:	version	&lt;Number&gt;	cookie version	value &lt;Collection&gt; collection of CookieValueSample how to create cookie fields see in CookieAgent comments</body></comment><class><name>SetCookieField</name><environment>Net</environment><super>Net.CookieFields</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.SetCookieField</class-id><body>SetCookieField represents 'Set-Cookie' field. Implementation is based on RFC2965 and Netscape specification. The field value is collection of SetCookieValue. </body></comment><class><name>SetCookie2Field</name><environment>Net</environment><super>Net.SetCookieField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.SetCookie2Field</class-id><body>SetCookie2Field represents 'Set-Cookie2' field. Implementation is based on RFC2965. The field value is collection of SetCookie2Value. </body></comment><class><name>HttpPage</name><environment>Net</environment><super>Net.NetSettingsPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>redirectRequest proxyExceptions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpPage</class-id><body>HttpPage creates Http UI Settings pageInstance Variables:	proxyExceptions	&lt;Collection of Strings&gt;	do not use proxy servers for domains in the proxyExceptions list	redirectRequest	&lt;ValueModel of Boolean&gt;	describe wether or not redirect the request </body></comment><class><name>HttpConnection</name><environment>Net</environment><super>OS.ExternalConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpConnection</class-id><body>This class exists to make sure we use an HttpBuffer.Instance Variables:</body></comment><class><name>CookieValueWithParams</name><environment>Net</environment><super>Net.ValueWithParams</super><private>false</private><indexed-type>none</indexed-type><inst-vars>setSelectors printSelectors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.CookieValueWithParams</class-id><body>CookieValueWithParams is super class for cookie value. Implements cookie field parsing and printing.Instance Variables:	printSelectors	&lt;Dictionary&gt;	print selectors for cookie field parameters	setSelectors	&lt;Dictionary&gt;	set selectors for cookie field parameters</body></comment><class><name>CookieValue</name><environment>Net</environment><super>Net.CookieValueWithParams</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.CookieValue</class-id><body>CookieValue represents value for CookieField class. Supports two specifications RFC2965 and Netscape preliminary specification.   The RFC2965 syntax for the header is:cookie          =  "Cookie:" cookie-version 1*((";" | ",") cookie-value)cookie-value    =  NAME "=" VALUE [";" path] [";" domain] [";" port]cookie-version  =  "$Version" "=" valueNAME            =  attrVALUE           =  valuepath            =  "$Path" "=" valuedomain          =  "$Domain" "=" valueport            =  "$Port" [ "=" &lt;"&gt; value &lt;"&gt; ]The Netscape syntax is:Cookie: NAME1=OPAQUE_SRTING1; NAME2=OPAQUE_STRING2...Sample how to create cookie fields see in CookieAgent comments</body></comment><class><name>Cookie2Field</name><environment>Net</environment><super>Net.StructuredHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.Cookie2Field</class-id><body>Cookie2Field represents 'cookie2' Http header field. The field is described in RFC2965 and facilitate interoperation between clients and servers that understand different versions of the cookie specification.	"Cookie2:" cookie-version</body></comment><class><name>HttpPrintHandler</name><environment>Net</environment><super>Net.MessagePrintHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contentLengthPosition bodyPosition transferStream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpPrintHandler</class-id><body>This class is printer for HTTP messages. It's knows how to print chunked HTTP message bodies and the first line of the message.Instance Variables:</body></comment><class><name>SetCookieValue</name><environment>Net</environment><super>Net.CookieValueWithParams</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.SetCookieValue</class-id><body>SetCookieValue represents value of 'Set-Cookie2' header field. Implementation supports RFC2109 and Netscape specificationThe Netscape syntax isSet-Cookie: NAME=VALUE; expires=DATE; path=PATH; domain=DOMAIN_NAME; secureThe syntax for the Set-Cookie response  header is   set-cookie      =       "Set-Cookie:" cookies   cookies         =       1#cookie   cookie          =       NAME "=" VALUE *(";" set-cookie-av)   NAME            =       attr   VALUE           =       value   set-cookie-av   =       "Comment" "=" value                   |       "Discard"                   |       "Domain" "=" value                   |       "Max-Age" "=" value                   |       "Path" "=" value                   |       "Secure"                   |       "Version" "=" 1*DIGIT</body></comment><class><name>SetCookie2Value</name><environment>Net</environment><super>Net.SetCookieValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.SetCookie2Value</class-id><body>SetCookie2Value represents value of 'Set-Cookie2' header field.The syntax for the Set-Cookie2 response   header is   set-cookie      =       "Set-Cookie2:" cookies   cookies         =       1#cookie   cookie          =       NAME "=" VALUE *(";" set-cookie-av)   NAME            =       attr   VALUE           =       value   set-cookie-av   =       "Comment" "=" value                   |       "CommentURL" "=" &lt;"&gt; http_URL &lt;"&gt;                   |       "Discard"                   |       "Domain" "=" value                   |       "Max-Age" "=" value                   |       "Path" "=" value                   |       "Port" [ "=" &lt;"&gt; portlist &lt;"&gt; ]                   |       "Secure"                   |       "Version" "=" 1*DIGIT   portlist        =       1#portnum   portnum         =       1*DIGIT</body></comment><class><name>HttpRedirectionError</name><environment>Net</environment><super>Net.HttpException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpRedirectionError</class-id><body>This class reports redirection errors which are reported by the HTTP server being accessed.3xx: Redirection - Further action must be taken in order to        complete the requestInstance Variables:</body></comment><class><name>HttpMovedError</name><environment>Net</environment><super>Net.HttpRedirectionError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpMovedError</class-id><body>This class reports 301/302 errors which are reported by the HTTP server being accessed."301"   ; Moved Permanently"302"   ; Moved TemporarilyInstance Variables:</body></comment><class><name>HttpParser</name><environment>Net</environment><super>Net.MessageParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpParser</class-id><body>This class is parser for HTTP messages. It's knows how to parse chunked HTTP message bodies and the first line of the message.Instance Variables:</body></comment><class><name>AcceptLanguageField</name><environment>Net</environment><super>Net.AcceptHeaderFields</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.AcceptLanguageField</class-id><body>AcceptLanguageField represents Accept-Language header field as it described in RFC2616. The Accept-Language request-header field is similar to Accept, but restricts the set of natural languages that are preferred as a response to the request. </body></comment><class><name>HttpEntityLengthError</name><environment>Net</environment><super>Net.HttpException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpEntityLengthError</class-id><body>This exception is raised when the "Contents-Length' field value is different than the actual size of message-bodyInstance Variables:</body></comment><class><name>HttpClientError</name><environment>Net</environment><super>Net.HttpException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpClientError</class-id><body>This class reports http client errors which are reported by the HTTP server being accessed.4xx: Client Error - The request contains bad syntax or cannot be        fulfilledInstance Variables:</body></comment><class><name>HttpUnauthorizedError</name><environment>Net</environment><super>Net.HttpClientError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpUnauthorizedError</class-id><body>This class reports 401 error which are reported by the HTTP server being accessed."401"   ; UnauthorizedInstance Variables:</body></comment><class><name>HttpObjectNotFound</name><environment>Net</environment><super>Net.HttpClientError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpObjectNotFound</class-id><body>HttpObjectNotFound reports 404 errors. The server has not found anything matching the Request-URI. No indication is given of whether the condition is temporary or permanent.</body></comment><class><name>HttpBadRequest</name><environment>Net</environment><super>Net.HttpClientError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpBadRequest</class-id><body>HttpBadRequest reports 400 Http errors. The request could not be understood by the server due to malformed syntax. The client SHOULD NOT repeat the request without modifications</body></comment><class><name>HttpProxyAuthenticationError</name><environment>Net</environment><super>Net.HttpClientError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpProxyAuthenticationError</class-id><body>This class reports 407 error which are reported by the HTTP server being accessed."407"   ; Proxy Authentication RequiredInstance Variables:</body></comment><class><name>HttpRequest</name><environment>Net</environment><super>Net.HttpEntity</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestLine </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpRequest</class-id><body>Represent Http request message from client to a server. A request message from a client to a server includes, within the first line of that message, the method to be applied to the resource,  the identifier of the resource, and the protocol version in use. The rest of the message is standard MIME entity.  The methods in low-level command interface protocol allow to execute the request and get a response.Instance Variables:	requestLine	&lt;HttpRequstLine&gt;	an instance of HttpRequestLineSample:	req := HttpRequest post: 'http://uddi.microsoft.com/inquire'.	req contents: '&lt;head&gt;&lt;title&gt;localhost - /testHttpServer/&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;H1&gt;'.	resp := req execute.</body></comment><shared-variable><name>HttpURLClass</name><environment>Net.HttpRequest</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>Preferences</name><environment>Net.HttpException</environment><private>false</private><constant>false</constant><category>preferences</category><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>Registry</name><environment>Net.CookieAgent</environment><private>false</private><constant>false</constant><category>registry</category><initializer></initializer><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>UseCachedCookies</name><environment>Net.CookieAgent</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>CacheCookies</name><environment>Net.CookieAgent</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>EnableLimits</name><environment>Net.CookieAgent</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>NumberEntriesPerServer</name><environment>Net.CookieAgent</environment><private>false</private><constant>false</constant><category>registry</category><initializer></initializer><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>NumberBytesPerCookie</name><environment>Net.CookieAgent</environment><private>false</private><constant>false</constant><category>registry</category><initializer></initializer><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>ServersCacheCookiesFrom</name><environment>Net.CookieAgent</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>NumberEntries</name><environment>Net.CookieAgent</environment><private>false</private><constant>false</constant><category>registry</category><initializer></initializer><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>DefaultVersion</name><environment>Net.CookieFields</environment><private>false</private><constant>false</constant><category>style</category><initializer>nil</initializer><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>DecodeContents</name><environment>Net.HttpBuildHandler</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>DecompressContents</name><environment>Net.HttpBuildHandler</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>CookieStyle</name><environment>Net.CookieValueWithParams</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>ProxyPort</name><environment>Net.HttpClient</environment><private>false</private><constant>false</constant><category>Proxies</category><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>EnableCookieProcessing</name><environment>Net.HttpClient</environment><private>false</private><constant>false</constant><category>Cookie support</category><initializer></initializer><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>Protocol</name><environment>Net.HttpClient</environment><private>false</private><constant>false</constant><category>protocol</category><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>ProxyHost</name><environment>Net.HttpClient</environment><private>false</private><constant>false</constant><category>Proxies</category><attributes><package>HTTP</package></attributes></shared-variable><methods><class-id>Net.CookieAgent</class-id> <category>utilities</category><body package="HTTP" selector="cookiesAt:">cookiesAt: anUrl	^self registry 			at: (self keyFrom: anUrl)			ifAbsentPut: [ OrderedCollection new ].</body><body package="HTTP" selector="setCookieFieldForRequest:">setCookieFieldForRequest: aHttpRequest	| f |	(f := self cookieFieldForUrl: aHttpRequest url ) notNil		ifTrue:  [aHttpRequest cookie: f ].	^f</body></methods><methods><class-id>Net.CookieAgent</class-id> <category>testing limits</category><body package="HTTP" selector="exceedNumberBytesPerCookie:">exceedNumberBytesPerCookie: aSetCookieValue	aSetCookieValue printString size &gt; self class numberBytesPerCookie		ifTrue: 			[ RegistryLimitationExc raiseRequestFrom: (#exceedNumberBytesPerCookie &lt;&lt; #net &gt;&gt; 'Exceed number bytes per cookie &lt;1s&gt;' expandMacrosWith: aSetCookieValue printString)  ].	^false</body><body package="HTTP" selector="exceedNumberEntries">exceedNumberEntries	self exceedNumberEntries: self registry</body><body package="HTTP" selector="exceedNumberEntries:">exceedNumberEntries: aRegistry	| size |	size := 0.	aRegistry values do: [ :vx | size := size + vx size ].	size &gt; self class numberEntries		ifTrue: 			[ RegistryLimitationExc raiseRequestFrom: (#exceedNumberEntries &lt;&lt; #net &gt;&gt; 'Exceed  total cookie number') ].	^false</body><body package="HTTP" selector="exceedNumberEntriesPerServer:">exceedNumberEntriesPerServer: aString	self exceedNumberEntriesPerServer: aString registry: self registry</body><body package="HTTP" selector="exceedNumberEntriesPerServer:registry:">exceedNumberEntriesPerServer: aString registry: aRegistry	| coll |	coll := aRegistry at: aString ifAbsent: [ ^false ].	coll size &gt; self class numberEntriesPerServer		ifTrue: 			[ RegistryLimitationExc raiseRequestFrom: (#exceedNumberEntriesPerServer &lt;&lt; #net &gt;&gt; 'Exceed number entries per server &lt;1s&gt;' expandMacrosWith: aString)  ].	^false</body><body package="HTTP" selector="shouldUpdateServer:">shouldUpdateServer: aString	^(self class serversCacheCookiesFrom isEmpty		or: [ self class serversCacheCookiesFrom notEmpty 			and: [ self class serversCacheCookiesFrom includes: aString ]]).</body><body package="HTTP" selector="testCookieBytesLimit:">testCookieBytesLimit: aSetCookieValue	self enableLimits		ifTrue: [ self exceedNumberBytesPerCookie: aSetCookieValue]</body><body package="HTTP" selector="testRegistryAndServerLimits:">testRegistryAndServerLimits: aString	self enableLimits		ifTrue: 			[ self exceedNumberEntriesPerServer: aString.			self exceedNumberEntries ].</body></methods><methods><class-id>Net.CookieAgent</class-id> <category>managing cookies</category><body package="HTTP" selector="getValidCookieValuesFrom:requestUrl:">getValidCookieValuesFrom: aCookieCollection requestUrl: anUrl	| coll |	coll := OrderedCollection new.	aCookieCollection do: 		[ :cx | 		cx value 			do: [ :vx | 				(self rejectCookieValue: vx requestUrl: anUrl) 					ifFalse: 						[self testCookieBytesLimit: vx.						coll add: vx]]].	^coll</body><body package="HTTP" selector="registryAdd:forUrl:">registryAdd: aCollection forUrl: anUrl	| setCookiesColl cookie k |	aCollection isEmpty ifTrue: [^nil].	setCookiesColl := self  registry 						at: (k := self keyFrom: anUrl)						ifAbsentPut: [ OrderedCollection new ].	aCollection 		do: [ :newCookie |			(cookie := setCookiesColl detect: [ :cx | cx = newCookie ] ifNone: [ nil]) notNil				ifTrue: [ setCookiesColl remove: cookie]].	setCookiesColl addAll: aCollection.	self testRegistryAndServerLimits: k.	^setCookiesColl</body><body package="HTTP" selector="rejectCookieValue:requestUrl:">rejectCookieValue: aSetCookieValue requestUrl: anUrl	aSetCookieValue isExpired ifTrue: [^true].	^(self validateDomain: aSetCookieValue domain host: anUrl host) not		or: [ (self validatePathFrom: aSetCookieValue path  path: anUrl pathString ) not			or: [(self validatePort: aSetCookieValue port port: anUrl port ) not ]]</body><body package="HTTP" selector="validateDomain:host:">validateDomain: aCookieDomain host: aHostString	| reqHost cookieDomain ind |	reqHost := aHostString asLowercase.	aCookieDomain notNil		ifTrue: 			[cookieDomain := aCookieDomain asLowercase.			(cookieDomain at: 1) ~= $. ifTrue: [ cookieDomain := '.', cookieDomain].			"The request-host has the form HD, where D is value of the domain attribute"			(( '*', cookieDomain) match: reqHost) ifFalse: [ ^false ].			ind := reqHost indexOfSubCollection:  cookieDomain startingAt: 1.			"The request-host contains embedded dots or  the domain attribute contains no embedded dots"			(((reqHost copyFrom: 1 to: ind - 1 ) includes: $.) 				or: [ ('.*.*' match: cookieDomain) not					and: [ ('.local' match: cookieDomain) not ]])				ifTrue: [^false].			].	^true.</body><body package="HTTP" selector="validatePathFrom:path:">validatePathFrom: aCookiePath path: requestPath	aCookiePath notNil		ifTrue: 			["the value for the path attribute has to be a prefix of the request url "			(( aCookiePath, '*' ) match: requestPath )				ifFalse: [ ^false ]].	^true</body><body package="HTTP" selector="validatePort:port:">validatePort: aCookiePort port: portNumber	"the request-port is not in the port attribute"	^(aCookiePort isNil or: [aCookiePort isKindOf: Boolean])		or: [	aCookiePort notNil			and: [ (aCookiePort isKindOf: Collection)				and: [(aCookiePort includes: portNumber) ]]]</body></methods><methods><class-id>Net.CookieAgent</class-id> <category>converting</category><body package="HTTP" selector="accept:for:key:">accept: anUrl for: aSetCookieValue key: keyUrl	^(aSetCookieValue isNotExpired		and: [ (self cookieDomain: aSetCookieValue domain accept: anUrl host)			and: [(self cookiePath: aSetCookieValue path accept: anUrl pathString)				and: [self cookiePort: aSetCookieValue port accept: anUrl port from: keyUrl ]]])</body><body package="HTTP" selector="cookieDomain:accept:">cookieDomain: aSetCookieDomain accept: aString	^aSetCookieDomain isNil		or: [ aSetCookieDomain notNil 				and: ['*', aSetCookieDomain asLowercase match: aString asLowercase]]</body><body package="HTTP" selector="cookieFieldForUrl:">cookieFieldForUrl: anUrl	"Creates 'Cookie' field for the specified url from registered 'Set-Cookie' or 'Set-Cookie2' fields "	| coll sc xInd yInd f |	coll := OrderedCollection new.	self registry		keysAndValuesDo:			[ :key :value | 			value 				do: [ :vx |				(self accept: anUrl for: vx key: key) ifTrue: [coll add: vx ]]].	coll isEmpty ifTrue: [ ^nil ].	sc := SortedCollection 			withAll: coll			sortBlock: [ :x : y |						xInd := x path notNil							ifTrue: [x path occurrencesOf: $/ ]							ifFalse: [0].						yInd := y path notNil							ifTrue: [y path occurrencesOf: $/ ]							ifFalse: [0].						xInd &gt;= yInd ].	f := sc first isRFCStyle		ifTrue: [CookieField newRfc ]		ifFalse: [ CookieField newNetscape ].	f value: (sc collect: [ :cx | cx asCookie ]).	^f</body><body package="HTTP" selector="cookiePath:accept:">cookiePath: aCookiePath accept: requestPath	^aCookiePath isNil 		or: [aCookiePath notNil 				and: [( aCookiePath, '*' ) match: requestPath ]]</body><body package="HTTP" selector="cookiePort:accept:from:">cookiePort: aSetCookiePort accept: aNumber from: hostPort	aSetCookiePort isNil ifTrue: [^true].	^(aSetCookiePort isKindOf: Boolean)		ifTrue: [(hostPort tokensBasedOn: $: ) last asNumber = aNumber]		ifFalse: 			[aSetCookiePort isEmpty 				ifTrue: [ true ]				ifFalse: [aSetCookiePort includes: aNumber ]]</body></methods><methods><class-id>Net.CookieAgent</class-id> <category>accessing</category><body package="HTTP" selector="cacheCookies">cacheCookies	^cacheCookies isNil		ifTrue: [cacheCookies := self class cacheCookies]		ifFalse: [ cacheCookies ]</body><body package="HTTP" selector="cacheCookies:">cacheCookies: aBoolean	cacheCookies := aBoolean</body><body package="HTTP" selector="classRegistry">classRegistry	^self class registry</body><body package="HTTP" selector="classRegistryAt:put:">classRegistryAt: aServerString put: aCollection	self classRegistry at: aServerString put: aCollection.	self enableLimits		ifTrue: 			[ self exceedNumberEntriesPerServer: aServerString registry: self classRegistry.			self exceedNumberEntries: self classRegistry ].</body><body package="HTTP" selector="enableLimits">enableLimits	^enableLimits isNil		ifTrue: [ enableLimits := self class enableLimits]		ifFalse: [ enableLimits ]</body><body package="HTTP" selector="enableLimits:">enableLimits: aBoolean	enableLimits := aBoolean</body><body package="HTTP" selector="keyFrom:">keyFrom: anUrl	^self class keyFrom: anUrl</body><body package="HTTP" selector="registry">registry	^registry</body><body package="HTTP" selector="useCachedCookies">useCachedCookies	^useCachedCookies isNil		ifTrue: [ useCachedCookies := self class useCachedCookies]		ifFalse: [ useCachedCookies ]</body><body package="HTTP" selector="useCachedCookies:">useCachedCookies: anObject	useCachedCookies := anObject</body></methods><methods><class-id>Net.CookieAgent</class-id> <category>initialize-release</category><body package="HTTP" selector="addCookiesFrom:requestUrl:">addCookiesFrom: aHttpResponse requestUrl: anUrl	self setCacheCookieFrom: aHttpResponse.	^self 		registryAdd: (self getValidCookieValuesFrom: aHttpResponse setCookieFields requestUrl: anUrl) 		forUrl: anUrl.</body><body package="HTTP" selector="initialize">initialize	registry := Dictionary  new.	self start.</body><body package="HTTP" selector="start">start	"Starts cookie session"	| vColl |	self class useCachedCookies		ifTrue: 			[ self classRegistry keysAndValuesDo:				[ :key :values | 				vColl := values select: [ :vx | vx isNotExpired ].				self registry at: key put: vColl copy ]].</body><body package="HTTP" selector="terminate">terminate	"Terminates cookie session. Saves session cookies to the class registry"	| coll vColl newColl |	self cacheCookies		ifTrue:			[ self registry keysAndValuesDo:				[ :key :values | 				(self shouldUpdateServer: key)					ifTrue: 						[vColl := values select: [ :vx | vx shouldNotBeDiscard and: [ vx isNotExpired ] ].						(coll := self classRegistry at: key ifAbsent: [ nil ]) isNil							ifTrue: [ self classRegistryAt: key put: vColl ]							ifFalse: 								[ newColl := OrderedCollection new: ( coll size + vColl size).								coll do: [ :vclass |  vColl detect: [ :vx | vx = vclass ] ifNone: [ newColl add: vclass]].								newColl addAll: vColl.								self classRegistryAt: key put: newColl ]]]].</body></methods><methods><class-id>Net.CookieAgent</class-id> <category>caching</category><body package="HTTP" selector="setCacheCookieFrom:">setCacheCookieFrom: aHttpResponse	| noCache |	aHttpResponse cacheControl notNil		ifTrue: 			[noCache := aHttpResponse cacheControl noCache.			(noCache isKindOf: Boolean) ifTrue: [ ^nil ].			('set-cookie2' match: noCache first )				ifTrue: [ self cacheCookies: false ]].</body></methods><methods><class-id>Net.CookieAgent class</class-id> <category>accessing</category><body package="HTTP" selector="cookiesAt:">cookiesAt: anUrl	^self registry 			at: (self keyFrom: anUrl)			ifAbsentPut: [ OrderedCollection new ].</body><body package="HTTP" selector="keyFrom:">keyFrom: anUrl	^anUrl host, ':', anUrl port printString</body><body package="HTTP" selector="registry">registry	^Registry isNil		ifTrue: [ self resetRegistry ]		ifFalse: [ Registry ]</body><body package="HTTP" selector="resetRegistry">resetRegistry	Registry := Dictionary new</body></methods><methods><class-id>Net.CookieAgent class</class-id> <category>persistence</category><body package="HTTP" selector="restoreRegistryFrom:">restoreRegistryFrom: aDataSource	| xml |	xml := (XML.XMLParser on:  aDataSource)				validate: false;				scanDocument.	Registry := (Dictionary restoreValueFrom: xml root)</body><body package="HTTP" selector="storeRegistryTo:">storeRegistryTo: aStream	aStream nextPutAll: '&lt;?xml version="1.0"?&gt;'.	(self registry asXmlNode: 'CookieRegistry' ) printOn: aStream.</body></methods><methods><class-id>Net.CookieAgent class</class-id> <category>instance creation</category><body package="HTTP" selector="addCookiesFrom:requestUrl:">addCookiesFrom: aHttpEntity requestUrl: anUrl	^self new		addCookiesFrom: aHttpEntity requestUrl: anUrl;		yourself</body><body package="HTTP" selector="new">new	^super new initialize</body></methods><methods><class-id>Net.CookieAgent class</class-id> <category>defaults</category><body package="HTTP" selector="defaultCacheCookies">defaultCacheCookies	^false</body><body package="HTTP" selector="defaultEnableLimits">defaultEnableLimits	^false</body><body package="HTTP" selector="defaultNumberBytesPerCookie">defaultNumberBytesPerCookie	^4096</body><body package="HTTP" selector="defaultNumberEntries">defaultNumberEntries	^300</body><body package="HTTP" selector="defaultNumberEntriesPerServer">defaultNumberEntriesPerServer	^20</body><body package="HTTP" selector="defaultServersCacheCookiesFrom">defaultServersCacheCookiesFrom	^OrderedCollection new</body><body package="HTTP" selector="defaultUseCachedCookies">defaultUseCachedCookies	^false</body></methods><methods><class-id>Net.CookieAgent class</class-id> <category>accessing settings</category><body package="HTTP" selector="cacheCookies">cacheCookies	^CacheCookies isNil		ifTrue: [self defaultCacheCookies]		ifFalse: [CacheCookies]</body><body package="HTTP" selector="cacheCookies:">cacheCookies: aBoolean	CacheCookies := aBoolean</body><body package="HTTP" selector="enableLimits">enableLimits	^EnableLimits isNil		ifTrue: [self defaultEnableLimits]		ifFalse: [EnableLimits]</body><body package="HTTP" selector="enableLimits:">enableLimits: aBoolean	EnableLimits := aBoolean</body><body package="HTTP" selector="numberBytesPerCookie">numberBytesPerCookie	^NumberBytesPerCookie isNil		ifTrue: [NumberBytesPerCookie := self defaultNumberBytesPerCookie ]		ifFalse: [NumberBytesPerCookie]</body><body package="HTTP" selector="numberBytesPerCookie:">numberBytesPerCookie: aNumber	NumberBytesPerCookie := aNumber</body><body package="HTTP" selector="numberEntries">numberEntries	^NumberEntries isNil		ifTrue: [NumberEntries := self defaultNumberEntries]		ifFalse: [NumberEntries]</body><body package="HTTP" selector="numberEntries:">numberEntries: aNumber	NumberEntries := aNumber</body><body package="HTTP" selector="numberEntriesPerServer">numberEntriesPerServer	^NumberEntriesPerServer isNil		ifTrue: [NumberEntriesPerServer := self defaultNumberEntriesPerServer]		ifFalse: [NumberEntriesPerServer]</body><body package="HTTP" selector="numberEntriesPerServer:">numberEntriesPerServer: aNumber	NumberEntriesPerServer := aNumber</body><body package="HTTP" selector="serversCacheCookiesFrom">serversCacheCookiesFrom	^ServersCacheCookiesFrom isNil		ifTrue: [ServersCacheCookiesFrom := self defaultServersCacheCookiesFrom]		ifFalse: [ServersCacheCookiesFrom]</body><body package="HTTP" selector="serversCacheCookiesFrom:">serversCacheCookiesFrom: aCollection	ServersCacheCookiesFrom := aCollection</body><body package="HTTP" selector="useCachedCookies">useCachedCookies	^UseCachedCookies isNil		ifTrue: [self defaultUseCachedCookies]		ifFalse: [UseCachedCookies]</body><body package="HTTP" selector="useCachedCookies:">useCachedCookies: aBoolean	UseCachedCookies := aBoolean</body></methods><methods><class-id>Net.HttpDispatcher</class-id> <category>visiting -- double dispatching</category><body package="HTTP" selector="acceptHttpEntity:with:">acceptHttpEntity: aHttpEntity  with: argument	[(self action: #startHttpEntity: with: aHttpEntity) 		ifTrue: 			[self visit: aHttpEntity messageLine. 			self visit: aHttpEntity header.				self action: #startHttpBody:  with: aHttpEntity.				self visit: aHttpEntity body.]		] ensure: 			[self action: #endHttpEntity: with: aHttpEntity].	^aHttpEntity</body><body package="HTTP" selector="acceptRequestLine:with:">acceptRequestLine: aRequestLine with: argument	self action: #startRequestLine: with: aRequestLine.	^aRequestLine</body><body package="HTTP" selector="acceptResponseStatusLine:with:">acceptResponseStatusLine: aResponseStatusLine with: argument	self action: #startResponseStatusLine: with: aResponseStatusLine.	^aResponseStatusLine</body></methods><methods><class-id>Net.CacheControl</class-id> <category>accessing</category><body package="HTTP" selector="addMustRevalidate">addMustRevalidate"must-revalidate"	self addDirective:  'must-revalidate'-&gt;nil</body><body package="HTTP" selector="addNoCache">addNoCache" 'no-cache' [ '= &lt;''&gt; 1#field-name &lt;''&gt; ] "	self addDirective: 'no-cache'-&gt;nil</body><body package="HTTP" selector="addNoStore">addNoStore"no-store"	self addDirective: 'no-store'-&gt;nil</body><body package="HTTP" selector="addNoTransform">addNoTransform"no-transform"	self addDirective:  'no-transform'-&gt;nil</body><body package="HTTP" selector="addOnlyIfCached">addOnlyIfCached"only-if-cached "	self addDirective: 'only-if-cached'-&gt;nil</body><body package="HTTP" selector="addPrivate">addPrivate"private [ ''='' &lt;''&gt; 1#field-name &lt;''&gt; ]"	self addDirective: 'private'-&gt;nil</body><body package="HTTP" selector="addProxyRevalidate">addProxyRevalidate"proxy-revalidate"	self addDirective: 'proxy-revalidate'-&gt;nil</body><body package="HTTP" selector="addPublic">addPublic"public "	self addDirective: 'public'-&gt;nil</body><body package="HTTP" selector="maxAge">maxAge"'max-age' ''='' delta-seconds "	^self detectValueFor: 'max-age'</body><body package="HTTP" selector="maxAge:">maxAge: aNumber"'max-age' ''='' delta-seconds "	self addDirective: 'max-age'-&gt;aNumber</body><body package="HTTP" selector="maxStale">maxStale"'max-stale' ''='' delta-seconds "	^self detectValueFor: 'max-stale'</body><body package="HTTP" selector="maxStale:">maxStale: aNumber"'max-stale' ''='' delta-seconds "	self addDirective:  'max-stale'-&gt;aNumber</body><body package="HTTP" selector="minFresh">minFresh"'min-fresh' ''='' delta-seconds "	^self detectValueFor: 'min-fresh'</body><body package="HTTP" selector="minFresh:">minFresh: aNumber"'min-fresh' ''='' delta-seconds "	self addDirective: 'min-fresh'-&gt;aNumber</body><body package="HTTP" selector="mustRevalidate">mustRevalidate"must-revalidate"	^self anySatisfy: 'must-revalidate'</body><body package="HTTP" selector="noCache">noCache" 'no-cache' [ '= &lt;''&gt; 1#field-name &lt;''&gt; ] "	^self detectValueFor: 'no-cache'</body><body package="HTTP" selector="noCache:">noCache: aCollOfStringsOrNil" 'no-cache' [ '= &lt;''&gt; 1#field-name &lt;''&gt; ] "	self addDirective: 'no-cache'-&gt;aCollOfStringsOrNil</body><body package="HTTP" selector="noStore">noStore"no-store"	^self anySatisfy: 'no-store'</body><body package="HTTP" selector="noTransform">noTransform"no-transform"	^self anySatisfy:  'no-transform'</body><body package="HTTP" selector="onlyIfCached">onlyIfCached"only-if-cached "	^self anySatisfy:  'only-if-cached'</body><body package="HTTP" selector="private">private"private [ ''='' &lt;''&gt; 1#field-name &lt;''&gt; ]"	^self detectValueFor: 'private'</body><body package="HTTP" selector="private:">private: aCollOfStringsOrNil"private [ ''='' &lt;''&gt; 1#field-name &lt;''&gt; ]"	self addDirective: 'private'-&gt;aCollOfStringsOrNil</body><body package="HTTP" selector="proxyRevalidate">proxyRevalidate"proxy-revalidate"	^self anySatisfy: 'proxy-revalidate'</body><body package="HTTP" selector="public">public"public "	^self anySatisfy: 'public'</body><body package="HTTP" selector="values">values	^value isNil		ifTrue: [ value := OrderedCollection new]		ifFalse: [ value ]</body></methods><methods><class-id>Net.CacheControl</class-id> <category>private</category><body package="HTTP" selector="anySatisfy:">anySatisfy: aString	^self values anySatisfy: [ :val | val key asLowercase = aString ]</body><body package="HTTP" selector="detectValueFor:">detectValueFor: aString 	| v |	^(v := self value detect: [ :val | val key asLowercase = aString ] ifNone: [nil]) notNil		ifTrue: 			[ v value notNil				ifTrue: [ v value]				ifFalse: [true]]		ifFalse: [false]</body></methods><methods><class-id>Net.CacheControl</class-id> <category>printing</category><body package="HTTP" selector="printParameters:on:">printParameters: anObject on: aStream 		aStream nextPut: $=.	(anObject isKindOf: OrderedCollection)		ifTrue:			[aStream nextPut: $".			anObject 				do: [ :param |  aStream nextPutAll: param]				separatedBy: [aStream nextPut: $, ].			aStream nextPut: $"  ]		ifFalse: 			[anObject respondsToArithmetic 				ifTrue: [anObject printOn: aStream]				ifFalse: [ aStream nextPutAll: anObject]]</body><body package="HTTP" selector="printValueOn:">printValueOn: aStream 		self values		do: 	[ :val |			aStream nextPutAll: val key.			val value notNil				ifTrue:					[self printParameters: val value on: aStream]]		separatedBy: [aStream nextPut: self separator].	aStream cr.</body></methods><methods><class-id>Net.CacheControl</class-id> <category>parsing</category><body package="HTTP" selector="parseItem:">parseItem: aString	| scanner token |	scanner := self scannerOn: aString readStream. 	token := scanner nextToken.	^(scanner hereChar == $= )		ifTrue: [token -&gt;(self parseParameters: scanner key: token asLowercase)]		ifFalse: [token-&gt;nil]</body><body package="HTTP" selector="parseParameters:key:">parseParameters: scanner key: aString	| paramColl newScanner t |	paramColl := OrderedCollection new.	scanner next.	scanner nextToken. 	^scanner tokenType == #quotedText 			ifTrue: 			[newScanner := scanner 							newSize: scanner token size 							startingAt: (scanner position - scanner token size - 1).			newScanner tokenizeList: [ t := newScanner nextToken. paramColl add: t]						separatedBy: [ newScanner token == self separator ].			scanner next.			paramColl]		ifFalse: 			[(scanner tokenType == #token and: [ self isDeltaSeconds: aString])				ifTrue: [ scanner token asNumber]				ifFalse: [scanner token]]</body></methods><methods><class-id>Net.CacheControl</class-id> <category>directives</category><body package="HTTP" selector="addDirective:">addDirective: anAssocOrString	| val |	val := (anAssocOrString isKindOf: Association)		ifTrue: [ anAssocOrString]		ifFalse: 	[anAssocOrString-&gt;nil].	self removeDirective: val key.	self values add: val</body><body package="HTTP" selector="directiveAt:">directiveAt: aString	^self detectValueFor: aString</body><body package="HTTP" selector="removeDirective:">removeDirective: aString	self values removeAllSuchThat: [ :v | v key = aString ].</body></methods><methods><class-id>Net.CacheControl</class-id> <category>testing</category><body package="HTTP" selector="isDeltaSeconds:">isDeltaSeconds: aString	^#( 'max-age' 'max-stale' 'min-fresh' ) includes: aString</body></methods><methods><class-id>Net.CacheControl class</class-id> <category>parsing</category><body package="HTTP" selector="fieldNames">fieldNames	^#('cache-control')</body></methods><methods><class-id>Net.HttpProxyExceptions</class-id> <category>aspects</category><body package="HTTP" selector="domainCollectionAsString">domainCollectionAsString	| aStream col |	col :=  parent proxyExceptions.	^col isEmpty		ifTrue: [String new]		ifFalse: 			[aStream := (String new: 64) writeStream.			col				do: [:element | aStream nextPutAll: element]				separatedBy: [aStream nextPut: $;].			aStream contents]</body><body package="HTTP" selector="httpProxyExceptions">httpProxyExceptions	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^httpProxyExceptions isNil		ifTrue:			[httpProxyExceptions := self domainCollectionAsString asValue]		ifFalse:			[httpProxyExceptions]</body><body package="HTTP" selector="parent:">parent: aHttpPage	parent := aHttpPage</body></methods><methods><class-id>Net.HttpProxyExceptions</class-id> <category>actions</category><body package="HTTP" selector="acceptHttpExceptions">acceptHttpExceptions	| proxyExceptions sc token |	proxyExceptions := OrderedCollection new: 10. 	sc := self httpProxyExceptions value string readStream.	[ sc atEnd ]		whileFalse: 			[token := sc upTo: $;. 			token notEmpty ifTrue: [ proxyExceptions add: token trimBlanks]].	parent acceptProxyExceptions: proxyExceptions.	self cancelHttpException.</body><body package="HTTP" selector="cancelHttpException">cancelHttpException	^self closeRequest</body></methods><methods><class-id>Net.AcceptHeaderFields</class-id> <category>accessing</category><body package="HTTP" selector="qValueAt:">qValueAt: index	^(self value at: index) paramAt: 'q'</body></methods><methods><class-id>Net.AcceptHeaderFields</class-id> <category>adding  range</category><body package="HTTP" selector="addValue:qValue:">addValue: vString qValue: qString	| valWithParams |	valWithParams := ValueWithParams newWithSeparators: self separators.	valWithParams value: vString.	qString notNil ifTrue: [ valWithParams paramAt: 'q' put: qString].	self value add: valWithParams.	^valWithParams</body></methods><methods><class-id>Net.AcceptHeaderFields class</class-id> <category>defaults</category><body package="HTTP" selector="defaultSeparators">defaultSeparators	^#($; $; $,  )</body></methods><methods><class-id>Net.HttpException</class-id> <category>printing</category><body package="HTTP" selector="defaultMessageText">defaultMessageText	^super defaultMessageText, '\(' withCRs, parameter printStatusLineMessage, ')'</body></methods><methods><class-id>Net.HttpException class</class-id> <category>handling http responses</category><body package="HTTP" selector="handleResponse:">handleResponse: resp	"trigger exceptions for all responses but 2xx (success) "	| exp |	resp isSuccess 		ifFalse: 			[ exp := (self preferences detect: [ :ea | ea key match: resp code ]) value.			exp signalWith: resp].	^resp</body><body package="HTTP" selector="initializePreferences">initializePreferences	"self initializePreferences "	Preferences := (OrderedCollection new: 13)		add: '400' -&gt; HttpBadRequest;		add: '401' -&gt; HttpUnauthorizedError;		add: '404' -&gt; HttpObjectNotFound;		add: '407' -&gt; HttpProxyAuthenticationError;		add: '301' -&gt;  HttpMovedError;		add: '302' -&gt;  HttpMovedError;		add: '510' -&gt; HttpNotExtendedError;		add: '1*' -&gt; HttpInformationalError;		add: '3*' -&gt;  HttpRedirectionError;		add: '4*' -&gt; HttpClientError;		add: '5*' -&gt; HttpServerError;		add: '*' -&gt; HttpException;		yourself.</body><body package="HTTP" selector="preferences">preferences	Preferences isNil ifTrue: [ self initializePreferences].	^Preferences</body></methods><methods><class-id>Net.HttpException class</class-id> <category>testing</category><body package="HTTP" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Net.HttpEntityError</class-id> <category>printing</category><body package="HTTP" selector="description">description	^self messageText</body></methods><methods><class-id>Net.AcceptCharsetField</class-id> <category>adding charset</category><body package="HTTP" selector="addCharset:">addCharset: cString	self addCharset: cString qValue: nil</body><body package="HTTP" selector="addCharset:qValue:">addCharset: cString qValue: qString 	self addValue: cString qValue: qString.</body></methods><methods><class-id>Net.AcceptCharsetField</class-id> <category>accessing</category><body package="HTTP" selector="charsetAt:">charsetAt: index	^self value at: index</body><body package="HTTP" selector="charsetTypeAt:">charsetTypeAt: index	^(self charsetAt: index) value</body></methods><methods><class-id>Net.AcceptCharsetField class</class-id> <category>parsing</category><body package="HTTP" selector="fieldNames">fieldNames	^#('accept-charset')</body></methods><methods><class-id>Net.AcceptCharsetField class</class-id> <category>instant creation</category><body package="HTTP" selector="charset:">charset: cString	^self charset: cString qValue: nil</body><body package="HTTP" selector="charset:qValue:">charset: cString qValue: qString	^(self name: 'accept-charset') 		addCharset: cString qValue: qString;		yourself</body></methods><methods><class-id>Net.HttpTimeout</class-id> <category>private</category><body package="HTTP" selector="defaultMessageText">defaultMessageText	^(#TimeoutConnectionNotResponding &lt;&lt; #net &gt;&gt; 'Timeout   Connection is not responding') asString</body></methods><methods><class-id>Net.AuthenticateChallengeField</class-id> <category>accessing</category><body package="HTTP" selector="realm">realm	^self element paramAt: 'realm'</body><body package="HTTP" selector="scheme">scheme	^self element value</body></methods><methods><class-id>Net.AuthenticateChallengeField</class-id> <category>adding </category><body package="HTTP" selector="addBasic:">addBasic: vString	^self addBasic: vString realm: nil</body><body package="HTTP" selector="addBasic:realm:">addBasic: vString realm: rString	| valWithParams |	valWithParams := ValueWithParams newWithSeparators: self separators.	valWithParams value: vString.	rString notNil ifTrue: [ valWithParams paramAt: 'realm' put: rString].	self value add: valWithParams.	^valWithParams</body></methods><methods><class-id>Net.AuthenticateChallengeField class</class-id> <category>parsing</category><body package="HTTP" selector="fieldNames">fieldNames	^#('www-authenticate' 'proxy-authenticate')</body></methods><methods><class-id>Net.AuthenticateChallengeField class</class-id> <category>defaults</category><body package="HTTP" selector="defaultSeparators">defaultSeparators	^#($  $, $  )</body></methods><methods><class-id>Net.HttpBuildHandler</class-id> <category>defaults</category><body package="HTTP" selector="defaultRootEntityType">defaultRootEntityType	^HttpEntity</body><body package="HTTP" selector="dispatcherClass">dispatcherClass	^HttpParser</body></methods><methods><class-id>Net.HttpBuildHandler</class-id> <category>accessing</category><body package="HTTP" selector="headerOnly">headerOnly	^super headerOnly		ifTrue: [ true]		ifFalse: [self entity headerOnly]</body><body package="HTTP" selector="options">options	^options</body><body package="HTTP" selector="options:">options: aDictionary	options := aDictionary</body></methods><methods><class-id>Net.HttpBuildHandler</class-id> <category>action callbacks</category><body package="HTTP" selector="endBody:">endBody: aBody	((self entity isMemberOf: MimeEntity) not and: [self entity isChunked])		ifTrue: [self entity removeFieldAt: 'transfer-encoding']. 	self shouldBeDecompressed 		ifTrue: 			[aBody setByteSource:  aBody parent decompressBody readWriteStream.			aBody parent removeFieldAt: 'content-encoding'.].	aBody isSimple		ifTrue: [self removeTransferContextAndDecode: aBody].	^true</body><body package="HTTP" selector="openBodyStream:">openBodyStream: aMessageBody	aMessageBody isSimple 		ifTrue: [aMessageBody setByteSource:  (ReadWriteStream on: (ByteArray new: 1024)) ]</body><body package="HTTP" selector="startBody:">startBody: aMessageBody" Body has to be decoded using specific charset. So we first accumulate octets, thencreate encoded stream with proper charset encoding "	(self entity isMemberOf: MimeEntity) 		ifTrue: [self openBodyStream: aMessageBody.^true].	(self headerOnly or: [self entity contentLength = 0 ]) ifTrue: [^false]. 	(self entity contentLength isNil 		and: [ self entity  hasTransferEncoding not			and: [self entity isResponse not] ]) ifTrue: [ ^false].	self openBodyStream: aMessageBody.	^true</body><body package="HTTP" selector="startMessageLine:">startMessageLine: aLineObject	self entity isNil		ifTrue: [ self entity: aLineObject entityType new ].	self entity messageLine: aLineObject.	^true</body></methods><methods><class-id>Net.HttpBuildHandler</class-id> <category>private</category><body package="HTTP" selector="handleStartBodyException:">handleStartBodyException: exception	(HttpTimeout handles: exception)		ifTrue: 			[self endBody: self entity body.			exception parameter: self entity.			exception pass]		ifFalse: [ super handleStartBodyException: exception ]</body><body package="HTTP" selector="readStream:length:lineEndConvention:">readStream: aStream length: lengthOrNil lineEndConvention: lineEndConvention"Always read Http body in binary mode. Need to reset text for chunked format "" Decompress the stream contents if the option is on and the message header includes gzip "	| counter body |	body := self entity body.	counter := lengthOrNil. 	[(counter == nil or: [counter &gt; 0]) and: [aStream atEnd not]]		whileTrue: 			[body byteSource nextPut: aStream next asInteger.			counter notNil ifTrue: [counter := counter - 1]].</body><body package="HTTP" selector="removeTransferContextAndDecode:">removeTransferContextAndDecode: aBody 	"Decode body source using current charset "	| ce |	aBody byteSource reset.	aBody isBinary ifTrue: [^aBody byteSource].	(((ce := aBody parent contentEncoding) notNil 			and: [ce notEmpty]) 				or: [self decodeContents not])		ifFalse: 			[aBody source: 				(EncodedStream 						on: aBody byteSource						encodedBy: (StreamEncoder new: aBody parent charset) initializeForMemory)						lineEndCRLF.			aBody source reset.]</body></methods><methods><class-id>Net.HttpBuildHandler</class-id> <category>initialization</category><body package="HTTP" selector="initialize">initialize	super initialize.	options := Dictionary new.</body></methods><methods><class-id>Net.HttpBuildHandler</class-id> <category>options</category><body package="HTTP" selector="decodeContents">decodeContents	^self options at: #decodeContents ifAbsentPut: [ self class decodeContents ]</body><body package="HTTP" selector="decodeContents:">decodeContents: aBoolean	self options at: #decodeContents put: aBoolean</body><body package="HTTP" selector="decompressContents">decompressContents	^self options at: #decompressContents ifAbsentPut: [ self class decompressContents ]</body><body package="HTTP" selector="decompressContents:">decompressContents: aBoolean	self options at: #decompressContents put: aBoolean</body></methods><methods><class-id>Net.HttpBuildHandler</class-id> <category>testing</category><body package="HTTP" selector="shouldBeDecompressed">shouldBeDecompressed	| ce |	^(self decompressContents 		and: [(ce := self entity contentEncoding) notNil 				and: ['gzip' match: ce ]])</body></methods><methods><class-id>Net.HttpBuildHandler class</class-id> <category>defaults</category><body package="HTTP" selector="defaultDecodeContents">defaultDecodeContents	^true</body><body package="HTTP" selector="defaultDecompressContents">defaultDecompressContents	^true</body></methods><methods><class-id>Net.HttpBuildHandler class</class-id> <category>accessing settings</category><body package="HTTP" selector="decodeContents">decodeContents	^DecodeContents isNil		ifTrue: [DecodeContents := self defaultDecodeContents]		ifFalse: [DecodeContents]</body><body package="HTTP" selector="decodeContents:">decodeContents: aBoolean	DecodeContents := aBoolean</body><body package="HTTP" selector="decompressContents">decompressContents	^DecompressContents isNil		ifTrue: [DecompressContents := self defaultDecompressContents ]		ifFalse: [DecompressContents]</body><body package="HTTP" selector="decompressContents:">decompressContents: aBoolean	DecompressContents := aBoolean</body></methods><methods><class-id>Net.HttpClient</class-id> <category>accessing</category><body package="HTTP" selector="connection">connection	^connection</body><body package="HTTP" selector="entityParsingOptions">entityParsingOptions	^entityParsingOptions isNil		ifTrue: [ entityParsingOptions := Dictionary new]		ifFalse: [ entityParsingOptions ]</body><body package="HTTP" selector="entityParsingOptions:">entityParsingOptions: aDictionary	entityParsingOptions := aDictionary</body><body package="HTTP" selector="protocol">protocol	^protocol ifNil: 		[protocol := request notNil						ifTrue: [ request protocol ]						ifFalse: [self class protocol ]		]</body><body package="HTTP" selector="protocol:">protocol: aString	protocol := aString</body><body package="HTTP" selector="proxyExceptions">proxyExceptions	^self class proxyExceptions</body><body package="HTTP" selector="proxyHost">proxyHost	proxyHost isNil		ifTrue: [ proxyHost := self class proxyHost].	^proxyHost</body><body package="HTTP" selector="proxyHost:">proxyHost: aHostSpec	proxyHost := aHostSpec</body><body package="HTTP" selector="proxyHostName">proxyHostName	^self proxyHost notNil		ifTrue: [ self proxyHost  name]		ifFalse: [ nil ]</body><body package="HTTP" selector="proxyHostPort">proxyHostPort	^(self proxyHost isNil or: [self proxyHost port]) isNil		ifTrue: [ nil ]		ifFalse: [ self proxyHost port ]</body><body package="HTTP" selector="proxyPassword">proxyPassword		^self proxyUser notNil		ifTrue: [ self proxyUser password]		ifFalse: [nil]</body><body package="HTTP" selector="proxyUser">proxyUser	^self proxyHost notNil		ifTrue: [ self proxyHost netUser]		ifFalse: [nil]</body><body package="HTTP" selector="proxyUser:">proxyUser: aNetUser	self proxyHost isNil		ifTrue: [ proxyHost := HostSpec new].	self proxyHost netUser: aNetUser.</body><body package="HTTP" selector="proxyUsername">proxyUsername		^self proxyUser notNil		ifTrue: [ self proxyUser username]		ifFalse: [nil]</body><body package="HTTP" selector="redirectRequest">redirectRequest	^self class redirectRequest</body><body package="HTTP" selector="requestClass">requestClass	^HttpRequest</body><body package="HTTP" selector="useProxy">useProxy	^self class useProxy</body><body package="HTTP" selector="useProxyAuthorization">useProxyAuthorization	^useProxyAuthorization isNil 		ifTrue: [ useProxyAuthorization := false]		ifFalse: [ useProxyAuthorization]</body><body package="HTTP" selector="user">user	user isNil		ifTrue: [ user := NetUser new ].	^user</body><body package="HTTP" selector="username:password:">username: unString password: pString	self user 			username: unString;			password: pString.</body></methods><methods><class-id>Net.HttpClient</class-id> <category>private</category><body package="HTTP" selector="addAuthorizationToRequest">addAuthorizationToRequest	^(self username isNil and: [ self password isNil])  		ifTrue: [nil]		ifFalse: [request username: self username password: self password]</body><body package="HTTP" selector="addProxyAuthorizationToRequest">addProxyAuthorizationToRequest	^(self useProxyAuthorization and: [self proxyUser notNil]) 		ifTrue: 			[request proxyUsername: self proxyUsername password: self proxyPassword]		ifFalse: [ nil]</body><body package="HTTP" selector="getResponse:">getResponse: aConnection	| resp stream |	^[stream := self getResponseStream. 	resp := request headerOnly		ifTrue: [HttpResponse readHeaderFrom: stream ]		ifFalse: 				[HttpResponse new				parsingOptions: self entityParsingOptions;				readFrom: stream.]. 	 resp log. 	(resp connection notNil and: [resp isConnectionClose ]) ifTrue: [ self close]. 	 HttpException handleResponse: resp.	"response is success "	self registerCookiesFromResponse: resp.	resp	] on: HttpException	 do:  [ :ex | 		(resp := self handleResponseException: ex ) isNil 			ifTrue: [ ex pass]			ifFalse: [ resp ]].</body><body package="HTTP" selector="getResponseStream">getResponseStream	^connection getResponseStream</body><body package="HTTP" selector="handleResponseException:">handleResponseException: ex	(HttpStatusLineError, HttpTimeout handles: ex)  ifTrue: [ self  close. ^nil ].	^self processResponse: ex</body><body package="HTTP" selector="prepareRequestToSend">prepareRequestToSend	self addProxyAuthorizationToRequest.	self addAuthorizationToRequest.	self keepAlive notNil		ifTrue: 			[self keepAlive ifTrue: [ request keepAlive: true].			(self keepAlive not and: [ request keepAlive not ]) 				ifTrue: [ request keepAlive: false]				ifFalse: [ request keepAlive: true ]].	request isChunked ifTrue: [ request removeFieldAt: 'Content-length'].	self addCookieToRequest.</body><body package="HTTP" selector="privateExecuteRequest">privateExecuteRequest	^self privateExecuteRequest: self getConnectionStream.</body><body package="HTTP" selector="privateExecuteRequest:">privateExecuteRequest: aConnectionStream	^self privateExecuteRequest: aConnectionStream do: nil</body><body package="HTTP" selector="privateExecuteRequest:do:">privateExecuteRequest: aConnectionStream do: aBlock	self prepareRequestToSend.	self class log: [ request printString ] level: #HTTPClientRequest.	request writeOn: aConnectionStream.	aBlock notNil ifTrue: [ aBlock value: aConnectionStream].	self	commit: aConnectionStream.	aConnectionStream lineEndCRLF.	^aConnectionStream</body><body package="HTTP" selector="processResponse:">processResponse: ex	| selector response |	^(response := ex parameter ) notNil		ifTrue: 			[ selector := (('process', response code ), ':') asSymbol .			^(self respondsTo: selector)				ifTrue: [self perform: selector with: ex ]				ifFalse: [nil]]		ifFalse: [nil]</body><body package="HTTP" selector="request:">request: aReq	request := aReq</body><body package="HTTP" selector="retryRequest">retryRequest	self disconnect.	^self executeAndGetResponse</body><body package="HTTP" selector="safelyExecuteBlock:">safelyExecuteBlock: aBlock	^[aBlock value: self getConnectionStream] 		ensure: 	[ self keepAlive ifFalse: [ self disconnect ]]</body></methods><methods><class-id>Net.HttpClient</class-id> <category>connection</category><body package="HTTP" selector="close">close	self terminateCookieAgent.	self disconnect.</body><body package="HTTP" selector="commit:">commit: aStream	aStream flush.</body><body package="HTTP" selector="connect">connect	self getConnectionStream</body><body package="HTTP" selector="disconnect">disconnect	connection notNil		ifTrue: [ connection disconnect].</body><body package="HTTP" selector="getConnectionStream">getConnectionStream	self isConnected ifFalse: [ self openConnectionStream ].	^connection stream</body><body package="HTTP" selector="getHostPort">getHostPort	| arr |	self useProxy		ifTrue:			[ self proxyHost isNil				ifTrue: [ ^HttpException  raiseSignal: (#ProxyHostIsNotDefined &lt;&lt; #net &gt;&gt; 'Proxy host is not defined in Settings')]				ifFalse: 					[(self proxyExceptions detect: [ :addr | addr match: request hostName ] ifNone: [nil]) isNil						ifTrue: 							[self hostName: self proxyHost name. 							self portNumber:  self proxyHost port.							useProxyAuthorization := true ]]].	self hostName isNil		ifTrue:			[arr := request hostPortToConnect.			self hostName: arr first.			arr last == nil				ifTrue: [self portNumber: self portNumber]				ifFalse: [ self portNumber: arr last ]].	^Array with: self hostName with: self portNumber</body><body package="HTTP" selector="httpsStreamHandlerClass">httpsStreamHandlerClass	^#{Net.HttpsStreamHandler} 		valueOrDo: 			[URI tryToLoad: 'https'.			^#{Net.HttpsStreamHandler} value ]</body><body package="HTTP" selector="isConnected">isConnected	^connection notNil and: [ connection isConnected ]</body><body package="HTTP" selector="isSecure">isSecure	^connection notNil and: [ connection isSecure ]</body><body package="HTTP" selector="keepAlive">keepAlive	keepAlive isNil		ifTrue: [ keepAlive := self class keepAlive].	^keepAlive</body><body package="HTTP" selector="keepAlive:">keepAlive: aBoolean	keepAlive := aBoolean</body><body package="HTTP" selector="onStreamHandler:">onStreamHandler: aHttpStreamHandler	connection := aHttpStreamHandler</body><body package="HTTP" selector="openConnectionStream">openConnectionStream	| hostPort |	connection isNil 		ifTrue: [ connection := self streamHandlerClass new ].	hostPort := self getHostPort.	^connection 		openStreamFor: hostPort first 		port: hostPort last 		timeout: self timeout.</body><body package="HTTP" selector="sslContext">sslContext	^(connection notNil and: [ connection isSecure ])		ifTrue: [connection sslContext ]		ifFalse: [ nil ]</body><body package="HTTP" selector="sslContext:">sslContext: anSSLContext	(connection notNil and: [ connection isSecure not])		ifTrue: [ ^HttpException  raiseSignal:  (#CanNotSSLContext &lt;&lt; #net &gt;&gt; 'Can not set SSLContext to HTTP connection') ].	connection isNil ifTrue: [ connection := self httpsStreamHandlerClass new ].	connection sslContext: anSSLContext</body><body package="HTTP" selector="streamHandlerClass">streamHandlerClass	^self streamHandlerClassFor: self protocol</body><body package="HTTP" selector="streamHandlerClassFor:">streamHandlerClassFor: aString	('http' match: aString)		ifTrue: [ ^HttpStreamHandler ].	('https' match: aString)		ifFalse: 			[^HttpException  raiseSignal:  ((#UnsupportedProtocol1s &lt;&lt; #net &gt;&gt; 'Unsupported protocol: &lt;1s&gt;')			expandMacrosWith: request protocol)].	^self httpsStreamHandlerClass</body><body package="HTTP" selector="validationBlock">validationBlock	^(connection notNil and: [ connection isSecure ])		ifTrue: [connection validationBlock ]		ifFalse: [ nil ]</body><body package="HTTP" selector="validationBlock:">validationBlock:  aBlock	(connection notNil and: [ connection isSecure not])		ifTrue: [ ^HttpException  raiseSignal:  (#CanNotValidationBlock &lt;&lt; #net &gt;&gt; 'Can not set validationBlock to HTTP connection') ].	connection isNil ifTrue: [ connection := self httpsStreamHandlerClass new ].	connection validationBlock:  aBlock</body></methods><methods><class-id>Net.HttpClient</class-id> <category>low-level command interface</category><body package="HTTP" selector="connectRequest:do:">connectRequest: aHttpRequest do: aBlock"This method should be used to write chunked message to the connection stream""This method opens connection stream, writes request header fields on the connection stream and passes this stream to the specified block. Answers HttpResponse if succeed "	| conn |	request := aHttpRequest.	conn := self getConnectionStream.	^[ self privateExecuteRequest: conn do: aBlock.	self  getResponse: conn ] 		ensure: [ self keepAlive ifFalse: [ self disconnect ]]</body><body package="HTTP" selector="executeAndGetResponse">executeAndGetResponse" Connect, send request, parse response and answer instance of HttpResponse class "	^self  executeRequestDo: [ :connectionx | self getResponse: connectionx ].</body><body package="HTTP" selector="executeRequest:">executeRequest: aRequest" Connect, send request and answer HttpResponse "	request := aRequest.	^self executeAndGetResponse</body><body package="HTTP" selector="executeRequest:do:">executeRequest: aRequest do: aBlock" Connect, send request and pass connection to specified block "	request := aRequest.	^self executeRequestDo: aBlock</body><body package="HTTP" selector="executeRequestDo:">executeRequestDo: aBlock" Connect, send request and pass connection to specified block "	^self safelyExecuteBlock:		[ :connectionx |		self privateExecuteRequest: connectionx.		aBlock value: connectionx ]</body></methods><methods><class-id>Net.HttpClient</class-id> <category>processing</category><body package="HTTP" selector="process100:">process100: ex	^ex retry</body><body package="HTTP" selector="process301:">process301: ex	self redirectRequest ifFalse: [^nil].	^(#('GET' 'HEAD') includes: request method )		ifTrue: 			[| newUrl |			newUrl := request url resolvePath: ex location.			request url = newUrl 				ifTrue: [ ex parameter ]				ifFalse: 					[request url: newUrl. 					self hostName: newUrl host.					self portNumber: newUrl port.					self terminateCookieAgent.					self retryRequest ]]		ifFalse: [ nil]</body><body package="HTTP" selector="process302:">process302: ex	^self process301: ex</body><body package="HTTP" selector="process401:">process401: exception	"Authorization required"	|  response |	(request fieldsAt:  'authorization') isEmpty 		ifFalse: [ ^exception pass ].	response := exception  parameter.	response basicWwwAuthenticationHeader isNil		ifTrue: [^nil ].	^self addAuthorizationToRequest notNil			ifTrue: [self retryRequest ]			ifFalse: [nil]</body><body package="HTTP" selector="process407:">process407: exception	"Proxy Authentication required"	|  response |	(request fieldsAt: 'proxy-authenticate' ) isEmpty 		ifFalse: [ ^self error: (#WrongProxyAuthenticateInformation &lt;&lt; #net &gt;&gt; 'Wrong proxy-authenticate information')].	response := exception  parameter. 	response basicProxyAuthenticationHeader isNil		ifTrue: [^nil ].	^self addProxyAuthorizationToRequest notNil		ifTrue: [self retryRequest]		ifFalse: [nil ]</body></methods><methods><class-id>Net.HttpClient</class-id> <category>HTTP commands</category><body package="HTTP" selector="delete:">delete: urlString	request := (self requestClass delete: urlString ).	^self  executeAndGetResponse</body><body package="HTTP" selector="get:">get: urlString"The GET method means retrieve whatever information (in the form of an entity ) is identified by the urlString""Returns an instance of HttpResponse if succeed or exception"	request := (self requestClass get: urlString ). 	^self  executeAndGetResponse</body><body package="HTTP" selector="headers:">headers: urlString"The HEAD method is identical to GET except that the server must not return a message body in the response""Returns an instance of HttpResponse if succeed or exception"	request := (self requestClass headers: urlString ).	^self  executeAndGetResponse</body><body package="HTTP" selector="post:contents:">post: urlString contents: aString " The POST method is used to request that the destination server accept the specified aString as a new subordinate of the resource identified by the urlStringReturns an instance of HttpResponse if succeed or exception"	request := (self requestClass post: urlString ).	request contents: aString. 	^self  executeAndGetResponse</body><body package="HTTP" selector="put:contents:">put: urlString contents: aString"The PUT method requests that the specified aString be stored under the supplied urlString.Returns an instance of HttpResponse if succeed or exception"	request := (self requestClass put: urlString ).	request contents: aString.	^self  executeAndGetResponse</body></methods><methods><class-id>Net.HttpClient</class-id> <category>streams -- guarded</category><body package="HTTP" selector="readStreamCmd:url:do:">readStreamCmd:  commandString url: url do: aBlock" Connect, evaluate block, ensure disconnect, answer block evaluation result "	^self executeRequest: (self requestClass method: commandString url: url asURI)					do: aBlock</body></methods><methods><class-id>Net.HttpClient</class-id> <category>streams -- unguarded</category><body package="HTTP" selector="readStreamCmd:url:">readStreamCmd:  commandString url: url" Connect, send request and answer http connection stream "	request := self requestClass method: commandString url: url asURI.	^self privateExecuteRequest: self getConnectionStream.</body></methods><methods><class-id>Net.HttpClient</class-id> <category>entity parsing options</category><body package="HTTP" selector="decodeContents:">decodeContents: aBoolean	self entityParsingOptions at: #decodeContents put: aBoolean</body><body package="HTTP" selector="decompressContents:">decompressContents: aBoolean	self entityParsingOptions at: #decompressContents put: aBoolean</body></methods><methods><class-id>Net.HttpClient</class-id> <category>cookie management</category><body package="HTTP" selector="addCookieToRequest">addCookieToRequest	self getCookieAgent isNil ifTrue: [ ^nil ].	^self cookieAgent setCookieFieldForRequest: request.</body><body package="HTTP" selector="cookieAgent">cookieAgent	^cookieAgent</body><body package="HTTP" selector="enableCookies">enableCookies	enableCookies isNil		ifTrue: [ enableCookies := self class enableCookieProcessing].	^enableCookies</body><body package="HTTP" selector="enableCookies:">enableCookies: aBoolean 	enableCookies := aBoolean</body><body package="HTTP" selector="getCookieAgent">getCookieAgent	self enableCookies ifFalse: [^nil].	cookieAgent isNil ifTrue: [cookieAgent := CookieAgent new].	^cookieAgent</body><body package="HTTP" selector="registerCookiesFromResponse:">registerCookiesFromResponse: aHttpResponse	self getCookieAgent isNil ifTrue: [ ^nil ].	(aHttpResponse setCookieFields detect: [ :f | f shouldTerminateSession ] ifNone: [nil]) notNil		ifTrue: [self terminateCookieAgent. ^nil ].	^self cookieAgent addCookiesFrom: aHttpResponse requestUrl: request url</body><body package="HTTP" selector="terminateCookieAgent">terminateCookieAgent	cookieAgent notNil		ifTrue: 			[ cookieAgent terminate.			cookieAgent := nil].</body></methods><methods><class-id>Net.HttpClient</class-id> <category>utilities</category><body package="HTTP" selector="getUserAndPasswordDialogFor:">getUserAndPasswordDialogFor: response	| dialog spec password result msg |	dialog := SimpleDialog new.	spec := (dialog class interfaceSpecFor: #emptySpec).	dialog initializeBuilderFor: nil.	dialog builder add: spec window.	dialog builder add: spec component.	dialog initializeWindowFor: nil.	msg := response descriptionString isNil				ifTrue: [(#TheServerRequiresUserPassword &lt;&lt; #net &gt;&gt; 'The server requires a user and password to see this resource.')]				ifFalse: [response descriptionString].	dialog setInitialGap.	dialog addMessage: msg centered: false.	dialog addGap: 8.	dialog addMessage: (#UserNameC &lt;&lt; #net &gt;&gt; 'User Name:') centered: false.	dialog addGap: 4.	dialog addTextLine: (user := String new asValue).	dialog addGap: 8.	dialog addMessage: (#PasswordC &lt;&lt; #net &gt;&gt; 'Password:') centered: false.	dialog addGap: 4.	dialog addTextLine: (password := String new asValue) type: #password.	dialog addGap: 8.	dialog addOK: [true].	dialog addGap: 6.	dialog preOpen.	dialog builder window maximumSize: Screen default bounds width @ dialog builder window displayBox height.	dialog builder window minimumSize: 150 @ dialog builder window displayBox height.	dialog builder openDialogWithExtent: dialog builder window displayBox extent.	result := dialog accept value		ifTrue: [self class encodeUser: user value password: password value]		ifFalse: [nil].	^result</body></methods><methods><class-id>Net.HttpClient</class-id> <category>defaults</category><body package="HTTP" selector="defaultPortNumber">defaultPortNumber	^self connection ifNotNil: [ self connection defaultPortNumber ]</body></methods><methods><class-id>Net.HttpClient class</class-id> <category>constants</category><body package="HTTP" selector="description">description	^(#HTTPServer &lt;&lt; #net &gt;&gt; 'HTTP server') asString</body><body package="HTTP" selector="serverType">serverType	^#HTTP</body></methods><methods><class-id>Net.HttpClient class</class-id> <category>accessing</category><body package="HTTP" selector="autoloadHttps">autoloadHttps	^Settings httpsAutoload</body><body package="HTTP" selector="autoloadHttps:">autoloadHttps: aBoolean	Settings httpsAutoload: aBoolean</body><body package="HTTP" selector="keepAlive">keepAlive	^Settings httpKeepAlive</body><body package="HTTP" selector="protocol">protocol	^Protocol ifNil: [ Protocol := self defaultProtocolValue ]</body><body package="HTTP" selector="protocol:">protocol: aString	Protocol := aString.</body><body package="HTTP" selector="proxyExceptions">proxyExceptions	^Settings httpProxyExceptions</body><body package="HTTP" selector="proxyHost">proxyHost	^Settings httpProxyHost</body><body package="HTTP" selector="redirectRequest">redirectRequest	^Settings httpRedirectRequest</body><body package="HTTP" selector="useProxy">useProxy	^Settings httpUseProxy</body></methods><methods><class-id>Net.HttpClient class</class-id> <category>utilities</category><body package="HTTP" selector="disableProxy">disableProxy	^self netSettings httpUseProxy: false</body><body package="HTTP" selector="enableProxy">enableProxy	^self netSettings httpUseProxy: true</body><body package="HTTP" selector="httpUsername:password:">httpUsername: username password: password	(username notNil and: [ password notNil])		ifTrue: 			[ Settings httpUser: (NetUser username: username password: password) ].</body><body package="HTTP" selector="proxyHost:port:">proxyHost: host port: port	self proxyHost: host port: port userid: nil password: nil</body><body package="HTTP" selector="proxyHost:port:userid:password:">proxyHost: host port: port userid: username password: password	| intPort hostSpec |	host isString ifFalse: [self error: (#ProxyHostNameMustBeString &lt;&lt; #net &gt;&gt; 'Proxy host name must be a string')].	intPort := port isCharacters 		ifTrue: [Integer readFrom: port readStream]		ifFalse: [port].	intPort isInteger 		ifFalse: [self error: (#ProxyPortMustBeAnInteger &lt;&lt; #net &gt;&gt; 'Proxy port must be an integer')].	hostSpec := (HostSpec new					name: host;					port:  intPort;					type: 'http';					yourself).	(username notNil and: [ password notNil])		ifTrue: [	hostSpec netUser: (NetUser username: username password: password)].	" set http proxy Settings "	Settings httpProxyHost: hostSpec.</body><body package="HTTP" selector="setKeepAlive">setKeepAlive	Settings httpKeepAlive: true</body></methods><methods><class-id>Net.HttpClient class</class-id> <category>instance creation</category><body package="HTTP" selector="loginToHost:asUser:withPassword:">loginToHost: aHostName asUser: userString withPassword: passwdString 	self shouldNotImplement</body><body package="HTTP" selector="loginToHost:port:asUser:withPassword:">loginToHost: aHostName port: aNumber asUser: userString withPassword: passwdString	self shouldNotImplement</body><body package="HTTP" selector="onStreamHandler:">onStreamHandler: aHttpStreamHandler	^self new		onStreamHandler: aHttpStreamHandler;		yourself</body></methods><methods><class-id>Net.HttpClient class</class-id> <category>debugging</category><body package="HTTP" selector="debugLabelsAndValues">debugLabelsAndValues	^OrderedCollection new		add: ((#HTTPClientRequest &lt;&lt; #net &gt;&gt; 'HTTP Client Request')-&gt;#HTTPClientRequest);		add: (#HTTPServerHeader &lt;&lt; #net &gt;&gt; 'HTTP Server Header')-&gt;#HTTPServerHeader;		add: (#HTTPServerMessage &lt;&lt; #net &gt;&gt; 'HTTP Server Message')-&gt;#HTTPServerMessage;		yourself</body><body package="HTTP" selector="menuItemName">menuItemName	^(#HTTPClientMessages &lt;&lt; #net &gt;&gt; 'HTTP Client Messages')</body></methods><methods><class-id>Net.HttpClient class</class-id> <category>class initialization</category><body package="HTTP" selector="initialize">initialize	"self initialize"	super initialize.	self registerToDebug.	HeaderField resetRegistry.</body></methods><methods><class-id>Net.HttpClient class</class-id> <category>defaults</category><body package="HTTP" selector="defaultEnableCookieProcessing">defaultEnableCookieProcessing	^false</body><body package="HTTP" selector="defaultPortNumber">defaultPortNumber"Moved to HttpStreamHandler"	^nil</body><body package="HTTP" selector="defaultProtocolValue">defaultProtocolValue	^'http'</body></methods><methods><class-id>Net.HttpClient class</class-id> <category>cookie management</category><body package="HTTP" selector="enableCookieProcessing">enableCookieProcessing	^EnableCookieProcessing isNil		ifTrue: [self defaultEnableCookieProcessing]		ifFalse: [EnableCookieProcessing]</body><body package="HTTP" selector="enableCookieProcessing:">enableCookieProcessing: aBoolean	EnableCookieProcessing := aBoolean</body></methods><methods><class-id>Net.HttpRequestLine</class-id> <category>visiting</category><body package="HTTP" selector="acceptVisit:with:">acceptVisit: aVisitor with: argument	^aVisitor acceptRequestLine: self with: argument</body></methods><methods><class-id>Net.HttpRequestLine</class-id> <category>accessing</category><body package="HTTP" selector="entityType">entityType	^HttpRequest</body><body package="HTTP" selector="extendedMethod">extendedMethod	^self prefix notNil		ifTrue: [ self prefix, self method]		ifFalse: [self method]</body><body package="HTTP" selector="headerOnly">headerOnly	^self method asSymbol == #HEAD</body><body package="HTTP" selector="host">host	^self url ~~ nil 		ifTrue: [ self url host ]		ifFalse: [ nil ]</body><body package="HTTP" selector="hostAndPort">hostAndPort	^self url ~~ nil		ifTrue: [self url hostAndPort ]		ifFalse: [ nil ]</body><body package="HTTP" selector="method">method	^method</body><body package="HTTP" selector="method:">method: aString	method := aString</body><body package="HTTP" selector="parent">parent	^nil</body><body package="HTTP" selector="path">path	^path</body><body package="HTTP" selector="port">port	^self url ~~ nil 		ifTrue: [ self url port ]		ifFalse: [ nil ]</body><body package="HTTP" selector="prefix">prefix	^prefix</body><body package="HTTP" selector="prefix:">prefix: aString	prefix := aString</body><body package="HTTP" selector="protocol">protocol	^self url ~~ nil		ifTrue: [ self url protocol asLowercase ]		ifFalse: 			[self version ~~ nil				ifTrue: [ (self version copyFrom: 1 to: (self version indexOf: $/ ) - 1) asLowercase ]				ifFalse: ['http']]</body><body package="HTTP" selector="url">url	^url</body><body package="HTTP" selector="url:">url: anURL	url := anURL asURI</body><body package="HTTP" selector="version">version	(version isNil or: [ version isEmpty])		ifTrue: [ version := self class defaultVersion].	^version</body><body package="HTTP" selector="version:">version: aString	version := aString</body></methods><methods><class-id>Net.HttpRequestLine</class-id> <category>composing</category><body package="HTTP" selector="writeOn:">writeOn: aStream	self printOn: aStream</body></methods><methods><class-id>Net.HttpRequestLine</class-id> <category>testing</category><body package="HTTP" selector="hasAbsoluteURI">hasAbsoluteURI	^self url ~~ nil</body><body package="HTTP" selector="isValid">isValid	^((#('POST' 'PUT' 'OPTIONS' 'GET' 'HEAD' 'DELETE' 'TRACE') includes: self method)		and: [ 'HTTP*' match: self version])</body></methods><methods><class-id>Net.HttpRequestLine</class-id> <category>printing</category><body package="HTTP" selector="printOn:">printOn: aStream	| urlForHeader |	urlForHeader := url isNil		ifTrue: [ path]		ifFalse: 			[Settings httpUseProxy				ifTrue: [self url asString]				ifFalse: [self url pathString]].	aStream nextPutAll: self extendedMethod;		space;		nextPutAll: urlForHeader;		space;		nextPutAll: self version.</body></methods><methods><class-id>Net.HttpRequestLine</class-id> <category>parsing</category><body package="HTTP" selector="readFrom:">readFrom: stream	| scanner index strUrl |	scanner := MimeScanner on: stream.	method := scanner nextToken.	(index := method indexOf: $-) &gt; 0		ifTrue: 			[prefix := method copyFrom: 1 to: index.			method := method copyFrom: index + 1 to: method size].	scanner skipWhiteSpace.	strUrl  := scanner upTo: Character space.	('http*' match: strUrl)		ifTrue: [url := strUrl asURI ]		ifFalse: [path := strUrl].	version := scanner scanText.</body></methods><methods><class-id>Net.HttpRequestLine class</class-id> <category>instance creation</category><body package="HTTP" selector="method:url:">method: aMethodString url: requestURI	^self new 		method: aMethodString;		url: requestURI;		yourself</body><body package="HTTP" selector="readFrom:">readFrom: stream	^self new readFrom: stream</body></methods><methods><class-id>Net.HttpRequestLine class</class-id> <category>defaults</category><body package="HTTP" selector="defaultVersion">defaultVersion	^'HTTP/1.1'</body></methods><methods><class-id>Net.HttpResponseStatusLine</class-id> <category>testing</category><body package="HTTP" selector="headerOnly">headerOnly		^(self code notNil 	and: [self code isEmpty not 	and: [self isInformationalReply or: [#('204' '304') includes: self code]]])		ifTrue: [true]		ifFalse: [false]</body><body package="HTTP" selector="isChallenge">isChallenge	^self isProxyAuthorizedRequired or: [ self isUnauthorized ]</body><body package="HTTP" selector="isClientError">isClientError	"Informational- Request received, continuing the process"	^self responseTypeIs: $4</body><body package="HTTP" selector="isError">isError	"Informational- Request received, continuing the process"	^(self isClientError or: [ self isServerError])</body><body package="HTTP" selector="isInformationalReply">isInformationalReply	"Informational - Request received, continuing the process"	^self responseTypeIs: $1</body><body package="HTTP" selector="isMoved">isMoved	"Moved permanently/temporarily"		^(self responseEquals: '301') or: [ self responseEquals: '302']</body><body package="HTTP" selector="isProxyAuthorizedRequired">isProxyAuthorizedRequired	"Proxy Authorized Required"	^self responseEquals: '407'</body><body package="HTTP" selector="isRedirectionReply">isRedirectionReply	"Informational- Request received, continuing the process"	^self responseTypeIs: $3</body><body package="HTTP" selector="isServerError">isServerError	"Informational- Request received, continuing the process"	^self responseTypeIs: $5</body><body package="HTTP" selector="isUnauthorized">isUnauthorized	"unauthorized"	^self responseEquals: '401'</body><body package="HTTP" selector="isValid">isValid	^(( 'HTTP*' match: self protocol) and: [ self status &gt; 99 and: [ self status &lt; 600 ]])</body></methods><methods><class-id>Net.HttpResponseStatusLine</class-id> <category>printing</category><body package="HTTP" selector="printMessageOn:">printMessageOn: aStream	self code isNil ifTrue: [ ^super printOn: aStream ].	aStream nextPutAll: self code; space.	self message notNil 		ifTrue: [aStream nextPutAll: self message].	aStream cr.</body><body package="HTTP" selector="printOn:">printOn: aStream	self code isNil ifTrue: [ ^super printOn: aStream ].	aStream nextPutAll: self protocol, '/', self version; space;			nextPutAll: self code; space.	self message notNil 		ifTrue: [aStream nextPutAll: self message].</body></methods><methods><class-id>Net.HttpResponseStatusLine</class-id> <category>accessing</category><body package="HTTP" selector="entityType">entityType	^HttpResponse</body><body package="HTTP" selector="parent">parent	^nil</body><body package="HTTP" selector="protocol">protocol	(protocol isNil or: [ protocol isEmpty])		ifTrue: [ protocol := self class defaultProtocol].	^protocol</body><body package="HTTP" selector="version">version	(version isNil or: [ version isEmpty])		ifTrue: [ version := self class defaultVersion].	^version</body></methods><methods><class-id>Net.HttpResponseStatusLine</class-id> <category>visiting</category><body package="HTTP" selector="acceptVisit:with:">acceptVisit: aVisitor with: argument	^aVisitor acceptResponseStatusLine: self with: argument</body></methods><methods><class-id>Net.HttpResponseStatusLine</class-id> <category>private</category><body package="HTTP" selector="readResponse">readResponse	"Read first line of the response.Parse response code"	| scanner |		scanner := MimeScanner on: stream.	protocol := scanner nextToken.	scanner nextToken.	version := scanner nextToken.	(self supportedVersions includes: version)		ifFalse: [HttpEntityError new				messageText: ((#UnexpectedHTTPVersion &lt;&lt; #net &gt;&gt; 'Unexpected HTTP version (&lt;1s&gt;)')						expandMacrosWith: version);				raiseSignal].	code := scanner nextToken.	scanner skipWhiteSpace.	messageStream nextPutAll: scanner scanText.</body><body package="HTTP" selector="setCode:">setCode: aString	code := aString</body><body package="HTTP" selector="supportedVersions">supportedVersions	^#('1.0' '1.1')</body></methods><methods><class-id>Net.HttpResponseStatusLine class</class-id> <category>defaults</category><body package="HTTP" selector="defaultProtocol">defaultProtocol	^'HTTP'</body><body package="HTTP" selector="defaultVersion">defaultVersion	^'1.1'</body></methods><methods><class-id>Net.HttpResponseStatusLine class</class-id> <category>instance creation</category><body package="HTTP" selector="code:">code: aString	^self new		setCode: aString;		yourself</body></methods><methods><class-id>Net.RegistryLimitationExc</class-id> <category>printing</category><body package="HTTP" selector="defaultMessageText">defaultMessageText	^'Cookie implementation limits'</body></methods><methods><class-id>Net.HttpEntity</class-id> <category>printing</category><body package="HTTP" selector="printForDisplayOn:">printForDisplayOn: aStream	self printOn: aStream</body><body package="HTTP" selector="printHeaderOn:">printHeaderOn: aStream	self printOn: aStream</body><body package="HTTP" selector="writeChunk:on:">writeChunk: anArray on: aStream 	self writeChunk: anArray on: aStream arguments: nil</body><body package="HTTP" selector="writeChunk:on:arguments:">writeChunk: anArray on: connectionStream arguments: args"Write chunk of message to a connection stream.Chunk format: 		chunk-size [ chunk-ext ] CRLF		chunk-data CRLF"	| size |	size := anArray size.	connectionStream lineEndTransparent.	self writeSize: size on: connectionStream arguments: args.	size &gt; 0		ifTrue: 			[connectionStream 				nextPutAll: anArray;				nextPut: Character cr; 				nextPut: Character lf]</body><body package="HTTP" selector="writeChunkedOn:do:">writeChunkedOn: stream do: aBlock 	self writeChunkedOn: stream do: aBlock footerDo: nil</body><body package="HTTP" selector="writeChunkedOn:do:footerDo:">writeChunkedOn: connectionStream do: aBlock footerDo: aBlock1"Write chunk body to a connection stream.	Chunked-body format:		chunk		0 CRLF		footer		CRLF"	connectionStream lineEndTransparent.	[aBlock value]		ensure: 			[self writeChunk: nil on: connectionStream.			aBlock1 notNil ifTrue: [aBlock1 value].			connectionStream lineEndTransparent.			connectionStream nextPut: Character cr; nextPut: Character lf ].</body><body package="HTTP" selector="writeChunkStream:on:">writeChunkStream: sourceStream on: aStream 	self writeChunkStream: sourceStream on: aStream arguments: nil</body><body package="HTTP" selector="writeChunkStream:on:arguments:">writeChunkStream: sourceStream on: aStream arguments: args"Write chunk of stream  to a connection stream."	self writeSize: sourceStream size on: aStream arguments: args.	[sourceStream atEnd]		whileFalse: 	[ aStream nextPut: sourceStream next]</body><body package="HTTP" selector="writeSize:on:arguments:">writeSize: size on: aStream arguments: argsString"Write a chunk size to a connection stream"" args are expected in format:* ( ; chunk-ext-name [ = chunk-ext-value] ) "	| str |	str := size printStringRadix: 16.	argsString notNil		ifTrue: [ str := str, ' ', argsString].	aStream nextPutAll: str; cr.	aStream nextPut: Character lf</body></methods><methods><class-id>Net.HttpEntity</class-id> <category>testing</category><body package="HTTP" selector="canBeDecoded">canBeDecoded	^(self transferEncoding isNil and: [ self contentEncoding isNil ])</body><body package="HTTP" selector="hasTransferEncoding">hasTransferEncoding	^self transferEncoding ~~ nil</body><body package="HTTP" selector="isChunked">isChunked	^self transferEncoding notNil and: [self transferEncoding match: 'chunked']</body><body package="HTTP" selector="isConnectionClose">isConnectionClose	self connection isNil ifTrue: [ ^false].	^(self connection detect: [ :val | 'close' match: val ] ifNone: [ nil ]) notNil</body><body package="HTTP" selector="isConnectionKeepAlive">isConnectionKeepAlive	^self keepAlive</body><body package="HTTP" selector="isExtended">isExtended	^(self fields detect: [ :field | self extendedFieldNames includes: field name] ifNone: [ nil] ) notNil</body><body package="HTTP" selector="isMandatory">isMandatory	^self isExtended</body><body package="HTTP" selector="isMultipartByteranges">isMultipartByteranges	| v |	^(v := self contentType ) ~~ nil		and: ['multipart/byteranges' match: v ]</body><body package="HTTP" selector="isResponse">isResponse	^false</body><body package="HTTP" selector="isValid">isValid	^self subclassResponsibility</body><body package="HTTP" selector="keepAlive">keepAlive"Persistent connections are the default for HTTP/1.1 messages; HTTP/1.1 spec introduce a new keyword (Connection: close) for declaring non-persistence. HTTP/1.1 defines the 'close' connection option  for the sender to signal that the connection will be closed after completion of the response. Persistent connections in HTTP/1.0 must be explicitly negotiated as they are not the default behavior. When it connects to an origin server, an HTTP/1.0 client MAY send the Keep-Alive connection-token : Connection: Keep-Alive  An HTTP/1.0 server would then respond with the Keep-Alive connection token and the client may proceed with an HTTP/1.0 (or Keep-Alive) persistent connection.A client MUST NOT send the Keep-Alive connection token to a proxy server as HTTP/1.0 proxy servers do not obey the rules of HTTP/1.1 for parsing the Connection header field."	self connection isNil ifTrue: [ ^false].	^(self connection detect: [ :val |'keep-alive' match: val ] ifNone: [ nil ]) notNil</body><body package="HTTP" selector="needsContentLength">needsContentLength	needsContentLength == nil		ifTrue: [ needsContentLength := self applyContentLength].	^needsContentLength</body><body package="HTTP" selector="needsContentTransferEncoding">needsContentTransferEncoding	^false</body></methods><methods><class-id>Net.HttpEntity</class-id> <category>mandatory extensions</category><body package="HTTP" selector="addFor:namespace:">addFor: fieldName namespace: nsString"Add new mandatory field  - man		with specified namespace - http://www.copyright.org/rights-managementnamespace id is generated dynamically""Man: http://www.copyright.org/rights-management; ns= xx"	| id |	id := self assignNextNamespaceId.	self addFor: fieldName namespace: nsString id: id.	^id</body><body package="HTTP" selector="addFor:namespace:id:">addFor: fieldName namespace: nsString id: idString"Add new mandatory field  - man		with specified namespace - http://www.copyright.org/rights-management		and id -  16""Man: http://www.copyright.org/rights-management; ns=16"	self addField: ( ManOptField field: fieldName namespace: nsString id: idString).	^idString</body><body package="HTTP" selector="allExtendedFieldsForNamespace:">allExtendedFieldsForNamespace: nsString"Returns collection of extended fields for the specified namespace""Man: http://www.copyright.org/rights-management; ns=16C-Opt: http://www.copyright.org/rights-management; ns=15"	| list list1 |	list := OrderedCollection new: 10.	(list1 :=  self allMandatoryFieldsForNamespace:  nsString) isEmpty not		ifTrue: [ list addAll: list1 ].	(list1 :=  self allOptionalFieldsForNamespace: nsString) isEmpty not		ifTrue: [ list addAll: list1 ].	^list</body><body package="HTTP" selector="allFieldsFor:namespace:">allFieldsFor: fieldName namespace:  nsString"Returns collection of specified extended fields for the specified namespace""Man: http://www.copyright.org/rights-management; ns=16Man: http://www.copyright.org/rights-management; ns=15"	^(self fieldsAt: fieldName)		select: [ :field | (field namespaceMapAt: nsString) notNil ]</body><body package="HTTP" selector="allFieldsWithId:">allFieldsWithId: idString"Returns collection of fields with the same header prefix ( namespace id)""16-copyright: http:/www.org/copyright.html16-contributions: http:/www.org/patches.html"	^self fields select: [ :field | (idString, '-*') match: field name]</body><body package="HTTP" selector="allIdsForNamespace:">allIdsForNamespace: nsString"Returns collection of namespace id's for all extended fields""Man: http://www.copyright.org/rights-management; ns=16Opt:  http://www.copyright.org/rights-management; ns=15""#( '16' '15')"	| list |	list := OrderedCollection new: 10.	self extendedFieldNames 		do: [ :fname | 			(self namespaceMapFor: fname) 				keysAndValuesDo: 					[ :k :v | 					(k equivalentTo: nsString ignoreCase: true) 						ifTrue: [ list add: v]]].	^list</body><body package="HTTP" selector="allMandatoryFieldsForNamespace:">allMandatoryFieldsForNamespace:  nsString"Returns collection of namespace id's for mandatory fields""Man: http://www.copyright.org/rights-management; ns=16C-Man:  http://www.copyright.org/rights-management; ns=15""#( '16' '15')"	| list1 list |	list := OrderedCollection new: 10.	self mandatoryFieldNames 		do: [ :fieldName |			(list1 := (self fieldsAt: fieldName)				select: [ :field | (field namespaceMapAt: nsString) notNil ]) isEmpty not		ifTrue: [ list addAll: list1]].	^list</body><body package="HTTP" selector="allOptionalFieldsForNamespace:">allOptionalFieldsForNamespace:  nsString"Returns collection of namespace id's for optional fields""Opt: http://www.copyright.org/rights-management; ns=16C-Opt:  http://www.copyright.org/rights-management; ns=15""#( '16' '15')"	| list1 list |	list := OrderedCollection new: 10.	self optionalFieldNames		do: [ :fieldName |				(list1 := (self fields at: fieldName) select: [ :field | (field namespaceMapAt: nsString) notNil ]) isEmpty not					ifTrue: [ list addAll: list1]].	^list</body><body package="HTTP" selector="assignNextNamespaceId">assignNextNamespaceId"Dynamically creates next namespace id and returns it as a string" 	self nextNamespaceId: self nextNamespaceId + 1.	^self nextNamespaceId printString</body><body package="HTTP" selector="extendedFieldForId:">extendedFieldForId: idString"Returns an extended field with the specified namespace id""Man: http://www.copyright.org/rights-management; ns=16"	| field |	(field :=  self mandatoryFieldForId: idString) notNil		ifTrue: [ ^field ].	(field :=  self optionalFieldForId: idString) notNil		ifTrue: [ ^field ].	^nil</body><body package="HTTP" selector="extendedFieldNames">extendedFieldNames	^#('man' 'c-man' 'opt' 'c-opt')</body><body package="HTTP" selector="fieldAt:id:">fieldAt: fieldName id: idString"Returns field with the specified namespace id (prefix)if this field is absent creates new header field ""16-copyright: http:/www.org/copyright.html"	^self getFieldAt: ( idString, '-', fieldName)</body><body package="HTTP" selector="fieldAt:put:id:">fieldAt: fieldName put: aValue id: idString"Set value (http:/www.org/copyright.html) 	for the specified field name (copyright)  	with namespace id (16)""16-copyright: http:/www.org/copyright.html"	(self getFieldAt: ( idString, '-', fieldName)) value: aValue</body><body package="HTTP" selector="fieldValueAt:id:">fieldValueAt: fieldName id: idString"Returns value (http:/www.org/copyright.html) for the specified field (16-copyright)""16-copyright: http:/www.org/copyright.html"	^self getValueFor: ( idString, '-', fieldName)</body><body package="HTTP" selector="idFor:namespace:">idFor: fieldName namespace: nsString"Returns namespace id for the specified mandatory(optional) field name and namespace""Man: http://www.copyright.org/rights-management; ns=16"" self idFor: 'man' namespace: 'http://www.copyright.org/rights-management' 	returns 16 "	^(self namespaceMapFor: fieldName) at: nsString</body><body package="HTTP" selector="mandatoryFieldForId:">mandatoryFieldForId:  idString"Returns mandatory field for the specified id""Man: http://www.copyright.org/rights-management; ns=16""C-Man: http://www.copyright.org/rt; ns=15"	| field |	self mandatoryFieldNames do:		[ :fieldName |		(field := (self fieldsAt: fieldName)					detect: [ :fd | (fd namespaceMapKeyAtValue: idString) notNil ] ifNone: [nil]) notNil			ifTrue: [ ^field ]].	^nil</body><body package="HTTP" selector="mandatoryFieldNames">mandatoryFieldNames	^#('man' 'c-man')</body><body package="HTTP" selector="namespaceFor:id:">namespaceFor: fieldName id:  idString"Returns namespace for the specified mandatory field and id""Man: http://www.copyright.org/rights-management; ns=16"" self namespaceFor: 'man' id: '16'	returns 'http://www.copyright.org/rights-management'  "	(self namespaceMapFor: fieldName)		keysAndValuesDo: 			[:aKey :aValue | aValue = idString ifTrue: [^aKey]].	^nil</body><body package="HTTP" selector="namespaceForId:">namespaceForId:  idString"Returns namespace for the specified id""Man: http://www.copyright.org/rights-management; ns=16"" self namespaceForId: '16'  returns: 'http://www.copyright.org/rights-management'  "	self namespaceMap		keysAndValuesDo: 			[:aKey :aValue | aValue = idString ifTrue: [^aKey]].	^nil</body><body package="HTTP" selector="namespaceMap">namespaceMap"Returns a dictionary all namespaces and id'snamespace is a keynamespace id is a value"	| dict |	dict := Dictionary new.	self extendedFieldNames do: [ :fname |		(self namespaceMapFor: fname) associations do: [ :ea | dict add: ea] ].	^dict</body><body package="HTTP" selector="namespaceMapFor:">namespaceMapFor: fnString"Returns a dictionary namespaces and id's for the specified field name ('man' 'opt' ...)namespace is a keynamespace id is a value"	| dict |	dict := Dictionary new.	(self fieldsAt: fnString) 		do: [ :field |   field namespaceMap associations do: [ :ea | dict add: ea] ].	^dict</body><body package="HTTP" selector="nextNamespaceId">nextNamespaceId"Returns namespace id (header-prefix)"	^nextNamespaceId isNil		ifTrue: [ nextNamespaceId := 10]		ifFalse: [ nextNamespaceId ]</body><body package="HTTP" selector="nextNamespaceId:">nextNamespaceId: aNumber"Sets namespace id (header-prefix)"		nextNamespaceId := aNumber</body><body package="HTTP" selector="optionalFieldForId:">optionalFieldForId:  idString"Returns optional field for the specified id""Opt: http://www.copyright.org/rights-management; ns=16""C-Opt: http://www.copyright.org/rt; ns=15"	| field |	self optionalFieldNames do:		[ :fieldName |		(field := (self fieldsAt: fieldName)					detect: [ :fd | (fd namespaceMapKeyAtValue: idString) notNil ] ifNone: [nil]) notNil			ifTrue: [ ^field ]].	^nil</body><body package="HTTP" selector="optionalFieldNames">optionalFieldNames	^#('opt' 'c-opt')</body><body package="HTTP" selector="removeNamespace:">removeNamespace: nsString"Removes all fields for the specified namespace"	(self allIdsForNamespace: nsString)		do: [ :id | self removeNamespaceId: id ].</body><body package="HTTP" selector="removeNamespaceId:">removeNamespaceId: idString"Removes all fields for the specified namespace id""Man: 'http://www.copyright.org/rights-management'; ns=14Man: 'http://www.copyright.org/rights-mgt'; ns=15, 'http://www.copyright.org/rt13'; ns=1314-Credentials: 'g5gj262jdw@4df'13-Credentials: 'QQQQ'  self removeNamespaceId: '13'.Result:Man: http://www.copyright.org/rights-management; ns=14Man: 'http://www.copyright.org/rights-mgt'; ns=1514-Credentials: 'g5gj262jdw@4df'  "	| field |	(self allFieldsWithId: idString)		do: [ :fd |  self removeFieldAt: fd name].	field := self extendedFieldForId: idString.	field removeId: idString.	field value isEmpty ifTrue: [ self removeField: field ].</body></methods><methods><class-id>Net.HttpEntity</class-id> <category>accessing fields</category><body package="HTTP" selector="allow">allow	^self fieldValueAt: 'allow'</body><body package="HTTP" selector="allow:">allow: stringOrCollection	(self getFieldAt: 'allow') value: stringOrCollection</body><body package="HTTP" selector="cacheControl">cacheControl	^self fieldAt: 'cache-control'</body><body package="HTTP" selector="cacheControl:">cacheControl: aStringOrAssociationOrCacheControl	(aStringOrAssociationOrCacheControl isKindOf: CacheControl) 		ifTrue: 			[self removeFieldAt: 'cache-control'.			self addField: aStringOrAssociationOrCacheControl]		ifFalse: [(self getFieldAt: 'cache-control') addDirective: aStringOrAssociationOrCacheControl]</body><body package="HTTP" selector="connection">connection	^self fieldValueAt: 'connection'</body><body package="HTTP" selector="connection:">connection: aString	(self getFieldAt: 'connection') value: aString</body><body package="HTTP" selector="contentBase">contentBase	^self fieldValueAt: 'content-base'</body><body package="HTTP" selector="contentBase:">contentBase: aString	(self getFieldAt: 'content-base') value: aString</body><body package="HTTP" selector="contentEncoding">contentEncoding	^self fieldValueAt: 'content-encoding'</body><body package="HTTP" selector="contentEncoding:">contentEncoding: aCollectionField	(self getFieldAt: 'content-encoding') value: aCollectionField</body><body package="HTTP" selector="contentLanguage">contentLanguage	^self fieldValueAt: 'content-language'</body><body package="HTTP" selector="contentLanguage:">contentLanguage: aString	(self getFieldAt: 'content-language') value: aString</body><body package="HTTP" selector="contentLocation">contentLocation	^self fieldValueAt: 'content-location'</body><body package="HTTP" selector="contentLocation:">contentLocation: aString	(self getFieldAt: 'content-location') value: aString</body><body package="HTTP" selector="contentMD5">contentMD5	^self fieldValueAt: 'content-md5'</body><body package="HTTP" selector="contentMD5:">contentMD5: aString	(self getFieldAt: 'content-md5') value: aString</body><body package="HTTP" selector="contentRange">contentRange	^self fieldValueAt: 'content-range'</body><body package="HTTP" selector="contentRange:">contentRange: aString	(self getFieldAt: 'content-range') value: aString</body><body package="HTTP" selector="cookie">cookie	^self fieldAt: 'cookie'</body><body package="HTTP" selector="cookie2">cookie2	^self fieldAt: 'cookie2'</body><body package="HTTP" selector="cookie2:">cookie2: aCookie2Field 	(self getFieldAt: 'cookie2') value: aCookie2Field</body><body package="HTTP" selector="cookie:">cookie: aCookieField 	self fieldAt: 'cookie' put: aCookieField</body><body package="HTTP" selector="date">date	^self fieldValueAt: 'date'</body><body package="HTTP" selector="date:">date: aTimestampOrStringOrArray	(self getFieldAt: 'date') value: aTimestampOrStringOrArray</body><body package="HTTP" selector="etag">etag	^self fieldValueAt: 'etag'</body><body package="HTTP" selector="etag:">etag: aString	(self getFieldAt: 'etag') value: aString</body><body package="HTTP" selector="expires">expires	^self fieldValueAt: 'expires'</body><body package="HTTP" selector="expires:">expires: aTimestampOrStringOrArray	(self getFieldAt: 'expires') value: aTimestampOrStringOrArray</body><body package="HTTP" selector="from">from	^self fieldValueAt: 'from'</body><body package="HTTP" selector="from:">from: aString	(self getFieldAt: 'from') value: aString</body><body package="HTTP" selector="lastModified">lastModified	^self fieldValueAt: 'last-modified'</body><body package="HTTP" selector="lastModified:">lastModified: aTimestampOrStringOrArray	(self getFieldAt: 'last-modified') value: aTimestampOrStringOrArray</body><body package="HTTP" selector="pragma">pragma	^self fieldValueAt: 'pragma'</body><body package="HTTP" selector="pragma:">pragma: aString	(self getFieldAt: 'pragma') value: aString</body><body package="HTTP" selector="removeFromCacheControl:">removeFromCacheControl: aString	(self getFieldAt: 'cache-control') removeDirective: aString</body><body package="HTTP" selector="setCookie">setCookie	^self fieldAt: 'set-cookie'</body><body package="HTTP" selector="setCookie2">setCookie2	^self fieldAt: 'set-cookie2'</body><body package="HTTP" selector="setCookie2:">setCookie2: aSetCookie2Field 	(self getFieldAt: 'set-cookie2') value: aSetCookie2Field</body><body package="HTTP" selector="setCookie:">setCookie: aSetCookieField 	(self getFieldAt: 'set-cookie') value: aSetCookieField</body><body package="HTTP" selector="setCookieFields">setCookieFields	| coll sc |	coll := OrderedCollection new.	(sc := self fieldAt: 'set-cookie') notNil ifTrue: [ coll add: sc ].	(sc := self fieldAt: 'set-cookie2') notNil ifTrue: [ coll add: sc ].	^coll</body><body package="HTTP" selector="transferCoding">transferCoding	^self fieldValueAt: 'transfer-coding'</body><body package="HTTP" selector="transferCoding:">transferCoding: aString	^self fieldValueAt: 'transfer-coding' put: aString</body><body package="HTTP" selector="transferEncoding">transferEncoding	^self fieldValueAt: 'transfer-encoding'</body><body package="HTTP" selector="transferEncoding:">transferEncoding: aString	^self fieldValueAt: 'transfer-encoding' put: aString</body><body package="HTTP" selector="via">via	^self fieldValueAt: 'via'</body><body package="HTTP" selector="via:">via: aString	(self getFieldAt: 'via') value: aString</body></methods><methods><class-id>Net.HttpEntity</class-id> <category>accessing</category><body package="HTTP" selector="applyContentLength">applyContentLength	^(self body notEmpty 		and: [ self hasTransferEncoding not 			and: [self isMultipartByteranges not ]])</body><body package="HTTP" selector="keepAlive:">keepAlive: aBoolean	| val  token |	token := aBoolean ifTrue: ['Keep-Alive'] ifFalse: ['close'].	val := (self getFieldAt: 'connection') value.	#('Keep-Alive' 'close') do: [ :t | val removeAllSuchThat:[ :elem | t match:  elem ]].	val add: token.</body><body package="HTTP" selector="messageLine">messageLine	^self subclassResponsibility</body><body package="HTTP" selector="messageLine:">messageLine: anObject	self subclassResponsibility</body></methods><methods><class-id>Net.HttpEntity</class-id> <category>visiting</category><body package="HTTP" selector="acceptVisit:with:">acceptVisit: aVisitor with: argument	^aVisitor acceptHttpEntity: self with: argument</body></methods><methods><class-id>Net.HttpEntity</class-id> <category>parsing</category><body package="HTTP" selector="parse:">parse: rfc822Scanner 	builder := self builder.	builder options: self parsingOptions.	^builder parse: self from: rfc822Scanner</body></methods><methods><class-id>Net.HttpEntity</class-id> <category>parsing options</category><body package="HTTP" selector="decodeContents:">decodeContents: aBoolean	self parsingOptions at: #decodeContents put: aBoolean</body><body package="HTTP" selector="decompressContents:">decompressContents: aBoolean	self parsingOptions at: #decompressContents put: aBoolean</body><body package="HTTP" selector="parsingOptions">parsingOptions	^parsingOptions isNil		ifTrue: [ parsingOptions := Dictionary new]		ifFalse: [ parsingOptions ]</body><body package="HTTP" selector="parsingOptions:">parsingOptions: aDictionary	parsingOptions := aDictionary</body></methods><methods><class-id>Net.HttpEntity</class-id> <category>private</category><body package="HTTP" selector="decompressBody">decompressBody	| writeStream zippedStream |	self byteSource isNil ifTrue: [ ^String new ].	writeStream := (ByteArray new: 1024) writeStream.	zippedStream := GZipReadStream on: self byteSource reset.	[zippedStream atEnd] whileFalse: [ writeStream nextPut: zippedStream next].	^writeStream contents</body><body package="HTTP" selector="doParse:">doParse: rfc822Stream	self parseBody:  rfc822Stream</body><body package="HTTP" selector="hasByteSource">hasByteSource	^self byteSource notNil</body></methods><methods><class-id>Net.HttpEntity</class-id> <category>attachments</category><body package="HTTP" selector="addFileAttachment:">addFileAttachment: fileNameOrString	^self addFileAttachment: fileNameOrString withEncoding: SimpleBody defaultCharsetEncoder</body><body package="HTTP" selector="addFileAttachment:withEncoding:">addFileAttachment: fileNameOrString withEncoding: aSymbol	| stream entity filename |	entity := MimeEntity new. 	filename := fileNameOrString asFilename.	entity 		fileName: filename tail;		contentType: (self class mimeTypeForFile: filename).	[entity isBinary		ifTrue: 			[stream := ( filename withEncoding: #binary) readStream.			entity body: (self class simpleBody new setByteSource: stream).] 		ifFalse: 			[entity charset: aSymbol.			stream := (filename withEncoding: aSymbol ) readStream. 			entity body: (self class simpleBody new source: stream)].	self addPart: entity. 	] ensure: [ stream notNil ifTrue: [ stream close]].	^entity</body></methods><methods><class-id>Net.HttpEntity</class-id> <category>accessing body parts</category><body package="HTTP" selector="byteContents">byteContents	| s |	^(s := self byteSource)  isNil		ifTrue: [ nil ]		ifFalse: [ s reset; contents ]</body><body package="HTTP" selector="byteSource">byteSource	^self body byteSource</body><body package="HTTP" selector="byteSource:">byteSource: aByteArrayStream	self body setByteSource: aByteArrayStream</body><body package="HTTP" selector="contents">contents"Returns the message body contents. If the entity still has compressed body contents the method returns the compressed bytes  "	| v ce |	^((ce := self contentEncoding) notNil and: ['gzip' match: ce ])		ifTrue: [self byteContents]		ifFalse: [(v := self body value) ifNotNil: [ v asString ]]</body><body package="HTTP" selector="decodedContents">decodedContents"Returns decoded body contents. If the entity still has compressed body contents the method decompresses the body and returns decoded body contents  "	| ce |	^((ce := self contentEncoding) notNil and: ['gzip' match: ce ])		ifTrue: [(self decompressBody withEncoding: self charset ) readStream contents]		ifFalse: 	[self decodedContentsWith: self charset ]</body><body package="HTTP" selector="decompressedContents">decompressedContents"Returns decompressed body contents. The body contents won't be changed "	| ce val |	ce := self contentEncoding.	^(ce notNil and: ['gzip' match: ce ])		ifTrue: [self decompressBody]		ifFalse: 			[ (val := self byteContents) notNil				ifTrue: [val]				ifFalse: [^HttpEntityError new messageText: (#CompressedValue &lt;&lt; #net &gt;&gt; 'There is no compressed value'); raise ]]</body></methods><methods><class-id>Net.HttpEntity class</class-id> <category>parsing</category><body package="HTTP" selector="readFrom:">readFrom: aStream	^self new readFrom: aStream</body></methods><methods><class-id>Net.HttpEntity class</class-id> <category>defaults</category><body package="HTTP" selector="defaultBuilderType">defaultBuilderType	^HttpBuildHandler</body><body package="HTTP" selector="defaultPrinterType">defaultPrinterType	^HttpPrintHandler</body></methods><methods><class-id>Net.HttpResponse</class-id> <category>testing</category><body package="HTTP" selector="failed">failed	^self isSuccess not</body><body package="HTTP" selector="headerOnly">headerOnly	^self statusLine headerOnly</body><body package="HTTP" selector="isClientError">isClientError	"Informational- Request received, continuing the process"	^self statusLine isClientError</body><body package="HTTP" selector="isError">isError	"Informational- Request received, continuing the process"	^self statusLine isError</body><body package="HTTP" selector="isInformationalReply">isInformationalReply	"Informational - Request received, continuing the process"	^self statusLine isInformationalReply</body><body package="HTTP" selector="isMoved">isMoved	"Moved permanently/temporarily"		^self statusLine isMoved</body><body package="HTTP" selector="isProxyAuthorizedRequired">isProxyAuthorizedRequired	"Proxy Authorized Required"	^self statusLine isProxyAuthorizedRequired</body><body package="HTTP" selector="isRedirectionReply">isRedirectionReply	"Informational- Request received, continuing the process"	^self statusLine isRedirectionReply</body><body package="HTTP" selector="isResponse">isResponse	^true</body><body package="HTTP" selector="isServerError">isServerError	"Informational- Request received, continuing the process"	^self statusLine isServerError</body><body package="HTTP" selector="isSuccess">isSuccess	^self statusLine isSuccess</body><body package="HTTP" selector="isUnauthorized">isUnauthorized	"unauthorized"	^self statusLine isUnauthorized</body><body package="HTTP" selector="isValid">isValid	^self statusLine isValid</body><body package="HTTP" selector="successful">successful	^self isSuccess</body></methods><methods><class-id>Net.HttpResponse</class-id> <category>accessing</category><body package="HTTP" selector="basicProxyAuthenticationHeader">basicProxyAuthenticationHeader	^(self fieldsAt: 'proxy-authenticate') detect: [:hdr | hdr scheme = 'basic'] ifNone: [nil]</body><body package="HTTP" selector="basicWwwAuthenticationHeader">basicWwwAuthenticationHeader	^(self fieldsAt: 'www-authenticate') detect: [:hdr | hdr scheme = 'basic'] ifNone: [nil]</body><body package="HTTP" selector="code">code	^self statusLine code</body><body package="HTTP" selector="descriptionString">descriptionString	^self printStatusLineMessage</body><body package="HTTP" selector="messageLine">messageLine	^self statusLine</body><body package="HTTP" selector="messageLine:">messageLine: aHttpResponseStatusLine	self statusLine: aHttpResponseStatusLine</body><body package="HTTP" selector="protocol">protocol	^self statusLine protocol</body><body package="HTTP" selector="statusLine">statusLine	^statusLine</body><body package="HTTP" selector="statusLine:">statusLine: aHttpResponseStatusLine	statusLine := aHttpResponseStatusLine</body><body package="HTTP" selector="version">version	^self statusLine version</body></methods><methods><class-id>Net.HttpResponse</class-id> <category>printing</category><body package="HTTP" selector="printHeaderOn:">printHeaderOn: aStream	self printer printMessageElement: self statusLine on: aStream.		self printer printMessageElement: self header on: aStream.</body><body package="HTTP" selector="printStatusLineMessage">printStatusLineMessage	| stream |	stream := (String new: 32) writeStream.	self statusLine printMessageOn: stream.	^stream contents</body></methods><methods><class-id>Net.HttpResponse</class-id> <category>accessing fields</category><body package="HTTP" selector="acceptRanges">acceptRanges	^self fieldValueAt: 'accept-ranges'</body><body package="HTTP" selector="acceptRanges:">acceptRanges: aStringOrCollection	(self getFieldAt: 'accept-ranges') value: aStringOrCollection</body><body package="HTTP" selector="age">age	^self fieldValueAt: 'age'</body><body package="HTTP" selector="age:">age: aString	(self getFieldAt: 'age') value: aString</body><body package="HTTP" selector="location">location	^self fieldValueAt: 'location'</body><body package="HTTP" selector="location:">location: aString	(self getFieldAt: 'location') value: aString</body><body package="HTTP" selector="proxyAuthenticate">proxyAuthenticate	^self fieldValueAt: 'proxy-authenticate'</body><body package="HTTP" selector="proxyAuthenticate:">proxyAuthenticate: aStringOrAuthenticateChallengeField"Sets a value the parameter can be a string or instance of AuthenticateChallengeField"		(aStringOrAuthenticateChallengeField isKindOf: AuthenticateChallengeField)		ifTrue: 			[ self removeFieldAt: 'proxy-authenticate'.			self addField: aStringOrAuthenticateChallengeField]		ifFalse: 			[ (self getFieldAt: 'proxy-authenticate') 				addBasic: aStringOrAuthenticateChallengeField]</body><body package="HTTP" selector="public">public	^self fieldValueAt: 'public'</body><body package="HTTP" selector="public:">public: aValue	(self getFieldAt:  'public') value: aValue</body><body package="HTTP" selector="retryAfter">retryAfter	^self fieldValueAt: 'retry-after'</body><body package="HTTP" selector="retryAfter:">retryAfter: aTimestampOrStringOrArray	(self getFieldAt:  'retry-after') value: aTimestampOrStringOrArray</body><body package="HTTP" selector="wwwAuthenticate">wwwAuthenticate"Returns all AuthenticateChallengeField"	^self fieldsAt:  'www-authenticate'</body><body package="HTTP" selector="wwwAuthenticate:">wwwAuthenticate: aStringOrAuthenticateChallengeField"Sets a value the parameter can be a string or instance of AuthenticateChallengeField"		(aStringOrAuthenticateChallengeField isKindOf: AuthenticateChallengeField)		ifTrue: 			[ self removeFieldAt: 'authenticate'.			self addField: aStringOrAuthenticateChallengeField]		ifFalse: 			[ (self getFieldAt: 'authenticate') 				addBasic: aStringOrAuthenticateChallengeField]</body></methods><methods><class-id>Net.HttpResponse</class-id> <category>private</category><body package="HTTP" selector="log">log	HttpClient log: 			[| s |			s := (String new: 128) writeStream.			self printHeaderOn: s.			s contents] 		level: #HTTPServerHeader.	HttpClient log: [self printString]  level: #HTTPServerMessage.</body><body package="HTTP" selector="statusCode:">statusCode: aString	statusLine := HttpResponseStatusLine code: aString</body></methods><methods><class-id>Net.HttpResponse class</class-id> <category>instance creation</category><body package="HTTP" selector="code:">code: aString	^self new		statusCode: aString;		yourself</body></methods><methods><class-id>Net.HttpURL</class-id> <category>stream -- guarded</category><body package="HTTP" selector="envelopeReadStreamDo:">envelopeReadStreamDo: aBlock	^self safelyExecuteBlock: 			[self client readStreamCmd: 'GET' 			url: self 			do: [ :connection |  aBlock value: connection ]]</body><body package="HTTP" selector="envelopeWriteStreamDo:">envelopeWriteStreamDo: aBlock	^self shouldNotImplement</body><body package="HTTP" selector="readByteStreamDo:">readByteStreamDo: aBlock"Returns not decoded byte array stream and the response header fields "	| message dictionary client |	client := self client.	client decodeContents: false.	self safelyExecuteBlock: [message := client get: self ].	self checkMultipart: message.	dictionary := Dictionary new.	message fields 		do: [:fld | dictionary at: fld name put: fld ].	^aBlock 		value: message byteSource reset		value: dictionary</body><body package="HTTP" selector="readStreamDo:">readStreamDo: aBlock"Returns the response contents stream and the response header fields."	| message dictionary |	self safelyExecuteBlock: [message := self client get: self ].	self checkMultipart: message.	dictionary := Dictionary new.	message fields 		do: [:fld | dictionary at: fld name put: fld ].	^aBlock 		value: message contents readStream 		value: dictionary</body><body package="HTTP" selector="writeStreamDo:">writeStreamDo: aBlock	^self shouldNotImplement</body></methods><methods><class-id>Net.HttpURL</class-id> <category>stream -- unguarded</category><body package="HTTP" selector="binaryReadStream">binaryReadStream"Returns stream on ByteArray"	| message |	self safelyExecuteBlock: [message := self client get: self ].	self checkMultipart: message. 	^message contents asByteArray readStream</body><body package="HTTP" selector="binaryWriteStream">binaryWriteStream	^self shouldNotImplement</body><body package="HTTP" selector="envelopeReadStream">envelopeReadStream		^self safelyExecuteBlock: 		[self client readStreamCmd: 'GET' url: self]</body><body package="HTTP" selector="envelopeWriteStream">envelopeWriteStream	^self shouldNotImplement</body><body package="HTTP" selector="readStream">readStream"Returns stream on ByteString"	| message |	self safelyExecuteBlock: [message := self client get: self ].	self checkMultipart: message.	^message contents readStream.</body><body package="HTTP" selector="writeStream">writeStream	^self shouldNotImplement</body></methods><methods><class-id>Net.HttpURL</class-id> <category>private</category><body package="HTTP" selector="checkMultipart:">checkMultipart: aHttpEntity	aHttpEntity isMultipart		ifTrue: 			[self error: (#MultipartBodiesAreNotYetSupported &lt;&lt; #net &gt;&gt; 'Multipart bodies are not yet supported')].</body><body package="HTTP" selector="newClient">newClient"Obsolete"	^self client</body><body package="HTTP" selector="protocolSignals">protocolSignals	^HttpException</body><body package="HTTP" selector="safelyExecuteBlock:">safelyExecuteBlock: aBlock	^aBlock on: HttpUnauthorizedError		do: [ :ex |  			self user notNil				ifTrue: [ ex pass]				ifFalse: 					[Settings httpUser notNil						ifTrue: 							[ self user: Settings httpUser.							ex retry ]						ifFalse: [ ex pass]]]</body></methods><methods><class-id>Net.HttpURL</class-id> <category>accessing</category><body package="HTTP" selector="client">client	| client |	client := HttpClient new.	self user ifNotNil: [ client user: self user ].	client 		decodeContents: self decodeContents;		decompressContents: self decompressContents.	^client</body><body package="HTTP" selector="decodeContents">decodeContents	^decodeContents ifNil: [decodeContents := HttpBuildHandler decodeContents]</body><body package="HTTP" selector="decodeContents:">decodeContents: aBoolean	decodeContents := aBoolean</body><body package="HTTP" selector="decompressContents">decompressContents	^decompressContents ifNil: [decompressContents := HttpBuildHandler decompressContents]</body><body package="HTTP" selector="decompressContents:">decompressContents: aBoolean	decompressContents := aBoolean</body><body package="HTTP" selector="hostAddress">hostAddress	^self socketAddress hostAddress</body><body package="HTTP" selector="hostAndPort">hostAndPort	^port = self defaultPortNumber		ifTrue: [host]		ifFalse: [host, ':', port printString]</body><body package="HTTP" selector="pathString">pathString	| stream str |	stream := (String new: 32) writeStream.	path do: [:s | stream nextPutAll: '/', s].	str := stream contents.	str isEmpty ifTrue: [str := '/'].	query notNil ifTrue: [str := str, '?', query].	^str</body><body package="HTTP" selector="resource">resource	| message data |	self safelyExecuteBlock: [message := self client get: self ].	self checkMultipart: message. 	data := (message contents asByteArray withEncoding: #UTF_8) readStream lineEndTransparent.	^XML.InputSource		uri: self		encoding: nil		stream:  data</body><body package="HTTP" selector="socketAddress">socketAddress	^IPSocketAddress hostName: self host port: self port</body><body package="HTTP" selector="user">user	^user</body><body package="HTTP" selector="user:">user: aNetUser	user := aNetUser</body><body package="HTTP" selector="username:password:">username: nameString password: passString	user := NetUser username: nameString password: passString</body></methods><methods><class-id>Net.HttpURL class</class-id> <category>accessing</category><body package="HTTP" selector="protocol">protocol	^'http'</body></methods><methods><class-id>Net.HttpURL class</class-id> <category>defaults</category><body package="HTTP" selector="defaultPortNumber">defaultPortNumber	^SocketAccessor IPPORT_HTTP</body></methods><methods><class-id>Net.HttpSocketAccessor</class-id> <category>defaults</category><body package="HTTP" selector="connectionClass">connectionClass	"Answer a default connection class for the receiver."	^HttpConnection</body></methods><methods><class-id>Net.HttpSocketAccessor</class-id> <category>private</category><body package="HTTP" selector="primReadInto:startingAt:for:">primReadInto: buffer startingAt: index for: count 	"buffer is a byte-object, the place where IO is performed. 	index is a SmallInteger, the starting-point in the buffer. 	count is a SmallInteger, the number of bytes to be read."	"Returns a SmallInteger, which is the count of the bytes read."	"WouldBlock is a potential error condition."	time := Time millisecondClockValue.	^super primReadInto: buffer startingAt: index for: count</body><body package="HTTP" selector="privateReadInto:startingAt:for:">privateReadInto: buffer startingAt: index for: count 	"buffer is a byte-object, the place where IO is performed. 	index is a SmallInteger, the starting-point in the buffer. 	count is a SmallInteger, the number of bytes to be read."	"Returns a SmallInteger, which is the count of the bytes read."	"WouldBlock is a potential error condition."	&lt;primitive: 679&gt;	| newTime |	(self class restartableError: errorCode)		ifTrue: 			[self readWaitWithTimeoutMs: self timeout.			newTime := Time millisecondClockValue. 			newTime - time &gt; self timeout ifTrue: [ ^HttpTimeout raise].			^OSErrorHolder needRetrySignal raise].	^self reportErrorProceeding</body></methods><methods><class-id>Net.HttpSocketAccessor</class-id> <category>accessing</category><body package="HTTP" selector="timeout">timeout	timeout == nil ifTrue: [timeout := 6000].	^timeout</body><body package="HTTP" selector="timeout:">timeout: numberOfMilliseconds	timeout := numberOfMilliseconds</body></methods><methods><class-id>Net.AcceptField</class-id> <category>accessing</category><body package="HTTP" selector="levelAt:">levelAt: index	^(self mediaRangeAt: index) paramAt: 'level'</body><body package="HTTP" selector="mediaRangeAt:">mediaRangeAt: index	^self value at: index</body><body package="HTTP" selector="mediaTypeAt:">mediaTypeAt: index	^(self mediaRangeAt: index) value</body></methods><methods><class-id>Net.AcceptField</class-id> <category>adding media range</category><body package="HTTP" selector="addMedia:">addMedia: vString	self addMedia: vString qValue: nil</body><body package="HTTP" selector="addMedia:level:">addMedia: vString level: lString	self addMedia: vString qValue: nil level: lString</body><body package="HTTP" selector="addMedia:qValue:">addMedia: vString qValue: qString	self addMedia: vString qValue: qString level: nil</body><body package="HTTP" selector="addMedia:qValue:level:">addMedia: vString qValue: qString level: lString	| valWithParams |	valWithParams := self addValue: vString qValue: qString.	lString notNil ifTrue: [ valWithParams paramAt: 'level' put: lString].</body></methods><methods><class-id>Net.AcceptField class</class-id> <category>parsing</category><body package="HTTP" selector="fieldNames">fieldNames	^#('accept')</body></methods><methods><class-id>Net.AcceptField class</class-id> <category>instant creation</category><body package="HTTP" selector="media:">media: vString	^self media: vString qValue: nil level: nil</body><body package="HTTP" selector="media:level:">media: mString level: lString	^self media: mString qValue: nil level: lString</body><body package="HTTP" selector="media:qValue:">media: vString qValue: qString	^self media: vString qValue: qString level: nil</body><body package="HTTP" selector="media:qValue:level:">media: mString qValue: qString level: lString" Answer an instance of this field representing media range"	^(self name: 'accept') 		addMedia: mString qValue: qString level: lString;		yourself</body></methods><methods><class-id>Net.HttpBuffer</class-id> <category>position accessing</category><body package="HTTP" selector="currentBufferPosition">currentBufferPosition	^bufferPosition</body></methods><methods><class-id>Net.HttpBuffer</class-id> <category>initialize-release</category><body package="HTTP" selector="initialize">initialize	"Initialize the receiver for operation."	super initialize.	bufferPosition := 0.</body></methods><methods><class-id>Net.HttpBuffer</class-id> <category>reading</category><body package="HTTP" selector="nextAndSetOffset:">nextAndSetOffset: offsetBlock	"Read the next buffer.  Pass the start of read into offsetBlock.	Answer the buffer."	| amt start |  	start := bufferAmount \\ buffer size + 1.	(start = 1 and: [bufferAmount &gt; 6])  		ifTrue: 						["To avoid the UHE when the read buffer has just been flushed/reused and 			right at that point a scanner skips back one position on a non seekable stream."			"This turned out to be cheap and reliable solution:			copy the last elements of the buffer, 3 is just a small amount"			buffer				replaceFrom: 1				to: 3				with: buffer				startingAt: bufferAmount - 3 + 1.			start := 4.			bufferPosition := bufferPosition + (buffer size - 3). ].	amt := self readBufferStartingAt: start. 	amt isNil ifTrue: [amt := 0].	offsetBlock value: start.			bufferAmount := start - 1 + amt.	^buffer</body></methods><methods><class-id>Net.HttpStreamHandler</class-id> <category>stream</category><body package="HTTP" selector="close">close	self disconnect</body><body package="HTTP" selector="commit">commit	stream flush.</body><body package="HTTP" selector="disconnect">disconnect	stream notNil		ifTrue: 			[ stream close.			stream := nil.]</body></methods><methods><class-id>Net.HttpStreamHandler</class-id> <category>accessing</category><body package="HTTP" selector="getResponseStream">getResponseStream	^stream</body><body package="HTTP" selector="stream">stream	^stream</body></methods><methods><class-id>Net.HttpStreamHandler</class-id> <category>defaults</category><body package="HTTP" selector="defaultEncoding">defaultEncoding	^self class defaultEncoding</body><body package="HTTP" selector="defaultPortNumber">defaultPortNumber	^self class defaultPortNumber</body></methods><methods><class-id>Net.HttpStreamHandler</class-id> <category>testing</category><body package="HTTP" selector="isConnected">isConnected	^stream notNil</body><body package="HTTP" selector="isSecure">isSecure	^false</body></methods><methods><class-id>Net.HttpStreamHandler</class-id> <category>initialize-release</category><body package="HTTP" selector="openStreamFor:port:timeout:">openStreamFor: hNameString port: aNumber timeout: tmNumber	stream := self 		socketStreamWithEncoding: self defaultEncoding		host: hNameString 		port: aNumber 		timeout: tmNumber.	^stream</body></methods><methods><class-id>Net.HttpStreamHandler</class-id> <category>private</category><body package="HTTP" selector="socketStreamWithEncoding:host:port:timeout:">socketStreamWithEncoding: aSymbol host: aHost port: aPortNumber timeout: tmNumber	| socket str |	socket := HttpSocketAccessor			family: (SocketAddress domainCodeFromName: #afInet)			type: SocketAccessor sockStream.	socket timeout: tmNumber. 	[socket connectTo: 			(IPSocketAddress 				hostName: aHost 				port: ( aPortNumber ifNil: [self class defaultPortNumber ]) ).	str := (socket asExternalConnection withEncoding: aSymbol)  readAppendStream  lineEndCRLF ]		ifCurtailed: [socket close].	^str</body></methods><methods><class-id>Net.HttpStreamHandler class</class-id> <category>defaults</category><body package="HTTP" selector="defaultEncoding">defaultEncoding	^encoding ifNil: [ encoding := #ISO8859_1 ]</body><body package="HTTP" selector="defaultPortNumber">defaultPortNumber	^SocketAccessor IPPORT_HTTP</body></methods><methods><class-id>Net.ManOptField</class-id> <category>accessing</category><body package="HTTP" selector="addNamespace:id:">addNamespace: urlString id: idNumber		| valWithParams |	valWithParams := ValueWithParams newWithSeparators: self separators.	valWithParams value: urlString.	idNumber notNil ifTrue: [valWithParams paramAt: 'ns' put: idNumber].	self value add: valWithParams.	^valWithParams</body><body package="HTTP" selector="id">id	^self element paramAt: 'ns'</body><body package="HTTP" selector="id:">id: idNumber		self element paramAt: 'ns' put: idNumber</body><body package="HTTP" selector="namespace">namespace	^self element value</body><body package="HTTP" selector="namespace:">namespace: urlString		self element value: urlString</body><body package="HTTP" selector="namespace:id:">namespace: urlString id: idNumber		self 		namespace: urlString;		id: idNumber</body></methods><methods><class-id>Net.ManOptField</class-id> <category>queries</category><body package="HTTP" selector="idForNamespace:">idForNamespace: urlString	^self idForNamespace: urlString ifAbsent: [nil]</body><body package="HTTP" selector="idForNamespace:ifAbsent:">idForNamespace: urlString ifAbsent: aBlock	| param |	param := self value detect: [ :ea | ea value = urlString] ifNone: [ nil].	^param notNil 		ifTrue: [ param paramAt: 'ns']		ifFalse: [ aBlock value]</body><body package="HTTP" selector="namespaceForId:">namespaceForId: idNumber	^self namespaceForId: idNumber ifAbsent: [nil]</body><body package="HTTP" selector="namespaceForId:ifAbsent:">namespaceForId: idNumber ifAbsent: aBlock	| param |	param := self value detect: [ :ea | (ea paramAt: 'ns') = idNumber] ifNone: [ nil].	^param notNil 		ifTrue: [ param value ]		ifFalse: [ aBlock value ]</body><body package="HTTP" selector="namespaceMap">namespaceMap	|dict|	dict := Dictionary new.	self value do: [ :ea | dict at: ea value put: (ea paramAt: 'ns')].	^dict</body><body package="HTTP" selector="namespaceMapAt:">namespaceMapAt: nsString	^self namespaceMapAt: nsString ifAbsent: nil</body><body package="HTTP" selector="namespaceMapAt:ifAbsent:">namespaceMapAt: nsString ifAbsent: aBlock	^self namespaceMap at: nsString ifAbsent: [aBlock].</body><body package="HTTP" selector="namespaceMapKeyAtValue:">namespaceMapKeyAtValue: idString	^self namespaceMapKeyAtValue: idString ifAbsent: nil</body><body package="HTTP" selector="namespaceMapKeyAtValue:ifAbsent:">namespaceMapKeyAtValue: idString ifAbsent: aBlock	self namespaceMap keysAndValuesDo: 		[:aKey :aValue |  idString = aValue ifTrue: [^aKey]].	^aBlock value</body><body package="HTTP" selector="removeId:">removeId: idString	self value removeAllSuchThat: 		 [ :valWithParams |			(valWithParams paramAt: 'ns')  = idString ]</body></methods><methods><class-id>Net.ManOptField class</class-id> <category>parsing</category><body package="HTTP" selector="fieldNames">fieldNames	^#('man' 'opt' 'c-man' 'c-opt' )</body></methods><methods><class-id>Net.ManOptField class</class-id> <category>instant creation</category><body package="HTTP" selector="field:namespace:id:">field: aFieldName namespace: nsString id: idString	^(self name: aFieldName) 		addNamespace: nsString id: idString;		yourself</body></methods><methods><class-id>Net.CookieFields</class-id> <category>initialize-release</category><body package="HTTP" selector="addName:value:">addName: nameString value: valString	| cookie |	cookie := self valueWithParamsClass name: nameString value: valString.	self value add: cookie.	^cookie</body><body package="HTTP" selector="initialize">initialize	name := self class fieldNames first</body></methods><methods><class-id>Net.CookieFields</class-id> <category>adding</category><body package="HTTP" selector="add:">add: aCookieField	self value addAll: aCookieField value</body><body package="HTTP" selector="addValue:">addValue: aCookieValueWithParams	self value add: aCookieValueWithParams</body></methods><methods><class-id>Net.CookieFields class</class-id> <category>defaults</category><body package="HTTP" selector="defaultSeparators">defaultSeparators	^#($; $; $,  )</body><body package="HTTP" selector="defaultVersion">defaultVersion	^DefaultVersion isNil		ifTrue: [ 1 ]		ifFalse: [ DefaultVersion ]</body><body package="HTTP" selector="defaultVersion:">defaultVersion: aNumber	DefaultVersion := aNumber</body></methods><methods><class-id>Net.CookieField</class-id> <category>accessing</category><body package="HTTP" selector="valueWithParamsClass">valueWithParamsClass	^CookieValue</body><body package="HTTP" selector="version">version	^version</body><body package="HTTP" selector="version:">version: aNumber	version := aNumber</body></methods><methods><class-id>Net.CookieField</class-id> <category>parsing</category><body package="HTTP" selector="doParse:">doParse: scanner	| tokens position list valx |	position := scanner position.	tokens := self doPrivateParse: scanner.	(tokens first asLowercase = '$version' and: [ (tokens at: 2) = $= ])		ifTrue: 			["RFC2965 style: the first attribute has to be $version "			version := tokens last asNumber]		ifFalse: 			["Netscape"  			scanner position: position.			version := nil ].	list := OrderedCollection new: 5.	[scanner atEnd ]		whileFalse: 			[valx := self valueWithParamsClass newWithSeparators: self separators.			valx readFrom: scanner.			list add: valx ].	^list</body></methods><methods><class-id>Net.CookieField</class-id> <category>private</category><body package="HTTP" selector="doPrivateParse:">doPrivateParse: scanner	| str  |	str := scanner scanUntil: 			[ scanner hereChar == self valueSeparator 				or: [ scanner hereChar == self groupSeparator] ].	^self tokenize: (self scannerOn: str readStream).</body></methods><methods><class-id>Net.CookieField</class-id> <category>printing</category><body package="HTTP" selector="printValueOn:">printValueOn: aStream 	version notNil		ifTrue: 			[aStream nextPutAll: '$version=', self version printString.			aStream nextPut: self valueSeparator].	self value notNil		ifTrue: 			[version notNil ifTrue: [ aStream crtab].			self value  				do: [ :param |  param printOn: aStream]				separatedBy: 					[aStream nextPut: self groupSeparator.					version notNil ifTrue: [ aStream crtab ]]]		ifFalse: [ aStream nextPutAll: '' ].	aStream cr.</body></methods><methods><class-id>Net.CookieField class</class-id> <category>instance creation</category><body package="HTTP" selector="new">new	^self newWithVersion: self defaultVersion</body><body package="HTTP" selector="newNetscape">newNetscape	^super new initialize</body><body package="HTTP" selector="newRfc">newRfc	^self new</body><body package="HTTP" selector="newWithVersion:">newWithVersion: aNumber	^super new		initialize;		version: aNumber;		yourself</body></methods><methods><class-id>Net.CookieField class</class-id> <category>defaults</category><body package="HTTP" selector="defaultSeparators">defaultSeparators	^#($; $; $;  )</body></methods><methods><class-id>Net.CookieField class</class-id> <category>parsing</category><body package="HTTP" selector="fieldNames">fieldNames	^#('cookie' )</body></methods><methods><class-id>Net.SetCookieField</class-id> <category>accessing</category><body package="HTTP" selector="valueWithParamsClass">valueWithParamsClass	^SetCookieValue</body></methods><methods><class-id>Net.SetCookieField</class-id> <category>testing</category><body package="HTTP" selector="shouldTerminateSession">shouldTerminateSession	^(self value detect: [ :vx | vx maxAge = 0 ] ifNone: [nil]) notNil</body></methods><methods><class-id>Net.SetCookieField</class-id> <category>composing</category><body package="HTTP" selector="writeOn:encoding:">writeOn: aStream encoding: aString	self printOn: aStream indent: 0</body></methods><methods><class-id>Net.SetCookieField</class-id> <category>printing</category><body package="HTTP" selector="printOn:indent:">printOn: aStream indent: level	self value 		do: [ :vx |			self printNameOn: aStream.			vx printOn: aStream]		separatedBy: [ aStream cr ]</body></methods><methods><class-id>Net.SetCookieField class</class-id> <category>instance creation</category><body package="HTTP" selector="add:">add: aSetCookieValue	^self new		add:  aSetCookieValue;		yourself</body><body package="HTTP" selector="addName:value:">addName: nameString value: valString	^self new		addName: nameString value: valString;		yourself</body><body package="HTTP" selector="new">new	^super new initialize</body></methods><methods><class-id>Net.SetCookieField class</class-id> <category>parsing</category><body package="HTTP" selector="fieldNames">fieldNames	^#('set-cookie' )</body></methods><methods><class-id>Net.SetCookie2Field</class-id> <category>accessing</category><body package="HTTP" selector="valueWithParamsClass">valueWithParamsClass	^SetCookie2Value</body></methods><methods><class-id>Net.SetCookie2Field class</class-id> <category>parsing</category><body package="HTTP" selector="fieldNames">fieldNames	^#('set-cookie2' )</body></methods><methods><class-id>Net.HttpPage</class-id> <category>accessing</category><body package="HTTP" selector="helpText">helpText	^(#HttpSettingsHelp &lt;&lt; #net &gt;&gt; 'HTTP Settings allow specifying proxy server settings on a per-user basis.  Proxies are used in some situations to access the web through a firewall, or for improved web access. - Keep Alive Connection can be checked to set persistent connection stream. Unchecked Keep Alive Connection causes closing http connection after each request. - Redirect Request -  there are a few scenarios:	a. An application does not have Http error handling - in this case the http client uses its default error handling for the MovedError and sends new request with the location specified in the server reply.	b. An application has http error handling and the Redirection check box is unchecked - the http client passes the MovedError exception to the application.	c. An application has http error handling and the Redirection check box is checked - the http clients uses its default error handling for the MovedError exception. - Use Proxy must be checked to use the proxy information - Address: is the host IP or name of the proxy server - Port: is the port number for the proxy server - Proxy User: is an user ID authorized to access the proxyProxy User must be defined as a user (see Specify user identities ) and then selected from the drop-down list. To define a new user, click Add User... .  Complete the form as described in help for the Identities page.') asString</body><body package="HTTP" selector="httpHost">httpHost	^self 		userPreferencesAt: #httpHost		ifAbsentPut: [ self defaultProxyHost asValue]</body><body package="HTTP" selector="httpKeepAlive">httpKeepAlive	^self 		userPreferencesAt: #httpKeepAlive		ifAbsentPut: [ self registry httpKeepAlive  asValue ]</body><body package="HTTP" selector="httpPort">httpPort	^self 		userPreferencesAt: #httpPort		ifAbsentPut: 			[ self defaultPort asValue]</body><body package="HTTP" selector="httpUseProxy">httpUseProxy 	^self 		userPreferencesAt: #httpUseProxy  		ifAbsentPut: [ self registry httpUseProxy  asValue ]</body><body package="HTTP" selector="netUserMenu">netUserMenu 	^self userListOwner netUserMenu</body><body package="HTTP" selector="proxyExceptions">proxyExceptions	proxyExceptions isNil		ifTrue: [ proxyExceptions := self registry httpProxyExceptions].	 ^proxyExceptions</body><body package="HTTP" selector="proxyUserMenuAspect">proxyUserMenuAspect	^self 		userPreferences at: #proxyUserMenuAspect		ifAbsentPut: [ self defaultProxyUserMenuAspect asValue]</body><body package="HTTP" selector="redirectRequest">redirectRequest	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^redirectRequest isNil		ifTrue:			[redirectRequest := self registry httpRedirectRequest asValue]		ifFalse:			[redirectRequest]</body></methods><methods><class-id>Net.HttpPage</class-id> <category>actions</category><body package="HTTP" selector="accept">accept	(self httpUseProxy value		and: [self httpHost value isEmpty])			 ifTrue: [ ^Dialog warn: (#ProxyHostIsEmpty &lt;&lt; #net &gt;&gt; 'Proxy host is empty!')].	self registry httpUseProxy: self httpUseProxy value.	self registry httpKeepAlive: self httpKeepAlive value.	self registry httpRedirectRequest: self redirectRequest value.	(self httpUseProxy value 		and: [self httpHost value notNil and: [ self httpHost value notEmpty ]])		ifTrue: 			[ self registry httpProxyHost: 					(HostSpec new							name: self httpHost value;							port:  self httpPort value;							type: 'http';							netUser: self proxyUserMenuAspect value;							yourself) ].	self registry httpProxyExceptions:  self proxyExceptions.</body><body package="HTTP" selector="acceptProxyExceptions:">acceptProxyExceptions: aCollection	proxyExceptions := aCollection.	manager tickle</body><body package="HTTP" selector="addIdentity">addIdentity	self userListOwner addIdentity</body><body package="HTTP" selector="httpAdvanced">httpAdvanced	( HttpProxyExceptions new parent: self; yourself ) open</body><body package="HTTP" selector="importSnapshots:">importSnapshots: aCollection	super importSnapshots: aCollection.	self userListOwner reset</body><body package="HTTP" selector="reset">reset	self httpKeepAlive value: self registry httpKeepAlive.	self httpUseProxy value: self registry httpUseProxy.	self redirectRequest value: self registry httpRedirectRequest.	self resetProxyAspects.</body><body package="HTTP" selector="resetProxyAspects">resetProxyAspects	self httpHost value: self defaultProxyHost.	self proxyUserMenuAspect value: self defaultProxyUserMenuAspect.	self httpPort value: self defaultPort.</body><body package="HTTP" selector="resetUIStateToDefault">resetUIStateToDefault	self httpKeepAlive value: self registry httpKeepAliveDefault.	self httpUseProxy value: self registry httpUseProxyDefault.	self redirectRequest value: self registry httpRedirectRequestDefault.	self resetProxyAspects.</body><body package="HTTP" selector="useProxyChanged">useProxyChanged	| aBoolean | 	aBoolean := self httpUseProxy value. 	#(proxyAddress proxyPort addIdentityButton advancedButton proxyUserMenuAspect)		do: [ :each | (self widgetAt: each ) isEnabled: aBoolean ].</body></methods><methods><class-id>Net.HttpPage</class-id> <category>defaults</category><body package="HTTP" selector="defaultHttpUserMenuAspect">defaultHttpUserMenuAspect	| ids | 	^(ids := self netUserMenu value menuItems) notEmpty		ifTrue: [ ids first value asValue]		ifFalse: [ nil asValue ]</body><body package="HTTP" selector="defaultPort">defaultPort	^self registry httpProxyHost notNil				ifTrue: [ self registry httpProxyHost port]				ifFalse: [80]</body><body package="HTTP" selector="defaultProxyHost">defaultProxyHost	^self registry httpProxyHost notNil			ifTrue: [ self registry httpProxyHost name]			ifFalse: ['' ]</body><body package="HTTP" selector="defaultProxyUserMenuAspect">defaultProxyUserMenuAspect	| uh usr |	uh := self registry httpProxyHost notNil		ifTrue: 			[( usr := self registry httpProxyHost netUser) notNil				ifTrue: [ usr ]].	^uh isNil 		ifTrue: [ self defaultHttpUserMenuAspect value]		ifFalse: [ uh]</body></methods><methods><class-id>Net.HttpPage</class-id> <category>interface opening</category><body package="HTTP" selector="postBuildWith:">postBuildWith: aBuilder	self httpHost onChangeSend: #tickle to: self.	self httpKeepAlive onChangeSend: #tickle to: self.	self httpPort onChangeSend: #tickle to: self.	self httpUseProxy onChangeSend: #tickle to: self.	self proxyUserMenuAspect onChangeSend: #tickle to: self.	self redirectRequest onChangeSend: #tickle to: self.	self httpUseProxy onChangeSend: #useProxyChanged to: self.	self useProxyChanged.</body></methods><methods><class-id>Net.HttpConnection</class-id> <category>iobuffer creation</category><body package="HTTP" selector="defaultIoBufferInMode:">defaultIoBufferInMode: binaryFlag	"Answer a default ioBuffer approiate to the receiver with either binary or text mode."	^HttpBuffer on: self mode: binaryFlag</body><body package="HTTP" selector="ioBufferInMode:">ioBufferInMode: binaryFlag	"Answer a default ioBuffer appropriate to the receiver with either binary or text mode."	^HttpBuffer on: self mode: binaryFlag</body></methods><methods><class-id>Net.CookieValueWithParams</class-id> <category>accessing</category><body package="HTTP" selector="addPort:">addPort: aNumber	^self port: aNumber</body><body package="HTTP" selector="domain">domain	^self params at: #domain ifAbsent: [nil]</body><body package="HTTP" selector="domain:">domain: aString	self params at: #domain put: aString</body><body package="HTTP" selector="name">name	^self value key</body><body package="HTTP" selector="nameValue">nameValue	^self value value</body><body package="HTTP" selector="path">path	^self params at: #path ifAbsent: [nil]</body><body package="HTTP" selector="path:">path: aString	self params at: #path put: aString</body><body package="HTTP" selector="port">port	^self params at: #port ifAbsent: [ nil ]</body><body package="HTTP" selector="port:">port: aCollOfNumbersOrNumber	| coll |	(aCollOfNumbersOrNumber isKindOf: Boolean)		ifTrue: [^self params at: #port put: aCollOfNumbersOrNumber].	coll := (aCollOfNumbersOrNumber isKindOf: Collection)			ifTrue: [aCollOfNumbersOrNumber]			ifFalse: 	[OrderedCollection with: aCollOfNumbersOrNumber].	^self params at: #port put: coll</body><body package="HTTP" selector="separators">separators	separators isNil 	ifTrue: [separators := SetCookieField defaultSeparators ].	^separators</body><body package="HTTP" selector="version">version	^self params at: #version ifAbsent: [nil ]</body><body package="HTTP" selector="version:">version: aNumber	self params 	at: #version 	put:  aNumber</body></methods><methods><class-id>Net.CookieValueWithParams</class-id> <category>parsing-printing params</category><body package="HTTP" selector="portPrintString">portPrintString"The syntax requires quotes around the portlist even if there is only one port in the list "	| aStream |	^(self port isKindOf: Boolean) 		ifTrue: [ nil ]		ifFalse:			[self port isEmpty ifTrue: [ ^nil].			aStream := String new writeStream.			self port				do: [ :px | aStream nextPutAll: px printString ]				separatedBy: [ aStream nextPut: $, ].			QuotedPrintRequired raiseFrom: aStream contents ]</body><body package="HTTP" selector="setPort:">setPort: aStringOrBoolean	| scanner coll |	aStringOrBoolean isString		ifTrue:			[coll := OrderedCollection new.			scanner := self scannerOn: aStringOrBoolean readStream.			scanner				tokenizeList: [coll add:  scanner nextToken asNumber ]				separatedBy: [ scanner token = $, ].			self params at: #port put: coll ]		ifFalse: [ self params at: #port put: aStringOrBoolean ]</body><body package="HTTP" selector="setVersion:">setVersion: aString	| n |	n := aString asNumber.	n ~= self defaultVersionNumber		ifTrue: [^self error: (#DetectedUnrecognizedCookieVersion &lt;&lt; #net &gt;&gt; 'Detected unrecognized cookie version: &lt;1s&gt;' expandMacrosWith:  aString ) asString].	self version: n.</body><body package="HTTP" selector="versionPrintString">versionPrintString"The syntax requires quotes around the portlist even if there is only one port in the list "	| aStream |	aStream := String new writeStream.	aStream nextPutAll: self version printString.	^aStream contents</body></methods><methods><class-id>Net.CookieValueWithParams</class-id> <category>parsing</category><body package="HTTP" selector="addParameterNamed:value:">addParameterNamed: valString value: parString	| sel |	(sel := setSelectors at: valString asSymbol ifAbsent: [nil]) notNil		ifTrue: 			[self params 				at: valString asSymbol				ifAbsent: [self perform: sel with: parString]]		ifFalse: 	[self processUnknownParam: valString value: parString]</body><body package="HTTP" selector="finishParse">finishParse	(self params at: #version ifAbsent: [nil ]) isNil		ifTrue: [self setNetscapeStyle]		ifFalse: [self setRFCStyle]</body><body package="HTTP" selector="parseParamValueFrom:">parseParamValueFrom: scanner 	^self 		safelyExecuteParseParamValueFrom: scanner		do: 			[ (scanner hereChar == $; or: [scanner hereChar isNil ])				ifTrue: 					["no value param (secure/discard)" 					 true ]				ifFalse: 					[scanner peek == $"						ifTrue: 							["RFC style"							MimeEncodedWordCoDec decodeText: scanner nextToken]						ifFalse: 							["possible Netscape style"							scanner scanWhile: [ scanner hereChar ~= self parametersSeparator]]]].</body></methods><methods><class-id>Net.CookieValueWithParams</class-id> <category>initialize-release</category><body package="HTTP" selector="initialize">initialize	super initialize.	setSelectors := Dictionary new.	setSelectors		at: #version put: #setVersion:;		at: #path put: #path:;		at: #domain put: #domain:;		at: #port put: #setPort:.	printSelectors := Dictionary new.	printSelectors 		at: #version put: #versionPrintString;		at: #path put: #path;		at: #domain put: #domain;		at: #port put: #portPrintString.</body><body package="HTTP" selector="name:value:">name: aString value: vString	self setValueName: aString value: vString.	self setRFCStyle</body><body package="HTTP" selector="netscapeStyleName:value:">netscapeStyleName: aString value: vString	self setValueName: aString value: vString.	self setNetscapeStyle</body><body package="HTTP" selector="setValueName:value:">setValueName: aString value: vString	value := Association key: aString value: vString.</body></methods><methods><class-id>Net.CookieValueWithParams</class-id> <category>printing</category><body package="HTTP" selector="printParameter:value:on:">printParameter: name value: anObject on: aStream 	| printSel printValue |	(printSel  := printSelectors at: name asSymbol ifAbsent: [nil]) notNil		ifTrue: 			[[printValue := self perform:  printSel. 			self isRFCStyle				ifTrue: [super printParameter: name value:  printValue on: aStream ]				ifFalse: 					[printValue notNil ifTrue: [aStream nextPutAll: '=', printValue ]]			] on: QuotedPrintRequired 			do: [ :ex | self printParameterAsQuotedText: name value: ex parameter on: aStream ]			]</body><body package="HTTP" selector="printParameterAsQuotedText:value:on:">printParameterAsQuotedText: name value: anObject on: aStream	self class scannerType print: $= on: aStream.	[self class scannerType printQuotedText: anObject on: aStream	] 	on: NonASCIICharException 		do: [ :ex | aStream nextPut: $"; nextPutAll: anObject; nextPut: $"]</body><body package="HTTP" selector="printValueOn:">printValueOn: aStream	value ~~ nil		ifTrue: 		[self isRFCStyle			ifTrue: 				[aStream nextPutAll: self value key,'='. 				self class scannerType printWord: self value value on: aStream]			ifFalse: [aStream nextPutAll: self value key,'=',self value value]]</body></methods><methods><class-id>Net.CookieValueWithParams</class-id> <category>cookie style</category><body package="HTTP" selector="isNetscapeStyle">isNetscapeStyle	^self isRFCStyle not</body><body package="HTTP" selector="isRFCStyle">isRFCStyle	^self version notNil</body><body package="HTTP" selector="setNetscapeStyle">setNetscapeStyle	self removeParamAt: #version.</body><body package="HTTP" selector="setRFCStyle">setRFCStyle	self version: self defaultVersionNumber.</body></methods><methods><class-id>Net.CookieValueWithParams</class-id> <category>private-utility</category><body package="HTTP" selector="processUnknownParam:value:">processUnknownParam: valString value: parString	self error: (#DetectedUnrecognizedCookieAttribute &lt;&lt; #net &gt;&gt; 'Detected unrecognized cookie attribute: &lt;1s&gt;' expandMacrosWith:  valString ) asString</body><body package="HTTP" selector="tokenizedValueFrom:">tokenizedValueFrom: rfc822Stream "The Name=Value is required and must be the first pair in Set-Cookie field"	| nx vx |	nx := rfc822Stream upTo: $=. 	rfc822Stream hereChar = $=		ifFalse:			[self error: (#WrongNameValueParameter &lt;&lt; #net &gt;&gt; 'Wrong required NAME=VALUE parameter ')].	vx := rfc822Stream peek = $"		ifTrue: [rfc822Stream nextToken]		ifFalse: [rfc822Stream upToEnd].	^nx -&gt; vx</body><body package="HTTP" selector="validateNextToken:for:">validateNextToken: scanner for: parName	| tok |	tok := scanner peek. 	^tok == $=		ifTrue: [ scanner next. true]		ifFalse: 	[tok = $; or: [tok isNil ]]</body></methods><methods><class-id>Net.CookieValueWithParams</class-id> <category>defaults</category><body package="HTTP" selector="defaultVersionNumber">defaultVersionNumber"RFC2965: Version=value REQUIRED.  The value of the Version attribute, a decimal integer, identifies the version of the state management specification to which the cookie conforms.  For this specification, Version=1   applies."	^CookieFields defaultVersion</body></methods><methods><class-id>Net.CookieValueWithParams</class-id> <category>comparing</category><body package="HTTP" selector="=">= aCookieValue	| d dv p pv |	d := self domain isNil		ifTrue: [ nil]		ifFalse: [ self domain asLowercase ].	dv := aCookieValue domain isNil		ifTrue: [ nil]		ifFalse: [ aCookieValue domain asLowercase ].	p := self path isNil		ifTrue: [ nil]		ifFalse: [ self path asLowercase ].	pv := aCookieValue path isNil		ifTrue: [ nil]		ifFalse: [ aCookieValue path asLowercase ].			^self name = aCookieValue name 		and: [ d = dv and:  [ p = pv ] ]</body></methods><methods><class-id>Net.CookieValueWithParams class</class-id> <category>instance creation</category><body package="HTTP" selector="name:value:">name: nString value: vString"Create cookie value field in default RFC style"	^self new		name: nString value: vString;		yourself</body><body package="HTTP" selector="netscapeStyleName:value:">netscapeStyleName: nString value: vString"Create cookie value field in Netscape style"	^self new		netscapeStyleName: nString value: vString;		yourself</body><body package="HTTP" selector="rfcStyleName:value:">rfcStyleName: nString value: vString"Create cookie value field in RFC style"	^self name: nString value: vString</body></methods><methods><class-id>Net.CookieValue</class-id> <category>parsing</category><body package="HTTP" selector="addParameterNamed:value:">addParameterNamed: valString value: parString	| nm |	nm := valString first = $$ 		ifTrue: [valString copyFrom: 2 to: valString size ]		ifFalse: [ valString].	super addParameterNamed: nm value: parString</body><body package="HTTP" selector="parseParameters:">parseParameters: scanner	| paramName pos nm |	pos := scanner position.	scanner atEnd		ifFalse: 			[scanner 				tokenizeList: 					[(paramName := scanner nextToken) notNil						ifTrue:							[nm := paramName first = $$ 								ifTrue: [paramName copyFrom: 2 to: paramName size ]								ifFalse: [ paramName].							setSelectors 								at: nm asLowercase asSymbol 								ifAbsent: [scanner position: pos. ^self].							scanner skipWhiteSpace.							(self validateNextToken: scanner for: paramName)								ifFalse: [Transcript cr; show: (#DetectedMalformedField &lt;&lt; #net &gt;&gt; 'Detected malformed field:'); cr; show: scanner contents.  ^self ].  							self 								addParameterNamed: paramName asLowercase 								value: (self parseParamValueFrom: scanner). ]]				separatedBy: 						[pos := scanner position. 						scanner token == self parametersSeparator 							or: [scanner token == $,] ]]</body></methods><methods><class-id>Net.CookieValue</class-id> <category>initialize-release</category><body package="HTTP" selector="name:value:">name: aString value: vString	self setValueName: aString value: vString.</body></methods><methods><class-id>Net.CookieValue</class-id> <category>accessing</category><body package="HTTP" selector="name">name	^self value key</body><body package="HTTP" selector="nameValue">nameValue	^self value value</body></methods><methods><class-id>Net.CookieValue</class-id> <category>printing</category><body package="HTTP" selector="printParameter:on:">printParameter: assoc on: aStream 	self class scannerType printWord: '$', assoc key on: aStream.	self printParameter: assoc key value: assoc value on: aStream.</body></methods><methods><class-id>Net.CookieValue</class-id> <category>private-utility</category><body package="HTTP" selector="processUnknownParam:value:">processUnknownParam: valString value: parString"It can be Netscape syntax: Cookie: name1=val1; name2=val2...  "	NewCookieSignal raiseFrom:  valString -&gt; parString</body></methods><methods><class-id>Net.Cookie2Field</class-id> <category>printing</category><body package="HTTP" selector="printValueOn:">printValueOn: aStream 	value notNil		ifTrue: [aStream nextPutAll: '$version=', self value printString ]</body></methods><methods><class-id>Net.Cookie2Field</class-id> <category>accessing</category><body package="HTTP" selector="version">version	^self value</body><body package="HTTP" selector="version:">version: aNumber	self value: aNumber</body></methods><methods><class-id>Net.Cookie2Field</class-id> <category>parsing</category><body package="HTTP" selector="doParse:">doParse: scanner	| vname |	vname := scanner nextToken. 	vname asLowercase = '$version'		ifFalse: 	[ ^self error: ((#DetectedInvalidVersionCookie2 &lt;&lt; #net &gt;&gt; 'Detected invalid Cookie2 version: &lt;1s&gt;') expandMacrosWith: name)].	^scanner nextToken = $=		ifTrue: [ scanner nextToken asNumber ]		ifFalse: [ self error: (#DetectedInvalidCookie2Header &lt;&lt; #net &gt;&gt; 'Detected invalid Cookie2 header') ]</body></methods><methods><class-id>Net.Cookie2Field class</class-id> <category>parsing</category><body package="HTTP" selector="fieldNames">fieldNames	^#('cookie2' )</body></methods><methods><class-id>Net.Cookie2Field class</class-id> <category>instance creation</category><body package="HTTP" selector="version:">version: aNumber	^self new		name: self fieldNames first;		version: aNumber;		yourself</body></methods><methods><class-id>Net.HttpPrintHandler</class-id> <category>action callbacks</category><body package="HTTP" selector="endBody:">endBody: aMessageBody" Print conclusion if any "" Reset line end convention for the stream for the boundary delimiter if it is multipart body "	transferStream notNil 		ifTrue: 			[ transferStream isInternal 				ifTrue: [stream lineEndCR ]				ifFalse: [ stream lineEndCRLF ]]		ifFalse: [ stream isInternal ifFalse: [ stream lineEndCRLF]].	self printConclusion: aMessageBody</body><body package="HTTP" selector="endHttpEntity:">endHttpEntity: aHttpEntity	self endContentLength: aHttpEntity. 	^super endEntity: aHttpEntity</body><body package="HTTP" selector="startBody:">startBody: aMessageBody	| lineEndConvention |	((lineEndConvention := aMessageBody sourceLineEndConvention) ~~ nil		and: [ stream isInternal not])			ifTrue: [stream lineEndConvention: lineEndConvention ].	^super startBody: aMessageBody</body><body package="HTTP" selector="startHttpBody:">startHttpBody: aHttpEntity	bodyPosition := self stream position</body><body package="HTTP" selector="startHttpEntity:">startHttpEntity: aMimeEntityOrNil	self setStreamFor: aMimeEntityOrNil.	^self startEntity: aMimeEntityOrNil</body><body package="HTTP" selector="startMessageLine:">startMessageLine: aMimeEntityOrNil	self printLine: aMimeEntityOrNil messageLine printString.	^true</body><body package="HTTP" selector="startRequestLine:">startRequestLine: aRequestLine	self entity isExtended		ifTrue: [ aRequestLine prefix: 'm-']		ifFalse: [ aRequestLine prefix: nil].	self printLine: aRequestLine printString.	self entity hasHostField		ifFalse: 			[self transferFields add: (HeaderField fromLine: 'host: ',  aRequestLine hostAndPort)].	^true</body><body package="HTTP" selector="startResponseStatusLine:">startResponseStatusLine:aResponseStatusLine	self printLine: aResponseStatusLine printString.	^true</body></methods><methods><class-id>Net.HttpPrintHandler</class-id> <category>defaults</category><body package="HTTP" selector="dispatcherClass">dispatcherClass	^HttpDispatcher</body></methods><methods><class-id>Net.HttpPrintHandler</class-id> <category>printing utilities</category><body package="HTTP" selector="printBodyStream:">printBodyStream: aStream	| binary |	stream isInternal ifTrue: [ ^self printBodyOnInternalStream: aStream].	stream binary. 	((aStream respondsTo: #isBinary) and: [(binary := aStream isBinary) not ])		ifTrue: [ aStream binary ].	[[aStream atEnd] 		whileFalse: [stream nextPut: aStream next]	] ensure: 			[stream text.			(binary notNil and: [binary not ]) ifTrue: [aStream text ] ]</body><body package="HTTP" selector="printHeader:">printHeader: aMessageHeader" Print header fields "	| fields |	aMessageHeader removeKey: 'content-length'.	(fields := OrderedCollection new: 10)		addAll: self transferFields;		addAll:  (aMessageHeader fieldsInOrder: self headerFieldOrder).	fields do: [ :field | self printHeaderField: field ]. 	self startContentLength: self entity</body><body package="HTTP" selector="printPreambule:">printPreambule: aMessageBody	^true</body></methods><methods><class-id>Net.HttpPrintHandler</class-id> <category>testing</category><body package="HTTP" selector="needsContentLength:">needsContentLength: aHttpEntity	^Settings httpSetContentLength and: [aHttpEntity needsContentLength ]</body></methods><methods><class-id>Net.HttpPrintHandler</class-id> <category>private</category><body package="HTTP" selector="endContentLength:">endContentLength: aHttpEntity	| pos str length |	(self needsContentLength: aHttpEntity) 		ifTrue: 			[self digestMode not				ifTrue: 					[pos := self stream position. 					length := pos - bodyPosition.					aHttpEntity contentLength:  length.					length := length printString.					self stream position: contentLengthPosition - length size.					self stream nextPutAll: length.  					self stream position: pos.].				transferStream isInternal				ifTrue: [ transferStream nextPutAll: stream encodedContents  asString]				ifFalse: 					[str :=  stream encodedContents readStream.					transferStream 						lineEndTransparent;						binary.					[[ str atEnd ]						whileFalse: 	[ transferStream nextPut: str next ]					] ensure: [transferStream text]]].</body><body package="HTTP" selector="printBodyOnInternalStream:">printBodyOnInternalStream: aStream	aStream text.	[aStream atEnd] 		whileFalse: [stream nextPut: aStream next]</body><body package="HTTP" selector="printDigestText:">printDigestText: aString	| str l c n  |	stream isInternal ifTrue: [ ^super printDigestText: aString ].	str := (aString asByteArrayEncoding: self entity charset) readStream.	l := 0.	self indentLines ifTrue: [ n :=  self level + self indentation]. 	c := nil.	[stream binary.		[ str atEnd ]		whileFalse: 			[((l = 0 or: [c = 13]) and: [n notNil ])				ifTrue: [ n timesRepeat: [stream nextPut: 9]. l := 1 ].			 c := str next.			self stream nextPut: c ].	] ensure: 		[ stream text ].</body><body package="HTTP" selector="setStreamFor:">setStreamFor: aHttpEntity	(self needsContentLength: aHttpEntity)		ifTrue: 			[transferStream := stream.			stream := ((ByteArray new: 1024) withEncoding: #ISO8859_1)  writeStream.			transferStream isInternal				ifTrue: [ stream lineEndCR]				ifFalse: [ stream lineEndCRLF ]] 		ifFalse: 			[ transferStream := nil. 			stream isInternal ifFalse: [stream lineEndCRLF ] ].</body><body package="HTTP" selector="setTransferContext:">setTransferContext: aMimeEntity"HTTP uses transfer-codings""The Internet Assigned Numbers Authority (IANA) acts as a registry for transfer-coding value tokens. Initially, the registry contains the following tokens: 'chunked',  'identity', 'gzip', 'compress', and 'deflate' "</body><body package="HTTP" selector="startContentLength:">startContentLength: aHttpEntity	(self digestMode not and: [ self needsContentLength: aHttpEntity ])		ifTrue: 			[self stream nextPutAll: 'Content-length: '. 			self stream next: 7 put: Character space.			contentLengthPosition := self stream position.			self stream cr].</body><body package="HTTP" selector="valueStreamFor:">valueStreamFor: aSimpleBody	^aSimpleBody byteValueAsStream.</body></methods><methods><class-id>Net.SetCookieValue</class-id> <category>accessing</category><body package="HTTP" selector="comment">comment	^self params at: #comment ifAbsent: [nil]</body><body package="HTTP" selector="comment:">comment: aString	self params at: #comment put: aString</body><body package="HTTP" selector="expires">expires	^self params at: #expires ifAbsent: [nil]</body><body package="HTTP" selector="expires:">expires: aTimestamp	self params at: #expires put: aTimestamp</body><body package="HTTP" selector="maxAge">maxAge	^self params at: #'max-age' ifAbsent: [ nil ]</body><body package="HTTP" selector="maxAge:">maxAge: aNumber	self params 	at: #'max-age' put: aNumber</body><body package="HTTP" selector="secure">secure	^self params at: #secure ifAbsent: [false]</body><body package="HTTP" selector="secure:">secure: aBoolean	aBoolean 		ifTrue: [self params  at: #secure put: aBoolean]		ifFalse: [self params removeKey: #secure ifAbsent: [nil]].</body></methods><methods><class-id>Net.SetCookieValue</class-id> <category>converting</category><body package="HTTP" selector="acceptDomain:">acceptDomain: aString	^'*', self domain asLowercase match: aString asLowercase</body><body package="HTTP" selector="acceptPath:">acceptPath: aString	^'*', self path match: aString</body><body package="HTTP" selector="acceptPort:">acceptPort: aNumber	^true</body><body package="HTTP" selector="asCookie">asCookie	| c |	c := CookieValue name: self name value: self nameValue.	self isNetscapeStyle ifTrue: [^c].	self path notNil		ifTrue: [c path: self path].	self domain notNil		ifTrue: [ c domain: self domain].	self port notNil 		ifTrue: [ c port: self port].	^c</body></methods><methods><class-id>Net.SetCookieValue</class-id> <category>testing</category><body package="HTTP" selector="isExpired">isExpired	^(self isRFCStyle 		and: [self maxAge notNil 			and: [Timestamp now &gt; (Timestamp fromSeconds: self maxAge)]])	or: [self isNetscapeStyle 		and: [self expires notNil 			and: [Timestamp now &gt; self expires]]]</body><body package="HTTP" selector="isNotExpired">isNotExpired	^self isExpired not</body><body package="HTTP" selector="shouldBeDiscard">shouldBeDiscard	^false</body><body package="HTTP" selector="shouldNotBeDiscard">shouldNotBeDiscard	^self shouldBeDiscard not</body></methods><methods><class-id>Net.SetCookieValue</class-id> <category>parsing-printing params</category><body package="HTTP" selector="commentPrintString">commentPrintString	^(self comment asByteArrayEncoding:  #utf8 ) asString</body><body package="HTTP" selector="expiresPrintString">expiresPrintString	"Return a properly formatted date string using GMT."	| GMTSeconds |	GMTSeconds := Timestamp fromSeconds: (TimeZone reference convertLocalSecondsToGMT: self expires asSeconds).	^TimestampPrintPolicy print: GMTSeconds using: 'ddd, dd mmm yyyy hh:mm:ss GMT'</body><body package="HTTP" selector="maxAgePrintString">maxAgePrintString	^self maxAge printString</body><body package="HTTP" selector="securePrintString">securePrintString	^nil</body><body package="HTTP" selector="setComment:">setComment: aString	self comment: (aString asByteArray withEncoding: #utf8 ) readStream contents</body><body package="HTTP" selector="setExpires:">setExpires: aString	self expires: (RFC822Scanner readDateAndTimeFrom: aString readStream)</body><body package="HTTP" selector="setMaxAge:">setMaxAge: aString	self maxAge:  aString asNumber</body><body package="HTTP" selector="setSecure:">setSecure: aBoolean	self secure: aBoolean</body></methods><methods><class-id>Net.SetCookieValue</class-id> <category>private-utility</category><body package="HTTP" selector="expireAfterDays:">expireAfterDays: aNumber	"Mark this cookie for expiration after aNumber of days from now."	| now |	now := Time dateAndTimeNow.	self expires:		(Timestamp			fromDate: ((now at: 1) addDays: aNumber)			andTime: (now at: 2))</body><body package="HTTP" selector="expireAfterHours:">expireAfterHours: aNumber	"Mark this cookie for expiration after aNumber of hours from now."	| now increment |	now := Time dateAndTimeNow.	increment := Time new hours: aNumber minutes: 0 seconds: 0.	self expires:		(Timestamp			fromDate: (now at: 1)			andTime: ((now at: 2) addTime: increment))</body><body package="HTTP" selector="expireImmediately">expireImmediately	"Mark this cookie for immediate expiration."	| now |	now := Time dateAndTimeNow.	self expires:		(Timestamp			fromDate: ((now at: 1) addDays: -1)			andTime: (now at: 2))</body></methods><methods><class-id>Net.SetCookieValue</class-id> <category>initialize-release</category><body package="HTTP" selector="initialize">initialize	super initialize.	setSelectors		at: #secure put: #setSecure:;		at: #'max-age'  put: #setMaxAge:;		at: #comment put: #setComment:;		at: #expires put: #setExpires:.	printSelectors 		at: #'max-age' put: #maxAgePrintString;		at: #comment put: #commentPrintString;		at: #expires put: #expiresPrintString;		at: #secure put: #securePrintString.</body></methods><methods><class-id>Net.SetCookieValue class</class-id> <category>defaults</category><body package="HTTP" selector="restoreValueFrom:">restoreValueFrom: anXMLElement	^SetCookieField readFrom: anXMLElement elements first text readStream</body></methods><methods><class-id>Net.SetCookie2Value</class-id> <category>parsing-printing params</category><body package="HTTP" selector="commentURLPrintString">commentURLPrintString	^self commentURL asString</body><body package="HTTP" selector="discardPrintString">discardPrintString	^nil</body><body package="HTTP" selector="setCommentURL:">setCommentURL: aString	^self commentURL: aString asURI</body><body package="HTTP" selector="setDiscard:">setDiscard: aBoolean	self discard:  aBoolean</body></methods><methods><class-id>Net.SetCookie2Value</class-id> <category>accessing</category><body package="HTTP" selector="commentURL">commentURL	^self params at: #commenturl ifAbsent: [nil ]</body><body package="HTTP" selector="commentURL:">commentURL: anURL	^self params at: #commenturl put: anURL</body><body package="HTTP" selector="discard">discard	^self params at: #discard ifAbsent: [ false ]</body><body package="HTTP" selector="discard:">discard: aBoolean	aBoolean 		ifTrue: [self params  at: #discard put: aBoolean]		ifFalse: [self params removeKey: #discard ifAbsent: [nil]].</body></methods><methods><class-id>Net.SetCookie2Value</class-id> <category>converting</category><body package="HTTP" selector="acceptPort:">acceptPort: aNumber	^self port notEmpty</body></methods><methods><class-id>Net.SetCookie2Value</class-id> <category>initialize-release</category><body package="HTTP" selector="initialize">initialize	super initialize.	setSelectors		at: #commenturl put: #setCommentURL:;		at: #discard  put: #setDiscard:.	printSelectors 		at: #commenturl put: #commentURLPrintString;		at: #discard put: #discardPrintString.	self setRFCStyle.</body></methods><methods><class-id>Net.SetCookie2Value</class-id> <category>testing</category><body package="HTTP" selector="shouldBeDiscard">shouldBeDiscard	^(self isRFCStyle and: [self discard ])</body></methods><methods><class-id>Net.SetCookie2Value class</class-id> <category>defaults</category><body package="HTTP" selector="restoreValueFrom:">restoreValueFrom: anXMLElement	^(SetCookie2Field readFrom: ( 'Set-Cookie2: ', anXMLElement elements first text ) readStream) value first</body></methods><methods><class-id>Net.SetCookie2Value class</class-id> <category>instance creation</category><body package="HTTP" selector="netscapeStyleName:value:">netscapeStyleName: nString value: vString	^self name: nString value: vString</body></methods><methods><class-id>Net.HttpMovedError</class-id> <category>accessing</category><body package="HTTP" selector="location">location	^self parameter location</body></methods><methods><class-id>Net.HttpParser</class-id> <category>parsing</category><body package="HTTP" selector="parse:">parse: rfc822Scanner	| header entity line |	self initialize.	self action: #startEntity: with: nil.	line := self parseFirstLine: rfc822Scanner  nextLine.	line notNil		ifTrue: 			[self action: #startMessageLine: with: line. 			header := self action: #startHeader: with: nil.			self parseHeader: header from: rfc822Scanner.			entity := self action: #endHeader: with: header. 			entity source: rfc822Scanner asStream. 			self parseBody: entity body from: rfc822Scanner].	^self action: #endEntity: with: entity.</body><body package="HTTP" selector="parseFirstLine:">parseFirstLine: aString	| scanner fLine |	aString isEmpty 		ifTrue: [^HttpStatusLineError new				messageText: (#EmptyHttpResponseStatusLine &lt;&lt; #net &gt;&gt; 'Can not read external stream, returns empty the Http response status line') asString;				raiseSignal].	scanner := MimeScanner on: aString readStream.	fLine := ('http' match: scanner nextToken asLowercase)		ifTrue: 			[HttpResponseStatusLine readFrom: aString readStream]		ifFalse: 			[HttpRequestLine readFrom: aString readStream ].	(fLine isNil or: [ fLine isValid not ])		ifTrue: [ ^HttpEntityError new messageText: ((#WrongResponseStatusLine &lt;&lt; #net &gt;&gt; 'Wrong response status line: &lt;1s&gt;')			expandMacrosWith: fLine printString); raiseSignal ].	^fLine</body><body package="HTTP" selector="parseMultipartBody:from:">parseMultipartBody: aMultipartBody from: rfc82Scanner	" Build multipart body recursively "	aMultipartBody 		scanPartsFrom: rfc82Scanner 		useSourceStream: self useSourceStream		do: [ :sourceStream | | part |			self action: #startBodyPart: with: nil.			part := super parse: (self scannerOn: sourceStream).			self action: #endBodyPart: with: part.			part].</body><body package="HTTP" selector="parseSimpleBody:from:">parseSimpleBody: body from: rfc822Scanner 	^(( body parent isMemberOf: MimeEntity) not and: [ body parent isChunked ])		ifTrue: [ self parseSimpleChunkedBody: body from: rfc822Scanner]		ifFalse: [ super parseSimpleBody: body from: rfc822Scanner ]</body><body package="HTTP" selector="parseSimpleChunkedBody:from:">parseSimpleChunkedBody: body from: rfc822Scanner	| source length line |	source := rfc822Scanner asStream.	" Read chunks until we find 0-length chunk "	[line := source nextLine.	source atEnd not and: [line notNil and: [(length := Integer readFrom: line readStream radix: 16) &gt; 0]]]		whileTrue: 			[self action: #startBodyStream:length: with: source with: length.			source upTo: Character cr].	self parseHeader: body parent header from: rfc822Scanner</body></methods><methods><class-id>Net.HttpParser</class-id> <category>defaults</category><body package="HTTP" selector="encoder">encoder	^#ISO8859_1</body></methods><methods><class-id>Net.AcceptLanguageField</class-id> <category>adding language</category><body package="HTTP" selector="addLanguage:">addLanguage: cString  	self addValue: cString qValue: nil</body><body package="HTTP" selector="addLanguage:qValue:">addLanguage: cString qValue: qString 	self addValue: cString qValue: qString.</body></methods><methods><class-id>Net.AcceptLanguageField class</class-id> <category>parsing</category><body package="HTTP" selector="fieldNames">fieldNames	^#('accept-language')</body></methods><methods><class-id>Net.AcceptLanguageField class</class-id> <category>instant creation</category><body package="HTTP" selector="language:">language: cString 	^self language: cString qValue: nil</body><body package="HTTP" selector="language:qValue:">language: cString qValue: qString	^(self name: 'accept-language') 		addLanguage: cString qValue: qString;		yourself</body></methods><methods><class-id>Net.HttpRequest</class-id> <category>accessing</category><body package="HTTP" selector="headerOnly">headerOnly	^self requestLine headerOnly</body><body package="HTTP" selector="hostName">hostName	^self hostPortToConnect first</body><body package="HTTP" selector="messageLine">messageLine	^self requestLine</body><body package="HTTP" selector="messageLine:">messageLine: aRequestLine	self requestLine: aRequestLine</body><body package="HTTP" selector="method">method	^self requestLine method</body><body package="HTTP" selector="port">port	^self hostPortToConnect last</body><body package="HTTP" selector="protocol">protocol	^self requestLine protocol</body><body package="HTTP" selector="proxyRealm:username:password:">proxyRealm: rString username: unString password: pString	| code |	^(code := self class encodeUser: unString password: pString) notNil		ifTrue:[ self addProxyAuthorizationCode: rString, ' ', code ]		ifFalse: [ nil]</body><body package="HTTP" selector="proxyUsername:password:">proxyUsername: unString password: pString	^self proxyRealm: 'Basic' username: unString password: pString</body><body package="HTTP" selector="realm:username:password:">realm: rString username: unString password: pString	| code |	^(code := self class encodeUser: unString password: pString) notNil		ifTrue:[ self addAuthorizationCode: rString, ' ', code ]		ifFalse: [ nil]</body><body package="HTTP" selector="requestLine">requestLine	^requestLine</body><body package="HTTP" selector="requestLine:">requestLine: aRequestLine	requestLine := aRequestLine.</body><body package="HTTP" selector="url">url	^self requestLine hasAbsoluteURI		ifTrue: [self requestLine url ]		ifFalse: 	[self urlClass host: self host pathString: self requestLine path]</body><body package="HTTP" selector="url:">url: aURI	^self requestLine url: aURI</body><body package="HTTP" selector="urlClass">urlClass	^self class httpURLClass</body><body package="HTTP" selector="username:password:">username: unString password: pString	^self realm: 'Basic' username: unString password: pString</body><body package="HTTP" selector="version">version	^self requestLine version</body><body package="HTTP" selector="version:">version: aString	^self requestLine version: aString</body></methods><methods><class-id>Net.HttpRequest</class-id> <category>private</category><body package="HTTP" selector="hostPortToConnect">hostPortToConnect"1.If Request-URI is an absoluteURI, the host is part of the        Request-URI. Any Host header field value in the request MUST be        ignored.2. If the Request-URI is not an absoluteURI, and the request        includes a Host header field, the host is determined by the Host        header field value.3. If the host as determined by rule 1 or 2 is not a valid host on        the server, the response MUST be a 400 (Bad Request) error        message."	| host str port |	self requestLine hasAbsoluteURI		ifTrue: 			[ ^Array with: self requestLine host with: self requestLine port]		ifFalse:			[ (host := self host) ~~ nil				ifTrue: 					[ str := host readStream.					host := str upTo: $:.					(port := Number readFrom: str) = 0 ifTrue: [ port := nil].					^Array with: host with: port]].		HttpBadRequest new messageText: (#HostIsNotSpecified &lt;&lt; #net &gt;&gt; 'Host is not specified'); raiseSignal</body><body package="HTTP" selector="method:url:">method: aMethodString url: requestURI	requestLine := HttpRequestLine new					method: aMethodString; 					url: requestURI asURI;					yourself</body></methods><methods><class-id>Net.HttpRequest</class-id> <category>mandatory extensions</category><body package="HTTP" selector="extendedMethod">extendedMethod	^self requestLine extendedMethod</body></methods><methods><class-id>Net.HttpRequest</class-id> <category>accessing fields</category><body package="HTTP" selector="accept">accept	" Returns all AcceptFields "	^self fieldsAt: 'accept'</body><body package="HTTP" selector="accept:">accept: aStringOrAcceptField"Sets a value the parameter can be a string or instance of AcceptField"		(aStringOrAcceptField isKindOf: AcceptField)		ifTrue: 			[ self removeFieldAt: 'accept'.			self addField: aStringOrAcceptField]		ifFalse: [ (self getFieldAt: 'accept') addMedia: aStringOrAcceptField]</body><body package="HTTP" selector="acceptCharset">acceptCharset"Returns collection of AcceptCharsetFields"	^self fieldsAt: 'accept-charset'</body><body package="HTTP" selector="acceptCharset:">acceptCharset: aStringOrAcceptCharsetField"Sets a value the parameter can be a string or instance of AcceptCharsetField"		(aStringOrAcceptCharsetField isKindOf: AcceptCharsetField)		ifTrue: 			[ self removeFieldAt: 'accept-charset'.			self addField: aStringOrAcceptCharsetField]		ifFalse: [ (self getFieldAt: 'accept-charset') addCharset: aStringOrAcceptCharsetField]</body><body package="HTTP" selector="acceptEncoding">acceptEncoding	^self fieldValueAt: 'accept-encoding'</body><body package="HTTP" selector="acceptEncoding:">acceptEncoding: aStringOrCollection	(self getFieldAt: 'accept-encoding') value: aStringOrCollection</body><body package="HTTP" selector="acceptLanguage">acceptLanguage" Returns all AcceptLanguageFields "	^self fieldsAt: 'accept-language'</body><body package="HTTP" selector="acceptLanguage:">acceptLanguage: aStringOrAcceptLanguageField"Sets a value the parameter can be a string or instance of AcceptLanguage"		(aStringOrAcceptLanguageField isKindOf: AcceptLanguageField)		ifTrue: 			[ self removeFieldAt: 'accept-language'.			self addField: aStringOrAcceptLanguageField]		ifFalse: 			[ (self getFieldAt: 'accept-language') 				addLanguage: aStringOrAcceptLanguageField]</body><body package="HTTP" selector="addAuthorizationCode:">addAuthorizationCode: code	self authorization: code</body><body package="HTTP" selector="addProxyAuthorizationCode:">addProxyAuthorizationCode: code	self proxyAuthorization: code</body><body package="HTTP" selector="authorization">authorization	^self fieldValueAt: 'authorization'</body><body package="HTTP" selector="authorization:">authorization: aValue	(self getFieldAt: 'authorization') value: aValue</body><body package="HTTP" selector="host">host	^self fieldValueAt: 'host'</body><body package="HTTP" selector="host:">host: aString	(self getFieldAt: 'host') value: aString</body><body package="HTTP" selector="ifMatch">ifMatch	^self fieldValueAt: 'if-match'</body><body package="HTTP" selector="ifMatch:">ifMatch: aStringOrCollection	(self getFieldAt: 'if-match') value: aStringOrCollection</body><body package="HTTP" selector="ifModifiedSince">ifModifiedSince	^self fieldValueAt: 'if-modified-since'</body><body package="HTTP" selector="ifModifiedSince:">ifModifiedSince: aString	(self getFieldAt: 'if-modified-since') value: aString</body><body package="HTTP" selector="ifNoneMatch">ifNoneMatch	^self fieldValueAt: 'if-none-match'</body><body package="HTTP" selector="ifNoneMatch:">ifNoneMatch: aStringOrCollection	(self getFieldAt: 'if-none-match') value: aStringOrCollection</body><body package="HTTP" selector="ifRange">ifRange	^self fieldValueAt: 'if-range'</body><body package="HTTP" selector="ifRange:">ifRange: aString	(self getFieldAt:'if-range') value: aString</body><body package="HTTP" selector="ifUnModifiedSince">ifUnModifiedSince	^self fieldValueAt: 'if-unmodified-since'</body><body package="HTTP" selector="ifUnModifiedSince:">ifUnModifiedSince: aString	(self getFieldAt: 'if-unmodified-since') value: aString</body><body package="HTTP" selector="maxForwards">maxForwards	^self fieldValueAt: 'max-forwards'</body><body package="HTTP" selector="maxForwards:">maxForwards: aString	(self getFieldAt:  'max-forwards') value: aString</body><body package="HTTP" selector="proxyAuthorization">proxyAuthorization	^self fieldValueAt: 'proxy-authorization'</body><body package="HTTP" selector="proxyAuthorization:">proxyAuthorization: aString	(self getFieldAt:  'proxy-authorization' ) value: aString</body><body package="HTTP" selector="referer">referer	^self fieldValueAt: (#referer &lt;&lt; #net &gt;&gt; 'referer')</body><body package="HTTP" selector="referer:">referer: aString	(self getFieldAt: 'referer') value: aString</body><body package="HTTP" selector="userAgent">userAgent	^self fieldValueAt: 'user-agent'</body><body package="HTTP" selector="userAgent:">userAgent: aString	(self getFieldAt: 'user-agent') value: aString</body></methods><methods><class-id>Net.HttpRequest</class-id> <category>testing</category><body package="HTTP" selector="hasHostField">hasHostField	^self host notNil</body><body package="HTTP" selector="isValid">isValid	^(self requestLine isValid and: [ self host notNil])</body></methods><methods><class-id>Net.HttpRequest</class-id> <category>transfer encodings</category><body package="HTTP" selector="transferFieldOrder">transferFieldOrder" HTTP request  recommends field order (if present) to be as follows. Order for remaining fiedls does not matter "	^#('host')</body></methods><methods><class-id>Net.HttpRequest</class-id> <category>low-level command interface</category><body package="HTTP" selector="execute">execute" Create http client, connect, send request and answer HttpResponse "	^self newClient		executeRequest: self</body><body package="HTTP" selector="executeDo:">executeDo: aBlock" Create http client, connect, send request and pass http connection stream to the specified block "	^self newClient		executeRequest: self		do: aBlock.</body><body package="HTTP" selector="newClient">newClient	^HttpClient new		entityParsingOptions: self parsingOptions;		yourself</body></methods><methods><class-id>Net.HttpRequest class</class-id> <category>Http commands</category><body package="HTTP" selector="delete:">delete: urlString	^self method: 'DELETE' url: urlString</body><body package="HTTP" selector="get:">get: urlString	^self method: 'GET' url: urlString</body><body package="HTTP" selector="headers:">headers: urlString	^self method: 'HEAD' url: urlString</body><body package="HTTP" selector="post:">post: urlString	^self method: 'POST' url: urlString</body><body package="HTTP" selector="put:">put: urlString	^self method: 'PUT' url: urlString</body></methods><methods><class-id>Net.HttpRequest class</class-id> <category>defaults</category><body package="HTTP" selector="defaultContentType">defaultContentType	^MimeTypeDescriptor contentTypeHtml</body><body package="HTTP" selector="defaultHttpURLClass">defaultHttpURLClass	^HttpURL</body></methods><methods><class-id>Net.HttpRequest class</class-id> <category>instance creation</category><body package="HTTP" selector="method:url:">method: aMethodString url: requestURI	^self new 		method: aMethodString url: requestURI;		yourself</body></methods><methods><class-id>Net.HttpRequest class</class-id> <category>utilities</category><body package="HTTP" selector="encodeUser:password:">encodeUser: user password: password	| uncodedValue result |	uncodedValue := (user, ':', password) asByteArrayEncoding: #ISO8859_1.	result := (String new: 32) writeStream.	MimeScanner encode: uncodedValue readStream asBase64To: result.	^result contents</body></methods><methods><class-id>Net.HttpRequest class</class-id> <category>accessing</category><body package="HTTP" selector="httpURLClass">httpURLClass	^HttpURLClass isNil 		ifTrue: [ HttpURLClass := self defaultHttpURLClass ]		ifFalse: [ HttpURLClass ]</body><body package="HTTP" selector="httpURLClass:">httpURLClass: aClass	HttpURLClass := aClass</body></methods><methods><class-id>Net.HttpProxyExceptions class</class-id> <category>interface specs</category><body package="HTTP" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #AdvancedProxyOptions #defaultString: 'Advanced Proxy Options' #catalogID: #net) 			#min: #(#{Core.Point} 412 202 ) 			#max: #(#{Core.Point} 412 202 ) 			#bounds: #(#{Graphics.Rectangle} 512 384 924 586 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 21 8 398 161 ) 					#name: 'GroupBox1' 					#label: #(#{Kernel.UserMessage} #key: #Exceptions #defaultString: 'Exceptions' #catalogID: #net) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 317 168 398 191 ) 					#name:  'ActionButton1'					#model: #cancelHttpException 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #net) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 233 168 314 191 ) 					#name: 'ActionButton2'					#model: #acceptHttpExceptions 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #net) 					#defaultable: true ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.Rectangle} 31 45 387 136 ) 					#name:  'TextEditor1' 					#model: #httpProxyExceptions 					#tabRequiresControl: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 283 0 45 0 1 1 ) 					#name: 'Label1' 					#label: #(#{Kernel.UserMessage} #key: #DoNotUseProxyServersForDomains #defaultString: 'Do not use proxy servers for domains beginning with:' #catalogID: #net) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 217 0 158 0 1 1 ) 					#name:  'Label2' 					#label: #(#{Kernel.UserMessage} #key: #UseSemicolonSeparateDomains #defaultString: 'Use semicolon (;) to separate domains.' #catalogID: #net) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 233 168 314 191 ) 					#name:  'ActionButton3' 					#model: #acceptHttpExceptions 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #net) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Net.HttpPage class</class-id> <category>interface specs</category><body package="HTTP" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #HTTPSettings 				#defaultString: 'HTTP Settings' 				#catalogID: #net ) 			#min: #(#{Core.Point} 363 311 ) 			#max: #(#{Core.Point} 363 311 ) 			#bounds: #(#{Graphics.Rectangle} 512 384 875 695 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.241158 0 1.0 0 0.707395 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #ProxyConfiguration 						#defaultString: 'Proxy Configuration' 						#catalogID: #net ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.0275482 0 0.318328 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Address 						#defaultString: 'Address:' 						#catalogID: #net ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.0275482 0 0.414791 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Port 						#defaultString: 'Port:' 						#catalogID: #net ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.0275482 0 0.511254 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #ProxyUser 						#defaultString: 'Proxy User:' 						#catalogID: #net ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.0 0 0.0 ) 					#model: #httpKeepAlive 					#label: 					#(#{Kernel.UserMessage} 						#key: #KeepAliveConnection 						#defaultString: 'Keep Alive Connection' 						#catalogID: #net ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.0 0 0.0803858 ) 					#model: #redirectRequest 					#label: 					#(#{Kernel.UserMessage} 						#key: #RedirectRequest 						#defaultString: 'Redirect Request' 						#catalogID: #net ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.0 0 0.160772 ) 					#model: #httpUseProxy 					#label: 					#(#{Kernel.UserMessage} 						#key: #UseProxy 						#defaultString: 'Use Proxy' 						#catalogID: #net ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.275482 0 0.305466 0 0.972452 0 0.385852 ) 					#name: #proxyAddress 					#model: #httpHost ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.275482 0 0.401929 0 0.517906 0 0.482315 ) 					#name: #proxyPort 					#model: #httpPort 					#type: #number ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.275482 0 0.498392 0 0.972452 0 0.578778 ) 					#name: #proxyUserMenuAspect 					#model: #proxyUserMenuAspect 					#menu: #netUserMenu ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.517906 0 0.601286 0 0.741047 0 0.675241 ) 					#name: #addIdentityButton 					#model: #addIdentity 					#label: 					#(#{Kernel.UserMessage} 						#key: #AddUser 						#defaultString: 'Add User...' 						#catalogID: #net ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.746556 0 0.601286 0 0.969697 0 0.675241 ) 					#name: #advancedButton 					#model: #httpAdvanced 					#label: 					#(#{Kernel.UserMessage} 						#key: #Advandec 						#defaultString: 'Advanced...' 						#catalogID: #webservices ) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-netClient</category><body package="HTTP" selector="c02HttpEnableCookieProcessing">c02HttpEnableCookieProcessing	&lt;setting: #(net httpCookie enableCookieProcessing )&gt;	^(BooleanSetting on: Net.HttpClient aspect: #enableCookieProcessing)		label: #HttpEnableCookieProcessing&lt;&lt; #net &gt;&gt; 'Enable cookie processing';		default: Net.HttpClient defaultEnableCookieProcessing;		helpText: #HttpEnableCookieProcessingHelpText &lt;&lt; #net &gt;&gt; 'Specifies whether or not to process Http cookies'</body><body package="HTTP" selector="c1CacheCookies">c1CacheCookies	&lt;setting: #(net httpCookie cacheCookies )&gt;	^(BooleanSetting on: Net.CookieAgent aspect: #cacheCookies)		label: #HttpCacheCookies&lt;&lt; #net &gt;&gt; 'Enable cookie caching upon termination the session';		default: Net.CookieAgent defaultCacheCookies;		helpText: #HttpCacheCookiesHelpText &lt;&lt; #net &gt;&gt; 'Specifies whether or not to cache Http cookies when the Http session is terminated'</body><body package="HTTP" selector="c2UseCachedCookies">c2UseCachedCookies	&lt;setting: #(net httpCookie useCachedCookies )&gt;	^(BooleanSetting on: Net.CookieAgent aspect: #useCachedCookies)		label: #HttpUseCachedCookies&lt;&lt; #net &gt;&gt; 'Use cached cookies for the session';		default: Net.CookieAgent defaultUseCachedCookies;		helpText: #HttpUseCachedCookiesHelpText &lt;&lt; #net &gt;&gt; 'Specifies whether or not to use already cached cookies for each session'</body><body package="HTTP" selector="c3EnableLimits">c3EnableLimits	&lt;setting: #(net httpCookie enableLimits )&gt;	^(BooleanSetting on: Net.CookieAgent aspect: #enableLimits)		label: #HttpEnableLimits&lt;&lt; #net &gt;&gt; 'Enable verification limits while proccesing cookies';		default: Net.CookieAgent defaultEnableLimits;		helpText: #HttpEnableLimitsHelpText &lt;&lt; #net &gt;&gt; 'Specifies whether or not to check the registry limits for cookies'</body><body package="HTTP" selector="c4NumberRegistryEntries">c4NumberRegistryEntries	&lt;setting: #(net httpCookie numberRegistryEntries )&gt;	^(NumberSetting on: Net.CookieAgent aspect: #numberEntries)		label: #HttpNumberEntries&lt;&lt; #net &gt;&gt; 'Total amount of cookies';		default: Net.CookieAgent defaultNumberEntries;		helpText: #HttpNumberEntriesHelpText &lt;&lt; #net &gt;&gt; 'Specifies max number cookies stored in the registry'</body><body package="HTTP" selector="c5NumberEntriesPerServer">c5NumberEntriesPerServer	&lt;setting: #(net httpCookie numberEntriesPerServer )&gt;	^(NumberSetting on: Net.CookieAgent aspect: #numberEntriesPerServer)		label: #HttpNumberEntriesPerServer&lt;&lt; #net &gt;&gt; 'Number cookies per host';		default: Net.CookieAgent defaultNumberEntriesPerServer;		helpText: #HttpNumberEntriesPerServerHelpText &lt;&lt; #net &gt;&gt; 'Specifies max number of cookies per unique host stored in the registry'</body><body package="HTTP" selector="c6NumberBytesPerCookie">c6NumberBytesPerCookie	&lt;setting: #(net httpCookie numberBytesPerCookie )&gt;	^(NumberSetting on: Net.CookieAgent aspect: #numberBytesPerCookie)		label: #HttpNumberBytesPerCookie&lt;&lt; #net &gt;&gt; 'Number bytes per cookie';		default: Net.CookieAgent defaultNumberBytesPerCookie;		helpText: #HttpNumberBytesPerCookieHelpText &lt;&lt; #net &gt;&gt; 'Specifies max number bytes per cookie stored in the registry'</body><body package="HTTP" selector="c7ServersCacheCookiesFrom">c7ServersCacheCookiesFrom	&lt;settingsPage: #(net httpCookie serversCacheCookiesFrom)&gt; 	^(SequenceSettingPage new)		label: #CookieServers &lt;&lt; #labels &gt;&gt; 'Cookie Servers';		icon: (ListIconLibrary visualFor: #net);		listHolder:  Net.CookieAgent serversCacheCookiesFrom asValue		displayBlock: [ :value | value ] 		acceptBlock: [ :value | value ] ;		helpText: #HttpServersCacheCookiesFromHelpText &lt;&lt; #net &gt;&gt; 'Specifies list of servers to cache cookies from. Empty list means to store cookies from all servers'</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="HTTP" selector="httpCookiePage">httpCookiePage	&lt;settingsPage: #(net httpCookie)&gt;	^ModularSettingsPage new		label: #HttpCookie &lt;&lt; #net &gt;&gt; 'Http Cookie';		icon: (ListIconLibrary visualFor: #net);		settings: (self settingsWithPrefix: #(net httpCookie ))</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-netClient</category><body package="HTTP" selector="miscellaneous4DecodeContent">miscellaneous4DecodeContent	&lt;setting: #(net miscellaneous decodeContent)&gt;	^(BooleanSetting on: Net.HttpBuildHandler aspect: #decodeContents )		label: #decodeContents &lt;&lt; #net &gt;&gt; 'Decode http message using content-type charset';		default: Net.HttpBuildHandler defaultDecodeContents;		helpText: #decodeContentHelpText &lt;&lt; #net &gt;&gt; 'Specifies whether or not decode http message body using the charset from the content-type header field. If the option is set on the message body contents will include decoded data. Having the option off the body contents is row bytes as they were read from the socket stream'</body><body package="HTTP" selector="miscellaneous5RemoveContentEncoding">miscellaneous5RemoveContentEncoding	&lt;setting: #(net miscellaneous removeContentEncoding)&gt;	^(BooleanSetting on: Net.HttpBuildHandler aspect: #decompressContents )		label: #decompressContents &lt;&lt; #net &gt;&gt; 'Decompress http message in case of gzip content encoding';		default: Net.HttpBuildHandler defaultDecompressContents;		helpText: #removeContentEncodingHelpText &lt;&lt; #net &gt;&gt; 'Specifies whether or not decompress http message body if it has the header field - "content-encoding: gzip".If the option is set on the message body contents will include decompressed data. Having the option off the body contents is row bytes as they were read from the socket stream.'</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="HTTP" selector="netHttpPage">netHttpPage	&lt;settingsPage: #(net http)&gt;	^Net.HttpPage new		label: #HttpSettings &lt;&lt; #labels &gt;&gt; 'HTTP';		icon: (ListIconLibrary visualFor: #net)</body></methods><initialize><class-id>Net.HttpClient</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ExternalConnection</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inputDescriptor outputDescriptor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Streaming</category><attributes><package>OS-Streaming</package></attributes></class><class><name>IOBuffer</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>input output buffer bufferAmount </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Streaming</category><attributes><package>OS-Streaming</package></attributes></class><class><name>MessageDispatcher</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>NetworkResponse</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>code messageStream stream </inst-vars><class-inst-vars></class-inst-vars><imports>			Tools.*			</imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>SocketAccessor</name><environment>OS</environment><super>OS.BlockableIOAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>concreteClass </class-inst-vars><imports></imports><category>OS-Sockets</category><attributes><package>OS-Sockets</package></attributes></class><class><name>NetClient</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>user hostName portNumber clientPI retries timeout delaySeconds </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>URLwithAuthority</name><environment>Net</environment><super>Net.URLwithPath</super><private>false</private><indexed-type>none</indexed-type><inst-vars>host port </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><class><name>MessageBuildHandler</name><environment>Net</environment><super>Net.MessageHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>internalStream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>ValueWithParams</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>params separators value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>MessageParser</name><environment>Net</environment><super>Net.MessageDispatcher</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>StructuredHeaderField</name><environment>Net</environment><super>Net.HeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>ValueWithParametersField</name><environment>Net</environment><super>Net.StructuredHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>separators </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>CollectionField</name><environment>Net</environment><super>Net.StructuredHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>separator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>MessagePrintHandler</name><environment>Net</environment><super>Net.MessageHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>MimeMultipartEntity</name><environment>Net</environment><super>Net.MimeEntity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>Exception</name><environment>Core</environment><super>Core.GenericException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>NetSettingsPage</name><environment>Net</environment><super>Tools.SettingsManagerPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>userPreferences userListOwner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetConfigTool</package></attributes></class></st-source>