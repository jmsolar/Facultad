<?xml version="1.0"?><st-source><!-- Name: URISupportComment: Contains the Uniform Resource Identification (URI) framework. URIs allow one to represent and access resources.DevelopmentPrerequisites: #(#(#any 'NetNamespace' ''))HideSource: falsePackageName: URISupportPackageName:: URISupportParcel: #('URISupport')PrerequisiteParcels: #(#('NetNamespace' ''))SaveSource: trueVersion: 7.3.1Date: 11:33:00 am April 20, 2005 --><time-stamp>From VisualWorksÂ®, 7.3.1 of April 20, 2005 on April 20, 2005 at 11:33:00 am</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>URI</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><comment><class-id>Net.URI</class-id><body>URI represents a Uniform Resource Identifier, which is a standardized string representation of the address of data on the net. These can be broken down into URLs and URNs. In general, an URL specifies an address which specifically names the computer which supplies the resource, and an URN specifies an abstract name which must be resolved to a specific computer name by the client at runtime, but this distinction is not necessarily followed in detail by the various URI types in use.In this framework, only URLs have been implemented, since currently the design and implementation of URNs is in flux, and the infrastructure is not fully developed.Subclasses must implement the following messages:	accessing		asString		resource	stream creation		binaryReadStream		binaryWriteStream		readStreamDo:		writeStreamDo:Subclasses must implement the following class side messages:	accessing		protocol</body></comment><class><name>UriEncodedStreamConstructor</name><environment>Net</environment><super>Core.EncodedStreamConstructor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><comment><class-id>Net.UriEncodedStreamConstructor</class-id><body>This class supports composing the description of a stream (which is named by a URI) with its encoding and any other interesting attributes, then creating the stream.</body></comment><class><name>ComponentNotLoaded</name><environment>Net</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars>defaultValueBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><comment><class-id>Net.ComponentNotLoaded</class-id><body>ComponentNotLoaded exception will be raised when the Http or Ftp url is created and one of the component HTTP or FTP is not loaded.Instance Variables:	defaultValueBlock	&lt;aBlock&gt;	default value block</body></comment><class><name>URL</name><environment>Net</environment><super>Net.URI</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><comment><class-id>Net.URL</class-id><body>URL is a class which represents those URIs that, usually, explicitly or implicitly identify the host computer which supplies the named resource, as opposed to URNs which require the host computer to be resolved at runtime via an unspecified mechanism. However, there have been some URLs developed which do not explicitly identify the server, so that this distinction is not rigid. However, URNs begin with "urn:" and usually use : as the separator between fields, and URLs may or may not begin with "url:", and usually use / to separate fields.</body></comment><class><name>URLwithPath</name><environment>Net</environment><super>Net.URL</super><private>false</private><indexed-type>none</indexed-type><inst-vars>path query fragment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><comment><class-id>Net.URLwithPath</class-id><body>URLwithPath uses the general syntax "protocol://host/path", where path may be composed of multiple segments separated by /, and where the host is usually the DNS name of a computer, but in subclasses such as FtpURL, the host may be more complex.Subclasses must implement the following messages:	initialize		parseHost:Instance Variables:	fragment	&lt;String&gt;	When the URL contains #, what follows is an address to a specific location within the resource. The interpretation of the address depends on the MIME type of the resource.	path	&lt;Array of: String&gt;	The components of the path which tells the server where to find the resource	query	&lt;String&gt;	If the URL contains a ?, what follows is the argument for the resource. In this case, the assumption is that the resource is a program of some type, such as a CGI or a database query, and the query part of the URL specifies the arguments.</body></comment><class><name>FileURL</name><environment>Net</environment><super>Net.URLwithPath</super><private>false</private><indexed-type>none</indexed-type><inst-vars>missingSlashes host </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><comment><class-id>Net.FileURL</class-id><body>FileURL represents an URL with the protocol 'file:', representing a file on the local hard disk or, rarely, on another computer on the LAN. Accessing the resource is done by converting the URL to a Filename and opening the file.Instance Variables:	host	&lt;String | nil&gt;	File URL syntax ideally is file://host/path. Usually, the host is empty, and the file name starts with three / characters, but (especially on Windows) we support a non-empty host, which translates to file names of the form "\\host\path".	missingSlashes	&lt;Boolean&gt;	true if, when the URL was created, the syntax used was host file syntax, and false if the URL used the portable, platform independent syntax that uses / as the separator.</body></comment><class><name>URLwithAuthority</name><environment>Net</environment><super>Net.URLwithPath</super><private>false</private><indexed-type>none</indexed-type><inst-vars>host port </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><comment><class-id>Net.URLwithAuthority</class-id><body>URLwithAuthority is super class for URL subclasses that are supporting host and port protocol	server        = [ [ userinfo "@" ] hostport ]Subclasses must implement the following messages:	accessing		clientInstance Variables:	host	&lt;String&gt;	 host name	port		&lt;Number&gt;	 port number</body></comment><class><name>UnknownURLType</name><environment>Net</environment><super>Net.URL</super><private>false</private><indexed-type>none</indexed-type><inst-vars>protocol data </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><comment><class-id>Net.UnknownURLType</class-id><body>UnknownURLType is created when there is no URL class matching the protocol of a URI string. It can be manipulated to limited extents but cannot retrieve any data.Instance Variables:	data	&lt;String&gt;	 everything in the URL after the protocol	protocol	&lt;String&gt;	the data transfer protocol name requested</body></comment><shared-variable><name>AutoloadHttps</name><environment>Net.URI</environment><private>false</private><constant>false</constant><category>Autoload</category><initializer></initializer><attributes><package>URISupport</package></attributes></shared-variable><shared-variable><name>ProtocolToClassCache</name><environment>Net.URI</environment><private>false</private><constant>true</constant><category>Optimization</category><initializer>Dictionary new: 5</initializer><attributes><package>URISupport</package></attributes></shared-variable><shared-variable><name>AutoloadHttp</name><environment>Net.URI</environment><private>false</private><constant>false</constant><category>Autoload</category><initializer></initializer><attributes><package>URISupport</package></attributes></shared-variable><shared-variable><name>AutoloadFtp</name><environment>Net.URI</environment><private>false</private><constant>false</constant><category>Autoload</category><initializer></initializer><attributes><package>URISupport</package></attributes></shared-variable><methods><class-id>Net.URI</class-id> <category>comparing</category><body package="URISupport" selector="=">= aURI"Current implementation considers that two URLs:  '&lt;schema&gt;://example.com/pub'  and  '&lt;schema&gt;://example.com/pub/'  are not equivalent  as they behave differently with respect to: #resolvePath:"	^self class = aURI class		and: [self asString = aURI asString]</body><body package="URISupport" selector="hash">hash	^self asString hash</body><body package="URISupport" selector="sameAs:">sameAs:  aURI	^self = aURI</body></methods><methods><class-id>Net.URI</class-id> <category>accessing</category><body package="URISupport" selector="asString">asString	^self subclassResponsibility</body><body package="URISupport" selector="asURI">asURI	^self</body><body package="URISupport" selector="protocol">protocol	^self class protocol</body><body package="URISupport" selector="protocol:">protocol: p	"Ignored by those protocols that only go by one name."	^self</body><body package="URISupport" selector="resource">resource	^self subclassResponsibility</body></methods><methods><class-id>Net.URI</class-id> <category>stream creation</category><body package="URISupport" selector="binaryReadStream">binaryReadStream	"Create a binary readStream on the data that the URI accesses.	Some URIs such as MailTo will not support this."	^self subclassResponsibility</body><body package="URISupport" selector="binaryWriteStream">binaryWriteStream	"Create a binary readStream on the data that the URI accesses.	Some URIs such as MailTo will not support this."	^self subclassResponsibility</body><body package="URISupport" selector="readStream">readStream	^(self withEncoding: #default) readStream</body><body package="URISupport" selector="readStreamDo:">readStreamDo: aBlock	"Create a binary readStream on the data that the URI accesses.	Evaluate the block with the stream as the first argument, and with	a Dictionary as the second argument. The Dictionary will describe	any additional information that the protocol can supply about the	resource, such as its file extension (using the key #extension) or	its MIME type (using the key #MIME). This method is responsible	for closing the stream after the block ends, as well as any other	cleanup.	Some URIs such as MailTo will not support this."	^self subclassResponsibility</body><body package="URISupport" selector="withEncoding:">withEncoding: aStreamEncoderName	^UriEncodedStreamConstructor		on: self		encoding: aStreamEncoderName</body><body package="URISupport" selector="writeStream">writeStream	^(self withEncoding: #default) writeStream</body><body package="URISupport" selector="writeStreamDo:">writeStreamDo: aBlock	"Create a binary writeStream on the data that the URI accesses.	Evaluate the block with the stream as the argument. This method	is responsible for closing the stream after the block ends, as well	as any other cleanup.	Some URIs such as Http or News may not support this."	^self subclassResponsibility</body></methods><methods><class-id>Net.URI</class-id> <category>private</category><body package="URISupport" selector="copyFromFTP:">copyFromFTP: aURI	self copyFromURI: aURI</body><body package="URISupport" selector="copyFromURI:">copyFromURI: aURI	self writeStreamDo: [:dest |		aURI readStreamDo: [:src :parms |			[src atEnd] whileFalse:				[dest nextPutAll: (src nextAvailable: 1024)]]]</body><body package="URISupport" selector="escaped:">escaped: aString	^self class encode: aString</body></methods><methods><class-id>Net.URI</class-id> <category>utilities</category><body package="URISupport" selector="copyTo:">copyTo: aURI	aURI asURI copyFromURI: self</body></methods><methods><class-id>Net.URI</class-id> <category>resolution</category><body package="URISupport" selector="resolvePath:">resolvePath: path	(path includes: $:)		ifTrue: [^URI fromString: path]		ifFalse: [^self resolveRelativePath: path]</body><body package="URISupport" selector="resolveRelativePath:">resolveRelativePath: path	self error: ((#RelativePathsAreNotSupported &lt;&lt; #net &gt;&gt; 'Relative paths are not supported for the "&lt;1s&gt;" protocol') expandMacrosWith: self protocol)</body></methods><methods><class-id>Net.URI</class-id> <category>printing</category><body package="URISupport" selector="printOn:">printOn: aStream	| str |	str := [self asString] on: Error do: [:ex | ex return: nil].	str == nil		ifTrue: [super printOn: aStream]		ifFalse: [aStream nextPutAll: '&lt;', str, '&gt;'].</body><body package="URISupport" selector="printProtocolOn:">printProtocolOn: aStream	aStream nextPutAll: self protocol, '://'.</body></methods><methods><class-id>Net.URI class</class-id> <category>accessing</category><body package="URISupport" selector="allowedChar">allowedChar	^self unreservedChar, ';?:@&amp;=+$,'</body><body package="URISupport" selector="autoloadFtp">autoloadFtp	^AutoloadFtp isNil		ifTrue: [AutoloadFtp := false]		ifFalse: [ AutoloadFtp ]</body><body package="URISupport" selector="autoloadFtp:">autoloadFtp: aBoolean	AutoloadFtp := aBoolean</body><body package="URISupport" selector="autoloadHttp">autoloadHttp	^AutoloadHttp isNil		ifTrue: [AutoloadHttp := false]		ifFalse: [ AutoloadHttp ]</body><body package="URISupport" selector="autoloadHttp:">autoloadHttp: aBoolean	AutoloadHttp := aBoolean</body><body package="URISupport" selector="autoloadHttps">autoloadHttps	^AutoloadHttps isNil		ifTrue: [AutoloadHttps := false]		ifFalse: [ AutoloadHttps ]</body><body package="URISupport" selector="autoloadHttps:">autoloadHttps: aBoolean	AutoloadHttps := aBoolean</body><body package="URISupport" selector="classForProtocol:">classForProtocol: aProtocol	| prot class res | 	prot := aProtocol asLowercase. 	class := ProtocolToClassCache at: prot ifAbsent: [].	(class ~~ nil and: [class protocol = prot]) ifTrue:		[^class].	self allSubclasses do:		[:cls |		cls protocol = prot ifTrue: [^ProtocolToClassCache at: prot put: cls]].	^(res := self tryToLoad: aProtocol) isNil		ifTrue: [ UnknownURLType ]		ifFalse: [ res ]</body><body package="URISupport" selector="obsolete">obsolete	super obsolete.	self resetProtocolToClassCache.</body><body package="URISupport" selector="pathAllowedChars">pathAllowedChars	^self unreservedChar, ':@&amp;=+$,'</body><body package="URISupport" selector="protocol">protocol	^self subclassResponsibility</body><body package="URISupport" selector="reservedChar">reservedChar	^';/?:@&amp;=+$,'</body><body package="URISupport" selector="resetProtocolToClassCache">resetProtocolToClassCache	"(self resetProtocolToClassCache)"	ProtocolToClassCache keys do: [ :k | ProtocolToClassCache removeKey: k].</body><body package="URISupport" selector="unreservedChar">unreservedChar	^'-_.!~*''()'</body><body package="URISupport" selector="userAllowedChars">userAllowedChars	^self unreservedChar, ';:&amp;=+$,'</body></methods><methods><class-id>Net.URI class</class-id> <category>instance creation</category><body package="URISupport" selector="fromString:">fromString: aString	"Error checking is somewhat minimal at this time."	| index protocol data |	(aString includes: $:)		ifFalse: [self error: (#ThisURIDoesNotContainProtocol &lt;&lt; #net &gt;&gt; 'This URI does not contain a protocol.')].	index := aString indexOf: $:.	protocol := aString copyFrom: 1 to: index-1.	data := aString copyFrom: index+1 to: aString size.	^((self classForProtocol: protocol)		fromString: data)			protocol: protocol</body></methods><methods><class-id>Net.URI class</class-id> <category>testing</category><body package="URISupport" selector="hasUnsafeChars:allowed:">hasUnsafeChars: aString allowed: allowed	| cCode |	aString do: [:c |		cCode := c asInteger.		(cCode &gt;= 32 and: [cCode &lt;= 126 or: [allowed includes: c]])			ifFalse: [^true]].	^false</body><body package="URISupport" selector="shouldEncode:allowed:">shouldEncode: character allowed: allowed	^(allowed includes: character) not		and: [character isAlphaNumeric not ]</body></methods><methods><class-id>Net.URI class</class-id> <category>encoding/decoding</category><body package="URISupport" selector="decode:">decode: aString 	|str |	str := (String new: aString size) writeStream.	self decode: aString on: str.	^str contents</body><body package="URISupport" selector="decode:errorMessage:allowed:">decode: aString errorMessage: message allowed: allowed	^(self hasUnsafeChars: aString allowed: allowed)		ifTrue: [ self error: message ]		ifFalse: [self decode: aString]</body><body package="URISupport" selector="decode:on:">decode: aString on: stream	| oldStr ch |	oldStr := aString readStream.	[oldStr atEnd] whileFalse:		[ch := oldStr next.		self decodeChar: ch from: oldStr to: stream].	^stream contents</body><body package="URISupport" selector="decodeChar:from:to:">decodeChar: character from: stream to: outputStream	| n c1 |	n := 0.  	character = $%		ifTrue: 			[2 timesRepeat:				[c1 := stream next.				c1 == nil					ifTrue: [self error: (#IncompleteEscapeSequence &lt;&lt; #net &gt;&gt; 'Incomplete escape sequence')]					ifFalse:						[c1 := c1 digitValue.						(c1 between: 0 and: 15)							ifFalse: [self error: (#DidntFindHexadecimalDigit &lt;&lt; #net &gt;&gt; 'Didn''t find a hexadecimal digit')].						n := n * 16 + c1]].			outputStream nextPut: (Character value: n)]		ifFalse: [ outputStream nextPut: character]</body><body package="URISupport" selector="encode:">encode: aString	^self encode: aString  allowed: self allowedChar.</body><body package="URISupport" selector="encode:allowed:">encode: aString  allowed: allowed	| stream |	stream := (String new: aString size) writeStream.	self encode: aString on: stream allowed: allowed.	^stream contents</body><body package="URISupport" selector="encode:on:">encode: aString on: stream	self encode: aString  on: stream allowed: self allowedChar</body><body package="URISupport" selector="encode:on:allowed:">encode: aString  on: stream allowed: allowed	| hex ch |	hex := '01234567890abcdefABCDEF'.	1 to: aString size	  do: [:ind |		ch := aString at: ind.		((self shouldEncode: ch allowed: allowed)			and: [ (ch =$% and: [ ind + 2 &gt; aString size])				or: [	(ch = $% and: [(hex includes: (aString at: ind + 1))						and: [(hex includes: (aString at: ind + 2))]]) not]])			ifTrue: 				[stream nextPut: $%.				ch asInteger printOn: stream paddedWith: $0 to: 2 base: 16]			ifFalse: [stream nextPut: ch]].</body></methods><methods><class-id>Net.URI class</class-id> <category>private</category><body package="URISupport" selector="loadNetParcel:autoload:">loadNetParcel: aString autoload: aBoolean"FTP, HTTP and HTTPS parcels have to be in the ..\net directory"	(PortableFilename named: '$(VISUALWORKS)\net\', aString,'.pcl') exists		ifFalse: [^nil ].	^aBoolean		ifTrue: [ self loadParcel: aString ]		ifFalse: 				[ComponentNotLoaded newException					parameter: aString;					defaultValueBlock: [ self loadParcel: aString ];					makeSureResumable;					raiseSignal]</body><body package="URISupport" selector="loadParcel:">loadParcel: aString	^[	Parcel ensureLoadedParcel: aString  withVersion:  nil.      	self classForProtocol: aString	] on: Error	do: [ :ex |  ex return: nil ]</body><body package="URISupport" selector="tryToLoad:">tryToLoad: protocolString	( 'http' match: protocolString)		ifTrue: [ ^self loadNetParcel: 'HTTP' autoload: self autoloadHttp].	( 'https' match: protocolString)		ifTrue: [	^self loadNetParcel: 'HTTPS' autoload: self autoloadHttps].	( 'ftp' match: protocolString)		ifTrue: [ 	^self loadNetParcel: 'FTP' autoload: self autoloadFtp ].	^nil</body></methods><methods><class-id>Net.UriEncodedStreamConstructor</class-id> <category>streams</category><body package="URISupport" selector="appendStream">appendStream	"Answer a write stream connected to the file represented by	the receiver."	^self notImplemented</body><body package="URISupport" selector="newReadAppendStream">newReadAppendStream	"Answer a new readAppend stream connected to the file represented by	the receiver."	^self notImplemented</body><body package="URISupport" selector="newReadWriteStream">newReadWriteStream	"Answer a new readWrite stream connected to the file represented by	the receiver."	^self notImplemented</body><body package="URISupport" selector="readAppendStream">readAppendStream	"Answer a readAppend stream connected to the file represented by	the receiver."	^self notImplemented</body><body package="URISupport" selector="readStream">readStream	"Answer a read stream connected to the file represented by	the receiver."	^self addEncodingTo: dataRepository binaryReadStream</body><body package="URISupport" selector="readWriteStream">readWriteStream	"Answer a readWrite stream connected to the file represented by	the receiver."	^self notImplemented</body><body package="URISupport" selector="writeStream">writeStream	"Answer a write stream connected to the file represented by	the receiver."	^self addEncodingTo: dataRepository binaryWriteStream</body></methods><methods><class-id>Net.ComponentNotLoaded</class-id> <category>constants</category><body package="URISupport" selector="defaultResumeValue">defaultResumeValue	"Answer the default value to resume with."	^defaultValueBlock value</body></methods><methods><class-id>Net.ComponentNotLoaded</class-id> <category>accessing</category><body package="URISupport" selector="defaultValueBlock:">defaultValueBlock: aBlock	defaultValueBlock := aBlock</body></methods><methods><class-id>Net.ComponentNotLoaded</class-id> <category>printing</category><body package="URISupport" selector="defaultMessageText">defaultMessageText	^(#CannotCreateURL &lt;&lt; #net &gt;&gt; 'Can not create URL, &lt;1s&gt; parcel is not loaded') expandMacrosWith: self parameter</body></methods><methods><class-id>Net.ComponentNotLoaded class</class-id> <category>testing</category><body package="URISupport" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Net.URL</class-id> <category>printing</category><body package="URISupport" selector="printOn:">printOn: aStream	| str |	str := [self asString] on: Error do: [:ex | ex return: nil].	str == nil		ifTrue: [super printOn: aStream]		ifFalse: [aStream nextPutAll: '&lt;URL:', str, '&gt;'].</body></methods><methods><class-id>Net.URL class</class-id> <category>accessing</category><body package="URISupport" selector="protocol">protocol	^'url'</body></methods><methods><class-id>Net.URLwithPath</class-id> <category>resolution</category><body package="URISupport" selector="addComponent:">addComponent: aFileComponent	aFileComponent = '..' 		ifTrue:			[path isEmpty 				ifFalse: 					[path first ~= '..'						ifTrue: [path := path copyFrom: 1 to: (path size-1 max: 0)]						ifFalse: 	[self privateAddComponent: aFileComponent]]]		ifFalse: 	[self privateAddComponent: aFileComponent]</body><body package="URISupport" selector="construct:">construct:  aFileComponent	^self copy 		addComponent: aFileComponent;		yourself</body><body package="URISupport" selector="removeLastComponent">removeLastComponent	path := path copyFrom: 1 to: path size-1</body><body package="URISupport" selector="resolveRelativePath:">resolveRelativePath: pathString	| copy |	('//*' match: pathString) ifTrue: [^self class fromString: pathString].	self class 		resolvePath: pathString 		do: 			[ :pathx :queryx :fragmentx |			copy := self copy.			copy query: queryx; fragment: fragmentx.			pathx first isEmpty				ifTrue: 					[copy path: #().					pathx removeFirst]				ifFalse: [copy removeLastComponent].			pathx 				do: [ :each | 					copy addComponent: ( self class decode: each) ]].	^copy</body><body package="URISupport" selector="withComponent:">withComponent: component	"Create a new URL with the argument component appended.	The new component is assumed to be already URL-encoded."	| p |	p := (self path isEmpty not and: [self path last = ''])		ifTrue: [self path copyFrom: 1 to: self path size-1]		ifFalse: [self path].	^self copy		query: nil;		fragment: nil;		path: p;		addComponent: component</body><body package="URISupport" selector="withComponents:">withComponents: comps	"Create a new URL with the argument components appended.	The new components are assumed to be already URL-encoded."	| p uri |	p := (self path isEmpty not and: [self path last = ''])		ifTrue: [self path copyFrom: 1 to: self path size-1]		ifFalse: [self path].	uri := self copy		query: nil;		fragment: nil;		path: p.	comps do: [:s | uri addComponent: s].	^uri</body><body package="URISupport" selector="withSimpleComponent:">withSimpleComponent: comp	"Create a new URL with the argument component appended.	The new component has not yet been URL-encoded, and this	will be done before it is appended."	^self withComponent:  comp</body><body package="URISupport" selector="withSimpleComponents:">withSimpleComponents: comps	"Create a new URL with the argument component appended.	The new components have not yet been URL-encoded, and this	will be done before they are appended."	^self withComponents: comps</body></methods><methods><class-id>Net.URLwithPath</class-id> <category>utilities</category><body package="URISupport" selector="directory">directory	^self withComponent: '..'</body><body package="URISupport" selector="tail">tail	| index |	path isEmpty ifTrue: [^''].	index := path last = ''		ifTrue: [path size-1]		ifFalse: [path size].	index = 0 ifTrue: [^''].	^self pathAt: index</body></methods><methods><class-id>Net.URLwithPath</class-id> <category>accessing</category><body package="URISupport" selector="fragment">fragment	^fragment</body><body package="URISupport" selector="fragment:">fragment: f	fragment := f</body><body package="URISupport" selector="path">path	^path</body><body package="URISupport" selector="path:">path: aPath	path := aPath</body><body package="URISupport" selector="pathAt:">pathAt: index	| p |	p := path at: index.	^self simpleValidate: p		errorMessage: ((#InvalidPathComponent1s &lt;&lt; #net &gt;&gt; 'Invalid path component: &lt;1s&gt;') expandMacrosWith: p)		allowed: self class pathAllowedChars</body><body package="URISupport" selector="query">query	^query</body><body package="URISupport" selector="query:">query: q	query := q</body></methods><methods><class-id>Net.URLwithPath</class-id> <category>private</category><body package="URISupport" selector="guessMimeType">guessMimeType"To do move Net.MimeTypeDescriptor to base classes and return:  Net.MimeTypeDescriptor contentType: mimeType"	^(#{Net.MimeTypeDescriptor} valueOrDo: [nil]) isNil 		ifTrue: ['text/plain' ]		ifFalse: [Net.MimeTypeDescriptor guessFromExtension: self tail asFilename extension]</body><body package="URISupport" selector="privateAddComponent:">privateAddComponent: aFileComponent	path := path copyWith: 				(self class encode: aFileComponent  					allowed: self class pathAllowedChars)</body><body package="URISupport" selector="protocolSignals">protocolSignals</body><body package="URISupport" selector="safelyExecuteBlock:">safelyExecuteBlock: aBlock	^aBlock value</body><body package="URISupport" selector="simpleValidate:errorMessage:allowed:">simpleValidate: aString errorMessage: message allowed: allowed	^self class decode: aString errorMessage: message allowed: allowed</body><body package="URISupport" selector="storeExtrasOn:">storeExtrasOn: aStream	query == nil ifFalse: [aStream nextPutAll: '?', query].	fragment == nil ifFalse: [aStream nextPutAll: '#', fragment].</body><body package="URISupport" selector="validateHost:">validateHost: aString	| str parts |	str := self simpleValidate: aString		errorMessage: ((#InvalidHostName1s &lt;&lt; #net &gt;&gt; 'Invalid host name: &lt;1s&gt;') expandMacrosWith: aString)		allowed: ''.	str do: [:ch |		(ch isAlphaNumeric or: ['.-_' includes: ch])			ifFalse: [self error: ((#InvalidHostName1s &lt;&lt; #net &gt;&gt; 'Invalid host name: &lt;1s&gt;') expandMacrosWith: aString)]].	parts := str tokensBasedOn: $..	parts do: [:str1 |		str1 isEmpty			ifTrue: [self error: ((#InvalidHostName1s &lt;&lt; #net &gt;&gt; 'Invalid host name: &lt;1s&gt;') expandMacrosWith: aString)].		(str1 first = $- or: [str1 last = $-])			ifTrue: [self error: ((#InvalidHostName1s &lt;&lt; #net &gt;&gt; 'Invalid host name: &lt;1s&gt;') expandMacrosWith: aString)]].	^str</body><body package="URISupport" selector="validatePassword:">validatePassword: aString	| str |	str := self simpleValidate: aString		errorMessage: ((#InvalidPassword1s &lt;&lt; #net &gt;&gt; 'Invalid password: &lt;1s&gt;') expandMacrosWith: aString)		allowed: self class userAllowedChars.	^str</body><body package="URISupport" selector="validatePort:">validatePort: aString	| str port |	str := self simpleValidate: aString		errorMessage: ((#InvalidPort1s &lt;&lt; #net &gt;&gt; 'Invalid port: &lt;1s&gt;') expandMacrosWith: aString)		allowed: ''.	port := 0.	str do: [:c |		(c between: $0 and: $9)			ifTrue: [port := port * 10 + c digitValue]			ifFalse: [self error: ((#InvalidPort1s &lt;&lt; #net &gt;&gt; 'Invalid port: &lt;1s&gt;') expandMacrosWith: aString).]].	^port</body><body package="URISupport" selector="validateUser:">validateUser: aString	| str |	str := self simpleValidate: aString		errorMessage: ((#InvalidUser1s &lt;&lt; #net &gt;&gt; 'Invalid user: &lt;1s&gt;') expandMacrosWith: aString)		allowed: self class userAllowedChars.	^str</body></methods><methods><class-id>Net.URLwithPath</class-id> <category>comparing</category><body package="URISupport" selector="sameAs:">sameAs:  aURI"Current implementation considers that two URLs are equivalent only when their path size is equal and therefore the method returns false for URLs: '&lt;schema&gt;://example.com/pub'  and  '&lt;schema&gt;://example.com/pub/' "	self path size = aURI path size ifFalse: [^false].	1 to: self path size 		do: [ :ind |			(self pathAt: ind) = (aURI pathAt: ind ) ifFalse: [ ^false ]].	^true</body></methods><methods><class-id>Net.URLwithPath</class-id> <category>printing</category><body package="URISupport" selector="printPathOn:">printPathOn: aStream 	self path size = 0		ifTrue: [aStream nextPutAll: '/']		ifFalse: 			[1 to: self path size  do: [ :ind | aStream nextPutAll: '/', (self pathAt: ind)]].</body><body package="URISupport" selector="printPathStringOn:">printPathStringOn: aStream 	path size = 0		ifTrue: [aStream nextPutAll: '/']		ifFalse: [path do: [:s | aStream nextPutAll: '/', s]].</body></methods><methods><class-id>Net.URLwithPath class</class-id> <category>instance creation</category><body package="URISupport" selector="fromString:">fromString: aString	"Error checking is somewhat minimal at this time."	| index host path |	('//*' match: aString)		ifFalse: [self error: (#URLDoesNotBeginWithProtocol &lt;&lt; #net &gt;&gt; 'URL does not begin with "protocol://"')].	index := (3 to: aString size) detect: [:i | '/?#' includes: (aString at: i)] ifNone: [].	index = nil		ifTrue:			[host := aString copyFrom: 3 to: aString size.			path := '']		ifFalse:			[host := aString copyFrom: 3 to: index-1.			(aString at: index ) = $/				ifTrue: [path := aString copyFrom: index+1 to: aString size]				ifFalse: [path := aString copyFrom: index to: aString size]].	^self host: host pathString: path</body><body package="URISupport" selector="host:path:">host: aHost path: aPath	^(self newWithPath: aPath)		parseHost: aHost;		yourself</body><body package="URISupport" selector="host:pathString:">host: aHost pathString: aPath	^self 		resolvePath: aPath 		do: [:pList :qString :fString |			(self host: aHost path: pList)				query: qString;				fragment: fString;				yourself]</body><body package="URISupport" selector="newWithPath:">newWithPath: aCollection	^(self new 		path: (self encodePath: aCollection);		yourself)</body></methods><methods><class-id>Net.URLwithPath class</class-id> <category>accessing</category><body package="URISupport" selector="protocol">protocol	^nil</body></methods><methods><class-id>Net.URLwithPath class</class-id> <category>encoding/decoding</category><body package="URISupport" selector="encodePath:">encodePath: aCollection	^aCollection collect: 		[ :component | 	self encode: component  allowed: self pathAllowedChars ]</body></methods><methods><class-id>Net.URLwithPath class</class-id> <category>private</category><body package="URISupport" selector="resolvePath:do:">resolvePath: string do: aBlock	| pString idx frag query list |	pString := string.	(pString includes: $#)		ifTrue:			[idx := pString indexOf: $#.			frag := pString copyFrom: idx+1 to: pString size.			pString := pString copyFrom: 1 to: idx-1]		ifFalse: [frag := nil].	(pString includes: $?)		ifTrue:			[idx := pString indexOf: $?.			query := pString copyFrom: idx+1 to: pString size.			pString := pString copyFrom: 1 to: idx-1]		ifFalse: [query := nil].	list := pString tokensBasedOn: $/.	^aBlock value: list value: query value: frag.</body></methods><methods><class-id>Net.FileURL</class-id> <category>resolution</category><body package="URISupport" selector="addComponent:">addComponent: aFileComponent	self privateAddComponent: aFileComponent.	self normalize</body></methods><methods><class-id>Net.FileURL</class-id> <category>accessing</category><body package="URISupport" selector="asFilename">asFilename	| path2 fn |	^missingSlashes		ifTrue: [self path asFilename]		ifFalse:			[path2 := (1 to: path size) collect: [:i | self pathAt: i].			host == nil				ifTrue: [Filename rootComponents: path2]				ifFalse:					[fn := (Filename pathForRemoteHost: host) asFilename.					path2 do: [:s | fn := fn construct: (fn class decodePortableComponent: s)].					fn]]</body><body package="URISupport" selector="asFilename:">asFilename: filenameClass	"Useful for doing testing"	| path2 fn |	^missingSlashes		ifTrue: [filenameClass named: self path]		ifFalse:			[path2 := (1 to: path size) collect: [:i | self pathAt: i].			host == nil				ifTrue: [filenameClass rootComponents: path2]				ifFalse:					[fn := filenameClass named: (filenameClass pathForRemoteHost: host).					path2 do: [:s | fn := fn construct: (fn class decodePortableComponent: s)].					fn]]</body><body package="URISupport" selector="asString">asString	| str |	str := (String new: 64) writeStream.	^missingSlashes		ifTrue: [str nextPutAll: 'file:'; nextPutAll: self path asString.			self storeExtrasOn: str.			str contents]		ifFalse:			[str nextPutAll: 'file://'.			host == nil ifFalse: [str nextPutAll: host].			str nextPutAll: '/'.			path do: [:i | str nextPutAll: i] separatedBy: [str nextPutAll: '/'].			self storeExtrasOn: str.			str contents]</body><body package="URISupport" selector="host:">host: aHost	host := aHost</body><body package="URISupport" selector="missingSlashes:">missingSlashes: aBoolean	missingSlashes := aBoolean</body><body package="URISupport" selector="path:">path: aPath	super path: aPath.	missingSlashes := false</body><body package="URISupport" selector="resource">resource	^XML.InputSource		uri: self		encoding: nil		stream: (self asFilename withEncoding: #UTF_8) readStream lineEndTransparent</body></methods><methods><class-id>Net.FileURL</class-id> <category>stream creation</category><body package="URISupport" selector="binaryReadStream">binaryReadStream	^(self asFilename withEncoding: #binary) readStream</body><body package="URISupport" selector="binaryWriteStream">binaryWriteStream	^(self asFilename withEncoding: #binary) writeStream</body><body package="URISupport" selector="readStreamDo:">readStreamDo: aBlock	| stream params | 	stream := (self asFilename withEncoding: #binary) readStream.	params := Dictionary new.	params at: #MIME put: self guessMimeType.	^[aBlock value: stream value: params] ensure: [stream close]</body><body package="URISupport" selector="writeStreamDo:">writeStreamDo: aBlock	| stream  |	stream := (self asFilename withEncoding: #binary) writeStream.	^[aBlock value: stream] ensure: [stream close]</body></methods><methods><class-id>Net.FileURL</class-id> <category>utilities</category><body package="URISupport" selector="delete">delete	self asFilename delete</body><body package="URISupport" selector="fileSize">fileSize	^self asFilename fileSize</body><body package="URISupport" selector="makeDirectory">makeDirectory	self asFilename makeDirectory</body><body package="URISupport" selector="tail">tail	^self asFilename tail</body></methods><methods><class-id>Net.FileURL</class-id> <category>file utilities</category><body package="URISupport" selector="directoryContents">directoryContents	^self asFilename directoryContents		collect: [:s | self withSimpleComponent: s]</body></methods><methods><class-id>Net.FileURL</class-id> <category>testing</category><body package="URISupport" selector="exists">exists	^self asFilename exists</body><body package="URISupport" selector="isDirectory">isDirectory	^self asFilename isDirectory</body></methods><methods><class-id>Net.FileURL</class-id> <category>private</category><body package="URISupport" selector="normalize">normalize	2 to: path size do: [:i |		((path at: i) = '..' and: [(path at: i-1) ~= '.' and: [(path at: i-1) ~= '..']])			ifTrue:				[path := (path copyFrom: 1 to: i-2), (path copyFrom: i+1 to: path size).				^self normalize].		(path at: i) = '.'			ifTrue:				[path := (path copyFrom: 1 to: i-1), (path copyFrom: i+1 to: path size).				^self normalize]].</body></methods><methods><class-id>Net.FileURL class</class-id> <category>instance creation</category><body package="URISupport" selector="fromFilename:">fromFilename: aFilename	| p |	p := aFilename uriComponents.	^(p respondsTo: #key)		ifTrue: 			[ (self newWithPath: p value)					host: p key; 					yourself]		ifFalse:[self newWithPath: p]</body><body package="URISupport" selector="fromString:">fromString: aString	"Error checking is somewhat minimal at this time."	"Lame override of the superclass because tests	supplied by Sun to OASIS use wierd syntax with	file: protocol."	"This approach puts a String in the path, which	should only be a Filename. This is required to	avoid canonicalizing the file name, but results in	an URL that can do nothing other than answer	the string which created it."	('//*' match: aString)		ifFalse: [^self new path: aString; missingSlashes: true].	^super fromString: aString</body><body package="URISupport" selector="host:path:">host: aHost path: aPath	^(#('' 'localhost') includes: aHost)		ifTrue: [ self newWithPath: aPath]		ifFalse: [ (self newWithPath: aPath) host: aHost; yourself ]</body></methods><methods><class-id>Net.FileURL class</class-id> <category>accessing</category><body package="URISupport" selector="protocol">protocol	^'file'</body></methods><methods><class-id>Net.URLwithAuthority</class-id> <category>accessing</category><body package="URISupport" selector="asString">asString	| str |	str := (String new: 64) writeStream.	self printProtocolOn: str.	self printAuthorityOn: str.	^str contents</body><body package="URISupport" selector="client">client	^self subclassResponsibility</body><body package="URISupport" selector="defaultPortNumber">defaultPortNumber	^self class defaultPortNumber</body><body package="URISupport" selector="host">host	^host</body><body package="URISupport" selector="port">port	^port isNil 		ifTrue: [ port := self defaultPortNumber]		ifFalse: [ port ]</body></methods><methods><class-id>Net.URLwithAuthority</class-id> <category>comparing</category><body package="URISupport" selector="sameAs:">sameAs: aURI	^(super sameAs: aURI)		and: [ ( host match: aURI host )			and: [ self port = aURI port ]]</body></methods><methods><class-id>Net.URLwithAuthority</class-id> <category>initialize</category><body package="URISupport" selector="host:port:">host: aString port: aNumber	host := aString.	port := aNumber.</body><body package="URISupport" selector="parseHost:">parseHost: aHostSpecification	self parseHostPort: aHostSpecification</body><body package="URISupport" selector="parseHostPort:">parseHostPort: fullHost	| idx pString |	(fullHost includes: $:)		ifTrue:			[idx := fullHost indexOf: $:.			host := self validateHost: (fullHost copyFrom: 1 to: idx-1).			(pString := fullHost copyFrom: idx+1 to: fullHost size) isEmpty				ifTrue: [ port := self defaultPortNumber ]				ifFalse: [ port := self validatePort: pString ]]		ifFalse:			[host := self validateHost: fullHost.			port := self defaultPortNumber]</body></methods><methods><class-id>Net.URLwithAuthority</class-id> <category>printing</category><body package="URISupport" selector="printAuthorityOn:">printAuthorityOn: aStream	aStream nextPutAll: host.	self port ~= self defaultPortNumber ifTrue: [aStream nextPutAll: ':'; print: self port].	self printPathStringOn: aStream.	self storeExtrasOn: aStream.</body></methods><methods><class-id>Net.UnknownURLType</class-id> <category>accessing</category><body package="URISupport" selector="asString">asString	^protocol, ':', data</body><body package="URISupport" selector="extraData:">extraData: extraData	data := extraData</body><body package="URISupport" selector="protocol">protocol	^protocol</body><body package="URISupport" selector="protocol:">protocol: p	protocol := p</body><body package="URISupport" selector="resource">resource	^self error: (#UnrecognizedTransferProtocol &lt;&lt; #net &gt;&gt; 'Unrecognized transfer protocol')</body></methods><methods><class-id>Net.UnknownURLType class</class-id> <category>instance creation</category><body package="URISupport" selector="fromString:">fromString: aString	"Error checking is somewhat minimal at this time."	^self new extraData: aString</body></methods><methods><class-id>Net.UnknownURLType class</class-id> <category>accessing</category><body package="URISupport" selector="protocol">protocol	^nil</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="URISupport" selector="asURI">asURI	"Answer a URI named the receiver."	^Net.URI fromString: self string</body></methods><methods><class-id>OS.Filename class</class-id> <category>private</category><body package="URISupport" selector="decodePortableComponent:">decodePortableComponent: aString	"Translate portable path notation (which for example uses '..'	to represent the parent directory) into the host equivalent"	^aString</body></methods><methods><class-id>OS.Filename</class-id> <category>private</category><body package="URISupport" selector="uriComponents">uriComponents	| list |	list := (self class components: self asString) asArray.	self isRelative		ifTrue: [list := #('.'), list].	^list</body></methods><methods><class-id>OS.MacFilename class</class-id> <category>private</category><body package="URISupport" selector="decodePortableComponent:">decodePortableComponent: aString	"Translate portable path notation (which for example uses '..'	to represent the parent directory) into the host equivalent"	^aString = '..'		ifTrue: [':']		ifFalse: [aString]</body></methods><methods><class-id>OS.UnixFilename</class-id> <category>private</category><body package="URISupport" selector="uriComponents">uriComponents	"#('/' '/a/b/c' 'a/b/c' '../a/b')		collect: [:i || f |			f := (UnixFilename named: i).			f asString = (f asURI asFilename: UnixFilename) asString]"	| list |	list := super uriComponents.	list size = 0		ifFalse: [list first = '/'			ifTrue: [list := list copyFrom: 2 to: list size]].	^list</body></methods><methods><class-id>OS.PCFilename</class-id> <category>private</category><body package="URISupport" selector="uriComponents">uriComponents	"#('\' '\a\b\c' 'a\b\c' 'c:\a\b' '\\romulan' '\\romulan\'			'\\romulan\disk' '\\romulan\disk\' '\\romulan\disk\a' '..\a\b')		collect: [:i || f |			f := (PCFilename named: i).			f asString = (f asURI asFilename: PCFilename) asString]"	| list idx host |	list := super uriComponents.	list size = 0		ifFalse: [list first = '\'			ifTrue: [list := list copyFrom: 2 to: list size]			ifFalse: [('#:\' match: list first)				ifTrue: [list at: 1 put: (list first copyWithout: $\)]				ifFalse: [('\\*\*\' match: list first)					ifTrue:						[idx := list first nextIndexOf: $\ from: 3 to: list first size.						host := list first copyFrom: 3 to: idx-1.						list at: 1 put: (list first copyFrom: idx+1 to: list first size-1).						list := host -&gt; list]					ifFalse: [('\\*\' match: list first)					ifTrue:						[host := list first copyFrom: 3 to: list first size-1.						list := host -&gt; (list copyFrom: 2 to: list size)]]]]].	^list</body></methods><methods><class-id>OS.Filename class</class-id> <category>instance creation</category><body package="URISupport" selector="rootComponents:">rootComponents: path	"Answer a new Filename with the supplied path.	Unless the first element of the path explicitly specifies	the local directory as the starting point of the path, the	resulting name should be modified to be an absolute	path name. For portability, '.' will be used to specify	the local directory as the starting point, even though on	Mac OS and possibly others a different convention is	used. Using '.' allows the path to refer to relative path	names in a platform independent way."	| stream filename |	path isEmpty ifTrue: [^self concreteClass fromRootComponent: ''].	stream := path readStream.	filename := self concreteClass fromRootComponent: stream next.	[stream atEnd] whileFalse:		[filename := filename construct:				(self concreteClass decodePortableComponent: stream next)].	^filename</body></methods><methods><class-id>OS.MacFilename</class-id> <category>private</category><body package="URISupport" selector="uriComponents">uriComponents	"Some of the following examples will answer false, if the	MacFilename ends in a colon which can safely be removed,	the URI will remove that colon.	#('a:b:c' 'a:b:c:' ':a' 'a' ':a:b:c' ':a:b:c:' ':::a:b:c')		collect: [:i || f |			f := (MacFilename named: i).			f asString = (f asURI asFilename: MacFilename) asString]"	| list |	list := super uriComponents.	list size = 0		ifFalse:			[(list size &gt; 1 and: [list first = '.' and: [(list at: 2) = ':']])				ifTrue: [list := #('.'), (list copyFrom: 3 to: list size)].			list := list collect: [:s | s copyWithout: $:].			list replaceAll: '' with: '..'].	^list</body></methods><methods><class-id>OS.Filename</class-id> <category>converting</category><body package="URISupport" selector="asURI">asURI	^Net.FileURL fromFilename: self</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>EncodedStreamConstructor</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dataRepository encoding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Filename</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>osName publicName logicalName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>MacFilename</name><environment>OS</environment><super>OS.Filename</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Mac</category><attributes><package>OS-Mac</package></attributes></class><class><name>PCFilename</name><environment>OS</environment><super>OS.Filename</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-PC</category><attributes><package>OS-PC</package></attributes></class><class><name>UnixFilename</name><environment>OS</environment><super>OS.Filename</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Unix</category><attributes><package>OS-Unix</package></attributes></class><class><name>Exception</name><environment>Core</environment><super>Core.GenericException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>