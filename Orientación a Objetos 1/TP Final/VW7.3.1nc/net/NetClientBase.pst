<?xml version="1.0"?><st-source><!-- Name: NetClientBaseNotice: Copyright © 2005-1999 Cincom Systems, Inc.  All Rights Reserved.Comment: Provides the prerequsite namespace and core classes that are used in the Internet Connectivity Toolkit.If you want to load the Internet Connectivity Toolkit, you should load the NetClients package instead.DbIdentifier: bear73DbTrace: 53233DevelopmentPrerequisites: #(#(#any 'Blowfish' '') #(#any 'Tools-Settings-VW' '') #(#any 'LoggingTool' '') #(#any 'NetNamespace' ''))PackageName: NetClientBaseParcel: #('NetClientBase')ParcelName: NetClientBasePrerequisiteParcels: #(#('Blowfish' '') #('Tools-Settings-VW' '') #('LoggingTool' '') #('NetNamespace' ''))PrintStringCache: (7.4  0,tkogan)Version: 7.3.1Date: 6:44:40 pm April 10, 2005 --><time-stamp>From VisualWorks®, 7.3.1 of April 10, 2005 on April 10, 2005 at 6:44:40 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>MessageElement</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source parent value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.MessageElement</class-id><body>MessageElement is abstract class for MIME header and body components.Subclasses must implement the following messages:	parsing		parse:		parseBody:	private		doParse:Instance Variables:	parent	&lt;MimeEntity&gt;	the message body parent or mime entity parent if the message if multipart	source	&lt;Stream&gt;	the message source stream	value	&lt;MimeEntity|SimpleBody|MultipartBody&gt; the message value</body></comment><class><name>Base64StreamEncoder</name><environment>Net</environment><super>Core.ByteStreamEncoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>index nibble nEncoded </inst-vars><class-inst-vars>sextetMap octetMap </class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.Base64StreamEncoder</class-id><body>Base64StreamEncoder is used to encode and decode base64 formatInstance Variables:	index	&lt;Number&gt;	octet index 	nEncoded	&lt;ArithmeticValue&gt;	number of encoded octets	nibble	&lt;Integer&gt;	octet to encode or decode</body></comment><class><name>NonASCIICharException</name><environment>Net</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>NetClientBase</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.NonASCIICharException</class-id><body>NonASCIICharException is raised when a scanner detects non-ASCII character </body></comment><class><name>NetClientError</name><environment>Net</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.NetClientError</class-id><body>NetClientError is raised if there is a problem with connection to a mail server</body></comment><class><name>SimpleScanner</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source hereChar token tokenType saveComments currentComment classificationMask sourceTrailStream </inst-vars><class-inst-vars>classificationTable </class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.SimpleScanner</class-id><body>SimpleScanner is super class for all net scannersSubclasses must implement the following messages:	tokenization		nextTokenInstance Variables:	buffer	&lt;WriteStream&gt;	buffer	classificationMask	&lt;Integer&gt;	classification mask for the current character (hereChar)	currentComment	&lt;String&gt;	current comment	hereChar	&lt;Character&gt;	current character	lineEndCRLF	&lt;Number&gt;	 lineEndCRLF	saveComments	&lt;Boolean&gt;	defines whether or not to save comments	source	&lt;EncodedStream&gt;	stream to parse	sourceTrailStream	&lt;WriteStream&gt;	can hold a copy of parsed source if it is set on (#sourceTrailOn)	token	&lt;String&gt;	current token	tokenType	&lt;ByteSymbol&gt;	token type</body></comment><class><name>INIScanner</name><environment>Net</environment><super>Net.SimpleScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.INIScanner</class-id><body>INIScanner is used to parse *.ini files</body></comment><class><name>NetworkResponse</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>code messageStream stream </inst-vars><class-inst-vars></class-inst-vars><imports>			Tools.*			</imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.NetworkResponse</class-id><body>NetworkResponse is super class for a net response.Instance Variables:	code	&lt;String&gt;	response code	messageStream	&lt;Stream&gt;	a stream with the parsed response 	stream	&lt;SimpleScanner&gt;	stream the response is read from</body></comment><class><name>MailIncrementNotification</name><environment>Tools</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>endingCount </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Tools.MailIncrementNotification</class-id><body>The MailIncrementNotification is used in the DeliveryMonitor to report a mail delivery progress</body></comment><class><name>MimeTypeDescriptor</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contentType binary properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.MimeTypeDescriptor</class-id><body>MimeTypeDescriptor is used to set the Content-Type field for a MimeEntity. Instance Variables:	binary	&lt;Boolean&gt;	answers whether or not this type is binary	contentType	&lt;String&gt;	'type/subtype' string. Should be lowercase	properties	&lt;Dictionary&gt;	can hold additional description</body></comment><class><name>NetUser</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>username password fullName account savePassword mailAddress </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.NetUser</class-id><body>NetUser holds a client authentication informationInstance Variables:	account	&lt;String&gt;	account	fullName	&lt;String&gt;	full user name	mailAddress	&lt;String&gt;	mail address	password	&lt;String&gt;	password	savePassword	&lt;Boolean&gt;	defines whether or not to remember the password in the Net Settings	username	&lt;String&gt;	username</body></comment><class><name>UTF7StreamEncoder</name><environment>Net</environment><super>Net.Base64StreamEncoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>shifting </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.UTF7StreamEncoder</class-id><body>UTF7StreamEncoder is used to encode/decode UTF7 format</body></comment><class><name>NetClient</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>user hostName portNumber clientPI retries timeout delaySeconds </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.NetClient</class-id><body>NetClient is abstract class for net clients.Subclasses must implement the following messages:	accessing		protocolInterpreterClass	connection		isConnectedInstance Variables:	clientPI	&lt;IMAPProtocolInterpreter | FTPProtocolInterpreter&gt;	protocol interpreter	delaySeconds	&lt;Number&gt;	description of delaySeconds	hostName	&lt;String&gt;	the host to connect to	portNumber	&lt;Number&gt;	the host port number	retries	&lt;ArithmeticValue&gt;	number retries to connect	timeout	&lt;Number&gt;	number millisecond to timeout	user	&lt;NetUser&gt;	net user authorization information</body></comment><class><name>ErrorMessageBox</name><environment>Net</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>errorMessage titleString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>Settings</name><environment>Net</environment><super>Tools.GenericSettingDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>httpProxyHostAspect passwordKey </class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.Settings</class-id><body>Settings is a central repository for various preference items related to Internet Connectivity clients. The Setting class is the model for application model UISettings.Instance Variables:Shared Variables:	Registry	&lt;IdentityDictionary&gt;	holds all settings</body></comment><class><name>TimedPromise</name><environment>Net</environment><super>Kernel.Promise</super><private>false</private><indexed-type>none</indexed-type><inst-vars>delay ms </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.TimedPromise</class-id><body>A TimedPromise represents the same  value as a Promise does.  An attempt to read the value of a TimedPromise will wait until the process has finished computing it or the specified timeout expires.  If the process terminates with an exception, an attempt to read the value of the TimedPromise will raise the same exception. In case of the timeout the OsNeedRetryError will be raised.Instance Variables:	delay	&lt;Delay&gt;	TimedPromise is using the delay semaphore to tells the consumers there is information available	ms	&lt;Number&gt;	The number of milliseconds to create Delay</body></comment><class><name>StreamSegment</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source offset size position </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.StreamSegment</class-id><body>StreamSegment is used in stream scanners for parsing portions of streams. Instance Variables:	offset	&lt;SmallInteger&gt;	the parent stream position the segment starts from	position	&lt;SmallInteger&gt;	current segment position	size	&lt;SmallInteger&gt;	the segment size	source	&lt;Stream&gt;	the parent stream</body></comment><class><name>HostSpec</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name netUser type port </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.HostSpec</class-id><body>HostSpec describes a net server. Instance Variables:	name	&lt;String&gt;	the server name	netUser	&lt;NetUser&gt;	the user information to log in to the server	port	&lt;Number&gt;	the server port	type	&lt;String&gt;	the server type such as 'http'/'imap'</body></comment><class><name>NetRef</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.NetRef</class-id><body>NetRef is used to save/restore objects from the Net Settings</body></comment><shared-variable><name>MimeCharsetToEncodingMap</name><environment>Net.MimeTypeDescriptor</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>IdentityDictionary new</initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>MimeTypeRegistry</name><environment>Net.MimeTypeDescriptor</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>OrderedCollection new</initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>FileExtensionToMimeTypeMap</name><environment>Net.MimeTypeDescriptor</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>Dictionary new</initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>TokenMask</name><environment>Net.INIScanner</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>16384</initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>CommentChars</name><environment>Net.INIScanner</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>Array with: Character cr with: $# with: Character lf</initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>Encoder</name><environment>Net.Base64StreamEncoder</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>nil</initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>CRLF</name><environment>Net.SimpleScanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>Array with: Character cr with: Character lf</initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>NilMask</name><environment>Net.SimpleScanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>0</initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>CRLFMask</name><environment>Net.SimpleScanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>8</initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>Cr</name><environment>Net.SimpleScanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>Character cr</initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>AlphabeticMask</name><environment>Net.SimpleScanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>1</initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>EndOfLineMask</name><environment>Net.SimpleScanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>16</initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>WhiteSpaceMask</name><environment>Net.SimpleScanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>4</initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>Lf</name><environment>Net.SimpleScanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>Character lf</initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>DigitMask</name><environment>Net.SimpleScanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>2</initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>LastUser</name><environment>Net.NetUser</environment><private>false</private><constant>false</constant><category>local globals</category><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>Registry</name><environment>Net.Settings</environment><private>false</private><constant>false</constant><category>registry</category><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>DefaultRetries</name><environment>Net.NetClient</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>DefaultIncomingMailClient</name><environment>Net.NetClient</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>MailRegistry</name><environment>Net.NetClient</environment><private>false</private><constant>false</constant><category>mailRegistry</category><initializer></initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>DefaultDelaySeconds</name><environment>Net.NetClient</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>DefaultOutgoingMailClient</name><environment>Net.NetClient</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>DefaultTimeout</name><environment>Net.NetClient</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>NetClientBase</package></attributes></shared-variable><methods><class-id>Net.MessageElement</class-id> <category>parsing</category><body package="NetClientBase" selector="parse">parse	^self parse: (self scannerOn: self source)</body><body package="NetClientBase" selector="parse:">parse: scanner" Each message element has responsibility to parse itself. The argument is an appropriate scanner. Scanners for RFC822, Mime and HTTP messages are stream wrappers, so they can be used to read and tokenize input stream "	self subclassResponsibility</body><body package="NetClientBase" selector="parseBody:">parseBody: scanner	self subclassResponsibility</body><body package="NetClientBase" selector="readBodyFrom:">readBodyFrom: aStream" Each message element has responsibility to read itself from input stream. Reading usually involves parsing, so implementations of this method typically create an instance of lexical scanner and invoke a parser (see explanation for parse: method) "	self source: aStream.	^self parseBody: (self scannerOn: aStream)</body><body package="NetClientBase" selector="readFrom:">readFrom: aStream" Each message element has responsibility to read itself from input stream. Reading usually involves parsing, so implementations of this method typically create an instance of lexical scanner and invoke a parser (see explanation for parse: method) "	self source: aStream.	^self parse: (self scannerOn: aStream)</body><body package="NetClientBase" selector="scannerOn:">scannerOn: aStream" Each element should know what the underlying syntax is. For example, structured fields would mostly use MIME syntax and tokenize input streams into MIME 'tokens' while &lt;address-spec&gt; which is part of many standards, has to be tokenized using RFC822 syntax (using RFC822 'atoms') "	^self class scannerOn: aStream</body><body package="NetClientBase" selector="valueFrom:">valueFrom: aString " Swazoo compatibility"	^self readFrom: aString readStream</body></methods><methods><class-id>Net.MessageElement</class-id> <category>printing</category><body package="NetClientBase" selector="printLine:on:indent:">printLine: aString on: aStream indent: level	aStream 		tab: level;		nextPutAll: aString;		cr</body><body package="NetClientBase" selector="printOn:">printOn: aStream	self printOn: aStream indent: 0</body><body package="NetClientBase" selector="printOn:indent:">printOn: aStream indent: level	aStream tab: level</body><body package="NetClientBase" selector="storeOn:">storeOn: aStream 	self printOn: aStream</body></methods><methods><class-id>Net.MessageElement</class-id> <category>accessing</category><body package="NetClientBase" selector="clearSource">clearSource	source := nil</body><body package="NetClientBase" selector="parent">parent	^parent</body><body package="NetClientBase" selector="parent:">parent: anObject	parent := anObject</body><body package="NetClientBase" selector="source">source	^source</body><body package="NetClientBase" selector="source:">source: anObject	source := anObject</body><body package="NetClientBase" selector="sourceContents">sourceContents	^self source contents</body><body package="NetClientBase" selector="sourceSize">sourceSize	^self source size</body><body package="NetClientBase" selector="value">value	^self getValue</body><body package="NetClientBase" selector="value:">value: anObject	value := anObject</body></methods><methods><class-id>Net.MessageElement</class-id> <category>initialization</category><body package="NetClientBase" selector="initialize">initialize</body></methods><methods><class-id>Net.MessageElement</class-id> <category>visiting</category><body package="NetClientBase" selector="acceptVisit:with:">acceptVisit: aVisitor with: argument" Override by invoking appropriate message on the visitor "</body></methods><methods><class-id>Net.MessageElement</class-id> <category>copying</category><body package="NetClientBase" selector="postCopy">postCopy	super postCopy.	parent := nil.</body></methods><methods><class-id>Net.MessageElement</class-id> <category>private</category><body package="NetClientBase" selector="doParse:">doParse: rfc822Stream	self subclassResponsibility</body><body package="NetClientBase" selector="getValue">getValue	^(value isNil and: [self source notNil])		ifTrue: [[value := self doParse: (self scannerOn: self source)]				ensure: [self source close]]		ifFalse: [value]</body></methods><methods><class-id>Net.MessageElement</class-id> <category>composing</category><body package="NetClientBase" selector="sendOn:">sendOn: aStream	self writeOn: aStream</body><body package="NetClientBase" selector="writeOn:">writeOn: aStream" Writing can be different from printing. Printing may be indented, abbreviatedand otherwise formatted for readability. Writing is used to actually send message.Default implementation is the same "	self printOn: aStream</body></methods><methods><class-id>Net.MessageElement</class-id> <category>testing</category><body package="NetClientBase" selector="isAddressDescriptor">isAddressDescriptor	^false</body></methods><methods><class-id>Net.MessageElement class</class-id> <category>instance creation</category><body package="NetClientBase" selector="new">new	^super new initialize</body></methods><methods><class-id>Net.MessageElement class</class-id> <category>parsing</category><body package="NetClientBase" selector="fromLine:">fromLine: aString " For compatibility with Swazoo "	self subclassResponsibility</body><body package="NetClientBase" selector="readFrom:">readFrom: aStream" Each message element has responsibility to read itself from input stream. Reading usually involves parsing, so implementations of this method create an instance of lexical scanner and invoke a parser (see explanation for parse: method) "	^self new readFrom: aStream</body><body package="NetClientBase" selector="scannerOn:">scannerOn: aStream 	^(aStream isKindOf: self scannerType)		ifTrue: [aStream]		ifFalse: [self scannerType on: aStream asStream]</body><body package="NetClientBase" selector="scannerType">scannerType	self subclassResponsibility</body></methods><methods><class-id>Net.Base64StreamEncoder</class-id> <category>initialization</category><body package="NetClientBase" selector="initialize">initialize	super initialize.	self reset</body></methods><methods><class-id>Net.Base64StreamEncoder</class-id> <category>private</category><body package="NetClientBase" selector="charsToEncode">charsToEncode	^#(1 2 3 4) at: index + 1.</body><body package="NetClientBase" selector="charsToPad">charsToPad	^#(0 2 1 0) at: index + 1.</body><body package="NetClientBase" selector="index">index	^index</body><body package="NetClientBase" selector="nibble">nibble	^nibble</body><body package="NetClientBase" selector="padChar">padChar	^$= asInteger</body><body package="NetClientBase" selector="privateNextPut:on:">privateNextPut: int on: aStream	| length |	length := int digitLength.	length = 1 		ifTrue: [ self nextPutOctet: int on: aStream]		ifFalse: [ 1 to: length do: [ :idx | self nextPackOctet: (int digitAt: idx) ] ]</body><body package="NetClientBase" selector="reset">reset	index := 0.	nEncoded := 0.	nibble := 0.</body></methods><methods><class-id>Net.Base64StreamEncoder</class-id> <category>manipulating sextets</category><body package="NetClientBase" selector="fillNibbleFrom:">fillNibbleFrom: aStream	|  nSextets code enc |	enc := self class octetMap.	nibble := 0.	nSextets := 0.	1 to: 4 do: [ :idx |		aStream atEnd ifTrue: [ ^nSextets ].		code := aStream next.		(code isNil or: [ code == self padChar ]) ifTrue: [ ^nSextets ].		nibble := nibble bitOr: ((enc at: code ) bitShift: (self shiftValueAt: idx)).		nSextets := nSextets + 1.	].	^nSextets</body><body package="NetClientBase" selector="nextPutNibble:on:">nextPutNibble: ival on: aStream	| nchars code dec |	dec := self class sextetMap.	nchars := self charsToEncode.	1 to: nchars do: [ :idx |		code := ((ival bitAnd: (self sextetMaskAt: idx)) bitShift: (self shiftValueAt: idx) negated) bitAnd: 16r3f. 		aStream nextPut: ( dec at: (code + 1)).	].	self charsToPad timesRepeat: [ aStream nextPut: self padChar ].	self reset</body><body package="NetClientBase" selector="octetsToDecodeFromSextets:">octetsToDecodeFromSextets: nSextets	" Depending on how many characters was read from source stream, answer "	" how many octets can be decoded from these characters (nSextets is zero-based) "	^#(0 0 1 2 3 ) at: nSextets + 1</body><body package="NetClientBase" selector="sextetMaskAt:">sextetMaskAt: idx	^#(		2r111111000000000000000000		2r000000111111000000000000		2r000000000000111111000000		2r000000000000000000111111	) at: idx.</body><body package="NetClientBase" selector="shiftValueAt:">shiftValueAt: idx	^#( 18 12 6 0 ) at: idx.</body></methods><methods><class-id>Net.Base64StreamEncoder</class-id> <category>accessing</category><body package="NetClientBase" selector="nextFrom:">nextFrom: aStream	"Decode the next byte(s) in the stream and answer the code."	nEncoded = 0 ifTrue: [ self getNibbleFrom: aStream ].	^self nextUnpackOctet.</body><body package="NetClientBase" selector="nextPut:on:">nextPut: c on: aStream	| code |	((code := self encoder encode: c) &gt; 255 or: [ c &lt; 0 ])		ifTrue: [self noEncodingFor: c]		ifFalse: [ self privateNextPut: code on: aStream]</body><body package="NetClientBase" selector="prepareToClose:">prepareToClose: aStream	"If there are some conventions about the state of the file	at closing, prepare those conventions."	index &gt; 0 ifTrue: [		index to: 2 do: [ :idx | self nextPackOctet: 0 ].		self nextPutNibble: self nibble on: aStream.	]</body></methods><methods><class-id>Net.Base64StreamEncoder</class-id> <category>packing/unpacking octets</category><body package="NetClientBase" selector="getNibbleFrom:">getNibbleFrom: aStream	| nSextets |	nSextets := self fillNibbleFrom: aStream.	nEncoded := self octetsToDecodeFromSextets: nSextets.	index := 3.</body><body package="NetClientBase" selector="nEncoded">nEncoded	" Answer number of encoded octets "	^nEncoded</body><body package="NetClientBase" selector="nextPackOctet:">nextPackOctet: octet	nibble := (nibble bitShift: 8) bitOr: octet.</body><body package="NetClientBase" selector="nextPutOctet:on:">nextPutOctet: octet on: aStream	self nextPackOctet: octet.	index := index + 1.	index = 3 ifTrue: [ self nextPutNibble: nibble on: aStream ]</body><body package="NetClientBase" selector="nextUnpackOctet">nextUnpackOctet	"Decode the next byte(s) in the stream and answer the character."	| octet |	nEncoded = 0 ifTrue: [ ^nil ].	octet := nibble digitAt: index.	index := index - 1.	nEncoded := nEncoded - 1.	^octet</body></methods><methods><class-id>Net.Base64StreamEncoder class</class-id> <category>class initialization</category><body package="NetClientBase" selector="initialize">initialize	"Initialize class variables"	self initializeMaps.	self flushEncoderDirectory.</body><body package="NetClientBase" selector="initializeMaps">initializeMaps	| stream |	stream := ((ByteArray new: 64) withEncoding: #ASCII) writeStream.	stream nextPutAll: self sextetMapCharacters.	sextetMap := stream encodedContents.	octetMap := IdentityDictionary new.	1 to: sextetMap size		do: [ :idx | octetMap at: ( sextetMap at: idx) put: (idx -1)].</body></methods><methods><class-id>Net.Base64StreamEncoder class</class-id> <category>testing</category><body package="NetClientBase" selector="test1">test1	"self test1"	| stream |	" Encoding string as base64 "	stream := (ByteArray new withEncoding: #BASE64) writeStream.	stream nextPutAll: 'Aladdin:open sesame'.	stream close.	" Should be 'QWxhZGRpbjpvcGVuIHNlc2FtZQ==' "	^(stream encodedContents withEncoding: #ASCII) readStream contents</body><body package="NetClientBase" selector="test2">test2	"self test2"	| stream input output char |	" Decoding base64-encoded string "	input := 'QWxhZGRpbjpvcGVuIHNlc2FtZQ==' asByteArray readStream.	stream := EncodedStream on: input encodedBy: Base64StreamEncoder asEncoder.	output := (ByteArray new: 64) writeStream.	[ (char := stream next) notNil ] whileTrue: [ output nextPut: char ].	^(output contents withEncoding: #ASCII) readStream contents		" should be 'Aladdin:open sesame'. "</body><body package="NetClientBase" selector="test3">test3	" self test3 "	| output stream input unistr base64str stream1 result char unistr1 stream2 |" Test encoding/decoding Unicode strings as base64. We take regular string 'Aladdin:open sesame', encode it as Unicode bytes (byte array) and then encodeUnicode bytes as base64. Then the process is reverted: base64-encoded stringis decoded back into Unicode byte array which is then decoded back into the original string "	output := (ByteArray new: 64) writeStream.	stream := EncodedStream on: output encodedBy: UnicodeStreamEncoder asEncoder. " Default string-&gt;Unicode encoder "	stream nextPutAll: 'Aladdin:open sesame'.	stream close.						" This is needed to flush byte buffer "	unistr := output contents.			" Unicode bytes "	output := (ByteArray new: 64) writeStream.	stream := EncodedStream on: output encodedBy: ((Base64StreamEncoder asEncoder) encoder: UnicodeCharacterEncoder new; yourself).	" Unicode bytes-&gt;base64 encoder "	stream nextPutAll: unistr.				stream close.						" This is needed to flush byte buffer "	base64str := output contents.	" base64-encoded string "	input := base64str readStream.		stream1 := EncodedStream on: input encodedBy: 	" Base64-&gt;Unicode decoder "								((Base64StreamEncoder asEncoder) encoder: UnicodeCharacterEncoder new; yourself).	result := (ByteArray new: 64) writeStream.	[ (char := stream1 next) notNil ] whileTrue: [ result nextPut: char ].		" Convert from base64 to Unicode "	unistr1 := result contents. 	" should be 'Aladdin:open sesame' in Unicode as byte array "	stream2 := EncodedStream on: unistr1 readStream encodedBy: UnicodeStreamEncoder asEncoder.	" Unicode-&gt;default string decoder "	^stream2 upToEnd.					" should be 'Aladdin:open sesame'. "</body></methods><methods><class-id>Net.Base64StreamEncoder class</class-id> <category>accesing</category><body package="NetClientBase" selector="octetMap">octetMap	^octetMap</body><body package="NetClientBase" selector="sextetMap">sextetMap	^sextetMap</body><body package="NetClientBase" selector="streamEncodingType">streamEncodingType	^#BASE64</body></methods><methods><class-id>Net.Base64StreamEncoder class</class-id> <category>private</category><body package="NetClientBase" selector="characterSet">characterSet	^'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'</body><body package="NetClientBase" selector="defaultCharacterEncoder">defaultCharacterEncoder	^String defaultPlatformClass encoder</body><body package="NetClientBase" selector="sextetMapCharacters">sextetMapCharacters	^'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'</body></methods><methods><class-id>Net.NetClientError class</class-id> <category>signalling</category><body package="NetClientBase" selector="signalWith:message:">signalWith: aParameter message: aString	"Raise an an exception with parameter set to aParameter and message set to aString."	^self new 		searchFrom: thisContext sender;		originator: thisContext sender homeReceiver;		parameter: aParameter;		messageText: aString;		raiseSignal.</body></methods><methods><class-id>Net.SimpleScanner</class-id> <category>stream interface -- reading</category><body package="NetClientBase" selector="atEnd">atEnd	^source atEnd</body><body package="NetClientBase" selector="binary">binary	source binary</body><body package="NetClientBase" selector="contents">contents	^source contents</body><body package="NetClientBase" selector="contentsSpecies">contentsSpecies	^((source respondsTo: #isBinary) and:[source isBinary])		ifTrue: [ByteArray]		ifFalse: [String]</body><body package="NetClientBase" selector="next">next	self hereChar: source next.	self sourceTrailNextPut: hereChar.	^hereChar</body><body package="NetClientBase" selector="next:">next: anInteger 	"Answer the next anInteger elements of the receiver."	| newCollection res |	newCollection := self contentsSpecies new: anInteger.	res := self next: anInteger into: newCollection startingAt: 1.	self sourceTrailNextPutAll: res.	^res</body><body package="NetClientBase" selector="next:into:startingAt:">next: anInteger into: aSequenceableCollection startingAt: startIndex 	"Store the next anInteger elements of the receiver into aSequenceableCollection 	starting at startIndex in aSequenceableCollection. Answer aSequenceableCollection."	| index stopIndex |	index := startIndex.	stopIndex := index + anInteger.	[[index &lt; stopIndex and: [self atEnd not ]]				whileTrue: [aSequenceableCollection at: index put: source next.							index := index + 1]]		on: Stream endOfStreamSignal		do: 			[:ex | ex retryUsing:					[(Stream incompleteNextCountSignal newExceptionFrom: self)						parameter: index - startIndex;						raiseRequest]].	^aSequenceableCollection</body><body package="NetClientBase" selector="nextLine">nextLine	^self scanUntil: [ self matchCharacterType: CRLFMask ]</body><body package="NetClientBase" selector="nextLineWithoutTerminator">nextLineWithoutTerminator" Answer next line. Do not inlude cr. Stream is positioned before terminating cr "	^self scanWhile: [ (self matchCharacterType: CRLFMask) not ].</body><body package="NetClientBase" selector="peek">peek	"Answer what would be returned with a self next, without	changing position.  If the receiver is at the end, answer nil."	| nextObject |	self atEnd ifTrue: [^nil].	nextObject := source next.	source skip: -1.	^nextObject</body><body package="NetClientBase" selector="peekFor:">peekFor: anObject 	"Answer false and do not move the position if self next ~= anObject or if the	receiver is at the end. Answer true and increment position if self next = anObject."	| nextObject |	self atEnd ifTrue: [^false].	nextObject := self next.	"peek for matching element"	anObject = nextObject ifTrue: [^true].	"gobble it if found"	self stepBack.	^false</body><body package="NetClientBase" selector="position">position	^source position</body><body package="NetClientBase" selector="position:">position: anInt	source position: anInt</body><body package="NetClientBase" selector="skip:">skip: integer	source skip: integer.	self sourceTrailSkip: integer.</body><body package="NetClientBase" selector="text">text	^source text</body><body package="NetClientBase" selector="throughAll:">throughAll: pattern	| str |	str := source throughAll: pattern.	self sourceTrailNextPutAll: str.	^str</body><body package="NetClientBase" selector="upTo:">upTo: anObject	"Answer a subcollection from position to the occurrence (if any, exclusive) of anObject.	 The stream is left positioned after anObject.	If anObject is not found answer everything."	| newStream element |	newStream := (self contentsSpecies new: 64) writeStream.	[self atEnd]		whileFalse:			[element := self next.			element = anObject				ifTrue: [^newStream contents].			newStream nextPut: element.].	^newStream contents</body><body package="NetClientBase" selector="upToAll:">upToAll: pattern 	| str |	str := source upToAll: pattern.	self sourceTrailNextPutAll: str.	^str</body><body package="NetClientBase" selector="upToEnd">upToEnd	| str |	str := source upToEnd.	self sourceTrailNextPutAll: str.	^str</body></methods><methods><class-id>Net.SimpleScanner</class-id> <category>expression types</category><body package="NetClientBase" selector="classificationMaskFor:">classificationMaskFor: charOrNil 	^self class classificationMaskFor: charOrNil</body><body package="NetClientBase" selector="matchCharacterType:">matchCharacterType: mask	^self classificationMask anyMask: mask</body><body package="NetClientBase" selector="mustMatch:">mustMatch: char	^self mustMatch: char notify: [self expected: (String with: char)]</body><body package="NetClientBase" selector="mustMatch:notify:">mustMatch: char notify: message	self skipWhiteSpace.	(self next == char)		ifFalse: [self notify: message]</body><body package="NetClientBase" selector="scanTokenMask:">scanTokenMask: tokenMask 	"Scan token based on character mask. Answers token's value. Stream is positioned before trhe character that terminated scan"	^self scanWhile: [self matchCharacterType: tokenMask]</body><body package="NetClientBase" selector="scanUntil:">scanUntil: aNiladicBlock 	^self scanUntil: aNiladicBlock do: [:stream :char | stream nextPut: char]</body><body package="NetClientBase" selector="scanUntil:do:">scanUntil: aNiladicBlock do: actionBlock	"Scan token using a block until match is found. At the end of scan the stream is positioned after the 	matching character. Answers token value"	| stream |	stream := (String new: 64) writeStream.		[self atEnd		ifTrue: 			[self hereChar: nil.			^stream contents].	self step.	aNiladicBlock value]		whileFalse: [actionBlock value: stream value: hereChar].	^stream contents</body><body package="NetClientBase" selector="scanWhile:">scanWhile: aNiladicBlock 	"Scan token using a block. At the end of scan the stream is positioned at the first character that does not match. hereChar is nil. Answers token value"	| str |	str := self scanUntil: [ aNiladicBlock value not ].	hereChar notNil ifTrue: [ self stepBack ].	^str</body><body package="NetClientBase" selector="scanWhile:do:">scanWhile: aNiladicBlock do: actionBlock	"Scan token using a block. At the end of scan the stream is positioned at the first character that does not match. hereChar is nil. Answers token value"	| str |	str := self scanUntil: [ aNiladicBlock value not ] do: actionBlock.	hereChar notNil ifTrue: [ self stepBack ].	^str</body><body package="NetClientBase" selector="step">step	^self next.</body><body package="NetClientBase" selector="stepBack">stepBack	self skip: -1.</body></methods><methods><class-id>Net.SimpleScanner</class-id> <category>accessing</category><body package="NetClientBase" selector="classificationMask">classificationMask	^classificationMask</body><body package="NetClientBase" selector="currentComment">currentComment	^currentComment</body><body package="NetClientBase" selector="hereChar">hereChar	^hereChar</body><body package="NetClientBase" selector="hereChar:">hereChar: char	hereChar := char.	classificationMask := self classificationMaskFor: hereChar</body><body package="NetClientBase" selector="saveComments">saveComments	^saveComments</body><body package="NetClientBase" selector="saveComments:">saveComments: aValue	saveComments := aValue</body><body package="NetClientBase" selector="size">size	^source size</body><body package="NetClientBase" selector="source">source	^source</body><body package="NetClientBase" selector="source:">source: aStreamSegment	source := aStreamSegment</body><body package="NetClientBase" selector="stream">stream	^source stream</body><body package="NetClientBase" selector="token">token	^token</body><body package="NetClientBase" selector="tokenType">tokenType	^tokenType</body></methods><methods><class-id>Net.SimpleScanner</class-id> <category>source trail</category><body package="NetClientBase" selector="sourceTrail">sourceTrail	| res |	sourceTrailStream notNil ifTrue: [res := sourceTrailStream contents].	sourceTrailStream := nil.	^res</body><body package="NetClientBase" selector="sourceTrailNextPut:">sourceTrailNextPut: char 	(sourceTrailStream notNil and: [char notNil])		ifTrue: [sourceTrailStream nextPut: char]</body><body package="NetClientBase" selector="sourceTrailNextPutAll:">sourceTrailNextPutAll: string	(sourceTrailStream notNil and: [string notNil])		ifTrue: [sourceTrailStream nextPutAll: string]</body><body package="NetClientBase" selector="sourceTrailOff">sourceTrailOff	sourceTrailStream := nil</body><body package="NetClientBase" selector="sourceTrailOn">sourceTrailOn	sourceTrailStream := (String new: 64) writeStream.</body><body package="NetClientBase" selector="sourceTrailSkip:"> sourceTrailSkip: integer	sourceTrailStream notNil		ifTrue: [sourceTrailStream skip: integer]</body></methods><methods><class-id>Net.SimpleScanner</class-id> <category>instance creation</category><body package="NetClientBase" selector="asStream">asStream	^source</body><body package="NetClientBase" selector="from:to:">from: start to: end	^self newSize: end - start startingAt: start</body><body package="NetClientBase" selector="newSize:">newSize: size	^self species on: (self asStream newSize: size )</body><body package="NetClientBase" selector="newSize:startingAt:">newSize: sizeNumber startingAt: aNumber 	^self species on: (self asStream newSize: sizeNumber startingAt: aNumber)</body></methods><methods><class-id>Net.SimpleScanner</class-id> <category>tokenization</category><body package="NetClientBase" selector="nextToken">nextToken	self subclassResponsibility</body><body package="NetClientBase" selector="nextTokenAsAssociation">nextTokenAsAssociation" Read next token and and answer tokenType-&gt;token "	self nextToken.	^tokenType-&gt;token</body><body package="NetClientBase" selector="scanToken:delimitedBy:notify:">scanToken: aNiladicBlock delimitedBy: anArray notify: errorMessageString " Scan next lexical token based on the criteria defined by NiladicBlock. The block is evaluated for every character read from input stream until it yields false. Stream is positioned before character that terminated scan""Example: self scanToken: [ self scanQuotedChar; matchCharacterType: DomainTextMask ] 	delimitedBy: '[]' notify: 'Malformed domain text'."	| string |	self mustMatch: anArray first.	string := self scanWhile: aNiladicBlock.	self mustMatch: anArray last notify: errorMessageString.	^string</body><body package="NetClientBase" selector="scanTokens:">scanTokens: textOrString 	"Answer with an Array which has been tokenized"	^self on: (ReadStream on: textOrString asString); tokenize.</body><body package="NetClientBase" selector="tokenize">tokenize	| s |	s := WriteStream on: (Array new: 16).	[self nextToken. tokenType = #doIt]		whileFalse: [s nextPut: token].	^s contents</body><body package="NetClientBase" selector="tokenizeList:separatedBy:">tokenizeList: aBlock separatedBy: comparisonBlock" list = token *( separator token) "	| stream block v |	stream := (Array new: 4) writeStream.	block := [(v := aBlock value) notNil ifTrue: [stream nextPut: v]].	block value.									" Evaluate for the first element "	self tokenizeWhile: [comparisonBlock value ] do: block.	^stream contents</body><body package="NetClientBase" selector="tokenizeUntil:do:">tokenizeUntil: aBlock do: actionBlock	[self skipWhiteSpace. self position. self nextToken. tokenType == #doIt or: aBlock]		whileFalse:  			[actionBlock value].</body><body package="NetClientBase" selector="tokenizeWhile:">tokenizeWhile: aBlock	| s |	s := WriteStream on: (Array new: 16).	self tokenizeWhile: [aBlock value]		do: [s nextPut: token].	^s contents</body><body package="NetClientBase" selector="tokenizeWhile:do:">tokenizeWhile: aBlock do: actionBlock 	| pos |		[self skipWhiteSpace.	pos := self position.	self nextToken.	tokenType ~= #doIt and: aBlock value]		whileTrue: [actionBlock value].	self position: pos	"Reset position to the beginning of the token that did not match"</body></methods><methods><class-id>Net.SimpleScanner</class-id> <category>error handling</category><body package="NetClientBase" selector="expected:">expected: aString 	"Notify that there is a problem at current token."	^ self notify: ((#expected &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; expected')expandMacrosWith: aString)</body><body package="NetClientBase" selector="notify:">notify: string	"Subclasses may wish to override this"	self error: string</body><body package="NetClientBase" selector="offEnd:">offEnd: aString 	"Parser overrides this"	^self notify: aString</body></methods><methods><class-id>Net.SimpleScanner</class-id> <category>initialize-release</category><body package="NetClientBase" selector="initialize">initialize	saveComments := true.	self hereChar: nil</body><body package="NetClientBase" selector="on:">on: inputStream 	"Bind the input stream"	self hereChar: nil.	self source: inputStream asStream</body><body package="NetClientBase" selector="on:from:to:">on: inputStream from: startPositionNumber to: sizeNumber 	self on: (StreamSegment			on: inputStream asStream			offset: startPositionNumber			size: sizeNumber)</body><body package="NetClientBase" selector="scan:">scan: inputStream 	"Bind the input stream, fill the character buffers and first token buffer"	self on: inputStream.	^self nextToken</body></methods><methods><class-id>Net.SimpleScanner</class-id> <category>sunit test helpers</category><body package="NetClientBase" selector="testScanTokens">testScanTokens	| s st |	s := WriteStream on: (Array new: 16).	st  := WriteStream on: (Array new: 16).	[tokenType = #doIt]		whileFalse: 			[s nextPut: token. st nextPut: tokenType.			self nextToken].	^Array with: s contents with: st contents</body><body package="NetClientBase" selector="testScanTokens:">testScanTokens: textOrString 	"Answer with an Array which has been tokenized"	self scan: (ReadStream on: textOrString asString).	^self testScanTokens.</body></methods><methods><class-id>Net.SimpleScanner</class-id> <category>positioning</category><body package="NetClientBase" selector="close">close	source close</body><body package="NetClientBase" selector="reset">reset	"Set the receiver's position to start position."	source reset</body></methods><methods><class-id>Net.SimpleScanner</class-id> <category>multi-character scans</category><body package="NetClientBase" selector="skipWhiteSpace">skipWhiteSpace	"It is inefficient because intermediate stream is created. Perhaps refactoring scanWhile: can help"	self scanWhile: [self matchCharacterType: WhiteSpaceMask]</body></methods><methods><class-id>Net.SimpleScanner</class-id> <category>printing</category><body package="NetClientBase" selector="printToken:on:">printToken: assoc on: stream	self class printToken: assoc on: stream</body><body package="NetClientBase" selector="printToken:tokenType:on:">printToken: value tokenType: aSymbol on: stream	self class printToken: value tokenType: aSymbol on: stream</body></methods><methods><class-id>Net.SimpleScanner</class-id> <category>private</category><body package="NetClientBase" selector="resetToken">resetToken	token := tokenType := nil</body></methods><methods><class-id>Net.SimpleScanner class</class-id> <category>instance creation</category><body package="NetClientBase" selector="new">new	^super new initialize</body><body package="NetClientBase" selector="on:">on: stream	^self new on: stream</body><body package="NetClientBase" selector="on:from:to:">on: stream from: startPositionNumber to: sizeNumber 	^self new		on: stream		from: startPositionNumber		to: sizeNumber</body></methods><methods><class-id>Net.SimpleScanner class</class-id> <category>class initialization</category><body package="NetClientBase" selector="initClassificationTable">initClassificationTable	classificationTable := WordArray new: 256.	self initClassificationTableWith: AlphabeticMask when:		[:c | ($a &lt;= c and: [c &lt;= $z]) or: [$A &lt;= c and: [c &lt;= $Z]]].	self initClassificationTableWith: DigitMask when:		[:c | c &gt;= $0 and: [c &lt;= $9]].	self initClassificationTableWith: WhiteSpaceMask when:		[:c | #(32 "space" 9  "tab") includes: c asInteger].	self initClassificationTableWith: CRLFMask when:		[:c | c == Character cr or: [ c == Character lf ] ].	self initClassificationTableWith: EndOfLineMask when: [:c | c == Character cr ].</body><body package="NetClientBase" selector="initClassificationTableWith:when:">initClassificationTableWith: mask when: aBlock	"Set the mask in all entries of the classificationTable for which	aBlock answers true."	0 to: classificationTable size-1 do: 		[:i |		(aBlock value: (Character value: i)) 			ifTrue:				[classificationTable 					at: i + 1 					put: ((classificationTable at: i+1) maskSet: mask)]]</body><body package="NetClientBase" selector="initialize">initialize	"SimpleScanner initialize"	self initializeConstants; initClassificationTable</body><body package="NetClientBase" selector="initializeConstants">initializeConstants	AlphabeticMask := 1.	DigitMask := 2.	WhiteSpaceMask := 4.	CRLFMask := 8.	EndOfLineMask := 16.	NilMask := 0.	Cr := Character cr.	Lf := Character lf.	CRLF := Array with: Character cr with: Character lf.</body></methods><methods><class-id>Net.SimpleScanner class</class-id> <category>accessing</category><body package="NetClientBase" selector="classificationMaskFor:">classificationMaskFor: charOrNil 	| ind |	^charOrNil isNil		ifTrue: [NilMask]		ifFalse: 			[ind := charOrNil asInteger + 1.			self  classificationTable size &lt; ind 				ifTrue: [ NonASCIICharException signalWith: charOrNil ].			self classificationTable at: ind ]</body><body package="NetClientBase" selector="classificationTable">classificationTable	^classificationTable isNil		ifTrue: [ superclass classificationTable ]		ifFalse: [ classificationTable ]</body><body package="NetClientBase" selector="classificationTable:">classificationTable: aValue	classificationTable := aValue</body><body package="NetClientBase" selector="cr">cr	^Cr</body><body package="NetClientBase" selector="crlf">crlf	^CRLF</body><body package="NetClientBase" selector="lf">lf	^Lf</body></methods><methods><class-id>Net.SimpleScanner class</class-id> <category>printing</category><body package="NetClientBase" selector="defaultTokenType">defaultTokenType	self subclassResponsibility</body><body package="NetClientBase" selector="printToken:on:">printToken: assocOrValue on: stream 	| tokenType token |	(assocOrValue isKindOf: Association)		ifTrue: 			[tokenType := assocOrValue key.			token := assocOrValue value]		ifFalse: 			[tokenType := self defaultTokenType.			token := assocOrValue].	self printToken: token tokenType: tokenType on: stream</body><body package="NetClientBase" selector="printToken:tokenType:on:">printToken: value tokenType: aSymbol on: stream	self subclassResponsibility</body></methods><methods><class-id>Net.SimpleScanner class</class-id> <category>character classification</category><body package="NetClientBase" selector="whiteSpace">whiteSpace	^String with: Character space with: Character tab</body></methods><methods><class-id>Net.INIScanner</class-id> <category>tokenization</category><body package="NetClientBase" selector="nextNVPair">nextNVPair	| pos key |	self skipComments.	pos := self position.	key := self nextToken.	key notNil ifTrue: [		self skipWhiteSpace.		(self peekFor: $= )			ifTrue: [ 	^ key -&gt; (self skipWhiteSpace; nextLine) trimBlanks ].		self position: pos.		self warnOnSkippedLine ].	^ nil.</body><body package="NetClientBase" selector="nextSection">nextSection	| key |	(key := self nextSectionHeader) notNil 		ifTrue: [ ^ key -&gt; self scanSectionBody ].	^ nil.</body><body package="NetClientBase" selector="nextSectionHeader">nextSectionHeader	"Section headers must start at the beginning of the line."	[self atEnd not and: [self peek ~~ $[]]		whileTrue: [ self nextLine ].	self atEnd ifTrue: [		tokenType := #doIt.		^ token := nil ].	token := self 		scanToken: [ self matchCharacterType: TokenMask ] 		delimitedBy: '[]' 		notify: (#errMalformedSectionHeader &lt;&lt; #dialogs &gt;&gt; 'Malformed section header').	self nextLine.	^ token.</body><body package="NetClientBase" selector="nextToken">nextToken	^self nextIniToken</body><body package="NetClientBase" selector="scanSectionBody">scanSectionBody	"Answer a Dictionary containing the section's key/value pairs.	 Empty value is allowed.	 No protection against duplicate keys - last entry in stream is installed."	| section nv |	section := Dictionary new.	[self skipComments.	self atEnd not and: [self peek ~~ $[]]		whileTrue: [ 			(nv := self nextNVPair) notNil 				ifTrue: [section add: nv].			self skipComments ].	^ section.</body><body package="NetClientBase" selector="scanToken">scanToken	" token  =  1*&lt;any CHAR except $[, $], $=, SPACE and CTLs&gt;. "	token := self scanTokenMask: TokenMask.	tokenType := #token.	^token</body><body package="NetClientBase" selector="sectionNamed:">sectionNamed: aString	| name |	[ name := self nextSectionHeader.	name notNil and: [name asLowercase ~= (aString asLowercase)] ] whileTrue.	^ self scanSectionBody.</body><body package="NetClientBase" selector="skipComments">skipComments	self skipWhiteSpace.	[CommentChars includes: self peek] 		whileTrue: [self nextLine].</body><body package="NetClientBase" selector="tokenizeAsDictionary">tokenizeAsDictionary	| ini section |	ini := Dictionary new.	[ self atEnd ] 		whileFalse: [			(section := self nextSection) notNil ifTrue: [ ini add: section ] ].	^ ini.</body><body package="NetClientBase" selector="warnOnSkippedLine">warnOnSkippedLine	Transcript cr; show: ((#ScannedLine1sSkipped &lt;&lt; #net &gt;&gt; 'Scanned line ''&lt;1s&gt;'' skipped.')			expandMacrosWith: self nextLine).</body></methods><methods><class-id>Net.INIScanner</class-id> <category>private</category><body package="NetClientBase" selector="nextIniToken">nextIniToken	| char |	self skipWhiteSpace.	char := self peek.	char isNil		"end of input"		ifTrue: [ 	tokenType := #doIt.			^ token := nil].	token := self scanToken.	" Tokens must be arranged in name = value pairs.		where value is allowed to be empty. "	token isEmpty		ifTrue: [ 	tokenType := #none.			^ token := nil].	^ token.</body></methods><methods><class-id>Net.INIScanner class</class-id> <category>class initialization</category><body package="NetClientBase" selector="initClassificationTable">initClassificationTable      super initClassificationTable.       self initClassificationTableWith: TokenMask when:           [:c | c &gt; Character space and: [ ('[]=' includes: c) not ] ].       self initClassificationTableWith: EndOfLineMask when:           [:c | c == Character cr or: [ c == Character lf ] ].</body><body package="NetClientBase" selector="initialize">initialize	"INIScanner initialize"	self initializeConstants; initClassificationTable</body><body package="NetClientBase" selector="initializeConstants">initializeConstants	TokenMask := 16384.</body></methods><methods><class-id>Net.NetworkResponse</class-id> <category>printing</category><body package="NetClientBase" selector="printOn:">printOn: aStream	| textStream |	code isNil ifTrue: [ ^super printOn: aStream ].	aStream nextPutAll: code; space.	messageStream notNil 		ifTrue: [textStream := messageStream contents readStream.		aStream nextPutAll: (textStream nextAvailable: 64).		textStream atEnd ifTrue: [aStream nextPutAll: '...']].</body></methods><methods><class-id>Net.NetworkResponse</class-id> <category>private</category><body package="NetClientBase" selector="getLine">getLine	"Return one line from the server, stripping CR/LF."	| line |	^((line := self stream nextLine) isNil or: [ line size &lt; 3]) 		ifTrue: [ nil ] 		ifFalse: [ LogEnvironment default log: [((#get1s &lt;&lt; #net &gt;&gt; '*get* %&lt;&lt;1s&gt;%&gt;')			expandMacrosWith: line)] level: #FTPResponse.			line ]</body><body package="NetClientBase" selector="hasContinuation:">hasContinuation: tokens" Answer true if this reply has continuation line(s) "	^(tokens at: 2) == self class continuationToken.</body><body package="NetClientBase" selector="isContinuationLine:">isContinuationLine: line" Answer true if this is a reply continuation line "	^(self isLastLine: line) not</body><body package="NetClientBase" selector="isLastLine:">isLastLine: tokens 	"Answer true if this is a last line of the response, that is, 	it has space in the fourth position and reply number in positions 	1-3 is the same as the current reply number"	^(tokens at: 2)		== self class terminationToken and: [tokens first = code]</body><body package="NetClientBase" selector="readResponse">readResponse	"Read first line of the response. Decode response code"	"and answer the line"	| tokens line |	tokens := self tokenizeLine: (( line := self getLine) isNil ifTrue: [ self class connectionSignal raise] ifFalse: [ line ]).	code := tokens first.	messageStream nextPutAll: (tokens at: 3).	(self hasContinuation: tokens)		ifTrue: 			[[(line := self getLine) isNil ifTrue: [ self class connectionSignal raise].			tokens := self tokenizeLine: line.			self isLastLine: tokens]				whileFalse: 					[ tokens last notNil						ifTrue: [ 	messageStream cr; nextPutAll: tokens last]].			(tokens at: 3) notNil						ifTrue: [messageStream cr; nextPutAll: (tokens at: 3)]]</body><body package="NetClientBase" selector="responseEquals:">responseEquals: threeDigitString 	^code asNumber =  threeDigitString asNumber</body><body package="NetClientBase" selector="responseTypeIs:">responseTypeIs: char 	^code isEmpty not		ifTrue: [ code first == char ]</body><body package="NetClientBase" selector="tokenizeLine:">tokenizeLine: aString 	"Answer 4-element array containing 3-character reply code, delimiter character, 	remainder of the string and the string itself"	| answer |	answer := Array new: 4.	aString isNil ifTrue: [ ^answer ].	^[answer		at: 4 put: aString;		at: 1 put: (aString copyFrom: 1 to: 3); 		at: 2 put: (aString at: 4); 		at: 3 put: (aString copyFrom: 5 to: aString size); 		yourself]		on: Object subscriptOutOfBoundsSignal do: [:ex | ex return: answer]</body></methods><methods><class-id>Net.NetworkResponse</class-id> <category>accessing</category><body package="NetClientBase" selector="code">code	^code</body><body package="NetClientBase" selector="codeAt:">codeAt: position" Answer character at specified position inside the status code "	^code at: position</body><body package="NetClientBase" selector="message">message	^messageStream contents</body><body package="NetClientBase" selector="status">status" Answer code as a number " 	^code notNil		ifTrue: [ Integer readFrom: code readStream]		ifFalse: [ 0 ]</body><body package="NetClientBase" selector="statusAt:">statusAt: position" Answer digit value of status code at a specified position " 	^(self codeAt: position) digitValue</body><body package="NetClientBase" selector="stream">stream	^stream</body><body package="NetClientBase" selector="stream:">stream: aStream	stream := aStream</body></methods><methods><class-id>Net.NetworkResponse</class-id> <category>initialization</category><body package="NetClientBase" selector="initialize">initialize	code = ''.	messageStream := (String new: 64) writeStream.</body></methods><methods><class-id>Net.NetworkResponse</class-id> <category>comparing</category><body package="NetClientBase" selector="=">= other	^code = other code</body></methods><methods><class-id>Net.NetworkResponse</class-id> <category>instance creation</category><body package="NetClientBase" selector="readFrom:">readFrom: aStream	self initialize.	self stream: aStream.	self readResponse.</body></methods><methods><class-id>Net.NetworkResponse</class-id> <category>testing</category><body package="NetClientBase" selector="isSuccess">isSuccess	"Success - The action was received, understood and accepted"	^self responseTypeIs: $2</body><body package="NetClientBase" selector="isUnknownError">isUnknownError	^code isEmpty not		ifTrue: [ ('12345' includes: code first) not ]</body></methods><methods><class-id>Net.NetworkResponse class</class-id> <category>constants</category><body package="NetClientBase" selector="continuationToken">continuationToken	^$-</body><body package="NetClientBase" selector="terminationToken">terminationToken	^Character space</body></methods><methods><class-id>Net.NetworkResponse class</class-id> <category>instance creation</category><body package="NetClientBase" selector="new">new	^super new initialize</body><body package="NetClientBase" selector="readFrom:">readFrom: aStream	^self new readFrom: aStream</body></methods><methods><class-id>Tools.MailIncrementNotification</class-id> <category>accessing</category><body package="NetClientBase" selector="endingCount:">endingCount: aNumber	endingCount := aNumber</body><body package="NetClientBase" selector="ticks">ticks	"Answer the number of ticks were signalled."	^parameter == nil		ifTrue: [ 1 ]		ifFalse: [ parameter ]</body></methods><methods><class-id>Tools.MailIncrementNotification class</class-id> <category>signalling</category><body package="NetClientBase" selector="signalWith:endingCount:">signalWith: aParameter endingCount: endingCount	"Raise an an exception with parameter set to aParameter."	^self new 		searchFrom: thisContext sender;		originator: thisContext sender homeReceiver;		parameter: aParameter;		endingCount: endingCount;		raiseSignal.</body></methods><methods><class-id>Net.MimeTypeDescriptor</class-id> <category>testing</category><body package="NetClientBase" selector="isBinary">isBinary	^binary</body><body package="NetClientBase" selector="isMultipart">isMultipart	^self type = 'multipart'</body><body package="NetClientBase" selector="isText">isText	^self type = 'text'</body></methods><methods><class-id>Net.MimeTypeDescriptor</class-id> <category>accessing</category><body package="NetClientBase" selector="binary">binary	^binary</body><body package="NetClientBase" selector="binary:">binary: aBoolean	binary := aBoolean</body><body package="NetClientBase" selector="contentType">contentType	^contentType</body><body package="NetClientBase" selector="contentType:">contentType: aString" aString is 'type/subtype'. Should be lowercase "	contentType := aString</body><body package="NetClientBase" selector="hasPropertyAt:">hasPropertyAt: aString 	properties isNil ifTrue: [^false].	properties findKey: aString ifAbsent: [^false].	^true</body><body package="NetClientBase" selector="properties">properties	^properties isNil		ifTrue: [properties := Dictionary new]		ifFalse: [properties]</body><body package="NetClientBase" selector="propertyAt:">propertyAt: aString 	^self propertyAt: aString ifAbsent: [ nil ]</body><body package="NetClientBase" selector="propertyAt:ifAbsent:">propertyAt: aString ifAbsent: aBlock	^properties isNil 		ifTrue: [aBlock value]		ifFalse: [properties at: aString ifAbsent: aBlock]</body><body package="NetClientBase" selector="propertyAt:put:">propertyAt: aString put: aValue	self properties at: aString put: aValue</body><body package="NetClientBase" selector="subtype">subtype	^(self contentType tokensBasedOn: $/) last.</body><body package="NetClientBase" selector="type">type	^(self contentType tokensBasedOn: $/) first.</body></methods><methods><class-id>Net.MimeTypeDescriptor</class-id> <category>printing</category><body package="NetClientBase" selector="printOn:">printOn: aStream	super printOn: aStream.	contentType notNil		ifTrue: [aStream nextPut: $(; nextPutAll: contentType; nextPut: $)]</body></methods><methods><class-id>Net.MimeTypeDescriptor class</class-id> <category>accessing mime types</category><body package="NetClientBase" selector="contentType:">contentType: aString" Answer Mime type descriptor for specified type/subtype "	^self contentType: aString ifAbsent: [nil]</body><body package="NetClientBase" selector="contentType:ifAbsent:">contentType: aString ifAbsent: aBlock" Answer Mime type descriptor for specified type/subtype "	^MimeTypeRegistry at: aString asLowercase ifAbsent: aBlock</body><body package="NetClientBase" selector="contentTypeApplicationOctetStream">contentTypeApplicationOctetStream	^'application/octet-stream'</body><body package="NetClientBase" selector="contentTypeFormData">contentTypeFormData	^'application/x-www-form-urlencoded'</body><body package="NetClientBase" selector="contentTypeHtml">contentTypeHtml	^'text/html'</body><body package="NetClientBase" selector="contentTypeMessageRfc822">contentTypeMessageRfc822	^'message/rfc822'</body><body package="NetClientBase" selector="contentTypeMultipartDigest">contentTypeMultipartDigest	^'multipart/digest'</body><body package="NetClientBase" selector="contentTypeMultipartFormData">contentTypeMultipartFormData	^'application/x-www-form-urlencoded'</body><body package="NetClientBase" selector="contentTypeMultipartMixed">contentTypeMultipartMixed	^'multipart/mixed'</body><body package="NetClientBase" selector="contentTypePlainText">contentTypePlainText	^'text/plain'</body><body package="NetClientBase" selector="contentTypeXml">contentTypeXml	^'text/xml'</body><body package="NetClientBase" selector="defaultContentType">defaultContentType	^self contentType: self defaultContentTypeString</body><body package="NetClientBase" selector="defaultContentTypeString">defaultContentTypeString	^self contentTypePlainText</body><body package="NetClientBase" selector="defaultUnsupportedContentType">defaultUnsupportedContentType	^self contentTypeApplicationOctetStream</body><body package="NetClientBase" selector="extension:">extension: aString" Answer Mime type descriptor for specified file extension "	^self extension: aString ifAbsent: [nil]</body><body package="NetClientBase" selector="extension:ifAbsent:">extension: aString ifAbsent: aBlock" Answer Mime type descriptor for specified file extension "	| contentType |	contentType := FileExtensionToMimeTypeMap at: aString asLowercase ifAbsent: [^aBlock value].	^contentType isNil		ifTrue: [ nil ]		ifFalse: [ MimeTypeDescriptor contentType: contentType ]</body><body package="NetClientBase" selector="guessFromContentType:">guessFromContentType: aString	"guesses a content type from the extension"	^self 		guessFromContentType: aString 		ifAbsent: [self contentType: self defaultUnsupportedContentType].</body><body package="NetClientBase" selector="guessFromContentType:ifAbsent:">guessFromContentType: aString ifAbsent: aBlock	"guesses a content type from the extension"	^ MimeTypeRegistry 		at: aString asLowercase 		ifAbsent: aBlock.</body><body package="NetClientBase" selector="mimeTypeForFile:">mimeTypeForFile: fileName"Returns content type string, guessing at the MIME type from the fileName extension. If the fileName doesn't have an extension returns default - 'application/octet-stream' "        ^self  guessFromExtension: fileName asFilename extension</body></methods><methods><class-id>Net.MimeTypeDescriptor class</class-id> <category>class initialization</category><body package="NetClientBase" selector="defaultFileExtensionMap">defaultFileExtensionMap 	^#(		#('3dm' 'x-world/x-3dmf')		#('3dmf' 'x-world/x-3dmf')		#('a' 'application/octet-stream')		#('aab' 'application/x-authorware-bin')		#('aam' 'application/x-authorware-map')		#('aas' 'application/x-authorware-seg')		#('abc' 'text/vndabc')		#('acgi' 'text/html')		#('afl' 'video/animaflex')		#('ai' 'application/postscript')		#('aif' 'audio/aiff')		#('aif' 'audio/x-aiff')		#('aifc' 'audio/aiff')		#('aifc' 'audio/x-aiff')		#('aiff' 'audio/aiff')		#('aiff' 'audio/x-aiff')		#('aim' 'application/x-aim')		#('aip' 'text/x-audiosoft-intra')		#('ani' 'application/x-navi-animation')		#('aos' 'application/x-nokia-9000-communicator-add-on-software')		#('aps' 'application/mime')		#('arc' 'application/octet-stream')		#('arj' 'application/arj')		#('arj' 'application/octet-stream')		#('art' 'image/x-jg')		#('asf' 'video/x-ms-asf')		#('asm' 'text/x-asm')		#('asp' 'text/asp')		#('asx' 'application/x-mplayer2')		#('asx' 'video/x-ms-asf')		#('asx' 'video/x-ms-asf-plugin')		#('au' 'audio/basic')		#('au' 'audio/x-au')		#('avi' 'application/x-troff-msvideo')		#('avi' 'video/avi')		#('avi' 'video/msvideo')		#('avi' 'video/x-msvideo')		#('avs' 'video/avs-video')		#('bcpio' 'application/x-bcpio')		#('bin' 'application/mac-binary')		#('bin' 'application/macbinary')		#('bin' 'application/octet-stream')		#('bin' 'application/x-binary')		#('bin' 'application/x-macbinary')		#('bm' 'image/bmp')		#('bmp' 'image/bmp')		#('bmp' 'image/x-windows-bmp')		#('boo' 'application/book')		#('book' 'application/book')		#('boz' 'application/x-bzip2')		#('bsh' 'application/x-bsh')		#('bz' 'application/x-bzip')		#('bz2' 'application/x-bzip2')		#('c' 'text/plain')		#('c' 'text/x-c')		#('c++' 'text/plain')		#('cat' 'application/vndms-pkiseccat')		#('cc' 'text/plain')		#('cc' 'text/x-c')		#('ccad' 'application/clariscad')		#('cco' 'application/x-cocoa')		#('cdf' 'application/cdf')		#('cdf' 'application/x-cdf')		#('cdf' 'application/x-netcdf')		#('cer' 'application/pkix-cert')		#('cer' 'application/x-x509-ca-cert')		#('cha' 'application/x-chat')		#('chat' 'application/x-chat')		#('class' 'application/java')		#('class' 'application/java-byte-code')		#('class' 'application/x-java-class')		#('com' 'application/octet-stream')		#('com' 'text/plain')		#('conf' 'text/plain')		#('cpio' 'application/x-cpio')		#('cpp' 'text/x-c')		#('cpt' 'application/mac-compactpro')		#('cpt' 'application/x-compactpro')		#('cpt' 'application/x-cpt')		#('crl' 'application/pkcs-crl')		#('crl' 'application/pkix-crl')		#('crt' 'application/pkix-cert')		#('crt' 'application/x-x509-ca-cert')		#('crt' 'application/x-x509-user-cert')		#('csh' 'application/x-csh')		#('csh' 'text/x-scriptcsh')		#('css' 'application/x-pointplus')		#('css' 'text/css')		#('cxx' 'text/plain')		#('dcr' 'application/x-director')		#('deepv' 'application/x-deepv')		#('def' 'text/plain')		#('der' 'application/x-x509-ca-cert')		#('dif' 'video/x-dv')		#('dir' 'application/x-director')		#('dl' 'video/dl')		#('dl' 'video/x-dl')		#('doc' 'application/msword')		#('dot' 'application/msword')		#('dp' 'application/commonground')		#('drw' 'application/drafting')		#('dump' 'application/octet-stream')		#('dv' 'video/x-dv')		#('dvi' 'application/x-dvi')		#('dwf' '(old)')		#('dwf' 'model/vnddwf')		#('dwg' 'application/acad')		#('dwg' 'image/vnddwg')		#('dwg' 'image/x-dwg')		#('dxf' 'application/dxf')		#('dxf' 'image/vnddwg')		#('dxf' 'image/x-dwg')		#('dxr' 'application/x-director')		#('el' 'text/x-scriptelisp')		#('elc' 'ELisp)')		#('elc' 'application/x-elc')		#('env' 'application/x-envoy')		#('eps' 'application/postscript')		#('es' 'application/x-esrehber')		#('etx' 'text/x-setext')		#('evy' 'application/envoy')		#('evy' 'application/x-envoy')		#('exe' 'application/octet-stream')		#('f' 'text/plain')		#('f' 'text/x-fortran')		#('f77' 'text/x-fortran')		#('f90' 'text/plain')		#('f90' 'text/x-fortran')		#('fdf' 'application/vndfdf')		#('fif' 'application/fractals')		#('fif' 'image/fif')		#('fli' 'video/fli')		#('fli' 'video/x-fli')		#('flo' 'image/florian')		#('flx' 'text/vndfmiflexstor')		#('fmf' 'video/x-atomic3d-feature')		#('for' 'text/plain')		#('for' 'text/x-fortran')		#('fpx' 'image/vndfpx')		#('fpx' 'image/vndnet-fpx')		#('frl' 'application/freeloader')		#('funk' 'audio/make')		#('g' 'text/plain')		#('g3' 'image/g3fax')		#('gif' 'image/gif')		#('gl' 'video/gl')		#('gl' 'video/x-gl')		#('gsd' 'audio/x-gsm')		#('gsm' 'audio/x-gsm')		#('gsp' 'application/x-gsp')		#('gss' 'application/x-gss')		#('gtar' 'application/x-gtar')		#('gz' 'application/x-compressed')		#('gz' 'application/x-gzip')		#('gzip' 'application/x-gzip')		#('gzip' 'multipart/x-gzip')		#('h' 'text/plain')		#('h' 'text/x-h')		#('hdf' 'application/x-hdf')		#('help' 'application/x-helpfile')		#('hgl' 'application/vndhp-HPGL')		#('hh' 'text/plain')		#('hh' 'text/x-h')		#('hlb' 'text/x-script')		#('hlp' 'application/hlp')		#('hlp' 'application/x-helpfile')		#('hlp' 'application/x-winhelp')		#('hpg' 'application/vndhp-HPGL')		#('hpgl' 'application/vndhp-HPGL')		#('hqx' 'application/binhex')		#('hqx' 'application/binhex4')		#('hqx' 'application/mac-binhex')		#('hqx' 'application/mac-binhex40')		#('hqx' 'application/x-binhex40')		#('hqx' 'application/x-mac-binhex40')		#('hta' 'application/hta')		#('htc' 'text/x-component')		#('htm' 'text/html')		#('html' 'text/html')		#('htmls' 'text/html')		#('htt' 'text/webviewhtml')		#('htx' 'text/html')		#('ice' 'x-conference/x-cooltalk')		#('ico' 'image/x-icon')		#('idc' 'text/plain')		#('ief' 'image/ief')		#('iefs' 'image/ief')		#('iges' 'application/iges')		#('iges' 'model/iges')		#('igs' 'application/iges')		#('igs' 'model/iges')		#('ima' 'application/x-ima')		#('imap' 'application/x-httpd-imap')		#('inf' 'application/inf')		#('ins' 'application/x-internett-signup')		#('ip' 'application/x-ip2')		#('isu' 'video/x-isvideo')		#('it' 'audio/it')		#('iv' 'application/x-inventor')		#('ivr' 'i-world/i-vrml')		#('ivy' 'application/x-livescreen')		#('jam' 'audio/x-jam')		#('jav' 'text/plain')		#('jav' 'text/x-java-source')		#('java' 'text/plain')		#('java' 'text/x-java-source')		#('jcm' 'application/x-java-commerce')		#('jfif' 'image/jpeg')		#('jfif' 'image/pjpeg')		#('jfif-tbnl' 'image/jpeg')		#('jpe' 'image/jpeg')		#('jpe' 'image/pjpeg')		#('jpeg' 'image/jpeg')		#('jpeg' 'image/pjpeg')		#('jpg' 'image/jpeg')		#('jpg' 'image/pjpeg')		#('jps' 'image/x-jps')		#('js' 'application/x-javascript')		#('jut' 'image/jutvision')		#('kar' 'audio/midi')		#('kar' 'music/x-karaoke')		#('ksh' 'application/x-ksh')		#('ksh' 'text/x-scriptksh')		#('la' 'audio/nspaudio')		#('la' 'audio/x-nspaudio')		#('lam' 'audio/x-liveaudio')		#('latex' 'application/x-latex')		#('lha' 'application/lha')		#('lha' 'application/octet-stream')		#('lha' 'application/x-lha')		#('lhx' 'application/octet-stream')		#('list' 'text/plain')		#('lma' 'audio/nspaudio')		#('lma' 'audio/x-nspaudio')		#('log' 'text/plain')		#('lsp' 'application/x-lisp')		#('lsp' 'text/x-scriptlisp')		#('lst' 'text/plain')		#('lsx' 'text/x-la-asf')		#('ltx' 'application/x-latex')		#('lzh' 'application/octet-stream')		#('lzh' 'application/x-lzh')		#('lzx' 'application/lzx')		#('lzx' 'application/octet-stream')		#('lzx' 'application/x-lzx')		#('m' 'text/plain')		#('m' 'text/x-m')		#('m1v' 'video/mpeg')		#('m2a' 'audio/mpeg')		#('m2v' 'video/mpeg')		#('m3u' 'audio/x-mpequrl')		#('man' 'application/x-troff-man')		#('map' 'application/x-navimap')		#('mar' 'text/plain')		#('mbd' 'application/mbedlet')		#('mc$' 'application/x-magic-cap-package-10')		#('mcd' 'application/mcad')		#('mcd' 'application/x-mathcad')		#('mcf' 'image/vasa')		#('mcf' 'text/mcf')		#('mcp' 'application/netmc')		#('me' 'application/x-troff-me')		#('mht' 'message/rfc822')		#('mhtml' 'message/rfc822')		#('mid' 'application/x-midi')		#('mid' 'audio/midi')		#('mid' 'audio/x-mid')		#('mid' 'audio/x-midi')		#('mid' 'music/crescendo')		#('mid' 'x-music/x-midi')		#('midi' 'application/x-midi')		#('midi' 'audio/midi')		#('midi' 'audio/x-mid')		#('midi' 'audio/x-midi')		#('midi' 'music/crescendo')		#('midi' 'x-music/x-midi')		#('mif' 'application/x-frame')		#('mif' 'application/x-mif')		#('mime' 'message/rfc822')		#('mime' 'www/mime')		#('mjf' 'audio/x-vndAudioExplosionMjuiceMediaFile')		#('mjpg' 'video/x-motion-jpeg')		#('mm' 'application/base64')		#('mm' 'application/x-meme')		#('mme' 'application/base64')		#('mod' 'audio/mod')		#('mod' 'audio/x-mod')		#('moov' 'video/quicktime')		#('mov' 'video/quicktime')		#('movie' 'video/x-sgi-movie')		#('mp2' 'audio/mpeg')		#('mp2' 'audio/x-mpeg')		#('mp2' 'video/mpeg')		#('mp2' 'video/x-mpeg')		#('mp2' 'video/x-mpeq2a')		#('mp3' 'audio/mpeg3')		#('mp3' 'audio/x-mpeg-3')		#('mp3' 'video/mpeg')		#('mp3' 'video/x-mpeg')		#('mpa' 'audio/mpeg')		#('mpa' 'video/mpeg')		#('mpc' 'application/x-project')		#('mpe' 'video/mpeg')		#('mpeg' 'video/mpeg')		#('mpg' 'audio/mpeg')		#('mpg' 'video/mpeg')		#('mpga' 'audio/mpeg')		#('mpp' 'application/vndms-project')		#('mpt' 'application/x-project')		#('mpv' 'application/x-project')		#('mpx' 'application/x-project')		#('mrc' 'application/marc')		#('ms' 'application/x-troff-ms')		#('mv' 'video/x-sgi-movie')		#('my' 'audio/make')		#('mzz' 'application/x-vndAudioExplosionmzz')		#('nap' 'image/naplps')		#('naplps' 'image/naplps')		#('nc' 'application/x-netcdf')		#('ncm' 'application/vndnokiaconfiguration-message')		#('nif' 'image/x-niff')		#('niff' 'image/x-niff')		#('nix' 'application/x-mix-transfer')		#('nsc' 'application/x-conference')		#('nvd' 'application/x-navidoc')		#('o' 'application/octet-stream')		#('oda' 'application/oda')		#('omc' 'application/x-omc')		#('omcd' 'application/x-omcdatamaker')		#('omcr' 'application/x-omcregerator')		#('p' 'text/x-pascal')		#('p10' 'application/pkcs10')		#('p10' 'application/x-pkcs10')		#('p12' 'application/pkcs-12')		#('p12' 'application/x-pkcs12')		#('p7a' 'application/x-pkcs7-signature')		#('p7c' 'application/pkcs7-mime')		#('p7c' 'application/x-pkcs7-mime')		#('p7m' 'application/pkcs7-mime')		#('p7m' 'application/x-pkcs7-mime')		#('p7r' 'application/x-pkcs7-certreqresp')		#('p7s' 'application/pkcs7-signature')		#('part' 'application/pro_eng')		#('pas' 'text/pascal')		#('pbm' 'image/x-portable-bitmap')		#('pcl' 'application/vndhp-PCL')		#('pcl' 'application/x-pcl')		#('pct' 'image/x-pict')		#('pcx' 'image/x-pcx')		#('pdb' 'chemical/x-pdb')		#('pdf' 'application/pdf')		#('pfunk' 'audio/make')		#('pfunk' 'audio/makemyfunk')		#('pgm' 'image/x-portable-graymap')		#('pgm' 'image/x-portable-greymap')		#('pic' 'image/pict')		#('pict' 'image/pict')		#('pkg' 'application/x-newton-compatible-pkg')		#('pko' 'application/vndms-pkipko')		#('pl' 'text/plain')		#('pl' 'text/x-scriptperl')		#('plx' 'application/x-PiXCLscript')		#('pm' 'image/x-xpixmap')		#('pm' 'text/x-scriptperl-module')		#('pm4' 'application/x-pagemaker')		#('pm5' 'application/x-pagemaker')		#('png' 'image/png')		#('pnm' 'application/x-portable-anymap')		#('pnm' 'image/x-portable-anymap')		#('pot' 'application/mspowerpoint')		#('pot' 'application/vndms-powerpoint')		#('pov' 'model/x-pov')		#('ppa' 'application/vndms-powerpoint')		#('ppm' 'image/x-portable-pixmap')		#('pps' 'application/mspowerpoint')		#('pps' 'application/vndms-powerpoint')		#('ppt' 'application/mspowerpoint')		#('ppt' 'application/powerpoint')		#('ppt' 'application/vndms-powerpoint')		#('ppt' 'application/x-mspowerpoint')		#('ppz' 'application/mspowerpoint')		#('pre' 'application/x-freelance')		#('prt' 'application/pro_eng')		#('ps' 'application/postscript')		#('psd' 'application/octet-stream')		#('pvu' 'paleovu/x-pv')		#('pwz' 'application/vndms-powerpoint')		#('py' 'text/x-scriptphyton')		#('pyc' 'applicaiton/x-bytecodepython')		#('qcp' 'audio/vndqcelp')		#('qd3' 'x-world/x-3dmf')		#('qd3d' 'x-world/x-3dmf')		#('qif' 'image/x-quicktime')		#('qt' 'video/quicktime')		#('qtc' 'video/x-qtc')		#('qti' 'image/x-quicktime')		#('qtif' 'image/x-quicktime')		#('ra' 'audio/x-pn-realaudio')		#('ra' 'audio/x-pn-realaudio-plugin')		#('ra' 'audio/x-realaudio')		#('ram' 'audio/x-pn-realaudio')		#('ras' 'application/x-cmu-raster')		#('ras' 'image/cmu-raster')		#('ras' 'image/x-cmu-raster')		#('rast' 'image/cmu-raster')		#('rexx' 'text/x-scriptrexx')		#('rf' 'image/vndrn-realflash')		#('rgb' 'image/x-rgb')		#('rm' 'application/vndrn-realmedia')		#('rm' 'audio/x-pn-realaudio')		#('rmi' 'audio/mid')		#('rmm' 'audio/x-pn-realaudio')		#('rmp' 'audio/x-pn-realaudio')		#('rmp' 'audio/x-pn-realaudio-plugin')		#('rng' 'application/ringing-tones')		#('rng' 'application/vndnokiaringing-tone')		#('rnx' 'application/vndrn-realplayer')		#('roff' 'application/x-troff')		#('rp' 'image/vndrn-realpix')		#('rpm' 'audio/x-pn-realaudio-plugin')		#('rt' 'text/richtext')		#('rt' 'text/vndrn-realtext')		#('rtf' 'application/rtf')		#('rtf' 'application/x-rtf')		#('rtf' 'text/richtext')		#('rtx' 'application/rtf')		#('rtx' 'text/richtext')		#('rv' 'video/vndrn-realvideo')		#('s' 'text/x-asm')		#('s3m' 'audio/s3m')		#('saveme' 'application/octet-stream')		#('sbk' 'application/x-tbook')		#('scm' 'application/x-lotusscreencam')		#('scm' 'text/x-scriptguile')		#('scm' 'text/x-scriptscheme')		#('scm' 'video/x-scm')		#('sdml' 'text/plain')		#('sdp' 'application/sdp')		#('sdp' 'application/x-sdp')		#('sdr' 'application/sounder')		#('sea' 'application/sea')		#('sea' 'application/x-sea')		#('set' 'application/set')		#('sgm' 'text/sgml')		#('sgm' 'text/x-sgml')		#('sgml' 'text/sgml')		#('sgml' 'text/x-sgml')		#('sh' 'application/x-bsh')		#('sh' 'application/x-sh')		#('sh' 'application/x-shar')		#('sh' 'text/x-scriptsh')		#('shar' 'application/x-bsh')		#('shar' 'application/x-shar')		#('shtml' 'text/html')		#('shtml' 'text/x-server-parsed-html')		#('sid' 'audio/x-psid')		#('sit' 'application/x-sit')		#('sit' 'application/x-stuffit')		#('skd' 'application/x-koan')		#('skm' 'application/x-koan')		#('skp' 'application/x-koan')		#('skt' 'application/x-koan')		#('sl' 'application/x-seelogo')		#('smi' 'application/smil')		#('smil' 'application/smil')		#('snd' 'audio/basic')		#('snd' 'audio/x-adpcm')		#('sol' 'application/solids')		#('spc' 'application/x-pkcs7-certificates')		#('spc' 'text/x-speech')		#('spl' 'application/futuresplash')		#('spr' 'application/x-sprite')		#('sprite' 'application/x-sprite')		#('src' 'application/x-wais-source')		#('ssi' 'text/x-server-parsed-html')		#('ssm' 'application/streamingmedia')		#('sst' 'application/vndms-pkicertstore')		#('step' 'application/step')		#('stl' 'application/sla')		#('stl' 'application/vndms-pkistl')		#('stl' 'application/x-navistyle')		#('stp' 'application/step')		#('sv4cpio' 'application/x-sv4cpio')		#('sv4crc' 'application/x-sv4crc')		#('svf' 'image/vnddwg')		#('svf' 'image/x-dwg')		#('svr' 'application/x-world')		#('svr' 'x-world/x-svr')		#('swf' 'application/x-shockwave-flash')		#('t' 'application/x-troff')		#('talk' 'text/x-speech')		#('tar' 'application/x-tar')		#('tbk' 'application/toolbook')		#('tbk' 'application/x-tbook')		#('tcl' 'application/x-tcl')		#('tcl' 'text/x-scripttcl')		#('tcsh' 'text/x-scripttcsh')		#('tex' 'application/x-tex')		#('texi' 'application/x-texinfo')		#('texinfo' 'application/x-texinfo')		#('text' 'application/plain')		#('text' 'text/plain')		#('tgz' 'application/gnutar')		#('tgz' 'application/x-compressed')		#('tif' 'image/tiff')		#('tif' 'image/x-tiff')		#('tiff' 'image/tiff')		#('tiff' 'image/x-tiff')		#('tr' 'application/x-troff')		#('tsi' 'audio/tsp-audio')		#('tsp' 'application/dsptype')		#('tsp' 'audio/tsplayer')		#('tsv' 'text/tab-separated-values')		#('turbot' 'image/florian')		#('txt' 'text/plain')		#('uil' 'text/x-uil')		#('uni' 'text/uri-list')		#('unis' 'text/uri-list')		#('unv' 'application/i-deas')		#('uri' 'text/uri-list')		#('uris' 'text/uri-list')		#('ustar' 'application/x-ustar')		#('ustar' 'multipart/x-ustar')		#('uu' 'application/octet-stream')		#('uu' 'text/x-uuencode')		#('uue' 'text/x-uuencode')		#('vcd' 'application/x-cdlink')		#('vcs' 'text/x-vCalendar')		#('vda' 'application/vda')		#('vdo' 'video/vdo')		#('vew' 'application/groupwise')		#('viv' 'video/vivo')		#('viv' 'video/vndvivo')		#('vivo' 'video/vivo')		#('vivo' 'video/vndvivo')		#('vmd' 'application/vocaltec-media-desc')		#('vmf' 'application/vocaltec-media-file')		#('voc' 'audio/voc')		#('voc' 'audio/x-voc')		#('vos' 'video/vosaic')		#('vox' 'audio/voxware')		#('vqe' 'audio/x-twinvq-plugin')		#('vqf' 'audio/x-twinvq')		#('vql' 'audio/x-twinvq-plugin')		#('vrml' 'application/x-vrml')		#('vrml' 'model/vrml')		#('vrml' 'x-world/x-vrml')		#('vrt' 'x-world/x-vrt')		#('vsd' 'application/x-visio')		#('vst' 'application/x-visio')		#('vsw' 'application/x-visio')		#('w60' 'application/wordperfect60')		#('w61' 'application/wordperfect61')		#('w6w' 'application/msword')		#('wav' 'audio/wav')		#('wav' 'audio/x-wav')		#('wb1' 'application/x-qpro')		#('wbmp' 'image/vndwapwbmp')		#('web' 'application/vndxara')		#('wiz' 'application/msword')		#('wk1' 'application/x-123')		#('wmf' 'windows/metafile')		#('wml' 'text/vndwapwml')		#('wmlc' 'application/vndwapwmlc')		#('wmls' 'text/vndwapwmlscript')		#('wmlsc' 'application/vndwapwmlscriptc')		#('word' 'application/msword')		#('wp' 'application/wordperfect')		#('wp5' 'application/wordperfect')		#('wp5' 'application/wordperfect60')		#('wp6' 'application/wordperfect')		#('wpd' 'application/wordperfect')		#('wpd' 'application/x-wpwin')		#('wq1' 'application/x-lotus')		#('wri' 'application/mswrite')		#('wri' 'application/x-wri')		#('wrl' 'application/x-world')		#('wrl' 'model/vrml')		#('wrl' 'x-world/x-vrml')		#('wrz' 'model/vrml')		#('wrz' 'x-world/x-vrml')		#('wsc' 'text/scriplet')		#('wsrc' 'application/x-wais-source')		#('wtk' 'application/x-wintalk')		#('xbm' 'image/x-xbitmap')		#('xbm' 'image/x-xbm')		#('xbm' 'image/xbm')		#('xdr' 'video/x-amt-demorun')		#('xgz' 'xgl/drawing')		#('xif' 'image/vndxiff')		#('xl' 'application/excel')		#('xla' 'application/excel')		#('xla' 'application/x-excel')		#('xla' 'application/x-msexcel')		#('xlb' 'application/excel')		#('xlb' 'application/vndms-excel')		#('xlb' 'application/x-excel')		#('xlc' 'application/excel')		#('xlc' 'application/vndms-excel')		#('xlc' 'application/x-excel')		#('xld' 'application/excel')		#('xld' 'application/x-excel')		#('xlk' 'application/excel')		#('xlk' 'application/x-excel')		#('xll' 'application/excel')		#('xll' 'application/vndms-excel')		#('xll' 'application/x-excel')		#('xlm' 'application/excel')		#('xlm' 'application/vndms-excel')		#('xlm' 'application/x-excel')		#('xls' 'application/excel')		#('xls' 'application/vndms-excel')		#('xls' 'application/x-excel')		#('xls' 'application/x-msexcel')		#('xlt' 'application/excel')		#('xlt' 'application/x-excel')		#('xlv' 'application/excel')		#('xlv' 'application/x-excel')		#('xlw' 'application/excel')		#('xlw' 'application/vndms-excel')		#('xlw' 'application/x-excel')		#('xlw' 'application/x-msexcel')		#('xm' 'audio/xm')		#('xml' 'application/xml')		#('xml' 'text/xml')		#('xmz' 'xgl/movie')		#('xpix' 'application/x-vndls-xpix')		#('xpm' 'image/x-xpixmap')		#('xpm' 'image/xpm')		#('x-png' 'image/png')		#('xsr' 'video/x-amt-showrun')		#('xwd' 'image/x-xwd')		#('xwd' 'image/x-xwindowdump')		#('xyz' 'chemical/x-pdb')		#('z' 'application/x-compress')		#('z' 'application/x-compressed')		#('zip' 'application/x-compressed')		#('zip' 'application/x-zip-compressed')		#('zip' 'application/zip')		#('zip' 'multipart/x-zip')		#('zoo' 'application/octet-stream')		#('zsh' 'text/x-scriptzsh')		#('jsp' 'text/html')		#('ssp' 'text/html')	)</body><body package="NetClientBase" selector="defaultMimeTypes">defaultMimeTypes "List of MIME content types. The second item defines whether or not this type will be considered as a binary type"	^#(		#('application/octet-stream' 1)		#('application/postscript' 1)		#('application/oda' 1)		#('application/atomicmail' 1)		#('application/andrew-inset' 1)		#('application/slate' 1)		#('application/wita' 1)		#('application/dec-dx' 1)		#('application/dca-rft' 1)		#('application/activemessage' 1)		#('application/rtf' 1)		#('application/applefile' 1)		#('application/mac-binhex40' 1)		#('application/news-message-id' 1)		#('application/news-transmission' 1)		#('application/wordperfect5.1' 1)		#('application/pdf' 1 #(#encoding 'base64'))		#('application/zip' 1)		#('application/macwriteii' 1)		#('application/msword' 1)		#('application/remote-printing' 1)		#('application/mathematica' 1)		#('application/cybercash' 1)		#('application/commonground' 1)		#('application/iges' 1)		#('application/riscos' 1)		#('application/eshop' 1)		#('application/x400-bp' 1)		#('application/sgml' 1)		#('application/cals-1840' 1)		#('application/pgp-encrypted' 1)		#('application/pgp-signature' 1)		#('application/pgp-keys' 1)		#('application/vnd.framemaker' 1)		#('application/vnd.mif' 1)		#('application/vnd.ms-excel' 1)		#('application/vnd.ms-powerpoint' 1)		#('application/vnd.ms-project' 1)		#('application/vnd.ms-works' 1)		#('application/vnd.ms-tnef' 1)		#('application/vnd.svd' 1)		#('application/vnd.music-niff' 1)		#('application/vnd.ms-artgalry' 1)		#('application/vnd.truedoc' 1)		#('application/vnd.koan' 1)		#('application/vnd.street-stream' 1)		#('application/vnd.fdf' 1)		#('application/set-payment-initiation' 1)		#('application/set-payment' 1)		#('application/set-registration-initiation' 1)		#('application/set-registration' 1)		#('application/vnd.seemail' 1)		#('application/vnd.businessobjects' 1)		#('application/vnd.meridian-slingshot' 1)		#('application/vnd.xara' 1)		#('application/sgml-open-catalog' 1)		#('application/vnd.rapid' 1)		#('application/vnd.enliven' 1)		#('application/vnd.japannet-registration-wakeup' 1)		#('application/vnd.japannet-verification-wakeup' 1)		#('application/vnd.japannet-payment-wakeup' 1)		#('application/vnd.japannet-directory-service' 1)		#('application/vnd.intertrust.digibox' 1)		#('application/vnd.intertrust.nncp' 1)		#('application/prs.alvestrand.titrax-sheet' 1)		#('application/vnd.noblenet-web' 1)		#('application/vnd.noblenet-sealer' 1)		#('application/vnd.noblenet-directory' 1)		#('application/prs.nprend' 1)		#('application/vnd.webturbo' 1)		#('application/hyperstudio' 1)		#('application/vnd.shana.informed.formtemplate' 1)		#('application/vnd.shana.informed.formdata' 1)		#('application/vnd.shana.informed.package' 1)		#('application/vnd.shana.informed.interchange' 1)		#('application/vnd.$commerce_battelle' 1)		#('application/vnd.osa.netdeploy' 1)		#('application/vnd.ibm.MiniPay' 1)		#('application/vnd.japannet-jpnstore-wakeup' 1)		#('application/vnd.japannet-setstore-wakeup' 1)		#('application/vnd.japannet-verification' 1)		#('application/vnd.japannet-registration' 1)		#('application/vnd.hp-HPGL' 1)		#('application/vnd.hp-PCL' 1)		#('application/vnd.hp-PCLXL' 1)		#('application/vnd.musician' 1)		#('application/vnd.FloGraphIt' 1)		#('application/vnd.intercon.formnet' 1)		#('application/vemmi' 1)		#('application/vnd.ms-asf' 1)		#('application/vnd.ecdis-update' 1)		#('application/vnd.powerbuilder6' 1)		#('application/vnd.powerbuilder6-s' 1)		#('application/vnd.lotus-wordpro' 1)		#('application/vnd.lotus-approach' 1)		#('application/vnd.lotus-1-2-3' 1)		#('application/vnd.lotus-organizer' 1)		#('application/vnd.lotus-screencam' 1)		#('application/vnd.lotus-freelance' 1)		#('application/vnd.fujitsu.oasys' 1)		#('application/vnd.fujitsu.oasys2' 1)		#('application/vnd.swiftview-ics' 1)		#('application/vnd.dna' 1)		#('application/prs.cww' 1)		#('application/vnd.wt.stf' 1)		#('application/vnd.dxr' 1)		#('application/vnd.mitsubishi.misty-guard.trustweb' 1)		#('application/vnd.ibm.modcap' 1)		#('application/vnd.acucobol' 1)		#('application/vnd.fujitsu.oasys3' 1)		#('application/marc' 1)		#('application/vnd.fujitsu.oasysprs' 1)		#('application/vnd.fujitsu.oasysgp' 1)		#('application/vnd.visio' 1)		#('application/vnd.netfpx' 1)		#('application/vnd.audiograph' 1)		#('application/vnd.epson.salt' 1)		#('application/vnd.3M.Post-it-Notes' 1)		#('application/vnd.novadigm.EDX' 1)		#('application/vnd.novadigm.EXT' 1)		#('application/vnd.novadigm.EDM' 1)		#('application/vnd.claymore' 1)		#('application/vnd.comsocaller' 1)		#('application/pkcs7-mime' 1)		#('application/pkcs7-signature' 1)		#('application/pkcs10' 1)		#('application/vnd.yellowriver-custom-menu' 1)		#('application/vnd.ecowin.chart' 1)		#('application/vnd.ecowin.series' 1)		#('application/vnd.ecowin.filerequest' 1)		#('application/vnd.ecowin.fileupdate' 1)		#('application/vnd.ecowin.seriesrequest' 1)		#('application/vnd.ecowin.seriesupdate' 1)		#('application/EDIFACT' 1)		#('application/EDI-X12' 1)		#('application/EDI-Consent' 1)		#('application/vnd.wrq-hp3000-labelled' 1)		#('application/vnd.minisoft-hp3000-save' 1)		#('application/vnd.ffsns' 1)		#('application/vnd.hp-hps' 1)		#('application/vnd.fujixerox.docuworks' 1)		#('application/xml' 1)		#('application/vnd.anser-web-funds-transfer-initiation' 1)		#('application/vnd.anser-web-certificate-issue-initiation' 1)		#('application/vnd.is-xpr' 1)		#('application/vnd.intu.qbo' 1)		#('application/vnd.publishare-delta-tree' 1)		#('application/vnd.cybank' 1)		#('application/batch-SMTP' 1)		#('application/vnd.uplanet.alert' 1)		#('application/vnd.uplanet.cacheop' 1)		#('application/vnd.uplanet.list' 1)		#('application/vnd.uplanet.listcmd' 1)		#('application/vnd.uplanet.channel' 1)		#('application/vnd.uplanet.bearer-choice' 1)		#('application/vnd.uplanet.signal' 1)		#('application/vnd.uplanet.alert-wbxml' 1)		#('application/vnd.uplanet.cacheop-wbmxl' 1)		#('application/vnd.uplanet.list-wbxml' 1)		#('application/vnd.uplanet.listcmd-wbxml' 1)		#('application/vnd.uplanet.channel-wbxml' 1)		#('application/vnd.uplanet.bearer-choice-wbxml' 1)		#('application/vnd.epson.quickanime' 1)		#('application/vnd.commonspace' 1)		#('application/vnd.fut-misnet' 1)		#('application/vnd.xfdl' 1)		#('application/vnd.intu.qfx' 1)		#('application/vnd.epson.ssf' 1)		#('application/vnd.epson.msf' 1)		#('application/vnd.powerbuilder7' 1)		#('application/vnd.powerbuilder7-s' 1)		#('application/vnd.lotus-notes' 1)		#('application/pkixcmp' 1)		#('application/vnd.wap.wmlc' 1)		#('application/vnd.wap.wmlscriptc' 1)		#('application/vnd.motorola.flexsuite' 1)		#('application/vnd.wap.wbxml' 1)		#('application/vnd.motorola.flexsuite.wem' 1)		#('application/vnd.motorola.flexsuite.kmr' 1)		#('application/vnd.motorola.flexsuite.adsi' 1)		#('application/vnd.motorola.flexsuite.fis' 1)		#('application/vnd.motorola.flexsuite.gotap' 1)		#('application/vnd.motorola.flexsuite.ttc' 1)		#('application/vnd.ufdl' 1)		#('application/vnd.accpac.simply.imp' 1)		#('application/vnd.accpac.simply.aso' 1)		#('application/vnd.vcx' 1)		#('application/ipp' 1)		#('application/ocsp-request' 1)		#('application/ocsp-response' 1)		#('application/vnd.previewsystems.box' 1)		#('application/vnd.mediastation.cdkey' 1)		#('application/vnd.pg.format' 1)		#('application/vnd.pg.osasli' 1)		#('application/vnd.hp-hpid' 1)		#('application/pkix-cert' 1)		#('application/pkix-crl' 1)		#('application/vnd.Mobius.TXF' 1)		#('application/vnd.Mobius.PLC' 1)		#('application/vnd.Mobius.DIS' 1)		#('application/vnd.Mobius.DAF' 1)		#('application/vnd.Mobius.MSL' 1)		#('application/vnd.cups-raster' 1)		#('application/vnd.cups-postscript' 1)		#('application/vnd.cups-raw' 1)		#('application/index' 1)		#('application/index.cmd' 1)		#('application/index.response' 1)		#('application/index.obj' 1)		#('application/index.vnd' 1)		#('application/vnd.triscape.mxs' 1)		#('application/vnd.powerbuilder75' 1)		#('application/vnd.powerbuilder75-s' 1)		#('application/vnd.dpgraph' 1)		#('application/http' 0)		#('application/sdp' 1)		#('application/vnd.eudora.data' 1)		#('application/vnd.fujixerox.docuworks.binder' 1)		#('application/vnd.vectorworks' 1)		#('application/vnd.grafeq' 1)		#('application/vnd.bmi' 1)		#('application/vnd.ericsson.quickcall' 1)		#('application/vnd.hzn-3d-crossword' 1)		#('application/vnd.wap.slc' 1)		#('application/vnd.wap.sic' 1)		#('application/vnd.groove-injector' 1)		#('application/vnd.fujixerox.ddd' 1)		#('application/vnd.groove-account' 1)		#('application/vnd.groove-identity-message' 1)		#('application/vnd.groove-tool-message' 1)		#('application/vnd.groove-tool-template' 1)		#('application/vnd.groove-vcard' 1)		#('application/vnd.ctc-posml' 1)		#('application/vnd.canon-lips' 1)		#('application/vnd.canon-cpdl' 1)		#('application/vnd.trueapp' 1)		#('application/vnd.s3sms' 1)		#('application/iotp' 1)		#('application/vnd.mcd' 1)		#('application/vnd.httphone' 1)		#('application/vnd.informix-visionary' 1)		#('application/vnd.msign' 1)		#('application/vnd.ms-lrm' 1)		#('application/vnd.contact.cmsg' 1)		#('application/vnd.epson.esf' 1)		#('application/whoispp-query' 1)		#('application/whoispp-response' 1)		#('application/vnd.mozilla.xul+xml' 1)		#('application/parityfec' 1)		#('application/vnd.palm' 1)		#('application/vnd.fsc.weblaunch' 1)		#('application/vnd.tve-trigger' 1)		#('application/dvcs' 1)		#('application/sieve' 1)		#('application/vnd.vividence.scriptfile' 1)		#('application/ms-word-document' 1)		#('application/mac-binhex40' 1)		#('application/mac-compactpro' 1)		#('application/x-gtar' 1)		#('application/x-shockwave-flash' 1)		#('application/x-stuffit' 1)		#('application/x-tar' 1)		#('audio/basic' 1)		#('audio/32kadpcm' 1)		#('audio/vnd.qcelp' 1)		#('audio/vnd.digital-winds' 1)		#('audio/vnd.lucent.voice' 1)		#('audio/vnd.octel.sbc' 1)		#('audio/vnd.rhetorex.32kadpcm' 1)		#('audio/vnd.vmx.cvsd' 1)		#('audio/vnd.nortel.vbk' 1)		#('audio/vnd.cns.anp1' 1)		#('audio/vnd.cns.inf1' 1)		#('audio/L16' 1)		#('audio/vnd.everad.plj' 1)		#('audio/telephone-event' 1)		#('audio/tone' 1)		#('audio/prs.sid' 1)		#('audio/vnd.nuera.ecelp4800' 1)		#('audio/vnd.nuera.ecelp7470' 1)		#('audio/mpeg' 1)		#('audio/parityfec' 1)		#('audio/MP4A-LATM' 1)		#('audio/midi' 1)		#('audio/x-aiff' 1)		#('audio/x-pn-realaudio' 1)		#('audio/x-pn-realaudio' 1)		#('audio/x-pn-realaudio-plugin' 1)		#('audio/x-realaudio' 1)		#('audio/x-wav' 1)		#('image/jpeg' 1)		#('image/gif' 1)		#('image/ief' 1)		#('image/g3fax' 1)		#('image/tiff' 1)		#('image/cgm' 1)		#('image/naplps' 1)		#('image/vnd.dwg' 1)		#('image/vnd.svf' 1)		#('image/vnd.dxf' 1)		#('image/png' 1)		#('image/vnd.fpx' 1)		#('image/vnd.net-fpx' 1)		#('image/vnd.xiff' 1)		#('image/prs.btif' 1)		#('image/vnd.fastbidsheet' 1)		#('image/vnd.wap.wbmp' 1)		#('image/prs.pti' 1)		#('image/vnd.cns.inf2' 1)		#('image/vnd.mix' 1)		#('image/vnd.fujixerox.edmics-rlc' 1)		#('image/vnd.fujixerox.edmics-mmr' 1)		#('image/vnd.fst' 1)		#('image/x-xbitmap' 1)		#('message/delivery-status' 0)		#('message/external-body' 0)		#('message/htpp' 0)		#('message/news' 0)		#('message/partial' 0)		#('message/rfc822' 0)		#('message/s-http' 0)		#('multipart/mixed' 0)		#('multipart/alternative' 0)		#('multipart/digest' 0)		#('multipart/parallel' 0)		#('multipart/appledouble' 0)		#('multipart/header-set' 0)		#('multipart/form-data' 0)		#('multipart/related' 0)		#('multipart/report' 0)		#('multipart/voice-message' 0)		#('multipart/signed' 0)		#('multipart/encrypted' 0)		#('multipart/byteranges' 0)		#('text/plain' 0)		#('text/richtext' 0)		#('text/enriched' 0)		#('text/tab-separated-values' 0)		#('text/html' 0)		#('text/sgml' 0)		#('text/vnd.latex-z' 0)		#('text/vnd.fmi.flexstor' 0)		#('text/uri-list' 0)		#('text/vnd.abc' 0)		#('text/rfc822-headers' 0)		#('text/vnd.in3d.3dml' 0)		#('text/prs.lines.tag' 0)		#('text/vnd.in3d.spot' 0)		#('text/css' 0)		#('text/xml' 0 #(#lineEndConvention 2))		#('text/rtf' 0)		#('text/directory' 0)		#('text/calendar' 0)		#('text/vnd.wap.wml' 0)		#('text/vnd.wap.wmlscript' 0)		#('text/vnd.motorola.reflex' 0)		#('text/vnd.fly' 0)		#('text/vnd.wap.sl' 0)		#('text/vnd.wap.si' 0)		#('text/t140' 0)		#('text/vnd.ms-mediapackage' 0)		#('text/vnd.IPTC.NewsML' 0)		#('text/vnd.IPTC.NITF' 0)		#('text/vnd.curl' 0)		#('text/vnd.DMClientScript' 0)		#('text/parityfec' 0)		#('video/mpeg' 1)		#('video/quicktime' 1)		#('video/vnd.vivo' 1)		#('video/vnd.motorola.video' 1)		#('video/vnd.motorola.videop' 1)		#('video/vnd.fvt' 1)		#('video/pointer' 1)		#('video/parityfec' 1)		#('video/vnd.mpegurl' 1)		#('video/MP4V-ES' 1)		#('video/x-msvideo' 1)		#('video/x-sgi-movie' 1)		#('model/iges' 1)		#('model/vrml' 1)		#('model/mesh' 1)		#('model/vnd.dwf' 1)		#('model/vnd.gtw' 1)		#('model/vnd.flatland.3dml' 1)		#('model/vnd.vtu' 1)		#('model/vnd.mts' 1)		#('model/vnd.gdl' 1)		#('model/vnd.gs-gdl' 1)		#('model/vnd.parasolid.transmit.text' 1)		#('model/vnd.parasolid.transmit.binary' 1)	)</body><body package="NetClientBase" selector="initialize">initialize	" MimeTypeDescriptor initialize "	self 		initializeMimeTypes;		initializeFileExtensionToMimeTypeMap;		initializeMimeCharsetToEncodingMap</body><body package="NetClientBase" selector="initializeFileExtensionToMimeTypeMap">initializeFileExtensionToMimeTypeMap	FileExtensionToMimeTypeMap := Dictionary new: 32.	self defaultFileExtensionMap do: [ :element | 		FileExtensionToMimeTypeMap at: element first put: element last].	FileExtensionToMimeTypeMap		at: 'html' put: 'text/html';		at: 'htm' put: 'text/html';		at: 'xml' put: 'text/xml';		at: 'txt' put: 'text/plain';		at: 'c' put: 'text/plain';		at: 'cpp' put: 'text/plain';		at: 'h' put: 'text/plain';		at: 'hpp' put: 'text/plain';		at: 'st' put: 'text/plain';		at: 'pst' put: 'text/plain';		at: 'cls' put: 'text/plain';		at: 'gif' put: 'image/gif';		at: 'jpg' put: 'image/jpeg';		at: 'jpeg' put: 'image/jpeg';		at: 'xbm' put: 'image/x-xbitmap';		at: 'mid' put: 'audio/midi';		at: 'doc' put: 'application/ms-word-document';	at: 'hqx' put: 'application/mac-binhex40';	at: 'cpt' put: 'application/mac-compactpro';	at: 'pdf' put: 'application/pdf';	at: 'ps' put: 'application/postscript';	at: 'ai' put: 'application/postscript';	at: 'eps' put: 'application/postscript';	at: 'rtf' put: 'text/rtf';	at: 'bin' put: 'application/octet-stream';	at: 'dms' put: 'application/octet-stream';	at: 'lha' put: 'application/octet-stream';	at: 'lzh' put: 'application/octet-stream';	at: 'exe' put: 'application/octet-stream';	at: 'class' put: 'application/octet-stream';	at: 'pcl' put: 'application/octet-stream';	at: 'im' put: 'application/octet-stream';	at: 'img' put: 'application/octet-stream';	at: 'zip' put: 'application/zip';	at: 'gz' put: 'application/gzip';	at: 'gtar' put: 'application/x-gtar';	at: 'swf' put: 'application/x-shockwave-flash';	at: 'sit' put: 'application/x-stuffit';	at: 'tar' put: 'application/x-tar';	at: 'au' put: 'audio/basic';	at: 'snd' put: 'audio/basic';	at: 'mid' put: 'audio/midi';	at: 'midi' put: 'audio/midi';	at: 'mpga' put: 'audio/mpeg';	at: 'mp2' put: 'audio/mpeg';	at: 'mp3' put: 'audio/mpeg';	at: 'aiff' put: 'audio/x-aiff';	at: 'aif' put: 'audio/x-aiff';	at: 'aifc' put: 'audio/x-aiff';	at: 'rm' put: 'audio/x-pn-realaudio';	at: 'ram' put: 'audio/x-pn-realaudio';	at: 'rpm' put: 'audio/x-pn-realaudio-plugin';	at: 'ra' put: 'audio/x-realaudio';	at: 'wav' put: 'audio/x-wav';	at: 'css' put: 'text/css';	at: 'mpeg' put: 'video/mpeg';	at: 'mpg' put: 'video/mpeg';	at: 'mpe' put: 'video/mpeg';	at: 'qt' put: 'video/quicktime';	at: 'mov' put: 'video/quicktime';	at: 'avi' put: 'video/x-msvideo';	at: 'movie' put: 'video/x-sgi-movie'.</body><body package="NetClientBase" selector="initializeMimeCharsetToEncodingMap">initializeMimeCharsetToEncodingMap	MimeCharsetToEncodingMap := IdentityDictionary new: 5.	#(		#(us-ascii ISO8859_1"ASCII")		#(default ISO8859_1"ASCII")		#('iso-8859-1' ISO8859_1)		#(binary binary)	) do: [ :arr | MimeCharsetToEncodingMap at: arr first asSymbol put: arr last asSymbol ]</body><body package="NetClientBase" selector="initializeMimeTypes">initializeMimeTypes	| contentType entity token binary |	MimeTypeRegistry := Dictionary new: 32.	self defaultMimeTypes do: [ :literalArray |		entity := MimeTypeDescriptor new.		contentType := literalArray at: 1.		entity contentType: contentType.		binary := (literalArray at: 2) = 1.		entity binary: binary.		3 to: literalArray size do: [ :idx |			token := literalArray at: idx.			(token isKindOf: Array)				ifTrue: [entity propertyAt: token first put: token last]].		MimeTypeRegistry at: contentType put: entity].</body></methods><methods><class-id>Net.MimeTypeDescriptor class</class-id> <category>Mime character sets</category><body package="NetClientBase" selector="defaultCharacterSet">defaultCharacterSet" Answer default character set that we use ""	#todo.			 Rework because we may use different character sets on different platforms "	^self iso8859x1</body><body package="NetClientBase" selector="defaultEncoding">defaultEncoding" Answer default character encoding that we use "	^self encodingForCharset: self defaultCharacterSet</body><body package="NetClientBase" selector="defaultMimeCharacterSet">defaultMimeCharacterSet" Default character set if none is specified "	^self usAscii</body><body package="NetClientBase" selector="encodingForCharset:">encodingForCharset: aCharsetName" 	MimeTypeDescriptor encodingForCharset: #us-ascii	MimeTypeDescriptor encodingForCharset: 'ISO-8859-1' "	^MimeCharsetToEncodingMap 		at: aCharsetName asLowercase asSymbol 		ifAbsent: [ self encodingForCharset: #default ]</body><body package="NetClientBase" selector="iso8859x1">iso8859x1	^'iso-8859-1'</body><body package="NetClientBase" selector="iso8859x1Encoding">iso8859x1Encoding	^self encodingForCharset: self iso8859x1</body><body package="NetClientBase" selector="usAscii">usAscii" Default canonical character set for Mime messages "	^'us-ascii'</body><body package="NetClientBase" selector="usAsciiEncoding">usAsciiEncoding" Encoding name for us-ascii charset "	^self encodingForCharset: self usAscii</body></methods><methods><class-id>Net.MimeTypeDescriptor class</class-id> <category>private</category><body package="NetClientBase" selector="guessFromExtension:">guessFromExtension: aString	"guesses a content type from the extension"	^self guessFromExtension: aString ifAbsent: [self defaultUnsupportedContentType].</body><body package="NetClientBase" selector="guessFromExtension:ifAbsent:">guessFromExtension: aString ifAbsent: aBlock"Guesses a content type from the extension. aString represents a file extension. Possible values: '.xxx', 'xxx', nil."	| ext |	aString isNil ifTrue: [^aBlock value].	ext := aString first == $.		ifTrue: [ aString copyFrom: 2 to: aString size ]		ifFalse: [ aString ].	^ FileExtensionToMimeTypeMap at: ext asLowercase ifAbsent: aBlock.</body></methods><methods><class-id>Net.NetUser</class-id> <category>accessing</category><body package="NetClientBase" selector="account">account	^account</body><body package="NetClientBase" selector="account:">account: aString	account := aString</body><body package="NetClientBase" selector="asText">asText	^self fullName</body><body package="NetClientBase" selector="fullName">fullName	^fullName</body><body package="NetClientBase" selector="fullName:">fullName: aString	fullName := aString</body><body package="NetClientBase" selector="mailAddress">mailAddress	^mailAddress</body><body package="NetClientBase" selector="mailAddress:">mailAddress: aString	mailAddress := aString</body><body package="NetClientBase" selector="name">name	^self username</body><body package="NetClientBase" selector="password">password	^password</body><body package="NetClientBase" selector="password:">password: aString 	password := aString</body><body package="NetClientBase" selector="registry">registry	^self class registry</body><body package="NetClientBase" selector="savePassword">savePassword	^savePassword</body><body package="NetClientBase" selector="savePassword:">savePassword: aBoolean	savePassword := aBoolean</body><body package="NetClientBase" selector="username">username	^username</body><body package="NetClientBase" selector="username:">username: aString 	username := aString</body></methods><methods><class-id>Net.NetUser</class-id> <category>testing</category><body package="NetClientBase" selector="isDefaultIdentity">isDefaultIdentity	^self registry isDefaultIdentity: self</body></methods><methods><class-id>Net.NetUser</class-id> <category>update</category><body package="NetClientBase" selector="updateBy:">updateBy: aNetUser	self  fullName: aNetUser fullName;		username: aNetUser username;		account: aNetUser account;		password: aNetUser password;		mailAddress: aNetUser mailAddress;		savePassword: aNetUser savePassword.</body></methods><methods><class-id>Net.NetUser</class-id> <category>printing</category><body package="NetClientBase" selector="asString">asString	| stream |	stream := (String new: 64) writeStream.	self printOn: stream.	^stream contents</body><body package="NetClientBase" selector="printDefaultOn:">printDefaultOn: aStream 	aStream nextPutAll: (#Default &lt;&lt; #net &gt;&gt; ' (Default) ') asString</body><body package="NetClientBase" selector="printMailAddressOn:">printMailAddressOn: aStream 	self mailAddress notNil			ifTrue: [  aStream nextPutAll: '  &lt;', self mailAddress, '&gt;'].</body><body package="NetClientBase" selector="printNameOn:">printNameOn: aStream 	self fullName notNil		ifTrue: [ aStream nextPutAll: self fullName]		ifFalse: 			[ aStream nextPutAll: self class name asString.			username notNil 				ifTrue: 					[aStream space; 						nextPutAll: username; 						nextPutAll: (#PasswordConcealed &lt;&lt; #net &gt;&gt; ' password (concealed)') asString]].</body><body package="NetClientBase" selector="printOn:">printOn: aStream 	self printNameOn: aStream.	self isDefaultIdentity ifTrue: [	self printDefaultOn: aStream ].	self printMailAddressOn: aStream</body><body package="NetClientBase" selector="specFrom:">specFrom: aDict	aDict keysAndValuesDo:		[ :key :value |			self instVarAt: ( self class instVarIndexFor: key) put: (Compiler evaluate: value readStream)]</body><body package="NetClientBase" selector="specString">specString	| stream value |	stream := (String new: 128) writeStream.	self class instVarNames 		do: [ :ins | 			(value := self instVarAt: ( self class instVarIndexFor: ins)) notNil 				ifTrue: 					[stream nextPutAll:  ins, ' = ', value printString; cr]].	^stream contents.</body></methods><methods><class-id>Net.NetUser</class-id> <category>persistence</category><body package="NetClientBase" selector="asXmlNode:">asXmlNode: aString 	^Settings netObject: self asXmlNode: aString</body></methods><methods><class-id>Net.NetUser class</class-id> <category>accessing</category><body package="NetClientBase" selector="lastUser">lastUser	^LastUser</body><body package="NetClientBase" selector="registry">registry	^Settings</body></methods><methods><class-id>Net.NetUser class</class-id> <category>instance creation</category><body package="NetClientBase" selector="request">request	"NetUser request"	| username password cancel |	username := (LastUser isNil					ifTrue: ['']					ifFalse: [LastUser]) asValue.	password := '' asValue.	cancel := (SimpleDialog initializedFor: nil)				setInitialGap;				addMessage: (#Username &lt;&lt; #net &gt;&gt; 'Username') textLine: username boundary: 0.4;				addGap;				addMessage: (#Password &lt;&lt; #net &gt;&gt; 'Password') textLine: password type: #password boundary: 0.4;				addGap;				addOK: [true];				openDialog;				cancel.	username value isEmpty ifFalse:		[LastUser := username value].	cancel value ifTrue: [^nil].	^self new 		username: username value; 		password: password value;		yourself</body><body package="NetClientBase" selector="request:">request: label	"NetUser request: ('Login to &lt;1s&gt; server &lt;2s&gt;' expandMacrosWith: 'POP3' with: 'sulu.cincom.com')"	| username password cancel |	username := (LastUser isNil					ifTrue: ['']					ifFalse: [LastUser]) asValue.	password := '' asValue.	cancel := (SimpleDialog initializedFor: nil)				setInitialGap;				addMessage: label centered: true;				addGap;				addMessage: (#Username &lt;&lt; #net &gt;&gt; 'Username') textLine: username boundary: 0.4;				addGap;				addMessage: (#Password &lt;&lt; #net &gt;&gt; 'Password') textLine: password type: #password boundary: 0.4;				addGap;				addOK: [true];				openDialog;				cancel.	username value isEmpty ifFalse:		[LastUser := username value].	cancel value ifTrue: [^nil].	^self new 		username: username value; 		password: password value;		yourself</body><body package="NetClientBase" selector="username:password:">username: aUsername password: aPassword	"PopUser username: 'foo' password: 'foo'"	|user|	user := self new.	LastUser := aUsername.	^user 		fullName: aUsername;		username: aUsername;		password: aPassword;		yourself</body></methods><methods><class-id>Net.NetUser class</class-id> <category>persistance</category><body package="NetClientBase" selector="restoreValueFrom:">restoreValueFrom: xmlColl	^Settings restoreNetObject: self new from:  xmlColl</body></methods><methods><class-id>Net.UTF7StreamEncoder</class-id> <category>testing</category><body package="NetClientBase" selector="isASCII:">isASCII: code	^(self isNotASCII: code) not</body><body package="NetClientBase" selector="isNotASCII:">isNotASCII: code	^(code &lt; 31 or: [ code &gt; 127 and: [ code &lt;255]])</body></methods><methods><class-id>Net.UTF7StreamEncoder</class-id> <category>accessing</category><body package="NetClientBase" selector="nextFrom:">nextFrom: aStream	"Decode the next byte(s) in the stream and answer the code."	| code c1 |	aStream peek isNil ifTrue: [ ^nil]. 	code := aStream peek.	(code = self shiftInCode) 		ifTrue: 			[ code := aStream next. 			((code = self shiftInCode) and: [ aStream peek = self shiftOutCode])				ifTrue: [ aStream next.  ^code].			self shifting: true].	((code = self shiftOutCode) and: [ self shifting])		ifTrue: 			[ (c1 := self shiftInNextFrom: aStream) notNil ifTrue: [ ^c1].			self shifting: false.			aStream next.			aStream peek isNil ifTrue: [ ^nil]].	^self shifting		ifTrue: [ self shiftInNextFrom: aStream]		ifFalse:  [aStream next ]</body><body package="NetClientBase" selector="nextPut:on:">nextPut: aCharacter on: aStream	"Encode aCharacter and write it to encoded stream."	|  col c |	c := self encoder encode: aCharacter.	col := OrderedCollection with: c.	c = self shiftInCode		ifTrue: [ col add: self shiftOutCode].	col do: [ :code |  			( (self isNotASCII: code)  and: [ self shifting not ])				ifTrue: 					[ self shiftIn: aStream.					self shifting: true].			( (self isASCII: code)  and: [ self shifting ])				ifTrue: 					[ self prepareToClose: aStream.					self shifting: false ].			self shifting				ifTrue: [ self shiftInNextPut: code on: aStream]				ifFalse: [ aStream nextPut: code]			]</body><body package="NetClientBase" selector="prepareToClose:">prepareToClose: aStream	self shifting		ifTrue: 			[super prepareToClose: aStream.			 self shiftOut: aStream]</body></methods><methods><class-id>Net.UTF7StreamEncoder</class-id> <category>private</category><body package="NetClientBase" selector="charsToPad">charsToPad	^0</body><body package="NetClientBase" selector="shiftIn:">shiftIn: aStream	aStream nextPut: self shiftInCode</body><body package="NetClientBase" selector="shiftInCode">shiftInCode	^$+ asInteger</body><body package="NetClientBase" selector="shifting">shifting	^shifting isNil		ifTrue: [ shifting := false ]		ifFalse: [ shifting ]</body><body package="NetClientBase" selector="shifting:">shifting: aBoolean	shifting := aBoolean</body><body package="NetClientBase" selector="shiftInNextFrom:">shiftInNextFrom: aStream 	|  c1 c2 | 	c1 := super nextFrom: aStream.	c1 == nil ifTrue: [^nil].	c2 := super nextFrom: aStream.	c2 == nil ifTrue: [^nil].	^(c1 bitShift: 8) + c2.</body><body package="NetClientBase" selector="shiftInNextPut:on:">shiftInNextPut: code on: aStream	| c1 c2 |	c1 := code bitShift: -8.	c2 := code bitAnd: 16rFF.	self privateNextPut: c1 on: aStream.	self privateNextPut: c2 on: aStream.</body><body package="NetClientBase" selector="shiftOut:">shiftOut: aStream	aStream nextPut: self shiftOutCode</body><body package="NetClientBase" selector="shiftOutCode">shiftOutCode	^$- asInteger</body></methods><methods><class-id>Net.UTF7StreamEncoder</class-id> <category>manipulating sextets</category><body package="NetClientBase" selector="fillNibbleFrom:">fillNibbleFrom: aStream	|  nSextets code enc |	enc := self class octetMap.	nibble := 0.	nSextets := 0.	1 to: 4 do: [ :idx |		(aStream atEnd or: [aStream peek == self shiftOutCode]) ifTrue: [ ^nSextets ].		(code := aStream next) isNil ifTrue: [ ^nSextets ].		nibble := nibble bitOr: ((enc at: code ) bitShift: (self shiftValueAt: idx)).		nSextets := nSextets + 1.	].	^nSextets</body></methods><methods><class-id>Net.UTF7StreamEncoder class</class-id> <category>private</category><body package="NetClientBase" selector="defaultCharacterEncoder">defaultCharacterEncoder	^UnicodeCharacterEncoder new</body></methods><methods><class-id>Net.UTF7StreamEncoder class</class-id> <category>accessing</category><body package="NetClientBase" selector="streamEncodingType">streamEncodingType	^#UTF_7</body></methods><methods><class-id>Net.UTF7StreamEncoder class</class-id> <category>class initialization</category><body package="NetClientBase" selector="initialize">initialize	"Initialize class variables"	super initialize</body></methods><methods><class-id>Net.NetClient</class-id> <category>accessing</category><body package="NetClientBase" selector="clientPI">clientPI	^clientPI isNil		ifTrue: [clientPI := self protocolInterpreterClass new]		ifFalse: [clientPI]</body><body package="NetClientBase" selector="clientPI:">clientPI: anProtocolInterpreter 	clientPI := anProtocolInterpreter</body><body package="NetClientBase" selector="delaySeconds">delaySeconds	delaySeconds isNil ifTrue: [ delaySeconds := self defaultDelaySeconds].	^ delaySeconds</body><body package="NetClientBase" selector="delaySeconds:">delaySeconds: aNumber	delaySeconds := aNumber</body><body package="NetClientBase" selector="hostName">hostName	^hostName</body><body package="NetClientBase" selector="hostName:">hostName: aString	hostName := aString</body><body package="NetClientBase" selector="password">password	^self user password</body><body package="NetClientBase" selector="portNumber">portNumber	^portNumber ifNil: [ self defaultPortNumber ].</body><body package="NetClientBase" selector="portNumber:">portNumber: aNumber	portNumber := aNumber</body><body package="NetClientBase" selector="protocolInterpreterClass">protocolInterpreterClass	^self subclassResponsibility</body><body package="NetClientBase" selector="retries">retries	retries isNil ifTrue: [retries := self defaultRetries].	^retries</body><body package="NetClientBase" selector="retries:">retries: aNumber	retries := aNumber</body><body package="NetClientBase" selector="timeout">timeout	timeout isNil ifTrue: [ timeout := self defaultTimeout].	^timeout</body><body package="NetClientBase" selector="timeout:">timeout: aNumber	timeout := aNumber</body><body package="NetClientBase" selector="user">user	^user</body><body package="NetClientBase" selector="user:">user: aNetUser	user := aNetUser</body><body package="NetClientBase" selector="username">username	^self user username</body></methods><methods><class-id>Net.NetClient</class-id> <category>connection</category><body package="NetClientBase" selector="connect">connect	"Establish a connection to the host"	^self clientPI connectToHost: self hostName port: self portNumber.</body><body package="NetClientBase" selector="connectIfClosed">connectIfClosed	self clientPI closed 		ifTrue: [self connect ]</body><body package="NetClientBase" selector="connectToHost:">connectToHost: aString	"Establish a connection to the host &lt;aString&gt;."	^ self connectToHost: aString port: nil</body><body package="NetClientBase" selector="connectToHost:port:">connectToHost: aString port: aNumber 	"Establish a connection to the host &lt;aString&gt;."	self hostName: aString.	self portNumber: aNumber.	self connect.</body><body package="NetClientBase" selector="disconnect">disconnect	"Disconnect from the host"	self logout.	clientPI disconnect.	clientPI := nil</body><body package="NetClientBase" selector="isConnected">isConnected	^self subclassResponsibility</body><body package="NetClientBase" selector="login">login</body><body package="NetClientBase" selector="loginAsUser:withPassword:">loginAsUser: userString withPassword: passwdString "Login to the host using the specified user name &lt;aString&gt;  and password&lt;aString&gt;"	user := NetUser username: userString password: passwdString.	self loginToHost</body><body package="NetClientBase" selector="loginToHost">loginToHost"Login to the host"	self login</body><body package="NetClientBase" selector="loginToHost:asUser:withPassword:">loginToHost: aHostName asUser: userString withPassword: passwdString "Connect and login to the host &lt;aString&gt;  using the specified user name&lt;aString&gt; and password&lt;aString&gt;"	^self		loginToHost: aHostName		port: nil		asUser: userString		withPassword: passwdString</body><body package="NetClientBase" selector="loginToHost:port:asUser:withPassword:">loginToHost: aHostName port: aNumber asUser: userString withPassword: passwdString "Connect and login to the host &lt;aString&gt;  using the specified user name&lt;aString&gt; and password&lt;aString&gt;"	self connectToHost: aHostName port: aNumber.	self loginAsUser: userString withPassword: passwdString.</body><body package="NetClientBase" selector="logout">logout</body><body package="NetClientBase" selector="reconnect">reconnect	"Reconnect to the host"	self disconnect.	self connect.</body></methods><methods><class-id>Net.NetClient</class-id> <category>printing</category><body package="NetClientBase" selector="printOn:">printOn: aStream	aStream nextPutAll: 'a', self class name.	self hostName notNil		ifTrue: [aStream 					nextPutAll: ' on: ';					nextPutAll: self hostName;					nextPut: $:;					nextPutAll: self portNumber printString].</body></methods><methods><class-id>Net.NetClient</class-id> <category>defaults</category><body package="NetClientBase" selector="defaultDelaySeconds">defaultDelaySeconds	^self class defaultDelaySeconds</body><body package="NetClientBase" selector="defaultPortNumber">defaultPortNumber	^self class defaultPortNumber</body><body package="NetClientBase" selector="defaultRetries">defaultRetries	^self class defaultRetries</body><body package="NetClientBase" selector="defaultTimeout">defaultTimeout	^self class defaultTimeout</body></methods><methods><class-id>Net.NetClient</class-id> <category>debugging</category><body package="NetClientBase" selector="log:level:">log: aString level: aLevel	self class log: aString level: aLevel</body></methods><methods><class-id>Net.NetClient</class-id> <category>persistence</category><body package="NetClientBase" selector="asXmlNode:">asXmlNode: aString 	^Settings netObject: self asXmlNode: aString</body></methods><methods><class-id>Net.NetClient class</class-id> <category>instance creation</category><body package="NetClientBase" selector="connectToHost:">connectToHost: aHostname "Create NetClient object, establish a connection to the host &lt;aString&gt;"	^self new connectToHost: aHostname port: nil</body><body package="NetClientBase" selector="connectToHost:port:">connectToHost: aHostname port: aPort"Create NetClient object, establish a connection to the host &lt;aString&gt; and port &lt;aString&gt;"	^self new connectToHost: aHostname port: aPort</body><body package="NetClientBase" selector="host:">host: aHostname"Create NetClient object, set up the host &lt;aString&gt;"	^(self new) 		hostName: aHostname; 		yourself</body><body package="NetClientBase" selector="host:port:">host: aHostname port: aPort "Create NetClient object, set up the host &lt;aString&gt; and port &lt;aString&gt;"	^(self new) 		hostName: aHostname; 		portNumber: aPort; 		yourself</body><body package="NetClientBase" selector="loginToHost:asUser:withPassword:">loginToHost: aHostName asUser: userString withPassword: passwdString "Create NetClient object, connect and login to the host &lt;aString&gt;  using the specified user name&lt;aString&gt;&amp;  password&lt;aString&gt; "	^self loginToHost: aHostName port: nil asUser: userString withPassword: passwdString</body><body package="NetClientBase" selector="loginToHost:port:asUser:withPassword:">loginToHost: aHostName port: aNumber asUser: userString withPassword: passwdString "Create NetClient object, connect and login to the host &lt;aString&gt;  using the specified user name&lt;aString&gt;,  password&lt;aString&gt; &amp; port &lt;aNumber&gt;"	^self new		loginToHost: aHostName 		port: aNumber 		asUser: userString 		withPassword: passwdString</body></methods><methods><class-id>Net.NetClient class</class-id> <category>debugging</category><body package="NetClientBase" selector="debugLabelsAndValues">debugLabelsAndValues	^OrderedCollection new		add: ((#NetClientMessages &lt;&lt; #net &gt;&gt; 'Net Client Messages')-&gt;#NetClient);		yourself</body><body package="NetClientBase" selector="log:level:">log: aString level: aLevel	Tools.LogEnvironment default log: aString level: aLevel</body><body package="NetClientBase" selector="menuItemName">menuItemName	^(#NetClientMessages &lt;&lt; #net &gt;&gt; 'Net Client Messages')</body><body package="NetClientBase" selector="registerToDebug">registerToDebug	Tools.LogEnvironment default addToDebug: self</body></methods><methods><class-id>Net.NetClient class</class-id> <category>defaults</category><body package="NetClientBase" selector="defaultDelaySeconds">defaultDelaySeconds	^DefaultDelaySeconds isNil		ifTrue: [ DefaultDelaySeconds := self defaultDelaySecondsValue ]		ifFalse: [ DefaultDelaySeconds ]</body><body package="NetClientBase" selector="defaultDelaySeconds:">defaultDelaySeconds: aNumber	DefaultDelaySeconds := aNumber</body><body package="NetClientBase" selector="defaultDelaySecondsValue">defaultDelaySecondsValue	^10</body><body package="NetClientBase" selector="defaultIncomingMailClient">defaultIncomingMailClient	DefaultIncomingMailClient isNil		ifTrue: [ self newDefaultIncomingMailClient ].	^DefaultIncomingMailClient</body><body package="NetClientBase" selector="defaultIncomingMailClient:">defaultIncomingMailClient: aMailClient	DefaultIncomingMailClient := aMailClient</body><body package="NetClientBase" selector="defaultOutgoingMailClient">defaultOutgoingMailClient	DefaultOutgoingMailClient isNil		ifTrue: [ self newDefaultOutgoingMailClient ].	^DefaultOutgoingMailClient</body><body package="NetClientBase" selector="defaultOutgoingMailClient:">defaultOutgoingMailClient: aMailClient	DefaultOutgoingMailClient := aMailClient</body><body package="NetClientBase" selector="defaultPortNumber">defaultPortNumber	^self subclassResponsibility</body><body package="NetClientBase" selector="defaultRetries">defaultRetries	^DefaultRetries isNil		ifTrue: [ DefaultRetries := self defaultRetriesValue]		ifFalse: [ DefaultRetries ]</body><body package="NetClientBase" selector="defaultRetries:">defaultRetries: aNumber	DefaultRetries := aNumber</body><body package="NetClientBase" selector="defaultRetriesValue">defaultRetriesValue	^5</body><body package="NetClientBase" selector="defaultTimeout">defaultTimeout	^DefaultTimeout isNil		ifTrue: [ DefaultTimeout := self defaultTimeoutValue ]		ifFalse: [ DefaultTimeout ]</body><body package="NetClientBase" selector="defaultTimeout:">defaultTimeout: aNumber	DefaultTimeout := aNumber</body><body package="NetClientBase" selector="defaultTimeoutValue">defaultTimeoutValue	^20000</body></methods><methods><class-id>Net.NetClient class</class-id> <category>reset defaults</category><body package="NetClientBase" selector="resetDefaultIncomingMailClient">resetDefaultIncomingMailClient	DefaultIncomingMailClient := nil.</body><body package="NetClientBase" selector="resetDefaultOutgoingMailClient">resetDefaultOutgoingMailClient	DefaultOutgoingMailClient := nil.</body><body package="NetClientBase" selector="resetDefaults">resetDefaults	self 		resetDefaultIncomingMailClient;		resetDefaultOutgoingMailClient.</body></methods><methods><class-id>Net.NetClient class</class-id> <category>class initialization</category><body package="NetClientBase" selector="initialize">initialize	"self initialize"	( self netSettings dependents includes: self )		ifFalse:	[ self netSettings addDependent: self ].	self registerClass.</body><body package="NetClientBase" selector="obsolete">obsolete	"Break dependencies"	[self netSettings dependents includes: self] whileTrue:		[self netSettings removeDependent: self].	^super obsolete</body></methods><methods><class-id>Net.NetClient class</class-id> <category>testing</category><body package="NetClientBase" selector="isIncomingMailClient">isIncomingMailClient	^false</body><body package="NetClientBase" selector="isMailClient">isMailClient	^false</body></methods><methods><class-id>Net.NetClient class</class-id> <category>registry</category><body package="NetClientBase" selector="mailRegistry">mailRegistry	^MailRegistry isNil		ifTrue: [ MailRegistry := IdentityDictionary new]		ifFalse: [ MailRegistry ]</body><body package="NetClientBase" selector="netSettings">netSettings	^Settings</body><body package="NetClientBase" selector="registerClass">registerClass</body><body package="NetClientBase" selector="registerClass:">registerClass: aClass	self mailRegistry at: aClass serverType put: aClass name</body></methods><methods><class-id>Net.NetClient class</class-id> <category>private</category><body package="NetClientBase" selector="loadParcelDialog:host:">loadParcelDialog: aText host: host	 ^Dialog warn: ((#SupportParcelShouldBeLoaded &lt;&lt; #net &gt;&gt; 'To create &lt;1s&gt; &lt;n&gt;&lt;2s&gt;Support parcel should be loaded!')			expandMacrosWith: aText			with: host type)</body><body package="NetClientBase" selector="newDefaultIncomingMailClient">newDefaultIncomingMailClient	| client  host |	(host := self netSettings defaultIncomingHost ) notNil		ifTrue: 			[  ( client := self mailRegistry at: host type asSymbol ifAbsent: [nil]) isNil				ifTrue: [ self loadParcelDialog: (#defaultIncomingMailClient &lt;&lt; #net &gt;&gt; 'default incoming mail client') host: host]				ifFalse: 					[ DefaultIncomingMailClient := (LiteralBindingReference pathString: 'Net.',client) value new												hostName: host name;												portNumber: host port;												user: host netUser;												yourself.]]		ifFalse: [ self updateSettingsDialog: (#defaultIncomingMailServer &lt;&lt; #net &gt;&gt; 'default incoming mail server')]</body><body package="NetClientBase" selector="newDefaultOutgoingMailClient">newDefaultOutgoingMailClient	| client  host |	(host := self netSettings defaultOutgoingHost) notNil		ifTrue: 			[  ( client := self mailRegistry at: host type asSymbol ifAbsent: [nil]) isNil				ifTrue: [ self loadParcelDialog: (#defaultOutgoingMailClient &lt;&lt; #net &gt;&gt; 'default outgoing mail client') host: host]				ifFalse: 					[ DefaultOutgoingMailClient := (LiteralBindingReference pathString: 'Net.',client) value new												hostName: host name;												portNumber: host port;												user: host netUser;												yourself.]]		ifFalse: [ self updateSettingsDialog: (#defaultOutgoingMailServer &lt;&lt; #net &gt;&gt; 'default outgoing mail server')]</body><body package="NetClientBase" selector="update:with:from:">update: anAspect with: arguments from: anObject	anAspect == #changedDefaultOutgoingServer		ifTrue: [self resetDefaultOutgoingMailClient].	anAspect == #changedDefaultIncomingServer		ifTrue: [self resetDefaultIncomingMailClient].	anAspect == #returnFromSnapshot 		ifTrue: [self resetDefaults ].</body><body package="NetClientBase" selector="updateSettingsDialog:">updateSettingsDialog: aText	 ^Dialog warn: ((#YouNeedToUpdateNetworkSetting &lt;&lt; #net &gt;&gt; 'You need to update Tools-%&gt;Network Setting.. for &lt;1s&gt;')			expandMacrosWith: aText)</body></methods><methods><class-id>Net.NetClient class</class-id> <category>constants</category><body package="NetClientBase" selector="description">description	^''</body><body package="NetClientBase" selector="serverType">serverType</body></methods><methods><class-id>Net.NetClient class</class-id> <category>persistance</category><body package="NetClientBase" selector="restoreValueFrom:">restoreValueFrom: xmlColl	^Settings restoreNetObject: self new from:  xmlColl</body></methods><methods><class-id>Net.ErrorMessageBox</class-id> <category>actions</category><body package="NetClientBase" selector="copyToClipboard">copyToClipboard	"Copy the message to the clipboard"	[Screen default putExternalSelection: self errorMessage value asString ]		on: Object errorSignal		do: [:ex | 				Screen default putExternalSelection: ''.				ex return].</body><body package="NetClientBase" selector="ok">ok	self accept value: true.</body><body package="NetClientBase" selector="openNotifier">openNotifier	"Open a debugger on the error."	self halt.	self ok.		"incase the debugger returns here:"</body></methods><methods><class-id>Net.ErrorMessageBox</class-id> <category>aspects</category><body package="NetClientBase" selector="errorMessage">errorMessage	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^errorMessage isNil		ifTrue:			[errorMessage := String new asValue]		ifFalse:			[errorMessage]</body><body package="NetClientBase" selector="labelFor:">labelFor: aKey	aKey == #Title		ifFalse: [ ^nil ].	^titleString == nil		ifTrue: [ (#DatabaseError &lt;&lt; #net &gt;&gt; 'Database Error') asString]		ifFalse: [ titleString ].</body><body package="NetClientBase" selector="titleString:">titleString: aString	titleString := aString.</body></methods><methods><class-id>Net.ErrorMessageBox class</class-id> <category>utilities</category><body package="NetClientBase" selector="openOnMessage:">openOnMessage: errorMessageString	"self openOnMessage: 'errorMessageString'"	^self openOnMessage: errorMessageString title: (#InternetConnectivity &lt;&lt; #net &gt;&gt; 'Internet Connectivity')</body><body package="NetClientBase" selector="openOnMessage:title:">openOnMessage: errorMessageString title: aString	"self openOnMessage: 'errorMessageString'"	| box |	box := self new.	box errorMessage value: errorMessageString.	box	titleString: aString.	box	open.	^box</body></methods><methods><class-id>Net.Settings</class-id> <category>persistence</category><body package="NetClientBase" selector="addStateXmlElementsTo:">addStateXmlElementsTo: rootElement	self class addStateXmlElementsTo: rootElement</body><body package="NetClientBase" selector="restoreFrom:">restoreFrom: aSettingSnapshot	self class importSnapshots: aSettingSnapshot stateNodes</body></methods><methods><class-id>Net.Settings</class-id> <category>initialize-release</category><body package="NetClientBase" selector="initialize">initialize	super initialize.	id := #( net )</body></methods><methods><class-id>Net.Settings class</class-id> <category>accessing settings</category><body package="NetClientBase" selector="anonymousLoginPassword">anonymousLoginPassword	(self registry at: #anonymousLoginPassword ifAbsent: [ nil ]) isNil		ifTrue: 			[(self defaultIdentity notNil and: [self defaultIdentity mailAddress notNil])				ifTrue: 					[self registry at: #anonymousLoginPassword 								put: self defaultIdentity mailAddress]].	^self registry at: #anonymousLoginPassword ifAbsent: [ nil ]</body><body package="NetClientBase" selector="defaultIdentity">defaultIdentity	^self registry at: #defaultIdentity  ifAbsent: [nil ]</body><body package="NetClientBase" selector="defaultIdentity:">defaultIdentity: aNetUser	self registry at: #defaultIdentity  put: aNetUser.	self changed: #changedDefaultIdentity with: aNetUser</body><body package="NetClientBase" selector="defaultIncomingHost">defaultIncomingHost	^self registry at: #defaultIncomingServer   ifAbsent: [nil ]</body><body package="NetClientBase" selector="defaultIncomingHost:">defaultIncomingHost: aHostSpec	self registry at: #defaultIncomingServer  put: aHostSpec.	self changed: #changedDefaultIncomingServer with: aHostSpec</body><body package="NetClientBase" selector="defaultOutgoingHost">defaultOutgoingHost	^self registry at: #defaultOutgoingServer ifAbsent: [ nil ]</body><body package="NetClientBase" selector="defaultOutgoingHost:">defaultOutgoingHost: aHostSpec	self registry at: #defaultOutgoingServer  put: aHostSpec.	self changed: #changedDefaultOutgoingServer with: aHostSpec</body><body package="NetClientBase" selector="ftpAnonymousLoginPassword:">ftpAnonymousLoginPassword: aString	self registry at: #anonymousLoginPassword put: aString.	self changed: #chagedAnonymousLoginPassword with: aString</body><body package="NetClientBase" selector="ftpAnonymousUser">ftpAnonymousUser	^NetUser new			fullName: 'anonymous';			username: 'anonymous';			password: self anonymousLoginPassword;			yourself.</body><body package="NetClientBase" selector="ftpPassiveMode">ftpPassiveMode	^self registry at: #ftpPassiveMode  ifAbsentPut: [ self ftpPassiveModeDefault ]</body><body package="NetClientBase" selector="ftpPassiveMode:">ftpPassiveMode: aBoolean	self registry at: #ftpPassiveMode  put: aBoolean.	self changed: #changedFtpPassiveMode with: aBoolean</body><body package="NetClientBase" selector="ftpPassiveModeDefault">ftpPassiveModeDefault	^false</body><body package="NetClientBase" selector="httpKeepAlive">httpKeepAlive	^self registry at: #httpKeepAlive  ifAbsentPut: [self httpKeepAliveDefault ]</body><body package="NetClientBase" selector="httpKeepAlive:">httpKeepAlive: aBoolean	self registry at: #httpKeepAlive put: aBoolean.	self changed: #changedHttpKeepAlive with: aBoolean.</body><body package="NetClientBase" selector="httpKeepAliveDefault">httpKeepAliveDefault	^true</body><body package="NetClientBase" selector="httpProxyExceptions">httpProxyExceptions	^self registry at: #httpProxyExceptions ifAbsentPut: [OrderedCollection new ]</body><body package="NetClientBase" selector="httpProxyExceptions:">httpProxyExceptions: aList	^self registry at: #httpProxyExceptions put: aList</body><body package="NetClientBase" selector="httpProxyHost">httpProxyHost	^self registry at: #httpProxyHost ifAbsent: [ nil ]</body><body package="NetClientBase" selector="httpProxyHost:">httpProxyHost: aHostSpec	self registry at: #httpProxyHost put: aHostSpec.	self addIdentity: self httpProxyHost netUser.	self changed: #changedHttpProxyHost with: aHostSpec.	httpProxyHostAspect := self registry at: #httpProxyHost.</body><body package="NetClientBase" selector="httpProxyHostAspect">httpProxyHostAspect	^httpProxyHostAspect isNil		ifTrue: 			[httpProxyHostAspect := self httpProxyHost  isNil				ifTrue: [String new]				ifFalse: [ self httpProxyHost]]		ifFalse: [httpProxyHostAspect]</body><body package="NetClientBase" selector="httpProxyUser">httpProxyUser	^self httpProxyHost notNil		ifTrue: [ self httpProxyHost netUser]		ifFalse: [ nil ]</body><body package="NetClientBase" selector="httpRedirectRequest">httpRedirectRequest		^self registry at: #httpRedirectRequest ifAbsent: [ self httpRedirectRequestDefault ]</body><body package="NetClientBase" selector="httpRedirectRequest:">httpRedirectRequest: aBoolean	self registry at: #httpRedirectRequest  put: aBoolean.	self changed: #changedHttpRedirectRequest with: aBoolean</body><body package="NetClientBase" selector="httpRedirectRequestDefault">httpRedirectRequestDefault	^true</body><body package="NetClientBase" selector="httpsAutoload">httpsAutoload	^self registry at: #httpsAutoload  ifAbsentPut: [ true ]</body><body package="NetClientBase" selector="httpsAutoload:">httpsAutoload: aBoolean	self registry at: #httpsAutoload  put: aBoolean.	self changed: #changedHttpsAutoload with: aBoolean</body><body package="NetClientBase" selector="httpSetContentLength">httpSetContentLength	^self registry at: #httpSetContentLength  ifAbsentPut: [ true ]</body><body package="NetClientBase" selector="httpSetContentLength:">httpSetContentLength: aBoolean	self registry at: #httpSetContentLength put: aBoolean.	self changed: #changedHttpSetContentLength with: aBoolean.</body><body package="NetClientBase" selector="httpUseProxy">httpUseProxy	^self registry at: #httpUseProxy  ifAbsentPut: [self httpUseProxyDefault ]</body><body package="NetClientBase" selector="httpUseProxy:">httpUseProxy: aBoolean	self registry at: #httpUseProxy put: aBoolean.	self changed: #changedHttpUseProxy with: aBoolean.</body><body package="NetClientBase" selector="httpUseProxyDefault">httpUseProxyDefault	^false</body><body package="NetClientBase" selector="httpUser">httpUser	^self registry at: #httpUser  ifAbsent: [nil ]</body><body package="NetClientBase" selector="httpUser:">httpUser: aNetUser	self registry at: #httpUser  put: aNetUser.	aNetUser notNil		ifTrue: [	self addIdentity: aNetUser].	self changed: #changedHttpUser with: aNetUser.</body><body package="NetClientBase" selector="identities">identities	^self registry at: #identities  ifAbsentPut: [OrderedCollection new ]</body><body package="NetClientBase" selector="mailServers">mailServers	^self registry at: #mailServers  ifAbsentPut: [OrderedCollection new ]</body><body package="NetClientBase" selector="passwordEncodingForPersistence">passwordEncodingForPersistence	^self registry at: #passwordEncoding  ifAbsentPut: [ Locale current defaultEncoding ]</body><body package="NetClientBase" selector="passwordEncodingForPersistence:">passwordEncodingForPersistence: aSymbol	^self registry at: #passwordEncoding  put: aSymbol</body><body package="NetClientBase" selector="registry">registry	^Registry</body><body package="NetClientBase" selector="setDefaultMailHost:">setDefaultMailHost: aHostSpec	( self isIncomingTypeHost: aHostSpec)		ifTrue: [ self defaultIncomingHost: aHostSpec].	(self isOutgoingTypeHost: aHostSpec)		ifTrue: [  self defaultOutgoingHost: aHostSpec].	(self detectMailHost: aHostSpec) == nil		ifTrue: [ self mailServers add: aHostSpec ]</body></methods><methods><class-id>Net.Settings class</class-id> <category>removing</category><body package="NetClientBase" selector="removeDefaultIdentity">removeDefaultIdentity	self registry removeKey: #defaultIdentity ifAbsent: [ nil ].	self changed: #removedDefaultIdentity.</body><body package="NetClientBase" selector="removeDefaultIncomingHost">removeDefaultIncomingHost	self registry removeKey: #defaultIncomingServer ifAbsent: [ nil ].	self changed: #removedDefaultIncomingServer.</body><body package="NetClientBase" selector="removeDefaultOutgoingHost">removeDefaultOutgoingHost	self registry removeKey: #defaultOutgoingServer ifAbsent: [ nil ].	self changed: #removedDefaultOutgoingServer.</body><body package="NetClientBase" selector="removeIdentity:">removeIdentity: aNetUser	| user |	(user := self  detectIdentity: aNetUser) notNil		ifTrue: [ self identities remove: user].	self mailServers 		do: [ :ea | (user := ea netUser) notNil					ifTrue: [ user fullName = aNetUser fullName ifTrue: [ea netUser: nil ]]].	self httpProxyHost notNil		ifTrue: 			[(user := self httpProxyHost netUser) notNil				ifTrue: [ user fullName = aNetUser fullName ifTrue: [ self httpProxyHost netUser: nil ]]].	self httpUser notNil		ifTrue: [ self httpUser fullName = aNetUser fullName ifTrue: [ self httpUser: nil ]].	self changed: #removedIdentity with: aNetUser.</body><body package="NetClientBase" selector="removeMailHost:">removeMailHost: aHostSpec	| host |	(host := self  detectMailHost: aHostSpec) notNil		ifTrue: 			[ self mailServers remove: host.			self changed: #removedMailServer with: aHostSpec.			( self isDefaultIncomingHost: aHostSpec)				ifTrue: [ self removeDefaultIncomingHost].			( self isDefaultOutgoingHost: aHostSpec)				ifTrue: [ self removeDefaultOutgoingHost]]</body><body package="NetClientBase" selector="resetIdentities">resetIdentities	self removeDefaultIdentity.	^self registry at: #identities put: OrderedCollection new</body><body package="NetClientBase" selector="resetServers">resetServers	self removeDefaultIncomingHost.	self removeDefaultOutgoingHost.	^self registry at: #mailServers  put: OrderedCollection new</body></methods><methods><class-id>Net.Settings class</class-id> <category>detecting</category><body package="NetClientBase" selector="detectIdentity:">detectIdentity: aNetUser	^self identities detect: [ :each | each fullName = aNetUser fullName] ifNone: [ nil ]</body><body package="NetClientBase" selector="detectIdentityByName:">detectIdentityByName: aName	^self identities detect: [ :each | each fullName = aName] ifNone: [ nil ]</body><body package="NetClientBase" selector="detectMailClientFor:">detectMailClientFor: aHostSpec	aHostSpec type isNil ifTrue: [^nil].	^self supportedMailClients 			detect: [ :ea | ea serverType asSymbol = aHostSpec type asSymbol ] ifNone: [nil].</body><body package="NetClientBase" selector="detectMailHost:">detectMailHost: aHostSpec	^self mailServers detect: [ :each | each name = aHostSpec name] ifNone: [ nil ]</body><body package="NetClientBase" selector="detectMailHostByName:">detectMailHostByName: aString	^self mailServers detect: [ :each | each name = aString ] ifNone: [ nil ]</body></methods><methods><class-id>Net.Settings class</class-id> <category>class initialization</category><body package="NetClientBase" selector="initialize">initialize	"Settings initialize"	self initializeRegistry.</body><body package="NetClientBase" selector="initializeRegistry">initializeRegistry	Registry isNil ifTrue: [ self resetRegistry ].</body><body package="NetClientBase" selector="resetRegistry">resetRegistry	" self resetRegistry "		Registry := Dictionary new.</body></methods><methods><class-id>Net.Settings class</class-id> <category>adding</category><body package="NetClientBase" selector="addIdentity:">addIdentity: aNetUser	| user |	aNetUser isNil ifTrue: [^nil].	(user := self  detectIdentity: aNetUser) notNil		ifTrue: 			[ user updateBy: aNetUser.			self changed: #updatedIdentity with: aNetUser]		ifFalse: 			[ self identities add: aNetUser.			self changed: #addedIdentity with: aNetUser]</body><body package="NetClientBase" selector="updateMailHost:">updateMailHost: aHostSpec	| host |	(host := self  detectMailHost: aHostSpec) notNil		ifTrue: 			[ host updateBy: aHostSpec.			self changed: #updatedMailHost with: host]		ifFalse: 			[ self mailServers add: aHostSpec.			self changed: #addedMailHost with: aHostSpec]</body></methods><methods><class-id>Net.Settings class</class-id> <category>mail server types</category><body package="NetClientBase" selector="serverTypeDescriptionFor:">serverTypeDescriptionFor: aHostSpec	| cl  |	cl := self supportedMailClients 			detect: [ :ea | ea serverType asSymbol = aHostSpec type asSymbol ] ifNone: [nil].	^cl notNil		ifTrue: [ cl description ]		ifFalse: [String new].</body><body package="NetClientBase" selector="supportedMailClients">supportedMailClients" mail server type and server description"	| col |	col := OrderedCollection new.	NetClient mailRegistry values do:			[ :ea | col add: ((LiteralBindingReference pathString: 'Net.',ea ) value)].	^col</body></methods><methods><class-id>Net.Settings class</class-id> <category>testing</category><body package="NetClientBase" selector="hasIdentityReference:">hasIdentityReference: aNetUser	| usr |	self mailServers 		detect: [ :ea | (usr := ea netUser) notNil					ifTrue: [ (usr fullName = aNetUser fullName) ifTrue: [ ^true]].				false] 		ifNone: [nil].	self httpProxyHost notNil		ifTrue: 			[(usr := self httpProxyHost netUser) notNil				ifTrue: [ (usr fullName = aNetUser fullName) ifTrue: [^true]]].	(usr := self httpUser) notNil		ifTrue: [ (usr fullName = aNetUser fullName) ifTrue: [^true]].	^false</body><body package="NetClientBase" selector="isDefaultIdentity:">isDefaultIdentity: aNetUser	| usr |	^(usr := self registry at: #defaultIdentity ifAbsent: [ nil ]) notNil		ifTrue: [ usr fullName = aNetUser fullName]		ifFalse: [ false ]</body><body package="NetClientBase" selector="isDefaultIncomingHost:">isDefaultIncomingHost: aHostSpec	| srv |	^(srv := self registry at: #defaultIncomingServer ifAbsent: [ nil ]) notNil		ifTrue: [ srv name = aHostSpec name]		ifFalse: [ false ]</body><body package="NetClientBase" selector="isDefaultMailHost:">isDefaultMailHost: aHostSpec	| srv |	(self isMailHost: aHostSpec) ifFalse: [^false].	srv := (( self isIncomingTypeHost: aHostSpec) 				ifTrue: [ self registry at: #defaultIncomingServer ifAbsent: [ nil ]]				ifFalse: [self registry at: #defaultOutgoingServer ifAbsent: [ nil ]]).	^srv notNil		ifTrue: [ srv name = aHostSpec name]		ifFalse: [ true ]</body><body package="NetClientBase" selector="isDefaultOutgoingHost:">isDefaultOutgoingHost: aHostSpec	| srv |	^(srv := self registry at: #defaultOutgoingServer ifAbsent: [ nil ]) notNil		ifTrue: [ srv name = aHostSpec name]		ifFalse: [ false ]</body><body package="NetClientBase" selector="isIncomingTypeHost:">isIncomingTypeHost: aHostSpec	| cl  |	^(cl := self detectMailClientFor: aHostSpec) notNil		ifTrue: [ cl isIncomingMailClient ]		ifFalse: [false]</body><body package="NetClientBase" selector="isMailHost:">isMailHost: aHostSpec	^(self detectMailClientFor: aHostSpec) notNil</body><body package="NetClientBase" selector="isOutgoingTypeHost:">isOutgoingTypeHost: aHostSpec	| cl  |	^(cl := self detectMailClientFor: aHostSpec) notNil		ifTrue: [ cl isOutgoingMailClient ]		ifFalse: [false]</body></methods><methods><class-id>Net.Settings class</class-id> <category>obsolete</category><body package="NetClientBase" selector="createObjectFrom:">createObjectFrom: aDict	| cls  value |	cls := (aDict at:  'class')  asQualifiedReference 		ifDefinedDo: [:class | class ]		elseDo: [ ^self error: ((#ThereIsNoClass1s &lt;&lt; #net &gt;&gt; 'There is no class: &lt;1s&gt;')			expandMacrosWith: (aDict at: (#class &lt;&lt; #net &gt;&gt; 'class')))].	value := aDict at: 'class_value' ifAbsent: [ nil].	value notNil		ifTrue: [ ^cls readFrom: value readStream].	aDict removeKey: 'class'. 	^cls new 		specFrom: aDict;		yourself</body><body package="NetClientBase" selector="getPatternFor:">getPatternFor: key	('identities' match: key)		ifTrue: [ ^[ :k :v |  (Registry at: k) add: (NetUser new specFrom: v)]].	(#('defaultIdentity' 'httpUser')		detect: [ :ea | ea match: key ] ifNone: [nil]) notNil			ifTrue: 				[ ^[ :k :v | Registry at: k put: (NetUser new specFrom: v)]].	('mailServers'  match: key)			ifTrue: [ ^[ :k :v | (Registry at: k) add: (HostSpec new specFrom: v)]].	(#('defaultIncomingServer' 'defaultOutgoingServer' 'httpProxyHost') 		detect: [ :ea | ea match: key ] ifNone: [nil]) notNil			ifTrue: [ ^[ :k :v |  Registry at: k put: (HostSpec new specFrom: v)]].	^[ :k :dict  | Registry at: k put: (Compiler evaluate: (dict at: 'value')) ]</body><body package="NetClientBase" selector="readFrom:">readFrom: aStream	| scanner key list |	list := OrderedCollection new: 10.	scanner :=  INIScanner on: aStream.	[ scanner atEnd ] 		whileFalse: [			(key := scanner nextSectionHeader) notNil 				ifTrue: [list add:  (key-&gt; scanner scanSectionBody)]].	self resetRegistry.	list do: [ :section |			key := section key.			(key detect: [ :c | c = $_ ] ifNone: [ nil]) notNil				ifTrue: 					[ key := (key copyUpTo: $_) asSymbol.					Registry at: key asSymbol ifAbsent: [ Registry at: key  put: List new]].			(self getPatternFor: key) value: key asSymbol value: section value].</body><body package="NetClientBase" selector="specString:">specString: anObject	| stream value |	stream := (String new: 128) writeStream.	anObject class instVarNames isEmpty		ifTrue: [ stream nextPutAll:  'value  = ', anObject printString; cr]		ifFalse: 			[ anObject class instVarNames					do: [ :ins | 						(value := anObject instVarAt: ( anObject class instVarIndexFor: ins)) notNil 							ifTrue: 								[stream nextPutAll:  ins, ' = ', value printString; cr]]].	^stream contents.</body><body package="NetClientBase" selector="storeOn:">storeOn: aStream	| list order  |	list := OrderedCollection new: 10.	order := #last.	self registry keysAndValuesDo: 		[ :key :value | 			order := (key = #identities 				ifTrue: [ #first]				ifFalse: [ #last]).			(value isKindOf: List)				ifTrue: 					[ value do: [ :ea | 							order = #first								ifTrue: [ 	list addFirst: ((key,'_', ea name) -&gt; ea)]								ifFalse: [ list addLast: ((key,'_', ea name) -&gt; ea)]]]				ifFalse: [ list add: (key asString -&gt;value)]].	list do: [ :item |			aStream cr.			aStream nextPutAll: '[', item key, ']'; cr; cr.			aStream nextPutAll: (self specString: item value) ].	^aStream contents</body></methods><methods><class-id>Net.Settings class</class-id> <category>private</category><body package="NetClientBase" selector="collection:asXmlNode:">collection: aCollection asXmlNode: aString	| node |	node := self nodeForClass: 'OrderedCollection' tag: aString.	aCollection do: [ :each | node addNode: (each asXmlNode: 'item' ) ].	^node</body><body package="NetClientBase" selector="createNetRefFor:tag:">createNetRefFor: aNetClient tag: aString	| node attr |	node := self nodeForClass: 'Net.NetRef' tag: aString.	attr := node attributes.	attr 	add: ( XML.Attribute name: 'fullName' value: aNetClient fullName ).	^node</body><body package="NetClientBase" selector="createNetRefServerFor:tag:">createNetRefServerFor: aHostSpec tag: aString	| node attr |	node := self nodeForClass: 'Net.NetRef' tag: aString.	attr := node attributes.	attr 	add: ( XML.Attribute name: 'name' value: aHostSpec name ).	^node</body><body package="NetClientBase" selector="createPasswordNode:tag:">createPasswordNode: passString tag: aString	| pass node attr cipher bf output stream |	cipher := Security.Blowfish key: self passwordKey.	bf := Security.BlockPadding on: cipher.	pass := bf encrypt: 				(ByteArray 					fromString: passString 					encoding: self passwordEncodingForPersistence).	node := self nodeForClass: 'Net.NetRef' tag: aString.	attr := node attributes.	output := (ByteArray new: 64) writeStream.	stream := EncodedStream on: output encodedBy: Base64StreamEncoder asEncoder.	stream nextPutAll: (pass asStringEncoding: #'iso-8859-1').	stream close.	attr 	add: ( XML.Attribute name: 'password' value: stream encodedContents asString  ).	^node</body><body package="NetClientBase" selector="dictionary:asXmlNode:">dictionary: aDict asXmlNode: aString	| node entry |	node := self nodeForClass: 'Dictionary' tag: aString.	aDict 		keysAndValuesDo: 			[ :key :value | 			entry := XML.Element tag: 'entry'.			node addNode: entry.			entry addNode: ( key asXmlNode: 'key' ).			entry addNode: ( value asXmlNode: 'value' ) ].		^node</body><body package="NetClientBase" selector="netObject:asXmlNode:">netObject: aClass asXmlNode: aString 	| value root node |	aString = #defaultIdentity		ifTrue: [  ^self createNetRefFor: aClass  tag: aString ].	(aString = #defaultIncomingServer or: [ aString = #defaultOutgoingServer ])		ifTrue: [  ^self createNetRefServerFor: aClass  tag: aString ].	root := self nodeForClass: aClass class fullName tag: aString.	aClass class instVarNames do: 			[:ins | 			(value := aClass instVarAt: (aClass class instVarIndexFor: ins)) notNil 				ifTrue: 					[ node := value class name = #NetUser 						ifTrue: [ self createNetRefFor: value tag: ins ]						ifFalse: 							[ ins = 'password'								ifTrue: [ self createPasswordNode: value tag: ins ]								ifFalse: [ value asXmlNode: ins]].					root addNode: node]].	^root</body><body package="NetClientBase" selector="nodeForClass:tag:">nodeForClass: aClassName tag: aString	| node |	node := XML.Element tag: aString.	node attributes: (OrderedCollection with: ( XML.Attribute name: 'smalltalkClass' value: aClassName )).	^node</body><body package="NetClientBase" selector="object:asXmlNode:">object: anObject asXmlNode: aString	| node |	node := self nodeForClass: anObject class fullName tag: aString.	node addNode: (XML.Text text: anObject printString ).	^node</body><body package="NetClientBase" selector="restoreClassFrom:">restoreClassFrom: anXMLElement	^(anXMLElement valueOfAttribute: 'smalltalkClass' ifAbsent: [^nil])		asSymbol asQualifiedReference value.</body><body package="NetClientBase" selector="restoreNetObject:from:">restoreNetObject: anObject from:  anXMLElement	| val xmlColl |	xmlColl := anXMLElement realElements.	xmlColl do: 			[ :el |  			val := el restoreValue.			anObject perform: (el tag type, ':') asSymbol  with: val].	^anObject</body><body package="NetClientBase" selector="restorePassword:">restorePassword: decString 	| cipher bf stream output char input bArr |	input := decString asByteArray readStream.	stream := EncodedStream on: input encodedBy: Base64StreamEncoder asEncoder.	output := (ByteArray new: 64) writeStream.	[ (char := stream next) notNil ] whileTrue: [ output nextPut: char ].	bArr := ByteArray fromString: output contents asString encoding: #'iso-8859-1'.	cipher := Security.Blowfish key: self passwordKey.	bf := Security.BlockPadding on: cipher.	^( bf decrypt: bArr) asStringEncoding: self passwordEncodingForPersistence.</body><body package="NetClientBase" selector="restoreRefFrom:">restoreRefFrom:  anXMLElement	| tag val |	tag := anXMLElement tag type asSymbol.	tag = #password		ifTrue: 			[val := anXMLElement valueOfAttribute: 'password' ifAbsent: [ nil].			 ^(self restorePassword: val) asString ].	(tag = #defaultIdentity or: [ tag = #netUser ])		ifTrue: 			[  val := anXMLElement valueOfAttribute: 'fullName' ifAbsent: [ nil].			^self detectIdentityByName: val ].	(tag = #defaultIncomingServer or: [ tag = #defaultOutgoingServer ])		ifTrue: 			[ val := anXMLElement valueOfAttribute: 'name' ifAbsent: [ nil].			^self detectMailHostByName: val ].</body><body package="NetClientBase" selector="string:asXmlNode:">string: valString asXmlNode: aString	| node |	node := self nodeForClass: 'String' tag: aString.	node addNode: (XML.Text text: valString ).	^node</body></methods><methods><class-id>Net.Settings class</class-id> <category>persistence</category><body package="NetClientBase" selector="addStateXmlElementsTo:">addStateXmlElementsTo: rootElement	| coll  | 	(coll := self registry at: #identities ifAbsent: [ nil]) notNil		ifTrue:  [ rootElement addNode: ( coll asXmlNode: #identities)].	(coll := self registry at: #mailServers ifAbsent: [ nil]) notNil		ifTrue:  [ rootElement addNode: ( coll asXmlNode: #mailServers)].	self registry keysAndValuesDo:		[ :key :value | 		(key ~= #identities and: [ key ~= #mailServers])			ifTrue: [	rootElement addNode: ( value asXmlNode: key) ]].</body><body package="NetClientBase" selector="importSnapshots:">importSnapshots: aCollectionElements	aCollectionElements do:		[ :el | self restoreSettingFrom: el ]</body><body package="NetClientBase" selector="restoreSettingFrom:">restoreSettingFrom: anXMLElement	| key coll |	key := anXMLElement tag type  asSymbol.	key = #identities		ifTrue: 			[coll := self restoreValueFrom: anXMLElement. 			^coll do: [ :each | self addIdentity:  each] ].	key = #mailServers		ifTrue: 			[coll := self restoreValueFrom: anXMLElement.			 ^coll do: [ :each | self updateMailHost:  each] ].	self registry 		at: key		put: (self restoreValueFrom: anXMLElement)</body><body package="NetClientBase" selector="restoreValueFrom:">restoreValueFrom: anXMLElement	^(self restoreClassFrom:  anXMLElement ) 			restoreValueFrom: anXMLElement</body></methods><methods><class-id>Net.Settings class</class-id> <category>password key</category><body package="NetClientBase" selector="defaultKey">defaultKey	^#[16r2b 16r7e 16r15 16r16 16r28 16rae 16rd2 16ra6 16rab 16rf7 16r15 16r88 16r09 16rcf 16r4f 16r3c].</body><body package="NetClientBase" selector="passwordKey">passwordKey	^passwordKey isNil		ifTrue: [ self defaultKey ]		ifFalse: [ passwordKey ]</body><body package="NetClientBase" selector="passwordKey:">passwordKey: aByteArray	passwordKey := aByteArray</body></methods><methods><class-id>Net.TimedPromise</class-id> <category>accessing</category><body package="NetClientBase" selector="ms:">ms: msec	ms := msec</body></methods><methods><class-id>Net.TimedPromise</class-id> <category>private</category><body package="NetClientBase" selector="startup">startup	ms notNil		ifTrue: 			[delay := Delay forMilliseconds: ms.			sync := delay delaySemaphore.			delay startup.	"Wait for data arrival or alarm expiry."]</body></methods><methods><class-id>Net.TimedPromise</class-id> <category>accessing-parent</category><body package="NetClientBase" selector="value">value	| result |	" Note -- only good for one waiter "	self startup.	delay isNil ifTrue: [ ^super value ].	sync wait.	result := delay inProgress not.	delay disable.	exception == nil		ifTrue: [			result				ifTrue: [OSErrorHolder needRetrySignal raise]				ifFalse: [^value]]		ifFalse: [(exception copyForReraise) searchFrom: thisContext; raise]</body></methods><methods><class-id>Net.TimedPromise class</class-id> <category>instance creation</category><body package="NetClientBase" selector="forMilliseconds:">forMilliseconds: ms	^super new			ms: ms; yourself</body></methods><methods><class-id>Net.StreamSegment</class-id> <category>initialization</category><body package="NetClientBase" selector="initialize">initialize	position := size := 0</body><body package="NetClientBase" selector="offset:size:">offset: integerPos size: integerSize	offset := integerPos.	size := integerSize.</body><body package="NetClientBase" selector="stream:">stream: aStream	source := aStream.	size = 0		ifTrue: [ size := aStream size ].	offset isNil		ifTrue: [ offset := aStream position ]		ifFalse: [ aStream position: offset ]</body></methods><methods><class-id>Net.StreamSegment</class-id> <category>positioning</category><body package="NetClientBase" selector="atEnd">atEnd	^self evaluateWithProperPositioning: [self privateAtEnd]</body><body package="NetClientBase" selector="close">close	source close</body><body package="NetClientBase" selector="position">position	^position</body><body package="NetClientBase" selector="position:">position: aNumber	position := aNumber</body><body package="NetClientBase" selector="reset">reset	"Set the receiver's position to start position."	position := 0.</body></methods><methods><class-id>Net.StreamSegment</class-id> <category>private</category><body package="NetClientBase" selector="contentsSpecies">contentsSpecies	^((source respondsTo: #binary) and:[source isBinary])		ifTrue: [ByteArray]		ifFalse: [String]</body><body package="NetClientBase" selector="doesNotUnderstand:">doesNotUnderstand: aMessage 	^source isNil		ifTrue: [super doesNotUnderstand: aMessage]		ifFalse: 			[self evaluateWithProperPositioning: 				[source 					perform: aMessage selector 					withArguments: aMessage arguments]]</body><body package="NetClientBase" selector="evaluateWithProperPositioning:">evaluateWithProperPositioning: aBlock	^[source position: position + offset.	aBlock value]		ensure: 			[ position := source position - offset ]</body><body package="NetClientBase" selector="pastEnd">pastEnd	"The receiver has attempted to read past the end, answer nil."	^Stream endOfStreamSignal raiseRequestFrom: self</body><body package="NetClientBase" selector="privateAtEnd">privateAtEnd	^source position - offset &gt;= size or: [source atEnd]</body><body package="NetClientBase" selector="privateContents">privateContents"We need this method because #next: for CRLF line end convention returns more than we need"	| collection |	^self 		evaluateWithProperPositioning: 			[collection := (source contentsSpecies new: self size) writeStream.			[self privateAtEnd ]				whileFalse: 					[ collection nextPut: source next].					collection contents]</body></methods><methods><class-id>Net.StreamSegment</class-id> <category>instance creation</category><body package="NetClientBase" selector="asStream">asStream	^self</body><body package="NetClientBase" selector="from:to:">from: start to: end	^source from: start + offset to: end + offset</body><body package="NetClientBase" selector="newSize:">newSize: anInteger 	^self newSize: anInteger startingAt: self position</body><body package="NetClientBase" selector="newSize:startingAt:">newSize: anInteger startingAt: localOffset 	^source newSize: anInteger startingAt: localOffset + offset</body></methods><methods><class-id>Net.StreamSegment</class-id> <category>accessing</category><body package="NetClientBase" selector="binary">binary	source binary</body><body package="NetClientBase" selector="contents">contents	| savePos |	savePos := self position.	^[self reset; privateContents]		ensure: [self position: savePos]</body><body package="NetClientBase" selector="next">next	^self 		evaluateWithProperPositioning: 			[self privateAtEnd				ifTrue: [self pastEnd]				ifFalse: [source next]]</body><body package="NetClientBase" selector="next:">next: anInteger 	^self 		evaluateWithProperPositioning: 			[(source atEnd or: [position + anInteger &gt; self size])				ifTrue: [self pastEnd]				ifFalse: [source next: anInteger]]</body><body package="NetClientBase" selector="next:into:startingAt:">next: anInteger into: aSequenceableCollection startingAt: startIndex 	"Store the next anInteger elements of the receiver into aSequenceableCollection 	starting at startIndex in aSequenceableCollection. Answer aSequenceableCollection."	| index stopIndex |	^self evaluateWithProperPositioning: 		[		index := startIndex.		stopIndex := index + anInteger.		[[index &lt; stopIndex and: [self privateAtEnd not ]]					whileTrue: [aSequenceableCollection at: index put: source next.								index := index + 1]]			on: Stream endOfStreamSignal			do: 				[:ex | ex retryUsing:						[(Stream incompleteNextCountSignal newExceptionFrom: self)							parameter: index - startIndex;							raiseRequest]].		aSequenceableCollection]</body><body package="NetClientBase" selector="nextAvailable:">nextAvailable: anInteger 	"Answer the next anInteger elements of the receiver.  If there are not	enough elements available, answer a collection of as many as are available."	| newStream end |	end := source position + anInteger.	^self evaluateWithProperPositioning:		[newStream := (source contentsSpecies new: 64) writeStream.		[self privateAtEnd or: [source position &gt; end ]]			whileFalse: [newStream nextPut: source next].		newStream contents]</body><body package="NetClientBase" selector="nextPut:">nextPut: aByte	^self 		evaluateWithProperPositioning: 			[source atEnd 				ifTrue: [self pastEnd]				ifFalse: [source nextPut: aByte]]</body><body package="NetClientBase" selector="peek">peek	"Answer what would be returned with a self next, without	changing position.  If the receiver is at the end, answer nil."	| nextObject |	^self evaluateWithProperPositioning: 		[self privateAtEnd ifTrue: [^nil].		nextObject := source next.		source skip: -1.		nextObject]</body><body package="NetClientBase" selector="peekFor:">peekFor: anObject 	"Answer false and do not move the position if self next ~= anObject or if the	receiver is at the end. Answer true and increment position if self next = anObject."	| nextObject |	self evaluateWithProperPositioning:		[self privateAtEnd ifTrue: [^false].		nextObject := source next.		"peek for matching element"		anObject = nextObject ifTrue: [^true].		"gobble it if found"		source skip: -1].	^false</body><body package="NetClientBase" selector="size">size	^size</body><body package="NetClientBase" selector="skip:">skip: integer	self evaluateWithProperPositioning: [source skip: integer]</body><body package="NetClientBase" selector="throughAll:">throughAll: aCollection	" Answer a subcollection from the current position	through the occurrence (if any, inclusive) of aCollection,	and leave the stream positioned after the occurrence.	If no occurrence is found, answer the entire remaining	stream contents, and leave the stream positioned at the end. "	| first length newStream |	self evaluateWithProperPositioning: [	newStream := (self contentsSpecies new: 64) writeStream.	(length := aCollection size) = 0 ifTrue: [^newStream contents].	first := aCollection at: 1.	[self privateAtEnd] whileFalse:		[| element |		element := source next.		newStream nextPut: element.		element = first ifTrue:			[| nonMatch nextPos |			nonMatch := 2.			nextPos := source position.			[nonMatch &gt; length ifTrue:				[" Success. "				newStream skip: -1. "Since the first element has been put in"				newStream nextPutAll: aCollection.				^newStream contents].			self privateAtEnd ifTrue:  " Not found. "				[" Copy the partial match. "				source position: nextPos.				[self privateAtEnd] whileFalse: [newStream nextPut: source next].				^newStream contents].			source next = (aCollection at: nonMatch)]				whileTrue: [nonMatch := nonMatch + 1].			" Didn't match, back up. "			source position: nextPos]]].	" Not found. "	^newStream contents</body><body package="NetClientBase" selector="upTo:">upTo: anObject	"Answer a subcollection from position to the occurrence (if any, exclusive) of anObject.	 The stream is left positioned after anObject.	If anObject is not found answer everything."	| newStream element |	^self evaluateWithProperPositioning:		[newStream := (source contentsSpecies new: 64) writeStream.		[self privateAtEnd]			whileFalse:				[element := source next.				element = anObject					ifTrue: [^newStream contents].				newStream nextPut: element.].		newStream contents]</body><body package="NetClientBase" selector="upToAll:">upToAll: aCollection	" Answer a subcollection from the current position	up to the occurrence (if any, not inclusive) of aCollection,	and leave the stream positioned before the occurrence.	If no occurrence is found, answer the entire remaining	stream contents, and leave the stream positioned at the end. "	| first length newStream|	self evaluateWithProperPositioning: [	(length := aCollection size) = 0 ifTrue: [^self].	first := aCollection at: 1.	newStream := (source contentsSpecies new: 64) writeStream.	[self privateAtEnd] whileFalse:		[| element |		element := source next.		newStream nextPut: element.		element = first ifTrue:			[| nonMatch |			nonMatch := 2.			[nonMatch &gt; length ifTrue:				[" Success.  Back up over the occurrence. "				source skip: length negated.				newStream skip: -1. "Since the first element has been put in"				^newStream contents].			self privateAtEnd ifTrue:  " Not found. "				[source skip: 2 - nonMatch.				" Copy the partial match. "				[self privateAtEnd] whileFalse: [newStream nextPut: source next].				^newStream contents].			source next = (aCollection at: nonMatch)]				whileTrue: [nonMatch := nonMatch + 1].			" Didn't match, back up. "			source skip: 1 - nonMatch]]].	" Not found. "	^newStream contents</body><body package="NetClientBase" selector="upToEnd">upToEnd	"Answer a collection consisting of all the elements from the current position	to the end of stream."	| newStream |	^self evaluateWithProperPositioning:		[newStream := (source contentsSpecies new: 64) writeStream.		[self privateAtEnd] whileFalse: [newStream nextPut: source next].		newStream contents]</body></methods><methods><class-id>Net.StreamSegment class</class-id> <category>instance creation</category><body package="NetClientBase" selector="new">new	^super new initialize</body><body package="NetClientBase" selector="on:">on: aStream 	^(self new) 		stream: aStream; 		yourself</body><body package="NetClientBase" selector="on:offset:size:">on: aStream offset: offsetNumber size: sizeNumber 	^(self new) 		stream: aStream; 		offset: offsetNumber size: sizeNumber; 		yourself</body></methods><methods><class-id>Net.HostSpec</class-id> <category>accessing</category><body package="NetClientBase" selector="name">name	^name</body><body package="NetClientBase" selector="name:">name: aString	name := aString</body><body package="NetClientBase" selector="netUser">netUser	^netUser</body><body package="NetClientBase" selector="netUser:">netUser: aNetUser	netUser := aNetUser</body><body package="NetClientBase" selector="port">port	^port</body><body package="NetClientBase" selector="port:">port: aNumber	port := aNumber</body><body package="NetClientBase" selector="registry">registry	^Settings</body><body package="NetClientBase" selector="type">type	^type</body><body package="NetClientBase" selector="type:">type: aString	type := aString</body></methods><methods><class-id>Net.HostSpec</class-id> <category>testing</category><body package="NetClientBase" selector="isDefaultMailHost">isDefaultMailHost	^self registry isDefaultMailHost: self</body><body package="NetClientBase" selector="isIncomingTypeMail">isIncomingTypeMail	^self registry isIncomingTypeHost: self</body><body package="NetClientBase" selector="isMailHost">isMailHost	^self registry isMailHost: self</body><body package="NetClientBase" selector="isOutgoingTypeMail">isOutgoingTypeMail	^self registry isOutgoingTypeHost: self</body></methods><methods><class-id>Net.HostSpec</class-id> <category>update</category><body package="NetClientBase" selector="updateBy:">updateBy: aHostSpec	self 		name: aHostSpec name;		type: aHostSpec type;		netUser: aHostSpec netUser;		port: aHostSpec port.</body></methods><methods><class-id>Net.HostSpec</class-id> <category>printing</category><body package="NetClientBase" selector="printDefaultDescriptionOn:">printDefaultDescriptionOn: aStream 	aStream nextPutAll: ' ( Default ', (self registry serverTypeDescriptionFor: self) asString, ')'</body><body package="NetClientBase" selector="printDescriptionOn:">printDescriptionOn: aStream 	aStream nextPutAll: ' (', (self registry serverTypeDescriptionFor: self) asString, ')'</body><body package="NetClientBase" selector="printOn:">printOn: aStream 	aStream nextPutAll: self name.	self isMailHost		ifTrue:			[self isDefaultMailHost				ifTrue: [ self printDefaultDescriptionOn: aStream]				ifFalse: [ self printDescriptionOn: aStream]]</body><body package="NetClientBase" selector="specFrom:">specFrom: aDict	| val tok |	aDict keysAndValuesDo:		[ :key :value |			key = 'netUser'				ifTrue: 					[tok := (INIScanner on: value readStream) nextToken.						val := Settings identities 							detect: [ :id | id fullName = tok] 							ifNone: [ ^self error: ((#NoUser1s &lt;&lt; #net &gt;&gt; 'No user: &lt;1s&gt;')			expandMacrosWith: value)].					self instVarAt: ( self class instVarIndexFor: key) put: val]				ifFalse:  					[self instVarAt: ( self class instVarIndexFor: key) put: (Compiler evaluate: value readStream) ]]</body><body package="NetClientBase" selector="specString">specString	| stream value |	stream := (String new: 32) writeStream.	self class instVarNames 		do: [ :ins | 			value := self instVarAt: ( self class instVarIndexFor: ins).			ins = 'netUser'				ifTrue: [ stream nextPutAll:  ins, ' = ', value name; cr]				ifFalse: 						[value notNil 						ifTrue: 							[stream nextPutAll:  ins, ' = ', value printString; cr]]].	^stream contents.</body></methods><methods><class-id>Net.HostSpec</class-id> <category>persistence</category><body package="NetClientBase" selector="asXmlNode:">asXmlNode: aString 	^Settings netObject: self asXmlNode: aString</body></methods><methods><class-id>Net.HostSpec class</class-id> <category>persistance</category><body package="NetClientBase" selector="restoreValueFrom:">restoreValueFrom: xmlColl	^Settings restoreNetObject: self new from:  xmlColl</body></methods><methods><class-id>Net.NetRef class</class-id> <category>persistence</category><body package="NetClientBase" selector="restoreValueFrom:">restoreValueFrom: anXMLElement	^Settings restoreRefFrom: anXMLElement</body></methods><methods><class-id>XML.Text</class-id> <category>net clients</category><body package="NetClientBase" selector="restoreValue">restoreValue</body><body package="NetClientBase" selector="restoreValueFor:">restoreValueFor: aClass	^aClass readFrom: self text</body></methods><methods><class-id>Core.String class</class-id> <category>net clients</category><body package="NetClientBase" selector="restoreValueFrom:">restoreValueFrom: anXMLElement	| els |	^(els := anXMLElement elements) isEmpty		ifTrue: [self new]		ifFalse: [ els first text ]</body></methods><methods><class-id>Core.String</class-id> <category>net clients</category><body package="NetClientBase" selector="asXmlNode:">asXmlNode: aString	| node |	node := XML.Element tag: aString.	node attributes: (OrderedCollection with: ( XML.Attribute name: 'smalltalkClass' value: 'String' )).	node addNode: (XML.Text text: self ).	^node</body></methods><methods><class-id>Core.Dictionary class</class-id> <category>net clients</category><body package="NetClientBase" selector="restoreValueFrom:">restoreValueFrom: anXMLElement	| xmlColl dict key value |	xmlColl := anXMLElement realElements.	dict := self new: xmlColl size.	xmlColl do: 			[ :el |			key := el realElements first restoreValue.			value := el realElements last restoreValue.			dict at:  key put: value ].	^dict</body></methods><methods><class-id>Core.Dictionary</class-id> <category>net clients</category><body package="NetClientBase" selector="asXmlNode:">asXmlNode: aString	^Net.Settings dictionary: self  asXmlNode: aString</body></methods><methods><class-id>Core.Collection class</class-id> <category>net clients</category><body package="NetClientBase" selector="restoreValueFrom:">restoreValueFrom: anXMLElement	| coll xmlColl |	xmlColl := anXMLElement realElements.	coll := self new: xmlColl size.	xmlColl do: 			[ :el |			coll add: el restoreValue ].	^coll</body></methods><methods><class-id>Core.Collection</class-id> <category>net clients</category><body package="NetClientBase" selector="asXmlNode:">asXmlNode: aString	^Net.Settings collection: self  asXmlNode: aString</body></methods><methods><class-id>XML.Element</class-id> <category>net clients</category><body package="NetClientBase" selector="restoreValue">restoreValue	^Net.Settings restoreValueFrom: self</body></methods><methods><class-id>Core.InternalStream</class-id> <category>Mime -- testing</category><body package="NetClientBase" selector="isInternal">isInternal	^true</body></methods><methods><class-id>Core.PositionableStream</class-id> <category>Mime -- stream segments</category><body package="NetClientBase" selector="from:to:">from: start to: end	^self newSize: end - start startingAt: start</body><body package="NetClientBase" selector="newSize:">newSize: anInteger 	^self newSize: anInteger startingAt: self position</body><body package="NetClientBase" selector="newSize:startingAt:">newSize: anInteger startingAt: offset	^Net.StreamSegment on: self offset: offset size: anInteger</body></methods><methods><class-id>Core.Stream</class-id> <category>Mime -- stream segments</category><body package="NetClientBase" selector="asStream">asStream	^self</body></methods><methods><class-id>Core.Stream</class-id> <category>Mime -- testing</category><body package="NetClientBase" selector="isInternal">isInternal	^false</body></methods><methods><class-id>Core.Stream</class-id> <category>Mime -- enumerating lines</category><body package="NetClientBase" selector="linesDo:">linesDo: aBlock" Enumerate stream line by line "	[self atEnd] 		whileFalse: [aBlock value: self nextLine]</body></methods><methods><class-id>Core.Stream</class-id> <category>accessing</category><body package="NetClientBase" selector="nextLine">nextLine	^self upTo: Character cr</body></methods><methods><class-id>Core.Object class</class-id> <category>net clients</category><body package="NetClientBase" selector="restoreValueFrom:">restoreValueFrom: anXMLElement	^self readFrom: anXMLElement elements first text readStream</body></methods><methods><class-id>Core.Object</class-id> <category>net clients</category><body package="NetClientBase" selector="asXmlNode:">asXmlNode: aString	^Net.Settings object: self asXmlNode: aString</body></methods><methods><class-id>Core.Text</class-id> <category>accessing</category><body package="NetClientBase" selector="concreteIndexFor:">concreteIndexFor: charIndex	^string concreteIndexFor: charIndex</body><body package="NetClientBase" selector="concreteString">concreteString	^string concreteString</body><body package="NetClientBase" selector="stringEncoding">stringEncoding	^string stringEncoding</body></methods><methods><class-id>Core.Symbol class</class-id> <category>net clients</category><body package="NetClientBase" selector="restoreValueFrom:">restoreValueFrom: anXMLElement	^self readFrom: anXMLElement elements first text readStream</body></methods><methods><class-id>Core.Symbol</class-id> <category>net clients</category><body package="NetClientBase" selector="asXmlNode:">asXmlNode: aString	| node |	node := XML.Element tag: aString.	node attributes: (OrderedCollection with: ( XML.Attribute name: 'smalltalkClass' value: 'Symbol' )).	node addNode: (XML.Text text: '#''', self, '''' ).	^node</body></methods><methods><class-id>Net.ErrorMessageBox class</class-id> <category>interface specs</category><body package="NetClientBase" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #Title 			#min: #(#{Core.Point} 384 166 ) 			#max: #(#{Core.Point} 384 166 ) 			#bounds: #(#{Graphics.Rectangle} 320 301 704 467 ) 			#flags: 4 ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.Rectangle} 4 1 280 154 ) 					#name: #errorMessage 					#model: #errorMessage 					#isReadOnly: true 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 284 4 375 25 ) 					#name: #ok 					#model: #ok 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #net) 					#isDefault: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 284 55 375 76 ) 					#name: #copyToClipboard 					#model: #copyToClipboard 					#label: #(#{Kernel.UserMessage} #key: #CopyMessage #defaultString: 'Copy Message' #catalogID: #net) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 284 29 375 50 ) 					#name: #openNotifier 					#model: #openNotifier 					#label: #(#{Kernel.UserMessage} #key: #Debug #defaultString: 'Debug' #catalogID: #net) ) ) ) )</body><body package="NetClientBase" selector="windowSpecOrig">windowSpecOrig	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #DatabaseErrorMessage #defaultString: 'Database Error Message' #catalogID: #net) 			#min: #(#{Core.Point} 397 188 ) 			#max: #(#{Core.Point} 397 188 ) 			#bounds: #(#{Graphics.Rectangle} 396 293 793 481 ) 			#flags: 4 			#menu: #windowMenu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0151134 0 0.0421687 0 0.987405 0 0.795181 ) 					#name: #errorMessage 					#model: #errorMessage 					#isReadOnly: true 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.753149 0 0.837349 0 0.987405 0 0.975904 ) 					#name: #ok 					#model: #ok 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #net) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Net.ErrorMessageBox class</class-id> <category>resources</category><body package="NetClientBase" selector="windowMenu">windowMenu	"MenuEditor new openOnClass: self andSelector: #windowMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_AdditionalInformation #defaultString: '&amp;Additional Information' #catalogID: #net) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_CopyToClipboard #defaultString: '&amp;Copy to Clipboard' #catalogID: #net) 							#value: #copyToClipboard ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_OpenNotifier #defaultString: '&amp;Open Notifier...' #catalogID: #net) 							#value: #openNotifier ) ) #(2 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-netClient</category><body package="NetClientBase" selector="netClient1DefaultTimeout">netClient1DefaultTimeout	&lt;setting: #(net netClient  defaultTimeout)&gt;	^(NumberSetting on: Net.NetClient aspect: #defaultTimeout)		label: #DefaultTimeout&lt;&lt; #net &gt;&gt; 'Default Timeout';		default: Net.NetClient defaultTimeoutValue;		helpText: #NetDefaultTimeoutHelpText &lt;&lt; #net &gt;&gt; 'The number of milliseconds to wait for the command completion'</body><body package="NetClientBase" selector="netClient2DefaultRetries">netClient2DefaultRetries	&lt;setting: #(net netClient  defaultRetries)&gt;	^(NumberSetting on: Net.NetClient aspect: #defaultRetries)		label: #DefaultRetries&lt;&lt; #net &gt;&gt; 'Default Retries';		default: Net.NetClient defaultRetriesValue;		helpText: #NetDefaultRetriesHelpText &lt;&lt; #net &gt;&gt; 'The number of attempts to connect to the host'</body><body package="NetClientBase" selector="netClient3DefaultDelaySeconds">netClient3DefaultDelaySeconds	&lt;setting: #(net netClient  defaultDelaySeconds)&gt;	^(NumberSetting on: Net.NetClient aspect: #defaultDelaySeconds)		label: #DefaultDelaySeconds&lt;&lt; #net &gt;&gt; 'Default Delay Seconds';		default:  Net.NetClient defaultDelaySecondsValue;		helpText: #NetDefaultDelaySecondsHelpText &lt;&lt; #net &gt;&gt; 'The number of seconds to wait between retries'</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="NetClientBase" selector="netClientPage">netClientPage	&lt;settingsPage: #(net netClient)&gt;	^ModularSettingsPage new		label: #NetClient &lt;&lt; #net &gt;&gt; 'Net Client';		icon: (ListIconLibrary visualFor: #net);		settings: (self settingsWithPrefix: #(net netClient ))</body></methods><initialize><class-id>Net.Base64StreamEncoder</class-id></initialize><initialize><class-id>Net.SimpleScanner</class-id></initialize><initialize><class-id>Net.INIScanner</class-id></initialize><initialize><class-id>Net.MimeTypeDescriptor</class-id></initialize><initialize><class-id>Net.UTF7StreamEncoder</class-id></initialize><initialize><class-id>Net.NetClient</class-id></initialize><initialize><class-id>Net.Settings</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Text</name><environment>XML</environment><super>XML.Node</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text stripped </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><class><name>Stream</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class><class><name>Promise</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sync value hasValue exception </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Processes</category><attributes><package>Kernel-Processes</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Element</name><environment>XML</environment><super>XML.Node</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tag attributes namespaces elements definition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Symbol</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>PositionableStream</name><environment>Core</environment><super>Core.PeekableStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collection position readLimit writeLimit policy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>ByteStreamEncoder</name><environment>Core</environment><super>Core.StreamEncoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Exception</name><environment>Core</environment><super>Core.GenericException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Notification</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Text</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string runs </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>InternalStream</name><environment>Core</environment><super>Core.PositionableStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>GenericSettingDescriptor</name><environment>Tools</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id position definingMethod </inst-vars><class-inst-vars></class-inst-vars><imports>			XML.Element			XML.Attribute			</imports><category>Tools-Settings</category><attributes><package>Tools-Settings</package></attributes></class></st-source>