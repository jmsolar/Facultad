<?xml version="1.0"?><st-source><!-- Name: MailNotice: Copyright © 1999, 2000, 2002, 2002, 2001 Cincom Systems, Inc.  All Rights Reserved.Comment: Mail parcel provides a high-level interface that makes it simple to retrieve, deliever and delete messages from mailboxes.DbIdentifier: bear73DbTrace: 53231DevelopmentPrerequisites: #(#(#any 'MIME' '') #(#any 'NetConfigTool' ''))PackageName: MailParcel: #('Mail')ParcelName: MailPrerequisiteParcels: #(#('MIME' '') #('NetConfigTool' ''))PrintStringCache: (7.4  0,tkogan)Version: 7.3.1Date: 6:45:06 pm April 10, 2005 --><time-stamp>From VisualWorks®, 7.3.1 of April 10, 2005 on April 10, 2005 at 6:45:06 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>LetterInTransit</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>letterText deliveryAction uid server serverType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Mail</category><attributes><package>Mail</package></attributes></class><comment><class-id>Net.LetterInTransit</class-id><body>LetterInTransit is used to hold row data received from a mail server in shared queue.Instance Variables:	letterText	&lt;String&gt;	mail message text	deliveryAction	&lt;Block&gt;	some action performed when a message has being processed	uid	&lt;String&gt;	message uid 	server	&lt;String&gt;	server name	serverType	&lt;String&gt;	IMAP/POP3</body></comment><class><name>Mailbox</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>user server lastMessage keepMail deleteMail deliveryQueue pollingProcess delaySemaphore sync settingsSync connection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Mail</category><attributes><package>Mail</package></attributes></class><comment><class-id>Net.Mailbox</class-id><body>The Mailbox class and its subclasses provide a high-level interface that makes it simple to check mailboxes. Instance Variables:	user	&lt;NetUser&gt;	the mailbox user	server	&lt;HostSpec&gt;	network server	lastMessage	&lt;Integer&gt;	last message number	keepMail	&lt;Boolean&gt;	keep mail indicatior	deleteMail	&lt;Boolean&gt;	delete mail indicator	deliveryQueue	&lt;SharedQueue&gt;  holds letter in transit	pollingProcess	&lt;Process&gt;	retrieve new messages from the mail server	delaySemaphore	&lt;Semaphore&gt;	provides synchronized communication between pollingProcess and main process	sync	&lt;RecursionLock&gt;	protects access to mailbox	settingsSync	&lt;RecursionLock&gt;	protects access to 'profile.smr' file (mailbox settings)	connection	&lt;NetClient&gt;	 specific net client, currently supported IMAP and POP3</body></comment><class><name>DeliveryMonitor</name><environment>Net</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>progress letter deliveryClient resultsQueue deliveryProcess </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Mail</category><attributes><package>Mail</package></attributes></class><comment><class-id>Net.DeliveryMonitor</class-id><body>DeliveryMonitor creates separate process for the mail delivery and while sending messages shows the progressInstance Variables:	progress	&lt;ValueHolder&gt;	number of messages to deliver	letter	&lt;Letter&gt;	letter for delivery	deliveryClient	&lt;NetClient&gt;	 SMTP client	resultsQueue	&lt;SharedQueue&gt;	 delivery queue	deliveryProcess	&lt;Process&gt;	delivery processShared Variables:	CollapseOnDelivery	&lt;Boolean&gt;	indicates if the window should be collapsed on delivery	DeliveryPriority	&lt;Number&gt;	priority</body></comment><shared-variable><name>DeliveryPriority</name><environment>Net.DeliveryMonitor</environment><private>false</private><constant>false</constant><category>constants</category><initializer>30</initializer><attributes><package>Mail</package></attributes></shared-variable><shared-variable><name>CollapseOnDelivery</name><environment>Net.DeliveryMonitor</environment><private>false</private><constant>false</constant><category>settings</category><initializer>false</initializer><attributes><package>Mail</package></attributes></shared-variable><methods><class-id>Net.LetterInTransit</class-id> <category>accessing</category><body package="Mail" selector="delivered">delivered	deliveryAction value.	letterText := nil.	uid := nil</body><body package="Mail" selector="deliveryAction">deliveryAction	^deliveryAction</body><body package="Mail" selector="deliveryAction:">deliveryAction: aBlock	deliveryAction := aBlock</body><body package="Mail" selector="letterText">letterText	^letterText</body><body package="Mail" selector="letterText:">letterText: aString	letterText := aString</body><body package="Mail" selector="server">server	^server</body><body package="Mail" selector="server:">server: aString	server := aString</body><body package="Mail" selector="serverType">serverType	^serverType</body><body package="Mail" selector="serverType:">serverType: aString	serverType := aString</body><body package="Mail" selector="size">size	^letterText size</body><body package="Mail" selector="uid">uid	^uid</body><body package="Mail" selector="uid:">uid: aString	uid := aString</body></methods><methods><class-id>Net.LetterInTransit</class-id> <category>initialize-release</category><body package="Mail" selector="letterText:onDelivery:">letterText: aString onDelivery: aBlock	letterText := aString.	deliveryAction := aBlock</body></methods><methods><class-id>Net.LetterInTransit</class-id> <category>delivery</category><body package="Mail" selector="sendOn:">sendOn: aStream	"Write the letter to aStream"" Old code for POP3	(letterText size &lt; 5	or: [(letterText copyFrom: 1 to: 5) ~= 'From ']) ifTrue:		[self halt: 'First line of header should be a From line.  It isn''t!']."	aStream nextPutAll: letterText</body></methods><methods><class-id>Net.LetterInTransit class</class-id> <category>instance creation</category><body package="Mail" selector="letterText:onDelivery:">letterText: aLetter onDelivery: aBlock	^self new 		letterText: aLetter onDelivery: aBlock;		yourself</body></methods><methods><class-id>Net.Mailbox</class-id> <category>commands</category><body package="Mail" selector="allHeaders">allHeaders	self subclassResponsibility</body><body package="Mail" selector="anyNewMail">anyNewMail	self subclassResponsibility</body><body package="Mail" selector="deleteMessageNumbers:">deleteMessageNumbers: aNumber	self subclassResponsibility</body><body package="Mail" selector="deliverNewMail">deliverNewMail	self subclassResponsibility</body><body package="Mail" selector="getMessage:">getMessage: number 	self subclassResponsibility</body><body package="Mail" selector="messageCount">messageCount	"How many messages are on the server?"	self subclassResponsibility</body><body package="Mail" selector="pollForNewMail">pollForNewMail	delaySemaphore ~~ nil ifTrue: [delaySemaphore signal]</body></methods><methods><class-id>Net.Mailbox</class-id> <category>private</category><body package="Mail" selector="clientSpecies">clientSpecies	self subclassResponsibility</body><body package="Mail" selector="createConnection">createConnection	(user isNil or: [server isNil]) ifTrue: [^nil].	connection := self clientSpecies connectToHost: self server. 	[connection user: self user; login]		on: NetClientError		do: [:ex | | newUser |			ex parameter == #connection ifTrue: [ ex pass].			ex parameter == #login 				ifTrue:					[(newUser := self requestNewUser)  isNil ifTrue: [ex pass].					self user: newUser.					ex retry]				ifFalse: [ex pass]].	^connection</body><body package="Mail" selector="deleteUids:">deleteUids: aSequenceOfUids	"Delete all the letters on the server.  Ignore non-existent ones"	^sync critical:		[(deliveryQueue isNil		 or: [deliveryQueue isEmpty]) ifFalse:			[ self error: (#TryingToDeleteLetters &lt;&lt; #net &gt;&gt; 'trying to delete letters when delivery queue is not empty.This will mess up message numbers.')].		 self connectedDo: [			connection isNil ifTrue:				[self class log: ((#CouldNotLoginToDeleteLetters &lt;&lt; #net &gt;&gt; 'could not login to delete letters on &lt;1s&gt;') expandMacrosWith: server).				 ^false].			lastMessage := self deleteMessageNumbers: aSequenceOfUids.			self saveSettings.			true]]</body><body package="Mail" selector="deliver:">deliver: aLetterInTransit	self deliveryQueue nextPut: aLetterInTransit.	#{Net.MailReader} ifDefinedDo:		[:mailReader| | activeInstance |		(activeInstance := mailReader activeInstance) ~~ nil ifTrue:			[activeInstance checkStatus]]</body><body package="Mail" selector="loadSettings">loadSettings	| data filename lines |	settingsSync critical:		[(filename := self settingsFilename asFilename) definitelyExists ifFalse: [ lastMessage := 0. ^self].		data := filename contentsOfEntireFile].	lines := data tokensBasedOn: $, .	lastMessage := (Number readFrom: (lines at: 2) readStream).</body><body package="Mail" selector="notifyServerMessageRead:">notifyServerMessageRead: uid	^nil</body><body package="Mail" selector="requestNewUser">requestNewUser		| username password cancel |	username := self user username asValue.	password := '' asValue.	cancel := (SimpleDialog initializedFor: nil)				setInitialGap;				addMessage: ((#YourLoginFailedFor1s &lt;&lt; #net &gt;&gt; 'Your login failed for &lt;1s&gt;') expandMacrosWith: server) centered: true;				addGap;				addMessage: (#PleaseTryAgain &lt;&lt; #net &gt;&gt; 'Please try again.') centered: true;				addGap;				addMessage: (#Username &lt;&lt; #net &gt;&gt; 'Username') textLine: username boundary: 0.4;				addGap;				addMessage: (#Password &lt;&lt; #net &gt;&gt; 'Password') textLine: password type: #password boundary: 0.4;				addGap;				addOK: [true];				openDialog;				cancel.	cancel value ifTrue: [^nil].	^NetUser new 		username: username value; 		password: password value;		yourself</body><body package="Mail" selector="safelyExecute:">safelyExecute: block" Ensure there is a connection; execute a block and make sure response is OK.Raise an appropriate exception if there is an error. Make sure connection is releasedif we had to acquire it "	^sync critical: [ self connectedDo: block.]</body><body package="Mail" selector="saveSettings">saveSettings	self saveSettings: lastMessage</body><body package="Mail" selector="saveSettings:">saveSettings: n	settingsSync critical:		[| output |output := self settingsFilename asFilename writeStream.		[output 			nextPutAll: self server;			nextPut: $, ;			print: n] ensure: [output close]]</body><body package="Mail" selector="settingsFilename">settingsFilename	| basename |	basename := self server, '.mailbox'.	^#{MailFile}		ifDefinedDo: [:mailFile| mailFile fileName: basename]		elseDo: [basename asFilename]</body></methods><methods><class-id>Net.Mailbox</class-id> <category>accessing</category><body package="Mail" selector="connectedDo:">connectedDo: aBlock 	| shouldDisconnect |	shouldDisconnect := connection isNil			ifTrue: 				[connection := self createConnection.				true]			ifFalse: [false].	^aBlock ensure: [shouldDisconnect			ifTrue: 				[connection disconnect.				connection := nil]]</body><body package="Mail" selector="connection">connection	^connection</body><body package="Mail" selector="deleteMail">deleteMail	^deleteMail isNil		ifTrue: [deleteMail := true]		ifFalse: [deleteMail]</body><body package="Mail" selector="deliveryQueue">deliveryQueue	^deliveryQueue notNil		ifTrue: [deliveryQueue]		ifFalse: [ deliveryQueue := SharedQueue new]</body><body package="Mail" selector="deliveryQueue:">deliveryQueue: sharedQueue 	deliveryQueue := sharedQueue</body><body package="Mail" selector="keepMail">keepMail	^keepMail isNil		ifTrue: [keepMail := true]		ifFalse: [keepMail]</body><body package="Mail" selector="lastMessage">lastMessage	^lastMessage notNil		ifTrue: [ lastMessage]		ifFalse: [ lastMessage := 0]</body><body package="Mail" selector="lastMessage:">lastMessage: aNumber	lastMessage := aNumber</body><body package="Mail" selector="logout">logout	connection notNil		ifTrue: 			[connection logout.			connection := nil]</body><body package="Mail" selector="server">server	^server</body><body package="Mail" selector="server:">server: aValue	server := aValue</body><body package="Mail" selector="serverType">serverType	self subclassResponsibility</body><body package="Mail" selector="terminate">terminate	pollingProcess isNil ifFalse: 		[pollingProcess terminate.		"We should find a way to clean up transactions in progress."]</body><body package="Mail" selector="user">user	^user</body><body package="Mail" selector="user:">user: aValue	user := aValue</body></methods><methods><class-id>Net.Mailbox</class-id> <category>debugging</category><body package="Mail" selector="debug:level:">debug: aStringOrBlock level: aLevel	Tools.LogEnvironment default debug: aStringOrBlock level: aLevel</body><body package="Mail" selector="log:level:">log: aStringOrBlock level: aLevel 	self class log: aStringOrBlock level: aLevel</body></methods><methods><class-id>Net.Mailbox</class-id> <category>initialize-release</category><body package="Mail" selector="initialize">initialize	sync := RecursionLock new.	settingsSync := RecursionLock new.</body></methods><methods><class-id>Net.Mailbox</class-id> <category>mail delivery</category><body package="Mail" selector="startPollingAt:every:">startPollingAt: priority every: seconds 	pollingProcess isNil ifFalse: [pollingProcess terminate].	pollingProcess := [			[| delay |			[self anyNewMail] whileTrue: [self deliverNewMail].			delay := Delay forSeconds: seconds.			delaySemaphore := delay delaySemaphore.			delay wait] repeat]				forkAt: priority"lastMessage := 0. self deliverAllMail."</body></methods><methods><class-id>Net.Mailbox class</class-id> <category>constants</category><body package="Mail" selector="defaultPollingPriority">defaultPollingPriority	^30</body><body package="Mail" selector="userClass">userClass	^NetUser</body></methods><methods><class-id>Net.Mailbox class</class-id> <category>debugging</category><body package="Mail" selector="log:level:">log: aStringOrBlock level: aLevel	Tools.LogEnvironment default log: aStringOrBlock level: aLevel</body><body package="Mail" selector="registerToDebug">registerToDebug	Tools.LogEnvironment default addToDebug: self</body></methods><methods><class-id>Net.Mailbox class</class-id> <category>instance creation</category><body package="Mail" selector="new">new	^super new initialize</body><body package="Mail" selector="startFetchMailProcessWithPriority:from:for:password:to:pollingInterval:">startFetchMailProcessWithPriority: priority from: serverName for: user password: password to: deliveryQueue pollingInterval: pollTime	| mailbox popUser |	mailbox := self new.	popUser := NetUser username: user password: password.	mailbox 		user: popUser;		server: serverName;		deliveryQueue: deliveryQueue;		loadSettings.	^mailbox 		startPollingAt: (priority isNil ifTrue: [self defaultPollingPriority] ifFalse: [priority]) 		every: pollTime</body><body package="Mail" selector="user:">user: popUser	| mailbox |	mailbox := self new.	^mailbox 		user: popUser;		yourself</body><body package="Mail" selector="user:server:">user: popUser server: server	"Pop3Mailbox 		user: PopUser request		server: (Dialog request: 'Pop Server:' initialAnswer: 'sulu.cincom.com')"	| mailbox |	mailbox := self new.	^mailbox 		user: popUser;		server: server;		yourself</body></methods><methods><class-id>Net.DeliveryMonitor</class-id> <category>initialize-release</category><body package="Mail" selector="letterForDelivery:deliveryClient:">letterForDelivery: let deliveryClient: mailClient 	self		letterForDelivery: let		deliveryClient: mailClient		resultsTo: nil</body><body package="Mail" selector="letterForDelivery:deliveryClient:resultsTo:">letterForDelivery: let deliveryClient: mailClient resultsTo: sharedQueueOrNil	letter := let.	deliveryClient := mailClient.	resultsQueue := sharedQueueOrNil</body></methods><methods><class-id>Net.DeliveryMonitor</class-id> <category>private</category><body package="Mail" selector="noteFailure">noteFailure	resultsQueue isNil ifTrue: [^self].	resultsQueue nextPut: false</body><body package="Mail" selector="noteSuccess">noteSuccess	resultsQueue isNil ifTrue: [^self].	resultsQueue nextPut: true</body><body package="Mail" selector="sendLetter">sendLetter	[deliveryClient sendLetter: letter]		on: OsInaccessibleError		do: [:ex | 			#{LetterWriter}				ifDefinedDo: [:letterWriter| letterWriter delayDeliveryOf: letter]				elseDo: [ex pass]]</body><body package="Mail" selector="setWindowLabel">setWindowLabel	self builder window label: ((#DeliveringMailFor1s &lt;&lt; #net &gt;&gt; 'Delivering mail for &lt;1s&gt;') expandMacrosWith: (letter subject ))</body></methods><methods><class-id>Net.DeliveryMonitor</class-id> <category>aspects</category><body package="Mail" selector="progress">progress	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^progress isNil		ifTrue:			[progress := 0.0 asValue]		ifFalse:			[progress]</body></methods><methods><class-id>Net.DeliveryMonitor</class-id> <category>actions</category><body package="Mail" selector="deliver">deliver	| estimatedSize increment window | 	estimatedSize := 1 max: letter size.	increment := 1.0 / estimatedSize.	self allButOpenInterface: #windowSpec.	window := self builder window.	window		openAroundCursorWithExtent: builder window minimumSize		andType: #normal.	self setWindowLabel.	CollapseOnDelivery ifTrue: [window collapse].	deliveryProcess := 		[[deliveryClient sendLetter: letter.		  [self closeRequest] uiEventFor: window.		  self noteSuccess]			on: MailIncrementNotification			do: 				[:not | 				[ [self progress value: progress value + (not ticks * increment)] uiEventFor: window] fork.				not resume]] forkAt: DeliveryPriority</body></methods><methods><class-id>Net.DeliveryMonitor class</class-id> <category>instance creation</category><body package="Mail" selector="deliver:using:">deliver: letterForDelivery using: deliveryClient 	| app |	app := self new.	app letterForDelivery: letterForDelivery deliveryClient: deliveryClient.	^app</body><body package="Mail" selector="deliver:using:resultsTo:">deliver: letterForDelivery using: deliveryClient resultsTo: sharedQueueOrNil	| app |	app := self new.	app letterForDelivery: letterForDelivery deliveryClient: deliveryClient resultsTo: sharedQueueOrNil.	^app</body></methods><methods><class-id>Net.DeliveryMonitor class</class-id> <category>interface specs</category><body package="Mail" selector="windowSpec">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #DeliveryMonitor #defaultString: 'Delivery Monitor' #catalogID: #net) 			#min: #(#{Core.Point} 256 45 ) 			#bounds: #(#{Graphics.Rectangle} 462 381 718 426 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ProgressWidgetSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #progress 					#isOpaque: true 					#model: #progress 					#direction: #horizontal 					#position: #topLeft 					#area: true 					#reverse: false ) ) ) )</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class></st-source>