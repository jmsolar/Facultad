<?xml version="1.0"?><st-source><!-- Name: ASN1Notice: Copyright © 2004 Cincom Systems, Inc.  All Rights Reserved.Comment: ASN1 contains a partial, but generally useful implementation of ASN.1.  It contians hierarchies that represent ASN.1 elements, including types and type constraints.  It also implements encoders/decoders for two ASN.1 encodings, BER and DER.Copyright: Copyright © 2004 Cincom Systems, Inc.All Rights ReservedDbIdentifier: bear73DbTrace: 51242DevelopmentPrerequisites: #(#(#any 'ASN1-Support' '') #(#any 'AT MetaNumerics' ''))PackageName: ASN1Parcel: #('ASN1')ParcelName: ASN1PrerequisiteParcels: #(#('ASN1-Support' '') #('AT MetaNumerics' ''))PrintStringCache: (73 53,mkobetic)Version: 7.3 - BETADate: 4:03:26 pm November 22, 2004 --><time-stamp>From VisualWorks®, 7.3 of November 22, 2004 on November 22, 2004 at 4:03:26 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>Asn1Struct</name><environment>ASN1</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>name order </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1-Support</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1Struct</class-id><body>Instances of Asn1Struct are used to decode ASN.1 SEQUENCEs and SETs.  It is not intended to be an extension of class Dictionary for general use.Instance Variables:	name	&lt;Symbol&gt;														optional name indicating the kind of stuct	order	&lt;OrderedCollection of: (Assoctiation key: Symbol value: Object)&gt;	associations ordered for enumeration</body></comment><class><name>SMINode</name><environment>ASN1</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>children integer oid parent symbol type value </inst-vars><class-inst-vars>root </class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.SMINode</class-id><body>An SMINode represents a node in a 'structure of manangement information' (SMI) as defined in RFC 1155 (Structure of Management Information) and expanded in RFC 1212 (Concise MIB Definitions).  In the context of an ASN.1 implementation, this class is used to derive the symbolic names associated with ASN.1 OBJECT_IDENTIFIERS.  It has a more extensive use in the implementation of the SNMP protocol, and some of the declared instVars look forward to its use in that context.Instance Variables:	children	&lt;Dictionary&gt;					the children of the SMINode	integer	&lt;Object&gt;						the integer associated with the SMINode	oid		&lt;Asn1OID | UndefinedObject&gt;	the Asn1OID associated with the SMINode	parent	&lt;SMINode | UndefinedObject&gt;	the parent of the SMINode	symbol	&lt;Symbol&gt;						the name associated with the SMINode	type	&lt;Asn1Type | UndefinedObject&gt;	the type of the SMINode's value	value	&lt;Object | UndefinedObject&gt;		the value of the SMINodeClass Instance Variables:	root		&lt;SMINode&gt;						the default root node</body></comment><class><name>Asn1TypeWrapper</name><environment>ASN1</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encoding type value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeWrapper</class-id><body>An Asn1TypeWrapper is an optional result of decoding that retains the source encoding, the Asn1Type that regulated the decoding, and the decoded value.Instance Variables:	encoding	&lt;ByteArray | Asn1Encoding&gt;	the encoding of the value	type		&lt;Asn1Type&gt;					the type of the value	value		&lt;Object&gt;						the decoded value</body></comment><class><name>Imported</name><environment>ASN1</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Imported</class-id><body>Imported is the abstract superclass of those types, native to ASN.1, that have been explicitly imported into VisualWorks because of their special semantics.  Note that the Imported hierarchy is functionally distinct from the Asn1Type hierarchy.  The latter is used to represent those characteristics of foreign types relevant to encoding and decoding.  The classes in the Imported hierarchy, in contrast, may be the end result of decoding, usually have a determinate encoding, and otherwise function like application classes.Instance Variables:	value	&lt;Object&gt;	the Smalltalk object wrapped in the special semantics of the imported type</body></comment><class><name>Asn1BitString</name><environment>ASN1</environment><super>ASN1.Imported</super><private>false</private><indexed-type>none</indexed-type><inst-vars>unused </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1BitString</class-id><body>Asn1BitString is an imported type that implements the ASN.1 semantics for a bit string with a specified number of unused bits.  The inherited 'value' instVar is expected to contain a ByteArray.Instance Variables:	unused	&lt;Integer&gt;	the number of bits considered to be 'unused' in the ByteArray value</body></comment><class><name>Asn1Exception</name><environment>ASN1</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1Exception</class-id><body>Asn1Exception is an abstract class.  It is the superclass of all ASN.1-specific exceptions.</body></comment><class><name>Asn1ExcStructBindingConflict</name><environment>ASN1</environment><super>ASN1.Asn1Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1ExcStructBindingConflict</class-id><body>An Asn1ExcStructBindingConflict is raised when a conflict is discovered while adding bindings to an Asn1Struct.</body></comment><class><name>Asn1ExcSMIPathUnknown</name><environment>ASN1</environment><super>ASN1.Asn1Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1ExcSMIPathUnknown</class-id><body>An Asn1ExcSMIPathUnknown is raised when a specified path cannot be found in a tree of SMINodes.</body></comment><class><name>Asn1OID</name><environment>ASN1</environment><super>ASN1.Imported</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encoding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1OID</class-id><body>An Asn1OID is the Smalltalk representation of an ASN.1 OBJECT_IDENTIFIER.  An Asn1OID always retains its original encoding to minimize marshaling time.Instance Variables:	encoding				&lt;ByteArray | Asn1Encoding&gt;	the encoding of the OIDShared Variables:	BEREncodingCache		&lt;Dictionary&gt;					the cache of encodings used to optimize marshaling of OIDs</body></comment><class><name>Asn1Stream</name><environment>ASN1</environment><super>Core.ReadWriteStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>tagDispatchTable </class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1Stream</class-id><body>Asn1Stream is an abstract class.  It is the superclass of the streams for marshaling and unmarshaling messages employing any of the ASN.1 encoding rules.  Subclasses must implement the following messages:	decoding - api		unmarshalObject		unmarshalObjectType:	encoding - api		marshalObject:		marshalObject:withType:	testing		requiresEncodingSort		requiresTagSortClass Instance Variables:	tagDispatchTable	&lt;Array | UndefinedObject&gt;	tag dispatch table for decoding</body></comment><class><name>ImportedWithType</name><environment>ASN1</environment><super>ASN1.Imported</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.ImportedWithType</class-id><body>ImportedWithType is the abstract superclass of those imported ASN.1 types that retain an Asn1Type in their 'type' instVar.Subclasses must implement the following messages:	accessing - translational		valueTypeInstance Variables:	type	&lt;Asn1Type&gt;	the Asn1Type of the imported type</body></comment><class><name>Asn1Choice</name><environment>ASN1</environment><super>ASN1.ImportedWithType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>choice </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1Choice</class-id><body>Asn1Choice is an imported type, optionally, but not currently used to represent ASN.1 CHOICE's in the decoded form of an object.  Users who want to see CHOICEs explicitly represented in the output of decoding may create a marshaler subclass that overrides the method 'decodeTLV_Choice:', using an instance of Asn1Choice as the generated object, like so:	...	^Asn1Choice		type: anAsn1TypeCHOICE		choiceSymbol: ele symbol		value: ( self endEncodingsWithValue: res ofType: typ )Instance Variables:	choice	&lt;Integer&gt;	the choice's tag</body></comment><class><name>Asn1ExcSMIPathSpecification</name><environment>ASN1</environment><super>ASN1.Asn1Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1ExcSMIPathSpecification</class-id><body>An Asn1ExcSMIPathSpecification is raised when an error is detected in the specification of a path in a tree of SMINodes.</body></comment><class><name>Asn1ExcTypeRegistration</name><environment>ASN1</environment><super>ASN1.Asn1Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1ExcTypeRegistration</class-id><body>An Asn1ExcTypeRegistration is raised when a violation is noted during the registration of an Asn1Type.</body></comment><class><name>Asn1Encoding</name><environment>ASN1</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source headerStart bodyStart bodyStop </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1Encoding</class-id><body>An Asn1Encoding is used to store the encoding of some decoded element.  Within some 'source' ByteArray' it retains offsets to the beginning of the encoding header (contianing the tag(s) and the length), the beginning of the encoding body, and the end of the encoding body.Instance Variables:	bodyStart	&lt;Integer&gt;		the beginning of the encoding's 'body'	bodyStop	&lt;Integer&gt;		the end of the encoding's 'body'	headerStart	&lt;Integer&gt;		the beginning of the encoding's 'header'	source		&lt;ByteArray&gt;	description of source</body></comment><class><name>Asn1TypeReference</name><environment>ASN1</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>symbol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeReference</class-id><body>Asn1TypeReference is used to implement forward referencing during type declaration and registration.  If a compound type is registered before one of its subtypes, the subtype is stored -- in the type registry and in the compound type being defined -- as an Asn1TypeReference.  Later, whenever the Asn1TypeReference is sent a message implemented in Asn1Type or any of its subtypes, then, by way of a reimplemented 'doesNotUnderstand:', the Asn1TypeReference is replaced with the concrete type using 'oneWayBecome:'.  If that type cannot be found, a runtime exception is raised.Instance Variables:	symbol		&lt;Symbol&gt;		the name of the type, presumed to be unique</body></comment><class><name>Asn1ExcTypeRealization</name><environment>ASN1</environment><super>ASN1.Asn1Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1ExcTypeRealization</class-id><body>An Asn1ExcTypeRealization is raised when a constraint or semantic violation is noted in the realization of an Asn1Type as an imported type.</body></comment><class><name>ImportedEnumeration</name><environment>ASN1</environment><super>ASN1.ImportedWithType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.ImportedEnumeration</class-id><body>An ImportedEnumeration is an imported type used to represent an ASN.1 ENUMERATED.</body></comment><class><name>Asn1ExcSMIConflict</name><environment>ASN1</environment><super>ASN1.Asn1Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1ExcSMIConflict</class-id><body>An Asn1ExcSMIConflict is raised when in inconsistency is noted during an attempt to update a tree of SMINodes.</body></comment><class><name>Asn1ExcMarshaling</name><environment>ASN1</environment><super>ASN1.Asn1Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1ExcMarshaling</class-id><body>An Asn1ExcMarshaling is raised when a marshaling error is detected during encoding or decoding.</body></comment><class><name>Asn1ExcTypeSpecification</name><environment>ASN1</environment><super>ASN1.Asn1Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1ExcTypeSpecification</class-id><body>An Asn1ExcTypeSpecification is raised when an error is detected in the specification of an Asn1Type.</body></comment><class><name>Asn1AbstractElement</name><environment>ASN1</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1AbstractElement</class-id><body>Asn1AbstractElement is the abstract superclass of the elements found in ASN.1 constructed types and enumerations.  This class and its subclasses implement selectors that facilitate the analysis of collections of such elements.</body></comment><class><name>Asn1Marker</name><environment>ASN1</environment><super>ASN1.Asn1AbstractElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1Marker</class-id><body>Asn1Marker is the abstract superclass of those classes used to represent the special markers defined in ASN.1.</body></comment><class><name>Asn1MarkerExtension</name><environment>ASN1</environment><super>ASN1.Asn1Marker</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>default </class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1MarkerExtension</class-id><body>An Asn1MarkerExtension represents an ASN.1 extension marker.  There is only one privileged, default instance.  Asn1MarkerExtension implements the selectors 'integer' and 'symbol' both of which return 'nil', so that ENUMERATED element collections -- which can contain extension markers -- may be processed without type checking.Class Instance Variables:	default	&lt;Asn1MarkerExtension&gt;	the sole instance</body></comment><class><name>Asn1MarkerException</name><environment>ASN1</environment><super>ASN1.Asn1Marker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>integer symbol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1MarkerException</class-id><body>Asn1MarkerException is intended to be used to represent ASN.1 exception markers.  It is not currently used.Instance Variables:	integer	&lt;Integer&gt;	the integer error code associated with the exception	symbol	&lt;Symbol&gt;	the name of the exception</body></comment><class><name>Asn1StreamBERBasic</name><environment>ASN1</environment><super>ASN1.Asn1Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1StreamBERBasic</class-id><body>Asn1StreamBERBasic is a BER encoding/decoding stream that assumes (1) that lengths will be stored in three bytes and (2) that tags will be one byte.  It is expected to be a suitable superclass for an SNMP encoder/decoder.</body></comment><class><name>Asn1StreamBERDefinite</name><environment>ASN1</environment><super>ASN1.Asn1StreamBERBasic</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scratchBuffer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1StreamBERDefinite</class-id><body>Asn1StreamBERDefinite is a BER encoding/decoding stream that assumes (1) that lengths are 'definitely' encoded in one or more bytes and (2) that tags may be more than one byte.  It is intended to be a suitable superclass for a DER encoder/decoder.Instance Variables:	scratchBuffer	&lt;PositionableStream&gt;	used to encode lengths</body></comment><class><name>Asn1StreamBERDefiniteEncodings</name><environment>ASN1</environment><super>ASN1.Asn1StreamBERDefinite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>currentEncoding encodingStack retainEncodings source </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1StreamBERDefiniteEncodings</class-id><body>Asn1StreamBERDefiniteEncodings is an encoder/decoder for BER that allows the user to globally retain the original encodings of marshaled objects.Instance Variables:	currentEncoding		&lt;Asn1Encoding&gt;		the current encoding	encodingStack		&lt;OrderedCollection&gt;		a stack for managing encodings	retainEncodings		&lt;Boolean&gt;				if 'true', encodings are retained	source				&lt;Collection&gt;			a copy of the entire ource encoding</body></comment><class><name>Asn1StreamDER</name><environment>ASN1</environment><super>ASN1.Asn1StreamBERDefiniteEncodings</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1StreamDER</class-id><body>Asn1StreamDER is an encoder/decoder for DER.</body></comment><class><name>Asn1Constraint</name><environment>ASN1</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1Constraint</class-id><body>Asn1Constraint is the abstract superclass of those classes that represent concrete constraints upon ASN.1's fundamental types.Subclasses must implement the following messages:	comparing		=		hash	private		privatePermits:</body></comment><class><name>Asn1ConstraintRegEx</name><environment>ASN1</environment><super>ASN1.Asn1Constraint</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1ConstraintRegEx</class-id><body>Asn1ConstraintRegEx has not been implemented and will raise an exception when tested.  It is intended to represent a regular expression constraint.</body></comment><class><name>Asn1ConstraintSubN</name><environment>ASN1</environment><super>ASN1.Asn1Constraint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>constraints </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1ConstraintSubN</class-id><body>Asn1ConstraintSubN is an abstract class.  It is the superclass of those constraints that 'spin' a collection of more basic subconstraints.Instance Variables:	constraints	&lt;(Collection of: Asn1Constraint)&gt;	da collection of subconstraints</body></comment><class><name>Asn1ConstraintUnion</name><environment>ASN1</environment><super>ASN1.Asn1ConstraintSubN</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1ConstraintUnion</class-id><body>An Asn1ConstraintUnion is fulfilled by any value that satisfies any of the 'contraints'.</body></comment><class><name>Asn1ConstraintSub1</name><environment>ASN1</environment><super>ASN1.Asn1Constraint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>constraint </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1ConstraintSub1</class-id><body>Asn1ConstraintSub1 is an abstract class.  It is the superclass of those constraints that 'spin' a single, more basic, subconstraint.Instance Variables:	constraint	&lt;Asn1Constraint&gt;	the contained subconstraint</body></comment><class><name>Asn1ConstraintExcept</name><environment>ASN1</environment><super>ASN1.Asn1ConstraintSub1</super><private>false</private><indexed-type>none</indexed-type><inst-vars>except </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1ConstraintExcept</class-id><body>An Asn1ConstraintExcept represents a constraint that is satisfied by any value that satisfies the 'constraint' and fails to satisfy the 'except'.Instance Variables:	except	&lt;Asn1Constraint&gt;	the 'except' constraint</body></comment><class><name>Asn1ConstraintSubType</name><environment>ASN1</environment><super>ASN1.Asn1Constraint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1ConstraintSubType</class-id><body>Asn1ConstraintSubType is an abstract class.  It is the superclass of those constraints that construct a constraint from an Asn1Type.Instance Variables:	type	&lt;Asn1Type&gt;	the type used to express the constraint</body></comment><class><name>Asn1ConstraintWithComponentType</name><environment>ASN1</environment><super>ASN1.Asn1ConstraintSubType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1ConstraintWithComponentType</class-id><body>Asn1ConstraintWithComponentType is used to rtepresent the 'OF type' constraint on SET OF and SEQUENCE OF types.  It is fulfilled if all elements of the set or sequence satisfy the constraint of 'type'.</body></comment><class><name>Asn1ConstraintOfType</name><environment>ASN1</environment><super>ASN1.Asn1ConstraintSubType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1ConstraintOfType</class-id><body>A Asn1ConstraintOfType is satisfied by any value that satisfies the constraints of the 'type'.</body></comment><class><name>Asn1ConstraintWithComponents</name><environment>ASN1</environment><super>ASN1.Asn1Constraint</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1ConstraintWithComponents</class-id><body>Asn1ConstraintWithComponents has not been implemented.  It is a constraint for the SET, SEQUENCE, and CHOICE types.</body></comment><class><name>Asn1ConstraintBlockClosure</name><environment>ASN1</environment><super>ASN1.Asn1Constraint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blockClosure </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1ConstraintBlockClosure</class-id><body>An Asn1ConstraintBlockClosure is used to represent arbitrary constraints that are best implemented in VisualWorks as BlockClosures.  ASN.1 itself has no notion of a block constraint.  Most of the default constraints on ASN.1 universal types are implemented using Asn1ConstraintBlockClosure.Instance Variables:	blockClosure	&lt;BlockClosure&gt;		a block that expresses a constraint</body></comment><class><name>Asn1ConstraintSize</name><environment>ASN1</environment><super>ASN1.Asn1Constraint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lower upper </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1ConstraintSize</class-id><body>An Asn1ConstraintSize is satisfied by any object with a size &gt;= 'lower' and &lt;= 'upper'.Instance Variables:	lower	&lt;Integer&gt;	the lower bound	upper	&lt;Integer&gt;	the upper bound</body></comment><class><name>Asn1ConstraintWithComponent</name><environment>ASN1</environment><super>ASN1.Asn1ConstraintSub1</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1ConstraintWithComponent</class-id><body>Asn1ConstraintWithComponent is a constraint for the SET OF and SEQUENCE OF types.  It is satisfied if each element of the set or sequence satisfies the 'constraint'.</body></comment><class><name>Asn1ConstraintValueUnion</name><environment>ASN1</environment><super>ASN1.Asn1Constraint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>values </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1ConstraintValueUnion</class-id><body>An Asn1ConstraintValueUnion is satisfied by any value that is equal to any of its 'values'.Instance Variables:	values	&lt;Collection&gt;	a collection of values</body></comment><class><name>Asn1ConstraintValueRange</name><environment>ASN1</environment><super>ASN1.Asn1Constraint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lower lowerOpen upper upperOpen </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1ConstraintValueRange</class-id><body>An Asn1ConstraintValueRange is satisfied by objects that satisfy the range.Instance Variables:	lower		&lt;Magnitude&gt;	the lower bound	lowerOpen	&lt;Boolean&gt;		'true' if the range is 'open' at the lower bound	upper		&lt;Magnitude&gt;	the upper bound	upperOpen	&lt;Boolean&gt;		'true' if the range is 'open' at the upper bound</body></comment><class><name>Asn1ConstraintEnumerated</name><environment>ASN1</environment><super>ASN1.Asn1Constraint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>elements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1ConstraintEnumerated</class-id><body>Asn1ConstraintAssociations is used to represent the constraints implied by the associations between Symbols and Integers found in the ASN.1 declarations of ENUMERATEDs and some subtypes of INTEGER.  Note that the 'elements' OrderedCollection may contain Asn1Enumerations, Asn1MarkerExtensions, or Associations.Instance Variables:	elements	&lt;(OrderedCollection)&gt;	associations between symbols and integers</body></comment><class><name>Asn1ConstraintTypeInclusion</name><environment>ASN1</environment><super>ASN1.Asn1ConstraintSubType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1ConstraintTypeInclusion</class-id><body>Asn1ConstraintTypeInclusion has not been implemented.</body></comment><class><name>Asn1ConstraintNull</name><environment>ASN1</environment><super>ASN1.Asn1Constraint</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>default </class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1ConstraintNull</class-id><body>An Asn1ConstraintNull represents an empty constraint, one satisfied by all values.  There should be only one in existence.Class Instance Variables:	default	&lt;Asn1ConstraintNull&gt;	the sole instance of the class</body></comment><class><name>Asn1ConstraintAlphabet</name><environment>ASN1</environment><super>ASN1.Asn1ConstraintSub1</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1ConstraintAlphabet</class-id><body>An Asn1ConstraintAlphabet represents a constraint on the alphabet used within a string type.  Its enclosed subconstraint is usually a union of character values.  The constraint is satisfied by strings in which all characters are members of the union.</body></comment><class><name>Asn1ConstraintSingleValue</name><environment>ASN1</environment><super>ASN1.Asn1Constraint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1ConstraintSingleValue</class-id><body>An Asn1ConstraintSingleValue is satisfied by any object that is equal to or permitted by the 'value'.Instance Variables:	value	&lt;Object | Asn1Constraint | Asn1Element | Asn1Type &gt;	an Object or an implementor of 'permits:'</body></comment><class><name>Asn1Type</name><environment>ASN1</environment><super>ASN1.Asn1TypeReference</super><private>false</private><indexed-type>none</indexed-type><inst-vars>children constraint parent wrap </inst-vars><class-inst-vars>defaultWrap </class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1Type</class-id><body>Asn1Type is an abstract class.  Instances of Asn1Type are used to represent the information needed to encode and decode an ASN.1 type and to support the double-dipatch protocol used during 'type-in-hand' encoding or decoding.Subclasses must implement the following messages:	encoding		tagBERInstance Variables:	children			&lt;Set | UndefinedObject&gt;			the children of the Asn1Type	constraint		&lt;Asn1Constraint&gt;				the constraint structure delimiting the Asn1Type	parent			&lt;Asn1Type | UndefinedObject&gt;	the parent of the Asn1Type	wrap			&lt;Boolean&gt;						intended for use in regulating type-specific decoding into Asn1TypeWrappersClass Instance Variables:	defaultWrap			&lt;Boolean&gt;					the default 'wrap' valueShared Variables:	TypeRegistry	&lt;Dictionary&gt;					the global type registry</body></comment><class><name>Asn1TypeBasic</name><environment>ASN1</environment><super>ASN1.Asn1Type</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeBasic</class-id><body>Asn1TypeBasic is the abstract superclass of the ASN.1 'basic' types, including the ASN.1 string types.  It stands in constrast with Asn1ConstructedType.</body></comment><class><name>Asn1TypeENUMERATED</name><environment>ASN1</environment><super>ASN1.Asn1TypeBasic</super><private>false</private><indexed-type>none</indexed-type><inst-vars>elements extensionMarkerCount </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeENUMERATED</class-id><body>Asn1TypeENUMERATED represents the ASN.1 ENUMERATED type.Instance Variables:	elements				&lt;(OrderedCollection of: (Association))&gt;	the symbol-to-integer mappings that define the enumeration	extensionMarkerCount	&lt;Integer&gt;								the number of extension markers</body></comment><class><name>Asn1TypeOBJECT_IDENTIFIER</name><environment>ASN1</environment><super>ASN1.Asn1TypeBasic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeOBJECT_IDENTIFIER</class-id><body>Asn1TypeOBJECT_IDENTIFIER represents the ASN.1 OBJECT IDENTIFIER type.</body></comment><class><name>Asn1TypeEMBEDDED_PDV</name><environment>ASN1</environment><super>ASN1.Asn1TypeBasic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeEMBEDDED_PDV</class-id><body>Asn1TypeEMBEDDED_PDV represents the ASN.1 EMBEDDED PDV type.</body></comment><class><name>Asn1TypeObjectDescriptor</name><environment>ASN1</environment><super>ASN1.Asn1TypeBasic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeObjectDescriptor</class-id><body>Asn1TypeObjectDescriptor represents the ASN.1 ObjectDescriptor type.</body></comment><class><name>Asn1TypeBMPString</name><environment>ASN1</environment><super>ASN1.Asn1TypeBasic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeBMPString</class-id><body>Asn1TypeBMPString represents the ASN.1 BMPString type.</body></comment><class><name>Asn1TypeUTF8String</name><environment>ASN1</environment><super>ASN1.Asn1TypeBasic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeUTF8String</class-id><body>Asn1TypeUTF8String represents the ASN.1 UTF8String type.</body></comment><class><name>Asn1TypeGeneralString</name><environment>ASN1</environment><super>ASN1.Asn1TypeBasic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeGeneralString</class-id><body>Asn1TypeGeneralString represents the ASN.1 GeneralString type.</body></comment><class><name>Asn1TypeGraphicString</name><environment>ASN1</environment><super>ASN1.Asn1TypeBasic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeGraphicString</class-id><body>Asn1TypeGraphicString represents the ASN.1 GraphicString type.</body></comment><class><name>Asn1TypeCHARACTER_STRING</name><environment>ASN1</environment><super>ASN1.Asn1TypeBasic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeCHARACTER_STRING</class-id><body>Asn1TypeCHARACTER_STRING represents the ASN.1 CHARACTER STRING type.</body></comment><class><name>Asn1TypeConstructed</name><environment>ASN1</environment><super>ASN1.Asn1Type</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeConstructed</class-id><body>Asn1TypeConstructed is the abstract superclass of the ASN.1 'constructed' types: SEQUENCE, SEQUENCE_OF, SET, SET_OF, and CHOICE.  It stands in contrast with Asn1TypeBasic.</body></comment><class><name>Asn1TypeStructured</name><environment>ASN1</environment><super>ASN1.Asn1TypeConstructed</super><private>false</private><indexed-type>none</indexed-type><inst-vars>elements defaultOrOptionalCount extensionMarkerCount minLength </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeStructured</class-id><body>Asn1TypeStructured is the abstract superclass of those constructed types that contained named, typed elements.  It is defined in contrast to Asn1TypeUnstructured.Instance Variables:	defaultOrOptionalCount	&lt;Integer&gt;								number of elements either with defaults or optional	elements				&lt;(OrderedCollection of: Asn1Element)&gt;	the elements of the structured type	extensionMarkerCount	&lt;Integer&gt;								the number of extension markers among the elements	minLength				&lt;Integer&gt;								the minimum element count</body></comment><class><name>Asn1TypeSEQUENCE</name><environment>ASN1</environment><super>ASN1.Asn1TypeStructured</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeSEQUENCE</class-id><body>Asn1TypeSEQUENCE represents the ASN.1 SEQUENCE type.</body></comment><class><name>Asn1TypeUnstructured</name><environment>ASN1</environment><super>ASN1.Asn1TypeConstructed</super><private>false</private><indexed-type>none</indexed-type><inst-vars>elementType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeUnstructured</class-id><body>Asn1TypeUnstructured is an abstract class.  It is the superclass of those constructed types that contain unnamed elements of the same type.  It is defined in contrast with Asn1TypeStructured.Instance Variables:	elementType	&lt;Asn1Type&gt;	the common type of the contained elements</body></comment><class><name>Asn1TypeSET</name><environment>ASN1</environment><super>ASN1.Asn1TypeStructured</super><private>false</private><indexed-type>none</indexed-type><inst-vars>decodingDictionary encodingDictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeSET</class-id><body>Asn1TypeSET represents the ASN.1 SET type.  Note that an ASN.1 SET is not  a set in the mathematical sense.  It is a SEQUENCE with an unconstrained transmission order.Instance Variables:	decodingDictionary	&lt;Dictionary&gt;	maps element tags to Asn1Elements	encodingDictionary	&lt;Dictionary&gt;	maps element symbols to Asn1Elements</body></comment><class><name>Asn1TypeEXTERNAL</name><environment>ASN1</environment><super>ASN1.Asn1TypeBasic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeEXTERNAL</class-id><body>Asn1TypeEXTERNAL represents the ASN.1 EXTERNAL type.</body></comment><class><name>Asn1TypeRELATIVE_OID</name><environment>ASN1</environment><super>ASN1.Asn1TypeBasic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeRELATIVE_OID</class-id><body>Asn1TypeRELATIVE_OID represents the ASN.1 RELATIVE OID type.</body></comment><class><name>Asn1TypeCHOICE</name><environment>ASN1</environment><super>ASN1.Asn1TypeStructured</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tags </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeCHOICE</class-id><body>Asn1TypeCHOICE represents the ASN.1 CHOICE type.Instance Variables:	tags	&lt;Set&gt;	the tags associated with the elements, used in decoding</body></comment><class><name>Asn1TypeSET_OF</name><environment>ASN1</environment><super>ASN1.Asn1TypeUnstructured</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeSET_OF</class-id><body>Asn1TypeSET_OF represents the ASN.1 SET OF type.  Note that an ASN.1 SET OF is not  a set in the mathematical sense.  It is a SEQUENCE OF with an unconstrained transmission order, that may contain multiple occurrences of the same value..</body></comment><class><name>Asn1TypeANY</name><environment>ASN1</environment><super>ASN1.Asn1TypeBasic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeANY</class-id><body>Asn1TypeANY represents the ASN.1 ANY type.</body></comment><class><name>Asn1TypeVideotexString</name><environment>ASN1</environment><super>ASN1.Asn1TypeBasic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeVideotexString</class-id><body>Asn1TypeVideotexString represents the ASN.1 VideotexString type.</body></comment><class><name>Asn1TypeBIT_STRING</name><environment>ASN1</environment><super>ASN1.Asn1TypeBasic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeBIT_STRING</class-id><body>Asn1TypeBIT_STRING represents the ASN.1 BIT STRING type.</body></comment><class><name>Asn1TypeINTEGER</name><environment>ASN1</environment><super>ASN1.Asn1TypeBasic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeINTEGER</class-id><body>Asn1TypeINTEGER represents the ASN.1 INTEGER type.</body></comment><class><name>Asn1TypeUniversalString</name><environment>ASN1</environment><super>ASN1.Asn1TypeBasic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeUniversalString</class-id><body>Asn1TypeUniversalString represents the ASN.1 UniversalString type.</body></comment><class><name>Asn1TypeOCTET_STRING</name><environment>ASN1</environment><super>ASN1.Asn1TypeBasic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeOCTET_STRING</class-id><body>Asn1TypeOCTET_STRING represents the ASN.1 OCTET STRING type.</body></comment><class><name>Asn1TypeBOOLEAN</name><environment>ASN1</environment><super>ASN1.Asn1TypeBasic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeBOOLEAN</class-id><body>Asn1TypeBOOLEAN represents the ASN.1 BOOLEAN type.</body></comment><class><name>Asn1TypeREAL</name><environment>ASN1</environment><super>ASN1.Asn1TypeBasic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeREAL</class-id><body>Asn1TypeREAL represents the ASN.1 REAL type.</body></comment><class><name>Asn1TypeUnknown</name><environment>ASN1</environment><super>ASN1.Asn1TypeBasic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeUnknown</class-id><body>Asn1TypeUnknown represents an unknown ASN.1 type.  It is used in code that attempts to proceed in the face unknown type tags and like marshaling difficulties.</body></comment><class><name>Asn1Element</name><environment>ASN1</environment><super>ASN1.Asn1AbstractElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>default hasDefault optional symbol tag taggingMode type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1Element</class-id><body>Asn1Element implements the elements found in the definitions of constructed types.Instance Variables:	default			&lt;Object | UndefinedObject&gt;	the default value, that could be nil	hasDefault		&lt;Boolean&gt;					indicates whether the element has a default	optional			&lt;Boolean&gt;					indicates whether the element is optional	symbol			&lt;ByteSymbol&gt;				the symbol identifying the element	tag				&lt;Integer&gt;					the elements type tag	taggingMode	&lt;Symbol&gt;					'#universal', '#implicit', or '#explicit'	type			&lt;Asn1Type&gt;				the type of the element</body></comment><class><name>Asn1TypeIA5String</name><environment>ASN1</environment><super>ASN1.Asn1TypeBasic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeIA5String</class-id><body>Asn1TypeIA5String represents the ASN.1 IA5String type.</body></comment><class><name>Asn1TypeVisibleString</name><environment>ASN1</environment><super>ASN1.Asn1TypeIA5String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeVisibleString</class-id><body>Asn1TypeVisibleString represents the ASN.1 VisibleString type.</body></comment><class><name>Asn1TypeUTCTime</name><environment>ASN1</environment><super>ASN1.Asn1TypeVisibleString</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeUTCTime</class-id><body>Asn1TypeUTCTime represents the ASN.1 UTCTime type.</body></comment><class><name>Asn1TypeGeneralizedTime</name><environment>ASN1</environment><super>ASN1.Asn1TypeVisibleString</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeGeneralizedTime</class-id><body>Asn1TypeGeneralizedTime represents the ASN.1 GeneralizedTime type.</body></comment><class><name>Asn1TypeNumericString</name><environment>ASN1</environment><super>ASN1.Asn1TypeIA5String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeNumericString</class-id><body>Asn1TypeNumericString represents the ASN.1 NumericString type.</body></comment><class><name>Asn1TypePrintableString</name><environment>ASN1</environment><super>ASN1.Asn1TypeIA5String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypePrintableString</class-id><body>Asn1TypePrintableString represents the ASN.1 PrintableString type.</body></comment><class><name>Asn1ExcUnknownTag</name><environment>ASN1</environment><super>ASN1.Asn1ExcMarshaling</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1ExcUnknownTag</class-id><body>An Asn1ExcUnknownTag is raised when an unknown type tag is encountered.</body></comment><class><name>Asn1TypeSEQUENCE_OF</name><environment>ASN1</environment><super>ASN1.Asn1TypeUnstructured</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeSEQUENCE_OF</class-id><body>Asn1TypeSEQUENCE_OF represents the ASN.1 SEQUENCE OF type.</body></comment><class><name>Asn1TypeNULL</name><environment>ASN1</environment><super>ASN1.Asn1TypeBasic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeNULL</class-id><body>Asn1TypeNULL represents the ASN.1 NULL type.</body></comment><class><name>Asn1TypeTeletexString</name><environment>ASN1</environment><super>ASN1.Asn1TypeBasic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1TypeTeletexString</class-id><body>Asn1TypeTeletexString represents the ASN.1 TeletexString type.</body></comment><class><name>Asn1Enumeration</name><environment>ASN1</environment><super>ASN1.Asn1AbstractElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>integer symbol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1Enumeration</class-id><body>An Asn1Enumeration represents one of the elements -- like the two in '{ female(0), male(1) }' -- that are found in the definition of ENUMERATEDs and of some subtypes of INTEGER.  Note that 'asAsn1Enumeration' is implemented (1) in Asn1Enumeration, (2) in Asn1MarkerExtension, because ENUMERATEDs may include extension markers, and (3) in Association, so that Associations may be easily converted.  This is not an 'imported' type because it is only used to represent an Asn1Type element, though it is like Asn1ImportedEnumeration, which latter may figure in application-level VisualWorks code.Instance Variables:	integer	&lt;Integer&gt;	the integer part of the element	symbol	&lt;Symbol&gt;	the symbolic part of the element</body></comment><class><name>Asn1ConstraintAllExcept</name><environment>ASN1</environment><super>ASN1.Asn1ConstraintSub1</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1ConstraintAllExcept</class-id><body>An Asn1ConstraintAllExcept is fulfilled by all objects that fail to satisfy its enclosed subconstraint.</body></comment><class><name>Asn1ConstraintIntersection</name><environment>ASN1</environment><super>ASN1.Asn1ConstraintSubN</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.Asn1ConstraintIntersection</class-id><body>An Asn1ConstraintIntersection is fulfilled by any value that satisfies all of the 'contraints'.</body></comment><shared-variable><name>BEREncodingCache</name><environment>ASN1.Asn1OID</environment><private>false</private><constant>false</constant><category>encoding caches</category><attributes><package>ASN1</package></attributes></shared-variable><shared-variable><name>TypeRegistry</name><environment>ASN1.Asn1Type</environment><private>false</private><constant>false</constant><category>type registry</category><attributes><package>ASN1</package></attributes></shared-variable><methods><class-id>ASN1.Asn1Struct</class-id> <category>printing</category><body package="ASN1" selector="fullPrintOn:">fullPrintOn: aStream	self fullPrintOn: aStream offset: 1</body><body package="ASN1" selector="fullPrintOn:offset:">fullPrintOn: aStream offset: offset	self printOn: aStream.	aStream nextPutAll: ' {'.	self associationsDo: [ :elem |		aStream cr; tab: offset;			nextPutAll: elem key; nextPutAll: ': '.			(elem value respondsTo: #fullPrintOn:offset:)				ifTrue: [ elem value fullPrintOn: aStream offset: offset + 1 ]				ifFalse: [ elem value printOn: aStream ] ].	aStream nextPutAll: ' }'.</body><body package="ASN1" selector="fullPrintString">fullPrintString	| aStream |	aStream := WriteStream on: (String new: 16).	self fullPrintOn: aStream offset: 1.	^aStream contents</body><body package="ASN1" selector="printOn:">printOn: aStream	aStream nextPutAll: self class name.	( name notNil ) ifTrue: [ aStream nextPutAll: '_', name ]</body></methods><methods><class-id>ASN1.Asn1Struct</class-id> <category>private</category><body package="ASN1" selector="atNewIndex:put:">atNewIndex: index put: anAssociation	self basicAt: index put: anAssociation.	tally := tally + 1.	order addLast: anAssociation.	self fullCheck</body><body package="ASN1" selector="doesNotUnderstand:">doesNotUnderstand: aMessage"attempt to interpret accessors as expected"	| selector numArgs |	selector := aMessage selector.	(numArgs := selector numArgs) isZero ifTrue: [		^self at: selector ifAbsent: [ super doesNotUnderstand: aMessage ] ].	(numArgs &gt; 1 or: [ selector last ~= $: ]) ifTrue: [		^super doesNotUnderstand: aMessage ].	self at: (selector copyFrom: 1 to: selector size - 1) asSymbol put: aMessage arguments first</body><body package="ASN1" selector="noCheckAdd:">noCheckAdd: anAssociation	super noCheckAdd: anAssociation.	order add: anAssociation.</body><body package="ASN1" selector="setTally">setTally	super setTally.	order := OrderedCollection new</body></methods><methods><class-id>ASN1.Asn1Struct</class-id> <category>accessing</category><body package="ASN1" selector="structName">structName	^name</body><body package="ASN1" selector="structName:">structName: aString	name := aString</body></methods><methods><class-id>ASN1.Asn1Struct</class-id> <category>enumerating</category><body package="ASN1" selector="do:">do: aBlock 	order do: [ :elem | aBlock value: elem value ]</body><body package="ASN1" selector="keysAndValuesDo:">keysAndValuesDo: aBlock 	order do: [ :elem | aBlock value: elem key value: elem value]</body></methods><methods><class-id>ASN1.Asn1Struct</class-id> <category>dictionary removing</category><body package="ASN1" selector="removeKey:ifAbsent:">removeKey: key ifAbsent: aBlock 	| index element |	index := self findKey: key ifAbsent: nil.  "avoid full block"	index == nil ifTrue: [^aBlock value].	element := self basicAt: index.	order remove: element.	self basicAt: index put: nil.	tally := tally - 1.	self fixCollisionsFrom: index.	^element value</body></methods><methods><class-id>ASN1.Asn1Struct</class-id> <category>dictionary enumerating</category><body package="ASN1" selector="associationsDo:">associationsDo: aBlock 	"Evaluate aBlock for each of the receiver's key/value associations."	order do: aBlock</body></methods><methods><class-id>ASN1.Asn1Struct</class-id> <category>copying</category><body package="ASN1" selector="copyEmpty:">copyEmpty: aSize	"Answer a copy of the receiver that contains no elements."	^(super copyEmpty: aSize)		structName: self structName;		yourself</body></methods><methods><class-id>ASN1.Asn1Struct</class-id> <category>adding</category><body package="ASN1" selector="add:">add: anAssociation 	^( ( self at: anAssociation key ifAbsent: [] ) notNil )		ifTrue:	[ Asn1ExcStructBindingConflict raiseSignal: (			( #theStructureAlreadyHasABindingFor1s &lt;&lt; #opentalk &gt;&gt;				'The structure already has a binding for ''&lt;1s&gt;''.' )				expandMacrosWith: anAssociation key ) ]		ifFalse:	[ super add: anAssociation ]</body></methods><methods><class-id>ASN1.Asn1Struct class</class-id> <category>instance creation</category><body package="ASN1" selector="name:">name: aString	^self new		structName: aString;		yourself</body></methods><methods><class-id>ASN1.SMINode</class-id> <category>accessing</category><body package="ASN1" selector="children">children	^children</body><body package="ASN1" selector="children:">children: aDictionary	children := aDictionary</body><body package="ASN1" selector="integer">integer	^integer</body><body package="ASN1" selector="integer:">integer: anInteger	self privateReviseParentKeyFrom: integer to: anInteger.	integer := anInteger.</body><body package="ASN1" selector="oid">oid	^oid</body><body package="ASN1" selector="oid:">oid: anAsn1OID	oid := anAsn1OID</body><body package="ASN1" selector="parent">parent	^parent</body><body package="ASN1" selector="parent:">parent: anSMINode	( parent ~~ nil )		ifTrue:	[ parent privateRemoveNode: self ].	parent := anSMINode.	( anSMINode ~~ nil )		ifTrue:	[ anSMINode privateAddNode: self ]</body><body package="ASN1" selector="symbol">symbol	^symbol</body><body package="ASN1" selector="symbol:">symbol: aSymbol	| s |	s := ( aSymbol == nil )			ifTrue:	[ nil ]			ifFalse:	[ aSymbol asSymbol ].	self privateReviseParentKeyFrom: symbol to: s.	symbol := s</body><body package="ASN1" selector="type">type	^type</body><body package="ASN1" selector="type:">type: anObject	type := anObject</body><body package="ASN1" selector="value">value	^value</body><body package="ASN1" selector="value:">value: anObject	value := anObject</body></methods><methods><class-id>ASN1.SMINode</class-id> <category>accessing - traversal</category><body package="ASN1" selector="ascendWithBlock:">ascendWithBlock: aBlockClosure	( integer ~~ self class rootInteger )		ifTrue:	[	aBlockClosure value: self.					parent ascendWithBlock: aBlockClosure				]</body><body package="ASN1" selector="at:">at: anIntegerOrSymbol	^children		at: anIntegerOrSymbol		ifAbsent: []</body><body package="ASN1" selector="at:ifAbsent:">at: anIntegerOrSymbol ifAbsent: aBlockClosure	^children		at: anIntegerOrSymbol		ifAbsent: aBlockClosure</body><body package="ASN1" selector="atAsn1OID:">atAsn1OID: anAsn1OID	^self root atPath: anAsn1OID value</body><body package="ASN1" selector="atPath:">atPath: anArray	"... expects an Array of Integers."	"... answers the leaf or nil, treating the receiver as the root of the path."	| leaf |	self privateCheckPathSpecification: anArray.	leaf := self.	anArray do: [ :n | leaf := leaf at: n ifAbsent: [ ^nil ] ].	^leaf</body><body package="ASN1" selector="descendPath:withBlock:">descendPath: anArray withBlock: aBlockClosure	| leaf |	leaf := self.	self privateCheckPathSpecification: anArray.	anArray do: [ :n |	leaf := leaf at: n ifAbsent: [ ^self smiPathUnknown ].						aBlockClosure value: leaf				].</body></methods><methods><class-id>ASN1.SMINode</class-id> <category>printing</category><body package="ASN1" selector="printOn:">printOn: aStream	aStream		nextPutAll: self class name;		nextPut: $(;		nextPut: Character space.	self printStandardFormatOn: aStream.	aStream		nextPut: Character space;		nextPut: $).</body><body package="ASN1" selector="printStandardFormatOn:">printStandardFormatOn: aStream	"... makes allowances for the evil of a missing 'integer'."	aStream		nextPutAll: ( ( symbol ~~ nil )						ifTrue:	[ symbol asString ]						ifFalse:	[ self class unknownSymbolString ] );		nextPut: Character space;		nextPut: $(;		nextPutAll: ( ( integer ~~ nil )						ifTrue:	[ integer printString ]						ifFalse:	[ self class unknownIntegerString ] );		nextPut: $)</body></methods><methods><class-id>ASN1.SMINode</class-id> <category>private</category><body package="ASN1" selector="privateAddNode:">privateAddNode: anSMINode	( anSMINode integer ~~ nil )		ifTrue:	[ children at: anSMINode integer put: anSMINode ].	( anSMINode symbol ~~ nil )		ifTrue:	[ children at: anSMINode symbol put: anSMINode ].	^anSMINode</body><body package="ASN1" selector="privateCheckChildren:againstChildren:">privateCheckChildren: aDictionary1 againstChildren: aDictionary2	" ... checks size and key membership only."	| k1 k2 |	( aDictionary1 size == aDictionary2 size )		ifFalse:	[ ^self smiChildConflict ].	k1 := aDictionary1 keys.	k2 := aDictionary2 keys.	k1 do: [ :k | ( k2 includes: k ) ifFalse: [ ^self smiChildConflict ] ].	^true</body><body package="ASN1" selector="privateCheckPathSpecification:">privateCheckPathSpecification: anArray	anArray do: [ :x | ( x isKindOf: Integer ) ifFalse: [ ^self smiPathSpecification ] ]</body><body package="ASN1" selector="privateRemoveNode:">privateRemoveNode: anSMINode	| b1 b2 |	b1 := b2 := false.	children removeKey: anSMINode integer ifAbsent: [ b1 := true ].	children removeKey: anSMINode symbol ifAbsent: [ b2 := true ].	^( b1 &amp; b2 )		ifTrue:	[ self smiPathUnknown ]		ifFalse:	[ anSMINode ]</body><body package="ASN1" selector="privateReplaceNode:with:">privateReplaceNode: anSMINode1 with: anSMINode2	"... dangerous, as it does not preserve the existing node's children."	self privateRemoveNode: anSMINode1.	^self privateAddNode: anSMINode2</body><body package="ASN1" selector="privateReviseNode:with:">privateReviseNode: anSMINode1 with: anSMINode2	"... preserves the existing node's children, and warns if there is a conflict."	| children1 children2 |	children1 := anSMINode1 children.	children2 := anSMINode2 children.	( children2 isEmpty or: [ self privateCheckChildren: children1 againstChildren: children2 ] )		ifTrue: [ anSMINode2 children: children1 ].	self privateRemoveNode: anSMINode1.	^self privateAddNode: anSMINode2</body><body package="ASN1" selector="privateReviseParentKeyFrom:to:">privateReviseParentKeyFrom: anIntegerOrSymbol1 to: anIntegerOrSymbol2	"... should handle possible 'nil' values."	( parent ~~ nil )		ifTrue:	[	( anIntegerOrSymbol1 ~~ nil )						ifTrue:	[ parent children removeKey: anIntegerOrSymbol1 ifAbsent: [] ].					( anIntegerOrSymbol2 ~~ nil )						ifTrue:	[ parent children at: anIntegerOrSymbol2 put: self ]								]</body></methods><methods><class-id>ASN1.SMINode</class-id> <category>adding</category><body package="ASN1" selector="addNode:">addNode: anSMINode	"... answers anSMINode or an exception."	| old |	old := children at: anSMINode integer ifAbsent: [].	^( old == nil )		ifTrue:	[ self privateAddNode: anSMINode ]		ifFalse:	[ self privateReviseNode: old with: anSMINode ]</body><body package="ASN1" selector="addNode:atPath:">addNode: anSMINode atPath: anArray	"... the path should include the 'integer' of the node as its last element."	( anSMINode integer ~~ anArray last )		ifTrue:	[ ^self smiPathAndNodeConflict ].	^self		privateReviseNode: ( self addPath: anArray )		with: anSMINode</body><body package="ASN1" selector="addNodes:">addNodes: aCollection 	aCollection do: [ :x | self addNode: x ]</body><body package="ASN1" selector="addPath:">addPath: anArray	"... expects an Array of Integers, and instantiates the path, treating the receiver as the root."	"... answers the leaf."	| leaf |	self privateCheckPathSpecification: anArray.	leaf := self.	anArray do: [ :n | leaf := leaf at: n ifAbsent: [ ( SMINode integer: n ) parent: leaf ] ].	^leaf</body><body package="ASN1" selector="atPath:setSymbol:">atPath: anArray setSymbol: aSymbol 	^( self addPath: anArray ) symbol: aSymbol</body><body package="ASN1" selector="setSymbol:atPath:">setSymbol: aSymbol atPath: anArray	^( self addPath: anArray ) symbol: aSymbol</body></methods><methods><class-id>ASN1.SMINode</class-id> <category>removing</category><body package="ASN1" selector="removeLeafNodeAtPath:">removeLeafNodeAtPath: anArray	"... answers an exception or the removed node."	"The Array may contain a mix of Integers and Symbols."	| leaf |	leaf := self.	anArray do: [ :n | leaf := leaf at: n ifAbsent: [ ^self smiPathUnknown  ] ].	leaf parent privateRemoveNode: leaf.	^leaf</body><body package="ASN1" selector="removeNode:">removeNode: anSMINode	^self privateRemoveNode: anSMINode</body></methods><methods><class-id>ASN1.SMINode</class-id> <category>accessing - root</category><body package="ASN1" selector="root">root	"((( SMINode root )))"	^self class root</body></methods><methods><class-id>ASN1.SMINode</class-id> <category>utility</category><body package="ASN1" selector="smiChildConflict">smiChildConflict	^Asn1ExcSMIConflict raiseSignal: (#existingNodeWithDifferentChildren &lt;&lt; #opentalk &gt;&gt; 'There is an existing node with different children.')</body><body package="ASN1" selector="smiPathAndNodeConflict">smiPathAndNodeConflict	^Asn1ExcSMIConflict raiseSignal: (#nodeIndexAndPathDoNotMatch &lt;&lt; #opentalk &gt;&gt; 'The node''s integer index does not match the last element in the path.')</body><body package="ASN1" selector="smiPathSpecification">smiPathSpecification	^Asn1ExcSMIPathSpecification raiseSignal: (#pathSpecificationsMustContainOnlyIntegers &lt;&lt; #opentalk &gt;&gt; 'SMI path specifications must contain only Integers.')</body><body package="ASN1" selector="smiPathUnknown">smiPathUnknown	^Asn1ExcSMIPathUnknown raiseSignal: (#unknownAsn1OID &lt;&lt; #opentalk &gt;&gt; 'The indicated SMI node was not found.')</body></methods><methods><class-id>ASN1.SMINode</class-id> <category>initialize-release</category><body package="ASN1" selector="initialize">initialize	children := Dictionary new: 3</body></methods><methods><class-id>ASN1.SMINode</class-id> <category>class initialization</category><body package="ASN1" selector="decodeFromTriplets:">decodeFromTriplets: anArray	"... called by the alternative, class-side initialization protocol."	| cc |	self		integer: (anArray at: 1);		symbol: (anArray at: 2).	cc := ( ( anArray at: 3 ) collect: [ :x | self class decodeFromTriplets: x ] ).	( cc isEmpty not ) ifTrue: [ self addNodes: cc ].</body></methods><methods><class-id>ASN1.SMINode</class-id> <category>accessing - derived</category><body package="ASN1" selector="alphabeticSymbol">alphabeticSymbol	^( ( symbol ~~ nil )			ifTrue:	[ symbol ]			ifFalse:	[ self class unknownSymbolString asSymbol ] )</body><body package="ASN1" selector="fullAlphabeticSymbol">fullAlphabeticSymbol	| oc str |	oc :=  OrderedCollection new: 11.	self ascendWithBlock: [ :x | oc addFirst: x symbolPreferredAsString  ].	str := WriteStream on: ( String new: 64 ).	oc 		do: [ :x | str nextPutAll: x ]		separatedBy: [ str nextPut: $. ].	^str contents asSymbol</body><body package="ASN1" selector="fullAlphabeticSymbolAtPath:">fullAlphabeticSymbolAtPath: anArray	| oc str |	oc :=  OrderedCollection new: anArray size.	self descendPath: anArray withBlock: [ :x | oc add: x symbolPreferredAsString ].	str := WriteStream on: ( String new: 64 ).	oc 		do: [ :x | str nextPutAll: x ]		separatedBy: [ str nextPut: $. ].	^str contents asSymbol</body><body package="ASN1" selector="integerPreferred">integerPreferred	^( integer ~~ nil )		ifTrue:	[ integer ]		ifFalse:	[ symbol ]</body><body package="ASN1" selector="nodeSymbol">nodeSymbol	^( ( symbol ~~ nil )			ifTrue:	[ symbol ]			ifFalse:	[ self class unknownSymbolString asSymbol ] )</body><body package="ASN1" selector="numericSymbol">numericSymbol	^( ( symbol ~~ nil )			ifTrue:	[ symbol ]			ifFalse:	[ self class unknownSymbolString asSymbol ] )</body><body package="ASN1" selector="symbolPreferred">symbolPreferred	^( symbol ~~ nil )		ifTrue:	[ symbol ]		ifFalse:	[ integer ]</body><body package="ASN1" selector="symbolPreferredAsString">symbolPreferredAsString	^( symbol ~~ nil )		ifTrue:	[ symbol asString ]		ifFalse:	[ integer printString]</body></methods><methods><class-id>ASN1.SMINode class</class-id> <category>utility</category><body package="ASN1" selector="rootInteger">rootInteger	"Zero is not allowed as the index of a substantive SMI node.  We use it for the root."	^0</body><body package="ASN1" selector="rootSymbol">rootSymbol	^#'&lt;root&gt;'</body><body package="ASN1" selector="unknownIntegerString">unknownIntegerString	^'?'</body><body package="ASN1" selector="unknownSymbolString">unknownSymbolString	^'&lt;unknown&gt;'</body></methods><methods><class-id>ASN1.SMINode class</class-id> <category>instance creation</category><body package="ASN1" selector="integer:">integer: anInteger	^self		integer: anInteger		parent: nil		symbol: nil</body><body package="ASN1" selector="integer:parent:">integer: anInteger parent: anSMINode	^self		integer: anInteger		parent: anSMINode		symbol: nil</body><body package="ASN1" selector="integer:parent:symbol:">integer: anInteger parent: anSMINode symbol: aSymbol	^( super new initialize )		integer: anInteger;		parent: anSMINode;		symbol: aSymbol;		yourself</body><body package="ASN1" selector="integer:symbol:">integer: anInteger symbol: aSymbol	^self		integer: anInteger		parent: nil		symbol: aSymbol</body><body package="ASN1" selector="new">new	"... a gesture to discourage the creation of SMINodes without a value for 'integer'."	^self shouldNotImplement</body></methods><methods><class-id>ASN1.SMINode class</class-id> <category>accessing</category><body package="ASN1" selector="root">root	"((( SMINode root )))"	^root</body><body package="ASN1" selector="root:">root: anSMINode	root := anSMINode</body></methods><methods><class-id>ASN1.SMINode class</class-id> <category>class initialization</category><body package="ASN1" selector="decodeFromTriplets:">decodeFromTriplets: anArray	"... unused."	"... a alternative initalization method."	^( self basicNew initialize )		decodeFromTriplets: anArray</body><body package="ASN1" selector="defaultRootData">defaultRootData	"... unused."	"... included to exemplify the alternative initialization strategy."	"... invoked thus:				self root: ( self decodeFromTriplets: self defaultRootData )	"	^Array		with: self rootInteger		with: self rootSymbol		with:		#(	#( 1 #iso				#(	#( 3 #org						#(	#( 6 #dod								#(	#( 1 #internet										#(	#( 1 #directory #() )											#( 2 #mgmt												#(	#( 1 #'mib-2'														#(	#( 1 #system																#(	#( 1 #sysDescr #() )																	#( 2 #sysObjectID #() )																	#( 3 #sysUpTime #() )																	#( 4 #sysContact #() )																	#( 5 #sysName #() )																	#( 6 #sysLocation #() )																	#( 7 #sysServices #() )																)															)															#( 2 #interfaces #() )															#( 3 #at #() )															#( 4 #ip #() )															#( 5 #icmp () )															#( 6 #tcp #() )															#( 7 #udp #() )															#( 8 #egp #() )															#( 11 #snmp #() )														)													)												)											)											#( 3 #experimental #() )											#( 4 #private #() )										)									)								)							)						)					)				)			)			#( 0 #itu #() )			#( 2 #'joint-iso-itu' 				#(	#( 5 #ds						#(	#( 1 #module								#(	#( 7 #authFrame										#(	#( 3 #x509 #() )										)									)								)							)						)					)				)			)		)</body><body package="ASN1" selector="initialize">initialize	"((( SMINode initialize )))"	self initializeRoot.</body><body package="ASN1" selector="initializeRoot">initializeRoot	SMINode root: ( SMINode integer: self rootInteger symbol: self rootSymbol ).	( SMINode root )		atPath: #( 0 )						setSymbol: 'itu-t';		atPath: #( 0 0 )						setSymbol: 'recommendation';		atPath: #( 0 1 )						setSymbol: 'question';		atPath: #( 0 2 )						setSymbol: 'administration';		atPath: #( 0 3 )						setSymbol: 'network-operator';		atPath: #( 0 4 )						setSymbol: 'identified-organization';		atPath: #( 0 5 )						setSymbol: 'r-recommendation';		atPath: #( 0 9 )						setSymbol: 'data';		atPath: #( 1 )						setSymbol: 'iso';		atPath: #( 1 0 )						setSymbol: 'standard';		atPath: #( 1 1 )						setSymbol: 'registration-authority';		atPath: #( 1 2 )						setSymbol: 'member-body';		atPath: #( 1 3 )						setSymbol: 'identified-organization';		atPath: #( 1 2 840 )					setSymbol: 'us';		atPath: #( 1 2 840 10040 )			setSymbol: 'x9-57';		atPath: #( 1 2 840 10040 4 )			setSymbol: 'x9algorithm';		atPath: #( 1 2 840 10040 4 1 )		setSymbol: 'dsa';		atPath: #( 1 2 840 10040 4 3 )		setSymbol: 'dsa-with-sha1';		atPath: #( 1 2 840 10046 )			setSymbol: 'ansi-x942';		atPath: #( 1 2 840 10046 2 )			setSymbol: 'number-types';		atPath: #( 1 2 840 10046 2 1 )		setSymbol: 'dhpublicnumber';		atPath: #( 1 3 6 )					setSymbol: 'dod';		atPath: #( 1 3 6 1 )					setSymbol: 'internet';		atPath: #( 1 3 6 1 1 )				setSymbol: 'directory';		atPath: #( 1 3 6 1 2 )				setSymbol: 'mgmt';		atPath: #( 1 3 6 1 3 )				setSymbol: 'experimental';		atPath: #( 1 3 6 1 4 )				setSymbol: 'private';		atPath: #( 1 3 6 1 5 )				setSymbol: 'security';		atPath: #( 1 3 6 1 6 )				setSymbol: 'snmpV2';		atPath: #( 1 3 6 1 7 )				setSymbol: 'mail';		atPath: #( 1 3 6 1 7 )				setSymbol: 'features';		atPath: #( 1 3 6 1 2 1 )				setSymbol: 'mib-2';		atPath: #( 1 3 6 1 2 2 )				setSymbol: 'pib';		atPath: #( 1 3 6 1 2 9 )				setSymbol: 'http';		atPath: #( 1 3 6 1 2 148 )			setSymbol: 'ipMIB';		atPath: #( 1 3 6 1 2 1 1 )				setSymbol: 'system';		atPath: #( 1 3 6 1 2 1 2 )				setSymbol: 'interface';		atPath: #( 1 3 6 1 2 1 3 )				setSymbol: 'at';		atPath: #( 1 3 6 1 2 1 4 )				setSymbol: 'ip';		atPath: #( 1 3 6 1 2 1 5 )				setSymbol: 'icmp';		atPath: #( 1 3 6 1 2 1 6 )				setSymbol: 'tcp';		atPath: #( 1 3 6 1 2 1 7 )				setSymbol: 'udp';		atPath: #( 1 3 6 1 2 1 8 )				setSymbol: 'egp';		atPath: #( 1 3 6 1 2 1 9 )				setSymbol: 'cmot';		atPath: #( 1 3 6 1 2 1 10 )			setSymbol: 'transmission';		atPath: #( 1 3 6 1 2 1 1 1 )			setSymbol: 'sysDescr';		atPath: #( 1 3 6 1 2 1 1 2 )			setSymbol: 'sysObjectID';		atPath: #( 1 3 6 1 2 1 1 3 )			setSymbol: 'sysUpTime';		atPath: #( 1 3 6 1 2 1 1 4 )			setSymbol: 'sysContact';		atPath: #( 1 3 6 1 2 1 1 5 )			setSymbol: 'sysName';		atPath: #( 1 3 6 1 2 1 1 6 )			setSymbol: 'sysLocation';		atPath: #( 1 3 6 1 2 1 1 7 )			setSymbol: 'sysServices';		atPath: #( 1 3 14 )					setSymbol: 'oiw';		atPath: #( 1 3 14 3 )					setSymbol: 'secsig';		atPath: #( 1 3 14 3 2 )				setSymbol: 'algorithms';		atPath: #( 1 3 14 3 2 12 )			setSymbol: 'dsa';		atPath: #( 1 3 14 3 2 26 ) 			setSymbol: 'hashAlgorithmIdentifier';		atPath: #( 1 3 14 3 2 27 )			setSymbol: 'dsaWithSHA1';		atPath: #( 2 )						setSymbol: 'joint-iso-itu-t';		atPath: #( 2 0 )						setSymbol: 'presentations';		atPath: #( 2 1 )						setSymbol: 'asn1';		atPath: #( 2 2 )						setSymbol: 'association-control';		atPath: #( 2 3 )						setSymbol: 'reliable-transfer';		atPath: #( 2 4 )						setSymbol: 'remote-operations';		atPath: #( 2 5 )						setSymbol: 'ds';		atPath: #( 2 5 4 )					setSymbol: 'attributeType';		atPath: #( 2 5 4 3 )					setSymbol: 'commonName';		atPath: #( 2 5 4 4 )					setSymbol: 'surname';		atPath: #( 2 5 4 5 )					setSymbol: 'serialNumber';		atPath: #( 2 5 4 6 )					setSymbol: 'countryName';		atPath: #( 2 5 4 7 )					setSymbol: 'localityName';		atPath: #( 2 5 4 8 )					setSymbol: 'stateOrProvinceName';		atPath: #( 2 5 4 9 )					setSymbol: 'streetAddress';		atPath: #( 2 5 4 10 )					setSymbol: 'organizationName';		atPath: #( 2 5 4 11 )					setSymbol: 'organizationalUnitName';		atPath: #( 2 5 4 12 )					setSymbol: 'title';		atPath: #( 2 5 4 13 )					setSymbol: 'description';		atPath: #( 2 5 4 41 )					setSymbol: 'name';		atPath: #( 2 5 4 42 )					setSymbol: 'givenName';		atPath: #( 2 5 4 43 )					setSymbol: 'initials';		atPath: #( 2 5 4 44 )					setSymbol: 'generationQualifier';		atPath: #( 2 5 4 46 )					setSymbol: 'dnQualifier';		atPath: #( 2 5 8 )					setSymbol: 'algorithm';		atPath: #( 2 5 8 1 )					setSymbol: 'encryptionAlgorithm';		atPath: #( 2 5 8 1 1 )				setSymbol: 'rsa';		atPath: #( 2 5 8 2 )					setSymbol: 'hashAlgorithm';		atPath: #( 2 5 8 3 )					setSymbol: 'signatureAlgorithm';		atPath: #( 2 5 29 )					setSymbol: 'ce';		atPath: #( 2 5 29 3 )					setSymbol: 'certificatePolicies';		atPath: #( 2 5 29 14 )				setSymbol: 'subjectKeyIdentifier';		atPath: #( 2 5 29 15 )				setSymbol: 'keyUsage';		atPath: #( 2 5 29 16 )				setSymbol: 'privateKeyUsagePeriod';		atPath: #( 2 5 29 17 )				setSymbol: 'subjectAltName';		atPath: #( 2 5 29 18 )				setSymbol: 'issuerAltName';		atPath: #( 2 5 29 19 )				setSymbol: 'basicConstraints';		atPath: #( 2 5 29 20 )				setSymbol: 'cRLNumber';		atPath: #( 2 5 29 21 )				setSymbol: 'reasonCode';		atPath: #( 2 5 29 23 )				setSymbol: 'instructionCode';		atPath: #( 2 5 29 24 )				setSymbol: 'invalidityDate';		atPath: #( 2 5 29 27 )				setSymbol: 'deltaCRLIndicator';		atPath: #( 2 5 29 28 )				setSymbol: 'issuingDistributionPoint';		atPath: #( 2 5 29 29 )				setSymbol: 'certificateIssuer';		atPath: #( 2 5 29 30 )				setSymbol: 'nameConstraints';		atPath: #( 2 5 29 31 )				setSymbol: 'cRLDistributionPoints';		atPath: #( 2 5 29 32 )				setSymbol: 'certificatePolicies';		atPath: #( 2 5 29 33 )				setSymbol: 'policyMappings';		atPath: #( 2 5 29 35 )				setSymbol: 'authorityKeyIdentifier';		atPath: #( 2 5 29 36 )				setSymbol: 'policyConstraints';		atPath: #( 2 5 29 37 )				setSymbol: 'extKeyUsage'.</body><body package="ASN1" selector="initializeRootAlternative">initializeRootAlternative	"((( SMINode initializeRootAlternative )))"	self root: ( self decodeFromTriplets: self defaultRootData )</body></methods><methods><class-id>ASN1.Asn1TypeWrapper</class-id> <category>accessing</category><body package="ASN1" selector="encoding">encoding	^encoding</body><body package="ASN1" selector="encoding:">encoding: aByteArrayOrAsn1Encoding	encoding := aByteArrayOrAsn1Encoding</body><body package="ASN1" selector="type">type	^type</body><body package="ASN1" selector="type:">type: anAsn1Type	type := anAsn1Type</body><body package="ASN1" selector="value">value	^value</body><body package="ASN1" selector="value:">value: aSmalltalkObject	value := aSmalltalkObject</body></methods><methods><class-id>ASN1.Asn1TypeWrapper</class-id> <category>encoding</category><body package="ASN1" selector="encodeASN1With:">encodeASN1With: aMarshaler	"... the generic, double-dispatch encoding API."  	"However, this implementation redispatches to the type held by this marshaling wrapper."	type encode: value with: aMarshaler</body><body package="ASN1" selector="tagBER">tagBER	^type tagBER</body></methods><methods><class-id>ASN1.Asn1TypeWrapper</class-id> <category>validation</category><body package="ASN1" selector="isPermissible">isPermissible	^type permits: value</body><body package="ASN1" selector="permits:">permits: anObject	^type permits: anObject</body></methods><methods><class-id>ASN1.Asn1TypeWrapper</class-id> <category>redirection</category><body package="ASN1" selector="doesNotUnderstand:">doesNotUnderstand: aMessage	^value perform: aMessage selector withArguments: aMessage arguments</body></methods><methods><class-id>ASN1.Asn1TypeWrapper</class-id> <category>protocol compatibility</category><body package="ASN1" selector="key">key	^type symbol</body></methods><methods><class-id>ASN1.Asn1TypeWrapper</class-id> <category>printing</category><body package="ASN1" selector="printOn:">printOn: aStream	aStream		nextPutAll: self class name;		nextPut: $(.	( type notNil )		ifTrue:	[ aStream 					nextPutAll: self type symbol asString;					nextPut: $/				].	aStream		nextPutAll: self value printString;		nextPut: $)</body></methods><methods><class-id>ASN1.Asn1TypeWrapper</class-id> <category>comparing</category><body package="ASN1" selector="=">= anObject	^( anObject class == self class )		and: [ ( anObject value = self value )			and: [ ( anObject type = self type )				and: [ ( anObject encoding = self encoding ) ] ] ]</body></methods><methods><class-id>ASN1.Asn1TypeWrapper class</class-id> <category>instance creation</category><body package="ASN1" selector="encoding:type:value:">encoding: aByteArray type: anAsn1Type value: anObject	^( super new )		encoding: aByteArray;		type: anAsn1Type;		value: anObject;		yourself</body><body package="ASN1" selector="encoding:value:">encoding: aByteArray value: anObject	^( super new )		encoding: aByteArray;		value: anObject;		yourself</body><body package="ASN1" selector="type:">type: anAsn1Type	^( super new )		type: anAsn1Type;		yourself</body><body package="ASN1" selector="type:value:">type: anAsn1Type value: anObject	^( super new )		type: anAsn1Type;		value: anObject;		yourself</body></methods><methods><class-id>ASN1.Imported</class-id> <category>accessing</category><body package="ASN1" selector="value">value	^value</body><body package="ASN1" selector="value:">value: anObject	value := anObject</body></methods><methods><class-id>ASN1.Imported</class-id> <category>comparing</category><body package="ASN1" selector="=">= anObject	^( anObject class == self class )		and: [ anObject value = self value ]</body><body package="ASN1" selector="hash">hash	^value hash</body></methods><methods><class-id>ASN1.Imported class</class-id> <category>instance creation</category><body package="ASN1" selector="value:">value: anObject	"((( Asn1ImportedTOC value: ( OrderedCollection with: 1 with: 2 ) )))"	^( self new )		value: anObject;		yourself</body></methods><methods><class-id>ASN1.Asn1BitString</class-id> <category>marshaling - asn1</category><body package="ASN1" selector="encodeASN1With:">encodeASN1With: aMarshaler	"... the generic, double-dispatch encoding API."	"... only the primitive encoding."	^aMarshaler encodeBIT_STRING: self</body><body package="ASN1" selector="tagBER">tagBER	"... avoid the namespace lookup."	^02r00000011	"ASN1.UniversalBIT_STRING = 3"</body></methods><methods><class-id>ASN1.Asn1BitString</class-id> <category>testing</category><body package="ASN1" selector="isEmpty">isEmpty	^( unused == 0 ) and: [ value = #[] ]</body></methods><methods><class-id>ASN1.Asn1BitString</class-id> <category>printing</category><body package="ASN1" selector="printOn:">printOn: aStream	aStream		nextPutAll: self class name;		nextPut: $(;		nextPutAll: value size printString;		nextPut: $/;		nextPutAll: unused printString;		nextPut: $/;		nextPutAll: value first printString;		nextPutAll: '...';		nextPutAll: value last printString;		nextPut: $)</body></methods><methods><class-id>ASN1.Asn1BitString</class-id> <category>accessing</category><body package="ASN1" selector="bytes">bytes	^value</body><body package="ASN1" selector="bytes:">bytes: aByteArray	self value: aByteArray</body><body package="ASN1" selector="unused">unused	^unused</body><body package="ASN1" selector="unused:">unused: anInteger	unused := anInteger</body></methods><methods><class-id>ASN1.Asn1BitString</class-id> <category>comparing</category><body package="ASN1" selector="=">= anObject	^( anObject class == self class )		and: [ anObject value = self value 			and: [ anObject unused == self unused ] ]</body><body package="ASN1" selector="hash">hash	^( value hash bitShift: 7 ) bitOr: unused hash</body></methods><methods><class-id>ASN1.Asn1BitString class</class-id> <category>instance creation</category><body package="ASN1" selector="empty">empty	^( self new )		unused: 0;		value: #[];		yourself</body><body package="ASN1" selector="unused:bytes:">unused: anInteger bytes: aByteArray	| n |	n := ( self new )			unused: anInteger;			value: aByteArray;			yourself.	self validate: n.	^n</body></methods><methods><class-id>ASN1.Asn1BitString class</class-id> <category>validation</category><body package="ASN1" selector="validate:">validate: anAsn1ImportedBitString	"... ensures that 'unused' is in the valid range and that the unused bits are '0', in accord with the stronger, DER requirement.  (BER allows '1's among the unused bits.)"	| uu vu vl mc |	uu := anAsn1ImportedBitString unused.	( ( uu &gt;= 0 ) and: [ uu &lt;= 7 ] )		ifFalse: [ ^Asn1ExcTypeRealization raiseSignal: (#theNumberOfUnusedBitsMustBeBetweenZeroAndSeven &lt;&lt; #opentalk &gt;&gt; 'The number of unused bits must be between zero and seven!') ].	( ( vu := anAsn1ImportedBitString value ) ~= #[] )		ifTrue:	[	vl := vu last.					mc := vl maskClear: ( ASN1.BitMasksTerminal at: ( uu + 1 ) ).					( vl = mc )						ifFalse:	[ ^Asn1ExcTypeRealization raiseSignal: (#unusedBitsMustBeZero &lt;&lt; #opentalk &gt;&gt; 'Unused bits must be zero!') ]				]</body></methods><methods><class-id>ASN1.Asn1OID</class-id> <category>accessing</category><body package="ASN1" selector="encoding">encoding	^encoding</body><body package="ASN1" selector="encoding:">encoding: aByteArray	encoding := aByteArray</body></methods><methods><class-id>ASN1.Asn1OID</class-id> <category>marshaling - asn1</category><body package="ASN1" selector="encodeASN1With:">encodeASN1With: aMarshaler	"... the generic, double-dispatch encoding API."	^aMarshaler encodeOBJECT_IDENTIFIER: self</body><body package="ASN1" selector="tagBER">tagBER	"... avoid the namespace lookup."	^02r00000110	"ASN1.UniversalOBJECT_IDENTIFIER = 6"</body></methods><methods><class-id>ASN1.Asn1OID</class-id> <category>printing</category><body package="ASN1" selector="printIntegersOn:">printIntegersOn: aStream	self value		do: [ :x | aStream nextPutAll: x printString ]		separatedBy: [ aStream nextPut: $. ]</body><body package="ASN1" selector="printOn:">printOn: aStream	aStream nextPutAll: self class name.	aStream nextPut: $(.	self printIntegersOn: aStream.	aStream nextPut: $).</body></methods><methods><class-id>ASN1.Asn1OID</class-id> <category>other representations</category><body package="ASN1" selector="alphabeticSymbol">alphabeticSymbol	^SMINode root fullAlphabeticSymbolAtPath: value.</body><body package="ASN1" selector="leafSymbol">leafSymbol	^( SMINode root atAsn1OID: self ) symbol</body><body package="ASN1" selector="numericSymbol">numericSymbol	| str |	str := WriteStream on: ( String new: ( value size * 2 ) ).	self printIntegersOn: str.	^str contents asSymbol</body></methods><methods><class-id>ASN1.Asn1OID class</class-id> <category>instance management</category><body package="ASN1" selector="addOID:">addOID: anAsn1ImportedOID	BEREncodingCache		at: anAsn1ImportedOID value		put: anAsn1ImportedOID</body><body package="ASN1" selector="findOIDValue:">findOIDValue: anArray	^BEREncodingCache		at: anArray		ifAbsent: []</body><body package="ASN1" selector="new">new	^self shouldNotImplement</body><body package="ASN1" selector="removeOID:">removeOID: anAsn1ImportedOID	BEREncodingCache		removeKey: anAsn1ImportedOID value</body><body package="ASN1" selector="value:">value: anObject	"Preserve object identity at creation."	| oid |	( ( oid := self findOIDValue: anObject ) isNil )		ifTrue:	[ self addOID:					( oid := ( super new )								value: anObject;								yourself )				].	^oid</body></methods><methods><class-id>ASN1.Asn1OID class</class-id> <category>class initialization</category><body package="ASN1" selector="initialize">initialize	self initializeBEREncodingCache</body><body package="ASN1" selector="initializeBEREncodingCache">initializeBEREncodingCache	BEREncodingCache := Dictionary new: 1024.</body><body package="ASN1" selector="resetBEREncodingCache">resetBEREncodingCache	"((( Asn1ImportedOID resetBEREncodingCache )))"	self initializeBEREncodingCache</body></methods><methods><class-id>ASN1.Asn1OID class</class-id> <category>accessing</category><body package="ASN1" selector="berEncodingCache">berEncodingCache	"((( Asn1ImportedOID berEncodingCache )))"	^BEREncodingCache</body></methods><methods><class-id>ASN1.Asn1Stream</class-id> <category>utility</category><body package="ASN1" selector="maxReadLimit">maxReadLimit	readLimit := collection size.	self reset.</body><body package="ASN1" selector="setReadLimit:">setReadLimit: anInteger 	readLimit := anInteger max: collection size.	self reset.</body></methods><methods><class-id>ASN1.Asn1Stream</class-id> <category>decoding - api</category><body package="ASN1" selector="unmarshalObject">unmarshalObject	"... the default, top-level, decoding entry point."	self subclassResponsibility</body><body package="ASN1" selector="unmarshalObjectType:">unmarshalObjectType: anAsn1Type	"... the default, top-level, entry point for type-in-hand decoding."	self subclassResponsibility</body></methods><methods><class-id>ASN1.Asn1Stream</class-id> <category>encoding - api</category><body package="ASN1" selector="marshalObject:">marshalObject: anObject	"... the default, top-level, encoding entry point."	self subclassResponsibility</body><body package="ASN1" selector="marshalObject:withType:">marshalObject: anObject withType: anAsn1Type	"... the default, top-level, entry point for type-in-hand encoding."	self subclassResponsibility</body></methods><methods><class-id>ASN1.Asn1Stream</class-id> <category>initialize-release</category><body package="ASN1" selector="initialize">initialize	"... intentionally null."</body></methods><methods><class-id>ASN1.Asn1Stream</class-id> <category>testing</category><body package="ASN1" selector="requiresEncodingSort">requiresEncodingSort	self subclassResponsibility</body><body package="ASN1" selector="requiresTagSort">requiresTagSort	self subclassResponsibility</body></methods><methods><class-id>ASN1.Asn1Stream class</class-id> <category>class initialization</category><body package="ASN1" selector="initialize">initialize	"((( self initialize )))"	self initializeTagDispatchTable.</body><body package="ASN1" selector="initializeTagDispatchTable">initializeTagDispatchTable	"Initialize the tag table used for unmarshaling or decoding."	self tagDispatchTable: nil.</body></methods><methods><class-id>ASN1.Asn1Stream class</class-id> <category>accessing</category><body package="ASN1" selector="tagDispatchTable">tagDispatchTable	^tagDispatchTable</body><body package="ASN1" selector="tagDispatchTable:">tagDispatchTable: anObject	tagDispatchTable := anObject</body></methods><methods><class-id>ASN1.Asn1Stream class</class-id> <category>instance creation</category><body package="ASN1" selector="new">new	^self basicNew initialize</body><body package="ASN1" selector="on:">on: aCollection 	"Answer a new instance of the receiver, streaming over aCollection."	^self new on: aCollection</body><body package="ASN1" selector="on:from:to:">on: aCollection from: firstIndex to: lastIndex 	"Answer a new instance streaming over a copy of aCollection from firstIndex to lastIndex."	^self new		on: aCollection		from: firstIndex		to: lastIndex</body><body package="ASN1" selector="with:">with: aCollection 	"Answer a new instance of the receiver streaming on aCollection.  Assume that the collection is already full so the position and the limits are set to the end."	^self new with: aCollection</body><body package="ASN1" selector="with:from:to:">with: aCollection from: firstIndex to: lastIndex 	"Answer a new instance of the receiver streaming on the subcollection of aCollection, starting at index firstIndex and ending at lastIndex.  Assume that the resulting collection is already full so the position and the limits are set to the end."	^self new with: ( aCollection copyFrom: firstIndex to: lastIndex )</body></methods><methods><class-id>ASN1.ImportedWithType</class-id> <category>marshaling - asn1</category><body package="ASN1" selector="containsAsn1Type">containsAsn1Type	^true</body></methods><methods><class-id>ASN1.ImportedWithType</class-id> <category>accessing</category><body package="ASN1" selector="type">type	^type</body><body package="ASN1" selector="type:">type: anAsn1Type	type := anAsn1Type</body></methods><methods><class-id>ASN1.ImportedWithType</class-id> <category>accessing - translational</category><body package="ASN1" selector="valueType">valueType	self subclassResponsibility</body></methods><methods><class-id>ASN1.ImportedWithType</class-id> <category>comparing</category><body package="ASN1" selector="=">= anObject	^( anObject class == self class )		and: [ anObject value = self value 			and: [ anObject type == self type ] ]</body><body package="ASN1" selector="hash">hash	^( value hash bitShift: 7 ) bitOr: type symbol hash</body></methods><methods><class-id>ASN1.ImportedWithType class</class-id> <category>instance creation</category><body package="ASN1" selector="type:">type: anAsn1Type	^( super new )		type: anAsn1Type;		yourself</body><body package="ASN1" selector="type:value:">type: anAsn1Type value: anObject	^( super new )		type: anAsn1Type;		value: anObject;		yourself</body></methods><methods><class-id>ASN1.Asn1Choice</class-id> <category>accessing - translational</category><body package="ASN1" selector="choiceSymbol">choiceSymbol	^( type elementWithTag: choice ) symbol</body><body package="ASN1" selector="choiceSymbol:">choiceSymbol: aSymbol	self choice: ( type elementWithSymbol: aSymbol ) tag</body><body package="ASN1" selector="valueType">valueType	^( type elementWithTag: choice ) type</body></methods><methods><class-id>ASN1.Asn1Choice</class-id> <category>marshaling - asn1</category><body package="ASN1" selector="encodeASN1With:">encodeASN1With: aMarshaler	"... the generic, double-dispatch encoding API."	aMarshaler encodeTLV: value withElement: ( type elementWithTag: choice )</body><body package="ASN1" selector="tag">tag	^( type elementWithTag: choice ) tag</body><body package="ASN1" selector="tagBER">tagBER	^( type elementWithTag: choice ) tagBER</body></methods><methods><class-id>ASN1.Asn1Choice</class-id> <category>printing</category><body package="ASN1" selector="fullPrintOn:offset:">fullPrintOn: aStream offset: offset	aStream		nextPutAll: self class name;		nextPut: $_;		nextPutAll: self type symbol;		nextPutAll: ' {';		nextPutAll: self valueType symbol;		nextPutAll: ' / '.	( value respondsTo: #fullPrintOn:offset:)		ifTrue:	[ value fullPrintOn: aStream offset: offset + 1 ]		ifFalse: [ value printOn: aStream ].	aStream nextPutAll: ' }'.</body><body package="ASN1" selector="printOn:">printOn: aStream	aStream		nextPutAll: self class name;		nextPut: $_;		nextPutAll: self type symbol;		nextPut: $(;		nextPutAll: self valueType symbol;		nextPut: $/;		nextPutAll: self value printString;		nextPut: $)</body></methods><methods><class-id>ASN1.Asn1Choice</class-id> <category>comparing</category><body package="ASN1" selector="=">= anObject	^( anObject class == self class )		and: [ anObject value = self value 			and: [ anObject type == self type				and: [ anObject choice == self choice ] ] ]</body><body package="ASN1" selector="hash">hash	^( ( ( value hash bitShift: 7 ) bitOr: type symbol hash ) bitShift: 7 ) bitOr: choice hash</body></methods><methods><class-id>ASN1.Asn1Choice</class-id> <category>accessing</category><body package="ASN1" selector="choice">choice	^choice</body><body package="ASN1" selector="choice:">choice: anInteger	choice := anInteger</body></methods><methods><class-id>ASN1.Asn1Choice</class-id> <category>encoding</category><body package="ASN1" selector="encode:with:">encode: anObject with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand.  Only Asn1ImportedChoice, among all the imported types, implements this method."	aMarshaler encodeV: anObject value withElement: ( type elementWithTag: choice )</body></methods><methods><class-id>ASN1.Asn1Choice class</class-id> <category>instance creation</category><body package="ASN1" selector="type:choice:value:">type: anAsn1Type choice: anInteger value: anObject	^( super new )		type: anAsn1Type;		choice: anInteger;		value: anObject;		yourself</body><body package="ASN1" selector="type:choiceSymbol:">type: anAsn1Type choiceSymbol: aSymbol	^( super new )		type: anAsn1Type;		choiceSymbol: aSymbol;		yourself</body><body package="ASN1" selector="type:choiceSymbol:value:">type: anAsn1Type choiceSymbol: aSymbol value: anObject	^( super new )		type: anAsn1Type;		choiceSymbol: aSymbol;		value: anObject;		yourself</body></methods><methods><class-id>ASN1.Asn1Encoding</class-id> <category>accessing</category><body package="ASN1" selector="bodyStart">bodyStart	^bodyStart</body><body package="ASN1" selector="bodyStart:">bodyStart: anInteger	bodyStart := anInteger</body><body package="ASN1" selector="bodyStop">bodyStop	^bodyStop</body><body package="ASN1" selector="bodyStop:">bodyStop: anInteger	bodyStop := anInteger</body><body package="ASN1" selector="headerStart">headerStart	^headerStart</body><body package="ASN1" selector="headerStart:">headerStart: anInteger	headerStart := anInteger</body><body package="ASN1" selector="source">source	^source</body><body package="ASN1" selector="source:">source: aByteArray	source := aByteArray</body></methods><methods><class-id>ASN1.Asn1Encoding</class-id> <category>api</category><body package="ASN1" selector="bodyEncoding">bodyEncoding	^source copyFrom: bodyStart to: bodyStop</body><body package="ASN1" selector="fullEncoding">fullEncoding	^source copyFrom: headerStart to: bodyStop</body><body package="ASN1" selector="headerEncoding">headerEncoding	^source copyFrom: headerStart to: bodyStart - 1</body></methods><methods><class-id>ASN1.Asn1Encoding class</class-id> <category>instance creation</category><body package="ASN1" selector="source:">source: aByteArray	^( self basicNew )		source: aByteArray;		yourself</body></methods><methods><class-id>ASN1.Asn1TypeReference</class-id> <category>accessing</category><body package="ASN1" selector="symbol">symbol	^symbol</body><body package="ASN1" selector="symbol:">symbol: aSymbol	"... do ensure that it will be aSymbol."	symbol := aSymbol asSymbol</body></methods><methods><class-id>ASN1.Asn1TypeReference</class-id> <category>redirection / tree patching</category><body package="ASN1" selector="doesNotUnderstand:">doesNotUnderstand: aMessage	| type |	type := Asn1Type typeRegistry				at: symbol				ifAbsent: [ Asn1ExcMarshaling raiseSignal: (#unknownASN1Type &lt;&lt; #opentalk &gt;&gt; 'Unknown ASN.1 type!') ].	self oneWayBecome: type.	^type perform: aMessage selector withArguments: aMessage arguments</body></methods><methods><class-id>ASN1.Asn1TypeReference</class-id> <category>comparing</category><body package="ASN1" selector="=">= anObject	^( anObject class == self class )		and: [ anObject symbol = self symbol ]</body><body package="ASN1" selector="hash">hash	^( self class name hash bitShift: 5 ) bitOr: symbol hash</body></methods><methods><class-id>ASN1.Asn1TypeReference class</class-id> <category>instance creation</category><body package="ASN1" selector="symbol:">symbol: aSymbol	^( super new )		symbol: aSymbol;		yourself</body></methods><methods><class-id>ASN1.ImportedEnumeration</class-id> <category>encoding</category><body package="ASN1" selector="encode:with:">encode: anObject with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand.  Only Asn1ImportedChoice, among all the imported types, implements this method."	aMarshaler encodeENUMERATED: self</body></methods><methods><class-id>ASN1.ImportedEnumeration</class-id> <category>accessing - translational</category><body package="ASN1" selector="valueSymbol">valueSymbol	^( type elementWithInteger: value ) symbol</body><body package="ASN1" selector="valueSymbol:">valueSymbol: aSymbol	self value: ( type elementWithSymbol: aSymbol ) integer</body><body package="ASN1" selector="valueType">valueType	^type</body></methods><methods><class-id>ASN1.ImportedEnumeration</class-id> <category>marshaling - asn1</category><body package="ASN1" selector="encodeASN1With:">encodeASN1With: aMarshaler	"... the generic, double-dispatch encoding API."	^aMarshaler encodeENUMERATED: self</body><body package="ASN1" selector="tagBER">tagBER	"... avoid the namespace lookup."	^02r00001010	"ASN1.UniversalENUMERATED = 10"</body></methods><methods><class-id>ASN1.ImportedEnumeration</class-id> <category>conversion</category><body package="ASN1" selector="asENUMERATED">asENUMERATED	^self</body></methods><methods><class-id>ASN1.ImportedEnumeration class</class-id> <category>instance creation</category><body package="ASN1" selector="type:valueSymbol:">type: anAsn1TypeENUMERATED valueSymbol: aSymbol	^( super new )		type: anAsn1TypeENUMERATED;		valueSymbol: aSymbol;		yourself</body></methods><methods><class-id>ASN1.Asn1AbstractElement</class-id> <category>printing</category><body package="ASN1" selector="printOn:">printOn: aStream	aStream		nextPutAll: ( self class name )</body></methods><methods><class-id>ASN1.Asn1AbstractElement</class-id> <category>testing</category><body package="ASN1" selector="hasDefault">hasDefault	"Answers whether the receiver contains a default value."	^false</body><body package="ASN1" selector="hasDefaultOrIsOptional">hasDefaultOrIsOptional	"Answers whether the receiver contains a default value or is optional."	^false</body><body package="ASN1" selector="isElement">isElement	"Answers whether the receiver is an element."	^false</body><body package="ASN1" selector="isEnumeration">isEnumeration	"Answers whether the receiver is an enumeration."	^false</body><body package="ASN1" selector="isExceptionMarker">isExceptionMarker	"Answers whether the receiver is an exception marker."	^false</body><body package="ASN1" selector="isExplicit">isExplicit	"Answers whether the receiver is explicitly tagged."	^false</body><body package="ASN1" selector="isExtensionMarker">isExtensionMarker	"Answers whether the receiver is an extension marker."	^false</body><body package="ASN1" selector="isImplicit">isImplicit	"Answers whether the receiver is implicitly tagged."	^false</body><body package="ASN1" selector="isMarker">isMarker	"Answers whether the receiver is a marker."	^false</body><body package="ASN1" selector="isOptional">isOptional	"Answers whether the receiver is optional."	^false</body><body package="ASN1" selector="isUniversal">isUniversal	"Answers whether the receiver is 'universally' tagged, that is, neither implicitly nor explicitly tagged."	^true</body></methods><methods><class-id>ASN1.Asn1Marker</class-id> <category>testing</category><body package="ASN1" selector="isMarker">isMarker	^true</body></methods><methods><class-id>ASN1.Asn1MarkerExtension</class-id> <category>testing</category><body package="ASN1" selector="isExtensionMarker">isExtensionMarker	^true</body></methods><methods><class-id>ASN1.Asn1MarkerExtension</class-id> <category>protocol compatibility</category><body package="ASN1" selector="integer">integer	^nil</body><body package="ASN1" selector="symbol">symbol	^nil</body></methods><methods><class-id>ASN1.Asn1MarkerExtension</class-id> <category>converting</category><body package="ASN1" selector="asAsn1Enumeration">asAsn1Enumeration	^self</body></methods><methods><class-id>ASN1.Asn1MarkerExtension class</class-id> <category>instance creation</category><body package="ASN1" selector="default">default	^self new</body><body package="ASN1" selector="new">new	^( default isNil )		ifTrue:	[ default := super new ]		ifFalse:	[ default ]</body></methods><methods><class-id>ASN1.Asn1MarkerException</class-id> <category>accessing</category><body package="ASN1" selector="integer">integer	^integer</body><body package="ASN1" selector="integer:">integer: anInteger	integer := anInteger</body><body package="ASN1" selector="symbol">symbol	^symbol</body><body package="ASN1" selector="symbol:">symbol: aSymbol	symbol := aSymbol</body></methods><methods><class-id>ASN1.Asn1MarkerException</class-id> <category>testing</category><body package="ASN1" selector="isExceptionMarker">isExceptionMarker	^true</body></methods><methods><class-id>ASN1.Asn1MarkerException class</class-id> <category>instance creation</category><body package="ASN1" selector="integer:symbol:">integer: anInteger symbol: aSymbol	^( self new )		integer: anInteger;		symbol: aSymbol;		yourself</body><body package="ASN1" selector="symbol:integer:">symbol: aSymbol integer: anInteger	^( self new )		integer: anInteger;		symbol: aSymbol;		yourself</body></methods><methods><class-id>ASN1.Asn1StreamBERBasic</class-id> <category>decoding - tagged types</category><body package="ASN1" selector="decodeBOOLEAN:">decodeBOOLEAN: anInteger	^( self next == 0 ) not</body><body package="ASN1" selector="decodeENUMERATED:">decodeENUMERATED: anInteger	"We elect to decode as an INTEGER unless we have a type in hand."	^self decodeINTEGER: anInteger	"^Asn1ImportedEnumeration		type: Asn1TypeENUMERATED default		value: ( self decodeINTEGER: anInteger )"</body><body package="ASN1" selector="decodeGeneralizedTime:">decodeGeneralizedTime: anInteger	| ts str pk yr mo da hr mn se ms gmtoff gmtadj |	ts := Timestamp new.	str := ReadStream on: ( self decodeVisibleString: anInteger ).	yr := ( str next: 4 ) asNumber.	mo := ( str next: 2 ) asNumber.	da := ( str next: 2 ) asNumber.	hr := ( str atEnd not and: [ str peek isDigit ] )			ifTrue:	[ ( str next: 2 ) asNumber ]			ifFalse:	[ 0 ].	mn := ( str atEnd not and: [ str peek isDigit ] )			ifTrue:	[ ( str next: 2 ) asNumber ]			ifFalse:	[ 0 ].	se := ( str atEnd not and: [ str peek isDigit ] )			ifTrue:	[ ( str next: 2 ) asNumber ]			ifFalse:	[ 0 ].	( str atEnd not and: [ ( pk := str peek ) = $. or: [ pk = $, ] ] )		ifTrue:	[	| pos n |					str skip: 1.					pos := str position.					n := 0.					[ str atEnd not and: [ ( 'Z+-' includes: str peek) not ] ]						whileTrue: [ n := n + 1. str next ].					str position: pos.					ms := ( str next: n ) asNumber.					ms := ( ms / ( 10 ** ( ms log truncated + 1 ) ) * 1000 ) truncated				]		ifFalse:	[	ms := 0				].	gmtoff := TimeZone reference secondsFromGMT / 3600.0.	( str atEnd )		ifTrue:	[	gmtadj := gmtoff.				].	( ( str atEnd ) not and: [ ( pk := str peek ) = $Z ] )		ifTrue:	[	gmtadj := 0.				].	( str atEnd not and: [ ( pk := str peek ) = $- or: [ pk = $+ ] ] )		ifTrue:	[	str skip: 1.					gmtadj := ( str next: 2 ) asNumber + ( ( str next: 2 ) asNumber / 60.0 ).					( pk = $- )						ifTrue:	[ gmtadj := gmtadj negated ].				].	ts := Timestamp new fromDate: ( Date newDay: da monthNumber: mo year: yr ).	ts := ts addSeconds: ( hr * 3600 ) + ( mn * 60 ) + se.	ts := ts addMilliseconds: ms.	( ( gmtadj := ( gmtoff - gmtadj ) * 3600 ) negative )		ifTrue:	[ ts := ts subtractSeconds: gmtadj abs ]		ifFalse:	[ ts := ts addSeconds: gmtadj ].	^ts</body><body package="ASN1" selector="decodeINTEGER:">decodeINTEGER: anInteger	"Pick off the first octet.  Test for a negative.  Pick off the remaining octets.  Finish off if negative."	| oct val negative m |	val := 0.	oct := self next.	negative := oct allMask: 2r10000000.	val := oct.	( anInteger - 1 ) timesRepeat:			[	oct := self next.				val := ( val bitShift: 8 ) + oct			].	( negative )		ifTrue:	[	val := val - 2r00000001.					m := ( 2 raisedTo: ( 8 * val digitLength ) ) - 1.					val := val bitXor: m.					val := val negated.				].	^val</body><body package="ASN1" selector="decodeNULL:">decodeNULL: anInteger	^nil</body><body package="ASN1" selector="decodeOBJECT_IDENTIFIER:">decodeOBJECT_IDENTIFIER: anInteger	"Record the starting position, so that the encoding may be cached if necessary. Estimate the size assuming that two OID elements are encoded in the first byte and that all subsequent OID elements consume only one byte.  Then read.  (The first two branch identifiers are packed into the first octet.  Some of the decoding logic is repetative, but I'd rather inline.)  Trim the array if necessary when done.  Preserve object identity.  Then, always cache the encoding if we do not already have it."	| ipos estimatedSize reads size array val id oct oid tpos enc |	ipos := self position.	estimatedSize := anInteger + 1.	reads := 0.	size := 0.		array := Array new: estimatedSize.	val := 0.	[ reads := reads + 1. ( oct := self next ) &gt; 127 ]		whileTrue:	[ val := ( val bitShift: 7 ) + ( oct bitAnd: 02r1111111 ) ].	val := ( val bitShift: 7 ) + oct.	size := size + 1.	array at: size put: val // 40.	( ( id := val rem: 40 ) ~~ 0 )		ifTrue:	[ size := size + 1. array at: size put: id ].	[ anInteger &gt; reads ]		whileTrue:	[	val := 0.						[ reads := reads + 1. ( oct := self next ) &gt; 127 ]							whileTrue:	[ val := ( val bitShift: 7 ) + ( oct bitAnd: 02r1111111 ) ].						val := ( val bitShift: 7 ) + oct.						size := size + 1.						array at: size put: val					].	array := self trimCollection: array ofSize: estimatedSize toSize: size.	oid := Asn1OID value: array.		"--- creation method preserves object identity ---"	( oid encoding isNil )		ifTrue:	[	tpos := self position.					self position: ipos.					enc := self							next: ( tpos - ipos )							into: ( ByteArray new: ( tpos - ipos ) )							startingAt: 1.					oid encoding: enc.					self position: tpos				].	^oid</body><body package="ASN1" selector="decodeOCTET_STRING:">decodeOCTET_STRING: anInteger	| ba  |	ba := ByteArray new: anInteger.	1 to: anInteger do: [ :x | ba at: x put: self next ].	^ba</body><body package="ASN1" selector="decodeSEQUENCEorSEQUENCE_OF:">decodeSEQUENCEorSEQUENCE_OF: anInteger	"Note that we use a higher than usual default estimate for the size of the OrderedCollection." 	| col tpos |	col := OrderedCollection new: 11.	tpos := self position + anInteger.	[ self position &lt; tpos ]		whileTrue: [ col add: self decodeTLV ].	^col</body><body package="ASN1" selector="decodeSETorSET_OF:">decodeSETorSET_OF: anInteger	"Note that we use a higher than usual default estimate for the size of the OrderedCollection." 	| col tpos |	col := OrderedCollection new: 11.	tpos := self position + anInteger.	[ self position &lt; tpos ]		whileTrue: [ col add: self decodeTLV ].	^col</body><body package="ASN1" selector="decodeUnknownType:">decodeUnknownType: anInteger	| ba  |	ba := ByteArray new: anInteger.	1 to: anInteger do: [ :x | ba at: x put: self next ].	^Asn1TypeWrapper		encoding: ba		type: Asn1TypeUnknown default		value: nil</body><body package="ASN1" selector="decodeUTCTime:">decodeUTCTime: anInteger	"Note that we go out of our way to raise an exception for a UTCTime encoding without a terminal 'Z' or offset."	| ts str pk yr mo da hr mn se gmtoff gmtadj |	ts := Timestamp new.	str := ReadStream on: ( self decodeVisibleString: anInteger ).	yr := ( str next: 2 ) asNumber.	yr := self resolveUTCYear: yr.	mo := ( str next: 2 ) asNumber.	da := ( str next: 2 ) asNumber.	hr := ( str atEnd not and: [ str peek isDigit ] )			ifTrue:	[ ( str next: 2 ) asNumber ]			ifFalse:	[ 0 ].	mn := ( str atEnd not and: [ str peek isDigit ] )			ifTrue:	[ ( str next: 2 ) asNumber ]			ifFalse:	[ 0 ].	se := ( str atEnd not and: [ str peek isDigit ] )			ifTrue:	[ ( str next: 2 ) asNumber ]			ifFalse:	[ 0 ].	gmtoff := TimeZone reference secondsFromGMT / 3600.0.	( str atEnd )		ifTrue:	[	Asn1ExcMarshaling raiseSignal: (#invalidUTCTimeEncoding &lt;&lt; #opentalk &gt;&gt; 'Invalid UTCTime encoding!')				].	( ( str atEnd ) not and: [ ( pk := str peek ) = $Z ] )		ifTrue:	[	gmtadj := 0.				].	( str atEnd not and: [ ( pk := str peek ) = $- or: [ pk = $+ ] ] )		ifTrue:	[	str skip: 1.					gmtadj := ( str next: 2 ) asNumber + ( ( str next: 2 ) asNumber / 60.0 ).					( pk = $- )						ifTrue:	[ gmtadj := gmtadj negated ].				].	ts := Timestamp new fromDate: ( Date newDay: da monthNumber: mo year: yr ).	ts := ts addSeconds: ( hr * 3600 ) + ( mn * 60 ) + se.	( ( gmtadj := ( gmtoff - gmtadj ) * 3600 ) negative )		ifTrue:	[ ts := ts subtractSeconds: gmtadj abs ]		ifFalse:	[ ts := ts addSeconds: gmtadj ].	^ts</body><body package="ASN1" selector="decodeVisibleString:">decodeVisibleString: anInteger	"... equals 'decodeOCTET_STRING:'."	| ba  |	ba := ByteArray new: anInteger.	1 to: anInteger do: [ :x | ba at: x put: self next ].	^ba asString</body></methods><methods><class-id>ASN1.Asn1StreamBERBasic</class-id> <category>encoding - tagged types</category><body package="ASN1" selector="encodeBOOLEAN:">encodeBOOLEAN: aBoolean	"... use the primitive form for 'true' that is optional for BER but required by DER."	( aBoolean )		ifTrue:	[ self nextPut: 02r11111111 ]		ifFalse:	[ self nextPut: 02r00000000 ]</body><body package="ASN1" selector="encodeENUMERATED:">encodeENUMERATED: anIntegerOrAsn1ImportedEnumerated	"Note that ENUMERATEDs may use negative integers and that 'Asn1ImportedEnumerated&gt;&gt;value' is assumed to return anInteger."	self encodeINTEGER: anIntegerOrAsn1ImportedEnumerated value</body><body package="ASN1" selector="encodeGeneralizedTime:">encodeGeneralizedTime: aTimestamp	"We always go for the longest, most specific form.  A GeneralizedTime is unlikely to exceed 23 characters."	"In encoding, [1] a dot is used rather a comma, and [2] there are no meaningless zeros written for fractions of a second.  These practices are optional under BER but required under DER."	| str mo da hr mn se ms sf gmtoff hroff mnoff |	str := WriteStream on: ( ByteString new: 23 ).	str nextPutAll: aTimestamp year printString.	( ( mo := aTimestamp month printString ) size == 1 )		ifTrue:	[ str nextPut: $0 ].	str nextPutAll: mo.	( ( da := aTimestamp day printString ) size == 1 )		ifTrue:	[ str nextPut: $0 ].	str nextPutAll: da.	( ( hr := aTimestamp hour printString ) size == 1 )		ifTrue:	[ str nextPut: $0 ].	str nextPutAll: hr.	( ( mn := aTimestamp minute printString ) size == 1 )		ifTrue:	[ str nextPut: $0 ].	str nextPutAll: mn.	( ( se := aTimestamp second printString ) size == 1 )		ifTrue:	[ str nextPut: $0 ].	str nextPutAll: se.	( ( ms := aTimestamp millisecond ) == 0 )		ifFalse:	[	sf := ( ms / 1000.0 ) printString.					str nextPutAll: ( sf copyFrom: 2 to: sf size )				].	gmtoff := TimeZone reference secondsFromGMT / 3600.0.	( gmtoff == 0 )		ifTrue:	[	str nextPut: $Z				]		ifFalse:	[	str nextPut: ( ( gmtoff negative )									ifTrue:	[ $- ]									ifFalse:	[ $+ ] ).					( ( hroff := gmtoff truncated abs printString ) size == 1 )						ifTrue:	[ str nextPut: $0 ].					str nextPutAll: hroff.					( ( mnoff := ( gmtoff fractionPart * 60 ) truncated printString ) size == 1 )						ifTrue:	[ str nextPut: $0 ].					str nextPutAll: mnoff				].	self encodeVisibleString: str contents</body><body package="ASN1" selector="encodeINTEGER:">encodeINTEGER: anInteger	"Note the test using 'allMask:'.  If a positive integer's high order bit is 1, an all-zero octet is written. If a negative integer's high order bit is 1, we extend the size of the mask to get the correct two's complement."	"((( ( Asn1StreamBER on: ( ByteArray new: 2 ) ) encodeINTEGER: 27066 )))"	"((( ( Asn1StreamBER on: ( ByteArray new: 2 ) ) encodeINTEGER: -27066 )))"	| n l m |	n := anInteger.	l := n digitLength.	( n negative )		ifTrue:	[	( ( n digitAt: l ) allMask: 2r10000000 )						ifTrue: [ l := l + 1 ].					m := ( 2 raisedTo: ( 8 * l ) ) - 1.					n := ( anInteger bitXor: m abs ) + 2r00000001.			 	]		ifFalse:	[	( ( n digitAt: l ) allMask: 2r10000000 )						ifTrue: [ self nextPut: 0 ]				].	n digitLength to: 1 by: -1 do: 		[ :ndx | self nextPut: ( n digitAt: ndx ) ]</body><body package="ASN1" selector="encodeNULL">encodeNULL	"Do nothing.  An ASN.1 NULL is encoded solely by its tag."</body><body package="ASN1" selector="encodeOBJECT_IDENTIFIER:">encodeOBJECT_IDENTIFIER: anAsn1ImportedOID	"Check for a stored encoding.  ....."	| enc ipos val tpos |	"--- write out the stored encoding if possible ---"	( ( enc := anAsn1ImportedOID encoding ) notNil )		ifTrue:	[ ^self nextPutAll: enc ].	"--- otherwise, do the work ---"	ipos := self position.	val := anAsn1ImportedOID value.	"--- first two arcs encoded in first byte ---"	self nextPut: ( ( val at: 1 ) * 40 + ( val at: 2 ) ).	"--- subsequent arcs encoded one per byte ---"	3 to: val size do:		[ :ndx |	| int bitndx places |				int := val at: ndx.				bitndx := int highBit.				places := bitndx // 7.				( places * 7 ) to: 2 by: -7 do: 					[ :pla |	| nib |							nib := ( int bitAnd: ( 02r1111111 bitShift: pla ) ) 									bitShift: pla negated.							self nextPut: ( nib bitOr: 02r10000000 ) 					].				self nextPut: ( int bitAnd: 02r1111111 )		].	"--- store encoding ---"	tpos := self position.	self position: ipos.	enc := self			next: ( tpos - ipos )			into: ( ByteArray new: ( tpos - ipos ) )			startingAt: 1.	anAsn1ImportedOID encoding: enc.	self position: tpos</body><body package="ASN1" selector="encodeOCTET_STRING:">encodeOCTET_STRING: anObject	anObject asByteArray do: [ :x | self nextPut: x ]</body><body package="ASN1" selector="encodeSEQUENCEorSEQUENCE_OF:">encodeSEQUENCEorSEQUENCE_OF: aSequenceableCollection	"Note that this method is used when there is no 'type-in-hand'.  Marshaling without type information is dangerous and error-prone in the case of SEQUENCEs, which may contain objects of multiple types, OPTIONAL values, EXTENSION markers, and DEFAULT values that a receiver is expected to fill in if they have not been transmitted."	aSequenceableCollection do: [ :o | self encodeTLV: o ].</body><body package="ASN1" selector="encodeSETorSET_OF:">encodeSETorSET_OF: aBag	"Note that this method is used when there is no 'type-in-hand'. Marshaling without type information is dangerous and error-prone in the case of SETs, which may contain objects of multiple types transmitted in arbitrary order, OPTIONAL values, EXTENSION markers, and DEFAULT values that a receiver is expected to fill in if they have not been transmitted."	aBag do: [ :o | self encodeTLV: o ].</body><body package="ASN1" selector="encodeUTCTime:">encodeUTCTime: aTimestamp	"We always go for the longest, most specific form.  A UTCTime is unlikely to exceed 17 characters."	| str mo da hr mn se gmtoff hroff mnoff |	str := WriteStream on: ( ByteString new: 17 ).	str nextPutAll: ( aTimestamp year printString copyFrom: 3 to: 4 ).	( ( mo := aTimestamp month printString ) size == 1 )		ifTrue:	[ str nextPut: $0 ].	str nextPutAll: mo.	( ( da := aTimestamp day printString ) size == 1 )		ifTrue:	[ str nextPut: $0 ].	str nextPutAll: da.	( ( hr := aTimestamp hour printString ) size == 1 )		ifTrue:	[ str nextPut: $0 ].	str nextPutAll: hr.	( ( mn := aTimestamp minute printString ) size == 1 )		ifTrue:	[ str nextPut: $0 ].	str nextPutAll: mn.	( ( se := ( aTimestamp second + ( aTimestamp millisecond / 1000 ) rounded ) printString ) size == 1 )		ifTrue:	[ str nextPut: $0 ].	str nextPutAll: se.	gmtoff := TimeZone reference secondsFromGMT / 3600.0.	( gmtoff == 0 )		ifTrue:	[	str nextPut: $Z				]		ifFalse:	[	str nextPut: ( ( gmtoff negative )									ifTrue:	[ $- ]									ifFalse:	[ $+ ] ).					( ( hroff := gmtoff truncated abs printString ) size == 1 )						ifTrue:	[ str nextPut: $0 ].					str nextPutAll: hroff.					( ( mnoff := ( gmtoff fractionPart * 60 ) truncated printString ) size == 1 )						ifTrue:	[ str nextPut: $0 ].					str nextPutAll: mnoff				].	self encodeVisibleString: str contents</body><body package="ASN1" selector="encodeVisibleString:">encodeVisibleString: aByteString	"... equals 'encodeOCTET_STRING:'."	aByteString asByteArray do: [ :x | self nextPut: x ]</body></methods><methods><class-id>ASN1.Asn1StreamBERBasic</class-id> <category>decoding - utility</category><body package="ASN1" selector="raiseTagMismatchException">raiseTagMismatchException	Asn1ExcMarshaling		raiseSignal: (#TagMismatchUnderTypeInHandDecoding &lt;&lt; #opentalk &gt;&gt; 'Tag mismatch under type-in-hand decoding!')</body><body package="ASN1" selector="raiseUnknownTagException">raiseUnknownTagException	 Asn1ExcUnknownTag 		raiseRequestErrorString: (#unknownTag &lt;&lt; #opentalk &gt;&gt; 'Unknown tag!')</body><body package="ASN1" selector="resolveUTCYear:">resolveUTCYear: anInteger	"... in effect, this resolves the year on the basis of the proposal of the ITU-T working group on the X.400 email proposal, mentioned in Dubuisson's 'ASN.1' on pp. 203-204 as rule &lt;7&gt;."	| curYear curCent lcy ccy ncy yr |	curYear := Date today year.	curCent := ( curYear / 100.0 ) truncated * 100.	lcy := ( curCent - 100 ) + anInteger.	ccy := curCent + anInteger.	ncy := ( curCent + 100 ) + anInteger.	yr := ( ( ( lcy - curYear ) abs ) &gt; ( ( ccy - curYear ) abs )  )			ifTrue:	[ ccy ]			ifFalse:	[ lcy ].	yr := ( ( ( yr - curYear ) abs ) &gt;= ( ( ncy - curYear ) abs ) )			ifTrue:	[ ncy ]			ifFalse:	[ yr ].	^yr</body><body package="ASN1" selector="tagDispatchWith:">tagDispatchWith: anInteger	"... might be re-rigged as a proceedable exception."	^[ self class tagDispatchTable at: anInteger ]		on: SubscriptOutOfBoundsError		do: [ :ex | self raiseUnknownTagException ]</body><body package="ASN1" selector="trimCollection:ofSize:toSize:">trimCollection: aCollection ofSize: anInteger1 toSize: anInteger2	^( anInteger1 &gt; anInteger2 )		ifTrue:	[ aCollection copyFrom: 1 to: anInteger2 ]		ifFalse:	[ aCollection ]</body></methods><methods><class-id>ASN1.Asn1StreamBERBasic</class-id> <category>decoding - api</category><body package="ASN1" selector="asTag:">asTag: anInteger	"... a tag-related utility invoked in decoding APIs."	"... if required, masks anInteger, as required by the tag matching scheme in effect."	"... use constant to avoid namespace lookup."	^anInteger bitAnd: 02r00011111 "ASN1.TagMaskNumber"</body><body package="ASN1" selector="decodeTLV">decodeTLV	"... a recursive entry point, not to be invoked without 'local knowledge'."	"... a restricted BER decoding entry point, suitable for use with SNMP because single octet tags and three byte definite lengths are assumed."	^( self tagDispatchWith: self nextTag )		value: self nextLength		value: self</body><body package="ASN1" selector="decodeTLV_Type:">decodeTLV_Type: anAsn1Type	"... a recursive entry point, not to be invoked without 'local knowledge'."	"... a restricted BER decoding entry point, suitable for use with SNMP because single octet tags and three byte definite lengths are assumed."	( anAsn1Type class == Asn1TypeCHOICE )		ifTrue:	[ ^self decodeTLV_Choice: anAsn1Type ].	( anAsn1Type class == Asn1TypeANY )		ifTrue:	[ ^self decodeTLV_Any: anAsn1Type ].	^self decodeTLV_Normal: anAsn1Type</body><body package="ASN1" selector="nextLength">nextLength	"... the method to be directly invoked in decoding APIs."	^self next3OctetDefiniteLength</body><body package="ASN1" selector="nextTag">nextTag	"... the method to be directly invoked in decoding APIs."	^self nextOctetTagMasked</body><body package="ASN1" selector="unmarshalObject">unmarshalObject	"... the default, top-level, decoding entry point, for type-agnostic decoding."	^[ self decodeTLV ]		on:	Error		do:	[ :ex | Asn1ExcMarshaling raiseSignal: ex errorString ]</body><body package="ASN1" selector="unmarshalObjectType:">unmarshalObjectType: anAsn1Type	"... the default, top-level, entry point for type-in-hand decoding."	^[ self decodeTLV_Type: anAsn1Type ]		on:	Error		do:	[ :ex | Asn1ExcMarshaling raiseSignal: ex errorString ]</body></methods><methods><class-id>ASN1.Asn1StreamBERBasic</class-id> <category>decoding - private</category><body package="ASN1" selector="checkChoiceTagMatchOf:and:">checkChoiceTagMatchOf: anAsn1TypeCHOICE and: anInteger	( ( anAsn1TypeCHOICE tags collect: [ :t | self asTag: t ] )		includes: anInteger )			ifFalse:	[ self raiseTagMismatchException ]</body><body package="ASN1" selector="checkNormalTagMatchOf:and:">checkNormalTagMatchOf: anAsn1ElementOrAsn1Type and: anInteger	( ( self asTag: anAsn1ElementOrAsn1Type tagBER ) ~~ anInteger )		ifTrue:	[ self raiseTagMismatchException ]</body><body package="ASN1" selector="decodeLV_Element:">decodeLV_Element: anAsn1Element	^( anAsn1Element isExplicit )		ifTrue:	[ self decodeLV_ExplicitType: anAsn1Element type ]		ifFalse:	[ self decodeLV_ImplicitType: anAsn1Element type ]</body><body package="ASN1" selector="decodeLV_ExplicitType:">decodeLV_ExplicitType: anAsn1Type	self nextLength.	^self decodeTLV_Type: anAsn1Type.</body><body package="ASN1" selector="decodeLV_ImplicitType:">decodeLV_ImplicitType: anAsn1Type	^anAsn1Type		decode: self nextLength		with: self</body><body package="ASN1" selector="decodeTLV_Any:">decodeTLV_Any: anAsn1TypeANY	"... for ANY types only."	^self decodeTLV</body><body package="ASN1" selector="decodeTLV_Choice:">decodeTLV_Choice: anAsn1TypeCHOICE	"... for CHOICE types only."	| tag ele typ |	self		checkChoiceTagMatchOf: anAsn1TypeCHOICE		and: ( tag := self nextTag ).	ele := anAsn1TypeCHOICE elementWithTag: tag.	typ := ele type.	^typ 		decode: self nextLength		with: self</body><body package="ASN1" selector="decodeTLV_Element:">decodeTLV_Element: anAsn1Element	"... invoked only in the decoding of types containing Asn1Elements (SEQUENCES, SETS, and CHOICES)."	"... must be recursive."	| typ |	typ := anAsn1Element type.	( typ class == Asn1TypeCHOICE )		ifTrue:	[ ^self decodeTLV_Choice: typ ].	( typ class == Asn1TypeANY )		ifTrue:	[ ^self decodeTLV_Any: typ ].	^self decodeTLV_NormalElement: anAsn1Element</body><body package="ASN1" selector="decodeTLV_Normal:">decodeTLV_Normal: anAsn1Type	"... for non-ANY, non-CHOICE types."	self checkNormalTagMatchOf: anAsn1Type and: ( self nextTag ).	^anAsn1Type symbol -&gt; 		( anAsn1Type			decode: self nextLength			with: self )</body><body package="ASN1" selector="decodeTLV_NormalElement:">decodeTLV_NormalElement: anAsn1Element	| typ |	typ := anAsn1Element type.	self checkNormalTagMatchOf: typ and: ( self nextTag ).	^( anAsn1Element isExplicit )		ifTrue:	[ self decodeLV_ExplicitType: typ ]		ifFalse:	[ self decodeLV_ImplicitType: typ ]</body><body package="ASN1" selector="next3OctetDefiniteLength">next3OctetDefiniteLength	"... not to be invoked directly in decoding APIs."	"... reads and forgets the first octet, assumed to be '02r10000010', that is, decimal 2 with the long-form bit on, and then processes the next two octets."	self next.	^( self next bitShift: 8 ) + self next</body><body package="ASN1" selector="nextOctetTag">nextOctetTag	"... read a single octet tag."	"... not to be invoked directly in decoding APIs."	^self next</body><body package="ASN1" selector="nextOctetTagMasked">nextOctetTagMasked	"... read a single octet tag and masks the first three bits."	"... not to be invoked directly in decoding APIs."	^self asTag: self nextOctetTag</body></methods><methods><class-id>ASN1.Asn1StreamBERBasic</class-id> <category>encoding - private</category><body package="ASN1" selector="encode3ByteDefiniteLength:">encode3ByteDefiniteLength: anInteger	self nextPut: 02r10000010.	( anInteger digitLength == 2 )		ifTrue:	[ self nextPut: ( anInteger digitAt: 2 ) ]		ifFalse: [ self nextPut: 0 ].	self nextPut: ( anInteger digitAt: 1 )</body><body package="ASN1" selector="encodeTLV:withElement:">encodeTLV: anObject withElement: anAsn1Element	"... geared for the use of 3-octet definite lengths."	"... the intention, implemented via 'encodeV:withElement:', is, in the case of explicitly tagged elements, to produce an encoding with the following structure:		T = private tag		L = length 		(V =) 	T1 = universal tag				L1 = length1				V1 = value encoding	"	| lpos vpos |	self nextPutTagFrom: anAsn1Element.	lpos := self position.	self nextPutAll: #[ 0 0 0 ].  "skip: 3"	self encodeV: anObject withElement: anAsn1Element.	vpos := self position.	self position: lpos.	self encodeLength: vpos - lpos - 3.	self position: vpos</body><body package="ASN1" selector="encodeV:withElement:">encodeV: anObject withElement: anAsn1Element	"... effectively 'private', as far as ordinary use is concerned, yet invoked by one encoding method in Asn1ImportedChoice."	( anAsn1Element isExplicit )		ifTrue:	[ self encodeTLV: anObject withType: anAsn1Element type ]		ifFalse:	[ anAsn1Element type encode: anObject with: self ].</body></methods><methods><class-id>ASN1.Asn1StreamBERBasic</class-id> <category>encoding - lengths</category><body package="ASN1" selector="encodeLength:">encodeLength: anInteger	"... the method to be directly invoked in encoding methods."	self encode3ByteDefiniteLength: anInteger</body></methods><methods><class-id>ASN1.Asn1StreamBERBasic</class-id> <category>encoding - utility</category><body package="ASN1" selector="nextPutTagFrom:">nextPutTagFrom: anObject	"... should cover both SubclassResponsibilityError and MessageNotUnderstood."	"... assumes single-byte tags." 	[ self nextPut: anObject tagBER ]		on: SubclassResponsibilityError, MessageNotUnderstood		do: [ :ex | ex resignalAs: ( ( Asn1ExcMarshaling new )									messageText: (#typeNotMarshalableUnderASN1 &lt;&lt; #opentalk &gt;&gt; 'The type is not marshalable under ASN.1!');									parameter: ex parameter;									yourself ) ].</body></methods><methods><class-id>ASN1.Asn1StreamBERBasic</class-id> <category>encoding - api</category><body package="ASN1" selector="encodeTLV:">encodeTLV: anObject	"... a recursive entry point, not to be invoked without 'local knowledge'."	"... geared for the use of 3-octet definite lengths."	"... assumes anObject responds to both 'tagBER' and 'encodeASN1With:'."	| lpos vpos |	self nextPutTagFrom: anObject.	lpos := self position.	self nextPutAll: #[ 0 0 0 ].  "skip: 3"	anObject encodeASN1With: self.	vpos := self position.	self position: lpos.	self encodeLength: vpos - lpos - 3.	self position: vpos</body><body package="ASN1" selector="encodeTLV:withType:">encodeTLV: anObject withType: anAsn1Type	"... a recursive entry point, not to be invoked without 'local knowledge'."	"... geared for the use of 3-octet definite lengths."	"... implements some initial analysis in order to correctly process those few imported types that already include ASN.1 type information." 	"... sends 'encode:with:' to an ASN1Type."	| lpos vpos encodingManager |	encodingManager := ( anObject containsAsn1Type )							ifTrue:	[ anObject ]							ifFalse:	[ anAsn1Type ].	self nextPutTagFrom: encodingManager.	lpos := self position.	self nextPutAll: #[ 0 0 0 ].  "skip: 3"	encodingManager encode: anObject with: self.	vpos := self position.	self position: lpos.	self encodeLength: vpos - lpos - 3.	self position: vpos</body><body package="ASN1" selector="marshalObject:">marshalObject: anObject	"... the top-level entry point for type-agnostic encoding."	[ self encodeTLV: anObject ]		on:	Error		do:	[ :ex | Asn1ExcMarshaling raiseSignal: ex errorString ]</body><body package="ASN1" selector="marshalObject:withType:">marshalObject: anObject withType: anAsn1Type	"... the top-level entry point for type-in-hand encoding."	[ self encodeTLV: anObject withType: anAsn1Type ]		on:	Error		do:	[ :ex | Asn1ExcMarshaling raiseSignal: ex errorString ]</body></methods><methods><class-id>ASN1.Asn1StreamBERBasic</class-id> <category>testing</category><body package="ASN1" selector="requiresEncodingSort">requiresEncodingSort	^false</body><body package="ASN1" selector="requiresTagSort">requiresTagSort	^false</body></methods><methods><class-id>ASN1.Asn1StreamBERBasic class</class-id> <category>class initialization</category><body package="ASN1" selector="initialize">initialize	"((( self initialize )))"	super initialize</body><body package="ASN1" selector="initializeTagDispatchTable">initializeTagDispatchTable	"Initialize the tag table used for unmarshalling."	"((( self initializeTagDispatchTable )))"	self tagDispatchTable: ( Array new: 32 ).	self tagDispatchTable 		at: 1	put: [ :len :m | m decodeBOOLEAN: len ];		at: 2	put: [ :len :m | m decodeINTEGER: len ];		at: 3	put: [ :len :m | m decodeBIT_STRING: len ];		at: 4	put: [ :len :m | m decodeOCTET_STRING: len ];		at: 5	put: [ :len :m | m decodeNULL: len ];		at: 6	put: [ :len :m | m decodeOBJECT_IDENTIFIER: len ];		at: 7	put: [ :len :m | m decodeObjectDescriptor: len ];		at: 8	put: [ :len :m | m decodeEXTERNALorINSTANCE_OF: len ];		at: 9	put: [ :len :m | m decodeREAL: len ];		at: 10	put: [ :len :m | m decodeENUMERATED: len ];		at: 11	put: [ :len :m | m decodeEMBEDDED_PDV: len ];		at: 12	put: [ :len :m | m decodeUTF8String: len ];		at: 13	put: [ :len :m | m decodeRELATIVE_OID: len ];		"14=reserved for future use"		"15=reserved for future use"		at: 16	put: [ :len :m | m decodeSEQUENCEorSEQUENCE_OF: len ];		at: 17	put: [ :len :m | m decodeSETorSET_OF: len ];		at: 18	put: [ :len :m | m decodeNumericString: len ];		at: 19	put: [ :len :m | m decodePrintableString: len ];		at: 20	put: [ :len :m | m decodeTeletexStringOrT61String: len ];		at: 21	put: [ :len :m | m decodeVideotexString: len ];		at: 22	put: [ :len :m | m decodeIA5String: len ];		at: 23	put: [ :len :m | m decodeUTCTime: len ];		at: 24	put: [ :len :m | m decodeGeneralizedTime: len ];		at: 25	put: [ :len :m | m decodeGraphicString: len ];		at: 26	put: [ :len :m | m decodeVisibleStringOrISO646String: len ];		at: 27	put: [ :len :m | m decodeGeneralString: len ];		at: 28	put: [ :len :m | m decodeUniversalString: len ];		at: 29	put: [ :len :m | m decodeCHARACTER_STRING: len ];		at: 30	put: [ :len :m | m decodeBMPString: len ].		"31 ... = reserved for future use"</body></methods><methods><class-id>ASN1.Asn1StreamBERDefinite</class-id> <category>decoding - tagged types</category><body package="ASN1" selector="decodeBIT_STRING:">decodeBIT_STRING: anInteger	| r tpos |	tpos := self position + anInteger.	r := Asn1BitString			unused: self next			bytes: ( collection copyFrom:  position + 1 to: tpos ).	self position: tpos.	^r</body><body package="ASN1" selector="decodeIA5String:">decodeIA5String: anInteger	"... equals 'decodeOCTET_STRING:'."	"... this is provisional and incorrect."	| ba  |	ba := ByteArray new: anInteger.	1 to: anInteger do: [ :x | ba at: x put: self next ].	^ba asString</body><body package="ASN1" selector="decodeNumericString:">decodeNumericString: anInteger	"... equals 'decodeOCTET_STRING:'."	| ba  |	ba := ByteArray new: anInteger.	1 to: anInteger do: [ :x | ba at: x put: self next ].	^ba asString</body><body package="ASN1" selector="decodePrintableString:">decodePrintableString: anInteger	"... equals 'decodeOCTET_STRING:'."	| ba  |	ba := ByteArray new: anInteger.	1 to: anInteger do: [ :x | ba at: x put: self next ].	^ba asString</body><body package="ASN1" selector="decodeTeletexStringOrT61String:">decodeTeletexStringOrT61String: anInteger	"... equals 'decodeOCTET_STRING:'."	"... provisional implementation!"	| ba  |	ba := ByteArray new: anInteger.	1 to: anInteger do: [ :x | ba at: x put: self next ].	^ba asString</body><body package="ASN1" selector="decodeVisibleStringOrISO646String:">decodeVisibleStringOrISO646String: anInteger	"... equals 'decodeOCTET_STRING:'."	| ba  |	ba := ByteArray new: anInteger.	1 to: anInteger do: [ :x | ba at: x put: self next ].	^ba asString</body></methods><methods><class-id>ASN1.Asn1StreamBERDefinite</class-id> <category>encoding - tagged types</category><body package="ASN1" selector="encodeBIT_STRING:">encodeBIT_STRING: anAsn1ImportedBitString	"... only the primitive encoding."	( anAsn1ImportedBitString isEmpty )		ifTrue:	[	self nextPut: 0				]		ifFalse:	[	self nextPut: anAsn1ImportedBitString unused.					self nextPutAll: anAsn1ImportedBitString bytes				]</body><body package="ASN1" selector="encodeIA5String:">encodeIA5String: aByteString	"... equals 'encodeOCTET_STRING:'."	"... this is provisional and incorrect."	aByteString asByteArray do: [ :x | self nextPut: x ]</body><body package="ASN1" selector="encodeNumericString:">encodeNumericString: aByteString	"... equals 'encodeOCTET_STRING:'."	aByteString asByteArray do: [ :x | self nextPut: x ]</body><body package="ASN1" selector="encodePrintableString:">encodePrintableString: aByteString	"... equals 'encodeOCTET_STRING:'."	aByteString asByteArray do: [ :x | self nextPut: x ]</body><body package="ASN1" selector="encodeVisibleStringOrISO646String:">encodeVisibleStringOrISO646String: aByteString	"... equals 'encodeOCTET_STRING:'."	aByteString asByteArray do: [ :x | self nextPut: x ]</body></methods><methods><class-id>ASN1.Asn1StreamBERDefinite</class-id> <category>decoding - api</category><body package="ASN1" selector="nextLength">nextLength	"... the method to be directly invoked in decoding APIs."	^self nextDefiniteLength.</body><body package="ASN1" selector="nextTag">nextTag	"... the method to be directly invoked in decoding APIs."	^self nextGenericTag</body><body package="ASN1" selector="unmarshalObject">unmarshalObject	"... the default, top-level, decoding entry point, for type-agnostic decoding."	^[ self decodeTLV		]	on:	Error			do:	[ :ex | Asn1ExcMarshaling raiseSignal: ex errorString ]</body><body package="ASN1" selector="unmarshalObjectType:">unmarshalObjectType: anAsn1Type	"... the default, top-level, entry point for type-in-hand decoding."	^[ self decodeTLV_Type: anAsn1Type		]	on:	Error			do:	[ :ex | Asn1ExcMarshaling raiseSignal: ex errorString ]</body></methods><methods><class-id>ASN1.Asn1StreamBERDefinite</class-id> <category>decoding - private</category><body package="ASN1" selector="decodeLV_ExplicitType:">decodeLV_ExplicitType: anAsn1Type	self nextLength.	^self decodeTLV_Type: anAsn1Type</body><body package="ASN1" selector="decodeLV_ImplicitType:">decodeLV_ImplicitType: anAsn1Type	^anAsn1Type		decode: self nextLength		with: self</body><body package="ASN1" selector="decodeTLV_Choice:">decodeTLV_Choice: anAsn1TypeCHOICE	"... for CHOICE types only."	| tag ele typ |	tag  := self nextTag.	self checkChoiceTagMatchOf: anAsn1TypeCHOICE and: tag.	ele := anAsn1TypeCHOICE elementWithTag: tag.	typ := ele type.	^typ decode: self nextLength with: self</body><body package="ASN1" selector="decodeTLV_Normal:">decodeTLV_Normal: anAsn1Type	"... for non-CHOICE types."	| tag |	tag  := self nextTag.	self checkNormalTagMatchOf: anAsn1Type and: tag.	^anAsn1Type decode: self nextLength with: self</body><body package="ASN1" selector="nextDefiniteLength">nextDefiniteLength	| oct val |	^( ( oct := self next ) anyMask: 2r10000000 )		ifTrue:	[	val := 0.					( oct maskClear: 2r10000000 ) 						timesRepeat:	[ val := ( val bitShift: 8 ) + self next ].					val 				]		ifFalse:	[ oct ]</body><body package="ASN1" selector="nextGenericTag">nextGenericTag	"... read a single or multiple octet tag."	"... not to be invoked directly in decoding APIs."	"... assumes that we do not need to represent the tag class or form."	| oct1 numberPart oct tag |	oct1 := self next.	( ( numberPart := self asTag: oct1 ) == 31 )			"--- single-octet tag ---"		ifFalse:	[ 	^numberPart				]			"--- multi-octet tag ---"		ifTrue:	[	tag := 0.					[	tag := tag bitShift: 7.						oct := self next.						tag := tag bitOr: ( oct maskClear: 2r10000000 ).					]	whileTrue:							[ oct anyMask: 2r10000000 ].					^tag				]</body><body package="ASN1" selector="nextShortDefiniteLength">nextShortDefiniteLength	^self next</body></methods><methods><class-id>ASN1.Asn1StreamBERDefinite</class-id> <category>accessing</category><body package="ASN1" selector="scratchBuffer">scratchBuffer	^( scratchBuffer isNil )		ifTrue:	[ scratchBuffer := ReadWriteStream on: ( ByteArray new: 64 ) ]		ifFalse:	[ scratchBuffer ]</body></methods><methods><class-id>ASN1.Asn1StreamBERDefinite</class-id> <category>encoding - private</category><body package="ASN1" selector="encodeDefiniteLength:">encodeDefiniteLength: anInteger	( anInteger &gt; 127 )		ifTrue:	[	self nextPut: ( 2r10000000 bitOr: anInteger digitLength ).					anInteger digitLength 						to: 1 						by: -1 						do: [ :idx | self nextPut: ( anInteger digitAt: idx ) ].				]		ifFalse: [ self nextPut: anInteger]</body><body package="ASN1" selector="encodeDefiniteLength:on:">encodeDefiniteLength: anInteger on: aWriteStream	( anInteger &gt; 127 )		ifTrue:	[	aWriteStream nextPut: ( 2r10000000 bitOr: anInteger digitLength ).					anInteger digitLength 						to: 1 						by: -1 						do: [ :idx | aWriteStream nextPut: ( anInteger digitAt: idx ) ].					aWriteStream contents				]		ifFalse: [ aWriteStream nextPut: anInteger].	^aWriteStream</body><body package="ASN1" selector="encodeTLV:withElement:">encodeTLV: anObject withElement: anAsn1Element	"... geared for the use of 3-octet definite lengths."	"... the intention, implemented via 'encodeV:withElement:', is, in the case of explicitly tagged elements, to produce an encoding with the following structure:		T = private tag		L = length 		(V =) 	T1 = universal tag				L1 = length1				V1 = value encoding	"	| lpos vpos len |	self nextPutTagFrom: anAsn1Element.	lpos := self position.	self nextPut: 0.  "skip: 1"	self encodeV: anObject withElement: anAsn1Element.	vpos := self position.	len := vpos - lpos - 1.	( len &lt;= 127 )		ifTrue:	[		self position: lpos.						self encodeDefiniteLength: len.						self position: vpos				]		ifFalse:	[	| inc |					self scratchBuffer reset.					self encodeDefiniteLength: len on: scratchBuffer.					inc := scratchBuffer position - 1.					self						shift: inc						from: lpos + 2						to: vpos.					self position: lpos.					scratchBuffer contents do: [ :x | self nextPut: x ].					self position: vpos + inc				]</body><body package="ASN1" selector="shift:from:to:">shift: increment from: start to: end	collection		replaceFrom: start + increment		to: end + increment		with: collection		startingAt: start.	readLimit := end + increment max: readLimit</body></methods><methods><class-id>ASN1.Asn1StreamBERDefinite</class-id> <category>encoding - lengths</category><body package="ASN1" selector="encodeLength:">encodeLength: anInteger	"... the method to be directly invoked in encoding methods."	"... intended to accord with the DER requirement that lengths be encoded in the minimum number of octets."	self encodeDefiniteLength: anInteger</body></methods><methods><class-id>ASN1.Asn1StreamBERDefinite</class-id> <category>protocol compatibility</category><body package="ASN1" selector="beginEncodings">beginEncodings	"... intentionally null."</body></methods><methods><class-id>ASN1.Asn1StreamBERDefinite</class-id> <category>encoding - api</category><body package="ASN1" selector="encodeTLV:">encodeTLV: anObject	"... a recursive entry point, not to be invoked without 'local knowledge'."	"... hopes for a 1-octet definite length and plays costly copying games otherwise."	"... assumes anObject responds to both 'tagBER' and 'encodeASN1With:'."	| lpos vpos len |	self nextPutTagFrom: anObject.	lpos := self position.	self nextPut: 0.	"skip: 1"	anObject encodeASN1With: self.	vpos := self position.	len := vpos - lpos - 1.	( len &lt;= 127 )		ifTrue:	[		self position: lpos.						self encodeDefiniteLength: len.						self position: vpos				]		ifFalse:	[	| inc |					self scratchBuffer reset.					self encodeDefiniteLength: len on: scratchBuffer.					inc := scratchBuffer position - 1.					self						shift: inc						from: lpos + 2						to: vpos.					self position: lpos.					scratchBuffer contents do: [ :x | self nextPut: x ].					self position: vpos + inc				]</body><body package="ASN1" selector="encodeTLV:withType:">encodeTLV: anObject withType: anAsn1Type	"... a recursive entry point, not to be invoked without 'local knowledge'."	"... hopes for a 1-octet definite length and plays costly copying games otherwise."	"... implements some initial analysis in order to correctly process those few imported types that already include ASN.1 type information." 	"... sends 'encode:with:' to an ASN1Type."	| lpos vpos encodingManager len |	encodingManager := ( anObject containsAsn1Type )							ifTrue:	[ anObject ]							ifFalse:	[ anAsn1Type ].	self nextPutTagFrom: encodingManager.	lpos := self position.	self nextPut: 0.  "skip: 1"	encodingManager encode: anObject with: self.	vpos := self position.	len := vpos - lpos - 1.	( len &lt;= 127 )		ifTrue:	[		self position: lpos.						self encodeDefiniteLength: len.						self position: vpos				]		ifFalse:	[	| inc |					self scratchBuffer reset.					self encodeDefiniteLength: len on: scratchBuffer.					inc := scratchBuffer position - 1.					self						shift: inc						from: lpos + 2						to: vpos.					self position: lpos.					scratchBuffer contents do: [ :x | self nextPut: x ].					self position: vpos + inc				]</body></methods><methods><class-id>ASN1.Asn1StreamBERDefinite</class-id> <category>decoding - unimplemented</category><body package="ASN1" selector="decodeBMPString:">decodeBMPString: anInteger	self error: (#notImplementedInThisRelease &lt;&lt; #opentalk &gt;&gt; 'This function has not been implemented in this release.')</body><body package="ASN1" selector="decodeCHARACTER_STRING:">decodeCHARACTER_STRING: anInteger	self error: (#notImplementedInThisRelease &lt;&lt; #opentalk &gt;&gt; 'This function has not been implemented in this release.')</body><body package="ASN1" selector="decodeEMBEDDED_PDV:">decodeEMBEDDED_PDV: anInteger	self error: (#notImplementedInThisRelease &lt;&lt; #opentalk &gt;&gt; 'This function has not been implemented in this release.')</body><body package="ASN1" selector="decodeEXTERNALorINSTANCE_OF:">decodeEXTERNALorINSTANCE_OF: anInteger	self error: (#notImplementedInThisRelease &lt;&lt; #opentalk &gt;&gt; 'This function has not been implemented in this release.')</body><body package="ASN1" selector="decodeGeneralString:">decodeGeneralString: anInteger	self error: (#notImplementedInThisRelease &lt;&lt; #opentalk &gt;&gt; 'This function has not been implemented in this release.')</body><body package="ASN1" selector="decodeGraphicString:">decodeGraphicString: anInteger	self error: (#notImplementedInThisRelease &lt;&lt; #opentalk &gt;&gt; 'This function has not been implemented in this release.')</body><body package="ASN1" selector="decodeObjectDescriptor:">decodeObjectDescriptor: anInteger	self error: (#notImplementedInThisRelease &lt;&lt; #opentalk &gt;&gt; 'This function has not been implemented in this release.')</body><body package="ASN1" selector="decodeREAL:">decodeREAL: anInteger	"... going for Doubles when possible."	"--- zero is encoded as a REAL of zero length ---"	( anInteger = 0 )		ifTrue:	[ ^Double zero ].	self error: (#notImplementedInThisRelease &lt;&lt; #opentalk &gt;&gt; 'This function has not been implemented in this release.')</body><body package="ASN1" selector="decodeRELATIVE_OID:">decodeRELATIVE_OID: anInteger	self error: (#notImplementedInThisRelease &lt;&lt; #opentalk &gt;&gt; 'This function has not been implemented in this release.')</body><body package="ASN1" selector="decodeUniversalString:">decodeUniversalString: anInteger	self error: (#notImplementedInThisRelease &lt;&lt; #opentalk &gt;&gt; 'This function has not been implemented in this release.')</body><body package="ASN1" selector="decodeUTF8String:">decodeUTF8String: anInteger	self error: (#notImplementedInThisRelease &lt;&lt; #opentalk &gt;&gt; 'This function has not been implemented in this release.')</body><body package="ASN1" selector="decodeVideotexString:">decodeVideotexString: anInteger	self error: (#notImplementedInThisRelease &lt;&lt; #opentalk &gt;&gt; 'This function has not been implemented in this release.')</body></methods><methods><class-id>ASN1.Asn1StreamBERDefinite</class-id> <category>encoding - unimplemented</category><body package="ASN1" selector="encodeBMPString:">encodeBMPString: anObject	self error: (#notImplementedInThisRelease &lt;&lt; #opentalk &gt;&gt; 'This function has not been implemented in this release.')</body><body package="ASN1" selector="encodeCHARACTER_STRING:">encodeCHARACTER_STRING: anObject	self error: (#notImplementedInThisRelease &lt;&lt; #opentalk &gt;&gt; 'This function has not been implemented in this release.')</body><body package="ASN1" selector="encodeEMBEDDED_PDV:">encodeEMBEDDED_PDV: anObject	self error: (#notImplementedInThisRelease &lt;&lt; #opentalk &gt;&gt; 'This function has not been implemented in this release.')</body><body package="ASN1" selector="encodeEXTERNALorINSTANCE_OF:">encodeEXTERNALorINSTANCE_OF: anObject	self error: (#notImplementedInThisRelease &lt;&lt; #opentalk &gt;&gt; 'This function has not been implemented in this release.')</body><body package="ASN1" selector="encodeGeneralString:">encodeGeneralString: anObject	self error: (#notImplementedInThisRelease &lt;&lt; #opentalk &gt;&gt; 'This function has not been implemented in this release.')</body><body package="ASN1" selector="encodeObjectDescriptor:">encodeObjectDescriptor: anObject	self error: (#notImplementedInThisRelease &lt;&lt; #opentalk &gt;&gt; 'This function has not been implemented in this release.')</body><body package="ASN1" selector="encodeREAL:">encodeREAL: anObject	"--- zero is encoded as a REAL of zero length ---"	( anObject = 0 )		ifTrue:	[ ^nil ].	"--- fixed representations for positive and negative infinity ---"	( #{Infinity} isDefined )		ifTrue:	[	( anObject == Infinity positive )						ifTrue:	[ ^self nextPut: 02r01000000 ].					( anObject == Infinity negative )						ifTrue:	[ ^self nextPut: 02r01000001 ].				].	self error: (#notImplementedInThisRelease &lt;&lt; #opentalk &gt;&gt; 'This function has not been implemented in this release.')</body><body package="ASN1" selector="encodeRELATIVE_OID:">encodeRELATIVE_OID: anObject	self error: (#notImplementedInThisRelease &lt;&lt; #opentalk &gt;&gt; 'This function has not been implemented in this release.')</body><body package="ASN1" selector="encodeUTF8String:">encodeUTF8String: anObject	self error: (#notImplementedInThisRelease &lt;&lt; #opentalk &gt;&gt; 'This function has not been implemented in this release.')</body></methods><methods><class-id>ASN1.Asn1StreamBERDefinite class</class-id> <category>class initialization</category><body package="ASN1" selector="initialize">initialize	"((( self initialize )))"	super initialize</body></methods><methods><class-id>ASN1.Asn1StreamBERDefiniteEncodings</class-id> <category>decoding - api</category><body package="ASN1" selector="decodeTLV">decodeTLV	"... a recursive entry point, not to be used at the top level without 'local knowledge'."	"... a moderately generic BER decoding entry point.  Variably-sized tags and definite lengths are assumed in the implementations of 'nextTag' and 'nextLength' respectively."	| tag len res |	self beginEncodings.	tag := self nextTag.	len := self nextLength.	( retainEncodings )		ifTrue:	[ currentEncoding bodyStart: self position + 1 ].	res := ( self tagDispatchWith: tag )				value: len				value: self.	^self endEncodingsWithValue: res</body><body package="ASN1" selector="nextLength">nextLength	"... the method to be directly invoked in decoding APIs."	^self nextDefiniteLength.</body><body package="ASN1" selector="unmarshalObject">unmarshalObject	"... the default, top-level, decoding entry point, for type-agnostic decoding."	^[ 	( retainEncodings )			ifTrue:	[ source := collection copy ].		self decodeTLV		]	on:	Error			do:	[ :ex | Asn1ExcMarshaling raiseSignal: ex errorString ]</body><body package="ASN1" selector="unmarshalObjectType:">unmarshalObjectType: anAsn1Type	"... the default, top-level, entry point for type-in-hand decoding."	^[	( retainEncodings )			ifTrue:	[ source := collection copy ].		self decodeTLV_Type: anAsn1Type		]	on:	Error			do:	[ :ex | Asn1ExcMarshaling raiseSignal: ex errorString ]</body></methods><methods><class-id>ASN1.Asn1StreamBERDefiniteEncodings</class-id> <category>accessing</category><body package="ASN1" selector="currentEncoding">currentEncoding	^currentEncoding</body><body package="ASN1" selector="encodingStack">encodingStack	^( encodingStack isNil )		ifTrue:	[ encodingStack := OrderedCollection new: 256 ]		ifFalse:	[ encodingStack ]</body><body package="ASN1" selector="retainEncodings">retainEncodings	^retainEncodings</body><body package="ASN1" selector="retainEncodings:">retainEncodings: aBoolean	retainEncodings := aBoolean</body></methods><methods><class-id>ASN1.Asn1StreamBERDefiniteEncodings</class-id> <category>stack - api</category><body package="ASN1" selector="beginEncodings">beginEncodings	( retainEncodings )		ifTrue:	[	self pushEncoding.					currentEncoding headerStart: self position + 1				].</body><body package="ASN1" selector="clearEncoding">clearEncoding	encodingStack := OrderedCollection new: 256.	currentEncoding := nil</body><body package="ASN1" selector="endEncodingsWithValue:">endEncodingsWithValue: anObject	^( retainEncodings )		ifTrue:	[	currentEncoding bodyStop: self position.					Asn1TypeWrapper encoding: self popEncoding value: anObject				]		ifFalse:	[ anObject ]</body><body package="ASN1" selector="endEncodingsWithValue:ofType:">endEncodingsWithValue: anObject ofType: anAsn1Type	^( retainEncodings )		ifTrue:	[	currentEncoding bodyStop: self position.					Asn1TypeWrapper						encoding: self popEncoding						type: anAsn1Type						value: anObject				]		ifFalse:	[ anObject ]</body><body package="ASN1" selector="popEncoding">popEncoding	| res |	res := self encodingStack removeLast.	currentEncoding := [ self encodingStack last ]							on: Error							do:	[ :ex | nil ].	^res</body><body package="ASN1" selector="pushEncoding">pushEncoding	| enc |	enc := Asn1Encoding source: source.	self encodingStack addLast: enc.	^currentEncoding := enc</body></methods><methods><class-id>ASN1.Asn1StreamBERDefiniteEncodings</class-id> <category>initialize-release</category><body package="ASN1" selector="initialize">initialize	super initialize.	retainEncodings := false</body></methods><methods><class-id>ASN1.Asn1StreamBERDefiniteEncodings</class-id> <category>decoding - private</category><body package="ASN1" selector="decodeLV_ExplicitType:">decodeLV_ExplicitType: anAsn1Type	| res | 	self nextLength.	( retainEncodings )		ifTrue:	[ currentEncoding bodyStart: self position + 1 ].	res := self decodeTLV_Type: anAsn1Type.	^self endEncodingsWithValue: res ofType: anAsn1Type</body><body package="ASN1" selector="decodeLV_ImplicitType:">decodeLV_ImplicitType: anAsn1Type	| len res |	len := self nextLength.	( retainEncodings )		ifTrue:	[ currentEncoding bodyStart: self position + 1 ].	res := anAsn1Type decode: len with: self.	^self endEncodingsWithValue: res ofType: anAsn1Type</body><body package="ASN1" selector="decodeTLV_Choice:">decodeTLV_Choice: anAsn1TypeCHOICE	"... for CHOICE types only."	| tag ele typ len res |	self beginEncodings.	tag  := self nextTag.	self checkChoiceTagMatchOf: anAsn1TypeCHOICE and: tag.	ele := anAsn1TypeCHOICE elementWithTag: tag.	typ := ele type.	len := self nextLength.	( retainEncodings )		ifTrue:	[ currentEncoding bodyStart: self position + 1 ].	res :=  typ decode: len with: self.	^self endEncodingsWithValue: res ofType: typ</body><body package="ASN1" selector="decodeTLV_Normal:">decodeTLV_Normal: anAsn1Type	"... for non-CHOICE types."	| tag len res |	self beginEncodings.	tag  := self nextTag.	self checkNormalTagMatchOf: anAsn1Type and: tag.	len := self nextLength.	( retainEncodings )		ifTrue:	[ currentEncoding bodyStart: self position + 1 ].	res := anAsn1Type decode: len with: self.	^self endEncodingsWithValue: res ofType: anAsn1Type</body><body package="ASN1" selector="decodeTLV_NormalElement:">decodeTLV_NormalElement: anAsn1Element	| typ |	self beginEncodings.	typ := anAsn1Element type.	self checkNormalTagMatchOf: anAsn1Element and: ( self nextTag ).	^( anAsn1Element isExplicit )		ifTrue:	[ self decodeLV_ExplicitType: typ ]		ifFalse:	[ self decodeLV_ImplicitType: typ ]</body></methods><methods><class-id>ASN1.Asn1StreamBERDefiniteEncodings class</class-id> <category>class initialization</category><body package="ASN1" selector="initialize">initialize	"((( self initialize )))"	super initialize</body></methods><methods><class-id>ASN1.Asn1StreamDER</class-id> <category>encoding - tagged types</category><body package="ASN1" selector="encodeGeneralizedTime:">encodeGeneralizedTime: aTimestamp	"Timestamps are converted to universal time, as required under DER."	| gmtoff ts str mo da hr mn se ms sf  |	gmtoff := TimeZone reference secondsFromGMT.	ts := ( gmtoff negative )			ifTrue:	[ aTimestamp addSeconds: gmtoff abs ]			ifFalse:	[ aTimestamp subtractSeconds: gmtoff ].	str := WriteStream on: ( ByteString new: 23 ).	str nextPutAll: ts year printString.	( ( mo := ts month printString ) size == 1 )		ifTrue:	[ str nextPut: $0 ].	str nextPutAll: mo.	( ( da := ts day printString ) size == 1 )		ifTrue:	[ str nextPut: $0 ].	str nextPutAll: da.	( ( hr := ts hour printString ) size == 1 )		ifTrue:	[ str nextPut: $0 ].	str nextPutAll: hr.	( ( mn := ts minute printString ) size == 1 )		ifTrue:	[ str nextPut: $0 ].	str nextPutAll: mn.	( ( se := ts second printString ) size == 1 )		ifTrue:	[ str nextPut: $0 ].	str nextPutAll: se.	( ( ms := ts millisecond ) == 0 )		ifFalse:	[	sf := ( ms / 1000.0 ) printString.					str nextPutAll: ( sf copyFrom: 2 to: sf size )				].	str nextPut: $Z.	self encodeVisibleString: str contents</body><body package="ASN1" selector="encodeSETorSET_OF:">encodeSETorSET_OF: aSet	"Note that this method is used when there is no 'type-in-hand'. Marshaling without type information is dangerous and error-prone in the case of SETs, which may contain objects of multiple types transmitted in arbitrary order, OPTIONAL values, EXTENSION markers, and DEFAULT values that a receiver is expected to fill in if they have not been transmitted."	| sc spos |	sc := SortedCollection new: aSet size.	sc sortBlock: [:x :y | x asString &lt;= y asString ].	spos := position.	aSet do:		[ :o |	self position: spos.				self encodeTLV: o.				sc add: ( collection copyFrom: spos + 1 to: position ). 		].	self position: spos.	sc do: [ :ba | self nextPutAll: ba ]</body><body package="ASN1" selector="encodeUTCTime:">encodeUTCTime: aTimestamp	"Timestamps are converted to universal time, as required under DER."	| gmtoff ts str mo da hr mn se |	gmtoff := TimeZone reference secondsFromGMT.	ts := ( gmtoff negative )			ifTrue:	[ aTimestamp addSeconds: gmtoff abs ]			ifFalse:	[ aTimestamp subtractSeconds: gmtoff ].	str := WriteStream on: ( ByteString new: 17 ).	str nextPutAll: ( ts year printString copyFrom: 3 to: 4 ).	( ( mo := ts month printString ) size == 1 )		ifTrue:	[ str nextPut: $0 ].	str nextPutAll: mo.	( ( da := ts day printString ) size == 1 )		ifTrue:	[ str nextPut: $0 ].	str nextPutAll: da.	( ( hr := ts hour printString ) size == 1 )		ifTrue:	[ str nextPut: $0 ].	str nextPutAll: hr.	( ( mn := ts minute printString ) size == 1 )		ifTrue:	[ str nextPut: $0 ].	str nextPutAll: mn.	( ( se := ( ts second + ( ts millisecond / 1000 ) rounded ) printString ) size == 1 )		ifTrue:	[ str nextPut: $0 ].	str nextPutAll: se.	str nextPut: $Z.	self encodeVisibleString: str contents</body></methods><methods><class-id>ASN1.Asn1StreamDER</class-id> <category>encoding - private</category><body package="ASN1" selector="encodeTLV:withElement:">encodeTLV: anObject withElement: anAsn1Element	"... as per the DER restrictions, does not encode elements with a value equal to the default."	( anAsn1Element hasDefault and: [ anObject = anAsn1Element default ] )		ifTrue:	[]		ifFalse:	[ super encodeTLV: anObject withElement: anAsn1Element ]</body></methods><methods><class-id>ASN1.Asn1StreamDER</class-id> <category>testing</category><body package="ASN1" selector="requiresEncodingSort">requiresEncodingSort	^true</body><body package="ASN1" selector="requiresTagSort">requiresTagSort	^true</body></methods><methods><class-id>ASN1.Asn1StreamDER class</class-id> <category>class initialization</category><body package="ASN1" selector="initialize">initialize	"((( self initialize )))"	super initialize</body></methods><methods><class-id>ASN1.Asn1Constraint</class-id> <category>printing</category><body package="ASN1" selector="printOn:">printOn: aStream	aStream nextPutAll: self class printString</body></methods><methods><class-id>ASN1.Asn1Constraint</class-id> <category>initialize-release</category><body package="ASN1" selector="initialize">initialize	"... intentionally null."</body></methods><methods><class-id>ASN1.Asn1Constraint</class-id> <category>comparing</category><body package="ASN1" selector="=">= anObject	self subclassResponsibility</body><body package="ASN1" selector="hash">hash	self subclassResponsibility</body></methods><methods><class-id>ASN1.Asn1Constraint</class-id> <category>private</category><body package="ASN1" selector="privatePermits:">privatePermits: anObject	self subclassResponsibility</body></methods><methods><class-id>ASN1.Asn1Constraint</class-id> <category>operational api</category><body package="ASN1" selector="permits:">permits: anObject	"Answers whether the constraint permits anObject."	^[ self privatePermits: anObject ]		on:	Error		do:	[ :ex | ^false ]</body></methods><methods><class-id>ASN1.Asn1Constraint class</class-id> <category>instance creation</category><body package="ASN1" selector="new">new	^super new initialize</body></methods><methods><class-id>ASN1.Asn1ConstraintRegEx</class-id> <category>comparing</category><body package="ASN1" selector="=">= anObject	self error: (#notImplementedInThisRelease &lt;&lt; #opentalk &gt;&gt; 'This function has not been implemented in this release.')</body><body package="ASN1" selector="hash">hash	self error: (#notImplementedInThisRelease &lt;&lt; #opentalk &gt;&gt; 'This function has not been implemented in this release.')</body></methods><methods><class-id>ASN1.Asn1ConstraintRegEx</class-id> <category>private</category><body package="ASN1" selector="privatePermits:">privatePermits: anObject	self error: (#notImplementedInThisRelease &lt;&lt; #opentalk &gt;&gt; 'This function has not been implemented in this release.')</body></methods><methods><class-id>ASN1.Asn1ConstraintSubN</class-id> <category>accessing</category><body package="ASN1" selector="constraints">constraints	^constraints</body><body package="ASN1" selector="constraints:">constraints: aCollection	constraints := aCollection</body></methods><methods><class-id>ASN1.Asn1ConstraintSubN</class-id> <category>configuration api</category><body package="ASN1" selector="addConstraint:">addConstraint: anAsn1Constraint	constraints add: anAsn1Constraint</body></methods><methods><class-id>ASN1.Asn1ConstraintSubN</class-id> <category>initialize-release</category><body package="ASN1" selector="initialize">initialize	constraints := OrderedCollection new</body></methods><methods><class-id>ASN1.Asn1ConstraintSubN</class-id> <category>comparing</category><body package="ASN1" selector="=">= anObject	^( anObject class == self class )		and: [ anObject constraints = self constraints ]</body><body package="ASN1" selector="hash">hash	"... 89 shift 7, then ...."	| octs |	octs := 02r01011001 bitShift: 7.	constraints do:	[ :c | octs bitXor: c hash. octs bitShift: 7 ].	^octs bitAnd: SmallInteger maxVal</body></methods><methods><class-id>ASN1.Asn1ConstraintSubN class</class-id> <category>instance creation</category><body package="ASN1" selector="with:">with: anAsn1Constraint	^( self new )		addConstraint: anAsn1Constraint;		yourself</body><body package="ASN1" selector="with:with:">with: anAsn1Constraint1 with: anAsn1Constraint2	^( self new )		addConstraint: anAsn1Constraint1;		addConstraint: anAsn1Constraint2;		yourself</body><body package="ASN1" selector="with:with:with:">with: anAsn1Constraint1 with: anAsn1Constraint2 with: anAsn1Constraint3	^( self new )		addConstraint: anAsn1Constraint1;		addConstraint: anAsn1Constraint2;		addConstraint: anAsn1Constraint3;		yourself</body><body package="ASN1" selector="with:with:with:with:">with: anAsn1Constraint1 with: anAsn1Constraint2 with: anAsn1Constraint3 with: anAsn1Constraint4	^( self new )		addConstraint: anAsn1Constraint1;		addConstraint: anAsn1Constraint2;		addConstraint: anAsn1Constraint3;		addConstraint: anAsn1Constraint4;		yourself</body><body package="ASN1" selector="withAll:">withAll: aSequenceableCollection	"... to ensure ordering, go out of the way to ensure aSequenceableCollection is one."	| n |	n := self new.	1 to: aSequenceableCollection size do:		[ :x | n addConstraint: ( aSequenceableCollection at: x ) ].	^n</body></methods><methods><class-id>ASN1.Asn1ConstraintUnion</class-id> <category>private</category><body package="ASN1" selector="privatePermits:">privatePermits: anObject	constraints do: [ :c | ( c privatePermits: anObject ) ifTrue: [ ^true ] ].	^false</body></methods><methods><class-id>ASN1.Asn1ConstraintSub1</class-id> <category>accessing</category><body package="ASN1" selector="constraint">constraint	^constraint</body><body package="ASN1" selector="constraint:">constraint: anAsn1Constraint	constraint := anAsn1Constraint</body></methods><methods><class-id>ASN1.Asn1ConstraintSub1</class-id> <category>comparing</category><body package="ASN1" selector="=">= anObject	^( anObject class == self class )		and: [ anObject constraint = self constraint ]</body><body package="ASN1" selector="hash">hash	"... 7 shift 29, then ...."	^( 02r00000111 bitShift: 29 ) bitOr: constraint hash</body></methods><methods><class-id>ASN1.Asn1ConstraintSub1 class</class-id> <category>instance creation</category><body package="ASN1" selector="with:">with: anAsn1Constraint	^( self new )		constraint: anAsn1Constraint;		yourself</body></methods><methods><class-id>ASN1.Asn1ConstraintExcept</class-id> <category>accessing</category><body package="ASN1" selector="except">except	^except</body><body package="ASN1" selector="except:">except: anAsn1Constraint	except := anAsn1Constraint</body></methods><methods><class-id>ASN1.Asn1ConstraintExcept</class-id> <category>comparing</category><body package="ASN1" selector="=">= anObject	^( anObject class == self class )		and: [ ( anObject constraint = self constraint )			and: [ anObject except = self except ] ]</body><body package="ASN1" selector="hash">hash	^( constraint hash bitShift: 8 ) bitOr: except hash</body></methods><methods><class-id>ASN1.Asn1ConstraintExcept</class-id> <category>private</category><body package="ASN1" selector="privatePermits:">privatePermits: anObject	^( constraint privatePermits: anObject ) and: [ ( except privatePermits: anObject ) not ]</body></methods><methods><class-id>ASN1.Asn1ConstraintExcept class</class-id> <category>instance creation</category><body package="ASN1" selector="with:except:">with: anAsn1Constraint1 except: anAsn1Constraint2	^( self new )		constraint: anAsn1Constraint1;		except: anAsn1Constraint2;		yourself</body></methods><methods><class-id>ASN1.Asn1ConstraintSubType</class-id> <category>comparing</category><body package="ASN1" selector="=">= anObject	^( anObject class == self class )		and: [ anObject type symbol = self type symbol ]</body></methods><methods><class-id>ASN1.Asn1ConstraintSubType</class-id> <category>accessing</category><body package="ASN1" selector="type">type	^type</body><body package="ASN1" selector="type:">type: anAsn1Type	type := anAsn1Type</body></methods><methods><class-id>ASN1.Asn1ConstraintSubType class</class-id> <category>instance creation</category><body package="ASN1" selector="with:">with: anAsn1Type	^( self new )		type: anAsn1Type;		yourself</body></methods><methods><class-id>ASN1.Asn1ConstraintWithComponentType</class-id> <category>comparing</category><body package="ASN1" selector="hash">hash	"... 193 shift 29, then ...."	^( 02r11000001 bitShift: 29 ) bitOr: type hash</body></methods><methods><class-id>ASN1.Asn1ConstraintWithComponentType</class-id> <category>private</category><body package="ASN1" selector="privatePermits:">privatePermits: anObject	anObject do: [ :x | ( type constraint privatePermits: x ) ifFalse: [ ^false ] ].	^true</body></methods><methods><class-id>ASN1.Asn1ConstraintOfType</class-id> <category>private</category><body package="ASN1" selector="privatePermits:">privatePermits: anObject	^type constraint privatePermits: anObject</body></methods><methods><class-id>ASN1.Asn1ConstraintOfType</class-id> <category>comparing</category><body package="ASN1" selector="hash">hash	"... 251 shift 29, then ...."	^( 02r11111011 bitShift: 29 ) bitOr: type hash</body></methods><methods><class-id>ASN1.Asn1ConstraintWithComponents</class-id> <category>comparing</category><body package="ASN1" selector="=">= anObject	self error: (#notImplementedInThisRelease &lt;&lt; #opentalk &gt;&gt; 'This function has not been implemented in this release.')</body><body package="ASN1" selector="hash">hash	self error: (#notImplementedInThisRelease &lt;&lt; #opentalk &gt;&gt; 'This function has not been implemented in this release.')</body></methods><methods><class-id>ASN1.Asn1ConstraintWithComponents</class-id> <category>private</category><body package="ASN1" selector="privatePermits:">privatePermits: anObject	self error: (#notImplementedInThisRelease &lt;&lt; #opentalk &gt;&gt; 'This function has not been implemented in this release.')</body></methods><methods><class-id>ASN1.Asn1ConstraintBlockClosure</class-id> <category>accessing</category><body package="ASN1" selector="blockClosure">blockClosure	^blockClosure</body><body package="ASN1" selector="blockClosure:">blockClosure: aBlockClosure	blockClosure := aBlockClosure</body></methods><methods><class-id>ASN1.Asn1ConstraintBlockClosure</class-id> <category>comparing</category><body package="ASN1" selector="=">= anObject	^( anObject class == self class )		and: [ anObject blockClosure = self blockClosure ]</body><body package="ASN1" selector="hash">hash	^blockClosure hash</body></methods><methods><class-id>ASN1.Asn1ConstraintBlockClosure</class-id> <category>private</category><body package="ASN1" selector="privatePermits:">privatePermits: anObject	^blockClosure value: anObject</body></methods><methods><class-id>ASN1.Asn1ConstraintBlockClosure class</class-id> <category>instance creation</category><body package="ASN1" selector="with:">with: aBlockClosure	^( self new )		blockClosure: aBlockClosure;		yourself</body></methods><methods><class-id>ASN1.Asn1ConstraintSize</class-id> <category>accessing</category><body package="ASN1" selector="lower">lower	^lower</body><body package="ASN1" selector="lower:">lower: anInteger	lower := anInteger</body><body package="ASN1" selector="upper">upper	^upper</body><body package="ASN1" selector="upper:">upper: anInteger	upper := anInteger</body></methods><methods><class-id>ASN1.Asn1ConstraintSize</class-id> <category>comparing</category><body package="ASN1" selector="=">= anObject	^( anObject class == self class )		and: [ ( anObject lower = self lower )			and: [ anObject upper = self upper ] ]</body><body package="ASN1" selector="hash">hash	^( lower hash bitShift: 8 ) bitOr: upper hash</body></methods><methods><class-id>ASN1.Asn1ConstraintSize</class-id> <category>private</category><body package="ASN1" selector="privatePermits:">privatePermits: anObject	| s |	s := anObject size.	^( s &gt;= lower ) and: [ s &lt;= upper ]</body></methods><methods><class-id>ASN1.Asn1ConstraintSize class</class-id> <category>instance creation</category><body package="ASN1" selector="lower:upper:">lower: anInteger1 upper: anInteger2	^( super new )		lower: anInteger1;		upper: anInteger2;		yourself</body><body package="ASN1" selector="size:">size: anInteger	^( super new )		lower: anInteger;		upper: anInteger;		yourself</body></methods><methods><class-id>ASN1.Asn1ConstraintWithComponent</class-id> <category>private</category><body package="ASN1" selector="privatePermits:">privatePermits: anObject	anObject do: [ :e | ( constraint privatePermits: e ) ifFalse: [ ^false ] ].	^true</body></methods><methods><class-id>ASN1.Asn1ConstraintValueUnion</class-id> <category>accessing</category><body package="ASN1" selector="values">values	^values</body><body package="ASN1" selector="values:">values: aCollection	values := aCollection</body></methods><methods><class-id>ASN1.Asn1ConstraintValueUnion</class-id> <category>configuration api</category><body package="ASN1" selector="addValue:">addValue: anObject	values add: anObject</body></methods><methods><class-id>ASN1.Asn1ConstraintValueUnion</class-id> <category>initialize-release</category><body package="ASN1" selector="initialize">initialize	values := Set new: 7</body></methods><methods><class-id>ASN1.Asn1ConstraintValueUnion</class-id> <category>comparing</category><body package="ASN1" selector="=">= anObject	^( anObject class == self class )		and: [ anObject values = self values ]</body><body package="ASN1" selector="hash">hash	^values hash</body></methods><methods><class-id>ASN1.Asn1ConstraintValueUnion</class-id> <category>private</category><body package="ASN1" selector="privatePermits:">privatePermits: anObject	^values includes: anObject</body></methods><methods><class-id>ASN1.Asn1ConstraintValueUnion class</class-id> <category>instance creation</category><body package="ASN1" selector="with:">with: aValue	^( self new )		addValue: aValue;		yourself</body><body package="ASN1" selector="with:with:">with: aValue1 with: aValue2	^( self new )		addValue: aValue1;		addValue: aValue2;		yourself</body><body package="ASN1" selector="with:with:with:">with: aValue1 with: aValue2 with: aValue3	^( self new )		addValue: aValue1;		addValue: aValue2;		addValue: aValue3;		yourself</body><body package="ASN1" selector="with:with:with:with:">with: aValue1 with: aValue2 with: aValue3 with: aValue4	^( self new )		addValue: aValue1;		addValue: aValue2;		addValue: aValue3;		addValue: aValue4;		yourself</body><body package="ASN1" selector="withAll:">withAll: aCollection	| n |	n := self new.	n values addAll: aCollection.	^n</body></methods><methods><class-id>ASN1.Asn1ConstraintValueRange</class-id> <category>accessing</category><body package="ASN1" selector="lower">lower	^lower</body><body package="ASN1" selector="lower:">lower: anObject	lower := anObject</body><body package="ASN1" selector="lowerOpen">lowerOpen	^lowerOpen</body><body package="ASN1" selector="lowerOpen:">lowerOpen: aBoolean	lowerOpen := aBoolean</body><body package="ASN1" selector="upper">upper	^upper</body><body package="ASN1" selector="upper:">upper: anObject	upper := anObject</body><body package="ASN1" selector="upperOpen">upperOpen	^upperOpen</body><body package="ASN1" selector="upperOpen:">upperOpen: aBoolean	upperOpen := aBoolean</body></methods><methods><class-id>ASN1.Asn1ConstraintValueRange</class-id> <category>initialize-release</category><body package="ASN1" selector="initialize">initialize	lowerOpen := upperOpen := false</body></methods><methods><class-id>ASN1.Asn1ConstraintValueRange</class-id> <category>private</category><body package="ASN1" selector="privatePermits:">privatePermits: anObject	^( lowerOpen			ifTrue: [ lower &lt; anObject ]			ifFalse: [ lower &lt;= anObject ] )				and:	[	upperOpen								ifTrue:	[ anObject &lt; upper ]								ifFalse: [ anObject &lt;= upper ] ]</body></methods><methods><class-id>ASN1.Asn1ConstraintValueRange</class-id> <category>comparing</category><body package="ASN1" selector="=">= anObject	^( anObject class == self class )		and: [ ( anObject lower = self lower )			and: [ ( anObject upper = self upper )				and: [ ( anObject lowerOpen = self lowerOpen )					and: [ anObject upperOpen = self upperOpen ] ] ] ]</body><body package="ASN1" selector="hash">hash	^( ( ( ( ( ( ( lower hash ) 		bitShift: 8 ) bitXor: ( upper hash ) )			bitShift: 8 ) bitXor: lowerOpen hash )				bitShift: 5 ) bitXor: upperOpen hash )					bitAnd: SmallInteger maxVal</body></methods><methods><class-id>ASN1.Asn1ConstraintValueRange class</class-id> <category>instance creation</category><body package="ASN1" selector="lower:lowerOpen:upper:upperOpen:">lower: anObject1 lowerOpen: aBoolean1 upper: anObject2 upperOpen: aBoolean2	^( self new )		lower: anObject1;		lowerOpen: aBoolean1;		upper: anObject2;		upperOpen: aBoolean2;		yourself</body><body package="ASN1" selector="lower:upper:">lower: anObject1 upper: anObject2	^( self new )		lower: anObject1;		upper: anObject2;		yourself</body></methods><methods><class-id>ASN1.Asn1ConstraintEnumerated</class-id> <category>accessing</category><body package="ASN1" selector="elements">elements	^elements</body><body package="ASN1" selector="elements:">elements: anOrderedCollectionOfAsn1EnumerationsOrAsn1MarkerExtensionsOrAssociations	elements := ( anOrderedCollectionOfAsn1EnumerationsOrAsn1MarkerExtensionsOrAssociations					collect: [ :x | x asAsn1Enumeration ] )</body></methods><methods><class-id>ASN1.Asn1ConstraintEnumerated</class-id> <category>initialize-release</category><body package="ASN1" selector="initialize">initialize	elements := OrderedCollection new: 7</body></methods><methods><class-id>ASN1.Asn1ConstraintEnumerated</class-id> <category>comparing</category><body package="ASN1" selector="=">= anObject	^( anObject class == self class )		and: [ anObject elements = self elements ]</body><body package="ASN1" selector="hash">hash	^elements hash</body></methods><methods><class-id>ASN1.Asn1ConstraintEnumerated</class-id> <category>private</category><body package="ASN1" selector="integers">integers	^elements collect: [ :enum | enum integer ]</body><body package="ASN1" selector="privatePermits:">privatePermits: anObject	^( self integers includes: anObject ) or: [ self symbols includes: anObject ]</body><body package="ASN1" selector="symbols">symbols	^elements collect: [ :enum | enum symbol ]</body></methods><methods><class-id>ASN1.Asn1ConstraintEnumerated</class-id> <category>configuration api</category><body package="ASN1" selector="addElement:">addElement: anAsn1EnumerationOrAsn1MarkerExtensionOrAssociation	elements addLast: ( anAsn1EnumerationOrAsn1MarkerExtensionOrAssociation asAsn1Enumeration )</body></methods><methods><class-id>ASN1.Asn1ConstraintEnumerated class</class-id> <category>instance creation</category><body package="ASN1" selector="with:">with: anAssociation	^( self new )		addElement: anAssociation;		yourself</body><body package="ASN1" selector="with:with:">with: anAssociation1 with: anAssociation2	^( self new )		addElement: anAssociation1;		addElement: anAssociation2;		yourself</body><body package="ASN1" selector="with:with:with:">with: anAssociation1 with: anAssociation2 with: anAssociation3	^( self new )		addElement: anAssociation1;		addElement: anAssociation2;		addElement: anAssociation3;		yourself</body><body package="ASN1" selector="with:with:with:with:">with: anAssociation1 with: anAssociation2 with: anAssociation3 with: anAssociation4	^( self new )		addElement: anAssociation1;		addElement: anAssociation2;		addElement: anAssociation3;		addElement: anAssociation4;		yourself</body><body package="ASN1" selector="withAll:">withAll: aSequenceableCollectionOfAssociations	^( self new )		elements: aSequenceableCollectionOfAssociations asOrderedCollection;		yourself</body></methods><methods><class-id>ASN1.Asn1ConstraintTypeInclusion</class-id> <category>private</category><body package="ASN1" selector="privatePermits:">privatePermits: anObject	self error: (#notImplementedInThisRelease &lt;&lt; #opentalk &gt;&gt; 'This function has not been implemented in this release.')</body></methods><methods><class-id>ASN1.Asn1ConstraintTypeInclusion</class-id> <category>comparing</category><body package="ASN1" selector="hash">hash	self error: (#notImplementedInThisRelease &lt;&lt; #opentalk &gt;&gt; 'This function has not been implemented in this release.')</body></methods><methods><class-id>ASN1.Asn1ConstraintNull</class-id> <category>comparing</category><body package="ASN1" selector="=">= anObject	^anObject == self</body><body package="ASN1" selector="hash">hash	^nil hash</body></methods><methods><class-id>ASN1.Asn1ConstraintNull</class-id> <category>private</category><body package="ASN1" selector="privatePermits:">privatePermits: anObject	^true</body></methods><methods><class-id>ASN1.Asn1ConstraintNull class</class-id> <category>instance creation</category><body package="ASN1" selector="default">default	^self new</body><body package="ASN1" selector="new">new	^( default isNil )		ifTrue:	[ default := super new ]		ifFalse:	[ default ]</body></methods><methods><class-id>ASN1.Asn1ConstraintAlphabet</class-id> <category>private</category><body package="ASN1" selector="privatePermits:">privatePermits: anObject	( anObject isKindOf: CharacterArray )		ifFalse: [ ^false ].	anObject do: [ :character | ( constraint privatePermits: character ) ifFalse: [ ^false ] ].	^true</body></methods><methods><class-id>ASN1.Asn1ConstraintSingleValue</class-id> <category>accessing</category><body package="ASN1" selector="value">value	^value</body><body package="ASN1" selector="value:">value: aLiteralOrAsn1Constraint	value := aLiteralOrAsn1Constraint</body></methods><methods><class-id>ASN1.Asn1ConstraintSingleValue</class-id> <category>comparing</category><body package="ASN1" selector="=">= anObject	^( anObject class == self class )		and: [ anObject value = self value ]</body><body package="ASN1" selector="hash">hash	^value hash</body></methods><methods><class-id>ASN1.Asn1ConstraintSingleValue</class-id> <category>private</category><body package="ASN1" selector="privatePermits:">privatePermits: anObject	^[ ( value = anObject )		or: [ anObject permits: anObject ] ]			on:	Error			do:	[ :ex | false ]</body></methods><methods><class-id>ASN1.Asn1ConstraintSingleValue class</class-id> <category>instance creation</category><body package="ASN1" selector="with:">with: anObject	^( self new )		value: anObject;		yourself</body></methods><methods><class-id>ASN1.Asn1Type</class-id> <category>accessing</category><body package="ASN1" selector="children">children	^children ifNil: [ children := Set new: 2 ]</body><body package="ASN1" selector="children:">children: aSet	children := aSet</body><body package="ASN1" selector="constraint">constraint	^constraint</body><body package="ASN1" selector="constraint:">constraint: anAsn1Constraint	constraint := anAsn1Constraint</body><body package="ASN1" selector="parent">parent	^parent</body><body package="ASN1" selector="parent:">parent: anAsn1Type	parent := anAsn1Type</body><body package="ASN1" selector="wrap">wrap	^wrap ifNil: [ wrap := self class defaultWrap ]</body><body package="ASN1" selector="wrap:">wrap: aBoolean	wrap := aBoolean</body></methods><methods><class-id>ASN1.Asn1Type</class-id> <category>testing</category><body package="ASN1" selector="isBasic">isBasic	^false</body><body package="ASN1" selector="isConstructed">isConstructed	^false</body><body package="ASN1" selector="isExtensible">isExtensible	"Indicates whether the type may be extended in revisions of an originating ASN.1 type specifciation and include an ASN.1 extension marker."	^false</body><body package="ASN1" selector="isScoping">isScoping	"Indicates whether the type may override default tags by creating context-specific tags.  In principle, 'universal' and 'context-specific' tag classes are sufficient to disambiguate all tags.  Any ASN.1 compiler that produces instances or structures of Asn1Type is expected to do its job without relying on contexts that represent 'application' or 'private' tag classes."	^false</body><body package="ASN1" selector="isStructured">isStructured	^false</body></methods><methods><class-id>ASN1.Asn1Type</class-id> <category>configuration api</category><body package="ASN1" selector="addChild:">addChild: anAsn1Type	( ( self childrenWithSymbol: anAsn1Type symbol ) isEmpty not )		ifTrue:	[ Transcript					cr;					show: ( ( #RedefiningASN1Type &lt;&lt; #opentalk &gt;&gt; 'Redefining ASN.1 type &lt;1s&gt;.' )								expandMacrosWith: anAsn1Type symbol )				].	self children add: anAsn1Type</body><body package="ASN1" selector="childrenWithSymbol:">childrenWithSymbol: aSymbol	^self children select: [ :x | x symbol == aSymbol ]</body><body package="ASN1" selector="removeChild:">removeChild: anAsn1Type	children		remove: anAsn1Type		ifAbsent: []</body><body package="ASN1" selector="removeChildrenWithSymbol:">removeChildrenWithSymbol: aSymbol	 ( self childrenWithSymbol: aSymbol )		do: [ :y | self children remove: y ]</body></methods><methods><class-id>ASN1.Asn1Type</class-id> <category>instance registration api</category><body package="ASN1" selector="register:">register: aSymbol	"... creates and registers a new Asn1Type instance."	^self class registerType:		( self class			parent: self			symbol: aSymbol		)</body><body package="ASN1" selector="register:constraint:">register: aSymbol constraint: anAsn1Constraint	"... creates and registers a new Asn1Type instance."	^self class registerType:		( self class			constraint: anAsn1Constraint			parent: self			symbol: aSymbol		)</body></methods><methods><class-id>ASN1.Asn1Type</class-id> <category>validation</category><body package="ASN1" selector="permits:">permits: anObject	^constraint permits: anObject</body></methods><methods><class-id>ASN1.Asn1Type</class-id> <category>encoding</category><body package="ASN1" selector="encode:with:">encode: anObject with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	self error: (#notImplementedInThisRelease &lt;&lt; #opentalk &gt;&gt; 'This function has not been implemented in this release.')</body><body package="ASN1" selector="tagBER">tagBER	self subclassResponsibility</body></methods><methods><class-id>ASN1.Asn1Type</class-id> <category>printing</category><body package="ASN1" selector="printOn:">printOn: aStream	aStream		nextPutAll: ( self class name );		nextPutAll: '( ';		nextPutAll: self symbol;		nextPutAll: ' / ';		print: self constraint;		nextPutAll: ' )'</body></methods><methods><class-id>ASN1.Asn1Type</class-id> <category>error</category><body package="ASN1" selector="obsoleteType">obsoleteType	self error: (#typeIsObsolete &lt;&lt; #opentalk &gt;&gt; 'This ASN.1 type is obsolete and no longer used.')</body></methods><methods><class-id>ASN1.Asn1Type</class-id> <category>initialize-release</category><body package="ASN1" selector="initialize">initialize	"... intentionally null."</body></methods><methods><class-id>ASN1.Asn1Type</class-id> <category>comparing</category><body package="ASN1" selector="=">= anObject	^( anObject class == self class )		and: [ ( anObject constraint = self constraint )			and: [ ( anObject wrap == self wrap )				and: [ ( anObject parent == self parent )					and: [ ( anObject children size == self children size )						and: [ ( anObject children isEmpty )								or: [ ( anObject children collect: [ :x | x symbol ] ) asSortedCollection										= ( self children collect: [ :x | x symbol ] ) asSortedCollection ] ] ] ] ] ]</body><body package="ASN1" selector="hash">hash	^( ( ( symbol hash bitShift: 5 ) bitOr: constraint hash ) bitShift: 1 ) bitOr: children size</body></methods><methods><class-id>ASN1.Asn1Type</class-id> <category>decoding</category><body package="ASN1" selector="decode:with:">decode: anInteger with: aMarshaler	"... the method invoked when unmarshaling type-in-hand."	self error: (#notImplementedInThisRelease &lt;&lt; #opentalk &gt;&gt; 'This function has not been implemented in this release.')</body></methods><methods><class-id>ASN1.Asn1Type class</class-id> <category>testing</category><body package="ASN1" selector="isConcrete">isConcrete	| sel |	sel := self class selectors.	^( sel includes: #defaultSymbol )		and: [ sel includes: #defaultConstraint ]</body></methods><methods><class-id>ASN1.Asn1Type class</class-id> <category>private</category><body package="ASN1" selector="childrenOf:allowChild:">childrenOf: anAsn1Type1 allowChild: anAsn1Type2	| m |	m := anAsn1Type1 children detect: [ :x | x symbol == anAsn1Type2 symbol ] ifNone: [].	( m ~~ nil and: [ m ~= anAsn1Type2 ] )		ifTrue:	[ ^Asn1ExcTypeRegistration raiseSignal: (#dangerousReregistration &lt;&lt; #opentalk &gt;&gt; 'The type being registered differs significantly from an existing type of the same name.') ]</body><body package="ASN1" selector="constraint:parent:symbol:">constraint: anAsn1Constraint parent: anAsn1TypeOrNil symbol: aSymbol	"... creates a new type without registering it.  We build an intersection with the inherited constraint because any ALL EXCEPT constraint implicitly refer to the supertype.  The putatively more restrictive constraints cannot be placed first, for the default constraint is often a type check."	| parent constraint |	parent := anAsn1TypeOrNil.	constraint := ( parent isNil )						ifTrue:	[ anAsn1Constraint ]						ifFalse:	[ ASN1.Asn1ConstraintIntersection									with: parent constraint									with: anAsn1Constraint ].	^( self new )		constraint: constraint;		parent: parent;		symbol: aSymbol;		yourself</body><body package="ASN1" selector="parent:symbol:">parent: anAsn1Type symbol: aSymbol	"... creates a new type without registering it.  We do not build a type intersection in this case, on the assumption that the parent is non-nil and that the new type's constraint is identical to the parent constraint."	^( self new )		constraint: anAsn1Type constraint;		parent: anAsn1Type;		symbol: aSymbol;		yourself</body><body package="ASN1" selector="registerType:">registerType: anAsn1Type	| parent |	( ( parent := anAsn1Type parent ) notNil )		ifTrue:	[ 	self childrenOf: parent allowChild: anAsn1Type.					parent addChild: anAsn1Type				].	self typeRegistry		at: anAsn1Type symbol		put: anAsn1Type.	^anAsn1Type</body><body package="ASN1" selector="unregisterType:">unregisterType: anAsn1Type	"We patch the type tree rather than remove subtypes, because parent constraints are included in child constraints at type creation."	| parent children |	( ( parent := anAsn1Type parent ) notNil )		ifTrue:	[ parent removeChild: anAsn1Type ].	( ( children := anAsn1Type children ) isEmpty not )		ifTrue:	[ children do: [ :c | c parent: parent ] ].	self typeRegistry removeKey: anAsn1Type symbol</body></methods><methods><class-id>ASN1.Asn1Type class</class-id> <category>instance registration api</category><body package="ASN1" selector="register:">register: aSymbol	"... creates and registers a new Asn1Type instance."	^self registerType:		( self			parent: self default			symbol: aSymbol		)</body><body package="ASN1" selector="register:constraint:">register: aSymbol constraint: anAsn1Constraint	"... creates and registers a new Asn1Type instance."	^self registerType:		( self			constraint: anAsn1Constraint			parent: self default			symbol: aSymbol		)</body><body package="ASN1" selector="registerDefault">registerDefault	^self registerType: self defaultConstructor</body><body package="ASN1" selector="unregisterTypeNamed:">unregisterTypeNamed: aSymbol	self unregisterType: ( self findTypeNamed: aSymbol )</body></methods><methods><class-id>ASN1.Asn1Type class</class-id> <category>class initialization</category><body package="ASN1" selector="initialize">initialize	"((( Asn1Type initialize )))"	self initializeASN1BitMasks.	self initializeASN1TagClasses.	self initializeASN1TagForms.	self initializeASN1TagMasks.	self initializeASN1UniversalTags.	self initializeASN1ConstructedTags.	self initializeRegistry.	defaultWrap := false</body><body package="ASN1" selector="initializeASN1BitMasks">initializeASN1BitMasks	"((( self initializeASN1BitMasks )))"	ASN1.BitMasksTerminal :=		#(	02r00000000			02r00000001			02r00000011 			02r00000111			02r00001111			02r00011111			02r00111111			02r01111111			02r11111111 )</body><body package="ASN1" selector="initializeASN1ConstructedTags">initializeASN1ConstructedTags	" Initialize the frequetly used (as in BER) ASN.1 constructed type tags."	"((( self initializeASN1ConstructedTags )))"	"[ CONSTRUCTED 16 ] does double duty."	ASN1.ConstructedSEQUENCE := ( ASN1.UniversalClass bitOr: ASN1.ConstructedForm ) bitOr: 16r10.	ASN1.ConstructedSEQUENCE_OF := ( ASN1.UniversalClass bitOr: ASN1.ConstructedForm ) bitOr: 16r10.	"[ CONSTRUCTED 17 ] does double duty."	ASN1.ConstructedSET := ( ASN1.UniversalClass bitOr: ASN1.ConstructedForm )  bitOr: 16r11.	ASN1.ConstructedSET_OF := ( ASN1.UniversalClass bitOr: ASN1.ConstructedForm )  bitOr: 16r11.</body><body package="ASN1" selector="initializeASN1TagClasses">initializeASN1TagClasses	"((( self initializeASN1TypeClasses )))"	ASN1.UniversalClass := 02r00000000.	ASN1.ApplicationClass := 02r01000000.	ASN1.ContextSpecificClass := 02r10000000.	ASN1.PrivateClass := 02r11000000.</body><body package="ASN1" selector="initializeASN1TagForms">initializeASN1TagForms	"((( self initializeASN1TagForms )))"	ASN1.PrimitiveForm := 02r00000000.	ASN1.ConstructedForm := 02r00100000.</body><body package="ASN1" selector="initializeASN1TagMasks">initializeASN1TagMasks	"((( self initializeASN1TagMasks )))"	ASN1.TagMaskClass := 02r11000000.	ASN1.TagMaskForm := 02r00100000.	ASN1.TagMaskNumber := 02r00011111.</body><body package="ASN1" selector="initializeASN1UniversalTags">initializeASN1UniversalTags	" Initialize universal ASN.1 type tags.  Note that the universal tags for constructed types are not used in BER."	"((( self initializeASN1UniversalTags )))"	"[ UNIVERSAL 0 ] is reserved for BER."	ASN1.UniversalBOOLEAN := ASN1.UniversalClass bitOr: 16r01.	ASN1.UniversalINTEGER := ASN1.UniversalClass bitOr: 16r02.	ASN1.UniversalBIT_STRING := ASN1.UniversalClass bitOr: 16r03.	ASN1.UniversalOCTET_STRING := ASN1.UniversalClass bitOr: 16r04.	ASN1.UniversalNULL := ASN1.UniversalClass bitOr: 16r05.	ASN1.UniversalOBJECT_IDENTIFIER := ASN1.UniversalClass bitOr: 16r06.	ASN1.UniversalObjectDescriptor := ASN1.UniversalClass bitOr: 16r07.	"[ UNIVERSAL 8 ] does double duty."	ASN1.UniversalEXTERNAL := ASN1.UniversalClass bitOr: 16r08.	ASN1.UniversalINSTANCE_OF := ASN1.UniversalClass bitOr: 16r08.	ASN1.UniversalREAL := ASN1.UniversalClass bitOr: 16r09.	ASN1.UniversalENUMERATED := ASN1.UniversalClass bitOr: 16r0A.	ASN1.UniversalEMBEDDED_PDV := ASN1.UniversalClass bitOr: 16r0B.	ASN1.UniversalUTF8String := ASN1.UniversalClass bitOr: 16r0C.	ASN1.UniversalRELATIVE_OID := ASN1.UniversalClass bitOr: 16r0D.	"[ UNIVERSAL 14 ] is reserved for future use."	"[ UNIVERSAL 15 ] is reserved for future use."	"[ UNIVERSAL 16 ] does double duty."	ASN1.UniversalSEQUENCE := ASN1.UniversalClass bitOr: 16r10.	ASN1.UniversalSEQUENCE_OF := ASN1.UniversalClass bitOr: 16r10.	"[ UNIVERSAL 17 ] does double duty."	ASN1.UniversalSET := ASN1.UniversalClass bitOr: 16r11.	ASN1.UniversalSET_OF := ASN1.UniversalClass bitOr: 16r11.	ASN1.UniversalNumericString := ASN1.UniversalClass bitOr: 16r12.	ASN1.UniversalPrintableString := ASN1.UniversalClass bitOr: 16r13.	"[ UNIVERSAL 20 ] does double duty."	ASN1.UniversalTeletexString := ASN1.UniversalClass bitOr: 16r14.	ASN1.UniversalT61String := ASN1.UniversalClass bitOr: 16r14.	ASN1.UniversalVideotexString := ASN1.UniversalClass bitOr: 16r15.	ASN1.UniversalIA5String := ASN1.UniversalClass bitOr: 16r16.	ASN1.UniversalUTCTime := ASN1.UniversalClass bitOr: 16r17.	ASN1.UniversalGeneralizedTime := ASN1.UniversalClass bitOr: 16r18.	ASN1.UniversalGraphicString := ASN1.UniversalClass bitOr: 16r19.	"[ UNIVERSAL 26 ] does double duty."	ASN1.UniversalVisibleString := ASN1.UniversalClass bitOr: 16r1A.	ASN1.UniversalISO646String := ASN1.UniversalClass bitOr: 16r1A.	ASN1.UniversalGeneralString := ASN1.UniversalClass bitOr: 16r1B.	"In the following, the first 'Universal' denotes the tag class, the second is part of the type name."	ASN1.UniversalUniversalString := ASN1.UniversalClass bitOr: 16r1C.	ASN1.UniversalCHARACTER_STRING := ASN1.UniversalClass bitOr: 16r1D.	ASN1.UniversalBMPString := ASN1.UniversalClass bitOr: 16r1E.	"The following two numbers, 31 and 32, present before entering the range of the 'constructed tags', are reserved for future use."</body><body package="ASN1" selector="initializeRegistry">initializeRegistry	"((( Asn1Type initializeRegistry )))"	self clearTypeRegistry.	self allSubclassesDo:		[ :sc |	( sc isConcrete )					ifTrue:	[ sc registerDefault ]		]</body></methods><methods><class-id>ASN1.Asn1Type class</class-id> <category>accessing</category><body package="ASN1" selector="defaultWrap">defaultWrap	^defaultWrap</body><body package="ASN1" selector="defaultWrap:">defaultWrap: aBoolean	defaultWrap := aBoolean</body><body package="ASN1" selector="typeRegistry">typeRegistry	"((( Asn1Type typeRegistry )))"	^TypeRegistry</body><body package="ASN1" selector="typeRegistry:">typeRegistry: aDictionary	TypeRegistry := aDictionary</body></methods><methods><class-id>ASN1.Asn1Type class</class-id> <category>registry api</category><body package="ASN1" selector="clearTypeRegistry">clearTypeRegistry	"((( Asn1Type clearTypeRegistry )))"	TypeRegistry := Dictionary new: 256.</body><body package="ASN1" selector="findTypeNamed:">findTypeNamed: aSymbol	"... patches in a type reference, that will hopefully be resolved later."	"... to support registration of highly nested types in arbitrary order."	^self typeRegistry		at: aSymbol		ifAbsentPut: [ Asn1TypeReference symbol: aSymbol ]</body><body package="ASN1" selector="resetTypeRegistry">resetTypeRegistry	"((( Asn1Type resetTypeRegistry )))"	self initializeRegistry</body></methods><methods><class-id>ASN1.Asn1Type class</class-id> <category>defaults</category><body package="ASN1" selector="default">default	^self findTypeNamed: self defaultSymbol</body><body package="ASN1" selector="defaultConstraint">defaultConstraint	"... should, in all but a few cases, be overridden."	^ASN1.Asn1ConstraintNull</body><body package="ASN1" selector="defaultConstructor">defaultConstructor	^self		constraint: self defaultConstraint		parent: nil		symbol: self defaultSymbol</body><body package="ASN1" selector="defaultSymbol">defaultSymbol	^self subclassResponsibility</body></methods><methods><class-id>ASN1.Asn1Type class</class-id> <category>instance creation</category><body package="ASN1" selector="new">new	^super new initialize</body></methods><methods><class-id>ASN1.Asn1TypeBasic</class-id> <category>testing</category><body package="ASN1" selector="isBasic">isBasic	^true</body></methods><methods><class-id>ASN1.Asn1TypeENUMERATED</class-id> <category>testing</category><body package="ASN1" selector="isExtensible">isExtensible	"Indicates whether the type may be extended in revisions of an originating ASN.1 type specifciation and include an ASN.1 extension marker."	^true</body></methods><methods><class-id>ASN1.Asn1TypeENUMERATED</class-id> <category>encoding</category><body package="ASN1" selector="encode:with:">encode: anAsn1ImportedEnumerated with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	aMarshaler encodeENUMERATED: anAsn1ImportedEnumerated</body><body package="ASN1" selector="tagBER">tagBER	"... avoid the namespace lookup."	^02r00001010	"ASN1.UniversalENUMERATED = 10"</body></methods><methods><class-id>ASN1.Asn1TypeENUMERATED</class-id> <category>private</category><body package="ASN1" selector="clearPredicates">clearPredicates	extensionMarkerCount := nil</body><body package="ASN1" selector="setExtensionMarkerCount">setExtensionMarkerCount	| n |	n := 0.	elements do: [ :e | ( e isExtensionMarker ) ifTrue: [ n := n + 1 ] ].	^extensionMarkerCount := n</body></methods><methods><class-id>ASN1.Asn1TypeENUMERATED</class-id> <category>accessing</category><body package="ASN1" selector="elements">elements	^elements</body><body package="ASN1" selector="elements:">elements: aSequenceableCollection	elements := aSequenceableCollection.	self clearPredicates</body><body package="ASN1" selector="extensionMarkerCount">extensionMarkerCount	^( extensionMarkerCount isNil )		ifTrue:	[ self setExtensionMarkerCount ]		ifFalse:	[ extensionMarkerCount ]</body></methods><methods><class-id>ASN1.Asn1TypeENUMERATED</class-id> <category>configuration api</category><body package="ASN1" selector="addElement:">addElement: anAsn1AbstractElement	elements addLast: anAsn1AbstractElement.	self clearPredicates</body><body package="ASN1" selector="removeElement:">removeElement: anAsn1AbstractElement	elements remove: anAsn1AbstractElement.	self clearPredicates</body></methods><methods><class-id>ASN1.Asn1TypeENUMERATED</class-id> <category>instance registration api</category><body package="ASN1" selector="register:">register: aSymbol	"... enumerated elements are required."	self shouldNotImplement</body><body package="ASN1" selector="register:constraint:">register: aSymbol constraint: anAsn1Constraint	"... enumerated elements are usually required, but not if sybtyping"	^super register: aSymbol constraint: anAsn1Constraint</body><body package="ASN1" selector="register:constraint:elements:">register: aSymbol constraint: anAsn1Constraint elements: aSequenceableCollection	"... creates and registers a new Asn1StructuredType instance."	^self class registerType:		( self class			constraint: anAsn1Constraint			parent: self			symbol: aSymbol			elements: aSequenceableCollection			yourself		)</body><body package="ASN1" selector="register:elements:">register: aSymbol elements: aSequenceableCollection	"... creates and registers a new Asn1StructuredType instance."	^self class registerType:		( self class			constraint: nil			parent: self			symbol: aSymbol			elements: aSequenceableCollection			yourself		)</body></methods><methods><class-id>ASN1.Asn1TypeENUMERATED</class-id> <category>accessing - elements</category><body package="ASN1" selector="elementAtIndex:">elementAtIndex: anInteger	^elements at: anInteger</body><body package="ASN1" selector="elementWithInteger:">elementWithInteger: anInteger	^elements detect: [ :x | x integer = anInteger ] ifNone: []</body><body package="ASN1" selector="elementWithSymbol:">elementWithSymbol: aSymbol	^elements detect: [ :x | x symbol = aSymbol ] ifNone: []</body></methods><methods><class-id>ASN1.Asn1TypeENUMERATED</class-id> <category>testing - elements</category><body package="ASN1" selector="hasExtensionMarkers">hasExtensionMarkers	^( self extensionMarkerCount &gt; 0 )</body></methods><methods><class-id>ASN1.Asn1TypeENUMERATED</class-id> <category>initialize-release</category><body package="ASN1" selector="initialize">initialize	super initialize.	wrap := false.	elements := OrderedCollection new: 7.</body></methods><methods><class-id>ASN1.Asn1TypeENUMERATED</class-id> <category>decoding</category><body package="ASN1" selector="decode:with:">decode: anInteger with: aMarshaler	"... the method invoked when unmarshaling type-in-hand."	^ImportedEnumeration		type: self		value: ( aMarshaler decodeENUMERATED: anInteger )</body></methods><methods><class-id>ASN1.Asn1TypeENUMERATED class</class-id> <category>defaults</category><body package="ASN1" selector="defaultConstraint">defaultConstraint	^Asn1ConstraintBlockClosure		with: [ :x | ( x isKindOf: Integer )					or: [ ( x class == ImportedEnumeration )							and: [ x value isKindOf: Integer ] ] ]</body><body package="ASN1" selector="defaultConstructor">defaultConstructor	"... intentionally call 'super' to avoid generating an element constraint."	^super		constraint: self defaultConstraint		parent: nil		symbol: self defaultSymbol</body><body package="ASN1" selector="defaultSymbol">defaultSymbol	^#'ENUMERATED'</body></methods><methods><class-id>ASN1.Asn1TypeENUMERATED class</class-id> <category>instance registration api</category><body package="ASN1" selector="register:">register: aSymbol	"... enumerated elements are required."	self shouldNotImplement</body><body package="ASN1" selector="register:constraint:">register: aSymbol constraint: anAsn1Constraint	"... enumerated elements are required."	self shouldNotImplement</body><body package="ASN1" selector="register:constraint:elements:">register: aSymbol constraint: anAsn1Constraint elements: aSequenceableCollection	"... creates and registers a new Asn1ENUMERATEDType instance."	^self registerType:		( self			constraint: anAsn1Constraint			parent: self default			symbol: aSymbol			elements: aSequenceableCollection			yourself		)</body><body package="ASN1" selector="register:elements:">register: aSymbol elements: aSequenceableCollection	"... creates and registers a new Asn1ENUMERATEDType instance."	^self registerType:		( self			constraint: nil			parent: self default			symbol: aSymbol			elements: aSequenceableCollection			yourself		)</body></methods><methods><class-id>ASN1.Asn1TypeENUMERATED class</class-id> <category>private</category><body package="ASN1" selector="constraint:parent:symbol:">constraint: anAsn1Constraint parent: anAsn1TypeOrNil symbol: aSymbol	"... enumerated elements are usually required, but not if sybtyping"	^super constraint: anAsn1Constraint parent: anAsn1TypeOrNil symbol: aSymbol</body><body package="ASN1" selector="constraint:parent:symbol:elements:">constraint: anAsn1Constraint parent: anAsn1TypeOrNil symbol: aSymbol elements: aSequenceableCollection	"... creates a new type without registering it.  We build an intersection with the inherited constraint because any ALL EXCEPT constraint implicitly refer to the supertype. Furthermore, we programatically generate, and splice in, the constraint implicit in the list of elements.  The putatively more restrictive constraints cannot be placed first, for the default constraint is often a type check."	| elements parent constraint subconstraint |	elements := aSequenceableCollection collect: [ :x | x asAsn1Enumeration ].	subconstraint := ( anAsn1Constraint isNil )						ifTrue:	[ Asn1ConstraintEnumerated withAll: elements ]						ifFalse:	[ Asn1ConstraintIntersection									with: ( Asn1ConstraintEnumerated withAll: elements )									with: anAsn1Constraint ].	parent := anAsn1TypeOrNil.	constraint := ( parent isNil )						ifTrue:	[ subconstraint ]						ifFalse:	[ ASN1.Asn1ConstraintIntersection									with: parent constraint									with: subconstraint ].	^( self new )		constraint: constraint;		parent: parent;		symbol: aSymbol;		elements: elements;		yourself</body><body package="ASN1" selector="parent:symbol:">parent: anAsn1Type symbol: aSymbol	"... enumerated elements are required."	self shouldNotImplement</body></methods><methods><class-id>ASN1.Asn1TypeOBJECT_IDENTIFIER</class-id> <category>encoding</category><body package="ASN1" selector="encode:with:">encode: anAsn1ImportedOID with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	aMarshaler encodeOBJECT_IDENTIFIER: anAsn1ImportedOID</body><body package="ASN1" selector="tagBER">tagBER	"... avoid the namespace lookup."	^02r00000110	"ASN1.UniversalOBJECT_IDENTIFIER = 6"</body></methods><methods><class-id>ASN1.Asn1TypeOBJECT_IDENTIFIER</class-id> <category>decoding</category><body package="ASN1" selector="decode:with:">decode: anInteger with: aMarshaler	"... the method invoked when unmarshaling type-in-hand."	^aMarshaler decodeOBJECT_IDENTIFIER: anInteger</body></methods><methods><class-id>ASN1.Asn1TypeOBJECT_IDENTIFIER</class-id> <category>initialize-release</category><body package="ASN1" selector="initialize">initialize	super initialize.	wrap := false.</body></methods><methods><class-id>ASN1.Asn1TypeOBJECT_IDENTIFIER class</class-id> <category>defaults</category><body package="ASN1" selector="defaultConstraint">defaultConstraint	^Asn1ConstraintBlockClosure		with: [ :x | x class == Asn1OID ]</body><body package="ASN1" selector="defaultSymbol">defaultSymbol	^#'OBJECT IDENTIFIER'</body></methods><methods><class-id>ASN1.Asn1TypeEMBEDDED_PDV</class-id> <category>encoding</category><body package="ASN1" selector="tagBER">tagBER	"... avoid the namespace lookup."	^02r00001011	"ASN1.UniversalEMBEDDED_PDV = 11"</body></methods><methods><class-id>ASN1.Asn1TypeEMBEDDED_PDV class</class-id> <category>defaults</category><body package="ASN1" selector="defaultSymbol">defaultSymbol	^#'EMBEDDED PDV'</body></methods><methods><class-id>ASN1.Asn1TypeObjectDescriptor</class-id> <category>encoding</category><body package="ASN1" selector="tagBER">tagBER	"... avoid the namespace lookup."	^02r00000111	"ASN1.UniversalObjectDescriptor = 7"</body></methods><methods><class-id>ASN1.Asn1TypeObjectDescriptor class</class-id> <category>defaults</category><body package="ASN1" selector="defaultSymbol">defaultSymbol	^#'ObjectDescriptor'</body></methods><methods><class-id>ASN1.Asn1TypeBMPString</class-id> <category>encoding</category><body package="ASN1" selector="tagBER">tagBER	"... avoid the namespace lookup."	^02r00011110	"ASN1.UniversalBMPString = 30"</body></methods><methods><class-id>ASN1.Asn1TypeBMPString class</class-id> <category>defaults</category><body package="ASN1" selector="defaultSymbol">defaultSymbol	^#'BMPString'</body></methods><methods><class-id>ASN1.Asn1TypeUTF8String</class-id> <category>encoding</category><body package="ASN1" selector="tagBER">tagBER	"... avoid the namespace lookup."	^02r00001100	"ASN1.UniversalUTF8String = 12"</body></methods><methods><class-id>ASN1.Asn1TypeUTF8String class</class-id> <category>defaults</category><body package="ASN1" selector="defaultSymbol">defaultSymbol	^#'UTF8String'</body></methods><methods><class-id>ASN1.Asn1TypeGeneralString</class-id> <category>encoding</category><body package="ASN1" selector="tagBER">tagBER	"... avoid the namespace lookup."	^02r00011011	"ASN1.UniversalGeneralString = 27"</body></methods><methods><class-id>ASN1.Asn1TypeGeneralString class</class-id> <category>defaults</category><body package="ASN1" selector="defaultSymbol">defaultSymbol	^#'GeneralString'</body></methods><methods><class-id>ASN1.Asn1TypeGraphicString</class-id> <category>encoding</category><body package="ASN1" selector="tagBER">tagBER	"... avoid the namespace lookup."	^02r00011001	"ASN1.UniversalGraphicString = 25"</body></methods><methods><class-id>ASN1.Asn1TypeGraphicString class</class-id> <category>defaults</category><body package="ASN1" selector="defaultSymbol">defaultSymbol	^#'GraphicString'</body></methods><methods><class-id>ASN1.Asn1TypeCHARACTER_STRING</class-id> <category>encoding</category><body package="ASN1" selector="tagBER">tagBER	"... avoid the namespace lookup."	^02r00011101	"ASN1.UniversalCHARACTER_STRING = 29"</body></methods><methods><class-id>ASN1.Asn1TypeCHARACTER_STRING class</class-id> <category>defaults</category><body package="ASN1" selector="defaultSymbol">defaultSymbol	^#'CHARACTER STRING'</body></methods><methods><class-id>ASN1.Asn1TypeConstructed</class-id> <category>testing</category><body package="ASN1" selector="isConstructed">isConstructed	^true</body></methods><methods><class-id>ASN1.Asn1TypeStructured</class-id> <category>testing</category><body package="ASN1" selector="isExtensible">isExtensible	"Indicates whether the type may be extended in revisions of an originating ASN.1 type specifciation and include an ASN.1 extension marker."	^true</body><body package="ASN1" selector="isScoping">isScoping	"Indicates whether the type may override default tags by creating context-specific tags.  In principle, 'universal' and 'context-specific' tag classes are sufficient to disambiguate all tags.  Any ASN.1 compiler that produces instances or structures of Asn1Type is expected to do its job without relying on contexts that represent 'application' or 'private' tag classes."	^true</body><body package="ASN1" selector="isStructured">isStructured	^true</body></methods><methods><class-id>ASN1.Asn1TypeStructured</class-id> <category>accessing</category><body package="ASN1" selector="defaultOrOptionalCount">defaultOrOptionalCount	^( defaultOrOptionalCount isNil )		ifTrue:	[ self setDefaultOrOptionalCount ]		ifFalse:	[ defaultOrOptionalCount ]</body><body package="ASN1" selector="elements">elements	^elements</body><body package="ASN1" selector="elements:">elements: aSequenceableCollection	elements := aSequenceableCollection.	self clearPredicates</body><body package="ASN1" selector="extensionMarkerCount">extensionMarkerCount	^( extensionMarkerCount isNil )		ifTrue:	[ self setExtensionMarkerCount ]		ifFalse:	[ extensionMarkerCount ]</body><body package="ASN1" selector="minLength">minLength	^( minLength isNil )		ifTrue:	[ self setMinLength ]		ifFalse:	[ minLength ]</body></methods><methods><class-id>ASN1.Asn1TypeStructured</class-id> <category>instance registration api</category><body package="ASN1" selector="register:constraint:elements:">register: aSymbol constraint: anAsn1Constraint elements: aCollection	"... creates and registers a new Asn1StructuredType instance."	^self class registerType:		( self class			constraint: anAsn1Constraint			parent: self			symbol: aSymbol			elements: aCollection			yourself		)</body></methods><methods><class-id>ASN1.Asn1TypeStructured</class-id> <category>configuration api</category><body package="ASN1" selector="addElement:">addElement: anAsn1AbstractElement	elements addLast: anAsn1AbstractElement.	self clearPredicates</body><body package="ASN1" selector="removeElement:">removeElement: anAsn1AbstractElement	elements remove: anAsn1AbstractElement.	self clearPredicates</body></methods><methods><class-id>ASN1.Asn1TypeStructured</class-id> <category>private</category><body package="ASN1" selector="clearPredicates">clearPredicates	defaultOrOptionalCount := extensionMarkerCount := minLength := nil</body><body package="ASN1" selector="indexOfFirstExtensionMarkerOrEnd">indexOfFirstExtensionMarkerOrEnd	| es |	es := elements size.	1 to: elements size do: [ :n | ( ( elements at: n ) isExtensionMarker ) ifTrue: [ ^n ] ].	^es</body><body package="ASN1" selector="setDefaultOrOptionalCount">setDefaultOrOptionalCount	| n |	n := 0.	elements do: [ :e | ( e hasDefaultOrIsOptional ) ifTrue: [ n := n + 1 ] ].	^defaultOrOptionalCount := n</body><body package="ASN1" selector="setExtensionMarkerCount">setExtensionMarkerCount	| n |	n := 0.	elements do: [ :e | ( e isExtensionMarker ) ifTrue: [ n := n + 1 ] ].	^extensionMarkerCount := n</body><body package="ASN1" selector="setMinLength">setMinLength	"... sets the minimum length for aCollection marshaled under this type.  ... allows the marshaling of 'old' type definitions without subsequent extensions."	| num ind |	num := ind := self indexOfFirstExtensionMarkerOrEnd.	1 to: ind do:		[ :ndx |	| ele |				ele := elements at: ndx.				( ( ele hasDefaultOrIsOptional ) or: [ ele isExtensionMarker ] )					ifTrue:	[ num := num - 1 ]		].	^minLength := num</body></methods><methods><class-id>ASN1.Asn1TypeStructured</class-id> <category>initialize-release</category><body package="ASN1" selector="initialize">initialize	elements := OrderedCollection new: 7.</body></methods><methods><class-id>ASN1.Asn1TypeStructured</class-id> <category>encoding</category><body package="ASN1" selector="checkTypeOf:">checkTypeOf: anObject	| ocl |	ocl := anObject class.	( ( ocl == Association ) or: [ ocl == Asn1TypeWrapper ] )		ifFalse:	[ ^Asn1ExcMarshaling raiseSignal: self typeErrorMessage ].</body><body package="ASN1" selector="extractValueFrom:">extractValueFrom: anObject	| ocl |	ocl := anObject class.	^( ( ( ocl == Association ) or: [ ocl == Asn1TypeWrapper ] )		ifTrue: [ anObject value ]		ifFalse: [ anObject ] )</body></methods><methods><class-id>ASN1.Asn1TypeStructured</class-id> <category>validation</category><body package="ASN1" selector="permits:">permits: anObject	"... for the moment, only check the structured type constraints, and not the constraints on the individual elements.  The latter gets nearly as complicated as marshaling."	^super permits: anObject</body></methods><methods><class-id>ASN1.Asn1TypeStructured</class-id> <category>accessing - elements</category><body package="ASN1" selector="elementAtIndex:">elementAtIndex: anInteger	^self elements at: anInteger</body><body package="ASN1" selector="elementWithSymbol:">elementWithSymbol: aSymbol	^self elements detect: [ :x | x symbol == aSymbol ]</body><body package="ASN1" selector="elementWithTag:">elementWithTag: anInteger	"... use constant to avoid namespace lookup."	^self elements detect: [ :x | ( x tag bitAnd: 02r00011111 "ASN1.TagMaskNumber" ) == 									( anInteger bitAnd: 02r00011111 "ASN1.TagMaskNumber" ) ]</body></methods><methods><class-id>ASN1.Asn1TypeStructured</class-id> <category>testing - elements</category><body package="ASN1" selector="hasDefaultsOrOptionals">hasDefaultsOrOptionals	^( self defaultOrOptionalCount &gt; 0 )</body><body package="ASN1" selector="hasExtensionMarkers">hasExtensionMarkers	^( self extensionMarkerCount &gt; 0 )</body><body package="ASN1" selector="permitsLength:">permitsLength: anInteger	^( ( anInteger &lt;= self sizeSansExtensionMarkers )		and: [ anInteger &gt;= self minLength ] )</body><body package="ASN1" selector="sizeSansExtensionMarkers">sizeSansExtensionMarkers	^( elements size - self extensionMarkerCount )</body></methods><methods><class-id>ASN1.Asn1TypeStructured class</class-id> <category>private</category><body package="ASN1" selector="constraint:parent:symbol:elements:">constraint: anAsn1Constraint parent: anAsn1TypeOrNil symbol: aSymbol elements: aSequenceableCollection	"... creates a new type without registering it.  We build an intersection with the inherited constraint because any ALL EXCEPT constraint implicitly refer to the supertype.  The putatively more restrictive constraint cannot be placed first, for it is often a type restriction."	| parent constraint |	parent := anAsn1TypeOrNil.	constraint := ( parent isNil )						ifTrue:	[ anAsn1Constraint ]						ifFalse:	[ ASN1.Asn1ConstraintIntersection									with: parent constraint									with: anAsn1Constraint ].	^( self new )		constraint: constraint;		parent: parent;		symbol: aSymbol;		elements: aSequenceableCollection;		yourself</body></methods><methods><class-id>ASN1.Asn1TypeStructured class</class-id> <category>instance registration api</category><body package="ASN1" selector="register:constraint:elements:">register: aSymbol constraint: anAsn1Constraint elements: aCollection	"... creates and registers a new Asn1StructuredType instance."	^self registerType:		( self			constraint: anAsn1Constraint			parent: self default			symbol: aSymbol			elements: aCollection			yourself		)</body></methods><methods><class-id>ASN1.Asn1TypeSEQUENCE</class-id> <category>encoding</category><body package="ASN1" selector="encode:with:">encode: aSequenceableCollection with: aMarshaler	"... the method invoked when unmarshaling type-in-hand.  ... performs an initial size check, the branches on stored parameters to case-optimized loops."	| bem bdo |	( self permitsLength: aSequenceableCollection size )		ifFalse:	[ Asn1ExcMarshaling					raiseSignal: ( #badObjectLengthForSEQUENCEType &lt;&lt; #opentalk &gt;&gt; 'Bad object length for SEQUENCE type!' ) ].	bem:= self hasExtensionMarkers.	bdo := self hasDefaultsOrOptionals.	^( bdo )		ifTrue:	[	( bem )						ifTrue:	[ self encodeCase4: aSequenceableCollection with: aMarshaler ]						ifFalse:	[ self encodeCase3: aSequenceableCollection with: aMarshaler ]				]		ifFalse:	[	( bem )						ifTrue:	[ self encodeCase2: aSequenceableCollection with: aMarshaler ]						ifFalse:	[ self encodeCase1: aSequenceableCollection with: aMarshaler ]				]</body><body package="ASN1" selector="encodeCase1:with:">encodeCase1: aSequenceableCollection with: aMarshaler	"Case 1: The type element collection has no extension markers and either [1] has no DEFAULTs or OPTIONALs or [2] has DEFAULTs or OPTIONALs but aSequenceableCollection has no missing elements."	1 to: aSequenceableCollection size do:		[ :ndx |	aMarshaler					encodeTLV: ( self extractValueFrom: ( aSequenceableCollection at: ndx ) )					withElement: ( elements at: ndx )		]</body><body package="ASN1" selector="encodeCase2:with:">encodeCase2: aSequenceableCollection with: aMarshaler	"Case 2: The type element collection has extension markers,  but either [1] has no DEFAULTs or OPTIONALs, or [2] has DEFAULTs or OPTIONALs but aSequenceableCollection has no missing elements.  Watch only for the extension markers as we go through the type elements.  Assume that one extension marker is never followed immediately by another (except at the very end).  This implies that an 'increment' rather than a 'while loop' is sufficient for the potentially required advance.  ... must support terminal and non-terminal extension markers."	| es en |	es := elements size.	en := 0.	1 to: aSequenceableCollection size do:		[ :ndx |	| ele |				ele := elements at: ( en := en + 1 ).				( ( ele isExtensionMarker ) and: [ en &lt; es ] )					ifTrue: [ ele := elements at: ( en := en + 1 ) ].				aMarshaler					encodeTLV: ( self extractValueFrom: ( aSequenceableCollection at: ndx ) )					withElement: ele		]</body><body package="ASN1" selector="encodeCase3:with:">encodeCase3: aSequenceableCollection with: aMarshaler	"Case 3:  The type element collection has no extension markers but does have DEFAULTs or OPTIONALs.  Check the relative sizes to discriminate further."	^( aSequenceableCollection size = elements size )		ifTrue:	[ self encodeCase1: aSequenceableCollection with: aMarshaler ]		ifFalse:	[ self encodeCase3f: aSequenceableCollection with: aMarshaler ]</body><body package="ASN1" selector="encodeCase3f:with:">encodeCase3f: aSequenceableCollection with: aMarshaler	"Case 3f: The type element collection has DEFAULTs or OPTIONALs, but no extension markers, and the type element collection is not the same size as the OrderedCollection being marshaled.  This implies that values are not provided for all DEFAULTs and OPTIONALs and that disambiguation is required.  We explicitly require that all elements of the SequenceableCollection be Associations or Asn1TypeWrappers so that marshaling will be unambiguous.  We implicitly enforce correct ordering in the SequenceableCollection by using a key-symbol match to skip OPTIONALs and DEFAULTs."	| cn cs obj retain |	cn := 0.	cs := aSequenceableCollection size.	retain := false.	elements do:		[ :ele |	( ( retain not ) and: [ cn &lt; cs ] )					ifTrue:	[	obj := aSequenceableCollection at: ( cn := cn + 1 ).								self checkTypeOf: obj							].				( obj key == ele symbol )					ifTrue:	[	retain := false.								aMarshaler									encodeTLV: obj value									withElement: ele							]					ifFalse:	[	( ele hasDefault )									ifTrue:	[	retain := true.												aMarshaler													encodeTLV: ele default													withElement: ele											]									ifFalse:	[	( ele isOptional )													ifTrue: [ retain := true ]													ifFalse:	[ ^Asn1ExcMarshaling raiseSignal: (#tagMismatchUnderTypeInHandEncoding &lt;&lt; #opentalk &gt;&gt; 'Key mismatch under type-in-hand encoding!') ]											]							]		]</body><body package="ASN1" selector="encodeCase4:with:">encodeCase4: aSequenceableCollection with: aMarshaler	"Case 4:  The type element collection has both extension markers and DEFAULTs or OPTIONALs.  Check the relative sizes to discriminate further."	^( aSequenceableCollection size = self sizeSansExtensionMarkers )		ifTrue:	[ self encodeCase2: aSequenceableCollection with: aMarshaler ]		ifFalse:	[ self encodeCase4f: aSequenceableCollection with: aMarshaler ]</body><body package="ASN1" selector="encodeCase4f:with:">encodeCase4f: aSequenceableCollection with: aMarshaler	"Case 4f: The type element collection has DEFAULTs or OPTIONALs, and extension markers, and the type element collection is not the same size as the OrderedCollection being marshaled.  This implies that values are not provided for all DEFAULTs and OPTIONALs, or that some extensions are not being marshaled and that disambiguation is required.  In this case, we explicitly require that all non-marker elements of the OrderedCollection be Associations or Asn1TypeWrappers so that marshaling will be unambiguous.  We implicitly enforce correct ordering in the OrderedCollection by using a key-symbol match to skip OPTIONALs and DEFAULTs."	| en |	en := 0.	1 to: aSequenceableCollection size do:		[ :ndx |	| obj ele |				obj := aSequenceableCollection at: ndx.				self checkTypeOf: obj.				[	ele := elements at: ( en := en + 1 ).					( obj key ~~ ele symbol )				] whileTrue.				aMarshaler					encodeTLV: obj value					withElement: ele		]</body><body package="ASN1" selector="tagBER">tagBER	"... avoid the namespace lookup."	^02r00110000	"ASN1.ConstructedSEQUENCE = 48"</body><body package="ASN1" selector="typeErrorMessage">typeErrorMessage	"... a 'helper' method."	^( #associationsOrWrappersNeededForSEQUENCE &lt;&lt; #opentalk &gt;&gt; 'A collection of Associations or Asn1TypeWrappers is needed to disambiguate the marshaling of this SEQUENCE type!' )</body></methods><methods><class-id>ASN1.Asn1TypeSEQUENCE</class-id> <category>decoding</category><body package="ASN1" selector="decode:with:">decode: anInteger with: aMarshaler	"... the method invoked when unmarshaling type-in-hand."	| res bem bdo |	bem:= self hasExtensionMarkers.	bdo := self hasDefaultsOrOptionals.	res := ( bdo )			ifTrue:	[	( bem )							ifTrue:	[ self decodeCase4: anInteger with: aMarshaler ]							ifFalse:	[ self decodeCase3: anInteger with: aMarshaler ]					]			ifFalse:	[	( bem )							ifTrue:	[ self decodeCase2: anInteger with: aMarshaler ]							ifFalse:	[ self decodeCase1: anInteger with: aMarshaler ]					].	^res structName: self symbol; yourself</body><body package="ASN1" selector="decodeCase1:with:">decodeCase1: anInteger with: aMarshaler	"Case 1: The type element collection has no extension markers and no DEFAULTs or OPTIONALs."	| str |	str := Asn1Struct new: 11.	elements do: [ :ele | str add: ( ele symbol -&gt; ( aMarshaler decodeTLV_Element: ele ) ) ].	^str structName: self symbol; yourself</body><body package="ASN1" selector="decodeCase2:with:">decodeCase2: anInteger with: aMarshaler	"Case 2: The type element collection has extension markers but no DEFAULTs or OPTIONALs.  ... must support terminal and non-terminal extension markers.  This implies handling additional octets after a terminal extension marker and an end to the octets after a non-terminal extension marker.  Assume that an extension marker is never followed by another extension marker."	| str en es tpos |	str := Asn1Struct new: 11.	en := 0.	es := elements size.	tpos := aMarshaler position + anInteger.	[	en := en + 1.		en &lt;= es	] whileTrue:		[	| ele |			ele := elements at: en.			( ele isExtensionMarker )				ifTrue:	[ ( aMarshaler position = tpos ) ifTrue: [ en := es ] ]				ifFalse:	[ str add: ele symbol -&gt; ( aMarshaler decodeTLV_Element: ele ) ].		].	"... skip ahead if there was a terminal extension marker."	( tpos &gt; aMarshaler position )		ifTrue:	[ ( elements last isExtensionMarker )					ifTrue:	[ aMarshaler position: tpos ]					ifFalse:	[ ^Asn1ExcMarshaling raiseSignal: (#genericUnmarshalingError &lt;&lt; #opentalk &gt;&gt; 'Unmarshaling error!') ]				].	^str</body><body package="ASN1" selector="decodeCase3:with:">decodeCase3: anInteger with: aMarshaler	"Case 3: The type element collection has DEFAULTs or OPTIONALs but no extension markers.  ... must handle one or more terminal DEFAULTs or OPTIONALs"	| str tpos retain tag itag |	str := Asn1Struct new: 11.	retain := false.	tpos := aMarshaler position + anInteger.	elements do: [ :ele |		( ele type class == Asn1TypeANY )			ifTrue:	[ 	( aMarshaler position &lt; tpos )							ifTrue:	[ str add: ele symbol -&gt; ( aMarshaler decodeTLV ) ]					]			ifFalse:	[	( ele type class == Asn1TypeCHOICE )							ifTrue:	[	( aMarshaler position &lt; tpos )											ifTrue:	[ str add: ele symbol -&gt; ( aMarshaler decodeTLV_Choice: ele type ) ]									]							ifFalse:	[	tag := aMarshaler asTag: ele tag.										( retain )											ifFalse:	[	( aMarshaler position &lt; tpos )															ifTrue:	[	aMarshaler beginEncodings.																		itag := aMarshaler nextTag																	]																												].										( itag = tag )											ifTrue:	[	( aMarshaler position &lt; tpos )															ifTrue: [ str add: ele symbol -&gt; ( aMarshaler decodeLV_Element: ele ) ].														retain := false.													]											ifFalse:	[	( ele hasDefault )															ifTrue:	[	str add: ( ele symbol -&gt; ele default ).																		retain := true.																	]															ifFalse:	[	( ele isOptional )																			ifTrue:	[ retain := true ]																			ifFalse:	[ ^Asn1ExcMarshaling raiseSignal: (#tagMismatchUnderTypeInHandDecoding &lt;&lt; #opentalk &gt;&gt; 'Tag mismatch under type-in-hand decoding!')																					]																	]													]								]				]	].	^str</body><body package="ASN1" selector="decodeCase4:with:">decodeCase4: anInteger with: aMarshaler	"Case 4: The type element collection has both extension markers and DEFAULTs or OPTIONALs."	| str en es tpos retain |	str := Asn1Struct new: 11.	en := 0.	es := elements size.	tpos := aMarshaler position + anInteger.	retain := false.	[	en := en + 1.		en &lt;= es	] whileTrue:		[	| ele |			ele := elements at: en.			( ele isExtensionMarker )				ifTrue:	[ ( aMarshaler position = tpos ) ifTrue: [ en := es ]						]				ifFalse:	[	| tag itag |							( ele type class == Asn1TypeANY )								ifTrue:	[ 	( aMarshaler position &lt; tpos )												ifTrue:	[ str add: ele symbol -&gt; ( aMarshaler decodeTLV ) ]										]								ifFalse:	[	( ele type class == Asn1TypeCHOICE )												ifTrue:	[	( aMarshaler position &lt; tpos )																ifTrue:	[ str add: ele symbol -&gt; ( aMarshaler decodeTLV_Choice: ele type ) ]										]												ifFalse:	[	tag := aMarshaler asTag: ele tag.															( retain )																ifFalse:	[	( aMarshaler position &lt; tpos )																				ifTrue:	[	aMarshaler beginEncodings.																							itag := aMarshaler nextTag																						]																						].															( itag = tag )																ifTrue:	[	( aMarshaler position &lt; tpos )																				ifTrue:	[ str add: ele symbol -&gt; ( aMarshaler decodeLV_Element: ele ) ].																			retain := false.																		]																ifFalse:	[	( ( ele isOptional ) or: [ ele hasDefault ] )																				ifTrue:	[ retain := true ]																				ifFalse:	[ ^Asn1ExcMarshaling raiseSignal: (#tagMismatchUnderTypeInHandDecoding &lt;&lt; #opentalk &gt;&gt; 'Tag mismatch under type-in-hand decoding!') ]																						]																				]														]										]		].	( tpos &gt; aMarshaler position )		ifTrue:	[ ( elements last isExtensionMarker )					ifTrue:	[ aMarshaler position: tpos ]					ifFalse:	[ ^Asn1ExcMarshaling raiseSignal: (#genericUnmarshalingError &lt;&lt; #opentalk &gt;&gt; 'Unmarshaling error!') ]				].	^str</body></methods><methods><class-id>ASN1.Asn1TypeSEQUENCE class</class-id> <category>defaults</category><body package="ASN1" selector="defaultConstraint">defaultConstraint	^Asn1ConstraintBlockClosure		with: [ :x | x class == OrderedCollection ]</body><body package="ASN1" selector="defaultSymbol">defaultSymbol	^#'SEQUENCE'</body></methods><methods><class-id>ASN1.Asn1TypeUnstructured</class-id> <category>accessing</category><body package="ASN1" selector="elementType">elementType	^elementType</body><body package="ASN1" selector="elementType:">elementType: aASN1Type	elementType := aASN1Type</body></methods><methods><class-id>ASN1.Asn1TypeUnstructured</class-id> <category>instance registration api</category><body package="ASN1" selector="register:constraint:elementType:">register: aSymbol constraint: anAsn1Constraint elementType: anAsn1Type	"... creates and registers a new Asn1StructuredType instance."	^self registerType:		( self class			constraint: anAsn1Constraint			parent: self			symbol: aSymbol			elementType: anAsn1Type			yourself		)</body></methods><methods><class-id>ASN1.Asn1TypeUnstructured class</class-id> <category>private</category><body package="ASN1" selector="constraint:parent:symbol:elementType:">constraint: anAsn1Constraint parent: anAsn1TypeOrNil symbol: aSymbol elementType: anAsn1Type	"... creates a new type without registering it.  We build an intersection with the inherited constraint because any ALL EXCEPT constraint implicitly refer to the supertype.  The putatively more restrictive constraint cannot be placed first, for it is often a type restriction."	| parent constraint |	parent := anAsn1TypeOrNil.	constraint := ( parent isNil )						ifTrue:	[ anAsn1Constraint ]						ifFalse:	[ ASN1.Asn1ConstraintIntersection									with: parent constraint									with: anAsn1Constraint ].	^( self new )		constraint: constraint;		parent: parent;		symbol: aSymbol;		elementType: anAsn1Type;		yourself</body></methods><methods><class-id>ASN1.Asn1TypeUnstructured class</class-id> <category>instance registration api</category><body package="ASN1" selector="register:constraint:elementType:">register: aSymbol constraint: anAsn1Constraint elementType: anAsn1Type	"... creates and registers a new Asn1StructuredType instance."	^self registerType:		( self			constraint: anAsn1Constraint			parent: self default			symbol: aSymbol			elementType: anAsn1Type			yourself		)</body></methods><methods><class-id>ASN1.Asn1TypeSET</class-id> <category>decoding</category><body package="ASN1" selector="decode:with:">decode: anInteger with: aMarshaler	"... the method invoked when unmarshaling type-in-hand."	| str tpos |	str := Asn1Struct new: 11.	tpos := aMarshaler position + anInteger.	[ aMarshaler position &lt; tpos ]		whileTrue:			[	| ele |				aMarshaler beginEncodings.				ele := self deriveElementFrom: ( aMarshaler nextTag ).				str add: ( ele key -&gt; ( aMarshaler decodeLV_Element: ele ) )			].	^str structName: self symbol; yourself</body><body package="ASN1" selector="deriveElementFrom:">deriveElementFrom: anInteger	"... a 'helper' method."	^self decodingDictionary		at: anInteger		ifAbsent: [ ^Asn1ExcMarshaling					raiseSignal: (#PrivateOrUniversalTagMismatchUnderTypeInHandDecoding &lt;&lt; #opentalk &gt;&gt; 'Private or universal tag mismatch under type-in-hand decoding!') ]</body></methods><methods><class-id>ASN1.Asn1TypeSET</class-id> <category>accessing</category><body package="ASN1" selector="decodingDictionary">decodingDictionary	^( decodingDictionary isNil )		ifTrue:	[ self setDecodingDictionary ]		ifFalse:	[ decodingDictionary ]</body><body package="ASN1" selector="encodingDictionary">encodingDictionary	^( encodingDictionary isNil )		ifTrue:	[ self setEncodingDictionary ]		ifFalse:	[ encodingDictionary ]</body></methods><methods><class-id>ASN1.Asn1TypeSET</class-id> <category>private</category><body package="ASN1" selector="clearPredicates">clearPredicates	super clearPredicates.	decodingDictionary := encodingDictionary := nil</body><body package="ASN1" selector="setDecodingDictionary">setDecodingDictionary	| dict |	dict := Dictionary new: elements size.	elements do: [ :ele | dict add: ele tag -&gt; ele ].	^decodingDictionary := dict</body><body package="ASN1" selector="setEncodingDictionary">setEncodingDictionary	| dict |	dict := Dictionary new: elements size.	elements do: [ :ele | dict add: ele symbol -&gt; ele ].	^encodingDictionary := dict</body></methods><methods><class-id>ASN1.Asn1TypeSET</class-id> <category>configuration api</category><body package="ASN1" selector="addElement:">addElement: anAsn1AbstractElement	super addElement: anAsn1AbstractElement.	self class validate: self</body></methods><methods><class-id>ASN1.Asn1TypeSET</class-id> <category>encoding</category><body package="ASN1" selector="encode:with:">encode: aSetOrDictionary with: aMarshaler	"... the method invoked when marshaling type-in-hand.  ... performs an initial size check.  ... performs an initial type translation."	| mc |	( self permitsLength: aSetOrDictionary size )		ifFalse:	[ Asn1ExcMarshaling					raiseSignal: ( #badObjectLengthForSETType &lt;&lt; #opentalk &gt;&gt; 'Bad object length for SET type!' ) ].	mc := ( aSetOrDictionary isKindOf: Dictionary )			ifTrue:	[ aSetOrDictionary associations ]			ifFalse:	[ aSetOrDictionary ].	( aMarshaler requiresTagSort )		ifTrue:	[ mc := SortedCollection withAll: mc sortBlock: [:x :y | x value tagBER &lt;= y value tagBER ] ].	mc do:		[ :o |	self checkTypeOf: o.				aMarshaler					encodeTLV: ( o value )					withElement: ( self encodingDictionary at: o key )		]</body><body package="ASN1" selector="tagBER">tagBER	"... avoid the namespace lookup."	^02r00110001	"ASN1.ConstructedSET = 49"</body><body package="ASN1" selector="typeErrorMessage">typeErrorMessage	"... a 'helper' method."	^( #associationsOrWrappersNeededForSET &lt;&lt; #opentalk &gt;&gt; 'A collection of Associations or Asn1TypeWrappers is needed to disambiguate the marshaling of SETs!' )</body></methods><methods><class-id>ASN1.Asn1TypeSET class</class-id> <category>defaults</category><body package="ASN1" selector="defaultConstraint">defaultConstraint	^Asn1ConstraintBlockClosure		with: [ :x | x class == OrderedCollection ]</body><body package="ASN1" selector="defaultSymbol">defaultSymbol	^#'SET'</body></methods><methods><class-id>ASN1.Asn1TypeSET class</class-id> <category>instance registration api</category><body package="ASN1" selector="register:constraint:elements:">register: aSymbol constraint: anAsn1Constraint elements: aCollection	"... creates and registers a new Asn1StructuredType instance."	| n |	n := self			constraint: anAsn1Constraint			parent: self default			symbol: aSymbol			elements: aCollection			yourself.	self validate: n.	^self registerType: n</body></methods><methods><class-id>ASN1.Asn1TypeSET class</class-id> <category>validation</category><body package="ASN1" selector="validate:">validate: anAsn1TypeSET	"SET elements must have unique tags."	| s |	s := ( anAsn1TypeSET elements collect: [ :x | x tag ] ) asSet.	( s size =  anAsn1TypeSET elements size )		ifFalse:	[ ^Asn1ExcTypeSpecification raiseSignal: (#setElementsMustHaveUniqueTags &lt;&lt; #opentalk &gt;&gt; 'Asn1TypeSET elements must have unique tags!') ]</body></methods><methods><class-id>ASN1.Asn1TypeEXTERNAL</class-id> <category>encoding</category><body package="ASN1" selector="tagBER">tagBER	"... avoid the namespace lookup."	^02r00001000	"ASN1.UniversalEXTERNAL = 8"</body></methods><methods><class-id>ASN1.Asn1TypeEXTERNAL class</class-id> <category>defaults</category><body package="ASN1" selector="defaultSymbol">defaultSymbol	^#'EXTERNAL'</body></methods><methods><class-id>ASN1.Asn1TypeRELATIVE_OID</class-id> <category>encoding</category><body package="ASN1" selector="tagBER">tagBER	"... avoid the namespace lookup."	^02r00001101	"ASN1.UniversalRELATIVE_OID = 13"</body></methods><methods><class-id>ASN1.Asn1TypeRELATIVE_OID class</class-id> <category>defaults</category><body package="ASN1" selector="defaultSymbol">defaultSymbol	^#'RELATIVE-OID'</body></methods><methods><class-id>ASN1.Asn1TypeCHOICE</class-id> <category>instance registration api</category><body package="ASN1" selector="register:elements:">register: aSymbol elements: aCollection	"... creates and registers a new Asn1StructuredType instance."	^self class registerType:		( self class			parent: self			symbol: aSymbol			elements: aCollection		)</body></methods><methods><class-id>ASN1.Asn1TypeCHOICE</class-id> <category>accessing</category><body package="ASN1" selector="tags">tags	^( tags isNil )		ifTrue:	[ self setTags ]		ifFalse:	[ tags ]</body></methods><methods><class-id>ASN1.Asn1TypeCHOICE</class-id> <category>private</category><body package="ASN1" selector="clearPredicates">clearPredicates	super clearPredicates.	tags := nil</body><body package="ASN1" selector="setTags">setTags	"... sweat to avoid a 'grow'."	| s |	s := Set new: ( elements size * 3 // 2 ).	elements do: [ :e | ( e isExtensionMarker ) ifFalse: [ s add: e tag ] ].	^tags := s</body></methods><methods><class-id>ASN1.Asn1TypeCHOICE</class-id> <category>encoding</category><body package="ASN1" selector="encode:with:">encode: anAsn1ImportedChoice with: aMarshaler	aMarshaler encodeTLV: anAsn1ImportedChoice value withElement: ( self elementWithTag: anAsn1ImportedChoice choice )</body></methods><methods><class-id>ASN1.Asn1TypeCHOICE</class-id> <category>initialize-release</category><body package="ASN1" selector="initialize">initialize	super initialize.	wrap := false.</body></methods><methods><class-id>ASN1.Asn1TypeCHOICE class</class-id> <category>defaults</category><body package="ASN1" selector="defaultConstraint">defaultConstraint	^Asn1ConstraintNull new</body><body package="ASN1" selector="defaultSymbol">defaultSymbol	^#'CHOICE'</body></methods><methods><class-id>ASN1.Asn1TypeCHOICE class</class-id> <category>instance registration api</category><body package="ASN1" selector="register:elements:">register: aSymbol elements: aCollection	"... creates and registers a new Asn1StructuredType instance."	^self registerType:		( self			parent: self default			symbol: aSymbol			elements: aCollection		)</body></methods><methods><class-id>ASN1.Asn1TypeCHOICE class</class-id> <category>private</category><body package="ASN1" selector="parent:symbol:elements:">parent: anAsn1TypeOrNil symbol: aSymbol elements: aSequenceableCollection	"... creates a new type without registering it.  We always enter a 'null' constraint because choices, in the relevant sense, do not have constraints."	^( self new )		constraint: Asn1ConstraintNull new;		parent: anAsn1TypeOrNil;		symbol: aSymbol;		elements: aSequenceableCollection;		yourself</body></methods><methods><class-id>ASN1.Asn1TypeSET_OF</class-id> <category>encoding</category><body package="ASN1" selector="encode:with:">encode: aSet with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	"... see the method comment of 'encodeSETorSET_OF:'."	aMarshaler encodeSETorSET_OF: aSet</body><body package="ASN1" selector="tagBER">tagBER	"... avoid the namespace lookup."	^02r00110001	"ASN1.ConstructedSET = 49"</body></methods><methods><class-id>ASN1.Asn1TypeSET_OF</class-id> <category>decoding</category><body package="ASN1" selector="decode:with:">decode: anInteger with: aMarshaler	"... the method invoked when unmarshaling type-in-hand."	^( elementType isNil )		ifTrue:	[ aMarshaler decodeSETorSET_OF: anInteger ]		ifFalse:	[	| oc tpos |					oc := OrderedCollection new: 11.					tpos := aMarshaler position + anInteger.					[ aMarshaler position &lt; tpos ]						whileTrue: [ oc add: ( aMarshaler decodeTLV_Type: elementType ) ].					oc				]</body></methods><methods><class-id>ASN1.Asn1TypeSET_OF class</class-id> <category>defaults</category><body package="ASN1" selector="defaultConstraint">defaultConstraint	^Asn1ConstraintBlockClosure		with: [ :x | x class == OrderedCollection ]</body><body package="ASN1" selector="defaultSymbol">defaultSymbol	^#'SET OF'</body></methods><methods><class-id>ASN1.Asn1TypeANY</class-id> <category>encoding</category><body package="ASN1" selector="tagBER">tagBER	^nil</body></methods><methods><class-id>ASN1.Asn1TypeANY class</class-id> <category>defaults</category><body package="ASN1" selector="defaultConstraint">defaultConstraint	^Asn1ConstraintNull default</body><body package="ASN1" selector="defaultSymbol">defaultSymbol	^#ANY</body></methods><methods><class-id>ASN1.Asn1TypeVideotexString</class-id> <category>encoding</category><body package="ASN1" selector="encode:with:">encode: anObject with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	self obsoleteType</body><body package="ASN1" selector="tagBER">tagBER	"... avoid the namespace lookup."	^02r00010101	"ASN1.UniversalVideotexString = 21"</body></methods><methods><class-id>ASN1.Asn1TypeVideotexString class</class-id> <category>defaults</category><body package="ASN1" selector="defaultSymbol">defaultSymbol	^#'VideotexString'</body></methods><methods><class-id>ASN1.Asn1TypeBIT_STRING</class-id> <category>decoding</category><body package="ASN1" selector="decode:with:">decode: anInteger with: aMarshaler	"... the method invoked when unmarshaling type-in-hand."	^aMarshaler decodeBIT_STRING: anInteger</body></methods><methods><class-id>ASN1.Asn1TypeBIT_STRING</class-id> <category>initialize-release</category><body package="ASN1" selector="initialize">initialize	super initialize.	wrap := false</body></methods><methods><class-id>ASN1.Asn1TypeBIT_STRING</class-id> <category>encoding</category><body package="ASN1" selector="tagBER">tagBER	"... avoid the namespace lookup."	^02r00000011	"ASN1.UniversalBIT_STRING = 3"</body></methods><methods><class-id>ASN1.Asn1TypeBIT_STRING class</class-id> <category>defaults</category><body package="ASN1" selector="defaultConstraint">defaultConstraint	^Asn1ConstraintBlockClosure		with: [ :x | x class == Asn1TypeBIT_STRING ]</body><body package="ASN1" selector="defaultSymbol">defaultSymbol	^#'BIT STRING'</body></methods><methods><class-id>ASN1.Asn1TypeINTEGER</class-id> <category>encoding</category><body package="ASN1" selector="encode:with:">encode: anInteger with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	aMarshaler encodeINTEGER: anInteger</body><body package="ASN1" selector="tagBER">tagBER	"... avoid the namespace lookup."	^02r00000010	"ASN1.UniversalINTEGER = 2"</body></methods><methods><class-id>ASN1.Asn1TypeINTEGER</class-id> <category>decoding</category><body package="ASN1" selector="decode:with:">decode: anInteger with: aMarshaler	"... the method invoked when unmarshaling type-in-hand."	^aMarshaler decodeINTEGER: anInteger</body></methods><methods><class-id>ASN1.Asn1TypeINTEGER</class-id> <category>instance registration api</category><body package="ASN1" selector="register:constraint:elements:">register: aSymbol constraint: anAsn1Constraint elements: aSequenceableCollection	"... creates and registers a new Asn1INTEGER instance that has been defined using the enumerative form, exempli gratia:		ErrorCode := INTEGER { disk-full(1), no-disk(2), disk-not-formatted(3) }	"	^self class registerType:		( self class			constraint: anAsn1Constraint			parent: self			symbol: aSymbol			elements: aSequenceableCollection			yourself		)</body><body package="ASN1" selector="register:elements:">register: aSymbol elements: aSequenceableCollection	"... creates and registers a new Asn1INTEGER instance that has been defined using the enumerative form, exempli gratia:		ErrorCode := INTEGER { disk-full(1), no-disk(2), disk-not-formatted(3) }	"	^self class registerType:		( self class			constraint: nil			parent: self			symbol: aSymbol			elements: aSequenceableCollection			yourself		)</body></methods><methods><class-id>ASN1.Asn1TypeINTEGER class</class-id> <category>defaults</category><body package="ASN1" selector="defaultConstraint">defaultConstraint	^Asn1ConstraintBlockClosure		with: [ :x | x isKindOf: Integer ]</body><body package="ASN1" selector="defaultSymbol">defaultSymbol	^#'INTEGER'</body></methods><methods><class-id>ASN1.Asn1TypeINTEGER class</class-id> <category>instance registration api</category><body package="ASN1" selector="register:constraint:elements:">register: aSymbol constraint: anAsn1Constraint elements: aSequenceableCollection	"... creates and registers a new Asn1INTEGER instance that has been defined using the enumerative form, exempli gratia:		ErrorCode := INTEGER { disk-full(1), no-disk(2), disk-not-formatted(3) }	"	^self registerType:		( self			constraint: anAsn1Constraint			parent: self default			symbol: aSymbol			elements: aSequenceableCollection			yourself		)</body><body package="ASN1" selector="register:elements:">register: aSymbol elements: aSequenceableCollection	"... creates and registers a new Asn1INTEGER instance that has been defined using the enumerative form, exempli gratia:		ErrorCode := INTEGER { disk-full(1), no-disk(2), disk-not-formatted(3) }	"	^self registerType:		( self			constraint: nil			parent: self default			symbol: aSymbol			elements: aSequenceableCollection			yourself		)</body></methods><methods><class-id>ASN1.Asn1TypeINTEGER class</class-id> <category>private</category><body package="ASN1" selector="constraint:parent:symbol:elements:">constraint: anAsn1Constraint parent: anAsn1TypeOrNil symbol: aSymbol elements: aSequenceableCollection	"... creates a new INTEGER type that has been defined using the enumerative form, without registering it.  We build an intersection with the inherited constraint because any ALL EXCEPT constraint implicitly refer to the supertype. Furthermore, we programatically generate, and splice in, the constraint implicit in the list of elements.  The putatively more restrictive constraints cannot be placed first, for the default constraint is often a type check."	| elements parent constraint subconstraint |	elements := aSequenceableCollection collect: [ :x | x asAsn1Enumeration ].	subconstraint := ( anAsn1Constraint isNil )						ifTrue:	[ Asn1ConstraintEnumerated withAll: elements ]						ifFalse:	[ Asn1ConstraintIntersection									with: ( Asn1ConstraintEnumerated withAll: elements )									with: anAsn1Constraint ].	parent := anAsn1TypeOrNil.	constraint := ( parent isNil )						ifTrue:	[ subconstraint ]						ifFalse:	[ ASN1.Asn1ConstraintIntersection									with: parent constraint									with: subconstraint ].	^( self new )		constraint: constraint;		parent: parent;		symbol: aSymbol;		yourself</body></methods><methods><class-id>ASN1.Asn1TypeUniversalString</class-id> <category>encoding</category><body package="ASN1" selector="tagBER">tagBER	"... avoid the namespace lookup."	^02r00011100	"ASN1.UniversalUniversalString = 28"</body></methods><methods><class-id>ASN1.Asn1TypeUniversalString class</class-id> <category>defaults</category><body package="ASN1" selector="defaultSymbol">defaultSymbol	^#'UniversalString'</body></methods><methods><class-id>ASN1.Asn1TypeOCTET_STRING</class-id> <category>encoding</category><body package="ASN1" selector="encode:with:">encode: aByteArray with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	aMarshaler encodeOCTET_STRING: aByteArray</body><body package="ASN1" selector="tagBER">tagBER	"... avoid the namespace lookup."	^02r00000100	"ASN1.UniversalOCTET_STRING = 4"</body></methods><methods><class-id>ASN1.Asn1TypeOCTET_STRING</class-id> <category>decoding</category><body package="ASN1" selector="decode:with:">decode: anInteger with: aMarshaler	"... the method invoked when unmarshaling type-in-hand."	^aMarshaler decodeOCTET_STRING: anInteger</body></methods><methods><class-id>ASN1.Asn1TypeOCTET_STRING class</class-id> <category>defaults</category><body package="ASN1" selector="defaultConstraint">defaultConstraint	^Asn1ConstraintBlockClosure		with: [ :x | x isKindOf: ByteArray ]</body><body package="ASN1" selector="defaultSymbol">defaultSymbol	^#'OCTET STRING'</body></methods><methods><class-id>ASN1.Asn1TypeBOOLEAN</class-id> <category>encoding</category><body package="ASN1" selector="encode:with:">encode: aBoolean with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	aMarshaler encodeBOOLEAN: aBoolean</body><body package="ASN1" selector="tagBER">tagBER	"... avoid the namespace lookup."	^02r00000001	"ASN1.UniversalBOOLEAN = 1"</body></methods><methods><class-id>ASN1.Asn1TypeBOOLEAN</class-id> <category>decoding</category><body package="ASN1" selector="decode:with:">decode: anInteger with: aMarshaler	"... the method invoked when unmarshaling type-in-hand."	^aMarshaler decodeBOOLEAN: anInteger</body></methods><methods><class-id>ASN1.Asn1TypeBOOLEAN class</class-id> <category>defaults</category><body package="ASN1" selector="defaultConstraint">defaultConstraint	^Asn1ConstraintBlockClosure		with: [ :x | x == true or: [ x == false ] ]</body><body package="ASN1" selector="defaultSymbol">defaultSymbol	^#'BOOLEAN'</body></methods><methods><class-id>ASN1.Asn1TypeREAL</class-id> <category>encoding</category><body package="ASN1" selector="encode:with:">encode: aLimitedPrecisionReal with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	aMarshaler encodeREAL: aLimitedPrecisionReal</body><body package="ASN1" selector="tagBER">tagBER	"... avoid the namespace lookup."	^02r00001001	"ASN1.UniversalREAL = 9"</body></methods><methods><class-id>ASN1.Asn1TypeREAL class</class-id> <category>defaults</category><body package="ASN1" selector="defaultConstraint">defaultConstraint	^Asn1ConstraintBlockClosure		with: [ :x | x isKindOf: LimitedPrecisionReal ]</body><body package="ASN1" selector="defaultSymbol">defaultSymbol	^#'REAL'</body></methods><methods><class-id>ASN1.Asn1TypeUnknown</class-id> <category>encoding</category><body package="ASN1" selector="tagBER">tagBER	^nil</body></methods><methods><class-id>ASN1.Asn1TypeUnknown class</class-id> <category>defaults</category><body package="ASN1" selector="defaultConstraint">defaultConstraint	^Asn1ConstraintNull default</body><body package="ASN1" selector="defaultSymbol">defaultSymbol	^#Unknown</body></methods><methods><class-id>ASN1.Asn1Element</class-id> <category>accessing</category><body package="ASN1" selector="default">default	^default</body><body package="ASN1" selector="default:">default: anObject	default := anObject</body><body package="ASN1" selector="hasDefault:">hasDefault: aBoolean	hasDefault := aBoolean</body><body package="ASN1" selector="optional">optional	^optional</body><body package="ASN1" selector="optional:">optional: aBoolean	optional := aBoolean</body><body package="ASN1" selector="symbol">symbol	^symbol ifNil: [ symbol := self type symbol ]</body><body package="ASN1" selector="symbol:">symbol: aSymbol	symbol := aSymbol</body><body package="ASN1" selector="tag">tag	^( tag isNil )		ifTrue:	[ tag := type tagBER ]		ifFalse:	[ tag ]</body><body package="ASN1" selector="tag:">tag: anInteger	tag := anInteger</body><body package="ASN1" selector="taggingMode">taggingMode	^taggingMode</body><body package="ASN1" selector="taggingMode:">taggingMode: aSymbolOrNil	taggingMode := aSymbolOrNil</body><body package="ASN1" selector="type">type	^type</body><body package="ASN1" selector="type:">type: aAsn1Type	type := aAsn1Type</body></methods><methods><class-id>ASN1.Asn1Element</class-id> <category>validation</category><body package="ASN1" selector="permits:">permits: anObject	^type constraint permits: anObject</body></methods><methods><class-id>ASN1.Asn1Element</class-id> <category>testing</category><body package="ASN1" selector="hasDefault">hasDefault	^hasDefault</body><body package="ASN1" selector="hasDefaultOrIsOptional">hasDefaultOrIsOptional	^default notNil or: [ optional ]</body><body package="ASN1" selector="isElement">isElement	^true</body><body package="ASN1" selector="isExplicit">isExplicit	^taggingMode == #explicit</body><body package="ASN1" selector="isImplicit">isImplicit	^taggingMode == #implicit</body><body package="ASN1" selector="isOptional">isOptional	^optional</body><body package="ASN1" selector="isUniversal">isUniversal	^taggingMode == #universal</body></methods><methods><class-id>ASN1.Asn1Element</class-id> <category>printing</category><body package="ASN1" selector="printOn:">printOn: aStream	aStream		nextPutAll: ( self class name );		nextPutAll: '( ';		nextPutAll: self symbol;		nextPutAll: ' )'</body></methods><methods><class-id>ASN1.Asn1Element</class-id> <category>protocol compatibility</category><body package="ASN1" selector="key">key	^symbol</body><body package="ASN1" selector="tagBER">tagBER	^self tag</body></methods><methods><class-id>ASN1.Asn1Element</class-id> <category>initialize-release</category><body package="ASN1" selector="initialize">initialize	hasDefault := false.	optional := false.	taggingMode := #universal</body></methods><methods><class-id>ASN1.Asn1Element class</class-id> <category>instance creation</category><body package="ASN1" selector="default:optional:symbol:tag:taggingMode:type:">default: anObject optional: aBoolean2 symbol: aSymbol1 tag: anInteger taggingMode: aSymbol2 type: anAsn1Type	| n |	n := ( self new )			default: anObject;			hasDefault: true;			optional: aBoolean2;			symbol: aSymbol1;			tag: anInteger;			taggingMode: aSymbol2;			type: anAsn1Type;			yourself.	self validate: n.	^n</body><body package="ASN1" selector="default:symbol:tag:taggingMode:type:">default: anObject symbol: aSymbol1 tag: anInteger taggingMode: aSymbol2 type: anAsn1Type	^( self new )		default: anObject;		hasDefault: true;		symbol: aSymbol1;		tag: anInteger;		taggingMode: aSymbol2;		type: anAsn1Type;		yourself</body><body package="ASN1" selector="default:symbol:type:">default: anObject symbol: aSymbol type: anAsn1Type	^( self new )		default: anObject;		hasDefault: true;		symbol: aSymbol;		type: anAsn1Type;		yourself</body><body package="ASN1" selector="new">new	^super new initialize</body><body package="ASN1" selector="optional:symbol:tag:taggingMode:type:">optional: aBoolean2 symbol: aSymbol1 tag: anInteger taggingMode: aSymbol2 type: anAsn1Type	^( self new )			optional: aBoolean2;			symbol: aSymbol1;			tag: anInteger;			taggingMode: aSymbol2;			type: anAsn1Type;			yourself</body><body package="ASN1" selector="optional:symbol:type:">optional: aBoolean2 symbol: aSymbol1 type: anAsn1Type	^( self new )			optional: aBoolean2;			symbol: aSymbol1;			type: anAsn1Type;			yourself</body><body package="ASN1" selector="symbol:tag:taggingMode:type:">symbol: aSymbol1 tag: anInteger taggingMode: aSymbol2 type: anAsn1Type	^( self new )		symbol: aSymbol1;		tag: anInteger;		taggingMode: aSymbol2;		type: anAsn1Type;		yourself</body><body package="ASN1" selector="symbol:tag:type:">symbol: aSymbol tag: anInteger type: anAsn1Type	^( self new )		symbol: aSymbol;		tag: anInteger;		type: anAsn1Type;		yourself</body><body package="ASN1" selector="symbol:type:">symbol: aSymbol type: anAsn1Type	^( self new )		symbol: aSymbol;		type: anAsn1Type;		yourself</body></methods><methods><class-id>ASN1.Asn1Element class</class-id> <category>validation</category><body package="ASN1" selector="validate:">validate: anAsn1Element	( anAsn1Element optional and: [ anAsn1Element default notNil ] )		ifTrue:	[ ^Asn1ExcTypeSpecification raiseSignal: (#elementsMayNotBeBothOptionalAndDefault &lt;&lt; #opentalk &gt;&gt; 'ASN.1 type elements may not be both OPTIONAL and have a DEFAULT value!') ]</body></methods><methods><class-id>ASN1.Asn1TypeIA5String</class-id> <category>encoding</category><body package="ASN1" selector="encode:with:">encode: aByteString with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	aMarshaler encodeIA5String: aByteString</body><body package="ASN1" selector="tagBER">tagBER	"... avoid the namespace lookup."	^02r00010110	"ASN1.UniversalIA5String = 22"</body></methods><methods><class-id>ASN1.Asn1TypeIA5String</class-id> <category>decoding</category><body package="ASN1" selector="decode:with:">decode: anInteger with: aMarshaler	"... the method invoked when unmarshaling type-in-hand."	^aMarshaler decodeIA5String: anInteger</body></methods><methods><class-id>ASN1.Asn1TypeIA5String class</class-id> <category>defaults</category><body package="ASN1" selector="defaultConstraint">defaultConstraint	"... the set CO of 32 control characters, plus ISOReg entry #6 (94 graphical characters), plus 'space' and 'delete'."	| charset |	charset := Set new: 32 + 94 + 2.	0 to: 31 do: [ :x | charset add: x asCharacter ].	charset addAll: '!"#$%&amp;''()*+,-./'.	charset addAll: '0123456789:;&lt;=&gt;?'.	charset addAll: '@ABCDEFGHIJKLMNO'.	charset addAll: 'PQRSTUVWXYZ[\]^_'.	charset addAll: '`abcdefghijkl;mno'.	charset addAll: 'pqrstuvwxyz{|}~'.	charset add: Character space.	charset add: Character del.	^Asn1ConstraintAlphabet		with: ( Asn1ConstraintValueUnion				withAll: charset )</body><body package="ASN1" selector="defaultSymbol">defaultSymbol	^#'IA5String'</body></methods><methods><class-id>ASN1.Asn1TypeVisibleString</class-id> <category>encoding</category><body package="ASN1" selector="encode:with:">encode: aByteString with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	aMarshaler encodeVisibleString: aByteString</body><body package="ASN1" selector="tagBER">tagBER	"... avoid the namespace lookup."	^02r00011010	"ASN1.UniversalVisibleString = 26"</body></methods><methods><class-id>ASN1.Asn1TypeVisibleString class</class-id> <category>defaults</category><body package="ASN1" selector="defaultConstraint">defaultConstraint	"... ISOReg entry #6 (94 characters), plus the space character."	| charset |	charset := Set new: 95.	charset addAll: '!"#$%&amp;''()*+,-./'.	charset addAll: '0123456789:;&lt;=&gt;?'.	charset addAll: '@ABCDEFGHIJKLMNO'.	charset addAll: 'PQRSTUVWXYZ[\]^_'.	charset addAll: '`abcdefghijkl;mno'.	charset addAll: 'pqrstuvwxyz{|}~'.	charset add: Character space.	^Asn1ConstraintAlphabet		with: ( Asn1ConstraintValueUnion				withAll: charset )</body><body package="ASN1" selector="defaultSymbol">defaultSymbol	^#'VisibleString'</body></methods><methods><class-id>ASN1.Asn1TypeUTCTime</class-id> <category>encoding</category><body package="ASN1" selector="encode:with:">encode: aTimestamp with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	aMarshaler encodeUTCTime: aTimestamp</body><body package="ASN1" selector="tagBER">tagBER	"... avoid the namespace lookup."	^02r00010111	"ASN1.UniversalUTCTime = 23"</body></methods><methods><class-id>ASN1.Asn1TypeUTCTime</class-id> <category>decoding</category><body package="ASN1" selector="decode:with:">decode: anInteger with: aMarshaler	"... the method invoked when unmarshaling type-in-hand."	^aMarshaler decodeUTCTime: anInteger</body></methods><methods><class-id>ASN1.Asn1TypeUTCTime class</class-id> <category>defaults</category><body package="ASN1" selector="defaultConstraint">defaultConstraint	^Asn1ConstraintBlockClosure		with: [ :x | x class == Timestamp ]</body><body package="ASN1" selector="defaultSymbol">defaultSymbol	^#'UTCTime'</body></methods><methods><class-id>ASN1.Asn1TypeGeneralizedTime</class-id> <category>encoding</category><body package="ASN1" selector="encode:with:">encode: vaTimestamp with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	aMarshaler encodeGeneralizedTime: vaTimestamp</body><body package="ASN1" selector="tagBER">tagBER	"... avoid the namespace lookup."	^02r00011000	"ASN1.UniversalGeneralizedTime = 24"</body></methods><methods><class-id>ASN1.Asn1TypeGeneralizedTime</class-id> <category>decoding</category><body package="ASN1" selector="decode:with:">decode: anInteger with: aMarshaler	"... the method invoked when unmarshaling type-in-hand."	^aMarshaler decodeGeneralizedTime: anInteger</body></methods><methods><class-id>ASN1.Asn1TypeGeneralizedTime class</class-id> <category>defaults</category><body package="ASN1" selector="defaultConstraint">defaultConstraint	^Asn1ConstraintBlockClosure		with: [ :x | x class == Timestamp ]</body><body package="ASN1" selector="defaultSymbol">defaultSymbol	^#'GeneralizedTime'</body></methods><methods><class-id>ASN1.Asn1TypeNumericString</class-id> <category>encoding</category><body package="ASN1" selector="encode:with:">encode: aByteString with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	aMarshaler encodeNumericString: aByteString</body><body package="ASN1" selector="tagBER">tagBER	"... avoid the namespace lookup."	^02r00010010	"ASN1.UniversalNumericString = 18"</body></methods><methods><class-id>ASN1.Asn1TypeNumericString class</class-id> <category>defaults</category><body package="ASN1" selector="defaultConstraint">defaultConstraint	| charset |	charset := Set new: 11.	charset addAll: '0123456789'.	charset add: Character space.	^Asn1ConstraintAlphabet		with: ( Asn1ConstraintValueUnion				withAll: charset )</body><body package="ASN1" selector="defaultSymbol">defaultSymbol	^#'NumericString'</body></methods><methods><class-id>ASN1.Asn1TypePrintableString</class-id> <category>encoding</category><body package="ASN1" selector="encode:with:">encode: aByteString with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	aMarshaler encodePrintableString: aByteString</body><body package="ASN1" selector="tagBER">tagBER	"... avoid the namespace lookup."	^02r00010011	"ASN1.UniversalPrintableString = 19"</body></methods><methods><class-id>ASN1.Asn1TypePrintableString</class-id> <category>decoding</category><body package="ASN1" selector="decode:with:">decode: anInteger with: aMarshaler	"... the method invoked when unmarshaling type-in-hand."	^aMarshaler decodePrintableString: anInteger</body></methods><methods><class-id>ASN1.Asn1TypePrintableString class</class-id> <category>defaults</category><body package="ASN1" selector="defaultConstraint">defaultConstraint	| charset |	charset := Set new: 74.	charset addAll: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.	charset addAll: 'abcdefghijklmnopqrstuvwxyz'.	charset addAll: '0123456789'.	charset add: Character space.	charset addAll: '''()+,-./:=?'.	^Asn1ConstraintAlphabet		with: ( Asn1ConstraintValueUnion				withAll: charset )</body><body package="ASN1" selector="defaultSymbol">defaultSymbol	^#'PrintableString'</body></methods><methods><class-id>ASN1.Asn1ExcUnknownTag class</class-id> <category>testing</category><body package="ASN1" selector="mayResume">mayResume	^true</body></methods><methods><class-id>ASN1.Asn1TypeSEQUENCE_OF</class-id> <category>encoding</category><body package="ASN1" selector="encode:with:">encode: anOrderedCollection with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	"... see the method comment of 'encodeSEQUENCEorSEQUENCE_OF:'."	( elementType isNil )		ifTrue:	[ aMarshaler encodeSEQUENCEorSEQUENCE_OF: anOrderedCollection ]		ifFalse:	[ anOrderedCollection do:					[ :x | aMarshaler encodeTLV: x withType: elementType ] ]</body><body package="ASN1" selector="tagBER">tagBER	"... avoid the namespace lookup."	^02r00110000	"ASN1.ConstructedSEQUENCE = 48"</body></methods><methods><class-id>ASN1.Asn1TypeSEQUENCE_OF</class-id> <category>decoding</category><body package="ASN1" selector="decode:with:">decode: anInteger with: aMarshaler	"... the method invoked when unmarshaling type-in-hand."	^( elementType isNil )		ifTrue:	[ aMarshaler decodeSEQUENCEorSEQUENCE_OF: anInteger ]		ifFalse:	[	| oc tpos |					oc := OrderedCollection new: 11.					tpos := aMarshaler position + anInteger.					[ aMarshaler position &lt; tpos ]						whileTrue: [ oc add: ( aMarshaler decodeTLV_Type: elementType ) ].					oc				]</body></methods><methods><class-id>ASN1.Asn1TypeSEQUENCE_OF class</class-id> <category>defaults</category><body package="ASN1" selector="defaultConstraint">defaultConstraint	^Asn1ConstraintBlockClosure		with: [ :x | x class == OrderedCollection ]</body><body package="ASN1" selector="defaultSymbol">defaultSymbol	^#'SEQUENCE OF'</body></methods><methods><class-id>ASN1.Asn1TypeNULL</class-id> <category>encoding</category><body package="ASN1" selector="encode:with:">encode: anUndefinedObject with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	aMarshaler encodeNULL</body><body package="ASN1" selector="tagBER">tagBER	"... avoid the namespace lookup."	^02r00000101	"ASN1.UniversalNULL = 5"</body></methods><methods><class-id>ASN1.Asn1TypeNULL</class-id> <category>decoding</category><body package="ASN1" selector="decode:with:">decode: anInteger with: aMarshaler	"... the method invoked when unmarshaling type-in-hand."	^aMarshaler decodeNULL: anInteger</body></methods><methods><class-id>ASN1.Asn1TypeNULL class</class-id> <category>defaults</category><body package="ASN1" selector="defaultConstraint">defaultConstraint	^Asn1ConstraintSingleValue		with: nil</body><body package="ASN1" selector="defaultSymbol">defaultSymbol	^#'NULL'</body></methods><methods><class-id>ASN1.Asn1TypeTeletexString</class-id> <category>encoding</category><body package="ASN1" selector="tagBER">tagBER	"... avoid the namespace lookup."	^02r00010100	"ASN1.UniversalTeletexString = 20"</body></methods><methods><class-id>ASN1.Asn1TypeTeletexString class</class-id> <category>defaults</category><body package="ASN1" selector="defaultConstraint">defaultConstraint	"... provisional."	^Asn1ConstraintNull default</body><body package="ASN1" selector="defaultSymbol">defaultSymbol	^#'TeletexString'</body></methods><methods><class-id>ASN1.Asn1Enumeration</class-id> <category>accessing</category><body package="ASN1" selector="integer">integer	^integer</body><body package="ASN1" selector="integer:">integer: anInteger	integer := anInteger</body><body package="ASN1" selector="symbol">symbol	^symbol</body><body package="ASN1" selector="symbol:">symbol: aSymbolOrString	symbol := aSymbolOrString asSymbol</body></methods><methods><class-id>ASN1.Asn1Enumeration</class-id> <category>testing</category><body package="ASN1" selector="isEnumeration">isEnumeration	^true</body></methods><methods><class-id>ASN1.Asn1Enumeration</class-id> <category>converting</category><body package="ASN1" selector="asAsn1Enumeration">asAsn1Enumeration	^self</body></methods><methods><class-id>ASN1.Asn1Enumeration</class-id> <category>comparing</category><body package="ASN1" selector="=">= anObject	^( anObject class == self class )		and: [ ( anObject integer = integer )			and: [ anObject symbol = symbol ] ]</body></methods><methods><class-id>ASN1.Asn1Enumeration class</class-id> <category>instance creation</category><body package="ASN1" selector="integer:symbol:">integer: anInteger symbol: aSymbol	^( super new )		integer: anInteger;		symbol: aSymbol;		yourself</body><body package="ASN1" selector="symbol:integer:">symbol: aSymbol integer: anInteger	^( super new )		integer: anInteger;		symbol: aSymbol;		yourself</body></methods><methods><class-id>ASN1.Asn1ConstraintAllExcept</class-id> <category>private</category><body package="ASN1" selector="privatePermits:">privatePermits: anObject	^( constraint privatePermits: anObject ) not</body></methods><methods><class-id>ASN1.Asn1ConstraintIntersection</class-id> <category>private</category><body package="ASN1" selector="privatePermits:">privatePermits: anObject	constraints do: [ :c | ( c privatePermits: anObject ) ifFalse: [ ^false ] ].	^true</body></methods><methods><class-id>Core.Timestamp</class-id> <category>marshaling - asn1</category><body package="ASN1" selector="asUTCTime">asUTCTime	"A Timestamp may be marshaled as a UTCTime by enclosing it in an Asn1TypeWrapper prior to marshaling."	^ASN1.Asn1TypeWrapper type: ASN1.Asn1TypeUTCTime default value: self</body></methods><methods><class-id>Core.Object</class-id> <category>marshaling - asn1</category><body package="ASN1" selector="asAsn1Type:">asAsn1Type: anAsn1Type		^ASN1.Asn1TypeWrapper			type: anAsn1Type			value: self</body><body package="ASN1" selector="asAsn1TypeNamed:">asAsn1TypeNamed: aSymbol		^self asAsn1Type: ( ASN1.Asn1Type findTypeNamed: aSymbol )</body></methods><methods><class-id>Core.Association</class-id> <category>converting</category><body package="ASN1" selector="asAsn1Enumeration">asAsn1Enumeration	"... assumes the key is aSymbol and the value is anInteger."	^ASN1.Asn1Enumeration		symbol: key		integer: value</body></methods><methods><class-id>Core.Integer</class-id> <category>marshaling - asn1</category><body package="ASN1" selector="asENUMERATED">asENUMERATED	"An Integer may be marshaled as an ENUMERATED by enclosing it in an Asn1TypeWrapper prior to marshaling or by wrapping it in an Ans1ImportedEnumerated.  Here, we take the first course.  Note that the Integers in ASN.1 ENUMERATEDs do not have a strictly numeric value in the sense that enumerations are, in ASN.1, never greter than or less than others.  In ENUMERATEDs the Integer has the semantic significance of a name."	^ASN1.Asn1TypeWrapper type: ASN1.Asn1TypeENUMERATED default value: self</body></methods><initialize><class-id>ASN1.SMINode</class-id></initialize><initialize><class-id>ASN1.Asn1OID</class-id></initialize><initialize><class-id>ASN1.Asn1Stream</class-id></initialize><initialize><class-id>ASN1.Asn1StreamBERBasic</class-id></initialize><initialize><class-id>ASN1.Asn1StreamBERDefinite</class-id></initialize><initialize><class-id>ASN1.Asn1StreamBERDefiniteEncodings</class-id></initialize><initialize><class-id>ASN1.Asn1StreamDER</class-id></initialize><initialize><class-id>ASN1.Asn1Type</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ReadWriteStream</name><environment>Core</environment><super>Core.WriteStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hour minute second millisecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>Association</name><environment>Core</environment><super>Core.LookupKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>