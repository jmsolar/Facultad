<?xml version="1.0"?><st-source><!-- Name: DSANotice: Copyright © 2005 Cincom Systems, Inc.  All Rights Reserved.Comment: This package contains an implementation of Digital Signature Algorithm (DSA) of the U.S. government's Digital Signature Standard (DSS). The DSA algorithm was proposed in 1991 and became a standard in May 1994. The official description is available as a Federal Information Processing Standards Publication (FIPS PUB 186, May 19, 1994; http://csrc.nist.gov/CryptoToolkit/tkdigsigs.html).The algorithm is represented by the class DSA providing API for signing and verifying. The keys can be generated with DSAKeyGenerator and are instantiated in the form of DSAPublicKey and DSAPrivateKey. The result of signing is a DSASignature and that's what needs to be handed in as a parameter for verification. For details please refer to the class comments.DbIdentifier: bear73DbTrace: 53785DevelopmentPrerequisites: #(#(#package 'CiphersBase' ''))PackageName: DSAParcel: #('DSA')PrerequisiteParcels: #(#('CiphersBase' ''))PrintStringCache: (731 2,mkobetic)Version: 7.3.1Date: 9:21:41 am April 18, 2005 --><time-stamp>From VisualWorks®, 7.3.1 of April 10, 2005 on April 18, 2005 at 9:21:41 am</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>DSAKey</name><environment>Security</environment><super>Security.EncryptionKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>p q g </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>DSA</package></attributes></class><comment><class-id>Security.DSAKey</class-id><body>Instance Variables:	p	&lt;LargeInteger&gt; a large prime of bit-length l, such that p=jq+1, where j &gt;= 2	q	&lt;LargeInteger&gt; a large prime of bit-length 160	g	&lt;LargeInteger&gt;	generator that has order q mod p</body></comment><class><name>DSAPrivateKey</name><environment>Security</environment><super>Security.DSAKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>DSA</package></attributes></class><comment><class-id>Security.DSAPrivateKey</class-id><body>Instance Variables:	x	&lt;LargeInteger&gt;	randomly generated private parameter, 0 &lt; x &lt; q</body></comment><class><name>DSAPublicKey</name><environment>Security</environment><super>Security.DSAKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>y </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>DSA</package></attributes></class><comment><class-id>Security.DSAPublicKey</class-id><body>Instance Variables:	y	&lt;LargeInteger&gt;	public parameter, y = g^x mod p</body></comment><class><name>DSAError</name><environment>Security</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>DSA</package></attributes></class><comment><class-id>Security.DSAError</class-id><body>Represents errors raised by the DSA algorithm.</body></comment><class><name>DSA</name><environment>Security</environment><super>Security.AsymmetricCipher</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sha privateKey publicKey random </inst-vars><class-inst-vars>random </class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>DSA</package></attributes></class><comment><class-id>Security.DSA</class-id><body>This class implements Digital Signature Algorithm (DSA) of the U.S. government's Digital Signature Standard (DSS). The DSA algorithm was proposed in 1991 and became a standard in May 1994. The official description is available as a Federal Information Processing Standards Publication (FIPS PUB 186, May 19, 1994; http://csrc.nist.gov/CryptoToolkit/tkdigsigs.html). A companion standard, the Secure Hash Standard, or SHS (FIPS PUB 180-1, April 17, 1995), describes a 160-bit message digest algorithm known as the Secure Hash Algorithm (SHA). This message digest is used to compute the signature. DSA does not support encryption, only signing.Instance Variables:	sha	&lt;SHA&gt; hash algorithm processing messages before signing	privateKey	&lt;DSAPrivateKey&gt; the key used for signing	publicKey	&lt;DSAPublicKey&gt; the key used for verifying signatures	random	&lt;DSSRandom&gt; random generator used in the signing processClass Instance Variables:	random	&lt;Random&gt; the default random generator</body></comment><class><name>DSASignature</name><environment>Security</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>r s </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>DSA</package></attributes></class><comment><class-id>Security.DSASignature</class-id><body>This class represents a DSA signature which consists of two large integers. Instances are usually generated using the DSA signing operation.Instance Variables:	r	&lt;LargePositiveInteger&gt;	signature parameter	s	&lt;LargePositiveInteger&gt;	signature parameter</body></comment><class><name>DSAKeyGenerator</name><environment>Security</environment><super>Security.KeyGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sha q p g x y seed seedMask counter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>DSA</package></attributes></class><comment><class-id>Security.DSAKeyGenerator</class-id><body>DSA key generator is described in the DSS standard itself. The standard restricts the key size parameter (refered to as l) to multiples of 64 starting at 512 and ending with 1024. The random generator is expected to generate large intergers of 160 bit size. The primality test is allowed to be probabilistic but the probability of false prime has to be less than 1/4^50.The generator produces a sequence of parameters, signalling various events along the way for observation. Finally packages them up as DSAPublicKey and DSAPrivateKey, which are accessible using the #privateKey and #publicKey messages. To force the generator to produce a new pair of keys it has to be cleared using the #flush message. The generator also provides additional parameters #seed and #counter that can be used to verify quality of the public key by other parties.Instance Variables:	sha	&lt;SHA&gt; an instance of the hash function	q	&lt;LargeInteger&gt; a large prime of bit-length 160	p	&lt;LargeInteger&gt; a large prime of bit-length l, such that p=jq+1, where j &gt;= 2	g	&lt;LargeInteger&gt;	generator that has order q mod p	x	&lt;LargeInteger&gt;	randomly generated private parameter, 0 &lt; x &lt; q	y	&lt;LargeInteger&gt;	public parameter, y = g^x mod p	seed	&lt;LargeInteger&gt; the seed used to generate q	seedMask	&lt;LargeInteger&gt;	the seed mask cache, (2 raisedTo: seed basicSize) - 1	counter	&lt;SmallInteger&gt; the counter value that yielded p</body></comment><methods><class-id>Security.DSAKey</class-id> <category>accessing</category><body package="DSA" selector="g">g^g</body><body package="DSA" selector="g:">g:  anIntegerg := anInteger</body><body package="DSA" selector="p">p^p</body><body package="DSA" selector="p:">p:  anIntegerp := anInteger</body><body package="DSA" selector="q">q^q</body><body package="DSA" selector="q:">q:  anIntegerq := anInteger</body></methods><methods><class-id>Security.DSAPrivateKey</class-id> <category>accessing</category><body package="DSA" selector="x">x^x</body><body package="DSA" selector="x:">x:  anIntegerx := anInteger</body></methods><methods><class-id>Security.DSAPrivateKey class</class-id> <category>instance creation</category><body package="DSA" selector="p:q:g:x:">p: p q: q g: g x: x	| inst |	inst := self new.	inst p: p.	inst q: q.	inst g: g.	inst x: x.	^inst</body></methods><methods><class-id>Security.DSAPublicKey</class-id> <category>accessing</category><body package="DSA" selector="y">y^y</body><body package="DSA" selector="y:">y:  anIntegery := anInteger</body></methods><methods><class-id>Security.DSAPublicKey class</class-id> <category>instance creation</category><body package="DSA" selector="p:q:g:y:">p: p q: q g: g y: y	| inst |	inst := self new.	inst p: p.	inst q: q.	inst g: g.	inst y: y.	^inst</body></methods><methods><class-id>Security.DSA</class-id> <category>deprecated</category><body package="DSA" selector="computeSignatureForMessageHash:privateKey:">computeSignatureForMessageHash: hash privateKey: aPrivateKey	"Answer the digital signature of the given message hash using the given private key. A signature is a pair of large integers. The private key is an array of four large integers: (p, q, g, x)."	| p q g x r s k tmp |	p := aPrivateKey p.	q := aPrivateKey q.	g := aPrivateKey  g.	x := aPrivateKey x.	r := s := 0.	[r = 0 or: [s = 0]] whileTrue: [		k := self nextRandom160 \\ q.		r := (g raisedTo: k modulo: p) \\ q.		tmp := (hash + (x * r)) \\ q.		s := ((self inverseOf: k mod: q) * tmp) \\ q].	^ DSASignature r: r s: s</body><body package="DSA" selector="verifySignature:ofMessageHash:publicKey:">verifySignature: aSignature ofMessageHash: hash publicKey: aPublicKey	"Answer true if the given signature is the authentic signature of the given message hash. That is, if the signature must have been computed using the private key set corresponding to the given public key. The public key is an array of four large integers: (p, q, g, y)."	| p q g y r s w u1 u2 v0 v |	p := aPublicKey p.	q := aPublicKey q.	g := aPublicKey g.	y := aPublicKey y.	r := aSignature r.	s := aSignature s.	((r &gt; 0) and: [r &lt; q]) ifFalse: [^ false].  "reject"	((s &gt; 0) and: [s &lt; q]) ifFalse: [^ false].  "reject"	w := self inverseOf: s mod: q.	u1 := (hash * w) \\ q.	u2 := (r * w) \\ q.	v0 := (g raisedTo: u1 modulo: p) * (y raisedTo: u2 modulo: p).	v := ( v0 \\ p) \\ q.	^ v = r</body></methods><methods><class-id>Security.DSA</class-id> <category>accessing</category><body package="DSA" selector="privateKey">privateKey	^privateKey</body><body package="DSA" selector="privateKey:">privateKey: aDSAPrivateKey	privateKey := aDSAPrivateKey</body><body package="DSA" selector="publicKey">publicKey	^publicKey</body><body package="DSA" selector="publicKey:">publicKey: aDSAPublicKey	publicKey := aDSAPublicKey</body><body package="DSA" selector="random">random	^random ifNil: [random := self defaultRandom]</body><body package="DSA" selector="random:">random: aDSSRandom	random := aDSSRandom</body></methods><methods><class-id>Security.DSA</class-id> <category>private</category><body package="DSA" selector="defaultRandom">defaultRandom	^self class random</body><body package="DSA" selector="inverseOf:mod:">inverseOf: x mod: n	"Answer the inverse of x modulus n. That is, the integer y such that (x * y) \\ n is 1. Both x and n must be positive, and it is assumed that x &lt; n and that x and n are integers."	"Details: Use the extended Euclidean algorithm, Schneier, p. 247."	" need to review to make faster"	| v u k u1 u2 u3 t1 t2 t3 tmp |	((x &lt;= 0) or: [n &lt;= 0]) ifTrue: [self error: (#xnMustBePositive &lt;&lt; #security &gt;&gt; 'x and n must be greater than zero')].	x &gt;= n ifTrue: [self error: (#xMustBeLessThanN &lt;&lt; #security &gt;&gt; 'x must be &lt; n')].	v := x.	u := n.	k := 0.	[x even and: [n even and: [u &gt; 0]]] whileTrue: [  "eliminate common factors of two"		k := k + 1.		u := u bitShift: -1.		v := v bitShift: -1].	u1 := 1. u2 := 0. u3 := u.	t1 := v. t2 := u - 1. t3 := v.	[	[u3 even ifTrue: [			((u1 odd) or: [u2 odd]) ifTrue: [				u1 := u1 + v.				u2 := u2 + u].			u1 := u1 bitShift: -1.			u2 := u2 bitShift: -1.			u3 := u3 bitShift: -1].		((t3 even) or: [u3 &lt; t3]) ifTrue: [			tmp := u1. u1 := t1. t1 := tmp.			tmp := u2. u2 := t2. t2 := tmp.			tmp := u3. u3 := t3. t3 := tmp].		u3 even and: [u3 &gt; 0]] whileTrue: ["loop while u3 is even"].		[((u1 &lt; t1) or: [u2 &lt; t2]) and: [u1 &gt; 0]] whileTrue: [			u1 := u1 + v.			u2 := u2 + u].			u1 := u1 - t1.		u2 := u2 - t2.		u3 := u3 - t3.		t3 &gt; 0] whileTrue: ["loop while t3 &gt; 0"].	[u1 &gt;= v and: [u2 &gt;= u]] whileTrue: [		u1 := u1 - v.		u2 := u2 - u].	u1 := u1 bitShift: k.	u2 := u2 bitShift: k.	u3 := u3 bitShift: k.	u3 = 1 ifFalse: [self error: (#NoInverse &lt;&lt; #security &gt;&gt; 'no inverse')].	^ u - u2</body></methods><methods><class-id>Security.DSA</class-id> <category>initialization</category><body package="DSA" selector="initialize">initialize	sha := SHA new.</body></methods><methods><class-id>Security.DSA</class-id> <category>services</category><body package="DSA" selector="decrypt:">decrypt: aByteArray"Decrypt aByteArray using the previously assigned private key."	"This algorithm doesn't support encryption"	^self shouldNotImplement</body><body package="DSA" selector="encrypt:">encrypt: aByteArray"Encrypts aByteArray using the previously assigned public key"	"This algorithm doesn't support encryption"	^self shouldNotImplement</body><body package="DSA" selector="sign:">sign: aByteObject	^self signDigestInteger: (sha integerHash: aByteObject)</body><body package="DSA" selector="signDigest:">signDigest: aByteObject	^self signDigestInteger: (		aByteObject isInteger			ifTrue: [aByteObject]			ifFalse: [aByteObject asLargePositiveInteger])</body><body package="DSA" selector="signDigestInteger:">signDigestInteger: aLargePositiveInteger	| p q g x r s k tmp |	privateKey ifNil: [ self error: (#NeedPrivateKeyToSign &lt;&lt; #security &gt;&gt; 'Private key needed for signing!')].	p := privateKey p.	q := privateKey q.	g := privateKey  g.	x := privateKey x.	r := s := 0.	[r = 0 or: [s = 0]] whileTrue: [		k := self random next \\ q.		r := (g raisedTo: k modulo: p) \\ q.		tmp := (aLargePositiveInteger + (x * r)) \\ q.		s := ((self inverseOf: k mod: q) * tmp) \\ q].	^ DSASignature r: r s: s</body><body package="DSA" selector="verify:of:">verify: aSignature of: aByteObject	^self		verify: aSignature		ofDigestInteger: (sha integerHash: aByteObject)</body><body package="DSA" selector="verify:ofDigest:">verify: aSignature ofDigest: aByteObject	^self		verify: aSignature		ofDigestInteger: (			aByteObject isInteger				ifTrue: [aByteObject]				ifFalse: [aByteObject asLargePositiveInteger])</body><body package="DSA" selector="verify:ofDigestInteger:">verify: aSignature ofDigestInteger: aLargePositiveInteger	| p q g y r s w u1 u2 v0 v |	publicKey ifNil: [ self error: (#NeedPublicKeyToVerify &lt;&lt; #security &gt;&gt; 'Public key needed for signature verification!') ].	p := publicKey p.	q := publicKey q.	g := publicKey g.	y := publicKey y.	r := aSignature r.	s := aSignature s.	((r &gt; 0) and: [r &lt; q]) ifFalse: [^ false].  "reject"	((s &gt; 0) and: [s &lt; q]) ifFalse: [^ false].  "reject"	w := self inverseOf: s mod: q.	u1 := (aLargePositiveInteger * w) \\ q.	u2 := (r * w) \\ q.	v0 := (g raisedTo: u1 modulo: p) * (y raisedTo: u2 modulo: p).	v := ( v0 \\ p) \\ q.	^ v = r</body></methods><methods><class-id>Security.DSA class</class-id> <category>deprecated</category><body package="DSA" selector="sign:privateKey:">sign: aStringOrStream privateKey: privateKey	"Sign the given message (a stream or string) and answer a signature string."		| dsa hasher h sig |	dsa := DSA new.	hasher := SHA new.	(aStringOrStream isByteObject)		ifTrue: [h := hasher integerHash: aStringOrStream]		ifFalse: [h := hasher integerHashStream: aStringOrStream].	sig := dsa computeSignatureForMessageHash: h privateKey: privateKey.	^ self signatureToString: sig</body><body package="DSA" selector="signatureToString:">signatureToString: aSignature	"Answer a string representation of the given signature. This string can be parsed using the stringToSignature: method."	| s hex |	s := WriteStream on: (String new: 2000).	s nextPutAll: '[DSA digital signature '.	hex := aSignature r printStringRadix: 16.	s nextPutAll: (hex copyFrom: 4 to: hex size).	s space.	hex := (aSignature s) printStringRadix: 16.	s nextPutAll: (hex copyFrom: 4 to: hex size).	s nextPutAll: ']'.	^ s contents</body><body package="DSA" selector="stringToSignature:">stringToSignature: aString	"Answer the signature stored in the given string. A signature string has the format:		 '[DSA digital signature &lt;r&gt; &lt;s&gt;]'	where &lt;r&gt; and &lt;s&gt; are large positive integers represented by strings of hexidecimal digits."	| prefix stream r s |	prefix := '[DSA digital signature '.	(aString beginsWith: prefix) ifFalse: [self error: 'bad signature prefix'].	stream := ReadStream on: aString.	stream position: prefix size.	r := Integer readFrom: stream base: 16.	stream next.	s := Integer readFrom: stream base: 16.	^ DSASignature r: r s: s</body><body package="DSA" selector="verify:isSignatureOf:publicKey:">verify: signatureString isSignatureOf: aStringOrStream publicKey: publicKey	"Answer true if the given signature string signs the given message (a stream or string)."	"Note: Random numbers are not needed for signature verification; thus, there is no need to call initRandomFromUser before verifying a signature."	| dsa hasher h sig |	dsa := DSA new.	hasher := SHA new.	(aStringOrStream isByteObject)		ifTrue: [h := hasher integerHash: aStringOrStream]		ifFalse: [h := hasher integerHashStream: aStringOrStream].	sig := self stringToSignature: signatureString.	^ dsa verifySignature: sig ofMessageHash: h publicKey: publicKey</body><body package="DSA" selector="verifySignature:isSignatureOf:publicKey:">verifySignature: aDSASignature isSignatureOf: aStringOrStream publicKey: publicKey	"Answer true if the given DSASignature  signs the given message (a stream or string)."	| dsa hasher h  |	dsa := DSA new.	hasher := SHA new.	(aStringOrStream  isByteObject)		ifTrue: [h := hasher integerHash: aStringOrStream]		ifFalse: [h := hasher integerHashStream: aStringOrStream].	^ dsa verifySignature: aDSASignature ofMessageHash: h publicKey: publicKey</body></methods><methods><class-id>Security.DSA class</class-id> <category>instance creation</category><body package="DSA" selector="new">new	^super new initialize</body></methods><methods><class-id>Security.DSA class</class-id> <category>accessing</category><body package="DSA" selector="defaultRandom">defaultRandom	^DSSRandom default</body><body package="DSA" selector="random">random	^random ifNil: [ self defaultRandom ]</body><body package="DSA" selector="random:">random: aRandom"Set the default random generator for DSA algorithms.	aRandom &lt;Random&gt; secure random generator"	random := aRandom</body></methods><methods><class-id>Security.DSASignature</class-id> <category>accessing</category><body package="DSA" selector="r">r	^r</body><body package="DSA" selector="s">s	^s</body></methods><methods><class-id>Security.DSASignature</class-id> <category>intialization</category><body package="DSA" selector="r:s:">r: rLargePositiveInteger s: sLargePositiveInteger	r := rLargePositiveInteger.	s := sLargePositiveInteger</body></methods><methods><class-id>Security.DSASignature class</class-id> <category>instance creation</category><body package="DSA" selector="r:s:">r: rLargePositiveInteger s: sLargePositiveInteger	^self new r: rLargePositiveInteger s: sLargePositiveInteger</body></methods><methods><class-id>Security.DSAKeyGenerator</class-id> <category>accessing</category><body package="DSA" selector="counter">counter	^counter</body><body package="DSA" selector="g">g	^g</body><body package="DSA" selector="l">l	^keySize</body><body package="DSA" selector="p">p	^p</body><body package="DSA" selector="q">q	^q</body><body package="DSA" selector="seed">seed	^seed</body><body package="DSA" selector="sha">sha	^sha</body><body package="DSA" selector="x">x	^x</body><body package="DSA" selector="y">y	^y</body></methods><methods><class-id>Security.DSAKeyGenerator</class-id> <category>initialization</category><body package="DSA" selector="keySize:random:primalityTest:">keySize: pLength random: aRandom primalityTest: pTest"	pLength	&lt;SmallInteger&gt; the bit-length of p, l = 512 + 64j, 0 &lt;= j &lt;= 8	aRandom	&lt;Random&gt; a random seed generator producing large intergers of size 160 bits	pTest	&lt;PrimalityTest&gt; a probabilistic primality test, with error probability less than 1/4^50"	super keySize: pLength random: aRandom primalityTest: pTest.	sha := SHA new.</body></methods><methods><class-id>Security.DSAKeyGenerator</class-id> <category>private</category><body package="DSA" selector="generateG">generateG"Generates parameter G. Appendix 4, DSS"	| j h |	p ifNil: [ self generateP ].	j := (p - 1) / q.	(j isInteger and: [j &gt; 1]) ifFalse: [		DSAError new			messageText: (#InvalidParameters &lt;&lt; #security &gt;&gt; 'Invalid parameters !');			parameter: self;			raise ].	h := 1.	[h := h + 1. (g := h raisedTo: j modulo: p) = 1] whileTrue.	self triggerEvent: #generatedG: with: g</body><body package="DSA" selector="generateP">generateP"Generates parameter P and a counter value."	| n w b offset lMask q2 bMask |	q ifNil: [ self generateQ ].	n := (keySize - 1) // 160.	b := (keySize - 1) \\ 160.	lMask := "2 raisedTo: l - 1"		((ByteArray new: keySize // 8 withAll: 0) at: keySize // 8 put: 128; yourself)			changeClassTo: LargePositiveInteger.	bMask := "(2 raisedTo: b) - 1"		(ByteArray new: b // 8 withAll: 255)			changeClassTo: LargePositiveInteger.	q2 := q * 2.	offset := 2.	counter := 0.	[ counter &lt; 4096 ] whileTrue: [		w := (0 to: n) inject: 0 into: [ :total :k || v |			v := sha hashInteger: (seed + offset + k bitAnd: seedMask).			k = n ifTrue: [ v := v bitAnd: bMask ].			total + (v bitShift: 160 * k)].		w := w bitOr: lMask.		p := w - (w \\ q2) + 1.		self triggerEvent: #tryingP:counter: with: p with: counter.		(p &gt; lMask and: [ primalityTest value: p ]) ifTrue: [			self triggerEvent: #foundP:counter: with: p with: counter.			^self ].		counter := counter + 1.		offset := offset + n + 1 ].	^DSAError raiseSignal: (#ParameterGenerationFailed &lt;&lt; #security &gt;&gt; 'Failed to generate parameters !')</body><body package="DSA" selector="generateQ">generateQ"Generates parameter Q and a seed"	| qMask |	p := counter := nil.	qMask := "(2 raisedTo: 159) + 1"		((ByteArray new: 20) at: 1 put: 1; at: 20 put: 128; yourself)			changeClassTo: LargePositiveInteger.	[	seed := random next.		seedMask ifNil: [ seedMask := "(2 raisedTo: seed basicSize) - 1"			(ByteArray new: seed basicSize withAll: 255) changeClassTo: LargePositiveInteger ].		q := (	(sha hashInteger: seed)				bitXor: (sha hashInteger: (seed + 1 bitAnd: seedMask))			) bitOr: qMask.		self triggerEvent: #tryingQ:seed: with: q with: seed.		primalityTest value: q	] whileFalse.	self triggerEvent: #foundQ:seed: with: q with: seed</body><body package="DSA" selector="generateX">generateX"Generates private parameter X. Section 4, DSS"	g ifNil: [ self generateG ].	[ (x := random next \\ q) &gt; 0] whileFalse.	self triggerEvent: #generatedX: with: x</body><body package="DSA" selector="generateY">generateY"Generates public parameter Y. Section 4, DSS"	x ifNil: [ self generateX ].	y := g raisedTo: x modulo: p.	self triggerEvent: #generatedY: with: y</body></methods><methods><class-id>Security.DSAKeyGenerator</class-id> <category>services</category><body package="DSA" selector="flush">flush"Flush all the parameters to make sure next generation creates new ones"	q := p := g := x := y := seed := seedMask := counter := nil</body><body package="DSA" selector="privateKey">privateKey	x ifNil: [ self generateX ].	^DSAPrivateKey p: p q: q g: g x: x</body><body package="DSA" selector="publicKey">publicKey	y ifNil: [ self generateY ].	^DSAPublicKey p: p q: q g: g y: y</body></methods><methods><class-id>Security.DSAKeyGenerator class</class-id> <category>events</category><body package="DSA" selector="eventsTriggered">eventsTriggered	^#(	tryingQ:seed:		foundQ:seed:		tryingP:counter:		foundP:counter:		generatedG:		generatedX:		generatedY:)</body></methods><methods><class-id>Security.DSAKeyGenerator class</class-id> <category>deprecated</category><body package="DSA" selector="l:">l: pLength	^self keySize: pLength</body><body package="DSA" selector="l:random:">l: pLength random: aRandom	^self keySize: pLength random: aRandom</body><body package="DSA" selector="l:random:primalityTest:">l: pLength random: aRandom primalityTest: pTest	^self keySize: pLength random: aRandom primalityTest: pTest</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>KeyGenerator</name><environment>Security</environment><super>Core.EventManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keySize random primalityTest </inst-vars><class-inst-vars>random </class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>CiphersBase</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>AsymmetricCipher</name><environment>Security</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>CiphersBase</package></attributes></class><class><name>EncryptionKey</name><environment>Security</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>CiphersBase</package></attributes></class></st-source>