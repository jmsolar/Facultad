<?xml version="1.0"?><st-source><!-- Name: DESNotice: Copyright © 2005 Cincom Systems, Inc.  All Rights Reserved.Comment: This package contains implementation of the popular DES encryption algorithm. The algorithm is described in many places, the reference definition is FIPS#46 published by US NIST. The algorithm is considered insecure by now because of it's limited key size (56 bits), although it still needs to be supported because of its wide deployment. Presently it is usually used in a tripple encryption mode to increase the key size to 168 bits, an thus increase the security of the application.The algorithm is represented by the class DES. To apply the algorithm create an instance of DES with the #key: instance creation method. The argument is the secret key which is expected to be a ByteArray of size 8. A DES instance can be used to both encrypt and decrypt 8 byte blocks arbitrarily (see protocol 'services').DbIdentifier: bear73DbTrace: 52194DevelopmentPrerequisites: #(#(#package 'CiphersBase' ''))PackageName: DESParcel: #('DES')PrerequisiteParcels: #(#('CiphersBase' ''))PrintStringCache: (731 0,mkobetic)Version: 7.3.1Date: 6:42:34 pm April 10, 2005 --><time-stamp>From VisualWorks®, 7.3.1 of April 10, 2005 on April 10, 2005 at 6:42:34 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>DESErrorSignal</name><environment>Security</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>DES</package></attributes></class><class><name>DESArrayLengthError</name><environment>Security</environment><super>Security.DESErrorSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>DES</package></attributes></class><class><name>DESDecryptionFailed</name><environment>Security</environment><super>Security.DESErrorSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>DES</package></attributes></class><class><name>DESHelper</name><environment>Security</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rL rH uL uH largeIntegerClass </inst-vars><class-inst-vars>largeIntegerClass </class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>DES</package></attributes></class><class><name>DES</name><environment>Security</environment><super>Security.BlockCipher</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ignoreParity checkForWeakKey mode keySchedule rowSelectionArray columnSelectionArray traceFile traceStream e_of_R_BitXor_Ki rNext permArray encryptInPlace helperU helperT helper registerR registerU registerT registerL registerTemp spRegisterTransformation skbTransformation spRegisterTransformation1 spRegisterTransformation2 spRegisterTransformation2ScratchRegister spRegisterTransformation3 spRegisterTransformation4 spRegisterTransformation5 spRegisterTransformation6 spRegisterTransformation7 spRegisterTransformation8 skbRegisterTransformation alternateShiftSequence reg arrayClass byteArrayClass largePositiveIntegerClass largePositiveScratchIntR largePositiveScratchIntU </inst-vars><class-inst-vars>registerClass desHelperClass arrayClass byteArrayClass largePositiveIntegerClass spRegisterTransformation skbTransformation skbRegisterTransformation alternateShiftSequence </class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>DES</package></attributes></class><comment><class-id>Security.DES</class-id><body>This class has two types of implementations for DES the orginal that I did which was fast but not great, however you could follow the book in Applied Cryptograhpy ,Cryptography thoery and prcatice and Hanbook of applied cryptography and see all the step clearly.The second and default implemetation is the one used. The IP and FP tranformations can be done as a bucnh of shifts xors and ands and take thirty steps rather than th forty or fify something. also the S and P box permutations can be combined in a matriw SPTranformation. then done together. so we now do it in half the time we used to.Instance Variables:	ignoreParity	&lt;?type?&gt;  comment	mode	&lt;?type?&gt;  comment	keySchedule	&lt;?type?&gt;  comment	rowSelectionArray	&lt;?type?&gt;  comment	columnSelectionArray	&lt;?type?&gt;  comment	traceFile	&lt;?type?&gt;  comment	traceStream	&lt;?type?&gt;  comment	e_of_R_BitXor_Ki	&lt;?type?&gt;  comment	rNext	&lt;?type?&gt;  comment	permArray	&lt;?type?&gt;  commentShared Variables:	AlternateShiftSequence	&lt;Array of: ?type?&gt;  comment	BinaryArrayConversionArray	&lt;Array of: ?type?&gt;  comment	CompressionPermutation	&lt;Array of: ?type?&gt;  comment	ExpansionPermutation	&lt;Array of: ?type?&gt;  comment	FinalPermutation	&lt;Array of: ?type?&gt;  comment	InitialPermutation	&lt;Array of: ?type?&gt;  comment	KeyPermutation	&lt;Array of: ?type?&gt;  comment	OddParityCheck	&lt;Array of: ?type?&gt;  comment	PBoxPermutation	&lt;Array of: ?type?&gt;  comment	PossiblyWeakKeys	&lt;Array of: ?type?&gt;  comment	SBoxes	&lt;Array of: ?type?&gt;  comment	SemiWeakKeys	&lt;Array of: ?type?&gt;  comment	ShiftSequence	&lt;Array of: ?type?&gt;  comment	SKBTransformation	&lt;Array of: ?type?&gt;  comment	SPtransformation	&lt;Array of: ?type?&gt;  comment	TraceEnabled	&lt;Array of: ?type?&gt;  comment	WeakKeys	&lt;Array of: ?type?&gt;  comment</body></comment><class><name>DESCBC</name><environment>Security</environment><super>Security.DES</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scratchBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>DES</package></attributes></class><class><name>DESBadKeySignal</name><environment>Security</environment><super>Security.DESErrorSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>DES</package></attributes></class><class><name>DESWeakKeySignal</name><environment>Security</environment><super>Security.DESBadKeySignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>DES</package></attributes></class><class><name>DESSPHelper</name><environment>Security</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rL rH </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>DES</package></attributes></class><shared-variable><name>PossiblyWeakKeys</name><environment>Security.DES</environment><private>false</private><constant>false</constant><category>statics</category><attributes><package>DES</package></attributes></shared-variable><shared-variable><name>SKBTransformation</name><environment>Security.DES</environment><private>false</private><constant>false</constant><category>alternate statics</category><initializer>Array new: 5</initializer><attributes><package>DES</package></attributes></shared-variable><shared-variable><name>SPRegisterTransformation</name><environment>Security.DES</environment><private>false</private><constant>false</constant><category>alternate statics</category><attributes><package>DES</package></attributes></shared-variable><shared-variable><name>SKBRegisterTransformation</name><environment>Security.DES</environment><private>false</private><constant>false</constant><category>alternate statics</category><initializer>Array new: 5</initializer><attributes><package>DES</package></attributes></shared-variable><shared-variable><name>AlternateShiftSequence</name><environment>Security.DES</environment><private>false</private><constant>false</constant><category>alternate statics</category><initializer>Array new: 5</initializer><attributes><package>DES</package></attributes></shared-variable><shared-variable><name>SemiWeakKeys</name><environment>Security.DES</environment><private>false</private><constant>false</constant><category>statics</category><attributes><package>DES</package></attributes></shared-variable><shared-variable><name>WeakKeys</name><environment>Security.DES</environment><private>false</private><constant>false</constant><category>statics</category><attributes><package>DES</package></attributes></shared-variable><shared-variable><name>OddParityCheck</name><environment>Security.DES</environment><private>false</private><constant>false</constant><category>statics</category><attributes><package>DES</package></attributes></shared-variable><shared-variable><name>SPtransformation</name><environment>Security.DES</environment><private>false</private><constant>false</constant><category>alternate statics</category><attributes><package>DES</package></attributes></shared-variable><methods><class-id>Security.DESHelper</class-id> <category>accesing</category><body package="DES" selector="getRasLargeInt">getRasLargeInt	| int |	int := self class largeIntegerClass basicNew: 4.	int basicAt: 3 put: (rH bitAnd: 16rff).	int basicAt:4 put: ((rH bitShift: -8) bitAnd: 16rff).	int basicAt: 1 put: (rL bitAnd: 16rff).	int basicAt:2 put: ((rL bitShift: -8) bitAnd: 16rff).	^int</body><body package="DES" selector="getRasLargeIntLoading:">getRasLargeIntLoading: alargeInt	alargeInt basicAt: 3 put: (rH bitAnd: 16rff).	alargeInt basicAt:4 put: ((rH bitShift: -8) bitAnd: 16rff).	alargeInt basicAt: 1 put: (rL bitAnd: 16rff).	alargeInt basicAt:2 put: ((rL bitShift: -8) bitAnd: 16rff).	^alargeInt</body><body package="DES" selector="getUasLargeInt">getUasLargeInt	| int |	int := self class largeIntegerClass basicNew: 4.	int basicAt: 3 put: (uH bitAnd: 16rff).	int basicAt:4 put: ((uH bitShift: -8) bitAnd: 16rff).	int basicAt: 1 put: (uL bitAnd: 16rff).	int basicAt:2 put: ((uL bitShift: -8) bitAnd: 16rff).	^int</body><body package="DES" selector="getUasLargeIntLoading:">getUasLargeIntLoading: alargeInt	alargeInt basicAt: 3 put: (uH bitAnd: 16rff).	alargeInt basicAt:4 put: ((uH bitShift: -8) bitAnd: 16rff).	alargeInt basicAt: 1 put: (uL bitAnd: 16rff).	alargeInt basicAt:2 put: ((uL bitShift: -8) bitAnd: 16rff).	^alargeInt</body><body package="DES" selector="loadFrom:">loadFrom: dataArray	       uH := ((dataArray at: 4) bitShift: 8) + (dataArray at: 3).       uL := ((dataArray at: 2) bitShift: 8) + (dataArray at: 1).        rH := ((dataArray at: 8) bitShift: 8) + (dataArray at: 7).       rL := ((dataArray at: 6) bitShift: 8) + (dataArray at: 5).</body><body package="DES" selector="rH">rH	^rH</body><body package="DES" selector="rH:rL:">rH: high16 rL: low16	rH := high16.	rL := low16.</body><body package="DES" selector="rL">rL	^rL</body><body package="DES" selector="u:r:">u: aLargeIntU r: aLargeIntR	       uH := ((aLargeIntU basicAt: 4) bitShift: 8) + (aLargeIntU basicAt: 3).       uL := ((aLargeIntU basicAt: 2) bitShift: 8) + (aLargeIntU basicAt: 1).        rH := ((aLargeIntR basicAt: 4) bitShift: 8) + (aLargeIntR basicAt: 3).       rL := ((aLargeIntR basicAt: 2) bitShift: 8) + (aLargeIntR basicAt: 1).</body><body package="DES" selector="uH">uH	^uH</body><body package="DES" selector="uH:uL:">uH: high16 uL: low16	uH := high16.	uL := low16.</body><body package="DES" selector="uL">uL	^uL</body></methods><methods><class-id>Security.DESHelper</class-id> <category>api IP and FP</category><body package="DES" selector="bitOrRreturningLargeInt:">bitOrRreturningLargeInt: aDESHelper	| high low int |	high := rH bitOr: aDESHelper rH.	low := rL bitOr: aDESHelper rL.	int := self class largeIntegerClass basicNew: 4.	int basicAt: 3 put: (high bitAnd: 16rff).	int basicAt:4 put: ((high bitShift: -8) bitAnd: 16rff).	int basicAt: 1 put: (low bitAnd: 16rff).	int basicAt:2 put: ((low bitShift: -8) bitAnd: 16rff).	^int</body><body package="DES" selector="bitOrUreturningLargeInt:">bitOrUreturningLargeInt: aDESHelper	| high low int |	high := uH bitOr: aDESHelper uH.	low := uL bitOr: aDESHelper uL.	int := self class largeIntegerClass basicNew: 4.	int basicAt: 3 put: (high bitAnd: 16rff).	int basicAt:4 put: ((high bitShift: -8) bitAnd: 16rff).	int basicAt: 1 put: (low bitAnd: 16rff).	int basicAt:2 put: ((low bitShift: -8) bitAnd: 16rff).	^int</body><body package="DES" selector="leftShiftRby1bitORedWithRRightShifted31LoadRegister:">leftShiftRby1bitORedWithRRightShifted31LoadRegister: aThirtyTwoBitRegister 	"do the operation and return a largeInt as a result	shift1 = 1 shift2=31"	| low1 high1 low2 high2 tl |	tl :=  ( rL bitShift: -15).	low1 := ( rL specialLeftShift1)  bitAnd: 16rffff.	high1 :=((rH specialLeftShift1  ) bitAnd: 16rffff) + ((tl) ).	low2 := ((rH bitShift: -15)				+ (rL bitShift: -31)) bitAnd: 16rffff.	high2 := rH bitShift: -31.	aThirtyTwoBitRegister hi: (high1 bitOr: high2) low: (low1 bitOr: low2).</body><body package="DES" selector="leftShiftRby1bitORedWithRRightShifted31SratchInt:">leftShiftRby1bitORedWithRRightShifted31SratchInt: aLargeInt 	"do the operation and return a largeInt as a result	shift1 = 1 shift2=31"	| low1 high1 low2 high2 bitOrHigh bitOrLow tl |	tl :=  ( rL bitShift: -15).	low1 := ( rL specialLeftShift1)  bitAnd: 16rffff.	high1 :=((rH specialLeftShift1  ) bitAnd: 16rffff) + ((tl) ).	low2 := ((rH bitShift: -15)				+ (rL bitShift: -31)) bitAnd: 16rffff.	high2 := rH bitShift: -31.	bitOrHigh := high1 bitOr: high2.	bitOrLow := low1 bitOr: low2.	aLargeInt basicAt: 3 put: (bitOrHigh bitAnd: 16rff).	aLargeInt basicAt: 4 put: ((bitOrHigh bitShift: -8)			bitAnd: 16rff).	aLargeInt basicAt: 1 put: (bitOrLow bitAnd: 16rff).	aLargeInt basicAt: 2 put: ((bitOrLow bitShift: -8)			bitAnd: 16rff).	^aLargeInt</body><body package="DES" selector="leftShiftRby:bitORedWithRRightShifted:">leftShiftRby: shift1 bitORedWithRRightShifted: shift2 	"do the operation and return a largeInt as a result"	| low1 high1 low2 high2 bitOrHigh bitOrLow int  tl |	rL := rL bitAnd: 16rffff.	shift1 &gt; 16 ifTrue:[ high1 :=  ( rL bitShift: shift1 -16)  bitAnd: 16rffff.					low1 := 0]	ifFalse:[	tl :=  ( rL bitShift: shift1- 16).	low1 := ( rL bitShift: shift1)  bitAnd: 16rffff.	high1 :=((rH bitShift: shift1  ) bitAnd: 16rffff) + ((tl) ).].	low2 := ((rH bitShift: 16 - shift2)				+ (rL bitShift: 0 - shift2)) bitAnd: 16rffff.	high2 := rH bitShift: 0 - shift2.	bitOrHigh := high1 bitOr: high2.	bitOrLow := low1 bitOr: low2.	int := largeIntegerClass basicNew: 4.	int basicAt: 3 put: (bitOrHigh bitAnd: 16rff).	int basicAt: 4 put: ((bitOrHigh bitShift: 0 - 8)			bitAnd: 16rff).	int basicAt: 1 put: (bitOrLow bitAnd: 16rff).	int basicAt: 2 put: ((bitOrLow bitShift: 0 - 8)			bitAnd: 16rff).	^int</body><body package="DES" selector="leftShiftUby1bitORedWithURightShifted31LoadRegister:">leftShiftUby1bitORedWithURightShifted31LoadRegister: aThirtyTwoBitRegister 	"do the operation and return a largeInt as a result"	| low1 high1 low2 high2  tl |	tl :=  ( uL bitShift: -15).	low1 := ( uL bitShift: 1)  bitAnd: 16rffff.	high1 :=((uH bitShift: 1  ) bitAnd: 16rffff) + ((tl) ).	low2 := ((uH bitShift: -15)				+ (uL bitShift: -31)) bitAnd: 16rffff.	high2 := uH bitShift: -31.	aThirtyTwoBitRegister hi: (high1 bitOr: high2) low: (low1 bitOr: low2).</body><body package="DES" selector="leftShiftUby1bitORedWithURightShifted31SratchInt:">leftShiftUby1bitORedWithURightShifted31SratchInt: aLargeInt 	"do the operation and return a largeInt as a result"	| low1 high1 low2 high2 bitOrHigh bitOrLow tl |	tl :=  ( uL bitShift: -15).	low1 := ( uL bitShift: 1)  bitAnd: 16rffff.	high1 :=((uH bitShift: 1  ) bitAnd: 16rffff) + ((tl) ).	low2 := ((uH bitShift: -15)				+ (uL bitShift: -31)) bitAnd: 16rffff.	high2 := uH bitShift: -31.	bitOrHigh := high1 bitOr: high2.	bitOrLow := low1 bitOr: low2.	aLargeInt basicAt: 3 put: (bitOrHigh bitAnd: 255).	aLargeInt basicAt: 4 put: ((bitOrHigh bitShift: -8)			bitAnd: 255).	aLargeInt basicAt: 1 put: (bitOrLow bitAnd: 255).	aLargeInt basicAt: 2 put: ((bitOrLow bitShift: -8)			bitAnd: 255).	^aLargeInt</body><body package="DES" selector="leftShiftUby:bitORedWithURightShifted:">leftShiftUby: shift1 bitORedWithURightShifted: shift2 	"do the operation and return a largeInt as a result"	| low1 high1 low2 high2 bitOrHigh bitOrLow int  tl |	uL := uL bitAnd: 16rffff.	shift1 &gt; 16 ifTrue:[ high1 :=  ( uL bitShift: shift1 -16)  bitAnd: 16rffff.					low1 := 0]	ifFalse:[	tl :=  ( uL bitShift: shift1- 16).	low1 := ( uL bitShift: shift1)  bitAnd: 16rffff.	high1 :=((uH bitShift: shift1  ) bitAnd: 16rffff) + ((tl) ).].	low2 := ((uH bitShift: 16 - shift2)				+ (uL bitShift: 0 - shift2)) bitAnd: 16rffff.	high2 := uH bitShift: 0 - shift2.	bitOrHigh := high1 bitOr: high2.	bitOrLow := low1 bitOr: low2.	int := largeIntegerClass basicNew: 4.	int basicAt: 3 put: (bitOrHigh bitAnd: 255).	int basicAt: 4 put: ((bitOrHigh bitShift: 0 - 8)			bitAnd: 255).	int basicAt: 1 put: (bitOrLow bitAnd: 255).	int basicAt: 2 put: ((bitOrLow bitShift: 0 - 8)			bitAnd: 255).	^int</body></methods><methods><class-id>Security.DESHelper</class-id> <category>api cycling</category><body package="DES" selector="cycleWithRShifted1maskH:maskL:">cycleWithRShifted1maskH: maskH maskL: maskL      | ttH ttL | 	ttH := (uH bitXor: (rH bitShift: -1)) bitAnd: maskH.       ttL := ((rH specialLeftShift15  ) + (rL bitShift: -1) bitXor: uL) bitAnd: maskL.       uH := uH bitXor: ttH.       uL := uL bitXor: ttL.       rH := rH bitXor: (ttH specialLeftShift1) + (ttL bitShift: (-15 )).       rL := rL bitXor: (ttL specialLeftShift1).</body><body package="DES" selector="cycleWithRShifted2maskH:maskL:">cycleWithRShifted2maskH: maskH maskL: maskL      | ttH ttL | 	ttH := (uH bitXor: (rH bitShift: -2)) bitAnd: maskH.       ttL := ((rH specialLeftShift14  ) + (rL bitShift: -2) bitXor: uL) bitAnd: maskL.       uH := uH bitXor: ttH.       uL := uL bitXor: ttL.       rH := rH bitXor: (ttH bitShift: 2) + (ttL bitShift: (-14 )).       rL := rL bitXor: (ttL bitShift: 2).</body><body package="DES" selector="cycleWithRShifted4maskH:maskL:">cycleWithRShifted4maskH: maskH maskL: maskL 	| ttH ttL |	ttH := (uH bitXor: (rH bitShift: -4))				bitAnd: maskH.	ttL := ((rH bitShift: 12)				+ (rL bitShift: -4) bitXor: uL)				bitAnd: maskL.	uH := uH bitXor: ttH.	uL := uL bitXor: ttL.	rH := rH bitXor: (ttH specialLeftShift4) + (ttL bitShift: -12).	rL := rL bitXor: (ttL specialLeftShift4)</body><body package="DES" selector="cycleWithRShifted:maskH:maskL:">cycleWithRShifted: shift maskH: maskH maskL: maskL      | ttH ttL |	rH := rH bitAnd: 16rffff.	rL := rL bitAnd: 16rffff.shift &gt; 15 ifTrue: [	ttH := (uH bitXor: (rH bitShift: 0 - shift)) bitAnd: maskH.       ttL := ((rH  ) + (rL bitShift: 0-shift) bitXor: uL) bitAnd: maskL.       uH := uH bitXor: ttH.       uL := uL bitXor: ttL.       rH := rH bitXor: (ttH bitShift: shift) + (ttL ).       rL := rL bitXor: (ttL bitShift: shift).] ifFalse:[	ttH := (uH bitXor: (rH bitShift: 0 - shift)) bitAnd: maskH.       ttL := ((rH bitShift: 16 -shift ) + (rL bitShift: 0-shift) bitXor: uL) bitAnd: maskL.       uH := uH bitXor: ttH.       uL := uL bitXor: ttL.       rH := rH bitXor: (ttH bitShift: shift) + (ttL bitShift: (shift - 16 )).       rL := rL bitXor: (ttL bitShift: shift).]</body><body package="DES" selector="cycleWithUShifted16maskH:maskL:">cycleWithUShifted16maskH: maskH maskL: maskL      | ttH ttL |	ttH :=  rH  bitAnd: maskH.       ttL := (uH   bitXor: rL) bitAnd: maskL.       rH := rH bitXor: ttH.       rL := rL bitXor: ttL.       uH := uH bitXor: ttL .</body><body package="DES" selector="cycleWithUShifted8maskH:maskL:">cycleWithUShifted8maskH: maskH maskL: maskL      | ttH ttL |	uH := uH bitAnd: 16rffff.	uL := uL bitAnd: 16rffff.	ttH := (  rH bitXor: (uH bitShift: -8)) bitAnd: maskH.       ttL := ((uH bitShift: 8 ) + (uL bitShift: -8) bitXor: rL) bitAnd: maskL.       rH := rH bitXor: ttH.       rL := rL bitXor: ttL.       uH := uH bitXor: (ttH specialLeftShift8) + (ttL bitShift: (-8 )).       uL := uL bitXor: (ttL specialLeftShift8).</body><body package="DES" selector="cycleWithUShifted:maskH:maskL:">cycleWithUShifted: shift maskH: maskH maskL: maskL      | ttH ttL |	uH := uH bitAnd: 16rffff.	uL := uL bitAnd: 16rffff.	shift &gt; 15 ifTrue: [	ttH := (  rH bitXor: (uH bitShift: 0 - shift)) bitAnd: maskH.       ttL := ((uH ) + (uL bitShift: 0-shift) bitXor: rL) bitAnd: maskL.       rH := rH bitXor: ttH.       rL := rL bitXor: ttL.       uH := uH bitXor: (ttH bitShift: shift) + (ttL ).       uL := uL bitXor: (ttL bitShift: shift). 	] ifFalse:[	ttH := (  rH bitXor: (uH bitShift: 0 - shift)) bitAnd: maskH.       ttL := ((uH bitShift: 16 -shift ) + (uL bitShift: 0-shift) bitXor: rL) bitAnd: maskL.       rH := rH bitXor: ttH.       rL := rL bitXor: ttL.       uH := uH bitXor: (ttH bitShift: shift) + (ttL bitShift: (shift - 16 )).       uL := uL bitXor: (ttL bitShift: shift).]</body></methods><methods><class-id>Security.DESHelper</class-id> <category>initialize</category><body package="DES" selector="initialize">initialize	largeIntegerClass := self class largeIntegerClass</body></methods><methods><class-id>Security.DESHelper class</class-id> <category>instance creation</category><body package="DES" selector="new">new	^super new initialize</body></methods><methods><class-id>Security.DESHelper class</class-id> <category>initialize</category><body package="DES" selector="initialize">initialize	largeIntegerClass := LargePositiveInteger.</body></methods><methods><class-id>Security.DESHelper class</class-id> <category>accesing</category><body package="DES" selector="largeIntegerClass">largeIntegerClass	^largeIntegerClass</body></methods><methods><class-id>Security.DES</class-id> <category>private encryption</category><body package="DES" selector="doBaseDesEncryptionEncryptionMode:">doBaseDesEncryptionEncryptionMode:  encrypt" do the base des encryption rounds See Applied Cryptography second edition by bruce schneier for detailed explanation of the algorithm"		| |	" do Initial Transformation  "	"IP&amp;FP can be done be done in 15 xor, 10 shifts and 5 ands. the DES Encryption helper does the moves in terms of small integers to aviod the large Integer math and since I know some of the results before hand I get a reduction in steps :-)"			"self halt."			helper cycleWithRShifted4maskH: 16r0f0f maskL: 16r0f0f.			helper cycleWithUShifted16maskH: 16r0000 maskL: 16rffff.			helper cycleWithRShifted2maskH: 16r3333 maskL: 16r3333.			helper cycleWithUShifted8maskH: 16r00ff maskL: 16r00ff.			helper cycleWithRShifted1maskH: 16r5555 maskL: 16r5555.	helper leftShiftUby1bitORedWithURightShifted31LoadRegister: registerR .	helper leftShiftRby1bitORedWithRRightShifted31LoadRegister: registerL." perform the actual rounds decrypting moves it in the oposite direction as encrypting this is the sbox and P box permutations that are done with one array that represents the  application of the two permutations. this speeds up the encryption proces by combining these steps."		encrypt 			ifTrue: [				1 to: 32 by: 8 do:[:step | "self halt."					self doRound1Index1:  step+0  index2:  step+0+1.					self doRound2Index1: step+2 index2: step+2+1.					self doRound1Index1:  step+4 index2: step+4+1.					self doRound2Index1:  step+6 index2: step+6+1.				]] 			ifFalse:[				31 to: 0 by: -8 do:[:step |					self doRound1Index1:  step-0 index2: step-0+1.					self doRound2Index1:  step-2 index2: step-2+1.					self doRound1Index1:  step-4 index2: step-4+1.					self doRound2Index1:  step-6 index2: step-6+1.				]].	"do final permutation  "		registerL rightShiftby1bitORedWithLeftShifted31LoadHelperU:  helper. 				registerR rightShiftby1bitORedWithLeftShifted31LoadHelperR:   helper.			helper cycleWithRShifted1maskH: 16r5555 maskL: 16r5555.			helper cycleWithUShifted8maskH: 16r00ff maskL: 16r00ff.			helper cycleWithRShifted2maskH: 16r3333 maskL: 16r3333.			helper cycleWithUShifted16maskH: 16r0000 maskL: 16rffff.			helper cycleWithRShifted4maskH: 16r0f0f maskL: 16r0f0f." confused? so am I but that is the point of encryption :-)"</body><body package="DES" selector="doBaseDesEncryptionOn:encryptionMode:">doBaseDesEncryptionOn: dataArray encryptionMode:  encrypt" do the base des encryption rounds See Applied Cryptography second edition by bruce schneier for detailed explanation of the algorithm"		| |		helper  u: (dataArray at: 1)  r: (dataArray at: 2).	" do Initial Transformation  "	"IP&amp;FP can be done be done in 15 xor, 10 shifts and 5 ands. the DES Encryption helper does the moves in terms of small integers to aviod the large Integer math and since I know some of the results before hand I get a reduction in steps :-)"			"self halt."			helper cycleWithRShifted4maskH: 16r0f0f maskL: 16r0f0f.			helper cycleWithUShifted16maskH: 16r0000 maskL: 16rffff.			helper cycleWithRShifted2maskH: 16r3333 maskL: 16r3333.			helper cycleWithUShifted8maskH: 16r00ff maskL: 16r00ff.			helper cycleWithRShifted1maskH: 16r5555 maskL: 16r5555.	helper leftShiftUby1bitORedWithURightShifted31LoadRegister: registerR .	helper leftShiftRby1bitORedWithRRightShifted31LoadRegister: registerL." perform the actual rounds decrypting moves it in the oposite direction as encrypting this is the sbox and P box permutations that are done with one array that represents the  application of the two permutations. this speeds up the encryption proces by combining these steps."		encrypt 			ifTrue: [				1 to: 32 by: 8 do:[:step | "self halt."					self doRound1Index1:  step+0  index2:  step+0+1.					self doRound2Index1: step+2 index2: step+2+1.					self doRound1Index1:  step+4 index2: step+4+1.					self doRound2Index1:  step+6 index2: step+6+1.				]] 			ifFalse:[				31 to: 0 by: -8 do:[:step |					self doRound1Index1:  step-0 index2: step-0+1.					self doRound2Index1:  step-2 index2: step-2+1.					self doRound1Index1:  step-4 index2: step-4+1.					self doRound2Index1:  step-6 index2: step-6+1.				]].	"do final permutation  "		registerL rightShiftby1bitORedWithLeftShifted31LoadHelperU:  helper. 		registerR rightShiftby1bitORedWithLeftShifted31LoadHelperR:   helper.			helper cycleWithRShifted1maskH: 16r5555 maskL: 16r5555.			helper cycleWithUShifted8maskH: 16r00ff maskL: 16r00ff.			helper cycleWithRShifted2maskH: 16r3333 maskL: 16r3333.			helper cycleWithUShifted16maskH: 16r0000 maskL: 16rffff.			helper cycleWithRShifted4maskH: 16r0f0f maskL: 16r0f0f.	"put the new data into the data array passed in, and zero out the temps because we are paranoid and also since they (NIST) tell us to to get rid of memory references asap. However in smalltalk one would be very challenged to try and look at the memory space and gues where the temporaries are hiding. doubt seriously if could be done."		dataArray at: 1 put: helper getUasLargeInt.		dataArray at: 2 put: helper getRasLargeInt." confused? so am I but that is the point of encryption :-)"</body><body package="DES" selector="doEcbEncryptBlock:encrypt:">doEcbEncryptBlock: input encrypt: encrypt		|   ouputArray l  |			ouputArray :=  byteArrayClass new: 8.		helper loadFrom: input .		self doBaseDesEncryptionEncryptionMode:  encrypt.		l := helper getUasLargeIntLoading: largePositiveScratchIntU.		"order the result"		1 to: 4 do:[:index | ouputArray at: index put: (l basicAt: index)].		l := helper getRasLargeIntLoading: largePositiveScratchIntR.		1 to: 4 do:[:index | ouputArray at: index + 4 put: (l basicAt: index)].	^ouputArray</body><body package="DES" selector="doRound1Index1:index2:">doRound1Index1: index1 index2: index2 			registerU hi: registerR hi low: registerR low.			registerT hi: registerR hi low: registerR low.			registerU bitXor:  (keySchedule at:index1). 			registerT bitXor:  (keySchedule at: index2 ).			registerT functionLR.			registerL bitXor:  (self computeSPRegisterTransformationU: registerU t: registerT).</body><body package="DES" selector="doRound2Index1:index2:">doRound2Index1: index1 index2: index2 			registerU hi: registerL hi low: registerL low.			registerT hi: registerL hi low: registerL low.			registerU bitXor:  (keySchedule at:index1). 			registerT bitXor:  (keySchedule at: index2 ).			registerT functionLR.			registerR bitXor: (self computeSPRegisterTransformationU: registerU t: registerT).</body><body package="DES" selector="olddoBaseDesEncryptionOn:encryptionMode:">olddoBaseDesEncryptionOn: dataArray encryptionMode:  encrypt" do the base des encryption rounds See Applied Cryptography second edition by bruce schneier for detailed explanation of the algorithm"		| |		helper  u: (dataArray at: 1)  r: (dataArray at: 2).	" do Initial Transformation  "	"IP&amp;FP can be done be done in 15 xor, 10 shifts and 5 ands. the DES Encryption helper does the moves in terms of small integers to aviod the large Integer math and since I know some of the results before hand I get a reduction in steps :-)"			"self halt."			helper cycleWithRShifted4maskH: 16r0f0f maskL: 16r0f0f.			helper cycleWithUShifted16maskH: 16r0000 maskL: 16rffff.			helper cycleWithRShifted2maskH: 16r3333 maskL: 16r3333.			helper cycleWithUShifted8maskH: 16r00ff maskL: 16r00ff.			helper cycleWithRShifted1maskH: 16r5555 maskL: 16r5555.	registerR loadLarge: (helper leftShiftUby1bitORedWithURightShifted31SratchInt: largePositiveScratchIntU)  .	registerL loadLarge: (helper leftShiftRby1bitORedWithRRightShifted31SratchInt: largePositiveScratchIntR)." perform the actual rounds decrypting moves it in the oposite direction as encrypting this is the sbox and P box permutations that are done with one array that represents the  application of the two permutations. this speeds up the encryption proces by combining these steps."		encrypt 			ifTrue: [				1 to: 32 by: 8 do:[:step | "self halt."					self doRound1Index1:  step+0  index2:  step+0+1.					self doRound2Index1: step+2 index2: step+2+1.					self doRound1Index1:  step+4 index2: step+4+1.					self doRound2Index1:  step+6 index2: step+6+1.				]] 			ifFalse:[				31 to: 0 by: -8 do:[:step |					self doRound1Index1:  step-0 index2: step-0+1.					self doRound2Index1:  step-2 index2: step-2+1.					self doRound1Index1:  step-4 index2: step-4+1.					self doRound2Index1:  step-6 index2: step-6+1.				]].	"do final permutation  "		helper  u: (registerL rightShiftby: 1 bitORedWithLeftShifted: 31  ) r: (registerR rightShiftby: 1 bitORedWithLeftShifted: 31  ).			helper cycleWithRShifted1maskH: 16r5555 maskL: 16r5555.			helper cycleWithUShifted8maskH: 16r00ff maskL: 16r00ff.			helper cycleWithRShifted2maskH: 16r3333 maskL: 16r3333.			helper cycleWithUShifted16maskH: 16r0000 maskL: 16rffff.			helper cycleWithRShifted4maskH: 16r0f0f maskL: 16r0f0f.	"put the new data into the data array passed in, and zero out the temps because we are paranoid and also since they (NIST) tell us to to get rid of memory references asap. However in smalltalk one would be very challenged to try and look at the memory space and gues where the temporaries are hiding. doubt seriously if could be done."		dataArray at: 1 put: helper getUasLargeInt.		dataArray at: 2 put: helper getRasLargeInt." confused? so am I but that is the point of encryption :-)"</body><body package="DES" selector="olddoEcbEncryptBlock:encrypt:">olddoEcbEncryptBlock: input encrypt: encrypt		| inIndex  ouputArray l llArray |	inIndex := 1.			ouputArray :=  byteArrayClass new: 8.		llArray :=  arrayClass new: 2.		l := self get32bitsFrom: input Index: inIndex.		llArray at: 1 put: l.		l := self get32bitsFrom: input Index: inIndex + 4.		llArray at: 2 put: l.		self doBaseDesEncryptionOn: llArray encryptionMode:  encrypt.				l := llArray at: 1.		"order the result"		1 to: 4 do:[:index | ouputArray at: index put: (l basicAt: index)].		l := llArray at: 2.		1 to: 4 do:[:index | ouputArray at: index + 4 put: (l basicAt: index)].		llArray at: 1 put: 0.		llArray at: 2 put: 0.	^ouputArray</body></methods><methods><class-id>Security.DES</class-id> <category>private utilities</category><body package="DES" selector="computeSPRegisterTransformationU:t:">computeSPRegisterTransformationU: u t: t 	"u and t are instances of thirtyTwo bit register this returns a 32 bit register"	"the first register is a copy since the register on the left alters and holds the values"	| firstSpRegister |	firstSpRegister := spRegisterTransformation2 at: (t low bitAnd: 16r3f) + 1.	spRegisterTransformation2ScratchRegister hi: firstSpRegister hi low: firstSpRegister low.	^((((((spRegisterTransformation2ScratchRegister bitOr: (spRegisterTransformation4 at: t rightShift8maskL16r3f + 1))		bitOr: (spRegisterTransformation6 at: t rightShift16maskL16r3f + 1))		bitOr: (spRegisterTransformation8 at: t rightShift24maskL16r3f + 1))		bitOr: (spRegisterTransformation1 at: (u low bitAnd: 16r3f)+ 1))		bitOr: (spRegisterTransformation3 at: u rightShift8maskL16r3f + 1))		bitOr: (spRegisterTransformation5 at: u rightShift16maskL16r3f + 1))		bitOr: (spRegisterTransformation7 at: u rightShift24maskL16r3f + 1)</body><body package="DES" selector="get32bitsFrom:Index:">get32bitsFrom: inputArray Index: index	| int intIndex |	int := self class largePositiveIntegerClass basicNew: 4.	intIndex := 0.	index to: index+ 3 do:[:ind | int basicAt: (intIndex := intIndex +1) put: (inputArray at: ind)].	^int</body><body package="DES" selector="oldcomputeSPRegisterTransformationU:t:">oldcomputeSPRegisterTransformationU: u t: t	"u and t are instances of thirtyTwo bit register this returns a 32 bit register""the first register is a copy since the register on the left alters and holds the values"^(((((((((spRegisterTransformation2) at: (((t low) bitAnd: 16r3f) +1)) shallowCopy					bitOr: ((spRegisterTransformation4) at: ((t rightShift: 8 maskL: 16r3f) +1)))					bitOr: ((spRegisterTransformation6) at: ((t rightShift: 16 maskL: 16r3f) +1)))					bitOr: ((spRegisterTransformation8) at: ((t rightShift: 24 maskL: 16r3f) +1)))					bitOr: ((spRegisterTransformation1) at: (((u low) bitAnd: 16r3f) +1)))					bitOr: ((spRegisterTransformation3) at: ((u rightShift: 8 maskL: 16r3f) +1)))					bitOr: ((spRegisterTransformation5) at: ((u rightShift: 16 maskL: 16r3f) +1)))					bitOr: ((spRegisterTransformation7) at: ((u rightShift: 24 maskL: 16r3f) ) +1))</body><body package="DES" selector="setKeySheduleFromKey:">setKeySheduleFromKey: key	" hopefully a faster implementation of computing the key schedule I use the ThirtyTwoBitRegisterClass to eliminate all theLarge integer operations in determining the key schedule. Looks complex and it is. also there are special shifts on small integer to preven large int math as well."	| c d t s   kIndex  keyArray  |		kIndex :=1.		keySchedule :=  arrayClass new: 32.		keyArray := key .		c := reg shallowCopy loadTop32:  keyArray .		d := reg shallowCopy loadBottom32: keyArray.		t := (((d shallowCopy rightShift4) bitXor: c) maskH: 16r0f0f maskL: 16r0f0f).		c bitXor: t.		d bitXor:(t shallowCopy leftShift4).		t := (((c shallowCopy leftShift18) bitXor: c) maskL16r0maskH: 16rcccc ).		c bitXor: (t shallowCopy  bitXor: (t shallowCopy rightShift18)).		t := ((d shallowCopy  leftShift18) bitXor: d) maskL16r0maskH: 16rcccc .		d bitXor: (t shallowCopy bitXor: (t shallowCopy rightShift18)).		t := ((d shallowCopy rightShift1) bitXor: c)maskH: 16r5555 maskL: 16r5555.		c bitXor: t.		d bitXor: (t shallowCopy leftShift1).		t := ((c shallowCopy rightShift8) bitXor: d) maskH: 16r00ff maskL: 16r00ff.		d bitXor: t.		c bitXor: (t shallowCopy leftShift8).		t := ((d shallowCopy rightShift1)bitXor: c) maskH: 16r5555 maskL: 16r5555.		c bitXor: t.		d bitXor: (t shallowCopy leftShift1). 				d := (((((d shallowCopy maskH16r0maskL: 16r000ff) leftShift16) bitOr: (d shallowCopy maskH16r0maskL: 16rff00)) bitOr: ((d shallowCopy maskL16r0maskH: 16r00ff ) rightShift16)) bitOr: ((c shallowCopy maskL16r0maskH: 16rf000 ) rightShift4)).		c maskH: 16r0fff.		1 to: 16 do:[:index | 		(alternateShiftSequence at: index) ifTrue:[				c := ((c shallowCopy rightShift2) bitOr: (c  leftShift26)).				d := ((d shallowCopy rightShift2) bitOr: (d  leftShift26)). ]			ifFalse:[				c := ((c shallowCopy rightShift1) bitOr: (c  leftShift27)).				d := ((d shallowCopy rightShift1) bitOr: (d  leftShift27)).].				c maskH: 16r0fff.			d maskH: 16r0fff.			s :=	 (((((skbRegisterTransformation at:1) at: ( ((c  low  ) bitAnd: 16r3f) + 1    ))  shallowCopy bitOr:				((skbRegisterTransformation at: 2) at: (((c  rightShift6maskL16r03) bitOr: (c  rightShift7maskL16r3c)) +1)  ) )  bitOr:				((skbRegisterTransformation at: 3) at: (((c  rightShift13maskL16r0f) bitOr: (c  rightShift14maskL16r30)) +1)  ) ) bitOr:				((skbRegisterTransformation at: 4) at: ((((c rightShift20maskL16r01) bitOr: (c  rightShift21maskL16r06))  bitOr: (c  rightShift22maskL16r38)) +1))).			t :=	(((((skbRegisterTransformation at: 5) at: (((d low  ) bitAnd: 16r3f)      + 1          )) shallowCopy  bitOr:				((skbRegisterTransformation at: 6) at: (((d  rightShift7maskL16r03) bitOr: (d  rightShift8maskL16r3c)) + 1) ) )   bitOr:				((skbRegisterTransformation at: 7) at: ((d  rightShift15maskL16r3f)         + 1       )) )  bitOr:				((skbRegisterTransformation at: 8) at: ((((d rightShift21maskL16r0f) bitOr: (d rightShift22maskL16r30))) +1))).			keySchedule at: kIndex  put:  (((t shallowCopy leftShift16) bitOr: (s shallowCopy  maskH16r0maskL: 16rffff)) ).			kIndex := kIndex + 1.			s := ((s shallowCopy rightShift16) bitOr: (t  maskL16r0maskH: 16rffff )).			s := (s shallowCopy leftShift4) bitOr: (s  rightShift28).			keySchedule at: kIndex  put: s .			kIndex := kIndex + 1.		].</body></methods><methods><class-id>Security.DES</class-id> <category>accessing</category><body package="DES" selector="checkForWeakKey">checkForWeakKey	^checkForWeakKey isNil ifTrue:[checkForWeakKey  := false] ifFalse:[checkForWeakKey ].</body><body package="DES" selector="encryptInPlace">encryptInPlace	^encryptInPlace isNil ifTrue:[encryptInPlace  := true] ifFalse:[encryptInPlace ].</body><body package="DES" selector="ignoreParity">ignoreParity	^ignoreParity isNil ifTrue:[ignoreParity  := true] ifFalse:[ignoreParity ].</body><body package="DES" selector="ignoreParity:">ignoreParity: aBooleen	ignoreParity  :=aBooleen</body><body package="DES" selector="setEncryptInPlace:">setEncryptInPlace: aBooleen	encryptInPlace  :=aBooleen</body></methods><methods><class-id>Security.DES</class-id> <category>services</category><body package="DES" selector="decryptInPlace:at:">decryptInPlace: aByteArray at: start"Decrypt in place one block of &lt;aByteArray&gt; at postion &lt;start&gt;.Block size is defined by the encryption algorithm."		aByteArray		replaceFrom: start		to: start + 7		with: (self				doEcbEncryptBlock: (aByteArray copyFrom: start to: start + 7)				encrypt: false)		startingAt: 1</body><body package="DES" selector="encryptInPlace:at:">encryptInPlace: aByteArray at: start"Encrypt in place one block of &lt;aByteArray&gt; at postion &lt;start&gt;.Block size is defined by the encryption algorithm."	aByteArray		replaceFrom: start		to: start + 7		with: (self				doEcbEncryptBlock: (aByteArray copyFrom: start to: start + 7)				encrypt: true)		startingAt: 1</body></methods><methods><class-id>Security.DES</class-id> <category>initialize</category><body package="DES" selector="initialize">initialize	super initialize.	helper := self class desHelperClass new.	helperU := self class desHelperClass new .	helperT := self class desHelperClass new.	registerR := self class registerClass basicNew.	registerU := self class registerClass basicNew.	registerT := self class registerClass basicNew.	registerL := self class registerClass basicNew.	spRegisterTransformation2ScratchRegister := self class registerClass basicNew.	spRegisterTransformation := self class spRegisterTransformation .	skbTransformation := self class skbTransformation.	skbRegisterTransformation := self class skbRegisterTransformation.	spRegisterTransformation1 := spRegisterTransformation at:  1.	spRegisterTransformation2 := spRegisterTransformation at: 2.	spRegisterTransformation3 := spRegisterTransformation at: 3.	spRegisterTransformation4 := spRegisterTransformation at: 4.	spRegisterTransformation5 := spRegisterTransformation at: 5.	spRegisterTransformation6 := spRegisterTransformation at: 6.	spRegisterTransformation7 := spRegisterTransformation at: 7.	spRegisterTransformation8 := spRegisterTransformation at: 8.	alternateShiftSequence := self class alternateShiftSequence.	reg := self class registerClass basicNew.  	arrayClass := self class arrayClass. 	byteArrayClass  := self class byteArrayClass. 	largePositiveIntegerClass := self class largePositiveIntegerClass.	largePositiveScratchIntR := largePositiveIntegerClass  basicNew:4. 	largePositiveScratchIntU := largePositiveIntegerClass  basicNew:4.	"keySchedule := Array new: 16.	1 to: 16 do: [:i | keySchedule at: i put: (Array new: 48)]."</body><body package="DES" selector="reset">reset	 keySchedule := nil.</body><body package="DES" selector="setKey:">setKey: an8ByteArray"Initialize the cipher with the given key.The key has to be 8 byte size."	self setKeySheduleFromKey: an8ByteArray</body></methods><methods><class-id>Security.DES</class-id> <category>encryption decryption</category><body package="DES" selector="decrypt:with:">decrypt: aTextStream with: aKey" this is the ecb mode of decryption for a stream "| extra byteArray key |	key := aKey asBigEndianByteArray.	byteArray := aTextStream asByteArray  .	self ignoreParity ifFalse:[(self class checkKeyParity: key) ifFalse:[self class badKeySignal raise]].	self setKeySheduleFromKey: key.	1 to: byteArray size - 7 by: 8 do:[:ind | |decyptedSublock|  decyptedSublock := self doEcbEncryptBlock: ( byteArray copyFrom: (ind ) to: ind + 7) encrypt: false.											" to save time and space replace unencrytpedBytes with the encrypted ones"										byteArray replaceBytesFrom: (ind ) to:  ind + 7with: decyptedSublock startingAt: 1]."now see from the last block if we had to pad"	extra := byteArray last + 1. ((extra &lt; 0) or:[extra &gt; 8 ]) ifTrue:[ self class decryptionFailedSignal raise].	self reset.^byteArray copyFrom: 1 to: (aTextStream size - extra)</body><body package="DES" selector="decryptBlock:with:">decryptBlock: aTextBlock with: aKey	| key textBlock |	key := aKey asBigEndianByteArray.	textBlock := aTextBlock asByteArray.	self ignoreParity ifFalse:[(self class checkKeyParity: key) ifFalse:[self class badKeySignal raise]].	keySchedule isNil ifTrue:[ self setKeySheduleFromKey: key.].	^self doEcbEncryptBlock: textBlock encrypt: false</body><body package="DES" selector="decryptPerfectSizeStream:with:">decryptPerfectSizeStream: aByteArray with: aKey 	"this array *must be* a multiple of 8 if not throw and exception. with this one we must be passed a 	byteArray"	"this is the ecb mode of encryption for a stream"	| byteArray key |	key := aKey asBigEndianByteArray.	aByteArray size \\ 8 = 0 ifFalse: [self class arrayLengthErrorSignal raise].	byteArray := self encryptInPlace				ifTrue: ["since we have a perfect block we have the option of decrypting in place to 					speed things up. 					this means the ByteArray passed in will then be the decrypted text"					aByteArray]				ifFalse: [aByteArray copy].	self ignoreParity ifFalse: [(self class checkKeyParity: key)			ifFalse: [self class badKeySignal raise]].	self setKeySheduleFromKey: key.	0		to: byteArray size - 8		by: 8		do: 			[:ind | 			| encyptedSublock |			encyptedSublock := self doEcbEncryptBlock: (byteArray copyFrom: ind + 1 to: ind + 8)						encrypt: false.	"to save time and space replace unencrytpedBytes with the encrypted ones"			byteArray				replaceBytesFrom: ind + 1				to: ind + 8				with: encyptedSublock				startingAt: 1].	self reset.	^byteArray</body><body package="DES" selector="encrypt:with:">encrypt: aTextStream with: aKey" one of the things we have to look at is the issue of when we don't have and even 64 bits. I am going to to it the way I think it is done with netscape where theypad with random bytes int the last block to make it even, the last byte indicates the extra bytes we had. we put that in the last byte. If the was no extra the we are padded 8 bytes already fill unused bytes with.random numbers for the pad bytes can just be a simple random number  (Random new next * 256) floor. we just don't want the text to have the chance of some how looknig the same, but it doesn have to be the CrpRandom that is nessary for other things like DSS and RSA key generation etc ."" this is the ecb mode of encryption for a stream "| extra byteArray endOfRealArray  start key |	key := aKey asBigEndianByteArray.	endOfRealArray := aTextStream size.	extra := 8 - (endOfRealArray \\ 8).	"add extra + the last block that we use to figure out the pad"	byteArray := aTextStream asByteArray growTo: aTextStream size + extra. " this results in generating a copy."	start := endOfRealArray + 1.	start to: byteArray size - 1 do:[:ind | byteArray at: ind put: ((Random new next * 256) floor )].	byteArray at: byteArray size put: extra -1.	self ignoreParity ifFalse:[(self class checkKeyParity: key) ifFalse:[self class badKeySignal raise]].	self setKeySheduleFromKey: key.	1 to: byteArray size - 7 by: 8  do:[:ind | |encyptedSublock|  encyptedSublock := self doEcbEncryptBlock: (byteArray copyFrom: ind to: ind + 7) encrypt: true.											" to save time and space replace unencrytpedBytes with the encrypted ones"										byteArray				replaceBytesFrom: ind				to: ind + 7				with: encyptedSublock 				startingAt: 1].	self reset.	^byteArray</body><body package="DES" selector="encryptBlock:with:">encryptBlock: aTextBlock with: aKey	| key textBlock |	key := aKey asBigEndianByteArray.	textBlock := aTextBlock asByteArray.	self ignoreParity ifFalse:[(self class checkKeyParity: key) ifFalse:[self class badKeySignal raise]].	keySchedule isNil ifTrue:[ self setKeySheduleFromKey: key.].	^self doEcbEncryptBlock: textBlock encrypt: true</body><body package="DES" selector="encryptPerfectSizeStream:with:">encryptPerfectSizeStream: aByteArray with: aKey 	"this array *must be* a multiple of 8 if not throw and exception. with this one we must be passed a 	byteArray"	"this is the ecb mode of encryption for a stream"	| byteArray key |	key := aKey asBigEndianByteArray.	aByteArray size \\ 8 = 0 ifFalse: [self class arrayLengthErrorSignal raise].	byteArray := self encryptInPlace				ifTrue: ["since we have a perfect block we have the option of encrypting in place to 					speed things up. 					this means the ByteArray passed in will then be the encrypted text"					aByteArray]				ifFalse: [aByteArray copy].	self ignoreParity ifFalse: [(self class checkKeyParity: key)			ifFalse: [self class badKeySignal raise]].	self setKeySheduleFromKey: key.	0		to: byteArray size - 8		by: 8		do: 			[:ind | 			| encyptedSublock |			encyptedSublock := self doEcbEncryptBlock: (byteArray copyFrom: ind + 1 to: ind + 8)						encrypt: true.	"to save time and space replace unencrytpedBytes with the encrypted ones"			byteArray				replaceBytesFrom: ind + 1				to: ind + 8				with: encyptedSublock				startingAt: 1].	self reset.	^byteArray</body><body package="DES" selector="newDecryptBlock:with:">newDecryptBlock: aTextBlock with: aKey	| key textBlock |	key := aKey asBigEndianByteArray.	textBlock := aTextBlock asByteArray.	self ignoreParity ifFalse:[(self class checkKeyParity: key) ifFalse:[self class badKeySignal raise]].	self setKeySheduleFromKey: key.	^self doEcbEncryptBlock: textBlock encrypt: false</body><body package="DES" selector="newEncryptBlock:with:">newEncryptBlock: aTextBlock with: aKey	| key textBlock |	key := aKey asBigEndianByteArray.	textBlock := aTextBlock asByteArray.	self ignoreParity ifFalse:[(self class checkKeyParity: key) ifFalse:[self class badKeySignal raise]].	self setKeySheduleFromKey: key.	^self doEcbEncryptBlock: textBlock encrypt: true</body></methods><methods><class-id>Security.DES class</class-id> <category>accessing</category><body package="DES" selector="alternateShiftSequence">alternateShiftSequence	^alternateShiftSequence</body><body package="DES" selector="arrayClass">arrayClass	^arrayClass</body><body package="DES" selector="blockSize">blockSize	^8</body><body package="DES" selector="byteArrayClass">byteArrayClass	^byteArrayClass</body><body package="DES" selector="desHelperClass">desHelperClass	^desHelperClass</body><body package="DES" selector="largePositiveIntegerClass">largePositiveIntegerClass	^largePositiveIntegerClass</body><body package="DES" selector="registerClass">registerClass	^registerClass</body><body package="DES" selector="skbRegisterTransformation">skbRegisterTransformation	^skbRegisterTransformation</body><body package="DES" selector="skbTransformation">skbTransformation	^skbTransformation</body><body package="DES" selector="spRegisterTransformation">spRegisterTransformation	^spRegisterTransformation</body></methods><methods><class-id>Security.DES class</class-id> <category>signal constants</category><body package="DES" selector="arrayLengthErrorSignal">arrayLengthErrorSignal	^DESArrayLengthError</body><body package="DES" selector="badKeySignal">badKeySignal	^DESBadKeySignal</body><body package="DES" selector="decryptionFailedSignal">decryptionFailedSignal	^DESDecryptionFailed</body><body package="DES" selector="weakKeySignal">weakKeySignal	^DESWeakKeySignal</body></methods><methods><class-id>Security.DES class</class-id> <category>key testing</category><body package="DES" selector="checkKeyParity:">checkKeyParity: aKey	| keyArray |	keyArray := aKey asBigEndianByteArray reverse.	keyArray do:[:eachByte | (OddParityCheck at: (eachByte bitAnd: 16rff) + 1 ) ~= eachByte ifTrue:[^false]].	^true</body><body package="DES" selector="isDESKeyWeak:">isDESKeyWeak: aDESKey	^((WeakKeys contains: [:weakKey | weakKey = aDESKey]) or: [SemiWeakKeys contains: [:semiWeakKey | semiWeakKey = aDESKey]]) or:[PossiblyWeakKeys contains: [:possiblyWeakKey | possiblyWeakKey = aDESKey]]</body></methods><methods><class-id>Security.DES class</class-id> <category>intialize</category><body package="DES" selector="initialize">initialize	"self initialize"	registerClass := ThirtyTwoBitRegister.	desHelperClass := DESHelper.	arrayClass := Array.	byteArrayClass := ByteArray.	largePositiveIntegerClass := LargePositiveInteger.	self initializeShiftSequence.	self initializeWeakKeysArray.	self initializePossiblyWeakKeysArray.	self initializeSemiWeakKeysArray.	self initializeOddParityCheck.	self initializeSPtransformation.	self initializeSPRegisterTransformation.	self initializeSKBTransformation.	self initializeSKBRegisterTransformation.	self intializeAlternateShiftSequence.	spRegisterTransformation := SPRegisterTransformation.	skbTransformation := SKBTransformation.	skbRegisterTransformation := SKBRegisterTransformation.	alternateShiftSequence := AlternateShiftSequence</body><body package="DES" selector="initializeOddParityCheck">initializeOddParityCheckOddParityCheck := #[  1   1   2   2   4   4   7   7   8   8  11  11  13  13  14  14  16  16  19  19  21  21  22  22  25  25  26  26  28  28  31  31  32  32  35  35  37  37  38  38  41  41  42  42  44  44  47  47  49  49  50  50  52  52  55  55  56  56  59  59  61  61  62  62  64  64  67  67  69  69  70  70  73  73  74  74  76  76  79  79  81  81  82  82  84  84  87  87  88  88  91  91  93  93  94  94  97  97  98  98 100 100 103 103 104 104 107 107 109 109 110 110 112 112 115 115 117 117 118 118 121 121 122 122 124 124 127 127 128 128 131 131 133 133 134 134 137 137 138 138 140 140 143 143 145 145 146 146 148 148 151 151 152 152 155 155 157 157 158 158 161 161 162 162 164 164 167 167 168 168 171 171 173 173 174 174 176 176 179 179 181 181 182 182 185 185 186 186 188 188 191 191 193 193 194 194 196 196 199 199 200 200 203 203 205 205 206 206 208 208 211 211 213 213 214 214 217 217 218 218 220 220 223 223 224 224 227 227 229 229 230 230 233 233 234 234 236 236 239 239 241 241 242 242 244 244 247 247 248 248 251 251 253 253 254 254]</body><body package="DES" selector="initializePossiblyWeakKeysArray">initializePossiblyWeakKeysArray"There are other keys that produce only four sub-keys. These keys are called possibly weak keys"PossiblyWeakKeys := #(16r1F1F0100E0E0101 16r011F1F01010E0E01 16r1F01011F0E01010E 16r01011F1F01010E0E 16rE0E00101F1F10101 16rFEFE0101FEFE0101 16rFEE01F01FEF10E01 16rE0FE1F01F1FE0E01 16rFEE0011FFEF1010E 16rE0FE011FF1FE010E 16rE0E01F1FF1F10E0E 16rFEFE1F1FFEFE0E0E 16r1F1F01010E0E0101 16r011F1F01010E0E01 16r1F01011F0E01010E 16r01011F1F01010E0E 16r01E0E00101F1F101 16r1FFEE0010EFEF001 16r1FE0FE010EF1FE01 16r01FEFE0101FEFE01 16r1FE0E01F0EF1F10E 16r01FEE01F01FEF10E 16r01E0FE1F01F1FE0E 16r1FFEFE1F0EFEFE0E 16rE00101E0F10101F1 16rFE1F01E0FE0E0EF1 16rFE011FE0FE010EF1 16rE01F1FE0F10E0EF1 16rFE0101FEFE0101FE 16rE01F01FEF10E01FE 16rE0011FFEF1010EFE 16rFE1F1FFEFE0E0EFE 16r1FFE01E00EFE01F1 16r01FE1FE001FE0EF1 16r1FE001FE0EF101FE 16r01E01FFE01F10EFE 16r0101E0E00101F1F1 16r1F1FE0E00E0EF1F1 16r1F01FEE00E01FEF1 16r011FFEE0010EFEF1 16r1F01E0FE0E01F1FE 16r011FE0FE010EF1FE 16r0101FEFE0001FEFE 16r1F1FFEFE0E0EFEFE 16rFEFEE0E0FEFEF1F1 16rE0FEFEE0F1FEFEF1 16rFEE0E0FEFEF1F1FE 16rE0E0FEFEF1F1FEFE ).</body><body package="DES" selector="initializeSemiWeakKeysArray">initializeSemiWeakKeysArray"Some pairs of keys encrypt plaintext to identical ciphertext. These semi-weak keys are"	SemiWeakKeys := #(16r01FE01FE01FE01FE 16rFE01FE01FE01FE01 16r1FE01FE00EF10EF1 16rE01FE01FF10EF10E 16r01E001E001F101F1 16rE001E001F101F101 16r1FFE1FFE0EFE0EFE 16rFE1FFE1FFE0EFE0E 16r011F011F010E010E 16r1F011F010E010E01 16rE0FEE0FEF1FEF1FE 16rFEE0FEE0FEF1FEF1)</body><body package="DES" selector="initializeShiftSequence">initializeShiftSequence	AlternateShiftSequence := #(false false true true true true true true false true true true true true true false)</body><body package="DES" selector="initializeSKBRegisterTransformation">initializeSKBRegisterTransformationSKBRegisterTransformation := Array new: 8.SKBTransformation doWithIndex:[:each :index | |array| array := Array new: 64.	each doWithIndex:[:eachValue :ind | array at: ind put: (ThirtyTwoBitRegister basicNew load: eachValue)].	SKBRegisterTransformation at: index put: array.].</body><body package="DES" selector="initializeSKBTransformation">initializeSKBTransformationSKBTransformation :=#(		#(		16r00000000 16r00000010 16r20000000 16r20000010 		16r00010000 16r00010010 16r20010000 16r20010010 		16r00000800 16r00000810 16r20000800 16r20000810 		16r00010800 16r00010810 16r20010800 16r20010810 		16r00000020 16r00000030 16r20000020 16r20000030 		16r00010020 16r00010030 16r20010020 16r20010030 		16r00000820 16r00000830 16r20000820 16r20000830 		16r00010820 16r00010830 16r20010820 16r20010830 		16r00080000 16r00080010 16r20080000 16r20080010 		16r00090000 16r00090010 16r20090000 16r20090010 		16r00080800 16r00080810 16r20080800 16r20080810 		16r00090800 16r00090810 16r20090800 16r20090810 		16r00080020 16r00080030 16r20080020 16r20080030 		16r00090020 16r00090030 16r20090020 16r20090030 		16r00080820 16r00080830 16r20080820 16r20080830 		16r00090820 16r00090830 16r20090820 16r20090830 		) #(		16r00000000 16r02000000 16r00002000 16r02002000 		16r00200000 16r02200000 16r00202000 16r02202000 		16r00000004 16r02000004 16r00002004 16r02002004 		16r00200004 16r02200004 16r00202004 16r02202004 		16r00000400 16r02000400 16r00002400 16r02002400 		16r00200400 16r02200400 16r00202400 16r02202400 		16r00000404 16r02000404 16r00002404 16r02002404 		16r00200404 16r02200404 16r00202404 16r02202404 		16r10000000 16r12000000 16r10002000 16r12002000 		16r10200000 16r12200000 16r10202000 16r12202000 		16r10000004 16r12000004 16r10002004 16r12002004 		16r10200004 16r12200004 16r10202004 16r12202004 		16r10000400 16r12000400 16r10002400 16r12002400 		16r10200400 16r12200400 16r10202400 16r12202400 		16r10000404 16r12000404 16r10002404 16r12002404 		16r10200404 16r12200404 16r10202404 16r12202404 		) #(		16r00000000 16r00000001 16r00040000 16r00040001 		16r01000000 16r01000001 16r01040000 16r01040001 		16r00000002 16r00000003 16r00040002 16r00040003 		16r01000002 16r01000003 16r01040002 16r01040003 		16r00000200 16r00000201 16r00040200 16r00040201 		16r01000200 16r01000201 16r01040200 16r01040201 		16r00000202 16r00000203 16r00040202 16r00040203 		16r01000202 16r01000203 16r01040202 16r01040203 		16r08000000 16r08000001 16r08040000 16r08040001 		16r09000000 16r09000001 16r09040000 16r09040001 		16r08000002 16r08000003 16r08040002 16r08040003 		16r09000002 16r09000003 16r09040002 16r09040003 		16r08000200 16r08000201 16r08040200 16r08040201 		16r09000200 16r09000201 16r09040200 16r09040201 		16r08000202 16r08000203 16r08040202 16r08040203 		16r09000202 16r09000203 16r09040202 16r09040203 		) #(		16r00000000 16r00100000 16r00000100 16r00100100 		16r00000008 16r00100008 16r00000108 16r00100108 		16r00001000 16r00101000 16r00001100 16r00101100 		16r00001008 16r00101008 16r00001108 16r00101108 		16r04000000 16r04100000 16r04000100 16r04100100 		16r04000008 16r04100008 16r04000108 16r04100108 		16r04001000 16r04101000 16r04001100 16r04101100 		16r04001008 16r04101008 16r04001108 16r04101108 		16r00020000 16r00120000 16r00020100 16r00120100 		16r00020008 16r00120008 16r00020108 16r00120108 		16r00021000 16r00121000 16r00021100 16r00121100 		16r00021008 16r00121008 16r00021108 16r00121108 		16r04020000 16r04120000 16r04020100 16r04120100 		16r04020008 16r04120008 16r04020108 16r04120108 		16r04021000 16r04121000 16r04021100 16r04121100 		16r04021008 16r04121008 16r04021108 16r04121108 		) #(		16r00000000 16r10000000 16r00010000 16r10010000 		16r00000004 16r10000004 16r00010004 16r10010004 		16r20000000 16r30000000 16r20010000 16r30010000 		16r20000004 16r30000004 16r20010004 16r30010004 		16r00100000 16r10100000 16r00110000 16r10110000 		16r00100004 16r10100004 16r00110004 16r10110004 		16r20100000 16r30100000 16r20110000 16r30110000 		16r20100004 16r30100004 16r20110004 16r30110004 		16r00001000 16r10001000 16r00011000 16r10011000 		16r00001004 16r10001004 16r00011004 16r10011004 		16r20001000 16r30001000 16r20011000 16r30011000 		16r20001004 16r30001004 16r20011004 16r30011004 		16r00101000 16r10101000 16r00111000 16r10111000 		16r00101004 16r10101004 16r00111004 16r10111004 		16r20101000 16r30101000 16r20111000 16r30111000 		16r20101004 16r30101004 16r20111004 16r30111004 		) #(		16r00000000 16r08000000 16r00000008 16r08000008 		16r00000400 16r08000400 16r00000408 16r08000408 		16r00020000 16r08020000 16r00020008 16r08020008 		16r00020400 16r08020400 16r00020408 16r08020408 		16r00000001 16r08000001 16r00000009 16r08000009 		16r00000401 16r08000401 16r00000409 16r08000409 		16r00020001 16r08020001 16r00020009 16r08020009 		16r00020401 16r08020401 16r00020409 16r08020409 		16r02000000 16r0A000000 16r02000008 16r0A000008 		16r02000400 16r0A000400 16r02000408 16r0A000408 		16r02020000 16r0A020000 16r02020008 16r0A020008 		16r02020400 16r0A020400 16r02020408 16r0A020408 		16r02000001 16r0A000001 16r02000009 16r0A000009 		16r02000401 16r0A000401 16r02000409 16r0A000409 		16r02020001 16r0A020001 16r02020009 16r0A020009 		16r02020401 16r0A020401 16r02020409 16r0A020409 		) #(		16r00000000 16r00000100 16r00080000 16r00080100 		16r01000000 16r01000100 16r01080000 16r01080100 		16r00000010 16r00000110 16r00080010 16r00080110 		16r01000010 16r01000110 16r01080010 16r01080110 		16r00200000 16r00200100 16r00280000 16r00280100 		16r01200000 16r01200100 16r01280000 16r01280100 		16r00200010 16r00200110 16r00280010 16r00280110 		16r01200010 16r01200110 16r01280010 16r01280110 		16r00000200 16r00000300 16r00080200 16r00080300 		16r01000200 16r01000300 16r01080200 16r01080300 		16r00000210 16r00000310 16r00080210 16r00080310 		16r01000210 16r01000310 16r01080210 16r01080310 		16r00200200 16r00200300 16r00280200 16r00280300 		16r01200200 16r01200300 16r01280200 16r01280300 		16r00200210 16r00200310 16r00280210 16r00280310 		16r01200210 16r01200310 16r01280210 16r01280310 		) #(		16r00000000 16r04000000 16r00040000 16r04040000 		16r00000002 16r04000002 16r00040002 16r04040002 		16r00002000 16r04002000 16r00042000 16r04042000 		16r00002002 16r04002002 16r00042002 16r04042002 		16r00000020 16r04000020 16r00040020 16r04040020 		16r00000022 16r04000022 16r00040022 16r04040022 		16r00002020 16r04002020 16r00042020 16r04042020 		16r00002022 16r04002022 16r00042022 16r04042022 		16r00000800 16r04000800 16r00040800 16r04040800 		16r00000802 16r04000802 16r00040802 16r04040802 		16r00002800 16r04002800 16r00042800 16r04042800 		16r00002802 16r04002802 16r00042802 16r04042802 		16r00000820 16r04000820 16r00040820 16r04040820 		16r00000822 16r04000822 16r00040822 16r04040822 		16r00002820 16r04002820 16r00042820 16r04042820 		16r00002822 16r04002822 16r00042822 16r04042822 ))</body><body package="DES" selector="initializeSPRegisterTransformation">initializeSPRegisterTransformationSPRegisterTransformation := Array new: 8.SPtransformation doWithIndex:[:each :index | |array| array := Array new: 64.	each doWithIndex:[:eachValue :ind | array at: ind put: (ThirtyTwoBitRegister basicNew load: eachValue)].	SPRegisterTransformation at: index put: array.].</body><body package="DES" selector="initializeSPtransformation">initializeSPtransformationSPtransformation := #(	#(		16r00820200  16r00020000  16r80800000  16r80820200 		16r00800000  16r80020200  16r80020000  16r80800000 		16r80020200  16r00820200  16r00820000  16r80000200 		16r80800200  16r00800000  16r00000000  16r80020000 		16r00020000  16r80000000  16r00800200  16r00020200 		16r80820200  16r00820000  16r80000200  16r00800200 		16r80000000  16r00000200  16r00020200  16r80820000 		16r00000200  16r80800200  16r80820000  16r00000000 		16r00000000  16r80820200  16r00800200  16r80020000 		16r00820200  16r00020000  16r80000200  16r00800200 		16r80820000  16r00000200  16r00020200  16r80800000 		16r80020200  16r80000000  16r80800000  16r00820000 		16r80820200  16r00020200  16r00820000  16r80800200 		16r00800000  16r80000200  16r80020000  16r00000000 		16r00020000  16r00800000  16r80800200  16r00820200 		16r80000000  16r80820000  16r00000200  16r80020200 		) #(		16r10042004  16r00000000  16r00042000  16r10040000 		16r10000004  16r00002004  16r10002000  16r00042000 		16r00002000  16r10040004  16r00000004  16r10002000 		16r00040004  16r10042000  16r10040000  16r00000004 		16r00040000  16r10002004  16r10040004  16r00002000 		16r00042004  16r10000000  16r00000000  16r00040004 		16r10002004  16r00042004  16r10042000  16r10000004 		16r10000000  16r00040000  16r00002004  16r10042004 		16r00040004  16r10042000  16r10002000  16r00042004 		16r10042004  16r00040004  16r10000004  16r00000000 		16r10000000  16r00002004  16r00040000  16r10040004 		16r00002000  16r10000000  16r00042004  16r10002004 		16r10042000  16r00002000  16r00000000  16r10000004 		16r00000004  16r10042004  16r00042000  16r10040000 		16r10040004  16r00040000  16r00002004  16r10002000 		16r10002004  16r00000004  16r10040000  16r00042000 		) #(		16r41000000  16r01010040  16r00000040  16r41000040 		16r40010000  16r01000000  16r41000040  16r00010040 		16r01000040  16r00010000  16r01010000  16r40000000 		16r41010040  16r40000040  16r40000000  16r41010000 		16r00000000  16r40010000  16r01010040  16r00000040 		16r40000040  16r41010040  16r00010000  16r41000000 		16r41010000  16r01000040  16r40010040  16r01010000 		16r00010040  16r00000000  16r01000000  16r40010040 		16r01010040  16r00000040  16r40000000  16r00010000 		16r40000040  16r40010000  16r01010000  16r41000040 		16r00000000  16r01010040  16r00010040  16r41010000 		16r40010000  16r01000000  16r41010040  16r40000000 		16r40010040  16r41000000  16r01000000  16r41010040 		16r00010000  16r01000040  16r41000040  16r00010040 		16r01000040  16r00000000  16r41010000  16r40000040 		16r41000000  16r40010040  16r00000040  16r01010000 		) #(		16r00100402  16r04000400  16r00000002  16r04100402 		16r00000000  16r04100000  16r04000402  16r00100002 		16r04100400  16r04000002  16r04000000  16r00000402 		16r04000002  16r00100402  16r00100000  16r04000000 		16r04100002  16r00100400  16r00000400  16r00000002 		16r00100400  16r04000402  16r04100000  16r00000400 		16r00000402  16r00000000  16r00100002  16r04100400 		16r04000400  16r04100002  16r04100402  16r00100000 		16r04100002  16r00000402  16r00100000  16r04000002 		16r00100400  16r04000400  16r00000002  16r04100000 		16r04000402  16r00000000  16r00000400  16r00100002 		16r00000000  16r04100002  16r04100400  16r00000400 		16r04000000  16r04100402  16r00100402  16r00100000 		16r04100402  16r00000002  16r04000400  16r00100402 		16r00100002  16r00100400  16r04100000  16r04000402 		16r00000402  16r04000000  16r04000002  16r04100400 		) #(		16r02000000  16r00004000  16r00000100  16r02004108 		16r02004008  16r02000100  16r00004108  16r02004000 		16r00004000  16r00000008  16r02000008  16r00004100 		16r02000108  16r02004008  16r02004100  16r00000000 		16r00004100  16r02000000  16r00004008  16r00000108 		16r02000100  16r00004108  16r00000000  16r02000008 		16r00000008  16r02000108  16r02004108  16r00004008 		16r02004000  16r00000100  16r00000108  16r02004100 		16r02004100  16r02000108  16r00004008  16r02004000 		16r00004000  16r00000008  16r02000008  16r02000100 		16r02000000  16r00004100  16r02004108  16r00000000 		16r00004108  16r02000000  16r00000100  16r00004008 		16r02000108  16r00000100  16r00000000  16r02004108 		16r02004008  16r02004100  16r00000108  16r00004000 		16r00004100  16r02004008  16r02000100  16r00000108 		16r00000008  16r00004108  16r02004000  16r02000008 		) #(		16r20000010  16r00080010  16r00000000  16r20080800 		16r00080010  16r00000800  16r20000810  16r00080000 		16r00000810  16r20080810  16r00080800  16r20000000 		16r20000800  16r20000010  16r20080000  16r00080810 		16r00080000  16r20000810  16r20080010  16r00000000 		16r00000800  16r00000010  16r20080800  16r20080010 		16r20080810  16r20080000  16r20000000  16r00000810 		16r00000010  16r00080800  16r00080810  16r20000800 		16r00000810  16r20000000  16r20000800  16r00080810 		16r20080800  16r00080010  16r00000000  16r20000800 		16r20000000  16r00000800  16r20080010  16r00080000 		16r00080010  16r20080810  16r00080800  16r00000010 		16r20080810  16r00080800  16r00080000  16r20000810 		16r20000010  16r20080000  16r00080810  16r00000000 		16r00000800  16r20000010  16r20000810  16r20080800 		16r20080000  16r00000810  16r00000010  16r20080010 		) #(		16r00001000  16r00000080  16r00400080  16r00400001 		16r00401081  16r00001001  16r00001080  16r00000000 		16r00400000  16r00400081  16r00000081  16r00401000 		16r00000001  16r00401080  16r00401000  16r00000081 		16r00400081  16r00001000  16r00001001  16r00401081 		16r00000000  16r00400080  16r00400001  16r00001080 		16r00401001  16r00001081  16r00401080  16r00000001 		16r00001081  16r00401001  16r00000080  16r00400000 		16r00001081  16r00401000  16r00401001  16r00000081 		16r00001000  16r00000080  16r00400000  16r00401001 		16r00400081  16r00001081  16r00001080  16r00000000 		16r00000080  16r00400001  16r00000001  16r00400080 		16r00000000  16r00400081  16r00400080  16r00001080 		16r00000081  16r00001000  16r00401081  16r00400000 		16r00401080  16r00000001  16r00001001  16r00401081 		16r00400001  16r00401080  16r00401000  16r00001001 		) #(		16r08200020  16r08208000  16r00008020  16r00000000 		16r08008000  16r00200020  16r08200000  16r08208020 		16r00000020  16r08000000  16r00208000  16r00008020 		16r00208020  16r08008020  16r08000020  16r08200000 		16r00008000  16r00208020  16r00200020  16r08008000 		16r08208020  16r08000020  16r00000000  16r00208000 		16r08000000  16r00200000  16r08008020  16r08200020 		16r00200000  16r00008000  16r08208000  16r00000020 		16r00200000  16r00008000  16r08000020  16r08208020 		16r00008020  16r08000000  16r00000000  16r00208000 		16r08200020  16r08008020  16r08008000  16r00200020 		16r08208000  16r00000020  16r00200020  16r08008000 		16r08208020  16r00200000  16r08200000  16r08000020 		16r00208000  16r00008020  16r08008020  16r08200000 		16r00000020  16r08208000  16r00208020  16r00000000 		16r08000000  16r08200020  16r00008000  16r00208020 	))</body><body package="DES" selector="initializeWeakKeysArray">initializeWeakKeysArray"Some initial keys are weak keys. The initial key is modified to get a sub-key for each round of DES. This is done by splitting the initial value in half and independently shifting each half. If all the bits in each half are either 0 or 1, then the key used for any cycle of the algorithm is the same as all other cycles. The four weak keys in DES are shown below" 	WeakKeys := #(16r00000000000000 16r0000000FFFFFFF 16rFFFFFFF0000000 16rFFFFFFFFFFFFFF)</body><body package="DES" selector="intializeAlternateShiftSequence">intializeAlternateShiftSequence	AlternateShiftSequence := #(false false true true true true true true false true true true true true true false)</body></methods><methods><class-id>Security.DES class</class-id> <category>instance creation</category><body package="DES" selector="new">new	^super new initialize</body></methods><methods><class-id>Security.DES class</class-id> <category>private utilities</category><body package="DES" selector="get32bitsFrom:Index:">get32bitsFrom: inputArray Index: index	" need to reimplement this to kill the large int math"		"^((((inputArray at: index+3) bitAnd: 16rff)&lt;&lt;24) + (((inputArray at: index+2) bitAnd: 16rff) &lt;&lt; 16) + (((inputArray at: index+1) bitAnd: 16rff)&lt;&lt;8) + ((inputArray at: index) bitAnd: 16rff))"	| int intIndex |	int := LargePositiveInteger basicNew: 4.	intIndex := 0.	index to: index+ 3 do:[:ind | int basicAt: (intIndex := intIndex +1) put: (inputArray at: ind)].	^int</body><body package="DES" selector="oldget32bitsFrom:Index:">oldget32bitsFrom: inputArray Index: index	" need to reimplement this to kill the large int math"		^((((inputArray at: index+3) bitAnd: 16rff)&lt;&lt;24) + (((inputArray at: index+2) bitAnd: 16rff) &lt;&lt; 16) + (((inputArray at: index+1) bitAnd: 16rff)&lt;&lt;8) + ((inputArray at: index) bitAnd: 16rff))</body></methods><methods><class-id>Security.DES class</class-id> <category>key generation</category><body package="DES" selector="getNewKey">getNewKey"generate a new randomly picked DES key and make sure that it isn't one of the know weak keys if it is try again till you get one."	"self getNewKey"| key |	[key := self setKeyParity:  (Integer generateRandomBits: 64).	self isDESKeyWeak: key ] whileTrue:[Transcript show: '.' ].^key</body><body package="DES" selector="setKeyParity:">setKeyParity: aKey	"aKey is a LargePositiveInteger"	| keyArray |	keyArray := aKey asBigEndianByteArray.	keyArray doWithIndex: [:eachByte :index | 			keyArray				at: index				put: (OddParityCheck at: (eachByte bitAnd: 16rff) + 1)].	^keyArray asLargePositiveInteger</body></methods><methods><class-id>Security.DESCBC</class-id> <category>private encryption decryption</category><body package="DES" selector="decryptBlock:IVorPreviousBlock:">decryptBlock: aByteArray IVorPreviousBlock: IVorPreviousBlock 	"this method does the decryption and it assumes you have set the key schedule already 	aslo since I use this internally I reve the check to see if I have byte arrays"	| decryptBlock |	decryptBlock := self doEcbEncryptBlock: aByteArray encrypt: false.	1 to: 8 do:[:index | decryptBlock at: index put: ((decryptBlock at: index) bitXor: (IVorPreviousBlock at: index) )].	^decryptBlock</body><body package="DES" selector="encryptBlock:IVorPreviousBlock:">encryptBlock: aByteArray IVorPreviousBlock: IVorPreviousBlock 	"this method do the encryption and it assumes you have set the key schedule already 	aslo since I use this internally I reve the check to see if I have byte arrays"	1 to: 8 do: [:index | scratchBlock at: index put: ((aByteArray at: index)				bitXor: (IVorPreviousBlock at: index))].	^self doEcbEncryptBlock: scratchBlock encrypt: true</body></methods><methods><class-id>Security.DESCBC</class-id> <category>encryption decryption</category><body package="DES" selector="decrypt:with:">decrypt: aTextStream with: aKey "This assumes we have a stream that was encrypted in a manner that was done in the encypt:with:withIVPaddedToStream: the last 8 bytes are my IV an I have to not assume that I had a perfect size stream and so I have padding."" this is the cbc mode of decryption for a stream "| extra byteArray key iv |	key := aKey asBigEndianByteArray.	byteArray := aTextStream asByteArray  .	iv := byteArray		copyFrom: byteArray size - 7 		to: byteArray size. 	self ignoreParity ifFalse:[(self class checkKeyParity: key) ifFalse:[self class badKeySignal raise]].	self setKeySheduleFromKey: key.	0 to: byteArray size - 16 by: 8 do:[:ind | |decyptedSublock newIv| newIv :=  ( byteArray copyFrom: (ind + 1) to: ind + 8).decyptedSublock := self decryptBlock: (newIv) IVorPreviousBlock: iv.iv := newIv.											" to save time and space replace unencrytpedBytes with the encrypted ones"										byteArray replaceBytesFrom: (ind + 1) to:  ind + 8 with: decyptedSublock startingAt: 1]."now see from the last block if we had to pad"	extra := byteArray at: (byteArray size - 8). ((extra &lt; 0) or:[extra &gt; 8 ]) ifTrue:[ self class decryptionFailedSignal raise].	self reset.^byteArray copyFrom: 1 to: (aTextStream size - 16 - extra)</body><body package="DES" selector="decrypt:with:iv:">decrypt: aTextStream with: aKey  iv: anIntializationVector"This is the mode that encrypts the stream of any size and in addtion to doing the standrad padding th IV is stuck on to the end.This is useful for dumping tha data to a file and you want to decrypt it with out knowing the IV but only the key"" this is the cbc mode of decryption for a stream "	| extra byteArray key iv |	key := aKey asBigEndianByteArray.	byteArray := aTextStream asByteArray  .	iv := anIntializationVector.	self ignoreParity ifFalse: [		(self class checkKeyParity: key) ifFalse:[			self class badKeySignal raise]].	self setKeySheduleFromKey: key.	1 to: byteArray size - 7 by: 8 do: [ :ind || decryptedSublock newIv |		newIv :=  byteArray copyFrom: ind to: ind + 7.		decryptedSublock := self decryptBlock: newIv with: aKey IVorPreviousBlock: iv.		iv := newIv.		"to save time and space replace unencrytpedBytes with the encrypted ones"		byteArray replaceBytesFrom: ind to: ind + 7 with: decryptedSublock startingAt: 1].	"now see from the last block if we had to pad"	extra := byteArray last + 1.	((extra &lt; 1) or: [extra &gt; 8]) ifTrue: [ self class decryptionFailedSignal raise].	self reset.	^byteArray copyFrom: 1 to: (byteArray size - extra)</body><body package="DES" selector="decrypt:with:withIVPaddedToStream:">decrypt: aTextStream with: aKey  withIVPaddedToStream: anIntializationVector" this is the mode that encrypts the stream of any size and in addtion to doing the standrad padding th IV is stuck on to the end. This is useful for dumping tha data to a file and you want to decrypt it with out knowing the IV but only the key"" this is the cbc mode of decryption for a stream and was encrypted with the encrypt:with:withIVPaddedToStream: "| extra byteArray key |	key := aKey asBigEndianByteArray.	byteArray := aTextStream asByteArray  .	self ignoreParity ifFalse:[(self class checkKeyParity: key) ifFalse:[self class badKeySignal raise]].	self setKeySheduleFromKey: key.	0 to: byteArray size - 8 by: 8 do:[:ind | |decyptedSublock|  decyptedSublock := self doEcbEncryptBlock: ( byteArray copyFrom: (ind + 1) to: ind + 8) encrypt: false.											" to save time and space replace unencrytpedBytes with the encrypted ones"										byteArray replaceBytesFrom: (ind + 1) to:  ind + 8 with: decyptedSublock startingAt: 1]."now see from the last block if we had to pad"	extra := byteArray last. ((extra &lt; 0) or:[extra &gt; 8 ]) ifTrue:[ self class decryptionFailedSignal raise].	self reset.^byteArray copyFrom: 1 to: (aTextStream size - 8 - extra)</body><body package="DES" selector="decryptBlock:with:IVorPreviousBlock:">decryptBlock: aByteArray with: aKey IVorPreviousBlock: IVorPreviousBlock	| key textBlock decryptBlock |	key := aKey asBigEndianByteArray.	textBlock := ByteArray new: 8.	self ignoreParity ifFalse:[(self class checkKeyParity: key) ifFalse:[self class badKeySignal raise]].	keySchedule isNil ifTrue:[ self setKeySheduleFromKey: key.].	decryptBlock := self doEcbEncryptBlock: aByteArray encrypt: false.	1 to: 8 do:[:index | textBlock at: index put: ((decryptBlock at: index) bitXor: (IVorPreviousBlock at: index) )].	^textBlock</body><body package="DES" selector="decryptPerfectSizeStream:with:iv:">decryptPerfectSizeStream: aByteArray with: aKey iv: anIntializationVector"This assumes we have a stream that was encrypted in a manner that was done in the encypt:with:iv: the las 8 bytes are my IV an I have to not assume that I had a perfect size stream and so I have padding."" this is the cbc mode of decryption for a stream "| byteArray key iv |	key := aKey asBigEndianByteArray.	byteArray := self encryptInPlace				ifTrue: ["since we have a perfect block we have the option of encrpting / decrypting in place to 					speed things up. 					this means the ByteArray passed in will then be the decrypted text"					aByteArray].	iv := anIntializationVector. 	self ignoreParity ifFalse:[(self class checkKeyParity: key) ifFalse:[self class badKeySignal raise]].	self setKeySheduleFromKey: key.	0 to: byteArray size - 8 by: 8 do:[:ind | |decyptedSublock newIv| newIv :=  ( byteArray copyFrom: (ind + 1) to: ind + 8).decyptedSublock := self decryptBlock: (newIv) IVorPreviousBlock: iv.iv := newIv.											" to save time and space replace unencrytpedBytes with the encrypted ones"										byteArray replaceBytesFrom: (ind + 1) to:  ind + 8 with: decyptedSublock startingAt: 1].	self reset.^byteArray</body><body package="DES" selector="encrypt:with:">encrypt: aTextStream with: aKey 	"do the encryption of the stream and pick a random IV and ust the appending version of the 	encryption"	^self		encrypt: aTextStream		with: aKey		withIVPaddedToStream: self class getNewKey</body><body package="DES" selector="encrypt:with:iv:">encrypt: aTextStream with: aKey iv: anIntializationVector 	"one of the things we have to look at is the issue of when we don't have and even 64 bits. I am going 	to to it the way I think it is done with netscape where they 	pad with random bytes int the last block to make it even, the last byte indicates the extra bytes we 	had. we put that in the last byte. If the was no extra the we are padded 8 bytes already fill unused 	bytes with.random numbers for the pad bytes can just be a simple random number (Random new 	next * 256) floor. we just don't want the text to have the chance of some how looknig the same, but 	it doesn have to be the CrpRandom that is nessary for other things like DSS and RSA key 	generation etc .we also need to append IV ont to the end of the stream"	"this is the ecb mode of encryption for a stream"	| extra byteArray endOfRealArray key iv random |	key := aKey asBigEndianByteArray.	iv := anIntializationVector asByteArray.	endOfRealArray := aTextStream size.	extra := 8 - (endOfRealArray \\ 8).	"add extra + the last block that we use to figure out the pad"	byteArray := aTextStream asByteArray growTo: endOfRealArray + extra.	"this results in generating a copy. "	random := Random new.	endOfRealArray + 1 to: byteArray size - 1 do: [:ind |		byteArray at: ind put: (random next * 256) floor].	byteArray at: byteArray size  put: extra - 1.	self ignoreParity ifFalse: [		(self class checkKeyParity: key)			ifFalse: [self class badKeySignal raise]].	self setKeySheduleFromKey: key.	1 to: byteArray size - 7 by: 8 do: [:ind | 			iv := self encryptBlock: (byteArray copyFrom: ind to: ind + 7) IVorPreviousBlock: iv.			"to save time and space replace unencrytpedBytes with the encrypted ones"					byteArray				replaceBytesFrom: ind				to: ind + 7				with: iv				startingAt: 1].	self reset.	^byteArray</body><body package="DES" selector="encrypt:with:withIVPaddedToStream:">encrypt: aTextStream with: aKey withIVPaddedToStream: anIntializationVector"one of the things we have to look at is the issue of when we don't have and even 64 bits. I am going 	to to it the way I think it is done with netscape where they 	pad with random bytes int the last block to make it even, the last byte indicates the extra bytes we 	had. we put that in the last byte. If the was no extra the we are padded 8 bytes already fill unused 	bytes with.random numbers for the pad bytes can just be a simple random number (Random new 	next * 256) floor. we just don't want the text to have the chance of some how looknig the same, but 	it doesn have to be the CrpRandom that is nessary for other things like DSS and RSA key 	generation etc .we also need to append IV ont to the end of the stream"	"this is the ecb mode of encryption for a stream"	| extra byteArray endOfRealArray start key iv |	key := aKey asBigEndianByteArray.	iv := anIntializationVector asBigEndianByteArray.	endOfRealArray := aTextStream size.	extra := endOfRealArray \\ 8.	"add extra + the last block that we use to figure out the pad"	byteArray := aTextStream asByteArray growTo: aTextStream size + (8 - extra) + 8.	"this results in generating a copy. and make sure there is room for the IV"	start := endOfRealArray + 1.	start to: byteArray size - 9 do: [:ind | byteArray at: ind put: ((Random new next * 256) floor bitAnd: 255)].	byteArray at: byteArray size - 8 put: extra.	1 to: 8 do:[:ind | byteArray at: (byteArray size - 8 + ind) put: (iv at: ind)].	self ignoreParity ifFalse: ["put the IV at the end"		(self class checkKeyParity: key)			ifFalse: [self class badKeySignal raise]].	self setKeySheduleFromKey: key.	0		to: byteArray size - 16		by: 8		do: 			[:ind | 			| encyptedSublock |			iv := encyptedSublock := self encryptBlock: (byteArray copyFrom: ind + 1 to: ind + 8)								IVorPreviousBlock: iv.	"to save time and space replace unencrytpedBytes with the encrypted ones"			byteArray				replaceBytesFrom: ind + 1				to: ind + 8				with: encyptedSublock				startingAt: 1].	self reset.	^byteArray</body><body package="DES" selector="encryptBlock:with:IVorPreviousBlock:">encryptBlock: aByteArray with: aKey IVorPreviousBlock: IVorPreviousBlock	| key textBlock previous |	key := aKey asBigEndianByteArray.	textBlock := ByteArray new: 8.	previous := IVorPreviousBlock asBigEndianByteArray.	1 to: 8 do:[:index | textBlock at: index put: ((aByteArray at: index) bitXor: (previous at: index) )].	self ignoreParity ifFalse:[(self class checkKeyParity: key) ifFalse:[self class badKeySignal raise]].	keySchedule isNil ifTrue:[ self setKeySheduleFromKey: key.].	^self doEcbEncryptBlock: textBlock encrypt: true</body><body package="DES" selector="encryptPerfectSizeStream:with:iv:">encryptPerfectSizeStream: aByteArray with: aKey iv: anIntializationVector 	"This will encrypte a Byte Array that is a multiple of 8 add no padding and not append the IV at the end. so you must use the decryptPerfectSizeStream: aTextStream with: aKey iv: anIntializationVector "	"this is the cbc mode of encryption for a stream"	| byteArray key iv  |	aByteArray size \\ 8 = 0 ifFalse: [self class arrayLengthErrorSignal raise].	key := aKey asBigEndianByteArray.	iv := anIntializationVector asBigEndianByteArray. 	byteArray := self encryptInPlace				ifTrue: ["since we have a perfect block we have the option of encrypting / decrypting in place to 					speed things up. 					this means the ByteArray passed in will then be the decrypted text"					aByteArray].	self ignoreParity ifFalse: ["put the IV at the end"		(self class checkKeyParity: key)			ifFalse: [self class badKeySignal raise]].	self setKeySheduleFromKey: key.	0		to: byteArray size - 8		by: 8		do: 			[:ind | 			| encyptedSublock |			iv := encyptedSublock := self encryptBlock: (byteArray copyFrom: ind + 1 to: ind + 8)								IVorPreviousBlock: iv.	"to save time and space replace unencrytpedBytes with the encrypted ones"			byteArray				replaceBytesFrom: ind + 1				to: ind + 8				with: encyptedSublock				startingAt: 1].	self reset.	^byteArray</body></methods><methods><class-id>Security.DESCBC</class-id> <category>initialize</category><body package="DES" selector="initialize">initialize	super initialize.	scratchBlock := ByteArray new: 8.</body></methods><methods><class-id>Security.DESCBC class</class-id> <category>intialize</category><body package="DES" selector="initialize">initialize	"self initialize"	registerClass := ThirtyTwoBitRegister.	desHelperClass := DESHelper.	arrayClass := Array.	byteArrayClass := ByteArray.	largePositiveIntegerClass := LargePositiveInteger.	spRegisterTransformation := SPRegisterTransformation.	skbTransformation := SKBTransformation.	skbRegisterTransformation := SKBRegisterTransformation.	alternateShiftSequence := AlternateShiftSequence</body></methods><methods><class-id>Security.DESSPHelper</class-id> <category>accessing</category><body package="DES" selector="getRasLargeInt">getRasLargeInt	| int |	int := LargePositiveInteger basicNew: 4.	int basicAt: 3 put: (rH bitAnd: 16rff).	int basicAt:4 put: ((rH bitShift: 0 - 8) bitAnd: 16rff).	int basicAt: 1 put: (rL bitAnd: 16rff).	int basicAt:2 put: ((rL bitShift: 0 - 8) bitAnd: 16rff).	^int</body><body package="DES" selector="r:">r: aLargeIntR       rH := aLargeIntR bitShift: -16.       rL := aLargeIntR bitAnd: 16rFFFF.</body></methods><methods><class-id>Security.DESSPHelper</class-id> <category>api</category><body package="DES" selector="rightShift:maskL:">rightShift: shift maskL: maskL	^shift &gt; 15 ifTrue:[rH bitAnd: maskL.] ifFalse:[((rH bitShift: 16 -shift ) + (rL bitShift: 0-shift))  bitAnd: maskL. ]</body></methods><methods><class-id>Core.ByteArray</class-id> <category>security</category><body package="DES" selector="growTo:">growTo: newSize	"Grow to the requested size."	| newArray |	newArray := self class new: (newSize).	newArray replaceBytesFrom: 1 to: self size with: self startingAt: 1.	^newArray</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>enumerating</category><body package="DES" selector="doWithIndex:">doWithIndex: aBlock  	"Evaluate aBlock with each of the receiver's elements as the argument and then theIndex as the second."	1 to: self size do: [:i | aBlock value: (self at: i) value: i]</body></methods><methods><class-id>Security.ThirtyTwoBitRegister</class-id> <category>operations</category><body package="DES" selector="functionLR">functionLR	| high1 low1 |" don't do any of the special left shift 12s becuasre they can't result in a large int and so this is faster"	high1 := (low bitShift:12) bitAnd: 16rffff.	low1 := 0.	low := (hi bitShift:12) + (low bitShift: -4).	hi := hi bitShift: -4.	hi := hi bitOr: high1.	low := low bitOr: low1</body><body package="DES" selector="leftShift1">leftShift1	| tl |	tl := low bitShift: -15.	low := (low bitShift: 1)				bitAnd: 65535.	hi := ((hi bitShift: 1)				bitAnd: 65535)				+ tl</body><body package="DES" selector="leftShift16">leftShift16	hi := low.	low := 0</body><body package="DES" selector="leftShift18">leftShift18	hi := (low bitShift: 2)				bitAnd: 65535.	low := 0</body><body package="DES" selector="leftShift26">leftShift26	hi := (low bitShift: 10)				bitAnd: 65535.	low := 0</body><body package="DES" selector="leftShift27">leftShift27	hi := (low bitShift: 11)				bitAnd: 65535.	low := 0</body><body package="DES" selector="leftShift4">leftShift4	| tl |	tl := low bitShift: -12.	low := (low bitShift: 4)				bitAnd: 65535.	hi := ((hi bitShift: 4)				bitAnd: 65535)				+ tl</body><body package="DES" selector="leftShift8">leftShift8	| tl |	tl := low bitShift: -8.	low := (low bitShift: 8)				bitAnd: 65535.	hi := ((hi bitShift: 8)				bitAnd: 65535)				+ tl</body></methods><methods><class-id>Security.ThirtyTwoBitRegister</class-id> <category>accessing</category><body package="DES" selector="loadBottom32:">loadBottom32: anArray       hi := ((anArray at: 8) bitShift: 8) + (anArray at: 7).       low := ((anArray at: 6) bitShift: 8) + (anArray at: 5).</body><body package="DES" selector="loadLarge:">loadLarge: anInteger	"Set my contents to the value of given integer.this asumes a large int of four bytes this is done for speed for encryption"	low := ((anInteger basicAt: 2) bitShift: 8) + (anInteger basicAt: 1).	hi := ((anInteger basicAt: 4) bitShift: 8) + (anInteger basicAt: 3)</body><body package="DES" selector="loadTop32:">loadTop32: anArray       hi := ((anArray at: 4) bitShift: 8) + (anArray at: 3).       low := ((anArray at: 2) bitShift: 8) + (anArray at: 1).</body></methods><methods><class-id>Security.ThirtyTwoBitRegister</class-id> <category>operations</category><body package="DES" selector="maskH16r0maskL:">maskH16r0maskL: maskL	hi := 0.	low := low bitAnd: maskL.</body><body package="DES" selector="maskH:">maskH: maskH	hi := hi bitAnd: maskH.</body><body package="DES" selector="maskH:maskL:">maskH: maskH maskL: maskL	hi := hi bitAnd: maskH.	low := low bitAnd: maskL.</body><body package="DES" selector="maskL16r0maskH:">maskL16r0maskH: maskH 	hi := hi bitAnd: maskH.	low := 0.</body><body package="DES" selector="rightShift1">rightShift1low := (hi specialLeftShift15 ) + (low bitShift: -1).hi :=(hi bitShift: -1).</body><body package="DES" selector="rightShift13maskL16r0f">rightShift13maskL16r0f			^((hi bitShift: 3) + (low bitShift: -13)) bitAnd: 16r0f</body><body package="DES" selector="rightShift14maskL16r30">rightShift14maskL16r30 	^(hi bitShift: 2)+ (low bitShift: -14) bitAnd: 16r30</body><body package="DES" selector="rightShift15maskL16r3f">rightShift15maskL16r3f	^(hi bitShift: 1)		+ (low bitShift: -15) bitAnd: 16r3f</body><body package="DES" selector="rightShift16">rightShift16	low := hi.	hi := 0</body><body package="DES" selector="rightShift16maskL16r3f">rightShift16maskL16r3f^hi  bitAnd: 16r3f</body><body package="DES" selector="rightShift16maskL:">rightShift16maskL: maskL 	^hi bitAnd: maskL</body><body package="DES" selector="rightShift18">rightShift18low := (hi bitShift: -2 ).hi := 0.</body><body package="DES" selector="rightShift2">rightShift2low := ((hi bitShift: 14 ) bitAnd: 16rffff)+ (low bitShift: -2).hi :=(hi bitShift: -2).</body><body package="DES" selector="rightShift20maskL16r01">rightShift20maskL16r01	^(hi bitShift: -4) bitAnd: 16r01</body><body package="DES" selector="rightShift21maskL16r06">rightShift21maskL16r06 	^(hi bitShift: -5) bitAnd: 16r06</body><body package="DES" selector="rightShift21maskL16r0f">rightShift21maskL16r0f	^(hi bitShift: -5) bitAnd: 16r0f</body><body package="DES" selector="rightShift22maskL16r30">rightShift22maskL16r30	^(hi bitShift: -6) bitAnd: 16r30</body><body package="DES" selector="rightShift22maskL16r38">rightShift22maskL16r38	^(hi bitShift: -6) bitAnd: 16r38</body><body package="DES" selector="rightShift24maskL16r3f">rightShift24maskL16r3f	^(hi bitShift: -8)		bitAnd: 63</body><body package="DES" selector="rightShift24maskL:">rightShift24maskL: maskL^(hi bitShift:  -8 )  bitAnd: maskL.</body><body package="DES" selector="rightShift28">rightShift28low := (hi bitShift: -12 ).hi :=0.</body><body package="DES" selector="rightShift4">rightShift4low :=((hi bitShift: 12) bitAnd: 16rffff) +  (low bitShift: -4) .hi :=(hi bitShift: -4).</body><body package="DES" selector="rightShift6maskL16r03">rightShift6maskL16r03 			^(low bitShift: -6) bitAnd: 16r03</body><body package="DES" selector="rightShift7maskL16r03">rightShift7maskL16r03	^(low bitShift: -7) bitAnd: 16r03</body><body package="DES" selector="rightShift7maskL16r3c">rightShift7maskL16r3c	^(low bitShift: -7) bitAnd: 16r3c</body><body package="DES" selector="rightShift8">rightShift8low := (hi bitShift: 8 ) + (low bitShift: -8).hi :=(hi bitShift: -8).</body><body package="DES" selector="rightShift8maskL16r3c">rightShift8maskL16r3c	^(low bitShift: -8) bitAnd: 16r3c</body><body package="DES" selector="rightShift8maskL16r3f">rightShift8maskL16r3f	^(low bitShift: -8) bitAnd: 16r3f</body><body package="DES" selector="rightShift8maskL:">rightShift8maskL: maskL 	^(hi bitShift: 8)		+ (low bitShift: -8) bitAnd: maskL</body><body package="DES" selector="rightShift:maskL:">rightShift: shift maskL: maskL 	^shift &gt;= 16		ifTrue: [shift = 16				ifTrue: [hi bitAnd: maskL]				ifFalse: [(hi bitShift: 16 - shift)						bitAnd: maskL]]		ifFalse: 			[low := low bitAnd: 65535.			(hi bitShift: 16 - shift)				+ (low bitShift: 0 - shift) bitAnd: maskL]</body><body package="DES" selector="rightShiftby1bitORedWithLeftShifted31LoadHelperR:">rightShiftby1bitORedWithLeftShifted31LoadHelperR: aHelper  	"do the operation and return a largeInt as a result "	| low1 high1 low2 high2     |		high1 :=  ( low specialLeftShift15) .	low1 := 0.	low2 := ((hi specialLeftShift15)				+ (low bitShift: -1)).	high2 := hi bitShift: -1.	aHelper rH: (high1 bitOr: high2) rL: (low1 bitOr: low2)</body><body package="DES" selector="rightShiftby1bitORedWithLeftShifted31LoadHelperU:">rightShiftby1bitORedWithLeftShifted31LoadHelperU: aHelper  	"do the operation and return a largeInt as a result "	| low1 high1 low2 high2     |		high1 :=  ( low specialLeftShift15) .	low1 := 0.	low2 := ((hi specialLeftShift15)				+ (low bitShift: -1)).	high2 := hi bitShift: -1.	aHelper uH: (high1 bitOr: high2) uL: (low1 bitOr: low2)</body><body package="DES" selector="rightShiftby:bitORedWithLeftShifted:">rightShiftby: shift2 bitORedWithLeftShifted: shift1 	"do the operation and return a largeInt as a result"	| low1 high1 low2 high2 bitOrHigh bitOrLow int  tl |	low := low bitAnd: 16rffff.	shift1 &gt; 15 ifTrue:[ high1 :=  ( low bitShift: shift1 -16)  bitAnd: 16rffff.					low1 := 0]	ifFalse:[	tl :=  ( low bitShift: shift1- 16).	low1 := ( low bitShift: shift1)  bitAnd: 16rffff.	high1 :=((hi bitShift: shift1  ) bitAnd: 16rffff) + ((tl) ).].	low2 := ((hi bitShift: 16 - shift2)				+ (low bitShift: 0 - shift2)) bitAnd: 16rffff.	high2 := hi bitShift: 0 - shift2.	bitOrHigh := high1 bitOr: high2.	bitOrLow := low1 bitOr: low2.	int := LargePositiveInteger basicNew: 4.	int basicAt: 3 put: (bitOrHigh bitAnd: 255).	int basicAt: 4 put: ((bitOrHigh bitShift: 0 - 8)			bitAnd: 255).	int basicAt: 1 put: (bitOrLow bitAnd: 255).	int basicAt: 2 put: ((bitOrLow bitShift: 0 - 8)			bitAnd: 255).	^int</body></methods><methods><class-id>Core.SmallInteger</class-id> <category>security</category><body package="DES" selector="specialLeftShift1">specialLeftShift1	" yes this is the just like the bitShift: message but  I am saving some cyles since I know the number that I am shifting over.so if it can't be done with a small integer result d the shift left with the values that I know have to be in there. this saves a few sends and test which done over a millioniterations saves time especially with the block ciphers since we handle only 8 bytes at a time so to do a megabyte requires 128000 iterations the faster each of those iterations the more I can encrypt in each second so every cycle counts so since I am only in this case concerned with 16 bits only mask before the shift to guarantee that I will always result with a small int in the primative"^(self bitAnd: 16r7FFF) bitShift:1</body><body package="DES" selector="specialLeftShift12">specialLeftShift12	"Answer a SmallInteger whose value (in two's-complement	representation) is the receiver's value (in two's-complement	representation) shifted left by the number of bits indicated by the	argument.  Negative arguments shift right.  Zeros are shifted in from	the right in left shifts.  The sign bit is extended in right shifts.  Fail	if the result cannot be represented as a SmallInteger."" yes this is the just like the bitShift: message but  I am saving some cyles since I know the number that I am shifting over.so if it can't be done with a small integer result d the shift left with the values that I know have to be in there. this saves a few sends and test which done over a millioniterations saves time especially with the block ciphers since we handle only 8 bytes at a time so to do a megabyte requires 128000 iterations the faster each of those iterations the more I can encrypt in each second so every cycle counts""do what eliot suggested mask befor you shift"^(self bitAnd: 16rff) bitShift: 12</body><body package="DES" selector="specialLeftShift14">specialLeftShift14	"Answer a SmallInteger whose value (in two's-complement	representation) is the receiver's value (in two's-complement	representation) shifted left by the number of bits indicated by the	argument.  Negative arguments shift right.  Zeros are shifted in from	the right in left shifts.  The sign bit is extended in right shifts.  Fail	if the result cannot be represented as a SmallInteger."" yes this is the just like the bitShift: message but  I am saving some cyles since I know the number that I am shifting over.so if it can't be done with a small integer result d the shift left with the values that I know have to be in there. this saves a few sends and test which done over a millioniterations saves time especially with the block ciphers since we handle only 8 bytes at a time so to do a megabyte requires 128000 iterations the faster each of those iterations the more I can encrypt in each second so every cycle counts""do what eliot suggested mask befor you shift"^(self bitAnd: 16rff) bitShift: 14</body><body package="DES" selector="specialLeftShift15">specialLeftShift15	" yes this is the just like the bitShift: message but  I am saving some cyles since I know the number that I am shifting over.so if it can't be done with a small integer result d the shift left with the values that I know have to be in there. this saves a few sends and test which done over a millioniterations saves time especially with the block ciphers since we handle only 8 bytes at a time so to do a megabyte requires 128000 iterations the faster each of those iterations the more I can encrypt in each second so every cycle counts so since I am only in this case concerned with 16 bits only mask before the shift to guarantee that I will always result with a small int in the primative"^(self bitAnd: 1) bitShift: 15</body><body package="DES" selector="specialLeftShift2">specialLeftShift2	" yes this is the just like the bitShift: message but  I am saving some cyles since I know the number that I am shifting over.so if it can't be done with a small integer result d the shift left with the values that I know have to be in there. this saves a few sends and test which done over a millioniterations saves time especially with the block ciphers since we handle only 8 bytes at a time so to do a megabyte requires 128000 iterations the faster each of those iterations the more I can encrypt in each second so every cycle counts so since I am only in this case concerned with 16 bits only mask before the shift to guarantee that I will always result with a small int in the primative"^(self bitAnd: 16r3FFF) bitShift: 2</body><body package="DES" selector="specialLeftShift4">specialLeftShift4	" yes this is the just like the bitShift: message but  I am saving some cyles since I know the number that I am shifting over.so if it can't be done with a small integer result d the shift left with the values that I know have to be in there. this saves a few sends and test which done over a millioniterations saves time especially with the block ciphers since we handle only 8 bytes at a time so to do a megabyte requires 128000 iterations the faster each of those iterations the more I can encrypt in each second so every cycle counts so since I am only in this case concerned with 16 bits only mask before the shift to guarantee that I will always result with a small int in the primative"^(self bitAnd: 16rFFF) bitShift:4</body><body package="DES" selector="specialLeftShift8">specialLeftShift8	" yes this is the just like the bitShift: message but  I am saving some cyles since I know the number that I am shifting over.so if it can't be done with a small integer result d the shift left with the values that I know have to be in there. this saves a few sends and test which done over a millioniterations saves time especially with the block ciphers since we handle only 8 bytes at a time so to do a megabyte requires 128000 iterations the faster each of those iterations the more I can encrypt in each second so every cycle counts so since I am only in this case concerned with 16 bits only mask before the shift to guarantee that I will always result with a small int in the primative"^(self bitAnd: 16rFF) bitShift:8</body></methods><initialize><class-id>Security.DESHelper</class-id></initialize><initialize><class-id>Security.DES</class-id></initialize><initialize><class-id>Security.DESCBC</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ThirtyTwoBitRegister</name><environment>Security</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hi low </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Hashes</category><attributes><package>SecurityBase</package></attributes></class><class><name>BlockCipher</name><environment>Security</environment><super>Security.SymmetricCipher</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blockSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>CiphersBase</package></attributes></class><class><name>SmallInteger</name><environment>Core</environment><super>Core.Integer</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars>minVal maxVal maxBits maxBytes </class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class></st-source>