<?xml version="1.0"?><st-source><!-- Name: X509Notice: Copyright © 2005 Cincom Systems, Inc.  All Rights Reserved.Comment: An X509 V3 certificate as defined by the September 23, 1998 draft of the PKIX Working Group of the Internet Engineering Task Force (IETF)X509 is functional barely... The excelent X.509 Style Guide by Peter Gutmann (http://www.cs.auckland.ac.nz/~pgut001/pubs/x509guide.txt) provides the details as to why. If a certificate comes from a program other than the one genrating it, the signatures probably won't match since people interpret the encoding rules differently (see the article). We are making and effort to make this more complete. There are severe problems in different interpretations of the spec and indeed trying to verify a certificate that has been in any way recoded with anything other than the software that generated it, it probably will fail. In some cases with some CA's it fails because the signature in no way resembles what the algorithm puts out. Needless to say while we have minimal functionality working, there remains a lot of work to be done and the CAs are not exactly forth comming with informationWhat this parcel can presently do is:	- read RSA and DSA signed certificates and get the subject public key	- verify RSA-MD5, RSA-SHA1 and DSA signatures most of the time.	- validate certificate chains using a registry of trusted CA certificatesDbIdentifier: bear73DbTrace: 53787DevelopmentPrerequisites: #(#(#any 'NetClientBase' '') #(#any 'NetNamespace' '') #(#package 'RSA' '') #(#package 'DSA' '') #(#bundle 'ASN1' ''))PackageName: X509Parcel: #('X509')PrerequisiteParcels: #(#('NetClientBase' '') #('NetNamespace' '') #('RSA' '') #('DSA' '') #('ASN1' ''))PrintStringCache: (731 7,mkobetic)Version: 7.3.1Date: 9:22:06 am April 18, 2005 --><time-stamp>From VisualWorks®, 7.3.1 of April 10, 2005 on April 18, 2005 at 9:22:06 am</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>X509CertificateViewer</name><environment>Security</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509Registry</name><environment>Security</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>trustedCertificates strict </inst-vars><class-inst-vars>default </class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509Registry</class-id><body>this class hold on to a set of trustested certificates you can either use the default instance who gets it's trusted certificates from the trustedCertifcates.pem file in the directory you are running the image or you can set the trusted certificates file from the class side method to set the defaultTrustedCertificate file.if a default registry does not exist it tries to create on from the default file and uses that for validation of the chain. you can us the other instance creation methods to create and use registries from you own pem files of trusted certificates. one might want to do this if you have internal certificates you trust for certain connections and another set you trust for either external connections or other connections where you want the trust relationship to be differentInstance Variables:	trustedCertificates	&lt;Collection of: X509Certificate&gt;  collection of trusted root certificates	strict	&lt;Boolean&gt;	adhere strictly to the latest version of the specification (RFC 3280 at the moment)Shared Variables:	DefaultCertificateFile	&lt;String&gt;   the default trusted Certificate pem file	NotTrustedCertificates	&lt;type&gt;  to be fleshed out in a later release	RevokedCertificates	&lt;type&gt;  to be fleshed out in a later release	TrustedCertificates	&lt;Set of:X509Certificates&gt;  comment	UnVerifiedCertificates	&lt;type&gt;  to be fleshed out in a later releaseClass Instance Variables:	default	&lt;X509Registry&gt;  default instance of the registry</body></comment><class><name>X509Certificate</name><environment>Security</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encodedCertificate certificateSequence tbsSequence derCertificate tbsCertificate tbsDerCertificate signatureAlgorithm signature privateKey marshaller </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509Certificate</class-id><body>An X509 V3 certificate as defined by the September 23, 1998 draft of the PKIX Working Group of the Internet Engineering Task Force (IETF)To be implemented: need to read certificate and private key pairs. (privateKey done added inst var to hold it)need to verify the the signature with all the different signature algorithms ,oh joy.return an ordered collection of associations dith DN oid description and value.There are severe problems in different interpretations of the spec and indeed if I try and verify a certificae that has been in any way recoded with anythng other than the software that encoded it. it probably will fail. and in some cases with some CA's it fails because the signature in no way resembles what the algorithm puts out.Needless to say while we have minimal functionality working like extracting the key and some certificate chaining in ssl, there remains a lot of work to be done and the CA are not excactly forth comming with information. CRL lists are not implented yet Due mostly to the fact of the CRL encoding differences from CA to CA. These will be in a future release.  </body></comment><class><name>X509CRLSignatureVerification</name><environment>Security</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509TBSCertificateRevocationList</name><environment>Security</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tbsSequence version signature issuer thisUpdate nextUpdate revokedCertificates userCertificates revocationDate crlExtensions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509TBSCertificate</name><environment>Security</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tbsSequence version serialNumber signature issuer validity subject subjectPublicKeyInfo extensions totalBytes idSequence classContextSpecific issuerUniqueID subjectUniqueID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509TBSCertificate</class-id><body>A TBS (to be signed) certificate</body></comment><class><name>X509DSACRLSignatureVerification</name><environment>Security</environment><super>Security.X509CRLSignatureVerification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509CertificateStream</name><environment>ASN1</environment><super>ASN1.Asn1StreamDER</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>X509</package></attributes></class><class><name>X509RSACRLSignatureVerification</name><environment>Security</environment><super>Security.X509CRLSignatureVerification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509CertificateRevocationList</name><environment>Security</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tbsCertificateList signatureAlgorithm signature derCertificate certificateSequence tbsDerCertificate tbsSequence </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509CertificateSignatureVerification</name><environment>Security</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509DSASignatureVerification</name><environment>Security</environment><super>Security.X509CertificateSignatureVerification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509Exception</name><environment>Security</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509Error</name><environment>Security</environment><super>Security.X509Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509Warning</name><environment>Security</environment><super>Security.X509Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509ValidityError</name><environment>Security</environment><super>Security.X509Warning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509NotValidYet</name><environment>Security</environment><super>Security.X509ValidityError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509Unknown</name><environment>Security</environment><super>Security.X509Warning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509Unsupported</name><environment>Security</environment><super>Security.X509Warning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509BrokenChain</name><environment>Security</environment><super>Security.X509Warning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509RootNotTrusted</name><environment>Security</environment><super>Security.X509Warning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509BadCACertificate</name><environment>Security</environment><super>Security.X509Warning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509BadCAConstraints</name><environment>Security</environment><super>Security.X509BadCACertificate</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509Notification</name><environment>Security</environment><super>Security.X509Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509ExtensionShouldBeCritical</name><environment>Security</environment><super>Security.X509Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>extension </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509UnhandledCriticalExtension</name><environment>Security</environment><super>Security.X509Unsupported</super><private>false</private><indexed-type>none</indexed-type><inst-vars>extension </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509Revoked</name><environment>Security</environment><super>Security.X509Warning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509CARevoked</name><environment>Security</environment><super>Security.X509Revoked</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509BadCAKeyUsage</name><environment>Security</environment><super>Security.X509BadCACertificate</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509BadCertificate</name><environment>Security</environment><super>Security.X509Warning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509InvalidSignature</name><environment>Security</environment><super>Security.X509BadCertificate</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509CertificateFileReader</name><environment>Security</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>line column stream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509CertificateFileReader</class-id><body>This class is meant to parse a file filled with certificates and certificate and private key pairs and return a collection  x509certificates.</body></comment><class><name>X509Expired</name><environment>Security</environment><super>Security.X509ValidityError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509Object</name><environment>Security</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509AccessDescription</name><environment>Security</environment><super>Security.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessMethod accessLocation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509Validity</name><environment>Security</environment><super>Security.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>notBefore notAfter asnValidityType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509DigestInfo</name><environment>Security</environment><super>Security.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>digestAlgorithm digest sequence maskClass application </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509NoticeReference</name><environment>Security</environment><super>Security.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>organization noticeNumbers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509SubjectPublicKeyInfo</name><environment>Security</environment><super>Security.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>algorithm subjectPublicKey publicKey </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509DSSSignatureValue</name><environment>Security</environment><super>Security.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>r s sequence rawData marshaller </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509DisplayText</name><environment>Security</environment><super>Security.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509GeneralName</name><environment>Security</environment><super>Security.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>otherName rfc822Name dnsName x400Address directoryName ediPartyName uniformResourceIdentifier ipAddress registerID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509GeneralSubtree</name><environment>Security</environment><super>Security.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>base minimun maximum </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509Qualifier</name><environment>Security</environment><super>Security.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cpSuri userNotice </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509AttributeValueAssertion</name><environment>Security</environment><super>Security.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type value asnType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509UnknownPublicKey</name><environment>Security</environment><super>Security.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rawData marshaller resultObject </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509RSAPublicKey</name><environment>Security</environment><super>Security.X509UnknownPublicKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sequence e n </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509DSAPublicKey</name><environment>Security</environment><super>Security.X509UnknownPublicKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>publicKey dssParameters y sequence </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509ReasonFlags</name><environment>Security</environment><super>Security.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>unused keyCompromise caCompromise affiliationChanged superseded cessationOFOperation certificateHold </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509Name</name><environment>Security</environment><super>Security.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>relativeDistinguishedName rawData </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509DistinguishedName</name><environment>Security</environment><super>Security.X509Name</super><private>false</private><indexed-type>none</indexed-type><inst-vars>distinguishedName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509DSSParameters</name><environment>Security</environment><super>Security.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>p q g sequence </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509UnknownPrivateKey</name><environment>Security</environment><super>Security.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encodedString privateKeyByteArray encodedPrivateKey rawData marshaller </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509RSAPrivateKey</name><environment>Security</environment><super>Security.X509UnknownPrivateKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sequence d n e p q exponent1 exponent2 coefficient version primeRi exponentDi coefficientTi otherPrimInfos </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509PolicyQualifierInfo</name><environment>Security</environment><super>Security.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>policyQualifierID qualifier </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509PolicyInformation</name><environment>Security</environment><super>Security.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>policyIdentifier policyQualifiers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509DistributionName</name><environment>Security</environment><super>Security.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fullName nameRelativeToCRLIssuer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509DistributionPoints</name><environment>Security</environment><super>Security.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>distributionPoint reasons crlIssuer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509EDIPartyName</name><environment>Security</environment><super>Security.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nameAssigner partyName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509DSAPrivateKey</name><environment>Security</environment><super>Security.X509UnknownPrivateKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y p q g sequence version </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509DSAPrivateKey</class-id><body>Instance Variables:	x	&lt;LargeInteger&gt;	y	&lt;LargeInterger&gt;	p	&lt;LargeInteger&gt;	q	&lt;LargeInteger&gt;	g	&lt;LargeInteger&gt;	sequence	&lt;ASN1Value&gt;	version	&lt;ASN1Value&gt;</body></comment><class><name>X509RevokedCertificates</name><environment>Security</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>listSequence userCertificate revocationDate crlEntryExtensions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509AlgorithmIdentifier</name><environment>Security</environment><super>Security.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>algorithm oid oidDescription parameters totalBytes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509UserNotice</name><environment>Security</environment><super>Security.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>noticeRef explicitText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509RSASignatureVerification</name><environment>Security</environment><super>Security.X509CertificateSignatureVerification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509OtherName</name><environment>Security</environment><super>Security.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeId value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509Extension</name><environment>Security</environment><super>Security.X509Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>idDescription critical value marshaller oid </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509PolicyMappings</name><environment>Security</environment><super>Security.X509Extension</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mappings </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><comment><class-id>Security.X509PolicyMappings</class-id><body>This extension is used in CA certificates.  It lists one or more pairs of OIDs; each pair includes an issuerDomainPolicy and a subjectDomainPolicy.  The pairing indicates the issuing CA considers its issuerDomainPolicy equivalent to the subject CA's subjectDomainPolicy.The issuing CA's users might accept an issuerDomainPolicy for certain applications.  The policy mapping defines the list of policies associated with the subject CA that may be accepted as comparable to the issuerDomainPolicy.Each issuerDomainPolicy named in the policy mapping extension SHOULD also be asserted in a certificate policies extension in the same certificate.  Policies SHOULD NOT be mapped either to or from the special value anyPolicy (section 4.2.1.5).This extension MAY be supported by CAs and/or applications, and it MUST be non-critical.(from 4.2.1.6  Policy Mappings)Instance Variables:	mappings	&lt;OrderedCollection of: (Asn1OID -&gt; Asn1OID)&gt; issuer/subject policy mappings</body></comment><class><name>X509BasicConstraints</name><environment>Security</environment><super>Security.X509Extension</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ca pathLenConstraint </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509NameConstraints</name><environment>Security</environment><super>Security.X509Extension</super><private>false</private><indexed-type>none</indexed-type><inst-vars>permittedSubtrees excludedSubtrees </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509AuthorityInformationAccess</name><environment>Security</environment><super>Security.X509Extension</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessDescription </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509SubjectAltName</name><environment>Security</environment><super>Security.X509Extension</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subjectAlternativeNames </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509ExtendedKeyUsage</name><environment>Security</environment><super>Security.X509Extension</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyPurposeId </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509CertificatePoliciesOld</name><environment>Security</environment><super>Security.X509Extension</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509KeyUsage</name><environment>Security</environment><super>Security.X509Extension</super><private>false</private><indexed-type>none</indexed-type><inst-vars>crlSign decipherOnly digitalSignature encipherOnly keyAgreement keyCertSign keyEncipherment nonRepudiation dataEncipherment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509AuthorityKeyIdentifier</name><environment>Security</environment><super>Security.X509Extension</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyIdentifier authorityCertIssuer authorityCertSerialNumber </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509CertificateIssuer</name><environment>Security</environment><super>Security.X509Extension</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509CRLDistributionPoints</name><environment>Security</environment><super>Security.X509Extension</super><private>false</private><indexed-type>none</indexed-type><inst-vars>distributionPoints </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509SubjectDirectoryAttributes</name><environment>Security</environment><super>Security.X509Extension</super><private>false</private><indexed-type>none</indexed-type><inst-vars>attributes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509IssuerAlernativeNames</name><environment>Security</environment><super>Security.X509Extension</super><private>false</private><indexed-type>none</indexed-type><inst-vars>generalNames </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509DeltaCRLIndicator</name><environment>Security</environment><super>Security.X509Extension</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509InvalidityDate</name><environment>Security</environment><super>Security.X509Extension</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509CRLNumber</name><environment>Security</environment><super>Security.X509Extension</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509PolicyConstraints</name><environment>Security</environment><super>Security.X509Extension</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requireExplicitPolicy inhibitPolicyMapping </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509CertificatePolicies</name><environment>Security</environment><super>Security.X509Extension</super><private>false</private><indexed-type>none</indexed-type><inst-vars>policyInformationCollection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509HoldInstructionCode</name><environment>Security</environment><super>Security.X509Extension</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509IssuingDistributionPoint</name><environment>Security</environment><super>Security.X509Extension</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509PrivateKeyUsagePeriod</name><environment>Security</environment><super>Security.X509Extension</super><private>false</private><indexed-type>none</indexed-type><inst-vars>notBefore notAfter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509SubjectKeyIdentifier</name><environment>Security</environment><super>Security.X509Extension</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><class><name>X509ReasonCode</name><environment>Security</environment><super>Security.X509Extension</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Certificates</category><attributes><package>X509</package></attributes></class><shared-variable><name>OIDExtensionMap</name><environment>Security.X509Extension</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>X509</package></attributes></shared-variable><shared-variable><name>SignatureVerificationDictionary</name><environment>Security.X509CertificateSignatureVerification</environment><private>false</private><constant>false</constant><category>constants</category><attributes><package>X509</package></attributes></shared-variable><shared-variable><name>DefaultCertificateFile</name><environment>Security.X509Registry</environment><private>false</private><constant>false</constant><category>Certificates</category><attributes><package>X509</package></attributes></shared-variable><shared-variable><name>UnVerifiedCertificates</name><environment>Security.X509Registry</environment><private>false</private><constant>false</constant><category>Certificates</category><attributes><package>X509</package></attributes></shared-variable><shared-variable><name>NotTrustedCertificates</name><environment>Security.X509Registry</environment><private>false</private><constant>false</constant><category>Certificates</category><attributes><package>X509</package></attributes></shared-variable><shared-variable><name>TrustedCertificates</name><environment>Security.X509Registry</environment><private>false</private><constant>false</constant><category>Certificates</category><attributes><package>X509</package></attributes></shared-variable><shared-variable><name>ShouldBeStrict</name><environment>Security.X509Registry</environment><private>false</private><constant>false</constant><category>Certificates</category><initializer>false</initializer><attributes><package>X509</package></attributes></shared-variable><shared-variable><name>RevokedCertificates</name><environment>Security.X509Registry</environment><private>false</private><constant>false</constant><category>Certificates</category><attributes><package>X509</package></attributes></shared-variable><shared-variable><name>OIDToDescription</name><environment>Security.X509Name</environment><private>false</private><constant>false</constant><category>ssl</category><initializer>X509Name buildOIDToDescription</initializer><attributes><package>X509</package></attributes></shared-variable><methods><class-id>Security.X509Registry</class-id> <category>accessing</category><body package="X509" selector="addCertificate:">addCertificate: aCertificate	trustedCertificates isNil ifTrue: [ trustedCertificates := Set new ].	trustedCertificates add: aCertificate</body><body package="X509" selector="beStrict">beStrict	strict := true</body><body package="X509" selector="certificateFor:">certificateFor: aDNAssociations	^trustedCertificates		detect: [ :cert | aDNAssociations = cert subject asAssociations ]		ifNone: [ nil ]</body><body package="X509" selector="dontBeStrict">dontBeStrict	strict := false</body><body package="X509" selector="isStrict">isStrict	^strict</body><body package="X509" selector="removeCertificate:">removeCertificate: aCertificate	trustedCertificates isNil ifTrue: [NotFoundError raiseWith: aCertificate].	trustedCertificates remove: aCertificate</body><body package="X509" selector="trustedCertificates">trustedCertificates	^trustedCertificates</body><body package="X509" selector="trustedCertificates:">trustedCertificates: aSet	trustedCertificates := aSet</body></methods><methods><class-id>Security.X509Registry</class-id> <category>chain verification</category><body package="X509" selector="trustedCertificateMatching:">trustedCertificateMatching: dnBytes	^trustedCertificates		detect: [ :cert | dnBytes = cert subjectDNInBytes ]		ifNone: [ nil ]</body><body package="X509" selector="validateCertificateChain:">validateCertificateChain: aCertificateChain 	"verify that the issuer of first certificate is the subject of the next. 	and with each make sure that they are valid. verify signatures 	and verify dates. with the last certificate since it is self signed 	check to see if we have the subject name in our trusted 	certificates registry. If not raise a proceedable exception. Also 	check to see if any certificate is in the revocation list."	| chain last root |	"Prepare a chain for validation loop"	chain := (last := (self trustedCertificateMatching: aCertificateChain last subjectDNInBytes)) isNil			ifTrue: [ (last := (self trustedCertificateMatching: aCertificateChain last issuerDNInBytes)) isNil					ifTrue: [ "In this case either the chain is rooted in an unknown CA certificate,						or the chain is simply incomplete. Both cases are equally bad."						X509RootNotTrusted new							messageText: (#CANotInTrustRegistry &lt;&lt; #security &gt;&gt; 'CA Not in Trust Registry!');							parameter: aCertificateChain last;							isResumable: true;							raiseSignal.						aCertificateChain ]					ifFalse: [ "Since the self signed certificate at the end of the chain is practically useless,						it is common practice to simply not send it. In this case just add our trusted CA cert to the end of the chain"						aCertificateChain copyWith: last ] ]			ifFalse: [ "This is the standard case, only the local copy of the trusted certificate should be used to validate the root of the chain"				aCertificateChain copy					removeLast;					addLast: last;					yourself ].	"Now let's go validate the chain"	root := chain last.	chain inject: nil into: [ :subject :issuer |		issuer			verifyValidityPeriod;			verifyRevocationStatus.		self verifyCriticalExtentions: issuer.		subject ifNotNil: [			"Unfortunatelly V1 certificates are still widely deployed (e.g. Verisign),			so we'll allow V1 roots when in relaxed mode"			(self isStrict not and: [issuer == root and: [issuer isVersionOne]])				ifFalse:[ self verifyCACertificate: issuer ].			subject verifyIssuedBy: issuer ].		issuer ]</body><body package="X509" selector="verifyBasicConstraints:">verifyBasicConstraints: aCertificate"Check Basic Constraints"	| basicConstraints |	basicConstraints := aCertificate getBasicContraints.	basicConstraints isNil ifTrue: [		^X509BadCAConstraints new			messageText: (#MissingBasicConstraints &lt;&lt; #security &gt;&gt; 'Basic Constraints are required for a CA certificate !');			parameter: aCertificate;			raiseSignal ].	basicConstraints isCritical ifFalse: [		X509ExtensionShouldBeCritical  new			messageText: (#ExtShouldBeCritical &lt;&lt; #security &gt;&gt; 'This extension should be critical');			parameter: aCertificate;			extension: basicConstraints;			raiseSignal ].	basicConstraints ca 	ifFalse: [		X509BadCAConstraints new			messageText: (#NonCABasicConstraints &lt;&lt; #security &gt;&gt; 'Basic Constraints are invalid for a CA certificate !');			parameter: aCertificate;			raiseSignal ].</body><body package="X509" selector="verifyCACertificate:">verifyCACertificate: aCertificate	self		verifyBasicConstraints: aCertificate;		verifyKeyUsage: aCertificate</body><body package="X509" selector="verifyCriticalExtentions:">verifyCriticalExtentions: aCertificate	(	aCertificate getCriticalExtensions			detect:[ :ext | ext isHandled not]			ifNone:[ nil ]	) ifNotNil: [ :extension |		X509UnhandledCriticalExtension new			messageText: (#UnhandledCriticalExt &lt;&lt; #security &gt;&gt; 'Critical extension is not handled');			parameter: aCertificate;			extension: extension;			raiseSignal  ].</body><body package="X509" selector="verifyKeyUsage:">verifyKeyUsage: aCertificate"Verify Key Usage extension"	| keyUsage |	keyUsage := aCertificate getKeyUsage.	keyUsage isNil ifTrue: [		^self isStrict ifTrue: [			X509BadCAKeyUsage new				messageText: (#MissingKeyUsage &lt;&lt; #security &gt;&gt; 'Key Usage is required for a CA certificate !');				parameter: aCertificate;				raiseSignal ] ].	keyUsage isCritical ifFalse:[		X509ExtensionShouldBeCritical  new			messageText: (#ExtShouldBeCritical &lt;&lt; #security &gt;&gt; 'This extension should be critical');			parameter: aCertificate;			extension: keyUsage;			raiseSignal ].	keyUsage keyCertSign ifFalse: [		X509BadCAKeyUsage new			messageText: (#NotForCertSigning1 &lt;&lt; #security &gt;&gt; 'Key Usage is invalid for a CA certificate !');			parameter: aCertificate;			raiseSignal ].</body></methods><methods><class-id>Security.X509Registry</class-id> <category>intialization</category><body package="X509" selector="initialize">initialize	strict := self class shouldBeStrict</body></methods><methods><class-id>Security.X509Registry class</class-id> <category>accessing</category><body package="X509" selector="addCertificateToTrust:">addCertificateToTrust: aCertificate 	self trustedCertificates add: aCertificate.	self updateDictionaries</body><body package="X509" selector="beStrict">beStrict	ShouldBeStrict := true.</body><body package="X509" selector="defaultCertificateFile">defaultCertificateFile^DefaultCertificateFile isNil ifTrue:[DefaultCertificateFile := 'trustedCertificates.pem'] ifFalse:[ DefaultCertificateFile]</body><body package="X509" selector="defaultCertificateFile:">defaultCertificateFile: aString DefaultCertificateFile := aString</body><body package="X509" selector="dontBeStrict">dontBeStrict	ShouldBeStrict := false.</body><body package="X509" selector="removeCertificate:">removeCertificate: aCertificate"remove a trusted Certificate from the registry and update the indexes"	self trustedCertificates remove: aCertificate ifAbsent: [].	self updateDictionaries</body><body package="X509" selector="shouldBeStrict">shouldBeStrict	^ShouldBeStrict</body><body package="X509" selector="trustedCertificates">trustedCertificates	^TrustedCertificates isNil ifTrue:[TrustedCertificates := Set new: 100 ] ifFalse:[TrustedCertificates ]</body><body package="X509" selector="updateDictionaries">updateDictionaries" needs to be added. update our indexes. want to index by signature, subjectDN"</body></methods><methods><class-id>Security.X509Registry class</class-id> <category>testing</category><body package="X509" selector="trustedCertificatesContains:">trustedCertificatesContains: aCertificate"fix this to add the certificate search"^self trustedCertificates contains: aCertificate</body></methods><methods><class-id>Security.X509Registry class</class-id> <category>instance creation</category><body package="X509" selector="default">default	^default isNil ifTrue:[default := self newDefault ] ifFalse:[default ]</body><body package="X509" selector="new">new	^super new initialize</body><body package="X509" selector="newDefault">newDefault	| inst |	inst := self newFromDefaultCertificateFile. 	TrustedCertificates := inst trustedCertificates.	^inst</body><body package="X509" selector="newFromCertificateFile:">newFromCertificateFile: aFileString	| inst defaultFile |	inst := self new.	defaultFile :=  aFileString asFilename.	inst trustedCertificates: (defaultFile exists ifTrue:[	(Set new: 100) addAll: (X509CertificateFileReader readCertificatesFrom: defaultFile)] ifFalse:[Set new: 100]).	^inst</body><body package="X509" selector="newFromDefaultCertificateFile">newFromDefaultCertificateFile	| inst defaultFile |	inst := self new.	defaultFile := self defaultCertificateFile asFilename.	inst trustedCertificates: (defaultFile exists ifTrue:[	(Set new: 100) addAll: (X509CertificateFileReader readCertificatesFrom: defaultFile)] ifFalse:[Set new: 100]).	^inst</body></methods><methods><class-id>Security.X509Registry class</class-id> <category>reading</category><body package="X509" selector="readTrustedCertificatesFromFile:">readTrustedCertificatesFromFile: aFilename		"self readTrustedCertificatesFromFile: '..\..\demo.pem'"	| collection |	collection := X509CertificateFileReader readCertificatesFrom: aFilename.	self trustedCertificates addAll: collection.</body></methods><methods><class-id>Security.X509Certificate</class-id> <category>accessing</category><body package="X509" selector="derCertificate">derCertificate	"Answers the DER encoded certificate"	^derCertificate</body><body package="X509" selector="encodedCertificate">encodedCertificate	^encodedCertificate</body><body package="X509" selector="extensions">extensions	"Answers an Ordered Collection of X509Extension objects"	^tbsCertificate extensions</body><body package="X509" selector="getCriticalExtensions">getCriticalExtensions 	^tbsCertificate getCriticalExtensions</body><body package="X509" selector="getPublicKey">getPublicKey	^tbsCertificate getPublicKey</body><body package="X509" selector="getRSAPublicKey">getRSAPublicKey	^tbsCertificate subjectPublicKeyInfo publicKey getKey</body><body package="X509" selector="issuerDN">issuerDN	"Answers the distinguished name of the issuer"	^tbsCertificate issuerDN</body><body package="X509" selector="issuerDNInBytes">issuerDNInBytes	"Answers the distinguished name of the issuer in Bytes"	^tbsCertificate issuerDNInBytes</body><body package="X509" selector="marshaller">marshaller	^marshaller isNil ifTrue:[ marshaller := ( ASN1.Asn1StreamDER on: ( ByteArray new: 4096 ) ) maxReadLimit.] ifFalse:[marshaller]</body><body package="X509" selector="marshaller:">marshaller: anObject	marshaller := anObject</body><body package="X509" selector="notAfter">notAfter	"a string containing notAfter as a UTCTIME"	^tbsCertificate notAfter</body><body package="X509" selector="notAfterDate">notAfterDate	"an instance of Date containing the date  of notAfter"	^tbsCertificate notAfterDate</body><body package="X509" selector="notAfterTime">notAfterTime	" instance of Time containing the time  of notAfter"	^tbsCertificate notAfterTime</body><body package="X509" selector="notBefore">notBefore	"string containing notBefore as a UTCTIME"	^tbsCertificate notAfter</body><body package="X509" selector="notBeforeDate">notBeforeDate	"instance of Date containing the date  of notBefore"	^tbsCertificate notBeforeDate</body><body package="X509" selector="notBeforeTime">notBeforeTime	" instance of Time containing the time  of notBefore"	^tbsCertificate notBeforeTime</body><body package="X509" selector="privateKey">privateKey	^privateKey</body><body package="X509" selector="privateKey:">privateKey: aPrivateKey	privateKey := aPrivateKey</body><body package="X509" selector="serialNumber">serialNumber	"Answers the serial number of  certificate"	^tbsCertificate serialNumber</body><body package="X509" selector="signature">signature	^signature</body><body package="X509" selector="signatureAlgorithm">signatureAlgorithm	^signatureAlgorithm</body><body package="X509" selector="signatureAlgorithmOID">signatureAlgorithmOID	"Answers the OID of the algorithm used to sign this certificate"	^tbsCertificate signatureAlgorithmOID</body><body package="X509" selector="signatureAlgorithmOIDDescription">signatureAlgorithmOIDDescription	"Answers the description of the OID of the algorithm used to sign this certificate"	^tbsCertificate signatureAlgorithmOIDDescription</body><body package="X509" selector="subjectDN">subjectDN	"Answers the distinguished name of the subject"	^tbsCertificate subjectDN</body><body package="X509" selector="subjectDNInBytes">subjectDNInBytes	"Answers the distinguished name of the subject"	^tbsCertificate subjectDNInBytes</body><body package="X509" selector="subjectPublicKey">subjectPublicKey	"Answers the subject's public key"	^tbsCertificate subjectPublicKeyInfo subjectPublicKey</body><body package="X509" selector="subjectPublicKeyAlgorithmOID">subjectPublicKeyAlgorithmOID	"OID of the algorithm used to generate the subject's public key"	^tbsCertificate subjectPublicKeyInfo algorithm getOID</body><body package="X509" selector="subjectPublicKeyAlgorithmOIDDescription">subjectPublicKeyAlgorithmOIDDescription	"description of the OID of the algorithm used to generate the subject's public key"	^tbsCertificate subjectPublicKeyInfo algorithm getOIDDescription</body><body package="X509" selector="tbsDerCertificate">tbsDerCertificate	"Answers the DER encoded certificate"	^tbsDerCertificate</body><body package="X509" selector="version">version	"Answers the version number of the certificate"	^tbsCertificate version</body></methods><methods><class-id>Security.X509Certificate</class-id> <category>key usage</category><body package="X509" selector="getKeyUsage">getKeyUsage 	^tbsCertificate getKeyUsage</body><body package="X509" selector="hasKeyUsage">hasKeyUsage 	^tbsCertificate hasKeyUsage</body><body package="X509" selector="isCrlSign">isCrlSign 	^tbsCertificate isCrlSign</body><body package="X509" selector="isDataEncipherment">isDataEncipherment 	^tbsCertificate isDataEncipherment</body><body package="X509" selector="isDecipherOnly">isDecipherOnly 	^tbsCertificate isDecipherOnly</body><body package="X509" selector="isDigitalSignature">isDigitalSignature 	^tbsCertificate isDigitalSignature</body><body package="X509" selector="isEncipherOnly">isEncipherOnly 	^tbsCertificate isEncipherOnly</body><body package="X509" selector="isKeyAgreement">isKeyAgreement 	^tbsCertificate isKeyAgreement</body><body package="X509" selector="isKeyCertSign">isKeyCertSign 	^tbsCertificate isKeyCertSign</body><body package="X509" selector="isKeyEncipherment">isKeyEncipherment 	^tbsCertificate isKeyEncipherment</body><body package="X509" selector="isKeyUsageCritical">isKeyUsageCritical 	^tbsCertificate isKeyUsageCritical</body><body package="X509" selector="isNonRepudiation">isNonRepudiation 	^tbsCertificate isNonRepudiation</body></methods><methods><class-id>Security.X509Certificate</class-id> <category>initialize</category><body package="X509" selector="getCertificateData">getCertificateData	"Answers true if the Base64 encoded certificate has the appropriate delimiters required for PEM 	format; otherwise, answers nil"	| i j k |	i := encodedCertificate				indexOfSubCollection: '--BEGIN '				startingAt: 1				ifAbsent: [^nil].	i := encodedCertificate				indexOfSubCollection: 'CERTIFICATE--'				startingAt: i				ifAbsent: [^nil].	j := encodedCertificate				indexOfSubCollection: '--END '				startingAt: i				ifAbsent: [^nil].	k := encodedCertificate				indexOfSubCollection: 'CERTIFICATE--'				startingAt: j				ifAbsent: [^nil].	i := (encodedCertificate findEither: Character cr or: Character lf from: i to: k).	^(encodedCertificate copyFrom: i to: j)		reject: [:c | c = $- or: [c isSeparator]]</body><body package="X509" selector="initialize:">initialize: aFile	"Checks that it is PEM (i.e. has the appropriate '---BEGIN CERTIFICATE---' and '---END CERTIFICATE---' lines. Strips out all cr/lf characters. Converts from Base 64"	^self initializeFromString:  aFile asFilename readStream contents.</body><body package="X509" selector="initializeFromBytes:">initializeFromBytes: aByteArray	derCertificate := aByteArray.	^self parse</body><body package="X509" selector="initializeFromString:">initializeFromString: aString	| s |	encodedCertificate := aString.	s := self getCertificateData.	s isNil ifTrue: [^nil].	^self initializeFromBytes: (self decodeBase64: s copy)</body><body package="X509" selector="initializeFromStringThatIncludesPrivateKey:">initializeFromStringThatIncludesPrivateKey: aString	| s array |	array := self separateCertificateFromPrivateKey: aString.	encodedCertificate := array first.	s := self getCertificateData.	s isNil ifTrue: [^nil].	self initializeFromBytes: (self decodeBase64: s copy).	privateKey := array at: 2</body><body package="X509" selector="initializeFromStringThatIncludesRSAPrivateKey:">initializeFromStringThatIncludesRSAPrivateKey: aString	| s array |	array := self separateCertificateFromRSAPrivateKey: aString.	encodedCertificate := array first.	s := array first.	s isNil ifTrue: [^nil].	self initializeFromBytes: (self decodeBase64: s copy).	privateKey :=X509RSAPrivateKey new  initializeFromBytes: ((self decodeBase64:(array at: 2)) )</body><body package="X509" selector="separateCertificateFromPrivateKey:">separateCertificateFromPrivateKey: aString</body><body package="X509" selector="separateCertificateFromRSAPrivateKey:">separateCertificateFromRSAPrivateKey: aString	"Answers true if the Base64 encoded certificate has the appropriate delimiters required for PEM 	format; otherwise, answers nil"	| i j k array |	array := Array new: 2.	i := aString				indexOfSubCollection: '--BEGIN '				startingAt: 1				ifAbsent: [^nil].	i := aString				indexOfSubCollection: 'CERTIFICATE--'				startingAt: i				ifAbsent: [^nil].	j := aString				indexOfSubCollection: '--END '				startingAt: i				ifAbsent: [^nil].	k := aString				indexOfSubCollection: 'CERTIFICATE--'				startingAt: j				ifAbsent: [^nil].	i := (aString findEither: Character cr or: Character lf from: i to: k).	array at: 1 put: ((aString copyFrom: i to: j)		reject: [:c | c = $- or: [c isSeparator]]).	i := aString				indexOfSubCollection: '---BEGIN RSA'				startingAt: 1				ifAbsent: [^nil].	i := aString				indexOfSubCollection: 'KEY--'				startingAt: i				ifAbsent: [^nil].	j := aString				indexOfSubCollection: '--END RSA'				startingAt: i				ifAbsent: [^nil].	k := aString				indexOfSubCollection: ' KEY--'				startingAt: j				ifAbsent: [^nil].	i := (aString findEither: Character cr or: Character lf from: i to: k).	array at: 2 put: ((aString copyFrom: i to: j)		reject: [:c | c = $- or: [c isSeparator]]).^array</body></methods><methods><class-id>Security.X509Certificate</class-id> <category>verification</category><body package="X509" selector="validateCertificateChain:">validateCertificateChain: anOrderedCollection 	^self class validateCertificateChain: anOrderedCollection</body><body package="X509" selector="verifyCriticalExtentionsHandled">verifyCriticalExtentionsHandled	| criticalExtensionsNotHandled |	criticalExtensionsNotHandled := self getCriticalExtensions detect:[:ea | ea isHandled not] ifNone:[nil].	criticalExtensionsNotHandled notNil ifTrue:[		X509UnhandledCriticalExtension new			messageText: (#UnhandledCritExt &lt;&lt; #security &gt;&gt; 'Critical Extension is Not Handled');			parameter: self;			isResumable: true;			raiseSignal  ].</body><body package="X509" selector="verifyIsCaCertificate">verifyIsCaCertificate	"check the basic contrints to see if the extension is present and if it is a ca certificate"	self isCACertificate ifFalse: [		X509BadCAConstraints new			messageText: (#NonCAIssuer &lt;&lt; #security &gt;&gt; 'Signing Certificate is not a CA Certificate, Certificate Chain Invalid !');			parameter: self;			isResumable: true;			raiseSignal ].</body><body package="X509" selector="verifyIssuedBy:">verifyIssuedBy: aCertificate	self issuerDNInBytes = aCertificate subjectDNInBytes ifFalse: [		X509BrokenChain new			messageText: (#CertificateChainInvalid &lt;&lt; #security &gt;&gt; 'Certificate Chain Invalid !');			parameter: (Array with: self with: aCertificate);			isResumable: true;			raiseSignal ].	self verifySignedBy: aCertificate</body><body package="X509" selector="verifyKeyCertSign">verifyKeyCertSign"check the basic constraints to see if the extension is present and if it is a ca certificate"	self isKeyUsageCritical ifFalse: [		X509ExtensionShouldBeCritical  new			messageText: (#CertExtShouldBeCritical &lt;&lt; #security &gt;&gt; 'This extension in this certificate should be critical');			parameter: self;			isResumable: true;			raiseSignal ].	self isKeyCertSign ifFalse: [		X509BadCAKeyUsage new			messageText: (#NotForCertSigning &lt;&lt; #security &gt;&gt; 'Signing Certificate is not Allowed to Sign Certificates !');			parameter: self;			isResumable: true;			raiseSignal ].</body><body package="X509" selector="verifyRevocationStatus">verifyRevocationStatus	self hasBeenRevoked ifTrue: [		X509Revoked new			messageText: (#CertificateRevoked &lt;&lt; #security &gt;&gt; 'Certificate Revoked!');			parameter: self;			isResumable: true;			raiseSignal]</body><body package="X509" selector="verifySignature">verifySignature"Verify signature on a self signed certificate.Throw an exception if the verification fails in any way, otherwise simply complete without exceptions"	self verifySignedBy: self</body><body package="X509" selector="verifySignedBy:">verifySignedBy: aCertificate"Run verification of the receiver's signature using aCertificate's public key.Throw an exception if the verification fails in any way, otherwise simply complete without exceptions"	| verifier |	verifier := X509CertificateSignatureVerification verifierForOID: signatureAlgorithm getOIDSymbol.	verifier isNil		ifTrue: [ "we do not have a verifier for this Algorithm OID yet raise the proceedable certificate unsupported "			X509Unsupported new				messageText: (#UnsupportedSigAlg &lt;&lt; #security &gt;&gt; 'Certificate signature algorithm is not supported!');				parameter: self;				isResumable: true;				raiseSignal ]		ifFalse: [			(verifier verifyCertificate: self isSignedBy: aCertificate) ifFalse: [				X509InvalidSignature new					messageText: (#InvalidSignature &lt;&lt; #security &gt;&gt; 'Certificate signature is not valid!');					parameter: self;					isResumable: true;					raiseSignal ] ]</body><body package="X509" selector="verifyValidityPeriod">verifyValidityPeriod	self isBeforeValidityDate ifTrue: [		X509NotValidYet new			messageText: (#CertificateNotValidYet &lt;&lt; #security &gt;&gt; 'Certificate not valid yet!');			parameter: self;			isResumable: true;			raiseSignal ].	self isExpired ifTrue: [		X509Expired new			messageText: (#CertificateExpired &lt;&lt; #security &gt;&gt; 'Certificate expired!');			parameter: self;			isResumable: true;			raiseSignal].</body></methods><methods><class-id>Security.X509Certificate</class-id> <category>basic constraints</category><body package="X509" selector="getBasicContraints">getBasicContraints 	^tbsCertificate getBasicContraints</body><body package="X509" selector="hasBasicConstraints">hasBasicConstraints 	^tbsCertificate hasBasicConstraints</body><body package="X509" selector="isCACertificate">isCACertificate 	^tbsCertificate isCACertificate</body></methods><methods><class-id>Security.X509Certificate</class-id> <category>ssl</category><body package="X509" selector="isRSA">isRSA	^self subjectPublicKeyAlgorithmOIDDescription = 'rsaEncryption'</body><body package="X509" selector="issuer">issuer	^tbsCertificate issuer</body><body package="X509" selector="subject">subject	^tbsCertificate subject</body></methods><methods><class-id>Security.X509Certificate</class-id> <category>testing</category><body package="X509" selector="hasBeenRevoked">hasBeenRevoked"add crl check for now return false"^false</body><body package="X509" selector="isBeforeValidityDate">isBeforeValidityDate	" true if the current date/time is prior to the 'notBefore' date; otherwise,  false"	| dt |	dt := Date dateAndTimeNow.	^(((dt at: 1) asSeconds) + ((dt at: 2) asSeconds)) &lt;	((self notBeforeDate) asSeconds + (self notBeforeTime) asSeconds)</body><body package="X509" selector="isExpired">isExpired	"true if the current data/time is past the 'notAfter' date; otherwise, false"	| dt |	dt := Date dateAndTimeNow.	^(dt at: 1) asSeconds + (dt at: 2) asSeconds &gt; (self notAfterDate asSeconds + self notAfterTime asSeconds)</body><body package="X509" selector="isValid">isValid	"true if current date/time is later than the 'notBefore' date and prior to the 'notAfter' date; otherwise, 	false"	| dt |	dt := Date dateAndTimeNow.	^(dt at: 1) asSeconds + (dt at: 2) asSeconds &gt; (self notBeforeDate asSeconds + self notBeforeTime asSeconds) and: [(dt at: 1) asSeconds + (dt at: 2) asSeconds &lt; (self notAfterDate asSeconds + self notAfterTime asSeconds)]</body><body package="X509" selector="isVersionOne">isVersionOne	^self version = 1</body><body package="X509" selector="isVersionThree">isVersionThree	^self version = 3</body></methods><methods><class-id>Security.X509Certificate</class-id> <category>printing</category><body package="X509" selector="printOn:">printOn: aStream	aStream		nextPutAll: 'X509v';		print: self version;		nextPutAll: ': ';		nextPutAll: (self subject asDictionary at: 'CN' ifAbsent:['No Common Name']);		nextPutAll: ' &lt;';		nextPutAll: (self issuer asDictionary at: 'CN' ifAbsent:['No Common Name']);		nextPut: $&gt;</body><body package="X509" selector="printOpenSSLOn:indent:">printOpenSSLOn: aStream indent: level"This should print the certificate in the format used by OpenSSL"	aStream		tab: level; nextPutAll: (#CertificatePrefix &lt;&lt; #security &gt;&gt; 'Certificate:') asString; cr;		tab: level + 1; nextPutAll: (#DataPrefix &lt;&lt; #security &gt;&gt; 'Data:') asString; cr.	tbsCertificate printOpenSSLOn: aStream indent: level + 2.	aStream		tab: level + 1;		nextPutAll: (#SignatureAlgorithmPrefix &lt;&lt; #security &gt;&gt; 'Signature Algorithm: ') asString;		nextPutAll: self signatureAlgorithm getOIDDescription; cr.	signature printOpenSSLOn: aStream indent: level + 2 width: 18</body><body package="X509" selector="printOpenSSLString">printOpenSSLString"This should print the certificate in the format used by OpenSSL"	| ws |	ws := WriteStream on: (String new: 100).	self printOpenSSLOn: ws indent: 0.	^ws contents</body></methods><methods><class-id>Security.X509Certificate</class-id> <category>utilities</category><body package="X509" selector="decodeBase64:">decodeBase64: aString	| input stream output char |	input := aString asByteArray readStream.	stream := EncodedStream on: input encodedBy: Net.Base64StreamEncoder asEncoder.	output := (ByteArray new: aString size) writeStream.	[ (char := stream next) notNil ] whileTrue: [ output nextPut: char ].	^output contents</body><body package="X509" selector="getFormattedCertificate">getFormattedCertificate	"Answers a String containing the formatted self"	| s idn i pk  |	s := WriteStream on: String new.	s nextPutAll: (#CertificateVersionPrefix &lt;&lt; #security &gt;&gt; 'X509 Certificate Version: ') asString; nextPutAll: self version printString; nextPutAll: ' ', (#SerialNumberPrefix &lt;&lt; #security &gt;&gt; 'Serial Number: ') asString; nextPutAll: self serialNumber printString.	idn := self issuerDN.	s cr; cr; nextPutAll: (#IssuerPrefix &lt;&lt; #security &gt;&gt; 'Issuer: ') asString.	idn := self issuerDN.	i := 1.	idn size		timesRepeat: 			[s nextPutAll: (idn at: i) type getOIDDescription; nextPutAll: '='; nextPutAll: (idn at: i) value value .			i = idn size ifFalse: [s nextPutAll: ', '].			i := i + 1].	s cr; cr.	idn := self issuerDN.	s cr; cr; nextPutAll: (#SubjectPrefix &lt;&lt; #security &gt;&gt; 'Subject: ') asString.	idn := self subjectDN.	i := 1.	idn size		timesRepeat: 			[s nextPutAll: (idn at: i) type getOIDDescription; nextPutAll: '='; nextPutAll: (idn at: i) value value.			i = idn size ifFalse: [s nextPutAll: ', '].			i := i + 1].	s cr; cr; nextPutAll: (#SubPubKeyAlgPrefix &lt;&lt; #security &gt;&gt; 'Subject Public Key Algorithm: ') asString; nextPutAll: self subjectPublicKeyAlgorithmOID value getDottedOID ; nextPutAll: ' ('; nextPutAll: self subjectPublicKeyAlgorithmOIDDescription; nextPutAll: ')'.	s cr; cr; nextPutAll: (#SubPubKeyPrefix &lt;&lt; #security &gt;&gt; 'Public Key:') asString.	pk := self subjectPublicKey getBitStringAsFormattedHexStrings.	s crtab; nextPutAll: pk.	self extensions isNil		ifFalse: 			[s cr; cr; nextPutAll: (#ExtensionsPrefix &lt;&lt; #security &gt;&gt; 'EXTENSIONS:') asString.			self extensions				do: 					[:ext | 					s crtab; nextPutAll: ext id; nextPutAll: ' ('; nextPutAll: ext idDescription; nextPutAll: ')'.					ext isCritical ifTrue: [s tab; nextPutAll: (#CRITICAL &lt;&lt; #security &gt;&gt; 'CRITICAL') asString]]].	s cr; cr; nextPutAll: (#SignatureAlgorithmPrefix &lt;&lt; #security &gt;&gt; 'Signature Algorithm: ') asString; nextPutAll: self signatureAlgorithmOID getDottedOID ; nextPutAll: ' ('; nextPutAll: self signatureAlgorithmOIDDescription; nextPutAll: ')'.	s cr; cr; nextPutAll: (#SignaturePrefix &lt;&lt; #security &gt;&gt; 'Signature:') asString.	pk := self signature asFormattedHexStrings.	s crtab; nextPutAll: pk.	^s contents</body><body package="X509" selector="inspectorExtraAttributes">inspectorExtraAttributes	^Array		with: (Tools.Trippy.TextAttribute label: 'description' text: self getFormattedCertificate)		with: (Tools.Trippy.TextAttribute label: 'openssl' text: self printOpenSSLString)</body></methods><methods><class-id>Security.X509Certificate</class-id> <category>parsing</category><body package="X509" selector="parse">parse	"Parses the certificate to extract its components and sub-components"	derCertificate do: [ :x | self marshaller nextPut: x ].	self marshaller setReadLimit: self marshaller position.	self marshaller position: 0.	self marshaller  retainEncodings: true.	certificateSequence := self marshaller  unmarshalObjectType: ( ASN1.Asn1Type findTypeNamed: #Certificate ).	tbsSequence :=certificateSequence tbsCertificate.	tbsDerCertificate := tbsSequence encoding fullEncoding.	tbsCertificate := X509TBSCertificate fromASN1Type: tbsSequence.	signatureAlgorithm := X509AlgorithmIdentifier fromASN1Type: tbsSequence signature .	signature :=		(X509DSASignatureVerification oidCollection includes:  signatureAlgorithm getOIDSymbol)			ifTrue: [ X509DSSSignatureValue fromASN1Type:( certificateSequence signatureValue ) ]			ifFalse: [ "the signature is not a complex object or it is one that is complex but we do not deal with yet"				certificateSequence signatureValue value value.].	^self</body></methods><methods><class-id>Security.X509Certificate class</class-id> <category>utilities</category><body package="X509" selector="decodeBase64:">decodeBase64: aString	| input stream output char |	input := aString asByteArray readStream.	stream := EncodedStream on: input encodedBy: Net.Base64StreamEncoder asEncoder.	output := (ByteArray new: 64) writeStream.	[ (char := stream next) notNil ] whileTrue: [ output nextPut: char ].	^output contents</body><body package="X509" selector="displayFormattedCertificateToTranscript">displayFormattedCertificateToTranscript	"self displayFormattedCertificateToTranscript"	"ask for and display the certificate to the transcript"	Transcript show: self getFormattedCertificate ;cr</body><body package="X509" selector="getFormattedCertificate">getFormattedCertificate	"Answers a String containing the formatted certificate""self getFormattedCertificate"	| filename certificate |	filename := Dialog requestFileName: (#RequestCertPath &lt;&lt; #security &gt;&gt; 'enter full path to certificate').	certificate := self fromFile: filename.	^certificate getFormattedCertificate</body><body package="X509" selector="getHex">getHex	"Answers the hexadecimal representation of the certificate"	| s data filename certificate |	filename := Dialog requestFileName: (#RequestCertPath &lt;&lt; #security &gt;&gt; 'enter full path to certificate').	certificate := self fromFile: filename.	certificate isNil ifTrue: [^(#FileNotFound &lt;&lt; #security &gt;&gt; 'File Not Found')].	data := certificate derCertificate.	s := WriteStream on: (String new: data size * 4).	0		to: data size - 1		by: 16		do: 			[:loc | 			s nextPutAll: loc hex; space; nextPut: $(; print: loc; nextPut: $); space; tab.			loc + 1 to: (loc + 16 min: data size)				do: [:i | s nextPutAll: (data at: i) hex; space].			s cr].	^s contents</body><body package="X509" selector="readFileWithCertificateAndRSAPrivateKeyPairs:">readFileWithCertificateAndRSAPrivateKeyPairs: aFilename"self readFileWithCertificateAndRSAPrivateKeyPairs: 'd:\ssl\openssl-0.9.5a\certs\ca-cert.pem' "	^aFilename asFilename exists		ifTrue: [self new initializeFromStringThatIncludesRSAPrivateKey: aFilename asFilename readStream contents.]		ifFalse: [nil]</body><body package="X509" selector="readFileWithCertificateAnPrivateKeyPairs:">readFileWithCertificateAnPrivateKeyPairs: aFilename" this is to be implemented"</body></methods><methods><class-id>Security.X509Certificate class</class-id> <category>instance creation</category><body package="X509" selector="fromBytes:">fromBytes: aByteArray	^self new initializeFromBytes: aByteArray</body><body package="X509" selector="fromFile:">fromFile: aFile 	^self new initialize: aFile</body><body package="X509" selector="fromString:">fromString:aString	^self new initializeFromString: aString</body><body package="X509" selector="readFromAssociation:">readFromAssociation: anAssociation"this is and association of a raw certificate and if the value is not nil the privateKey if the Key is not know the instansiate anX509UnknownKey"| certificate |	certificate := self fromString: anAssociation key.anAssociation value notNil ifTrue:[certificate privateKey: (X509UnknownPrivateKey readAndReturnSomeKeyFrom: anAssociation value)].^certificate</body></methods><methods><class-id>Security.X509Certificate class</class-id> <category>chain verification</category><body package="X509" selector="validateCertificateChain:">validateCertificateChain: anOrderedCollection 	^X509Registry default validateCertificateChain: anOrderedCollection</body></methods><methods><class-id>Security.X509Certificate class</class-id> <category>asn1 framework</category><body package="X509" selector="addSMINodeOIDDescriptions">addSMINodeOIDDescriptions	self addSMINodeOIDDescriptions1.	self addSMINodeOIDDescriptions2.	self addSMINodeOIDDescriptions3.	self addSMINodeOIDDescriptions4.	self addSMINodeOIDDescriptions5</body><body package="X509" selector="addSMINodeOIDDescriptions1">addSMINodeOIDDescriptions1	( ASN1.SMINode root )		atPath: #( 0 )						setSymbol: 'itu-t';		atPath: #( 0 0 )						setSymbol: 'recommendation';		atPath: #( 0 1 )						setSymbol: 'question';		atPath: #( 0 2 )						setSymbol: 'administration';		atPath: #( 0 3 )						setSymbol: 'network-operator';		atPath: #( 0 4 )						setSymbol: 'identified-organization';		atPath: #( 0 5 )						setSymbol: 'r-recommendation';		atPath: #( 0 9 )						setSymbol: 'data';		atPath: #( 1 )						setSymbol: 'iso';		atPath: #( 1 0 )						setSymbol: 'standard';		atPath: #( 1 1 )						setSymbol: 'registration-authority';		atPath: #( 1 2 )						setSymbol: 'member-body';		atPath: #( 1 3 )						setSymbol: 'identified-organization';		atPath: #( 1 2 840 )					setSymbol: 'us';		atPath: #( 1 2 840 10040 )			setSymbol: 'x9-57';		atPath: #( 1 2 840 10040 4 )			setSymbol: 'x9algorithm';		atPath: #( 1 2 840 10040 4 1 )		setSymbol: 'dsa';		atPath: #( 1 2 840 10040 4 3 )		setSymbol: 'dsa-with-sha1';		atPath: #( 1 2 840 10046 )			setSymbol: 'ansi-x942';		atPath: #( 1 2 840 10046 2 )			setSymbol: 'number-types';		atPath: #( 1 2 840 10046 2 1 )		setSymbol: 'dhpublicnumber';		atPath: #( 1 3 6 )					setSymbol: 'dod';		atPath: #( 1 3 6 1 )					setSymbol: 'internet';		atPath: #( 1 3 6 1 1 )				setSymbol: 'directory';		atPath: #( 1 3 6 1 2 )				setSymbol: 'mgmt';		atPath: #( 1 3 6 1 3 )				setSymbol: 'experimental';		atPath: #( 1 3 6 1 4 )				setSymbol: 'private';		atPath: #( 1 3 6 1 5 )				setSymbol: 'security';		atPath: #( 1 3 6 1 6 )				setSymbol: 'snmpV2';		atPath: #( 1 3 6 1 7 )				setSymbol: 'mail';		atPath: #( 1 3 6 1 7 )				setSymbol: 'features';		atPath: #( 1 3 6 1 2 1 )				setSymbol: 'mib-2';		atPath: #( 1 3 6 1 2 2 )				setSymbol: 'pib';		atPath: #( 1 3 6 1 2 9 )				setSymbol: 'http';		atPath: #( 1 3 6 1 2 148 )			setSymbol: 'ipMIB';		atPath: #( 1 3 6 1 2 1 1 )				setSymbol: 'system';		atPath: #( 1 3 6 1 2 1 2 )				setSymbol: 'interface';		atPath: #( 1 3 6 1 2 1 3 )				setSymbol: 'at';		atPath: #( 1 3 6 1 2 1 4 )				setSymbol: 'ip';		atPath: #( 1 3 6 1 2 1 5 )				setSymbol: 'icmp';		atPath: #( 1 3 6 1 2 1 6 )				setSymbol: 'tcp';		atPath: #( 1 3 6 1 2 1 7 )				setSymbol: 'udp';		atPath: #( 1 3 6 1 2 1 8 )				setSymbol: 'egp';		atPath: #( 1 3 6 1 2 1 9 )				setSymbol: 'cmot';		atPath: #( 1 3 6 1 2 1 10 )			setSymbol: 'transmission';		atPath: #( 1 3 6 1 2 1 1 1 )			setSymbol: 'sysDescr';		atPath: #( 1 3 6 1 2 1 1 2 )			setSymbol: 'sysObjectID';		atPath: #( 1 3 6 1 2 1 1 3 )			setSymbol: 'sysUpTime';		atPath: #( 1 3 6 1 2 1 1 4 )			setSymbol: 'sysContact';		atPath: #( 1 3 6 1 2 1 1 5 )			setSymbol: 'sysName';		atPath: #( 1 3 6 1 2 1 1 6 )			setSymbol: 'sysLocation';		atPath: #( 1 3 6 1 2 1 1 7 )			setSymbol: 'sysServices';		atPath: #( 1 3 14 )					setSymbol: 'oiw';		atPath: #( 1 3 14 3 )					setSymbol: 'secsig';		atPath: #( 1 3 14 3 2 )				setSymbol: 'algorithms';		atPath: #( 1 3 14 3 2 12 )			setSymbol: 'dsa';		atPath: #( 1 3 14 3 2 26 ) 			setSymbol: 'hashAlgorithmIdentifier';		atPath: #( 1 3 14 3 2 27 )			setSymbol: 'dsaWithSHA1';		atPath: #( 2 )						setSymbol: 'joint-iso-itu-t';		atPath: #( 2 0 )						setSymbol: 'presentations';		atPath: #( 2 1 )						setSymbol: 'asn1';		atPath: #( 2 2 )						setSymbol: 'association-control';		atPath: #( 2 3 )						setSymbol: 'reliable-transfer';		atPath: #( 2 4 )						setSymbol: 'remote-operations';		atPath: #( 2 5 )						setSymbol: 'ds';		atPath: #( 2 5 4 )					setSymbol: 'attributeType';		atPath: #( 2 5 4 3 )					setSymbol: 'commonName';		atPath: #( 2 5 4 4 )					setSymbol: 'surname';		atPath: #( 2 5 4 5 )					setSymbol: 'serialNumber';		atPath: #( 2 5 4 6 )					setSymbol: 'countryName';		atPath: #( 2 5 4 7 )					setSymbol: 'localityName';		atPath: #( 2 5 4 8 )					setSymbol: 'stateOrProvinceName';		atPath: #( 2 5 4 9 )					setSymbol: 'streetAddress';		atPath: #( 2 5 4 10 )					setSymbol: 'organizationName';		atPath: #( 2 5 4 11 )					setSymbol: 'organizationalUnitName';		atPath: #( 2 5 4 12 )					setSymbol: 'title';		atPath: #( 2 5 4 13 )					setSymbol: 'description';		atPath: #( 2 5 4 41 )					setSymbol: 'name';		atPath: #( 2 5 4 42 )					setSymbol: 'givenName';		atPath: #( 2 5 4 43 )					setSymbol: 'initials';		atPath: #( 2 5 4 44 )					setSymbol: 'generationQualifier';		atPath: #( 2 5 4 46 )					setSymbol: 'dnQualifier';		atPath: #( 2 5 8 )					setSymbol: 'algorithm';		atPath: #( 2 5 8 1 )					setSymbol: 'encryptionAlgorithm';		atPath: #( 2 5 8 1 1 )				setSymbol: 'rsa';		atPath: #( 2 5 8 2 )					setSymbol: 'hashAlgorithm';		atPath: #( 2 5 8 3 )					setSymbol: 'signatureAlgorithm';		atPath: #( 2 5 29 )					setSymbol: 'ce';		atPath: #( 2 5 29 3 )					setSymbol: 'certificatePolicies';		atPath: #( 2 5 29 14 )				setSymbol: 'subjectKeyIdentifier';		atPath: #( 2 5 29 15 )				setSymbol: 'keyUsage';		atPath: #( 2 5 29 16 )				setSymbol: 'privateKeyUsagePeriod';		atPath: #( 2 5 29 17 )				setSymbol: 'subjectAltName';		atPath: #( 2 5 29 18 )				setSymbol: 'issuerAltName';		atPath: #( 2 5 29 19 )				setSymbol: 'basicConstraints';		atPath: #( 2 5 29 20 )				setSymbol: 'cRLNumber';		atPath: #( 2 5 29 21 )				setSymbol: 'reasonCode';		atPath: #( 2 5 29 23 )				setSymbol: 'instructionCode';		atPath: #( 2 5 29 24 )				setSymbol: 'invalidityDate';		atPath: #( 2 5 29 27 )				setSymbol: 'deltaCRLIndicator';		atPath: #( 2 5 29 28 )				setSymbol: 'issuingDistributionPoint';		atPath: #( 2 5 29 29 )				setSymbol: 'certificateIssuer';		atPath: #( 2 5 29 30 )				setSymbol: 'nameConstraints';		atPath: #( 2 5 29 31 )				setSymbol: 'cRLDistributionPoints';		atPath: #( 2 5 29 32 )				setSymbol: 'certificatePolicies';		atPath: #( 2 5 29 33 )				setSymbol: 'policyMappings';		atPath: #( 2 5 29 35 )				setSymbol: 'authorityKeyIdentifier';		atPath: #( 2 5 29 36 )				setSymbol: 'policyConstraints';		atPath: #( 2 5 29 37 )				setSymbol: 'extKeyUsage'.</body><body package="X509" selector="addSMINodeOIDDescriptions2">addSMINodeOIDDescriptions2	( ASN1.SMINode root )	atPath:  #(0) setSymbol:  'undef';	atPath:  #(1) setSymbol:  'Enterprises';	atPath:  #(1) setSymbol:  'iso';	atPath:  #(1 2) setSymbol:  'member_body';	atPath:  #(1 3) setSymbol:  'org';	atPath:  #(2 5) setSymbol:  'X500';	atPath:  #(1 3 6) setSymbol:  'dod';	atPath:  #(2 5 4) setSymbol:  'X509';	atPath:  #(2 5 8) setSymbol:  'X500algorithms';	atPath:  #(2 5 29) setSymbol:  'id_ce';	atPath:  #(1 2 840) setSymbol:  'ISO_US';	atPath:  #(1 3 6 1) setSymbol:  'iana';	atPath:  #(2 5 4 3) setSymbol:  'commonName';	atPath:  #(2 5 4 4) setSymbol:  'surname';	atPath:  #(2 5 4 5) setSymbol:  'serialNumber';	atPath:  #(2 5 4 6) setSymbol:  'countryName';	atPath:  #(2 5 4 7) setSymbol:  'localityName';	atPath:  #(2 5 4 8) setSymbol:  'stateOrProvinceName';	atPath:  #(2 5 4 10) setSymbol:  'organizationName';	atPath:  #(2 5 4 11) setSymbol:  'organizationalUnitName';	atPath:  #(2 5 4 12) setSymbol:  'title';	atPath:  #(2 5 4 13) setSymbol:  'description';	atPath:  #(2 5 4 41) setSymbol:  'name';	atPath:  #(2 5 4 42) setSymbol:  'givenName';	atPath:  #(2 5 4 43) setSymbol:  'initials';	atPath:  #(2 5 4 45) setSymbol:  'uniqueIdentifier';	atPath:  #(2 5 4 46) setSymbol:  'dnQualifier';	atPath:  #(2 5 29 14) setSymbol:  'subject_key_identifier';	atPath:  #(2 5 29 15) setSymbol:  'key_usage';	atPath:  #(2 5 29 16) setSymbol:  'private_key_usage_period';	atPath:  #(2 5 29 17) setSymbol:  'subject_alt_name';	atPath:  #(2 5 29 18) setSymbol:  'issuer_alt_name';	atPath:  #(2 5 29 19) setSymbol:  'basic_constraints';	atPath:  #(2 5 29 20) setSymbol:  'crl_number';	atPath:  #(2 5 29 21) setSymbol:  'crl_reason';	atPath:  #(2 5 29 24) setSymbol:  'invalidity_date';	atPath:  #(2 5 29 27) setSymbol:  'delta_crl';	atPath:  #(2 5 29 31) setSymbol:  'crl_distribution_points';	atPath:  #(2 5 29 32) setSymbol:  'certificate_policies';	atPath:  #(2 5 29 35) setSymbol:  'authority_key_identifier';	atPath:  #(2 5 29 37) setSymbol:  'ext_key_usage';	atPath:  #(1466 344) setSymbol:  'dcObject';	atPath:  #(1 3 6 1 1) setSymbol:  'Directory';	atPath:  #(1 3 6 1 2) setSymbol:  'Management';	atPath:  #(1 3 6 1 3) setSymbol:  'E perimental';	atPath:  #(1 3 6 1 4) setSymbol:  'Private';	atPath:  #(1 3 6 1 5) setSymbol:  'Security';	atPath:  #(1 3 6 1 6) setSymbol:  'SNMPv2';	atPath:  #(1 3 6 1 7) setSymbol:  'Mail';	atPath:  #(1 3 14 3 2) setSymbol:  'algorithm';	atPath:  #(2 5 8 1 1) setSymbol:  'rsa';	atPath:  #(2 5 8 3 100) setSymbol:  'mdc2WithRSA';	atPath:  #(2 5 8 3 101) setSymbol:  'mdc2';	atPath:  #(1 2 840 10040) setSymbol:  'X9_57';	atPath:  #(1 3 14 3 2 3) setSymbol:  'md5WithRSA';	atPath:  #(1 3 14 3 2 6) setSymbol:  'des_ecb';	atPath:  #(1 3 14 3 2 7) setSymbol:  'des_cbc';	atPath:  #(1 3 14 3 2 8) setSymbol:  'des_ofb64';	atPath:  #(1 3 14 3 2 9) setSymbol:  'des_cfb64';	atPath:  #(1 3 14 3 2 11) setSymbol:  'rsaSignature';	atPath:  #(1 3 14 3 2 12) setSymbol:  'dsa_2';	atPath:  #(1 3 14 3 2 13) setSymbol:  'dsaWithSHA';	atPath:  #(1 3 14 3 2 15) setSymbol:  'shaWithRSAEncryption';	atPath:  #(1 3 14 3 2 17) setSymbol:  'des_ede';	atPath:  #(1 3 14 3 2 18) setSymbol:  'sha';	atPath:  #(1 3 14 3 2 26) setSymbol:  'sha1';	atPath:  #(1 3 14 3 2 27) setSymbol:  'dsaWithSHA1_2';	atPath:  #(1 3 14 3 2 29) setSymbol:  'sha1WithRSA';	atPath:  #(1 3 36 3 2 1) setSymbol:  'ripemd160';	atPath:  #(1 3 101 1 4 1) setSymbol:  's net';	atPath:  #(1 1 1 1 666 1) setSymbol:  'rle_compression';	atPath:  #(1 1 1 1 666 2) setSymbol:  'zlib_compression';	atPath:  #(1 2 840 113549) setSymbol:  'rsadsi';	atPath:  #(1 2 840 10040 4) setSymbol:  'X9cm';	atPath:  #(1 3 6 1 5 5 7) setSymbol:  'id_pkix';	atPath:  #(1 3 36 3 3 1 2) setSymbol:  'ripemd160WithRSA';	atPath:  #(1 2 840 113549 1) setSymbol:  'pkcs';	atPath:  #(1 2 840 10040 4 1) setSymbol:  'dsaEncryption';	atPath:  #(1 2 840 10040 4 3) setSymbol:  'dsaWithSHA1';	atPath:  #(1 3 6 1 5 5 7 0) setSymbol:  'id_pki _mod';	atPath:  #(1 3 6 1 5 5 7 1) setSymbol:  'id_pe';	atPath:  #(1 3 6 1 5 5 7 2) setSymbol:  'id_qt';	atPath:  #(1 3 6 1 5 5 7 3) setSymbol:  'id_kp';	atPath:  #(1 3 6 1 5 5 7 4) setSymbol:  'id_it';	atPath:  #(1 3 6 1 5 5 7 5) setSymbol:  'id_pkip';	atPath:  #(1 3 6 1 5 5 7 6) setSymbol:  'id_alg';	atPath:  #(1 3 6 1 5 5 7 7) setSymbol:  'id_cmc';	atPath:  #(1 3 6 1 5 5 7 8) setSymbol:  'id_on';	atPath:  #(1 3 6 1 5 5 7 9) setSymbol:  'id_pda';	atPath:  #(1 3 6 1 5 5 7 10) setSymbol:  'id_aca';	atPath:  #(1 3 6 1 5 5 7 11) setSymbol:  'id_qcs';	atPath:  #(1 3 6 1 5 5 7 12) setSymbol:  'id_cct';	atPath:  #(1 3 6 1 5 5 7 48) setSymbol:  'id_ad';	atPath:  #(2 16 840 1 113730) setSymbol:  'netscape';	atPath:  #(1 2 840 113549 1 1) setSymbol:  'pkcs1';	atPath:  #(1 2 840 113549 1 3) setSymbol:  'pkcs3';	atPath:  #(1 2 840 113549 1 5) setSymbol:  'pkcs5';	atPath:  #(1 2 840 113549 1 7) setSymbol:  'pkcs7';	atPath:  #(1 2 840 113549 1 9) setSymbol:  'pkcs9';	atPath:  #(1 2 840 113549 2 2) setSymbol:  'md2';	atPath:  #(1 2 840 113549 2 4) setSymbol:  'md4';	atPath:  #(1 2 840 113549 2 5) setSymbol:  'md5';	atPath:  #(1 2 840 113549 2 7) setSymbol:  'hmacWithSHA1';	atPath:  #(1 2 840 113549 3 2) setSymbol:  'rc2_cbc';	atPath:  #(1 2 840 113549 3 4) setSymbol:  'rc4';	atPath:  #(1 2 840 113549 3 7) setSymbol:  'des_ede3_cbc';	atPath:  #(1 2 840 113549 3 8) setSymbol:  'rc5_cbc';	atPath:  #(1 3 6 1 5 5 7 0 1) setSymbol:  'id_pkix1_explicit_88';	atPath:  #(1 3 6 1 5 5 7 0 2) setSymbol:  'id_pkix1_implicit_88';	atPath:  #(1 3 6 1 5 5 7 0 3) setSymbol:  'id_pkix1_explicit_93';	atPath:  #(1 3 6 1 5 5 7 0 4) setSymbol:  'id_pkix1_implicit_93';	atPath:  #(1 3 6 1 5 5 7 0 5) setSymbol:  'id_mod_crmf';	atPath:  #(1 3 6 1 5 5 7 0 6) setSymbol:  'id_mod_cmc';	atPath:  #(1 3 6 1 5 5 7 0 7) setSymbol:  'id_mod_kea_profile_88';	atPath:  #(1 3 6 1 5 5 7 0 8) setSymbol:  'id_mod_kea_profile_93';	atPath:  #(1 3 6 1 5 5 7 0 9) setSymbol:  'id_mod_cmp';	atPath:  #(1 3 6 1 5 5 7 0 10) setSymbol:  'id_mod_qualified_cert_88'</body><body package="X509" selector="addSMINodeOIDDescriptions3">addSMINodeOIDDescriptions3	( ASN1.SMINode root )atPath: #(1 2 840 113549 1 9 16) setSymbol: 'SMIME';	atPath: #(1 2 840 113549 1 9 20) setSymbol: 'friendlyName';	atPath: #(1 2 840 113549 1 9 21) setSymbol: 'localKeyID';	atPath: #(1 3 6 1 4 1 3029 1 2) setSymbol: 'bf_cbc';	atPath: #(1 3 6 1 5 5 7 5 1 1) setSymbol: 'id_regCtrl_regToken';	atPath: #(1 3 6 1 5 5 7 5 1 2) setSymbol: 'id_regCtrl_authenticator';	atPath: #(1 3 6 1 5 5 7 5 1 3) setSymbol: 'id_regCtrl_pkiPublicationInfo';	atPath: #(1 3 6 1 5 5 7 5 1 4) setSymbol: 'id_regCtrl_pkiArchiveOptions';	atPath: #(1 3 6 1 5 5 7 5 1 5) setSymbol: 'id_regCtrl_oldCertID';	atPath: #(1 3 6 1 5 5 7 5 1 6) setSymbol: 'id_regCtrl_protocolEncrKey';	atPath: #(1 3 6 1 5 5 7 5 2 1) setSymbol: 'id_regInfo_utf8Pairs';	atPath: #(1 3 6 1 5 5 7 5 2 2) setSymbol: 'id_regInfo_certReq';	atPath: #(1 3 6 1 5 5 7 48 1 1) setSymbol: 'id_pki _OCSP_basic';	atPath: #(1 3 6 1 5 5 7 48 1 2) setSymbol: 'id_pki _OCSP_Nonce';	atPath: #(1 3 6 1 5 5 7 48 1 3) setSymbol: 'id_pki _OCSP_CrlID';	atPath: #(1 3 6 1 5 5 7 48 1 4) setSymbol: 'id_pki _OCSP_acceptableResponses';	atPath: #(1 3 6 1 5 5 7 48 1 5) setSymbol: 'id_pki _OCSP_noCheck';	atPath: #(1 3 6 1 5 5 7 48 1 6) setSymbol: 'id_pki _OCSP_archiveCutoff';	atPath: #(1 3 6 1 5 5 7 48 1 7) setSymbol: 'id_pki _OCSP_serviceLocator';	atPath: #(1 3 6 1 5 5 7 48 1 8) setSymbol: 'id_pki _OCSP_e tendedStatus';	atPath: #(1 3 6 1 5 5 7 48 1 9) setSymbol: 'id_pki _OCSP_valid';	atPath: #(1 3 6 1 5 5 7 48 1 10) setSymbol: 'id_pki _OCSP_path';	atPath: #(1 3 6 1 5 5 7 48 1 11) setSymbol: 'id_pki _OCSP_trustRoot';	atPath: #(2 16 840 1 113730 1 1) setSymbol: 'netscape_cert_type';	atPath: #(2 16 840 1 113730 1 2) setSymbol: 'netscape_base_url';	atPath: #(2 16 840 1 113730 1 3) setSymbol: 'netscape_revocation_url';	atPath: #(2 16 840 1 113730 1 4) setSymbol: 'netscape_ca_revocation_url';	atPath: #(2 16 840 1 113730 1 7) setSymbol: 'netscape_renewal_url';	atPath: #(2 16 840 1 113730 1 8) setSymbol: 'netscape_ca_policy_url';	atPath: #(2 16 840 1 113730 1 12) setSymbol: 'netscape_ssl_server_name';	atPath: #(2 16 840 1 113730 1 13) setSymbol: 'netscape_comment';	atPath: #(2 16 840 1 113730 2 5) setSymbol: 'netscape_cert_sequence';	atPath: #(2 16 840 1 113730 4 1) setSymbol: 'ns_sgc';	atPath: #(0 9 2342 19200300 100 1 25) setSymbol: 'domainComponent';	atPath: #(0 9 2342 19200300 100 4 13) setSymbol: 'Domain';	atPath: #(1 2 840 113549 1 9 16 0) setSymbol: 'id_smime_mod';	atPath: #(1 2 840 113549 1 9 16 1) setSymbol: 'id_smime_ct';	atPath: #(1 2 840 113549 1 9 16 2) setSymbol: 'id_smime_aa';	atPath: #(1 2 840 113549 1 9 16 3) setSymbol: 'id_smime_alg';	atPath: #(1 2 840 113549 1 9 16 4) setSymbol: 'id_smime_cd';	atPath: #(1 2 840 113549 1 9 16 5) setSymbol: 'id_smime_spq';	atPath: #(1 2 840 113549 1 9 16 6) setSymbol: 'id_smime_cti';	atPath: #(1 2 840 113549 1 9 22 1) setSymbol: ' 509Certificate';	atPath: #(1 2 840 113549 1 9 22 2) setSymbol: 'sdsiCertificate';	atPath: #(1 2 840 113549 1 9 23 1) setSymbol: ' 509Crl';	atPath: #(1 2 840 113549 1 12 1 1) setSymbol: 'pbe_WithSHA1And128BitRC4';	atPath: #(1 2 840 113549 1 12 1 2) setSymbol: 'pbe_WithSHA1And40BitRC4';	atPath: #(1 2 840 113549 1 12 1 3) setSymbol: 'pbe_WithSHA1And3_Key_TripleDES_CBC';	atPath: #(1 2 840 113549 1 12 1 4) setSymbol: 'pbe_WithSHA1And2_Key_TripleDES_CBC';	atPath: #(1 2 840 113549 1 12 1 5) setSymbol: 'pbe_WithSHA1And128BitRC2_CBC';	atPath: #(1 2 840 113549 1 12 1 6) setSymbol: 'pbe_WithSHA1And40BitRC2_CBC';	atPath: #(1 3 6 1 4 1 311 2 1 14) setSymbol: 'ms_e t_req';	atPath: #(1 3 6 1 4 1 311 2 1 21) setSymbol: 'ms_code_ind';	atPath: #(1 3 6 1 4 1 311 2 1 22) setSymbol: 'ms_code_com';	atPath: #(1 3 6 1 4 1 311 10 3 1) setSymbol: 'ms_ctl_sign';	atPath: #(1 3 6 1 4 1 311 10 3 3) setSymbol: 'ms_sgc';	atPath: #(1 3 6 1 4 1 311 10 3 4) setSymbol: 'ms_efs';	atPath: #(1 2 840 113549 1 9 16 0 1) setSymbol: 'id_smime_mod_cms';	atPath: #(1 2 840 113549 1 9 16 0 2) setSymbol: 'id_smime_mod_ess';	atPath: #(1 2 840 113549 1 9 16 0 3) setSymbol: 'id_smime_mod_oid';	atPath: #(1 2 840 113549 1 9 16 0 4) setSymbol: 'id_smime_mod_msg_v3';	atPath: #(1 2 840 113549 1 9 16 0 5) setSymbol: 'id_smime_mod_ets_eSignature_88';	atPath: #(1 2 840 113549 1 9 16 0 6) setSymbol: 'id_smime_mod_ets_eSignature_97';	atPath: #(1 2 840 113549 1 9 16 0 7) setSymbol: 'id_smime_mod_ets_eSigPolicy_88';	atPath: #(1 2 840 113549 1 9 16 0 8) setSymbol: 'id_smime_mod_ets_eSigPolicy_97';	atPath: #(1 2 840 113549 1 9 16 1 1) setSymbol: 'id_smime_ct_receipt';	atPath: #(1 2 840 113549 1 9 16 1 2) setSymbol: 'id_smime_ct_authData';	atPath: #(1 2 840 113549 1 9 16 1 3) setSymbol: 'id_smime_ct_publishCert';	atPath: #(1 2 840 113549 1 9 16 1 4) setSymbol: 'id_smime_ct_TSTInfo';	atPath: #(1 2 840 113549 1 9 16 1 5) setSymbol: 'id_smime_ct_TDTInfo';	atPath: #(1 2 840 113549 1 9 16 1 6) setSymbol: 'id_smime_ct_contentInfo';	atPath: #(1 2 840 113549 1 9 16 1 7) setSymbol: 'id_smime_ct_DVCSRequestData';	atPath: #(1 2 840 113549 1 9 16 1 8) setSymbol: 'id_smime_ct_DVCSResponseData';	atPath: #(1 2 840 113549 1 9 16 2 1) setSymbol: 'id_smime_aa_receiptRequest';	atPath: #(1 2 840 113549 1 9 16 2 2) setSymbol: 'id_smime_aa_securityLabel';	atPath: #(1 2 840 113549 1 9 16 2 3) setSymbol: 'id_smime_aa_mlE pandHistory';	atPath: #(1 2 840 113549 1 9 16 2 4) setSymbol: 'id_smime_aa_contentHint';	atPath: #(1 2 840 113549 1 9 16 2 5) setSymbol: 'id_smime_aa_msgSigDigest';	atPath: #(1 2 840 113549 1 9 16 2 6) setSymbol: 'id_smime_aa_encapContentType';	atPath: #(1 2 840 113549 1 9 16 2 7) setSymbol: 'id_smime_aa_contentIdentifier';	atPath: #(1 2 840 113549 1 9 16 2 8) setSymbol: 'id_smime_aa_macValue';	atPath: #(1 2 840 113549 1 9 16 2 9) setSymbol: 'id_smime_aa_equivalentLabels';	atPath: #(1 2 840 113549 1 9 16 2 10) setSymbol: 'id_smime_aa_contentReference';	atPath: #(1 2 840 113549 1 9 16 2 11) setSymbol: 'id_smime_aa_encrypKeyPref';	atPath: #(1 2 840 113549 1 9 16 2 12) setSymbol: 'id_smime_aa_signingCertificate';	atPath: #(1 2 840 113549 1 9 16 2 13) setSymbol: 'id_smime_aa_smimeEncryptCerts';	atPath: #(1 2 840 113549 1 9 16 2 14) setSymbol: 'id_smime_aa_timeStampToken';	atPath: #(1 2 840 113549 1 9 16 2 15) setSymbol: 'id_smime_aa_ets_sigPolicyId';	atPath: #(1 2 840 113549 1 9 16 2 16) setSymbol: 'id_smime_aa_ets_commitmentType';	atPath: #(1 2 840 113549 1 9 16 2 17) setSymbol: 'id_smime_aa_ets_signerLocation';	atPath: #(1 2 840 113549 1 9 16 2 18) setSymbol: 'id_smime_aa_ets_signerAttr';	atPath: #(1 2 840 113549 1 9 16 2 19) setSymbol: 'id_smime_aa_ets_otherSigCert';	atPath: #(1 2 840 113549 1 9 16 2 20) setSymbol: 'id_smime_aa_ets_contentTimestamp';	atPath: #(1 2 840 113549 1 9 16 2 21) setSymbol: 'id_smime_aa_ets_CertificateRefs';	atPath: #(1 2 840 113549 1 9 16 2 22) setSymbol: 'id_smime_aa_ets_RevocationRefs';	atPath: #(1 2 840 113549 1 9 16 2 23) setSymbol: 'id_smime_aa_ets_certValues';	atPath: #(1 2 840 113549 1 9 16 2 24) setSymbol: 'id_smime_aa_ets_revocationValues';	atPath: #(1 2 840 113549 1 9 16 2 25) setSymbol: 'id_smime_aa_ets_escTimeStamp';	atPath: #(1 2 840 113549 1 9 16 2 26) setSymbol: 'id_smime_aa_ets_certCRLTimestamp';	atPath: #(1 2 840 113549 1 9 16 2 27) setSymbol: 'id_smime_aa_ets_archiveTimeStamp';	atPath: #(1 2 840 113549 1 9 16 2 28) setSymbol: 'id_smime_aa_signatureType';	atPath: #(1 2 840 113549 1 9 16 2 29) setSymbol: 'id_smime_aa_dvcs_dvc';	atPath: #(1 2 840 113549 1 9 16 3 1) setSymbol: 'id_smime_alg_ESDHwith3DES';	atPath: #(1 2 840 113549 1 9 16 3 2) setSymbol: 'id_smime_alg_ESDHwithRC2';	atPath: #(1 2 840 113549 1 9 16 3 3) setSymbol: 'id_smime_alg_3DESwrap';	atPath: #(1 2 840 113549 1 9 16 3 4) setSymbol: 'id_smime_alg_RC2wrap';	atPath: #(1 2 840 113549 1 9 16 3 5) setSymbol: 'id_smime_alg_ESDH';	atPath: #(1 2 840 113549 1 9 16 3 6) setSymbol: 'id_smime_alg_CMS3DESwrap';	atPath: #(1 2 840 113549 1 9 16 3 7) setSymbol: 'id_smime_alg_CMSRC2wrap';	atPath: #(1 2 840 113549 1 9 16 4 1) setSymbol: 'id_smime_cd_ldap';	atPath: #(1 2 840 113549 1 9 16 5 1) setSymbol: 'id_smime_spq_ets_sqt_uri';	atPath: #(1 2 840 113549 1 9 16 5 2) setSymbol: 'id_smime_spq_ets_sqt_unotice';	atPath: #(1 2 840 113549 1 9 16 6 1) setSymbol: 'id_smime_cti_ets_proofOfOrigin';	atPath: #(1 2 840 113549 1 9 16 6 2) setSymbol: 'id_smime_cti_ets_proofOfReceipt';	atPath: #(1 2 840 113549 1 9 16 6 3) setSymbol: 'id_smime_cti_ets_proofOfDelivery';	atPath: #(1 2 840 113549 1 9 16 6 4) setSymbol: 'id_smime_cti_ets_proofOfSender 1';	atPath: #(1 2 840 113549 1 9 16 6 5) setSymbol: 'id_smime_cti_ets_proofOfApproval';	atPath: #(1 2 840 113549 1 9 16 6 6) setSymbol: 'id_smime_cti_ets_proofOfCreation';	atPath: #(1 2 840 113549 1 12 10 1 1) setSymbol: 'keyBag';	atPath: #(1 2 840 113549 1 12 10 1 2) setSymbol: 'pkcs8ShroudedKeyBag';	atPath: #(1 2 840 113549 1 12 10 1 3) setSymbol: 'certBag';	atPath: #(1 2 840 113549 1 12 10 1 4) setSymbol: 'crlBag';	atPath: #(1 2 840 113549 1 12 10 1 5) setSymbol: 'secretBag';	atPath: #(1 2 840 113549 1 12 10 1 6) setSymbol: 'safeContentsBag';	atPath: #(1 3 6 1 4 1 188 7 1 1 2) setSymbol: 'idea_cbc'</body><body package="X509" selector="addSMINodeOIDDescriptions4">addSMINodeOIDDescriptions4	( ASN1.SMINode root )	atPath:#( 1 3 6 1 5 5 7 0 11) setSymbol:  'id_mod_qualified_cert_93';	atPath:#( 1 3 6 1 5 5 7 0 12) setSymbol:  'id_mod_attribute_cert';	atPath:#( 1 3 6 1 5 5 7 0 13) setSymbol:  'id_mod_timestamp_protocol';	atPath:#( 1 3 6 1 5 5 7 0 14) setSymbol:  'id_mod_ocsp';	atPath:#( 1 3 6 1 5 5 7 0 15) setSymbol:  'id_mod_dvcs';	atPath:#( 1 3 6 1 5 5 7 0 16) setSymbol:  'id_mod_cmp2000';	atPath:#( 1 3 6 1 5 5 7 1 1) setSymbol:  'info_access';	atPath:#( 1 3 6 1 5 5 7 1 2) setSymbol:  'biometricInfo';	atPath:#( 1 3 6 1 5 5 7 1 3) setSymbol:  'qcStatements';	atPath:#( 1 3 6 1 5 5 7 1 4) setSymbol:  'ac_auditEntity';	atPath:#( 1 3 6 1 5 5 7 1 5) setSymbol:  'ac_targeting';	atPath:#( 1 3 6 1 5 5 7 1 6) setSymbol:  'aaControls';	atPath:#( 1 3 6 1 5 5 7 1 7) setSymbol:  'sbqp_ipAddrBlock';	atPath:#( 1 3 6 1 5 5 7 1 8) setSymbol:  'sbqp_autonomousSysNum';	atPath:#( 1 3 6 1 5 5 7 1 9) setSymbol:  'sbqp_routerIdentifier';	atPath:#( 1 3 6 1 5 5 7 2 1) setSymbol:  'id_qt_cps';	atPath:#( 1 3 6 1 5 5 7 2 2) setSymbol:  'id_qt_unotice';	atPath:#( 1 3 6 1 5 5 7 2 3) setSymbol:  'te tNotice';	atPath:#( 1 3 6 1 5 5 7 3 1) setSymbol:  'server_auth';	atPath:#( 1 3 6 1 5 5 7 3 2) setSymbol:  'client_auth';	atPath:#( 1 3 6 1 5 5 7 3 3) setSymbol:  'code_sign';	atPath:#( 1 3 6 1 5 5 7 3 4) setSymbol:  'email_protect';	atPath:#( 1 3 6 1 5 5 7 3 5) setSymbol:  'ipsecEndSystem';	atPath:#( 1 3 6 1 5 5 7 3 6) setSymbol:  'ipsecTunnel';	atPath:#( 1 3 6 1 5 5 7 3 7) setSymbol:  'ipsecUser';	atPath:#( 1 3 6 1 5 5 7 3 8) setSymbol:  'time_stamp';	atPath:#( 1 3 6 1 5 5 7 3 9) setSymbol:  'OCSP_sign';	atPath:#( 1 3 6 1 5 5 7 3 10) setSymbol:  'dvcs';	atPath:#( 1 3 6 1 5 5 7 4 1) setSymbol:  'id_it_caProtEncCert';	atPath:#( 1 3 6 1 5 5 7 4 2) setSymbol:  'id_it_signKeyPairTypes';	atPath:#( 1 3 6 1 5 5 7 4 3) setSymbol:  'id_it_encKeyPairTypes';	atPath:#( 1 3 6 1 5 5 7 4 4) setSymbol:  'id_it_preferredSymmAlg';	atPath:#( 1 3 6 1 5 5 7 4 5) setSymbol:  'id_it_caKeyUpdateInfo';	atPath:#( 1 3 6 1 5 5 7 4 6) setSymbol:  'id_it_currentCRL';	atPath:#( 1 3 6 1 5 5 7 4 7) setSymbol:  'id_it_unsupportedOIDs';	atPath:#( 1 3 6 1 5 5 7 4 8) setSymbol:  'id_it_subscriptionRequest';	atPath:#( 1 3 6 1 5 5 7 4 9) setSymbol:  'id_it_subscriptionResponse';	atPath:#( 1 3 6 1 5 5 7 4 10) setSymbol:  'id_it_keyPairParamReq';	atPath:#( 1 3 6 1 5 5 7 4 11) setSymbol:  'id_it_keyPairParamRep';	atPath:#( 1 3 6 1 5 5 7 4 12) setSymbol:  'id_it_revPassphrase';	atPath:#( 1 3 6 1 5 5 7 4 13) setSymbol:  'id_it_implicitConfirm';	atPath:#( 1 3 6 1 5 5 7 4 14) setSymbol:  'id_it_confirmWaitTime';	atPath:#( 1 3 6 1 5 5 7 4 15) setSymbol:  'id_it_origPKIMessage';	atPath:#( 1 3 6 1 5 5 7 5 1) setSymbol:  'id_regCtrl';	atPath:#( 1 3 6 1 5 5 7 5 2) setSymbol:  'id_regInfo';	atPath:#( 1 3 6 1 5 5 7 6 1) setSymbol:  'id_alg_des40';	atPath:#( 1 3 6 1 5 5 7 6 2) setSymbol:  'id_alg_noSignature';	atPath:#( 1 3 6 1 5 5 7 6 3) setSymbol:  'id_alg_dh_sig_hmac_sha1';	atPath:#( 1 3 6 1 5 5 7 6 4) setSymbol:  'id_alg_dh_pop';	atPath:#( 1 3 6 1 5 5 7 7 1) setSymbol:  'id_cmc_statusInfo';	atPath:#( 1 3 6 1 5 5 7 7 2) setSymbol:  'id_cmc_identification';	atPath:#( 1 3 6 1 5 5 7 7 3) setSymbol:  'id_cmc_identityProof';	atPath:#( 1 3 6 1 5 5 7 7 4) setSymbol:  'id_cmc_dataReturn';	atPath:#( 1 3 6 1 5 5 7 7 5) setSymbol:  'id_cmc_transactionId';	atPath:#( 1 3 6 1 5 5 7 7 6) setSymbol:  'id_cmc_senderNonce';	atPath:#( 1 3 6 1 5 5 7 7 7) setSymbol:  'id_cmc_recipientNonce';	atPath:#( 1 3 6 1 5 5 7 7 8) setSymbol:  'id_cmc_addE tensions';	atPath:#( 1 3 6 1 5 5 7 7 9) setSymbol:  'id_cmc_encryptedPOP';	atPath:#( 1 3 6 1 5 5 7 7 10) setSymbol:  'id_cmc_decryptedPOP';	atPath:#( 1 3 6 1 5 5 7 7 11) setSymbol:  'id_cmc_lraPOPWitness';	atPath:#( 1 3 6 1 5 5 7 7 15) setSymbol:  'id_cmc_getCert';	atPath:#( 1 3 6 1 5 5 7 7 16) setSymbol:  'id_cmc_getCRL';	atPath:#( 1 3 6 1 5 5 7 7 17) setSymbol:  'id_cmc_revokeRequest';	atPath:#( 1 3 6 1 5 5 7 7 18) setSymbol:  'id_cmc_regInfo';	atPath:#( 1 3 6 1 5 5 7 7 19) setSymbol:  'id_cmc_responseInfo';	atPath:#( 1 3 6 1 5 5 7 7 21) setSymbol:  'id_cmc_queryPending';	atPath:#( 1 3 6 1 5 5 7 7 22) setSymbol:  'id_cmc_popLinkRandom';	atPath:#( 1 3 6 1 5 5 7 7 23) setSymbol:  'id_cmc_popLinkWitness';	atPath:#( 1 3 6 1 5 5 7 7 24) setSymbol:  'id_cmc_confirmCertAcceptance';	atPath:#( 1 3 6 1 5 5 7 8 1) setSymbol:  'id_on_personalData';	atPath:#( 1 3 6 1 5 5 7 9 1) setSymbol:  'id_pda_dateOfBirth';	atPath:#( 1 3 6 1 5 5 7 9 2) setSymbol:  'id_pda_placeOfBirth';	atPath:#( 1 3 6 1 5 5 7 9 3) setSymbol:  'id_pda_pseudonym';	atPath:#( 1 3 6 1 5 5 7 9 4) setSymbol:  'id_pda_gender';	atPath:#( 1 3 6 1 5 5 7 9 5) setSymbol:  'id_pda_countryOfCitizenship';	atPath:#( 1 3 6 1 5 5 7 9 6) setSymbol:  'id_pda_countryOfResidence';	atPath:#( 1 3 6 1 5 5 7 10 1) setSymbol:  'id_aca_authenticationInfo';	atPath:#( 1 3 6 1 5 5 7 10 2) setSymbol:  'id_aca_accessIdentity';	atPath:#( 1 3 6 1 5 5 7 10 3) setSymbol:  'id_aca_chargingIdentity';	atPath:#( 1 3 6 1 5 5 7 10 4) setSymbol:  'id_aca_group';	atPath:#( 1 3 6 1 5 5 7 10 5) setSymbol:  'id_aca_role';	atPath:#( 1 3 6 1 5 5 7 11 1) setSymbol:  'id_qcs_pki QCSynta _v1';	atPath:#( 1 3 6 1 5 5 7 12 1) setSymbol:  'id_cct_crs';	atPath:#( 1 3 6 1 5 5 7 12 2) setSymbol:  'id_cct_PKIData';	atPath:#( 1 3 6 1 5 5 7 12 3) setSymbol:  'id_cct_PKIResponse';	atPath:#( 1 3 6 1 5 5 7 48 1) setSymbol:  'ad_OCSP';	atPath:#( 1 3 6 1 5 5 7 48 2) setSymbol:  'ad_ca_issuers';	atPath:#( 1 3 6 1 5 5 7 48 3) setSymbol:  'ad_timeStamping';	atPath:#( 1 3 6 1 5 5 7 48 4) setSymbol:  'ad_dvcs';	atPath:#( 2 16 840 1 113730 1) setSymbol:  'netscape_cert_e tension';	atPath:#( 2 16 840 1 113730 2) setSymbol:  'netscape_data_type';	atPath:#( 1 2 840 113533 7 66 10) setSymbol:  'cast5_cbc';	atPath:#( 1 2 840 113533 7 66 12) setSymbol:  'pbeWithMD5AndCast5_CBC';	atPath:#( 1 2 840 113549 1 1 1) setSymbol:  'rsaEncryption';	atPath:#( 1 2 840 113549 1 1 2) setSymbol:  'md2WithRSAEncryption';	atPath:#( 1 2 840 113549 1 1 4) setSymbol:  'md5WithRSAEncryption';	atPath:#( 1 2 840 113549 1 1 5) setSymbol:  'sha1WithRSAEncryption';	atPath:#( 1 2 840 113549 1 3 1) setSymbol:  'dhKeyAgreement';	atPath:#( 1 2 840 113549 1 5 1) setSymbol:  'pbeWithMD2AndDES_CBC';	atPath:#( 1 2 840 113549 1 5 3) setSymbol:  'pbeWithMD5AndDES_CBC';	atPath:#( 1 2 840 113549 1 5 4) setSymbol:  'pbeWithMD2AndRC2_CBC';	atPath:#( 1 2 840 113549 1 5 6) setSymbol:  'pbeWithMD5AndRC2_CBC';	atPath:#( 1 2 840 113549 1 5 10) setSymbol:  'pbeWithSHA1AndDES_CBC';	atPath:#( 1 2 840 113549 1 5 11) setSymbol:  'pbeWithSHA1AndRC2_CBC';	atPath:#( 1 2 840 113549 1 5 12) setSymbol:  'id_pbkdf2';	atPath:#( 1 2 840 113549 1 5 13) setSymbol:  'pbes2';	atPath:#( 1 2 840 113549 1 5 14) setSymbol:  'pbmac1';	atPath:#( 1 2 840 113549 1 7 1) setSymbol:  'pkcs7_data';	atPath:#( 1 2 840 113549 1 7 2) setSymbol:  'pkcs7_signed';	atPath:#( 1 2 840 113549 1 7 3) setSymbol:  'pkcs7_enveloped';	atPath:#( 1 2 840 113549 1 7 4) setSymbol:  'pkcs7_signedAndEnveloped';	atPath:#( 1 2 840 113549 1 7 5) setSymbol:  'pkcs7_digest';	atPath:#( 1 2 840 113549 1 7 6) setSymbol:  'pkcs7_encrypted';	atPath:#( 1 2 840 113549 1 9 1) setSymbol:  'pkcs9_emailAddress';	atPath:#( 1 2 840 113549 1 9 2) setSymbol:  'pkcs9_unstructuredName';	atPath:#( 1 2 840 113549 1 9 3) setSymbol:  'pkcs9_contentType';	atPath:#( 1 2 840 113549 1 9 4) setSymbol:  'pkcs9_messageDigest';	atPath:#( 1 2 840 113549 1 9 5) setSymbol:  'pkcs9_signingTime';	atPath:#( 1 2 840 113549 1 9 6) setSymbol:  'pkcs9_countersignature';	atPath:#( 1 2 840 113549 1 9 7) setSymbol:  'pkcs9_challengePassword';	atPath:#( 1 2 840 113549 1 9 8) setSymbol:  'pkcs9_unstructuredAddress';	atPath:#( 1 2 840 113549 1 9 9) setSymbol:  'pkcs9_e tCertAttributes';	atPath:#( 1 2 840 113549 1 9 14) setSymbol:  'e t_req';	atPath:#( 1 2 840 113549 1 9 15) setSymbol:  'SMIMECapabilities'</body><body package="X509" selector="addSMINodeOIDDescriptions5">addSMINodeOIDDescriptions5	(ASN1.SMINode root)		atPath: #(1 3 14 3 2 26) setSymbol: 'id-sha1';		atPath: #(1 2 840 113549 2 2) setSymbol: 'md2';		atPath: #(1 2 840 113549 2 5) setSymbol: 'md5';		atPath: #(1 2 840 10046 2 1) setSymbol: 'Diffie-Hellman';		"atPath: #(1 2 840 10040 4 1) setSymbol: 'id-dsa';"		atPath: #(1 2 840 10040 4 3) setSymbol: 'id-dsa-with-sha1';		atPath: #(2 2 840 10040 2 1) setSymbol: 'id-holdinstruction-none';		atPath: #(2 2 840 10040 2 2) setSymbol: 'id-holdinstruction-callissuer';		atPath: #(2 2 840 10040 2 3) setSymbol: 'id-holdinstruction-reject';		atPath: #(2 5 4 3) setSymbol: 'commonName';		atPath: #(2 5 4 4) setSymbol: 'surname';		atPath: #(2 5 4 6) setSymbol: 'countryName';		atPath: #(2 5 4 7) setSymbol: 'localityName';		atPath: #(2 5 4 8) setSymbol: 'stateOrProvinceName';		atPath: #(2 5 4 10) setSymbol: 'organizationName';		atPath: #(2 5 4 11) setSymbol: 'organizationalUnitName';		atPath: #(2 5 4 12) setSymbol: 'title';		atPath: #(2 5 4 41) setSymbol: 'name';		atPath: #(2 5 4 42) setSymbol: 'givenName';		atPath: #(2 5 4 43) setSymbol: 'initials';		atPath: #(2 5 4 44) setSymbol: 'generationQualifier';		atPath: #(2 5 4 46) setSymbol: 'dnQualifier';		atPath: #(1 2 840 113533 7 65 0) setSymbol: 'entrustVersion';		atPath: #(1 2 840 113549 1 1 1) setSymbol: 'rsaEncryption';		atPath: #(1 2 840 113549 1 1 2) setSymbol: 'md2WithRSAEncryption';		atPath: #(1 2 840 113549 1 1 4) setSymbol: 'md5WithRSAEncryption';		atPath: #(1 2 840 113549 1 1 5) setSymbol: 'sha1WithRSAEncryption';		atPath: #(1 2 840 113549 1 9 1) setSymbol: 'e-mailAddress';		atPath: #(1 2 840 113549 1 9 3) setSymbol: 'contentType';		atPath: #(1 2 840 113549 1 9 4) setSymbol: 'messageDigest';		atPath: #(1 2 840 113549 1 9 6) setSymbol: 'counterSignature';		atPath: #(1 2 840 113549 1 9 7) setSymbol: 'challengePassword';		atPath: #(1 3 14 3 2 12) setSymbol: 'dsa';		atPath: #(1 3 14 3 2 27) setSymbol: 'dsa With SHA1';		atPath: #(2 16 840 1 113730 1 1) setSymbol: 'netscapeCertificateType';		atPath: #(2 16 840 1 113730 1 12) setSymbol: 'SslServerName';		atPath: #(2 16 840 1 113730 1 13) setSymbol: 'netscapeCertificateComment';		atPath: #(2 16 840 1 113730 1 2) setSymbol: 'BaseURL';		atPath: #(2 16 840 1 113730 1 3) setSymbol: 'RevocationURL';		atPath: #(2 16 840 1 113730 1 4) setSymbol: 'CARevocationURL';		atPath: #(2 16 840 1 113730 1 7) setSymbol: 'renewalURL';		atPath: #(2 16 840 1 113730 1 8) setSymbol: 'netscapeCaPolicyURL';		atPath: #(2 5 29 14) setSymbol: 'subjectKeyIdentifier';		atPath: #(2 5 29 15) setSymbol: 'keyUsage';		atPath: #(2 5 29 16) setSymbol: 'privateKeyUsagePeriod';		atPath: #(2 5 29 17) setSymbol: 'subjectAlternativeName';		atPath: #(2 5 29 18) setSymbol: 'issuerAlternativeName';		atPath: #(2 5 29 19) setSymbol: 'basicConstraints';		atPath: #(2 5 29 20) setSymbol: 'cRLNumber';		atPath: #(2 5 29 21) setSymbol: 'reasonCode';		atPath: #(2 5 29 23) setSymbol: 'holdInstructionCode';		atPath: #(2 5 29 24) setSymbol: 'invalidityDate';		atPath: #(2 5 29 27) setSymbol: 'deltaCRLIndicator';		atPath: #(2 5 29 28) setSymbol: 'issuingDistributionPoint';		atPath: #(2 5 29 29) setSymbol: 'certificateIssuer';		atPath: #(2 5 29 3) setSymbol: 'certificate policies - old';		atPath: #(2 5 29 30) setSymbol: 'nameConstraints';		atPath: #(2 5 29 31) setSymbol: 'cRLDistributionPoints';		atPath: #(2 5 29 32) setSymbol: 'certificatePolicies';		atPath: #(2 5 29 33) setSymbol: 'policyMappings';		atPath: #(2 5 29 35) setSymbol: 'authorityKeyIdentifier';		atPath: #(2 5 29 36) setSymbol: 'policyConstraints';		atPath: #(2 5 4 10) setSymbol: 'O';		atPath: #(2 5 4 11) setSymbol: 'OU';		atPath: #(2 5 4 13) setSymbol: '??';		atPath: #(2 5 4 3) setSymbol: 'CN';		atPath: #(2 5 4 6) setSymbol: 'C';		atPath: #(2 5 4 7) setSymbol: 'L';		atPath: #(2 5 4 8) setSymbol: 'S';		atPath: #(2 5 8 1 1) setSymbol: 'rsa'</body><body package="X509" selector="initAlgorithmIdentifier">initAlgorithmIdentifier	"AlgorithmIdentifier  ::=  SEQUENCE  {		algorithm               OBJECT IDENTIFIER,		parameters              ANY DEFINED BY algorithm OPTIONAL  }"	ASN1.Asn1TypeSEQUENCE		register:		#AlgorithmIdentifier		constraint:	ASN1.Asn1ConstraintNull default		elements:	( OrderedCollection						with: ( ASN1.Asn1Element								symbol: #algorithm								type: ( ASN1.Asn1Type findTypeNamed: #'OBJECT IDENTIFIER' ) )						with: ( ASN1.Asn1Element								optional: true								symbol: #parameters								type: ( ASN1.Asn1Type findTypeNamed: #ANY ) ) ).</body><body package="X509" selector="initAsn1Types">initAsn1Types	" order here is important we work from the base types up to the higher ones"	"extentions are different in that each extension has to be built once the extensions are read in and then we parse out the raw values to see if we recognized the extension present. so those types can be built last since the collection they are in it is not known beforhand as to what they are"	self initVersion.	self initSerialNumber.	self initTime.	self initValidity.  	self initUniqueIdentifier.	self initExtension.	self initExtensions.	self initAlgorithmIdentifier.	self initSubjectPublicKeyInfo.	self initAttributeType.	self initAttributeValue.	self initAttributeTypeAndValue.	self initRelativeDistinguishedName.	self initRDNSequence.	self initName.	self initTBSCertificate.	self initCertificate.	self initRSAPublicKeyTypes.	self initDSSSignatureType.	self initDSAPublicKey.	self initDSAPrivateKey.	self initDSSParmsType.	X509Extension allSubclasses do: [ :class | class initAsn1Types ]</body><body package="X509" selector="initAttributeType">initAttributeType	"AttributeType ::= OBJECT IDENTIFIER"	ASN1.Asn1TypeOBJECT_IDENTIFIER register: #AttributeType.</body><body package="X509" selector="initAttributeTypeAndValue">initAttributeTypeAndValue	"AttributeTypeAndValue ::= SEQUENCE {		type     AttributeType,		value    AttributeValue }"ASN1.Asn1TypeSEQUENCE		register:		#AttributeTypeAndValue		constraint:	ASN1.Asn1ConstraintNull default		elements:	( OrderedCollection						with: ( ASN1.Asn1Element								symbol: #type								type: ( ASN1.Asn1Type findTypeNamed: #AttributeType ) )						with: ( ASN1.Asn1Element								symbol: #value								type: ( ASN1.Asn1Type findTypeNamed: #AttributeValue ) ) ).</body><body package="X509" selector="initAttributeValue">initAttributeValue	"AttributeValue ::= ANY DEFINED BY AttributeType"	ASN1.Asn1TypeANY register: #AttributeValue.</body><body package="X509" selector="initBasicConstraints">initBasicConstraints	"BasicConstraintsSyntax ::= SEQUENCE {	cA	BOOLEAN DEFAULT FALSE,	pathLenConstraint INTEGER (0..MAX) OPTIONAL}"ASN1.Asn1TypeBOOLEAN register: #CA.ASN1.Asn1TypeINTEGER register: #PathLenConstraint .ASN1.Asn1TypeSEQUENCE		register:		#BasicConstraints		constraint:	ASN1.Asn1ConstraintNull default		elements:	( OrderedCollection						with: ( ASN1.Asn1Element								default: false								symbol: #ca								type: ( ASN1.Asn1Type findTypeNamed: #CA ) )						with: ( ASN1.Asn1Element								optional: true								symbol: #pathLenConstraint 								type: ( ASN1.Asn1Type findTypeNamed: #PathLenConstraint ) ) ).</body><body package="X509" selector="initCertificate">initCertificate	"Certificate  ::=  SEQUENCE  {		tbsCertificate       TBSCertificate,		signatureAlgorithm   AlgorithmIdentifier,		signatureValue       BIT STRING  }"	ASN1.Asn1TypeSEQUENCE		register:		#Certificate		constraint:	ASN1.Asn1ConstraintNull default		elements:	( OrderedCollection						with: ( ASN1.Asn1Element								symbol: #tbsCertificate								type: ( ASN1.Asn1Type findTypeNamed: #TBSCertificate ) )						with: ( ASN1.Asn1Element								symbol: #signatureAlgorithm								type: ( ASN1.Asn1Type findTypeNamed: #AlgorithmIdentifier ) )						with: ( ASN1.Asn1Element								symbol: #signatureValue								type: ( ASN1.Asn1Type findTypeNamed: #'BIT STRING' ) ) ).</body><body package="X509" selector="initDSAPrivateKey">initDSAPrivateKey" See the man page for the dsa command in the openssl suite, option -inform	DSAPrivateKey  ::=  SEQUENCE  {		version	INTEGER, -- curently zero		p		INTEGER,		q		INTEGER,		g		INTEGER ,		y		INTEGER,		x		INTEGER  }"	| collection |	ASN1.Asn1TypeINTEGER register: #DSS_version_value.	ASN1.Asn1TypeINTEGER register: #DSS_P_value.	ASN1.Asn1TypeINTEGER register: #DSS_Q_value.	ASN1.Asn1TypeINTEGER register: #DSS_G_value.	ASN1.Asn1TypeINTEGER register: #DSS_Y_value.	ASN1.Asn1TypeINTEGER register: #DSS_X_value.	collection := OrderedCollection new.	collection add: (ASN1.Asn1Element symbol: #version				type: (ASN1.Asn1Type findTypeNamed: #DSS_version_value)).	collection add: (ASN1.Asn1Element symbol: #p				type: (ASN1.Asn1Type findTypeNamed: #DSS_P_value)).	collection add: (ASN1.Asn1Element symbol: #q				type: (ASN1.Asn1Type findTypeNamed: #DSS_Q_value)).	collection add: (ASN1.Asn1Element symbol: #g				type: (ASN1.Asn1Type findTypeNamed: #DSS_G_value)).	collection add: (ASN1.Asn1Element symbol: #y				type: (ASN1.Asn1Type findTypeNamed: #DSS_Y_value)).	collection add: (ASN1.Asn1Element symbol: #x				type: (ASN1.Asn1Type findTypeNamed: #DSS_X_value)).	ASN1.Asn1TypeSEQUENCE 		register: #DSAPrivateKey		constraint: ASN1.Asn1ConstraintNull default		elements: collection</body><body package="X509" selector="initDSAPublicKey">initDSAPublicKey	"DSAPublicKey ::= INTEGER -- public key, Y"	| |	ASN1.Asn1TypeINTEGER register: #DSA_PublicKey.</body><body package="X509" selector="initDSSParmsType">initDSSParmsType	"        Dss-Parms  ::=  SEQUENCE  {            p             INTEGER,            q             INTEGER,            g             INTEGER  }"	| collection |"	ASN1.Asn1TypeINTEGER register: #DSS_P_value.	ASN1.Asn1TypeINTEGER register: #DSS_Q_value.	ASN1.Asn1TypeINTEGER register: #DSS_G_value.""Since the private Key was created before this is called the above types exist already"	collection := OrderedCollection new.	collection add: (ASN1.Asn1Element symbol: #p				type: (ASN1.Asn1Type findTypeNamed: #DSS_P_value)).	collection add: (ASN1.Asn1Element symbol: #q				type: (ASN1.Asn1Type findTypeNamed: #DSS_Q_value)).	collection add: (ASN1.Asn1Element symbol: #g				type: (ASN1.Asn1Type findTypeNamed: #DSS_G_value)).	ASN1.Asn1TypeSEQUENCE 		register: #DSSParms		constraint: ASN1.Asn1ConstraintNull default		elements: collection</body><body package="X509" selector="initDSSSignatureType">initDSSSignatureType	"Dss-Sig-Value  ::=  SEQUENCE  {                   r       INTEGER,                   s       INTEGER  }"	| collection |	ASN1.Asn1TypeINTEGER register: #DSS_R_value.	ASN1.Asn1TypeINTEGER register: #DSS_S_value.	collection := OrderedCollection new.	collection add: (ASN1.Asn1Element symbol: #r				type: (ASN1.Asn1Type findTypeNamed: #DSS_R_value)).	collection add: (ASN1.Asn1Element symbol: #s				type: (ASN1.Asn1Type findTypeNamed: #DSS_S_value)).	ASN1.Asn1TypeSEQUENCE 		register: #DSSSignature		constraint: ASN1.Asn1ConstraintNull default		elements: collection</body><body package="X509" selector="initExtension">initExtension	"Extension  ::=  SEQUENCE  {		extnID      OBJECT IDENTIFIER,		critical    BOOLEAN DEFAULT FALSE,		extnValue   OCTET STRING  }"	ASN1.Asn1TypeSEQUENCE		register:		#Extension		constraint:	ASN1.Asn1ConstraintNull default		elements:	( OrderedCollection						with: ( ASN1.Asn1Element								symbol: #extnID								type: ( ASN1.Asn1Type findTypeNamed: #'OBJECT IDENTIFIER' ) )						with: ( ASN1.Asn1Element								default: false								symbol: #critical								type: ( ASN1.Asn1Type findTypeNamed: #BOOLEAN ) )						with: ( ASN1.Asn1Element								symbol: #extnValue								type: ( ASN1.Asn1Type findTypeNamed: #'OCTET STRING' ) ) ).</body><body package="X509" selector="initExtensions">initExtensions	"Extensions  ::=  SEQUENCE SIZE (1..MAX) OF Extension"	ASN1.Asn1TypeSEQUENCE_OF		register: #Extensions		constraint: ( ASN1.Asn1ConstraintSize lower: 1 upper: SmallInteger maxVal )		elementType: ( ASN1.Asn1Type findTypeNamed: #Extension ).</body><body package="X509" selector="initName">initName	"Name ::= CHOICE { RDNSequence }"	ASN1.Asn1TypeCHOICE		register:		#Name		elements:	( OrderedCollection						with: ( ASN1.Asn1Element								symbol: nil								type: ( ASN1.Asn1Type findTypeNamed: #RDNSequence ) ) ).</body><body package="X509" selector="initRDNSequence">initRDNSequence	"RDNSequence ::= SEQUENCE OF RelativeDistinguishedName"	ASN1.Asn1TypeSEQUENCE_OF		register: #RDNSequence		constraint: ( ASN1.Asn1ConstraintNull default )		elementType: ( ASN1.Asn1Type findTypeNamed: #RelativeDistinguishedName ).</body><body package="X509" selector="initRelativeDistinguishedName">initRelativeDistinguishedName	"RelativeDistinguishedName ::= SET OF AttributeTypeAndValue"	ASN1.Asn1TypeSET_OF		register: #RelativeDistinguishedName		constraint: ( ASN1.Asn1ConstraintNull default )		elementType: ( ASN1.Asn1Type findTypeNamed: #AttributeTypeAndValue ).</body><body package="X509" selector="initRSAIntegerTypes">initRSAIntegerTypes"register the RSA specific integer types"ASN1.Asn1TypeINTEGER register: #RSAVersion.ASN1.Asn1TypeINTEGER register: #RSAModulus.ASN1.Asn1TypeINTEGER register: #RSAPublicExponent.ASN1.Asn1TypeINTEGER register: #RSAPrivateExponent.ASN1.Asn1TypeINTEGER register: #RSAPrime1.ASN1.Asn1TypeINTEGER register: #RSAPrime2.ASN1.Asn1TypeINTEGER register: #RSAExponent1.ASN1.Asn1TypeINTEGER register: #RSAExponent2.ASN1.Asn1TypeINTEGER register: #RSACoefficient.ASN1.Asn1TypeINTEGER register: #RSAPrime.ASN1.Asn1TypeINTEGER register: #RSAExponent.</body><body package="X509" selector="initRSAOtherPrimeInfo">initRSAOtherPrimeInfo	"OtherPrimeInfo ::= SEQUENCE {prime INTEGER, -- riexponent INTEGER, -- dicoefficient INTEGER -- ti }"	| collection |	collection := OrderedCollection new.	collection add: (ASN1.Asn1Element symbol: #prime				type: (ASN1.Asn1Type findTypeNamed: #RSAPrime)).	collection add: (ASN1.Asn1Element symbol: #exponent				type: (ASN1.Asn1Type findTypeNamed: #RSAExponent)).	collection add: (ASN1.Asn1Element symbol: #coefficient				type: (ASN1.Asn1Type findTypeNamed: #RSACoefficient)).	ASN1.Asn1TypeSEQUENCE 		register: #OtherPrimeInfo		constraint: ASN1.Asn1ConstraintNull default		elements: collection</body><body package="X509" selector="initRSAOtherPrimeInfos">initRSAOtherPrimeInfos	"OtherPrimeInfos ::= SEQUENCE OF OtherPrimeInfo"	| collection |	collection := OrderedCollection new.	collection add: (ASN1.Asn1Element symbol: #otherPrimeInfo				type: (ASN1.Asn1Type findTypeNamed: #OtherPrimeInfo)).	ASN1.Asn1TypeSEQUENCE 		register: #OtherPrimeInfos		constraint: ASN1.Asn1ConstraintNull default		elements: collection</body><body package="X509" selector="initRSAPrivateKey">initRSAPrivateKey	"RSAPrivateKey ::= SEQUENCE {version Version,modulus INTEGER, -- npublicExponent INTEGER, -- eprivateExponent INTEGER, -- dprime1 INTEGER, -- pprime2 INTEGER, -- qexponent1 INTEGER, -- d mod (p-1)exponent2 INTEGER, -- d mod (q-1)coefficient INTEGER -- (inverse of q) mod potherPrimeInfos OtherPrimeInfos OPTIONAL }Version ::= INTEGEROtherPrimeInfos ::= SEQUENCE OF OtherPrimeInfoOtherPrimeInfo ::= SEQUENCE {prime INTEGER, -- riexponent INTEGER, -- dicoefficient INTEGER -- ti }"	| collection |	collection := OrderedCollection new.	collection add: (ASN1.Asn1Element symbol: #version				type: (ASN1.Asn1Type findTypeNamed: #RSAVersion)).	collection add: (ASN1.Asn1Element symbol: #modulus				type: (ASN1.Asn1Type findTypeNamed: #RSAModulus)).	collection add: (ASN1.Asn1Element symbol: #publicExponent				type: (ASN1.Asn1Type findTypeNamed: #RSAPublicExponent)).	collection add: (ASN1.Asn1Element symbol: #privateExponent				type: (ASN1.Asn1Type findTypeNamed: #RSAPrivateExponent)).	collection add: (ASN1.Asn1Element symbol: #prime1				type: (ASN1.Asn1Type findTypeNamed: #RSAPrime1)).	collection add: (ASN1.Asn1Element symbol: #prime2				type: (ASN1.Asn1Type findTypeNamed: #RSAPrime2)).	collection add: (ASN1.Asn1Element symbol: #exponent1				type: (ASN1.Asn1Type findTypeNamed: #RSAExponent1)).	collection add: (ASN1.Asn1Element symbol: #exponent2				type: (ASN1.Asn1Type findTypeNamed: #RSAExponent2)).	collection add: (ASN1.Asn1Element symbol: #coefficient				type: (ASN1.Asn1Type findTypeNamed: #RSACoefficient)).	collection add: (ASN1.Asn1Element 				optional: true				symbol: #otherPrimeInfos				type: (ASN1.Asn1Type findTypeNamed: #OtherPrimeInfos)).	ASN1.Asn1TypeSEQUENCE 		register: #RSAPrivateKey		constraint: ASN1.Asn1ConstraintNull default		elements: collection</body><body package="X509" selector="initRSAPublicKey">initRSAPublicKey	"RSAPublicKey ::= SEQUENCE {    modulus           INTEGER,  -- n    publicExponent    INTEGER   -- e }"	| collection |	collection := OrderedCollection new.	collection add: (ASN1.Asn1Element symbol: #modulus				type: (ASN1.Asn1Type findTypeNamed: #RSAModulus)).	collection add: (ASN1.Asn1Element symbol: #publicExponent				type: (ASN1.Asn1Type findTypeNamed: #RSAPublicExponent)).	ASN1.Asn1TypeSEQUENCE 		register: #RSAPublicKey		constraint: ASN1.Asn1ConstraintNull default		elements: collection</body><body package="X509" selector="initRSAPublicKeyTypes">initRSAPublicKeyTypes	"RSAPrivateKey ::= SEQUENCE {version Version,modulus INTEGER, -- npublicExponent INTEGER, -- eprivateExponent INTEGER, -- dprime1 INTEGER, -- pprime2 INTEGER, -- qexponent1 INTEGER, -- d mod (p-1)exponent2 INTEGER, -- d mod (q-1)coefficient INTEGER -- (inverse of q) mod potherPrimeInfos OtherPrimeInfos OPTIONAL }Version ::= INTEGEROtherPrimeInfos ::= SEQUENCE OF OtherPrimeInfoOtherPrimeInfo ::= SEQUENCE {prime INTEGER, -- riexponent INTEGER, -- dicoefficient INTEGER -- ti }RSAPublicKey ::= SEQUENCE {    modulus           INTEGER,  -- n    publicExponent    INTEGER   -- e }"	self initRSAIntegerTypes.	self initRSAOtherPrimeInfo.	self initRSAOtherPrimeInfos.	self initRSAPublicKey.	self initRSAPrivateKey</body><body package="X509" selector="initSerialNumber">initSerialNumber	"CertificateSerialNumber  ::=  INTEGER"	ASN1.Asn1TypeINTEGER		register:		#CertificateSerialNumber		constraint:	ASN1.Asn1ConstraintNull default.</body><body package="X509" selector="initSubjectPublicKeyInfo">initSubjectPublicKeyInfo	"SubjectPublicKeyInfo  ::=  SEQUENCE  {		algorithm            AlgorithmIdentifier,		subjectPublicKey     BIT STRING  }"	ASN1.Asn1TypeSEQUENCE		register:		#SubjectPublicKeyInfo		constraint:	ASN1.Asn1ConstraintNull default		elements:	( OrderedCollection						with: ( ASN1.Asn1Element								symbol: #algorithm								type: ( ASN1.Asn1Type findTypeNamed: #AlgorithmIdentifier ) )						with: ( ASN1.Asn1Element								symbol: #subjectPublicKey								type: ( ASN1.Asn1Type findTypeNamed: #'BIT STRING' ) ) ).</body><body package="X509" selector="initTBSCertificate">initTBSCertificate	"TBSCertificate  ::=  SEQUENCE  {		version         [0]  EXPLICIT Version DEFAULT v1,		serialNumber         CertificateSerialNumber,		signature            AlgorithmIdentifier,		issuer               Name,		validity             Validity,		subject              Name,		subjectPublicKeyInfo SubjectPublicKeyInfo,		issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,                             -- If present, version MUST be v2 or v3		subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,                             -- If present, version MUST be v2 or v3		extensions      [3]  EXPLICIT Extensions OPTIONAL                             -- If present, version MUST be v3        }"	ASN1.Asn1TypeSEQUENCE		register:		#TBSCertificate		constraint:	ASN1.Asn1ConstraintNull default		elements:	( ( OrderedCollection new: 10 )						add: ( ASN1.Asn1Element								default: 0								symbol: #version								tag: 0								taggingMode: #explicit								type: ( ASN1.Asn1Type findTypeNamed: #Version ) );						add: ( ASN1.Asn1Element								symbol: #serialNumber								type: ( ASN1.Asn1Type findTypeNamed: #CertificateSerialNumber ) );						add: ( ASN1.Asn1Element								symbol: #signature								type: ( ASN1.Asn1Type findTypeNamed: #AlgorithmIdentifier ) );						add: ( ASN1.Asn1Element								symbol: #issuer								type: ( ASN1.Asn1Type findTypeNamed: #Name ) );						add: ( ASN1.Asn1Element								symbol: #validity								type: ( ASN1.Asn1Type findTypeNamed: #Validity ) );						add: ( ASN1.Asn1Element								symbol: #subject								type: ( ASN1.Asn1Type findTypeNamed: #Name ) );						add: ( ASN1.Asn1Element								symbol: #subjectPublicKeyInfo								type: ( ASN1.Asn1Type findTypeNamed: #SubjectPublicKeyInfo ) );						add: ( ASN1.Asn1Element								optional: true								symbol: #issuerUniqueID								tag: 1								taggingMode: #implicit								type: ( ASN1.Asn1Type findTypeNamed: #UniqueIdentifier ) );						add: ( ASN1.Asn1Element								optional: true								symbol: #subjectUniqueID								tag: 2								taggingMode: #implicit								type: ( ASN1.Asn1Type findTypeNamed: #UniqueIdentifier ) );						add: ( ASN1.Asn1Element								optional: true								symbol: #extensions								tag: 3								taggingMode: #explicit								type: ( ASN1.Asn1Type findTypeNamed: #Extensions ) );						yourself ).</body><body package="X509" selector="initTime"> initTime	"Time ::= CHOICE {		utcTime        UTCTime,		generalTime    GeneralizedTime }"	ASN1.Asn1TypeCHOICE		register:		#Time		elements:	( OrderedCollection						with: ( ASN1.Asn1Element								symbol: #utcTime								type: ASN1.Asn1TypeUTCTime default )						with: ( ASN1.Asn1Element								symbol: #generalTime								type: ASN1.Asn1TypeGeneralizedTime default ) ).</body><body package="X509" selector="initUniqueIdentifier">initUniqueIdentifier	"UniqueIdentifier  ::=  BIT STRING"	ASN1.Asn1TypeBIT_STRING register: #UniqueIdentifier.</body><body package="X509" selector="initValidity"> initValidity   	"Validity ::= SEQUENCE {		notBefore	Time,		notAfter       Time }"	ASN1.Asn1TypeSEQUENCE		register:		#Validity		constraint:	ASN1.Asn1ConstraintNull default		elements:	( OrderedCollection						with: ( ASN1.Asn1Element								symbol: #notBefore								type: ( ASN1.Asn1Type findTypeNamed: #Time ) )						with: ( ASN1.Asn1Element								symbol: #notAfter								type: ( ASN1.Asn1Type findTypeNamed: #Time ) ) ).</body><body package="X509" selector="initVersion">initVersion	" Version  ::=  INTEGER  {  v1(0), v2(1), v3(2)  }"	ASN1.Asn1TypeINTEGER		register:		#Version		constraint:	( ASN1.Asn1ConstraintEnumerated						with: #v1 -&gt; 0						with: #v2 -&gt; 1						with: #v3 -&gt; 2 ).</body></methods><methods><class-id>Security.X509Certificate class</class-id> <category>initialize-release</category><body package="X509" selector="createTypes">createTypes	" Version  ::=  INTEGER  {  v1(0), v2(1), v3(2)  }"	ASN1.Asn1TypeINTEGER		register:		#Version		constraint:	( ASN1.Asn1ConstraintEnumerated						with: #v1 -&gt; 0						with: #v2 -&gt; 1						with: #v3 -&gt; 2 ).	"CertificateSerialNumber  ::=  INTEGER"	ASN1.Asn1TypeINTEGER		register:		#CertificateSerialNumber		constraint:	ASN1.Asn1ConstraintNull default.	"Time ::= CHOICE {		utcTime        UTCTime,		generalTime    GeneralizedTime }"	ASN1.Asn1TypeCHOICE		register:		#Time		elements:	( OrderedCollection						with: ( ASN1.Asn1Element								symbol: #utcTime								type: ASN1.Asn1TypeUTCTime default )						with: ( ASN1.Asn1Element								symbol: #generalTime								type: ASN1.Asn1TypeGeneralizedTime default ) ).   	"Validity ::= SEQUENCE {		notBefore	Time,		notAfter       Time }"	ASN1.Asn1TypeSEQUENCE		register:		#Validity		constraint:	ASN1.Asn1ConstraintNull default		elements:	( OrderedCollection						with: ( ASN1.Asn1Element								symbol: #notBefore								type: ( ASN1.Asn1Type findTypeNamed: #Time ) )						with: ( ASN1.Asn1Element								symbol: #notAfter								type: ( ASN1.Asn1Type findTypeNamed: #Time ) ) ).	"UniqueIdentifier  ::=  BIT STRING"	ASN1.Asn1TypeBIT_STRING register: #UniqueIdentifier.	"Extension  ::=  SEQUENCE  {		extnID      OBJECT IDENTIFIER,		critical    BOOLEAN DEFAULT FALSE,		extnValue   OCTET STRING  }"	ASN1.Asn1TypeSEQUENCE		register:		#Extension		constraint:	ASN1.Asn1ConstraintNull default		elements:	( OrderedCollection						with: ( ASN1.Asn1Element								symbol: #extnID								type: ( ASN1.Asn1Type findTypeNamed: #'OBJECT IDENTIFIER' ) )						with: ( ASN1.Asn1Element								default: false								symbol: #critical								type: ( ASN1.Asn1Type findTypeNamed: #BOOLEAN ) )						with: ( ASN1.Asn1Element								symbol: #extnValue								type: ( ASN1.Asn1Type findTypeNamed: #'OCTET STRING' ) ) ).	"Extensions  ::=  SEQUENCE SIZE (1..MAX) OF Extension"	ASN1.Asn1TypeSEQUENCE_OF		register: #Extensions		constraint: ( ASN1.Asn1ConstraintSize lower: 1 upper: SmallInteger maxVal )		elementType: ( ASN1.Asn1Type findTypeNamed: #Extension ).	"AlgorithmIdentifier  ::=  SEQUENCE  {		algorithm               OBJECT IDENTIFIER,		parameters              ANY DEFINED BY algorithm OPTIONAL  }"	ASN1.Asn1TypeSEQUENCE		register:		#AlgorithmIdentifier		constraint:	ASN1.Asn1ConstraintNull default		elements:	( OrderedCollection						with: ( ASN1.Asn1Element								symbol: #algorithm								type: ( ASN1.Asn1Type findTypeNamed: #'OBJECT IDENTIFIER' ) )						with: ( ASN1.Asn1Element								optional: true								symbol: #parameters								type: ( ASN1.Asn1Type findTypeNamed: #ANY ) ) ).	"SubjectPublicKeyInfo  ::=  SEQUENCE  {		algorithm            AlgorithmIdentifier,		subjectPublicKey     BIT STRING  }"	ASN1.Asn1TypeSEQUENCE		register:		#SubjectPublicKeyInfo		constraint:	ASN1.Asn1ConstraintNull default		elements:	( OrderedCollection						with: ( ASN1.Asn1Element								symbol: #algorithm								type: ( ASN1.Asn1Type findTypeNamed: #AlgorithmIdentifier ) )						with: ( ASN1.Asn1Element								symbol: #subjectPublicKey								type: ( ASN1.Asn1Type findTypeNamed: #'BIT STRING' ) ) ).	"AttributeType ::= OBJECT IDENTIFIER"	ASN1.Asn1TypeOBJECT_IDENTIFIER register: #AttributeType.	"AttributeValue ::= ANY DEFINED BY AttributeType"	ASN1.Asn1TypeANY register: #AttributeValue.	"AttributeTypeAndValue ::= SEQUENCE {		type     AttributeType,		value    AttributeValue }"	ASN1.Asn1TypeSEQUENCE		register:		#AttributeTypeAndValue		constraint:	ASN1.Asn1ConstraintNull default		elements:	( OrderedCollection						with: ( ASN1.Asn1Element								symbol: #type								type: ( ASN1.Asn1Type findTypeNamed: #AttributeType ) )						with: ( ASN1.Asn1Element								symbol: #value								type: ( ASN1.Asn1Type findTypeNamed: #AttributeValue ) ) ).	"RelativeDistinguishedName ::= SET OF AttributeTypeAndValue"	ASN1.Asn1TypeSET_OF		register: #RelativeDistinguishedName		constraint: ( ASN1.Asn1ConstraintNull default )		elementType: ( ASN1.Asn1Type findTypeNamed: #AttributeTypeAndValue ).	"RDNSequence ::= SEQUENCE OF RelativeDistinguishedName"	ASN1.Asn1TypeSEQUENCE_OF		register: #RDNSequence		constraint: ( ASN1.Asn1ConstraintNull default )		elementType: ( ASN1.Asn1Type findTypeNamed: #RelativeDistinguishedName ).	"Name ::= CHOICE { RDNSequence }"	ASN1.Asn1TypeCHOICE		register:		#Name		elements:	( OrderedCollection						with: ( ASN1.Asn1Element								symbol: nil								type: ( ASN1.Asn1Type findTypeNamed: #RDNSequence ) ) ).	"TBSCertificate  ::=  SEQUENCE  {		version         [0]  EXPLICIT Version DEFAULT v1,		serialNumber         CertificateSerialNumber,		signature            AlgorithmIdentifier,		issuer               Name,		validity             Validity,		subject              Name,		subjectPublicKeyInfo SubjectPublicKeyInfo,		issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,                             -- If present, version MUST be v2 or v3		subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,                             -- If present, version MUST be v2 or v3		extensions      [3]  EXPLICIT Extensions OPTIONAL                             -- If present, version MUST be v3        }"	ASN1.Asn1TypeSEQUENCE		register:		#TBSCertificate		constraint:	ASN1.Asn1ConstraintNull default		elements:	( ( OrderedCollection new: 10 )						add: ( ASN1.Asn1Element								default: 0								symbol: #version								tag: 0								taggingMode: #explicit								type: ( ASN1.Asn1Type findTypeNamed: #Version ) );						add: ( ASN1.Asn1Element								symbol: #serialNumber								type: ( ASN1.Asn1Type findTypeNamed: #CertificateSerialNumber ) );						add: ( ASN1.Asn1Element								symbol: #signature								type: ( ASN1.Asn1Type findTypeNamed: #AlgorithmIdentifier ) );						add: ( ASN1.Asn1Element								symbol: #issuer								type: ( ASN1.Asn1Type findTypeNamed: #Name ) );						add: ( ASN1.Asn1Element								symbol: #validity								type: ( ASN1.Asn1Type findTypeNamed: #Validity ) );						add: ( ASN1.Asn1Element								symbol: #subject								type: ( ASN1.Asn1Type findTypeNamed: #Name ) );						add: ( ASN1.Asn1Element								symbol: #subjectPublicKeyInfo								type: ( ASN1.Asn1Type findTypeNamed: #SubjectPublicKeyInfo ) );						add: ( ASN1.Asn1Element								optional: true								symbol: #issuerUniqueID								tag: 1								taggingMode: #implicit								type: ( ASN1.Asn1Type findTypeNamed: #UniqueIdentifier ) );						add: ( ASN1.Asn1Element								optional: true								symbol: #subjectUniqueID								tag: 2								taggingMode: #implicit								type: ( ASN1.Asn1Type findTypeNamed: #UniqueIdentifier ) );						add: ( ASN1.Asn1Element								optional: true								symbol: #extensions								tag: 3								taggingMode: #explicit								type: ( ASN1.Asn1Type findTypeNamed: #Extensions ) );						yourself ).	"Certificate  ::=  SEQUENCE  {		tbsCertificate       TBSCertificate,		signatureAlgorithm   AlgorithmIdentifier,		signatureValue       BIT STRING  }"	ASN1.Asn1TypeSEQUENCE		register:		#Certificate		constraint:	ASN1.Asn1ConstraintNull default		elements:	( OrderedCollection						with: ( ASN1.Asn1Element								symbol: #tbsCertificate								type: ( ASN1.Asn1Type findTypeNamed: #TBSCertificate ) )						with: ( ASN1.Asn1Element								symbol: #signatureAlgorithm								type: ( ASN1.Asn1Type findTypeNamed: #AlgorithmIdentifier ) )						with: ( ASN1.Asn1Element								symbol: #signatureValue								type: ( ASN1.Asn1Type findTypeNamed: #'BIT STRING' ) ) ).</body><body package="X509" selector="initialize">initialize	"ignore the eceptions for now since the are most likley a result of having the type already there however it brings up other questions that have to be answered so for now it gets left this way till I know"	ASN1.Asn1Type resetTypeRegistry.	[self initAsn1Types] on: ASN1.Asn1Exception do:[:ex | ex return.].	self addSMINodeOIDDescriptions</body></methods><methods><class-id>Security.X509TBSCertificateRevocationList</class-id> <category>initializing</category><body package="X509" selector="initialize:">initialize: aTbsSequence</body><body package="X509" selector="parse:">parse: aTBSSequence</body></methods><methods><class-id>Security.X509TBSCertificateRevocationList class</class-id> <category>initializing</category><body package="X509" selector="fromASN1Value:">fromASN1Value: anASN1Value 	^self new parse: anASN1Value</body></methods><methods><class-id>Security.X509TBSCertificate</class-id> <category>key usage</category><body package="X509" selector="getKeyUsage">getKeyUsage	^self hasExtensions ifTrue: [ extensions detect:[:ea | ea isKeyUsage ] ifNone: [nil]] ifFalse:[nil]</body><body package="X509" selector="hasKeyUsage">hasKeyUsage	^self hasExtensions and: [ extensions contains:[:ea | ea isKeyUsage]]</body><body package="X509" selector="isCrlSign">isCrlSign	^self hasExtensions and: [ extensions contains:[:ea | ea isKeyUsage ifTrue:[ea crlSign ] ifFalse:[false ]]]</body><body package="X509" selector="isDataEncipherment">isDataEncipherment	^self hasExtensions and: [ extensions contains:[:ea | ea isKeyUsage ifTrue:[ea dataEncipherment ] ifFalse:[false ]]]</body><body package="X509" selector="isDecipherOnly">isDecipherOnly	^self hasExtensions and: [ extensions contains:[:ea | ea isKeyUsage ifTrue:[ea decipherOnly ] ifFalse:[false ]]]</body><body package="X509" selector="isDigitalSignature">isDigitalSignature	^self hasExtensions and: [ extensions contains:[:ea | ea isKeyUsage ifTrue:[ea digitalSignature ] ifFalse:[false ]]]</body><body package="X509" selector="isEncipherOnly">isEncipherOnly	^self hasExtensions and: [ extensions contains:[:ea | ea isKeyUsage ifTrue:[ea encipherOnly ] ifFalse:[false ]]]</body><body package="X509" selector="isKeyAgreement">isKeyAgreement	^self hasExtensions and: [ extensions contains:[:ea | ea isKeyUsage ifTrue:[ea keyAgreement ] ifFalse:[false ]]]</body><body package="X509" selector="isKeyCertSign">isKeyCertSign	^self hasExtensions and: [ extensions contains:[:ea | ea isKeyUsage ifTrue:[ea keyCertSign ] ifFalse:[false ]]]</body><body package="X509" selector="isKeyEncipherment">isKeyEncipherment	^self hasExtensions and: [ extensions contains:[:ea | ea isKeyUsage ifTrue:[ea keyEncipherment ] ifFalse:[false ]]]</body><body package="X509" selector="isKeyUsageCritical">isKeyUsageCritical	^self hasExtensions and: [ extensions contains:[:ea | ea isKeyUsage ifTrue:[ea isCritical ] ifFalse:[false ]]]</body><body package="X509" selector="isNonRepudiation">isNonRepudiation	^self hasExtensions and: [ extensions contains:[:ea | ea isKeyUsage ifTrue:[ea nonRepudiation ] ifFalse:[false ]]]</body></methods><methods><class-id>Security.X509TBSCertificate</class-id> <category>accessing</category><body package="X509" selector="extensions">extensions	"Ordered Collection of X509Extension objects"	^extensions</body><body package="X509" selector="getPublicKey">getPublicKey	^subjectPublicKeyInfo getPublicKey</body><body package="X509" selector="issuerDN">issuerDN	"distinguished name of the issuer"	^issuer getRDN</body><body package="X509" selector="issuerDNInBytes">issuerDNInBytes	"distinguished name of the issuer"	^issuer getDNBytes</body><body package="X509" selector="notAfter">notAfter	"instance of String containing notAfter as a UTCTIME"	^validity notAfter</body><body package="X509" selector="notAfterDate">notAfterDate	"instance of Date containing the date component of notAfter"	^validity notAfterDate</body><body package="X509" selector="notAfterTime">notAfterTime	"instance of Time containing the time component of notAfter"	^validity notAfterTime</body><body package="X509" selector="notBefore">notBefore	"instance of String containing notBefore as a UTCTIME"	^validity notBefore</body><body package="X509" selector="notBeforeDate">notBeforeDate	"instance of Date containing the date component of notBefore"	^validity notBeforeDate</body><body package="X509" selector="notBeforeTime">notBeforeTime	"instance of Time containing the time component of notBefore"	^validity notBeforeTime</body><body package="X509" selector="serialNumber">serialNumber	"serial number of this certificate"	^serialNumber</body><body package="X509" selector="signatureAlgorithmOID">signatureAlgorithmOID	"OID of the algorithm used to sign this certificate"	^signature getOID</body><body package="X509" selector="signatureAlgorithmOIDDescription">signatureAlgorithmOIDDescription	"description of the OID of the algorithm used to sign this certificate"	^signature getOIDDescription</body><body package="X509" selector="subjectDN">subjectDN	"distinguished name of the subject"	^subject getRDN</body><body package="X509" selector="subjectDNInBytes">subjectDNInBytes	"distinguished name of the subject"	^subject getDNBytes</body><body package="X509" selector="subjectPublicKeyInfo">subjectPublicKeyInfo	"subject's public key info"	^subjectPublicKeyInfo</body><body package="X509" selector="totalBytes">totalBytes	"total number of bytes in the TBS"	^totalBytes</body><body package="X509" selector="version">version	"version of this certificate"	^version</body></methods><methods><class-id>Security.X509TBSCertificate</class-id> <category>queries</category><body package="X509" selector="getCriticalExtensions">getCriticalExtensions	self hasExtensions ifFalse:[^OrderedCollection new].	^extensions select:[:ea | ea isCritical]</body><body package="X509" selector="hasExtensions">hasExtensions	^extensions notNil and: [extensions notEmpty ]</body></methods><methods><class-id>Security.X509TBSCertificate</class-id> <category>basic constraints</category><body package="X509" selector="getBasicContraints">getBasicContraints 	^self hasExtensions ifTrue: [ extensions detect:[:ea | ea isBasicConstraint ] ifNone: [nil]] ifFalse:[nil]</body><body package="X509" selector="hasBasicConstraints">hasBasicConstraints	^self hasExtensions and: [ extensions contains:[:ea | ea isBasicConstraint]]</body><body package="X509" selector="isCACertificate">isCACertificate	^self hasExtensions and: [ extensions contains:[:ea | ea isBasicConstraint ifTrue:[ea ca ] ifFalse:[false ]]]</body></methods><methods><class-id>Security.X509TBSCertificate</class-id> <category>ssl</category><body package="X509" selector="issuer">issuer	^issuer</body><body package="X509" selector="subject">subject	^subject</body></methods><methods><class-id>Security.X509TBSCertificate</class-id> <category>printing</category><body package="X509" selector="printOpenSSLOn:indent:">printOpenSSLOn: aStream indent: level"This should print the certificate in the format used by OpenSSL"	| notBefore notAfter format |	notBefore :=  validity  notBefore.	notAfter :=  validity  notAfter.	format := 'mmm d hh:mm:ss yyyy'.	aStream		tab: level; nextPutAll: (#VersionPrefix &lt;&lt; #security &gt;&gt; 'Version: ') asString; print: version;			nextPutAll: ' (0x'; print: version - 1; nextPut: $); cr;		tab: level; nextPutAll: (#SerialNumberPrefix &lt;&lt; #security &gt;&gt; 'Serial Number: ') asString; cr.	serialNumber asBigEndianByteArray printOpenSSLOn: aStream indent: level + 1 width: 50.	aStream        	tab: level; nextPutAll: (#SignatureAlgorithmPrefix &lt;&lt; #security &gt;&gt; 'Signature Algorithm: ') asString;		nextPutAll: signature getOIDDescription; cr;		tab: level; nextPutAll: (#IssuerPrefix &lt;&lt; #security &gt;&gt; 'Issuer: ') asString.	issuer printOpenSSLOn: aStream indent: 0.	aStream cr;		tab: level; nextPutAll: (#ValidityPrefix &lt;&lt; #security &gt;&gt; 'Validity') asString; cr;		tab: level + 1; nextPutAll: (#NotBeforePrefix &lt;&lt; #security &gt;&gt; 'Not Before: ') asString.	TimestampPrintPolicy print: notBefore on: aStream using: format.	aStream nextPutAll: (#GMTPrefix &lt;&lt; #security &gt;&gt; ' GMT') asString; cr;		tab: level + 1; nextPutAll: (#NotAfterPrefix &lt;&lt; #security &gt;&gt; 'Not After : ') asString.	TimestampPrintPolicy print: notAfter on: aStream using: format.	aStream nextPutAll: (#GMTPrefix &lt;&lt; #security &gt;&gt; ' GMT') asString; cr;		tab: level; nextPutAll: (#SubjectPrefix &lt;&lt; #security &gt;&gt; 'Subject: ') asString.	subject printOpenSSLOn: aStream indent: 0.	aStream cr;        	tab: level; nextPutAll: (#SubjectKeyInfoPrefix &lt;&lt; #security &gt;&gt; 'Subject Public Key Info:') asString; cr.	subjectPublicKeyInfo printOpenSSLOn: aStream indent: level + 1.		"key"	(extensions isNil or: [extensions isEmpty]) ifFalse: [		aStream tab: level; nextPutAll: (#X509ExtensionsPrefix &lt;&lt; #security &gt;&gt; 'X509v3 extensions:') asString; cr.		extensions do: [ :ext |			ext printOpenSSLOn: aStream indent: level + 1 ] ]</body><body package="X509" selector="printOpenSSLString">printOpenSSLString"This should print the certificate in the format used by OpenSSL"	| ws |	ws := WriteStream on: (String new: 100).	self printOpenSSLOn: ws indent: 0.	^ws contents</body></methods><methods><class-id>Security.X509TBSCertificate</class-id> <category>utilities</category><body package="X509" selector="inspectorExtraAttributes">inspectorExtraAttributes	^Array		with: (Tools.Trippy.TextAttribute label: 'openssl' text: self printOpenSSLString)</body></methods><methods><class-id>Security.X509TBSCertificate</class-id> <category>parsing</category><body package="X509" selector="fromASN1Type:">fromASN1Type: anASN1Type 	"get the certificate specific components from the asn1 type wrapper"	"Parses anASN1Value into the certificate components"	tbsSequence := anASN1Type.	version := tbsSequence version + 1.	serialNumber := tbsSequence serialNumber value.	signature := X509AlgorithmIdentifier fromASN1Type: tbsSequence signature .	issuer := X509Name fromASN1Type: tbsSequence issuer.	validity := X509Validity fromASN1Type: tbsSequence validity.	subject := X509Name fromASN1Type: tbsSequence subject.	subjectPublicKeyInfo := X509SubjectPublicKeyInfo 				fromASN1Type: tbsSequence subjectPublicKeyInfo.	self getExtensionsFromASN1Type: tbsSequence</body><body package="X509" selector="getExtensionsFromASN1Type:">getExtensionsFromASN1Type: anAsn1Type	"this will extract a set of extensions from the set"	| extensionCollection |	(anAsn1Type includesKey: #extensions) ifTrue:[	extensionCollection := anAsn1Type extensions value.	extensions := extensionCollection collect:[:ea |  X509Extension fromASN1Type: ea]].</body></methods><methods><class-id>Security.X509TBSCertificate class</class-id> <category>instance creation</category><body package="X509" selector="fromASN1Type:">fromASN1Type: anASN1Type 	^self new fromASN1Type:  anASN1Type</body><body package="X509" selector="fromASN1Value:">fromASN1Value: anASN1Value 	^self new parse: anASN1Value</body></methods><methods><class-id>ASN1.X509CertificateStream</class-id> <category>decoding - api</category><body package="X509" selector="unmarshalObject">unmarshalObject	"... the default, top-level, decoding entry point, for type-agnostic decoding."	^[ 	( retainEncodings )			ifTrue:	[ source := collection copy ].		self decodeTLV		]	on:	Error			do:	[ :ex | Asn1ExcMarshaling raiseSignal: ex errorString ]</body></methods><methods><class-id>ASN1.X509CertificateStream</class-id> <category>initialize-release</category><body package="X509" selector="initialize">initialize	super initialize.	self createTypes</body></methods><methods><class-id>Security.X509CertificateRevocationList</class-id> <category>initialize</category><body package="X509" selector="initialize:">initialize: aFile	"Checks that it is PEM (i.e. has the appropriate '-----BEGIN X509 CRL-----' and '-----END X509 CRL-----' lines. Strips out all cr/lf characters. Converts from Base 64"	^self initializeFromString:  aFile asFilename readStream contents.</body><body package="X509" selector="initializeFromBytes:">initializeFromBytes: aByteArray	derCertificate := aByteArray.	^self parse</body><body package="X509" selector="initializeFromDirecttBitsIn:">initializeFromDirecttBitsIn: aFile	"this assumes the file is bianry. it is not PEM encoded"	^self initializeFromBytes:  (aFile asFilename readStream contents  changeClassTo: ByteArray).</body></methods><methods><class-id>Security.X509CertificateSignatureVerification</class-id> <category>api</category><body package="X509" selector="verifyCertificate:isSignedBy:">verifyCertificate: aSubjectCertificate isSignedBy: anIssuerCertificate	"First test verify that the signature Algorithm specified is the same as the one in the tbsCertificate.	Now this depending on the certificate can fail. It happens often if a certificate has been reencoded	by something other than the software that generated it. In that case most likely the hashes will not match producing a signature failure. see Package comments"	aSubjectCertificate signatureAlgorithm getOID = aSubjectCertificate signatureAlgorithmOID		ifFalse: [ X509BadCertificate new				messageText: (#SubjectSigAlgMismatch &lt;&lt; #security &gt;&gt; 'Subject signature algorithm mismatch!');				parameter: aSubjectCertificate;				isResumable: true;				raiseSignal ]</body></methods><methods><class-id>Security.X509CertificateSignatureVerification class</class-id> <category>initialize</category><body package="X509" selector="initialize">initializeself initializeSignatureVerificationDictionary</body><body package="X509" selector="initializeSignatureVerificationDictionary">initializeSignatureVerificationDictionarySignatureVerificationDictionary := Dictionary new.</body></methods><methods><class-id>Security.X509CertificateSignatureVerification class</class-id> <category>accessing</category><body package="X509" selector="verifierForOID:">verifierForOID: oid "self verifierForOID: #x1x2x840x113549x1x1x4 "	| classes |	classes := self subclasses select: [:each | each oidCollection includes: oid].	^classes isEmpty		ifTrue: ["should only be one or empty"			nil]		ifFalse: [classes first new]</body></methods><methods><class-id>Security.X509DSASignatureVerification</class-id> <category>api</category><body package="X509" selector="verifyCertificate:isSignedBy:">verifyCertificate: aSubjectCertificate isSignedBy: anIssuerCertificate	super verifyCertificate: aSubjectCertificate isSignedBy: anIssuerCertificate.	"anIssuerCertificate subjectPublicKeyAlgorithmOIDDescription = 'dsaEncryption'"	anIssuerCertificate subjectPublicKeyAlgorithmOID getDottedOID = '1.2.840.10040.4.1'		ifFalse: [ X509InvalidSignature new				messageText: (#IssuerSigAlgMismatch &lt;&lt; #security &gt;&gt; 'Issuer signature algorithm mismatch!');				parameter: (Array with: aSubjectCertificate with: anIssuerCertificate);				isResumable: true;				raiseSignal ].	^DSA new		publicKey: anIssuerCertificate getPublicKey;		verify: aSubjectCertificate signature getSignature		of: aSubjectCertificate tbsDerCertificate</body></methods><methods><class-id>Security.X509DSASignatureVerification class</class-id> <category>accessing</category><body package="X509" selector="oidCollection">oidCollection	^#(#x1x2x840x10040x4x3  #x1x2x840x10040x4x1  #x1x3x14x3x2x12  #x1x3x14x3x2x27 #x1x3x14x3x2x12 #x1x3x14x3x2x13 #x1x3x14x3x2x27 #x1x2x840x10040x4x3 )</body></methods><methods><class-id>Security.X509Warning</class-id> <category>testing</category><body package="X509" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Security.X509Notification</class-id> <category>private - actions</category><body package="X509" selector="defaultAction">defaultAction	"What to do when the exception is unhandled. By default, Notifications can be ignored."		^self defaultResumeValue</body></methods><methods><class-id>Security.X509ExtensionShouldBeCritical</class-id> <category>accessing</category><body package="X509" selector="extension">extension	^extension</body><body package="X509" selector="extension:">extension: anObject	extension := anObject</body></methods><methods><class-id>Security.X509UnhandledCriticalExtension</class-id> <category>accessing</category><body package="X509" selector="extension">extension	^extension</body><body package="X509" selector="extension:">extension: anObject	extension := anObject</body></methods><methods><class-id>Security.X509CertificateFileReader</class-id> <category>api</category><body package="X509" selector="readFromStream:">readFromStream: aStream	| collection certificateCollection |	collection := self breakStreamIntoCollectionOfRawAssociations: aStream.	certificateCollection := OrderedCollection new: collection size.	collection do: [:each |		[	| cert |			cert  := X509Certificate readFromAssociation: each.			cert notNil ifTrue: [certificateCollection add: cert]		] on: Error do: [ :ex |			Transcript show: (				(#CertAndKeyReadError1s &lt;&lt; #security &gt;&gt; 'Error reading certificate/private key pair : &lt;1s&gt;')					expandMacrosWith: each printString);				cr ]].	^certificateCollection</body></methods><methods><class-id>Security.X509CertificateFileReader</class-id> <category>private</category><body package="X509" selector="breakStreamIntoCollectionOfRawAssociations:">breakStreamIntoCollectionOfRawAssociations: aStream 	| collection encodeCertificate p finalPosition encodedPrivateKey |	stream := aStream.	collection := OrderedCollection new: 200.	[stream atEnd]		whileFalse: 			[(self peekForString: '-BEGIN')				ifTrue: 					[stream skip: -4.					p := stream position.					self peekForString: '---END'.					self peekForString: 'CERTIFICATE----'.					finalPosition := stream position + 15.					stream position: p.					encodeCertificate := stream next: finalPosition - p.					stream skip: 1.					(self						peekForString: 'KEY----'						inTheNext: 50						resetting: true)						ifTrue: 							[(self peekForString: '---BEGIN')								ifTrue: 									[stream skip: -1.									p := stream position.									self peekForString: '---END'.									self peekForString: 'KEY----'.									finalPosition := stream position + 7.									stream position: p.									encodedPrivateKey := stream next: finalPosition - p].].							collection add: encodeCertificate -&gt; encodedPrivateKey.							encodedPrivateKey := encodeCertificate := nil]	ifFalse:[			stream atEnd ifFalse: [				stream skip: 1]].].	^collection</body><body package="X509" selector="peekForString:">peekForString: str 	"peek for the string and if found position the stream at the begining of the string since we need that 	information for making the certificate and Keys"	| p |	p := stream position.	(stream skipUpTo: (str at: 1)) isNil ifTrue: [^false].	1 to: str size do: [:i | (stream peekFor: (str at: i))			ifFalse: [^stream atEnd					ifTrue: 						[stream position: p.						false]					ifFalse: 						[stream skip: 2 - i.						self peekForString: str]]].	stream position: stream position - str size.	^true</body><body package="X509" selector="peekForString:inTheNext:resetting:">peekForString: str inTheNext: count resetting: reset 	"peek for the string in the next count positions. if found position the stream at the begining of the 	string if reset is true"	| p |	count = 0 ifTrue: [^false].	p := stream position.	(stream skipUpTo: (str at: 1)) isNil ifTrue: [^false].	(stream position - p ) &gt; count ifTrue:[stream position: p. ^false].	1 to: str size do: [:i | (stream peekFor: (str at: i))			ifFalse: [^stream atEnd					ifTrue: 						[stream position: p.						false]					ifFalse: 						[stream skip: 2 - i.						self							peekForString: str							inTheNext: count - 1							resetting: reset]]].	reset		ifTrue: [stream position: p]		ifFalse: [stream position: stream position - str size].	^true</body></methods><methods><class-id>Security.X509CertificateFileReader class</class-id> <category>testing</category><body package="X509" selector="examplePEMcontents">examplePEMcontents^'issuer= /C=AU/ST=Queensland/O=CryptSoft Pty Ltd/CN=Test CA (1024 bit)subject=/C=AU/ST=Queensland/O=CryptSoft Pty Ltd/CN=Server test cert (512 bit)-----BEGIN CERTIFICATE-----MIIB6TCCAVICAQQwDQYJKoZIhvcNAQEEBQAwWzELMAkGA1UEBhMCQVUxEzARBgNVBAgTClF1ZWVuc2xhbmQxGjAYBgNVBAoTEUNyeXB0U29mdCBQdHkgTHRkMRswGQYDVQQDExJUZXN0IENBICgxMDI0IGJpdCkwHhcNOTgwNjI5MjM1MjQwWhcNMDAwNjI4MjM1MjQwWjBjMQswCQYDVQQGEwJBVTETMBEGA1UECBMKUXVlZW5zbGFuZDEaMBgGA1UEChMRQ3J5cHRTb2Z0IFB0eSBMdGQxIzAhBgNVBAMTGlNlcnZlciB0ZXN0IGNlcnQgKDUxMiBiaXQpMFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAJ+zw4Qnlf8SMVIPFe9GEcStgOY2Ww/dgNdhjeD8ckUJNP5VZkVDTGiXav6ooKXfX3j/7tdkuD8Ey2//Kv7+ue0CAwEAATANBgkqhkiG9w0BAQQFAAOBgQCVvvfkGSe2GHgDFfmOua4Isjb9JVhImWMASiOClkZlMESDJjsszg/6+d/W+8TrbObhazpl95FivXBVucbj9dudh7AOIZu1h1MAPlyknc9Ud816vz3FejB4qqUoaXjnlkrIgEbr/un7jSS86WOe0hRhwHkJFUGcPZf9ND22Etc+AQ==-----END CERTIFICATE----------BEGIN RSA PRIVATE KEY-----MIIBPAIBAAJBAJ+zw4Qnlf8SMVIPFe9GEcStgOY2Ww/dgNdhjeD8ckUJNP5VZkVDTGiXav6ooKXfX3j/7tdkuD8Ey2//Kv7+ue0CAwEAAQJAN6W31vDEP2DjdqhzCDDuOA4NACqoiFqyblo7yc2tM4h4xMbC3Yx5UKMN9ZkCtX0gzrz6DyF47bdKcWBzNWCjgQIhANEoojVt7hq+SQ6MCN6FTAysGgQf56Q3TYoJMoWvdiXVAiEAw3e3rc+VJpOzrHuDo6bgpjUAAXM+v3fcpsfZSNO6V7kCIQCtbVjanpUwvZkMI9by02oUk9taki3bPzPfAfNPYAbCJQIhAJXNQDWyqwn/lGmR11cqY2y9nZ1+5w3yHGatLrcDnQHxAiEAvnlEGo8K85u+KwIOimM48ZG8oTk7iFdkqLJR1utT3aU=-----END RSA PRIVATE KEY-----subject=/C=US/O=AT&amp;T Bell Laboratories/OU=Prototype Research CAissuer= /C=US/O=AT&amp;T Bell Laboratories/OU=Prototype Research CAnotBefore=950413210656ZnotAfter =970412210656Z-----BEGIN X509 CERTIFICATE-----MIICCDCCAXECAQAwDQYJKoZIhvcNAQEEBQAwTjELMAkGA1UEBhMCVVMxHzAdBgNVBAoUFkFUJlQgQmVsbCBMYWJvcmF0b3JpZXMxHjAcBgNVBAsUFVByb3RvdHlwZSBSZXNlYXJjaCBDQTAeFw05NTA0MTMyMTA2NTZaFw05NzA0MTIyMTA2NTZaME4xCzAJBgNVBAYTAlVTMR8wHQYDVQQKFBZBVCZUIEJlbGwgTGFib3JhdG9yaWVzMR4wHAYDVQQLFBVQcm90b3R5cGUgUmVzZWFyY2ggQ0EwgZwwDQYJKoZIhvcNAQEBBQADgYoAMIGGAoGAebOmgtSCl+wCYZc86UGYeTLY8cjmW2P0FN8ToT/u2pECCoFdrlycX0OR3wt0ZhpFXLVNeDnHwEE9veNUih7pCL2ZBFqoIoQkB1lZmXRiVtjGonz8BLm/qrFMYHb0lme/Ol+s118mwKVxnn6bSAeI/OXKhLaVdYZWk+aEaxEDkVkCAQ8wDQYJKoZIhvcNAQEEBQADgYEAAZMG14lZmZ8bahkaHaTV9dQf4p2FZiQTFwHP9ZyGsXPC+LT5dG5iTaRmyjNIJdPWohZDl97kAci79aBndvuEvRKOjLHs3WRGBIwERnAcnY9Mz8u/zIHK23PjYVxGGaZd669OJwD0CYyqH22HH9nFUGaoJdsv39ChW0NRdLE9+y8=-----END X509 CERTIFICATE-----issuer= /C=AU/ST=Queensland/O=CryptSoft Pty Ltd/CN=Test PCA (1024 bit)subject=/C=AU/ST=Queensland/O=CryptSoft Pty Ltd/CN=Test CA (1024 bit)-----BEGIN CERTIFICATE-----MIICJjCCAY8CAQAwDQYJKoZIhvcNAQEEBQAwXDELMAkGA1UEBhMCQVUxEzARBgNVBAgTClF1ZWVuc2xhbmQxGjAYBgNVBAoTEUNyeXB0U29mdCBQdHkgTHRkMRwwGgYDVQQDExNUZXN0IFBDQSAoMTAyNCBiaXQpMB4XDTk3MDYwOTEzNTc0M1oXDTAxMDYwOTEzNTc0M1owWzELMAkGA1UEBhMCQVUxEzARBgNVBAgTClF1ZWVuc2xhbmQxGjAYBgNVBAoTEUNyeXB0U29mdCBQdHkgTHRkMRswGQYDVQQDExJUZXN0IENBICgxMDI0IGJpdCkwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAKO7o8t116VP6cgybTsZDCZhr95nYlZuya3aCi1IKoztqwWnjbmDFIriOqGFPrZQ+moMETC9D59iRW/dFXSv1F65ka/XY2hLh9exCCo7XuUcDs53Qp3bI3AmMqHjgzE8oO3ajyJAzJkTTOUecQU2mw/gI4tMM0LqWMQS7luTy4+xAgMBAAEwDQYJKoZIhvcNAQEEBQADgYEAM7achv3vhLQJcv/65eGEpBXM40ZDVoFQFFJWaY5p883HTqLB1x4FdzsXHH0QKBTcKpWwqyu4YDm3fb8oDugw72bCzfyZK/zVZPR/hVlqI/fvU109Qoc+7oPvIXWky71HfcK6ZBCAq30KIqGM/uoM60INq97qjDmCJapagcNBGQs=-----END CERTIFICATE----------BEGIN RSA PRIVATE KEY-----MIICXQIBAAKBgQCju6PLddelT+nIMm07GQwmYa/eZ2JWbsmt2gotSCqM7asFp425gxSK4jqhhT62UPpqDBEwvQ+fYkVv3RV0r9ReuZGv12NoS4fXsQgqO17lHA7Od0Kd2yNwJjKh44MxPKDt2o8iQMyZE0zlHnEFNpsP4COLTDNC6ljEEu5bk8uPsQIDAQABAoGAVZmpFZsDZfr0l2S9tLLwpjRWNOlKATQkno6q2WesT0eGLQufTciY+c8ypfU6hyio8r5iUl/VhhdjhAtKx1mRpiotftHo/eYf8rtsrnprOnWG0bWjLjtIoMbcxGn2J3bN6LJmbJMjDs0eJ3KnTu646F3nDUw2oGAwmpzKXA1KAP0CQQDRvQhxk2D3PehsHvG665u2pB5ipYQngEFlZO7RHJZzJOZEWSLuuMqaF/7pTfA5jiBvWqCgJeCRRInL21ru4dlPAkEAx9jj7BgKn5TYnMoBSSe0afjsV9oApVpN1Nacb1YDtCwy+scp3++snFxlv98wxIlSdpwMUn+AUWfjiWR7Tu/G/wJBAJ/KjwZIrFVxewP0x2ILYsTRYLzzMS4PDsO7FB+I0i7DbBOifXS2oNSpd3I0CNMwrxFnUHzynpbOStVfN3ZL5w0CQQCapwFahxBRhkJKsxhjoFJBX9yl75JoY4Wvm5Tbo9ih6UJaRx3kqfkN14L2BKYcsZgbKY9vmDOYy6iNfjDeWTfJAkBkfPUb8oTJ/nSP5zN6sqGxSY4krc4xLxpRmxoJ8HL2XfhqXkTzbU13RX9JJ/NZ8vQN9Vm2NhxRGJocQkmcdVtJ-----END RSA PRIVATE KEY----------BEGIN X509 CERTIFICATE-----MIICYDCCAiACAgEoMAkGBSsOAwINBQAwfDELMAkGA1UEBhMCVVMxNjA0BgNVBAoTLU5hdGlvbmFsIEFlcm9uYXV0aWNzIGFuZCBTcGFjZSBBZG1pbmlzdHJhdGlvbjEZMBcGA1UECxMQVGVzdCBFbnZpcm9ubWVudDEaMBgGA1UECxMRRFNTLU5BU0EtUGlsb3QtQ0EwHhcNOTYwMjI2MTYzMjQ1WhcNOTcwMjI1MTYzMjQ1WjB8MQswCQYDVQQGEwJVUzE2MDQGA1UEChMtTmF0aW9uYWwgQWVyb25hdXRpY3MgYW5kIFNwYWNlIEFkbWluaXN0cmF0aW9uMRkwFwYDVQQLExBUZXN0IEVudmlyb25tZW50MRowGAYDVQQLExFEU1MtTkFTQS1QaWxvdC1DQTCB8jAJBgUrDgMCDAUAA4HkADCB4AJBAMA/ssKbhPNUG7ZlASfVwEJU21O5OyF/iyBzgHI1O8eOhJGUYO8cc8wDMjR508Mr9cp6Uhl/ZB7FV5GkLNEnRHYCQQDUEaSg45P2qrDwixTRhFhmWz5Nvc4lRFQ/42XPcchiJBLbbn3QK74T2IxY1yY+kCNq8XrIqf5fJJzIH0J/xUP3AhUAsg2wsQHfDGYk/BOSulX3fVd0geUCQQCzCFUQAh+ZkEmp5804cs6ZWBhrUAfnra8lJItYo9xPcXgdIfLfibcXR71UsyO77MRD7B0+Ag2tq794IleCVcEEMAkGBSsOAwINBQADLwAwLAIUUayDfreRYh2WeU86/pHNdkUC1IgCFEfxe1f0oMpxJyrJ5XIxTi7vGdoK-----END X509 CERTIFICATE----------BEGIN X509 CERTIFICATE-----MIICGTCCAdgCAwCqTDAJBgUrDgMCDQUAMHwxCzAJBgNVBAYTAlVTMTYwNAYDVQQKEy1OYXRpb25hbCBBZXJvbmF1dGljcyBhbmQgU3BhY2UgQWRtaW5pc3RyYXRpb24xGTAXBgNVBAsTEFRlc3QgRW52aXJvbm1lbnQxGjAYBgNVBAsTEURTUy1OQVNBLVBpbG90LUNBMB4XDTk2MDUxNDE3MDE0MVoXDTk3MDUxNDE3MDE0MVowMzELMAkGA1UEBhMCQVUxDzANBgNVBAoTBk1pbmNvbTETMBEGA1UEAxMKRXJpYyBZb3VuZzCB8jAJBgUrDgMCDAUAA4HkADCB4AJBAKbfHz6vE6pXXMTpswtGUec2tvnfLJUsoxE9qs4+ObZX7LmLvragNPUeiTJx7UOWZ5DfBj6bXLc8eYne0lP1g3ACQQDUEaSg45P2qrDwixTRhFhmWz5Nvc4lRFQ/42XPcchiJBLbbn3QK74T2IxY1yY+kCNq8XrIqf5fJJzIH0J/xUP3AhUAsg2wsQHfDGYk/BOSulX3fVd0geUCQQCzCFUQAh+ZkEmp5804cs6ZWBhrUAfnra8lJItYo9xPcXgdIfLfibcXR71UsyO77MRD7B0+Ag2tq794IleCVcEEMAkGBSsOAwINBQADMAAwLQIUWsuuJRE3VT4ueWkWMAJMJaZjj1ECFQCYY0zX4bzMLC7obsrHD8XAHG+ZRG==-----END X509 CERTIFICATE----------BEGIN CERTIFICATE-----MIICTTCCAbagAwIBAgIBADANBgkqhkiG9w0BAQQFADBMMQswCQYDVQQGEwJHQjEMMAoGA1UEChMDVUNMMRgwFgYDVQQLEw9JQ0UtVEVMIFByb2plY3QxFTATBgNVBAMTDFRydXN0RmFjdG9yeTAeFw05NzA0MjIxNDM5MTRaFw05ODA0MjIxNDM5MTRaMEwxCzAJBgNVBAYTAkdCMQwwCgYDVQQKEwNVQ0wxGDAWBgNVBAsTD0lDRS1URUwgUHJvamVjdDEVMBMGA1UEAxMMVHJ1c3RGYWN0b3J5MIGcMAoGBFUIAQECAgQAA4GNADCBiQKBgQCEieR8NcXkUW1f0G6aC6u0i8q/98JqS6RxK5YmHIGKCkuTWAUjzLfUa4dtU9igGCjTuxaDqlzEim+t/02pmiBZT9HaX++35MjQPUWmsChcYU5WyzGErXi+rQawzlwS73zM8qiPj/97lXYycWhgL0VaiDSPxRXEUdWoaGruom4mNQIDAQABo0IwQDAdBgNVHQ4EFgQUHal1LZr7oVg5z6lYzrhTgZRCmcUwDgYDVR0PAQH/BAQDAgH2MA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQEEBQADgYEAfaggfl6FZoioecjv0dq8/DXo/u11iMZvXn08gjX/zl2b4wtPbShOSY5FhkSm8GeySasz+/Nwb/uzfnIhokWilfPZHtlCWtXbIy/TN51eJyq04ceDCQDWvLC2enVg9KB+GJ34b5c5VaPRzq8MBxsAS7ELuYGtmYgYm9NZOIr7yU0=-----END CERTIFICATE----------BEGIN CERTIFICATE-----MIIB6jCCAZQCAgEtMA0GCSqGSIb3DQEBBAUAMIGAMQswCQYDVQQGEwJVUzE2MDQGA1UEChMtTmF0aW9uYWwgQWVyb25hdXRpY3MgYW5kIFNwYWNlIEFkbWluaXN0cmF0aW9uMRkwFwYDVQQLExBUZXN0IEVudmlyb25tZW50MR4wHAYDVQQLExVNRDUtUlNBLU5BU0EtUGlsb3QtQ0EwHhcNOTYwNDMwMjIwNTAwWhcNOTcwNDMwMjIwNTAwWjCBgDELMAkGA1UEBhMCVVMxNjA0BgNVBAoTLU5hdGlvbmFsIEFlcm9uYXV0aWNzIGFuZCBTcGFjZSBBZG1pbmlzdHJhdGlvbjEZMBcGA1UECxMQVGVzdCBFbnZpcm9ubWVudDEeMBwGA1UECxMVTUQ1LVJTQS1OQVNBLVBpbG90LUNBMFkwCgYEVQgBAQICAgADSwAwSAJBALmmX5+GqAvcrWK13rfDrNX9UfeA7f+ijyBgeFQjYUoDpFqapw4nzQBLbAXug8pKkRwa2Zh8YODhXsRWu2F/UckCAwEAATANBgkqhkiG9w0BAQQFAANBAH9aOBA+QCsjxXgnSqHx04gcU8S49DVUb1f2XVoLnHlIb8RnX0k5O6mpHT5eti9bLkiWGJNMJ4L0AJ/ac+SmHZc=-----END CERTIFICATE-----'</body><body package="X509" selector="test1">test1	"self test1"	| stream |	stream := self examplePEMcontents readStream.	^self new readFromStream: stream</body></methods><methods><class-id>Security.X509CertificateFileReader class</class-id> <category>reading</category><body package="X509" selector="readCertificatesFrom:">readCertificatesFrom: aFilename	"self readCertificatesFrom: 'd:\encryptionCommon\demo.pem'"	| stream1 stream2 |	[stream1 := aFilename asFilename readStream .	stream2 := stream1 contents readStream] ensure:[	stream1 close].	^self new readFromStream: stream2</body></methods><methods><class-id>Security.X509Object</class-id> <category>initialize</category><body package="X509" selector="initialize:">initialize: anASN1Value 	self subclassResponsibility</body><body package="X509" selector="initializeFromAnASN1Type:">initializeFromAnASN1Type: anASN1Type	self subclassResponsibility</body></methods><methods><class-id>Security.X509Object class</class-id> <category>instance creation</category><body package="X509" selector="fromASN1Type:">fromASN1Type: anASN1Type	^self new initializeFromAnASN1Type: anASN1Type</body><body package="X509" selector="fromASN1Value:">fromASN1Value: anASN1Value 	^self new initialize: anASN1Value</body></methods><methods><class-id>Security.X509AccessDescription</class-id> <category>accessing</category><body package="X509" selector="accessLocation">accessLocation	^accessLocation</body><body package="X509" selector="accessLocation:">accessLocation: anObject	accessLocation := anObject</body><body package="X509" selector="accessMethod">accessMethod	^accessMethod</body><body package="X509" selector="accessMethod:">accessMethod: anObject	accessMethod := anObject</body></methods><methods><class-id>Security.X509Validity</class-id> <category>accessing</category><body package="X509" selector="notAfter">notAfter	" a timeStamp made from the ans1 type in UTC format"	^notAfter</body><body package="X509" selector="notAfterDate">notAfterDate	"date component of notAfter"	^ notAfter asDate</body><body package="X509" selector="notAfterTime">notAfterTime	"time component of notAfter"	^notAfter asTime.</body><body package="X509" selector="notBefore">notBefore	" a timeStamp made from the ans1 type in UTC format"	^notBefore</body><body package="X509" selector="notBeforeDate">notBeforeDate	"date component of notBefore"	^notBefore asDate.</body><body package="X509" selector="notBeforeTime">notBeforeTime	"time component of notBefore" 	^notBefore asTime.</body></methods><methods><class-id>Security.X509Validity</class-id> <category>initialize release</category><body package="X509" selector="initializeFromAnASN1Type:">initializeFromAnASN1Type: anASN1Type 	"Extracts 'notBefore' and 'notAfter' "	asnValidityType := anASN1Type.	notBefore := anASN1Type notBefore .	notAfter := anASN1Type notAfter</body></methods><methods><class-id>Security.X509Validity class</class-id> <category>instance creation</category><body package="X509" selector="fromASN1Value:">fromASN1Value: anASN1Value	^self new initialize: anASN1Value</body></methods><methods><class-id>Security.X509DigestInfo</class-id> <category>accessing</category><body package="X509" selector="digest">digest	^digest</body><body package="X509" selector="digestAlgorithm">digestAlgorithm	^digestAlgorithm</body><body package="X509" selector="sequence">sequence	^sequence</body></methods><methods><class-id>Security.X509DigestInfo class</class-id> <category>instance creation</category><body package="X509" selector="fromASN1Value:">fromASN1Value: anASN1Value 	^self new initialize: anASN1Value</body></methods><methods><class-id>Security.X509NoticeReference</class-id> <category>accessing</category><body package="X509" selector="noticeNumbers">noticeNumbers	^noticeNumbers</body><body package="X509" selector="noticeNumbers:">noticeNumbers: anObject	noticeNumbers := anObject</body><body package="X509" selector="organization">organization	^organization</body><body package="X509" selector="organization:">organization: anObject	organization := anObject</body></methods><methods><class-id>Security.X509SubjectPublicKeyInfo</class-id> <category>accessing</category><body package="X509" selector="algorithm">algorithm	"algorithm used to sign the public key"	^algorithm</body><body package="X509" selector="getPublicKey">getPublicKey	^ publicKey getKey</body><body package="X509" selector="getRSAPublicKey">getRSAPublicKey^  RSAPublicKey e: self getX509RSAPublicKey e  n: self getX509RSAPublicKey n</body><body package="X509" selector="getX509DSAPublicKey">getX509DSAPublicKey| inst |	inst := X509DSAPublicKey fromASN1Type: subjectPublicKey.	algorithm parameters notNil ifTrue:[	inst dssParameters: (X509DSSParameters fromASN1Type: algorithm parameters)] .	^inst</body><body package="X509" selector="getX509RSAPublicKey">getX509RSAPublicKey	^X509RSAPublicKey fromASN1Type: subjectPublicKey</body><body package="X509" selector="publicKey">publicKey	"subject's public key"	^publicKey</body><body package="X509" selector="subjectPublicKey">subjectPublicKey	"subject's public key"	^subjectPublicKey</body></methods><methods><class-id>Security.X509SubjectPublicKeyInfo</class-id> <category>initialize</category><body package="X509" selector="initializeFromAnASN1Type:">initializeFromAnASN1Type: anASN1Type algorithm := X509AlgorithmIdentifier fromASN1Type: anASN1Type algorithm .subjectPublicKey := anASN1Type subjectPublicKey.self initializePublicKey.</body><body package="X509" selector="initializePublicKey">initializePublicKey	" right now we assumethe keys are rsaEncryption Keys. later I need to check for the algorithm and instantiate the right key for whichever Algorithm"	(X509RSASignatureVerification oidCollection includes: self algorithm getOIDSymbol) ifTrue:[ ^publicKey := self getX509RSAPublicKey].(X509DSASignatureVerification oidCollection includes: self algorithm getOIDSymbol)  ifTrue:[^publicKey :=  self getX509DSAPublicKey]."don't have the public key for this algorithm implemented so just place the ASN value into the instance variable, note will will further the implementation to include others"publicKey := subjectPublicKey.</body></methods><methods><class-id>Security.X509SubjectPublicKeyInfo</class-id> <category>printing</category><body package="X509" selector="printOpenSSLOn:indent:">printOpenSSLOn: aStream indent: level"This should print the key info in the format used by OpenSSL"	aStream		tab: level; nextPutAll: (#PubKeyAlgPrefix &lt;&lt; #security &gt;&gt; 'Public Key Algorithm: ') asString;			nextPutAll: algorithm getOIDDescription; cr.	publicKey printOpenSSLOn: aStream indent: level</body></methods><methods><class-id>Security.X509SubjectPublicKeyInfo class</class-id> <category>instance creation</category><body package="X509" selector="fromASN1Value:">fromASN1Value: anASN1Value 	^self new initialize: anASN1Value</body></methods><methods><class-id>Security.X509DSSSignatureValue</class-id> <category>accessing</category><body package="X509" selector="getSignature">getSignature	^DSASignature r: r  s: s</body><body package="X509" selector="marshaller">marshaller	^marshaller isNil ifTrue:[ marshaller := ( ASN1.Asn1StreamDER on: ( ByteArray new: 4096 ) ) maxReadLimit.] ifFalse:[marshaller]</body><body package="X509" selector="marshaller:">marshaller: anObject	marshaller := anObject</body><body package="X509" selector="r">r^r</body><body package="X509" selector="rawData">rawData	^rawData</body><body package="X509" selector="rawData:">rawData: anObject	rawData := anObject</body><body package="X509" selector="s">s^s</body></methods><methods><class-id>Security.X509DSSSignatureValue</class-id> <category>initialize</category><body package="X509" selector="initializeFromAnASN1Type:">initializeFromAnASN1Type: anASN1Type	| resultObject |"sequence of two integers r and s"	self rawData: anASN1Type  value value.	self rawData do: [ :x | self marshaller nextPut: x ].	self marshaller setReadLimit: self marshaller position.	self marshaller position: 0.	self marshaller  retainEncodings: true.	resultObject := self marshaller  unmarshalObjectType: ( ASN1.Asn1Type findTypeNamed: #DSSSignature ).	r := resultObject r value.	s :=  resultObject s value</body></methods><methods><class-id>Security.X509DSSSignatureValue class</class-id> <category>instance creation</category><body package="X509" selector="fromASN1Value:">fromASN1Value: anASN1Value 	^self new initialize: anASN1Value</body></methods><methods><class-id>Security.X509DSSSignatureValue class</class-id> <category>accessing</category><body package="X509" selector="oidCollection">oidCollection	^#()</body></methods><methods><class-id>Security.X509DisplayText</class-id> <category>accessing</category><body package="X509" selector="text">text	^text</body><body package="X509" selector="text:">text: anObject	text := anObject</body></methods><methods><class-id>Security.X509GeneralName</class-id> <category>accessing</category><body package="X509" selector="directoryName">directoryName	^directoryName</body><body package="X509" selector="directoryName:">directoryName: anObject	directoryName := anObject</body><body package="X509" selector="dnsName">dnsName	^dnsName</body><body package="X509" selector="dnsName:">dnsName: anObject	dnsName := anObject</body><body package="X509" selector="ediPartyName">ediPartyName	^ediPartyName</body><body package="X509" selector="ediPartyName:">ediPartyName: anObject	ediPartyName := anObject</body><body package="X509" selector="ipAddress">ipAddress	^ipAddress</body><body package="X509" selector="ipAddress:">ipAddress: anObject	ipAddress := anObject</body><body package="X509" selector="otherName">otherName	^otherName</body><body package="X509" selector="otherName:">otherName: anObject	otherName := anObject</body><body package="X509" selector="registerID">registerID	^registerID</body><body package="X509" selector="registerID:">registerID: anObject	registerID := anObject</body><body package="X509" selector="rfc822Name">rfc822Name	^rfc822Name</body><body package="X509" selector="rfc822Name:">rfc822Name: anObject	rfc822Name := anObject</body><body package="X509" selector="uniformResourceIdentifier">uniformResourceIdentifier	^uniformResourceIdentifier</body><body package="X509" selector="uniformResourceIdentifier:">uniformResourceIdentifier: anObject	uniformResourceIdentifier := anObject</body><body package="X509" selector="x400Address">x400Address	^x400Address</body><body package="X509" selector="x400Address:">x400Address: anObject	x400Address := anObject</body></methods><methods><class-id>Security.X509GeneralSubtree</class-id> <category>accessing</category><body package="X509" selector="base">base	^base</body><body package="X509" selector="base:">base: anObject	base := anObject</body><body package="X509" selector="maximum">maximum	^maximum</body><body package="X509" selector="maximum:">maximum: anObject	maximum := anObject</body><body package="X509" selector="minimun">minimun	^minimun</body><body package="X509" selector="minimun:">minimun: anObject	minimun := anObject</body></methods><methods><class-id>Security.X509Qualifier</class-id> <category>accessing</category><body package="X509" selector="cpSuri">cpSuri	^cpSuri</body><body package="X509" selector="cpSuri:">cpSuri: anObject	cpSuri := anObject</body><body package="X509" selector="userNotice">userNotice	^userNotice</body><body package="X509" selector="userNotice:">userNotice: anObject	userNotice := anObject</body></methods><methods><class-id>Security.X509AttributeValueAssertion</class-id> <category>accessing</category><body package="X509" selector="asnType">asnType	"Answers the Asn Type component from which the type and value were derived type/value pair"	^asnType</body><body package="X509" selector="type">type	"Answers the type component of the type/value pair"	^type</body><body package="X509" selector="value">value	"Answers the value component of the type/value pair"	^value</body></methods><methods><class-id>Security.X509AttributeValueAssertion</class-id> <category>initialize</category><body package="X509" selector="initializeFromAnASN1Type:">initializeFromAnASN1Type: anASN1Type 	asnType := anASN1Type value.	type := asnType type value.	value := asnType value</body></methods><methods><class-id>Security.X509AttributeValueAssertion class</class-id> <category>instance creation</category><body package="X509" selector="fromASN1Value:">fromASN1Value: anASN1Value 	^self new initialize: anASN1Value</body></methods><methods><class-id>Security.X509UnknownPublicKey</class-id> <category>accessing</category><body package="X509" selector="marshaller">marshaller	^marshaller isNil ifTrue:[ marshaller := ( ASN1.Asn1StreamDER on: ( ByteArray new: 4096 ) ) maxReadLimit.] ifFalse:[marshaller]</body><body package="X509" selector="marshaller:">marshaller: anObject	marshaller := anObject</body><body package="X509" selector="rawData">rawData	^rawData</body><body package="X509" selector="rawData:">rawData: anObject	rawData := anObject</body></methods><methods><class-id>Security.X509RSAPublicKey</class-id> <category>accessing</category><body package="X509" selector="e">e	^e</body><body package="X509" selector="getKey">getKey	^ self class keyClass  e:  e  n: n</body><body package="X509" selector="n">n	^n</body></methods><methods><class-id>Security.X509RSAPublicKey</class-id> <category>initialize</category><body package="X509" selector="initializeFromAnASN1Type:">initializeFromAnASN1Type: anASN1Type	|  |	self rawData: anASN1Type value value.	self rawData do: [ :x | self marshaller nextPut: x ].	self marshaller setReadLimit: self marshaller position.	self marshaller position: 0.	self marshaller  retainEncodings: true.	resultObject := self marshaller  unmarshalObjectType: ( ASN1.Asn1Type findTypeNamed: #RSAPublicKey ).	n := resultObject modulus value.	e := resultObject publicExponent value.</body></methods><methods><class-id>Security.X509RSAPublicKey</class-id> <category>printing</category><body package="X509" selector="printOpenSSLOn:indent:">printOpenSSLOn: aStream indent: level"This should print the key in the format used by OpenSSL"	| keySize nArray |	nArray :=  n asBigEndianByteArray.	keySize :=nArray  size * 8.	aStream		tab: level; nextPutAll: (#RSAPubKeyPrefix &lt;&lt; #security &gt;&gt; 'RSA Public Key: (') asString;		print: keySize; nextPutAll: (#BitsSuffix &lt;&lt; #security &gt;&gt; ' bits)') asString; cr;		tab: level + 1; nextPutAll: (#ModulusPrefix &lt;&lt; #security &gt;&gt; 'Modulus (') asString;		print: nArray size * 8; nextPutAll: (#BitSuffix &lt;&lt; #security &gt;&gt; ' bit)') asString; nextPut: $:; cr.	(#[0], nArray) printOpenSSLOn: aStream indent: level + 2 width: 15.	aStream tab: level + 1; nextPutAll: (#ExponentPrefix &lt;&lt; #security &gt;&gt; 'Exponent: ') asString;		print: e ; nextPutAll: ' (0x'.	e  printOn: aStream base: 16.	aStream nextPut: $); cr</body></methods><methods><class-id>Security.X509RSAPublicKey class</class-id> <category>constants</category><body package="X509" selector="keyClass">keyClass	^RSAPublicKey</body></methods><methods><class-id>Security.X509RSAPublicKey class</class-id> <category>instance creation</category><body package="X509" selector="fromASN1Value:">fromASN1Value: anASN1Value 	^self new initialize: anASN1Value</body></methods><methods><class-id>Security.X509DSAPublicKey</class-id> <category>accessing</category><body package="X509" selector="dssParameters">dssParameters	^dssParameters</body><body package="X509" selector="dssParameters:">dssParameters: anObject	dssParameters := anObject</body><body package="X509" selector="getKey">getKey	^dssParameters notNil ifTrue:[ DSAPublicKey  p: dssParameters p  q: dssParameters q  g: dssParameters g  y: publicKey ] ifFalse:[DSAPublicKey  p: nil  q: nil  g: nil  y: publicKey  ]</body><body package="X509" selector="publicKey">publicKey	^publicKey</body></methods><methods><class-id>Security.X509DSAPublicKey</class-id> <category>printing</category><body package="X509" selector="printOpenSSLOn:indent:">printOpenSSLOn: aStream indent: level"This should print the key in the format used by OpenSSL"	aStream		tab: level; nextPutAll: (#DSAPubKeyPrefix &lt;&lt; #security &gt;&gt; 'DSA Public Key:') asString; cr;		tab: level + 1; nextPutAll: (#pubPrefix &lt;&lt; #security &gt;&gt; 'pub:') asString; cr.	y printOpenSSLOn: aStream indent: level + 2 width: 15.	aStream		tab: level + 1; nextPutAll: (#PPrefix &lt;&lt; #security &gt;&gt; 'P:') asString; cr.	dssParameters p printOpenSSLOn: aStream indent: level + 2 width: 15.	aStream		tab: level + 1; nextPutAll: (#QPrefix &lt;&lt; #security &gt;&gt; 'Q:') asString; cr.	dssParameters q printOpenSSLOn: aStream indent: level + 2 width: 15.	aStream		tab: level + 1; nextPutAll: (#GPrefix &lt;&lt; #security &gt;&gt; 'G:') asString; cr.	dssParameters g printOpenSSLOn: aStream indent: level + 2 width: 15.</body></methods><methods><class-id>Security.X509DSAPublicKey</class-id> <category>initialize</category><body package="X509" selector="initializeFromAnASN1Type:">initializeFromAnASN1Type: anASN1Type	"get the Public Key Y"	self rawData: anASN1Type  value value.	self rawData do: [ :x | self marshaller nextPut: x ].	self marshaller setReadLimit: self marshaller position.	self marshaller position: 0.	self marshaller  retainEncodings: true.	resultObject := self marshaller  unmarshalObjectType: ( ASN1.Asn1Type findTypeNamed: #DSA_PublicKey ).	publicKey := resultObject value</body></methods><methods><class-id>Security.X509DSAPublicKey class</class-id> <category>instance creation</category><body package="X509" selector="fromASN1Value:">fromASN1Value: anASN1Value 	^self new initialize: anASN1Value</body></methods><methods><class-id>Security.X509ReasonFlags</class-id> <category>accessing</category><body package="X509" selector="affiliationChanged">affiliationChanged	^affiliationChanged</body><body package="X509" selector="affiliationChanged:">affiliationChanged: anObject	affiliationChanged := anObject</body><body package="X509" selector="caCompromise">caCompromise	^caCompromise</body><body package="X509" selector="caCompromise:">caCompromise: anObject	caCompromise := anObject</body><body package="X509" selector="certificateHold">certificateHold	^certificateHold</body><body package="X509" selector="certificateHold:">certificateHold: anObject	certificateHold := anObject</body><body package="X509" selector="cessationOFOperation">cessationOFOperation	^cessationOFOperation</body><body package="X509" selector="cessationOFOperation:">cessationOFOperation: anObject	cessationOFOperation := anObject</body><body package="X509" selector="keyCompromise">keyCompromise	^keyCompromise</body><body package="X509" selector="keyCompromise:">keyCompromise: anObject	keyCompromise := anObject</body><body package="X509" selector="superseded">superseded	^superseded</body><body package="X509" selector="superseded:">superseded: anObject	superseded := anObject</body><body package="X509" selector="unused">unused	^unused</body><body package="X509" selector="unused:">unused: anObject	unused := anObject</body></methods><methods><class-id>Security.X509Name</class-id> <category>printing</category><body package="X509" selector="printOpenSSLOn:indent:">printOpenSSLOn: aStream indent: level"This should print the certificate in the format used by OpenSSL"	aStream tab: level.	self getRDN		do: [ :ava |			aStream				nextPutAll: (ava type getShortOIDDescription);				nextPut: $=;				nextPutAll: ava value value ]		separatedBy: [ aStream nextPutAll: ', ' ]</body><body package="X509" selector="printOpenSSLString">printOpenSSLString"This should print the certificate in the format used by OpenSSL"	| ws |	ws := WriteStream on: (String new: 100).	self printOpenSSLOn: ws indent: 0.	^ws contents</body></methods><methods><class-id>Security.X509Name</class-id> <category>accessing</category><body package="X509" selector="getDNBytes">getDNBytes	"return the raw bytes"	^rawData</body><body package="X509" selector="getRDN">getRDN	"OrderedCollection containing the RDN attribute/value pairs"	^relativeDistinguishedName</body></methods><methods><class-id>Security.X509Name</class-id> <category>ssl</category><body package="X509" selector="asAssociations">asAssociations"Return an ordered collection of associations. It compares better than the dictionary an I am still not sure if the order is relevant or not. Dictionary is handy for other cases."	^self getRDN collect: [ :ava || oid |		oid := ava type getDottedOID.		(OIDToDescription at: oid ifAbsent: [ oid ])			-&gt; ava value value ].</body><body package="X509" selector="asDictionary">asDictionary	| dict |	dict := Dictionary new.	self getRDN do: [ :ava || oid |		oid := ava type getDottedOID.		dict			at: (OIDToDescription at: oid ifAbsent: [ oid ])			put: ava value value ].	^dict</body></methods><methods><class-id>Security.X509Name</class-id> <category>initialize</category><body package="X509" selector="initializeFromAnASN1Type:">initializeFromAnASN1Type: anASN1Type 	rawData := anASN1Type encoding fullEncoding.	relativeDistinguishedName :=  OrderedCollection new.	 anASN1Type do: [ :name |		name value do: [ :ava |			relativeDistinguishedName add: (X509AttributeValueAssertion fromASN1Type: ava) ] ]</body></methods><methods><class-id>Security.X509Name class</class-id> <category>instance creation</category><body package="X509" selector="fromASN1Value:">fromASN1Value: anASN1Value 	^self new initialize: anASN1Value</body></methods><methods><class-id>Security.X509Name class</class-id> <category>ssl</category><body package="X509" selector="buildOIDToDescription">buildOIDToDescription	^Dictionary new		at: '2.5.4.10' put: 'O';	"organization"		at: '2.5.4.11' put: 'OU';	"organization unit"		at: '2.5.4.3' put: 'CN';	"common name"		at: '2.5.4.6' put: 'C';		"country"		at: '2.5.4.7' put: 'L';		"locality"		at: '2.5.4.8' put: 'S';		"state or province"		yourself</body></methods><methods><class-id>Security.X509DistinguishedName</class-id> <category>accessing</category><body package="X509" selector="getDN">getDN	^distinguishedName</body></methods><methods><class-id>Security.X509DSSParameters</class-id> <category>accessing</category><body package="X509" selector="g">g^g</body><body package="X509" selector="getg">getg^g</body><body package="X509" selector="getp">getp^p</body><body package="X509" selector="getq">getq^q</body><body package="X509" selector="p">p^p</body><body package="X509" selector="q">q^q</body></methods><methods><class-id>Security.X509DSSParameters</class-id> <category>initialize</category><body package="X509" selector="initializeFromAnASN1Type:">initializeFromAnASN1Type: anASN1Type	p := (anASN1Type value at: 1) value .	q := (anASN1Type value at: 2) value .	g := (anASN1Type value at: 3) value .</body></methods><methods><class-id>Security.X509DSSParameters class</class-id> <category>instance creation</category><body package="X509" selector="fromASN1Value:">fromASN1Value: anASN1Value 	^self new initialize: anASN1Value</body></methods><methods><class-id>Security.X509UnknownPrivateKey</class-id> <category>accessing</category><body package="X509" selector="encodedString">encodedString	^encodedString</body><body package="X509" selector="encodedString:">encodedString: anEncodedString	encodedString := anEncodedString</body><body package="X509" selector="marshaller">marshaller	^marshaller isNil ifTrue:[ marshaller := ( ASN1.Asn1StreamDER on: ( ByteArray new: 4096 ) ) maxReadLimit.] ifFalse:[marshaller]</body><body package="X509" selector="marshaller:">marshaller: anObject	marshaller := anObject</body><body package="X509" selector="rawData">rawData	^rawData</body><body package="X509" selector="rawData:">rawData: anObject	rawData := anObject</body></methods><methods><class-id>Security.X509UnknownPrivateKey</class-id> <category>initialization</category><body package="X509" selector="getPrivateKeyData">getPrivateKeyData	self subclassResponsibility</body><body package="X509" selector="initialize:">initialize: anASN1Value 	self subclassResponsibility</body><body package="X509" selector="initializeFromBytes:">initializeFromBytes: aByteArray	privateKeyByteArray := aByteArray.	^self parse</body><body package="X509" selector="initializeFromString:">initializeFromString: aString	| s |	encodedPrivateKey := aString.	s := self getPrivateKeyData.	s isNil ifTrue: [^nil].	^self initializeFromBytes:(self decodeBase64: s copy)</body><body package="X509" selector="parse">parse	^self initializeFromByteArray: (privateKeyByteArray )</body></methods><methods><class-id>Security.X509UnknownPrivateKey</class-id> <category>utilities</category><body package="X509" selector="decodeBase64:">decodeBase64: aString	| input stream output char |	input := aString asByteArray readStream.	stream := EncodedStream on: input encodedBy: Net.Base64StreamEncoder asEncoder.	output := (ByteArray new: 64) writeStream.	[ (char := stream next) notNil ] whileTrue: [ output nextPut: char ].	^output contents</body></methods><methods><class-id>Security.X509UnknownPrivateKey class</class-id> <category>accessing</category><body package="X509" selector="keyClasses">keyClasses	^self subclasses</body></methods><methods><class-id>Security.X509UnknownPrivateKey class</class-id> <category>instance creation</category><body package="X509" selector="fromString:">fromString: aString	^self new initializeFromString: aString</body><body package="X509" selector="readAndReturnSomeKeyFrom:">readAndReturnSomeKeyFrom: aString	"try To determine which key can read this if non return myself with the striing in my inst var"		| keyClass |	keyClass := self keyClasses detect:[:each |  each canReadKey: aString] ifNone:[self].	^keyClass fromString: aString</body></methods><methods><class-id>Security.X509RSAPrivateKey</class-id> <category>accessing</category><body package="X509" selector="coefficient">coefficient	^coefficient</body><body package="X509" selector="coefficientTi">coefficientTi	^coefficientTi</body><body package="X509" selector="d">d	^d</body><body package="X509" selector="e">e	^e</body><body package="X509" selector="exponent1">exponent1	^exponent1</body><body package="X509" selector="exponent2">exponent2	^exponent2</body><body package="X509" selector="exponentDi">exponentDi	^exponentDi</body><body package="X509" selector="getKey">getKey	^ self class keyClass  newFromX509RSAPrivateKey: self</body><body package="X509" selector="n">n	^n</body><body package="X509" selector="otherPrimInfos">otherPrimInfos	^otherPrimInfos</body><body package="X509" selector="p">p	^p</body><body package="X509" selector="primeRi">primeRi	^primeRi</body><body package="X509" selector="q">q	^q</body><body package="X509" selector="version">version	^version</body></methods><methods><class-id>Security.X509RSAPrivateKey</class-id> <category>initialization</category><body package="X509" selector="getPrivateKeyData">getPrivateKeyData	"Answers true if the Base64 encoded Private Key has the appropriate delimiters required for PEM 	format; otherwise, answers nil"	| i j k |	i := encodedPrivateKey				indexOfSubCollection: '--BEGIN '				startingAt: 1				ifAbsent: [^nil].	i := encodedPrivateKey				indexOfSubCollection: 'RSA PRIVATE KEY--'				startingAt: i				ifAbsent: [^nil].	j := encodedPrivateKey				indexOfSubCollection: '--END '				startingAt: i				ifAbsent: [^nil].	k := encodedPrivateKey				indexOfSubCollection: 'RSA PRIVATE KEY--'				startingAt: j				ifAbsent: [^nil].	i := (encodedPrivateKey findEither: Character cr or: Character lf from: i to: k).	^(encodedPrivateKey copyFrom: i to: j)		reject: [:c | c = $- or: [c isSeparator]]</body><body package="X509" selector="initializeFromByteArray:">initializeFromByteArray: aByteArray 	| resultObject |	self rawData: aByteArray.	self rawData do: [:z | self marshaller nextPut: z].	self marshaller setReadLimit: self marshaller position.	self marshaller position: 0.	self marshaller retainEncodings: true.	resultObject := self marshaller 				unmarshalObjectType: (ASN1.Asn1Type findTypeNamed: #RSAPrivateKey).	version := resultObject version value.	n := resultObject modulus value.	e := resultObject publicExponent value.	d := resultObject privateExponent value.	p := resultObject prime1 value.	q := resultObject prime2 value.	exponent1 := resultObject exponent1 value.	exponent2 := resultObject exponent2 value.	coefficient := resultObject coefficient value.	(resultObject value includesKey: #otherPrimeInfos) 		ifTrue: 			[otherPrimInfos := resultObject otherPrimeInfos value.			coefficientTi := otherPrimInfos otherPrimeInfo coefficient.			exponentDi := otherPrimInfos otherPrimeInfo exponent.			primeRi := otherPrimInfos otherPrimeInfo prime]</body></methods><methods><class-id>Security.X509RSAPrivateKey class</class-id> <category>examplePrivateKeys</category><body package="X509" selector="example1">example1^'-----BEGIN RSA PRIVATE KEY-----MIIBPAIBAAJBAJ+zw4Qnlf8SMVIPFe9GEcStgOY2Ww/dgNdhjeD8ckUJNP5VZkVDTGiXav6ooKXfX3j/7tdkuD8Ey2//Kv7+ue0CAwEAAQJAN6W31vDEP2DjdqhzCDDuOA4NACqoiFqyblo7yc2tM4h4xMbC3Yx5UKMN9ZkCtX0gzrz6DyF47bdKcWBzNWCjgQIhANEoojVt7hq+SQ6MCN6FTAysGgQf56Q3TYoJMoWvdiXVAiEAw3e3rc+VJpOzrHuDo6bgpjUAAXM+v3fcpsfZSNO6V7kCIQCtbVjanpUwvZkMI9by02oUk9taki3bPzPfAfNPYAbCJQIhAJXNQDWyqwn/lGmR11cqY2y9nZ1+5w3yHGatLrcDnQHxAiEAvnlEGo8K85u+KwIOimM48ZG8oTk7iFdkqLJR1utT3aU=-----END RSA PRIVATE KEY-----'</body><body package="X509" selector="example1TestCertificate">example1TestCertificate^'-----BEGIN CERTIFICATE-----MIIB6TCCAVICAQQwDQYJKoZIhvcNAQEEBQAwWzELMAkGA1UEBhMCQVUxEzARBgNVBAgTClF1ZWVuc2xhbmQxGjAYBgNVBAoTEUNyeXB0U29mdCBQdHkgTHRkMRswGQYDVQQDExJUZXN0IENBICgxMDI0IGJpdCkwHhcNOTgwNjI5MjM1MjQwWhcNMDAwNjI4MjM1MjQwWjBjMQswCQYDVQQGEwJBVTETMBEGA1UECBMKUXVlZW5zbGFuZDEaMBgGA1UEChMRQ3J5cHRTb2Z0IFB0eSBMdGQxIzAhBgNVBAMTGlNlcnZlciB0ZXN0IGNlcnQgKDUxMiBiaXQpMFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAJ+zw4Qnlf8SMVIPFe9GEcStgOY2Ww/dgNdhjeD8ckUJNP5VZkVDTGiXav6ooKXfX3j/7tdkuD8Ey2//Kv7+ue0CAwEAATANBgkqhkiG9w0BAQQFAAOBgQCVvvfkGSe2GHgDFfmOua4Isjb9JVhImWMASiOClkZlMESDJjsszg/6+d/W+8TrbObhazpl95FivXBVucbj9dudh7AOIZu1h1MAPlyknc9Ud816vz3FejB4qqUoaXjnlkrIgEbr/un7jSS86WOe0hRhwHkJFUGcPZf9ND22Etc+AQ==-----END CERTIFICATE-----'</body></methods><methods><class-id>Security.X509RSAPrivateKey class</class-id> <category>constants</category><body package="X509" selector="keyClass">keyClass	^RSAPrivateKey</body></methods><methods><class-id>Security.X509RSAPrivateKey class</class-id> <category>testing</category><body package="X509" selector="canReadKey:">canReadKey: encodedPrivateKey 	^(encodedPrivateKey		indexOfSubCollection: 'DSA PRIVATE KEY--'		startingAt: 1		ifAbsent: [nil]) notNil</body><body package="X509" selector="test1">test1	"self test1"	| inst |	inst := X509Certificate fromString: self example1TestCertificate.	Transcript show: inst getFormattedCertificate; cr.	^inst -&gt;(self fromString: self example1)</body></methods><methods><class-id>Security.X509PolicyQualifierInfo</class-id> <category>accessing</category><body package="X509" selector="policyQualifierID">policyQualifierID	^policyQualifierID</body><body package="X509" selector="policyQualifierID:">policyQualifierID: anObject	policyQualifierID := anObject</body><body package="X509" selector="qualifier">qualifier	^qualifier</body><body package="X509" selector="qualifier:">qualifier: anObject	qualifier := anObject</body></methods><methods><class-id>Security.X509DistributionName</class-id> <category>accessing</category><body package="X509" selector="fullName">fullName	^fullName</body><body package="X509" selector="fullName:">fullName: anObject	fullName := anObject</body><body package="X509" selector="nameRelativeToCRLIssuer">nameRelativeToCRLIssuer	^nameRelativeToCRLIssuer</body><body package="X509" selector="nameRelativeToCRLIssuer:">nameRelativeToCRLIssuer: anObject	nameRelativeToCRLIssuer := anObject</body></methods><methods><class-id>Security.X509DistributionPoints</class-id> <category>accessing</category><body package="X509" selector="crlIssuer">crlIssuer	^crlIssuer</body><body package="X509" selector="crlIssuer:">crlIssuer: anObject	crlIssuer := anObject</body><body package="X509" selector="distributionPoint">distributionPoint	^distributionPoint</body><body package="X509" selector="distributionPoint:">distributionPoint: anObject	distributionPoint := anObject</body><body package="X509" selector="reasons">reasons	^reasons</body><body package="X509" selector="reasons:">reasons: anObject	reasons := anObject</body></methods><methods><class-id>Security.X509EDIPartyName</class-id> <category>accessing</category><body package="X509" selector="nameAssigner">nameAssigner	^nameAssigner</body><body package="X509" selector="nameAssigner:">nameAssigner: anObject	nameAssigner := anObject</body><body package="X509" selector="partyName">partyName	^partyName</body><body package="X509" selector="partyName:">partyName: anObject	partyName := anObject</body></methods><methods><class-id>Security.X509DSAPrivateKey</class-id> <category>accessing</category><body package="X509" selector="g">g	^g</body><body package="X509" selector="g:">g: anObject	g := anObject</body><body package="X509" selector="getKey">getKey	^DSAPrivateKey		p: p 		q: q 		g: g 		x: x</body><body package="X509" selector="p">p	^p</body><body package="X509" selector="p:">p: anObject	p := anObject</body><body package="X509" selector="q">q	^q</body><body package="X509" selector="q:">q: anObject	q := anObject</body><body package="X509" selector="x">x	^x</body><body package="X509" selector="x:">x: anObject	x := anObject</body><body package="X509" selector="y">y	^y</body><body package="X509" selector="y:">y: anObject	y := anObject</body></methods><methods><class-id>Security.X509DSAPrivateKey</class-id> <category>initialization</category><body package="X509" selector="getPrivateKeyData">getPrivateKeyData	"Answers true if the Base64 encoded Private Key has the appropriate delimiters required for PEM 	format; otherwise, answers nil"	| i j k |	i := encodedPrivateKey				indexOfSubCollection: '--BEGIN '				startingAt: 1				ifAbsent: [^nil].	i := encodedPrivateKey				indexOfSubCollection: 'DSA PRIVATE KEY--'				startingAt: i				ifAbsent: [^nil].	j := encodedPrivateKey				indexOfSubCollection: '--END '				startingAt: i				ifAbsent: [^nil].	k := encodedPrivateKey				indexOfSubCollection: 'DSA PRIVATE KEY--'				startingAt: j				ifAbsent: [^nil].	i := (encodedPrivateKey findEither: Character cr or: Character lf from: i to: k).	^(encodedPrivateKey copyFrom: i to: j)		reject: [:c | c = $- or: [c isSeparator]]</body><body package="X509" selector="initializeFromByteArray:">initializeFromByteArray: aByteArray	| resultObject |	self rawData: aByteArray.	self rawData do: [ :z | self marshaller nextPut: z ].	self marshaller setReadLimit: self marshaller position.	self marshaller position: 0.	self marshaller  retainEncodings: true.	resultObject := self marshaller  unmarshalObjectType: ( ASN1.Asn1Type findTypeNamed: #DSAPrivateKey ).	p := resultObject p value.	q :=  resultObject q value.	g := resultObject g value.	y :=  resultObject y value.	x :=  resultObject x value.	"| counter |	sequence := anASN1Value.	counter := 0.	version  :=  ASN1Value fromByteArray: (sequence data) startingAt: 1.	counter := counter + version totalBytes +1.	p := ASN1Value fromByteArray: (sequence data) startingAt: (counter).	counter := counter + p totalBytes.	q := ASN1Value fromByteArray: (sequence data) startingAt: (counter).	counter := counter + q totalBytes.	g := ASN1Value fromByteArray: (sequence data) startingAt:counter.	counter := counter + g totalBytes.	y := ASN1Value fromByteArray: (sequence data) startingAt: (counter).	counter := counter + y totalBytes.	x := ASN1Value fromByteArray: (sequence data) startingAt: (counter).	counter := counter + x totalBytes."</body></methods><methods><class-id>Security.X509DSAPrivateKey class</class-id> <category>testing</category><body package="X509" selector="canReadKey:">canReadKey: encodedPrivateKey 	^(encodedPrivateKey		indexOfSubCollection: 'RSA PRIVATE KEY--'		startingAt: 1		ifAbsent: [nil]) notNil</body></methods><methods><class-id>Security.X509RevokedCertificates</class-id> <category>initialize</category><body package="X509" selector="parse:">parse: anASN1Value</body></methods><methods><class-id>Security.X509RevokedCertificates class</class-id> <category>instance creation</category><body package="X509" selector="fromASN1Value:">fromASN1Value: anASN1Value 	^self new parse: anASN1Value</body></methods><methods><class-id>Security.X509AlgorithmIdentifier</class-id> <category>accessing</category><body package="X509" selector="getOID">getOID	"Answers the OID for this algorithm"	^oid</body><body package="X509" selector="getOIDDescription">getOIDDescription	"Answers the OID description for this algorithm"	^oidDescription</body><body package="X509" selector="getOIDSymbol">getOIDSymbol	"Answers object identifier asSymbol"	^algorithm getOIDSymbol</body><body package="X509" selector="getOLDOIDSymbol">getOLDOIDSymbol	"Answers object identifier asSymbol"	| oidString ix |	oidString := oid copy.	oidString := 'x' , self getOID.	ix := 1.	[ix &lt; oidString size]		whileTrue: 			[(oidString at: ix)				= $. ifTrue: [oidString at: ix put: $x].			ix := ix + 1].^oidString asSymbol</body><body package="X509" selector="parameters">parameters	^parameters</body><body package="X509" selector="parameters:">parameters: anObject	parameters := anObject</body><body package="X509" selector="totalBytes">totalBytes	"Answers total bytes. See NOTE in totalBytes method of ASN1Value"	^totalBytes</body></methods><methods><class-id>Security.X509AlgorithmIdentifier</class-id> <category>initialize</category><body package="X509" selector="initializeFromAnASN1Type:">initializeFromAnASN1Type: anASN1Type 	"get the algorithm and parameters from anASN1Value. Gets the OID for the algorithm"	| |	algorithm := anASN1Type  algorithm.	oid := algorithm .	oidDescription := algorithm  getShortOIDDescription.	parameters := anASN1Type   at: #parameters ifAbsent:[nil].</body></methods><methods><class-id>Security.X509AlgorithmIdentifier class</class-id> <category>instance creation</category><body package="X509" selector="fromASN1Value:">fromASN1Value: anASN1Value 	^self new initialize: anASN1Value</body></methods><methods><class-id>Security.X509UserNotice</class-id> <category>accessing</category><body package="X509" selector="explicitText">explicitText	^explicitText</body><body package="X509" selector="explicitText:">explicitText: anObject	explicitText := anObject</body><body package="X509" selector="noticeRef">noticeRef	^noticeRef</body><body package="X509" selector="noticeRef:">noticeRef: anObject	noticeRef := anObject</body></methods><methods><class-id>Security.X509RSASignatureVerification</class-id> <category>api</category><body package="X509" selector="verifyCertificate:isSignedBy:">verifyCertificate: aSubjectCertificate isSignedBy: anIssuerCertificate	super verifyCertificate: aSubjectCertificate isSignedBy: anIssuerCertificate.	"anIssuerCertificate subjectPublicKeyAlgorithmOIDDescription = 'rsaEncryption'"	anIssuerCertificate subjectPublicKeyAlgorithmOID getDottedOID = '1.2.840.113549.1.1.1'		ifFalse: [ X509InvalidSignature new				messageText: (#IssuerSigAlgMismatch &lt;&lt; #security &gt;&gt; 'Issuer signature algorithm mismatch!');				parameter: (Array with: aSubjectCertificate with: anIssuerCertificate);				isResumable: true;				raiseSignal ].	^self		verifySignature: aSubjectCertificate signature		onDERCertificate: aSubjectCertificate tbsDerCertificate		alogorithm: aSubjectCertificate signatureAlgorithm 		key: anIssuerCertificate getPublicKey</body><body package="X509" selector="verifySignature:onDERCertificate:alogorithm:key:">verifySignature: aSignature onDERCertificate: tbsDerCertificate alogorithm: algorithm key: aPublicKey	| hashSymbol sig |	hashSymbol :=		( algorithm getOIDDescription ) asSymbol.	sig := aSignature  first = 0			ifTrue:[aSignature data copyFrom:2 to: aSignature data size ]			ifFalse:[aSignature  ].	^RSA new		hashIdentifier: hashSymbol;		publicKey: aPublicKey;		verify: sig of: tbsDerCertificate</body></methods><methods><class-id>Security.X509RSASignatureVerification class</class-id> <category>accessing</category><body package="X509" selector="oidCollection">oidCollection	^#(#x1x2x840x113549x1x1x2 #x1x2x840x113549x1x1x4 #x1x2x840x113549x1x1x5 #x1x2x840x113549x1x1x1 #x2x5x8x1x1)</body></methods><methods><class-id>Security.X509OtherName</class-id> <category>accessing</category><body package="X509" selector="typeId">typeId	^typeId</body><body package="X509" selector="typeId:">typeId: anObject	typeId := anObject</body><body package="X509" selector="value">value	^value</body><body package="X509" selector="value:">value: anObject	value := anObject</body></methods><methods><class-id>Security.X509Extension</class-id> <category>printing</category><body package="X509" selector="printOpenSSLOn:indent:">printOpenSSLOn: aStream indent: level"This should print the extension in the format used by OpenSSL"	aStream tab: level; nextPutAll: self class name; nextPut: $:.	critical ifTrue: [aStream nextPutAll: (#CriticalSuffix &lt;&lt; #security &gt;&gt; ' critical') asString].	aStream cr</body></methods><methods><class-id>Security.X509Extension</class-id> <category>accessing</category><body package="X509" selector="id">id	"OID for the extension"	^oid getDottedOID</body><body package="X509" selector="idDescription">idDescription	" the description of the OID for the extension"	^idDescription</body><body package="X509" selector="isCritical">isCritical	" the value of the instance variable critical"	^critical</body><body package="X509" selector="isHandled">isHandled	^false</body><body package="X509" selector="marshaller">marshaller	^marshaller isNil ifTrue:[ marshaller := ( ASN1.Asn1StreamDER on: ( ByteArray new: 4096 ) ) maxReadLimit.] ifFalse:[marshaller]</body><body package="X509" selector="marshaller:">marshaller: anObject	marshaller := anObject</body><body package="X509" selector="oid">oid	^oid</body><body package="X509" selector="value">value	"the value"	^value</body></methods><methods><class-id>Security.X509Extension</class-id> <category>queries</category><body package="X509" selector="isBasicConstraint">isBasicConstraint	^false</body><body package="X509" selector="isKeyUsage">isKeyUsage	^false</body><body package="X509" selector="isSubjectAltName">isSubjectAltName	^false</body><body package="X509" selector="isSubjectKeyIdentifier">isSubjectKeyIdentifier	^false</body></methods><methods><class-id>Security.X509Extension</class-id> <category>initialize</category><body package="X509" selector="initializeFromAnASN1Type:">initializeFromAnASN1Type: anASN1Type	oid := anASN1Type extnID.	idDescription :=		[	oid getOIDDescription		] 	on: ASN1.Asn1ExcSMIPathUnknown			do: [ :ex | ex return: '' ].	critical :=  anASN1Type  critical value.	value := anASN1Type extnValue value.	self asn1Type ifNotNil: [ :type || stream |		stream := ASN1.Asn1StreamDER with: value.		value := stream reset; unmarshalObjectType: type ]</body></methods><methods><class-id>Security.X509Extension</class-id> <category>private</category><body package="X509" selector="asn1Type">asn1Type"Answer the ASN.1 type for the extension value."	^nil</body></methods><methods><class-id>Security.X509Extension class</class-id> <category>instance creation</category><body package="X509" selector="fromASN1Type:">fromASN1Type: anASN1Type	^(self extensionClassFor: anASN1Type extnID value) new		initializeFromAnASN1Type: anASN1Type</body><body package="X509" selector="fromASN1Value:">fromASN1Value: anASN1Value 	^self new initialize: anASN1Value</body></methods><methods><class-id>Security.X509Extension class</class-id> <category>private</category><body package="X509" selector="buildOIDExtensionMap">buildOIDExtensionMap		| map |	map := IdentityDictionary new.	self allSubclasses do: [ :class || oid |		oid := class objectIDString asAsn1OID.		map at: oid put: class.		map at: class put: oid ].	^OIDExtensionMap := map</body><body package="X509" selector="classMethodsChanged">classMethodsChanged	self flushOIDExtensionMap</body><body package="X509" selector="initAsn1Types">initAsn1Types</body><body package="X509" selector="objectIDString">objectIDString	^self subclassResponsibility</body></methods><methods><class-id>Security.X509Extension class</class-id> <category>accessing</category><body package="X509" selector="extensionClassFor:">extensionClassFor: anOID	^self oidExtensionMap at: anOID ifAbsent: [X509Extension]</body><body package="X509" selector="flushOIDExtensionMap">flushOIDExtensionMap	OIDExtensionMap := nil</body><body package="X509" selector="oid">oid	^self oidFor: self</body><body package="X509" selector="oidExtensionMap">oidExtensionMap	^OIDExtensionMap ifNil: [ self buildOIDExtensionMap ].</body><body package="X509" selector="oidFor:">oidFor: anExtension	^self oidExtensionMap at: anExtension class instanceBehavior</body></methods><methods><class-id>Security.X509PolicyMappings</class-id> <category>accessing</category><body package="X509" selector="mappings">mappings	^mappings</body></methods><methods><class-id>Security.X509PolicyMappings class</class-id> <category>private</category><body package="X509" selector="initAsn1Types">initAsn1Types"   PolicyMappings ::= SEQUENCE SIZE (1..MAX) OF SEQUENCE {        issuerDomainPolicy      CertPolicyId,        subjectDomainPolicy     CertPolicyId }"</body><body package="X509" selector="objectIDString">objectIDString	^'2.5.29.33'</body></methods><methods><class-id>Security.X509BasicConstraints</class-id> <category>accessing</category><body package="X509" selector="ca">ca	^ca</body><body package="X509" selector="ca:">ca: anObject	ca := anObject</body><body package="X509" selector="pathLenConstraint">pathLenConstraint	^pathLenConstraint</body><body package="X509" selector="pathLenConstraint:">pathLenConstraint: anObject	pathLenConstraint := anObject</body></methods><methods><class-id>Security.X509BasicConstraints</class-id> <category>queries</category><body package="X509" selector="isBasicConstraint">isBasicConstraint	^true</body><body package="X509" selector="isHandled">isHandled	^true</body></methods><methods><class-id>Security.X509BasicConstraints</class-id> <category>printing</category><body package="X509" selector="printOpenSSLOn:indent:">printOpenSSLOn: aStream indent: level"This should print the extension in the format used by OpenSSL"	aStream tab: level;		nextPutAll: (#BasicConstraintsPrefix &lt;&lt; #security &gt;&gt; 'X509v3 Basic Constraints:') asString.	critical ifTrue: [aStream nextPutAll: (#CriticalSuffix &lt;&lt; #security &gt;&gt; ' critical') asString ].	aStream cr; tab: level; nextPutAll: (#CAPrefix &lt;&lt; #security &gt;&gt; 'CA:') asString.	aStream		nextPutAll: (ca				ifTrue: [(#TRUE &lt;&lt; #security &gt;&gt; 'TRUE') asString]				ifFalse: [(#FALSE &lt;&lt; #security &gt;&gt; 'FALSE') asString]);		cr.	pathLenConstraint ifNotNil: [ :len |		aStream tab: level;		nextPutAll: (#pathLenPrefix &lt;&lt; #security &gt;&gt; 'pathLen: ') asString;		print: len; cr ]</body></methods><methods><class-id>Security.X509BasicConstraints</class-id> <category>initialize</category><body package="X509" selector="initializeFromAnASN1Type:">initializeFromAnASN1Type: anASN1Type	super initializeFromAnASN1Type: anASN1Type.	self isCritical ifFalse:[		X509ExtensionShouldBeCritical  new			messageText: (#CertExtShouldBeCritical &lt;&lt; #security &gt;&gt; 'This extension in this certificate should be critical');			parameter: self;			isResumable: true;			raiseSignal ].	ca := value cA.	(value includesKey: #pathLenConstraint) ifTrue:[		pathLenConstraint := value pathLenConstraint]</body></methods><methods><class-id>Security.X509BasicConstraints</class-id> <category>private</category><body package="X509" selector="asn1Type">asn1Type"Answer the ASN.1 type for the extension value."	^ASN1.Asn1Type findTypeNamed: #BasicConstraints</body></methods><methods><class-id>Security.X509BasicConstraints class</class-id> <category>private</category><body package="X509" selector="initAsn1Types">initAsn1Types"   BasicConstraints ::= SEQUENCE {        cA                      BOOLEAN DEFAULT FALSE,        pathLenConstraint       INTEGER (0..MAX) OPTIONAL }"	ASN1.Asn1TypeSEQUENCE		register:		#BasicConstraints		constraint:	ASN1.Asn1ConstraintNull default		elements:	( OrderedCollection						with: ( ASN1.Asn1Element								default: false								symbol: #cA								type: ( ASN1.Asn1Type findTypeNamed: #BOOLEAN ) )						with: ( ASN1.Asn1Element								optional: true								symbol: #pathLenConstraint								type: ( ASN1.Asn1Type findTypeNamed: #INTEGER ) ) ).</body><body package="X509" selector="objectIDString">objectIDString	^'2.5.29.19'</body></methods><methods><class-id>Security.X509NameConstraints</class-id> <category>accessing</category><body package="X509" selector="excludedSubtrees">excludedSubtrees	^excludedSubtrees</body><body package="X509" selector="excludedSubtrees:">excludedSubtrees: anObject	excludedSubtrees := anObject</body><body package="X509" selector="permittedSubtrees">permittedSubtrees	^permittedSubtrees</body><body package="X509" selector="permittedSubtrees:">permittedSubtrees: anObject	permittedSubtrees := anObject</body></methods><methods><class-id>Security.X509NameConstraints class</class-id> <category>private</category><body package="X509" selector="objectIDString">objectIDString	^'2.5.29.30'</body></methods><methods><class-id>Security.X509AuthorityInformationAccess</class-id> <category>accessing</category><body package="X509" selector="accessDescription">accessDescription	^accessDescription</body><body package="X509" selector="accessDescription:">accessDescription: anObject	accessDescription := anObject</body></methods><methods><class-id>Security.X509AuthorityInformationAccess class</class-id> <category>private</category><body package="X509" selector="objectIDString">objectIDString	^'1.3.6.1.5.5.7.1.1'</body></methods><methods><class-id>Security.X509SubjectAltName</class-id> <category>accessing</category><body package="X509" selector="subjectAlternativeNames">subjectAlternativeNames	^subjectAlternativeNames</body><body package="X509" selector="subjectAlternativeNames:">subjectAlternativeNames: anObject	subjectAlternativeNames := anObject</body></methods><methods><class-id>Security.X509SubjectAltName</class-id> <category>queries</category><body package="X509" selector="isSubjectAltName">isSubjectAltName	^true</body></methods><methods><class-id>Security.X509SubjectAltName class</class-id> <category>private</category><body package="X509" selector="initAsn1Types">initAsn1Types"   SubjectAltName ::= GeneralNames   GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName   GeneralName ::= CHOICE {        otherName                       [0]     OtherName,        rfc822Name                      [1]     IA5String,        dNSName                         [2]     IA5String,        x400Address                     [3]     ORAddress,        directoryName                   [4]     Name,        ediPartyName                    [5]     EDIPartyName,        uniformResourceIdentifier       [6]     IA5String,        iPAddress                       [7]     OCTET STRING,        registeredID                    [8]     OBJECT IDENTIFIER }   OtherName ::= SEQUENCE {        type-id    OBJECT IDENTIFIER,        value      [0] EXPLICIT ANY DEFINED BY type-id }   EDIPartyName ::= SEQUENCE {        nameAssigner            [0]     DirectoryString OPTIONAL,        partyName               [1]     DirectoryString }"</body><body package="X509" selector="objectIDString">objectIDString	^'2.5.29.17'</body></methods><methods><class-id>Security.X509ExtendedKeyUsage</class-id> <category>accessing</category><body package="X509" selector="keyPurposeId">keyPurposeId	^keyPurposeId</body><body package="X509" selector="keyPurposeId:">keyPurposeId: anObject	keyPurposeId := anObject</body></methods><methods><class-id>Security.X509ExtendedKeyUsage class</class-id> <category>private</category><body package="X509" selector="objectIDString">objectIDString	^'2.5.29.37'</body></methods><methods><class-id>Security.X509CertificatePoliciesOld class</class-id> <category>private</category><body package="X509" selector="objectIDString">objectIDString	^'2.5.29.3'</body></methods><methods><class-id>Security.X509KeyUsage</class-id> <category>queries</category><body package="X509" selector="isKeyUsage">isKeyUsage	^true</body></methods><methods><class-id>Security.X509KeyUsage</class-id> <category>accessing</category><body package="X509" selector="crlSign">crlSign	^crlSign</body><body package="X509" selector="crlSign:">crlSign: anObject	crlSign := anObject</body><body package="X509" selector="dataEncipherment">dataEncipherment	^dataEncipherment</body><body package="X509" selector="dataEncipherment:">dataEncipherment: anObject	dataEncipherment := anObject</body><body package="X509" selector="decipherOnly">decipherOnly	^decipherOnly</body><body package="X509" selector="decipherOnly:">decipherOnly: anObject	decipherOnly := anObject</body><body package="X509" selector="digitalSignature">digitalSignature	^digitalSignature</body><body package="X509" selector="digitalSignature:">digitalSignature: anObject	digitalSignature := anObject</body><body package="X509" selector="encipherOnly">encipherOnly	^encipherOnly</body><body package="X509" selector="encipherOnly:">encipherOnly: anObject	encipherOnly := anObject</body><body package="X509" selector="isHandled">isHandled	^true</body><body package="X509" selector="keyAgreement">keyAgreement	^keyAgreement</body><body package="X509" selector="keyAgreement:">keyAgreement: anObject	keyAgreement := anObject</body><body package="X509" selector="keyCertSign">keyCertSign	^keyCertSign</body><body package="X509" selector="keyCertSign:">keyCertSign: anObject	keyCertSign := anObject</body><body package="X509" selector="keyEncipherment">keyEncipherment	^keyEncipherment</body><body package="X509" selector="keyEncipherment:">keyEncipherment: anObject	keyEncipherment := anObject</body><body package="X509" selector="nonRepudiation">nonRepudiation	^nonRepudiation</body><body package="X509" selector="nonRepudiation:">nonRepudiation: anObject	nonRepudiation := anObject</body></methods><methods><class-id>Security.X509KeyUsage</class-id> <category>constants</category><body package="X509" selector="cRLSignMask">cRLSignMask	^2r0000001000000000</body><body package="X509" selector="dataEnciphermentMask">dataEnciphermentMask	^2r0001000000000000</body><body package="X509" selector="decipherOnlyMask">decipherOnlyMask	^2r0000000010000000</body><body package="X509" selector="digitalSignatureMask">digitalSignatureMask	^2r1000000000000000</body><body package="X509" selector="encipherOnlyMask">encipherOnlyMask	^2r0000000100000000</body><body package="X509" selector="keyAgreementMask">keyAgreementMask	^2r0000100000000000</body><body package="X509" selector="keyCertSignMask">keyCertSignMask	^2r0000010000000000</body><body package="X509" selector="keyEnciphermentMask">keyEnciphermentMask	^2r0010000000000000</body><body package="X509" selector="nonRepudiationMask">nonRepudiationMask	^2r0100000000000000</body></methods><methods><class-id>Security.X509KeyUsage</class-id> <category>private</category><body package="X509" selector="asn1Type">asn1Type"Answer the ASN.1 type for the extension value."	^ASN1.Asn1Type findTypeNamed: #KeyUsage</body></methods><methods><class-id>Security.X509KeyUsage</class-id> <category>initialize</category><body package="X509" selector="initializeFromAnASN1Type:">initializeFromAnASN1Type: anASN1Type 	super initializeFromAnASN1Type: anASN1Type .	digitalSignature := (value bitAt: 1).	nonRepudiation := (value bitAt: 2).	keyEncipherment := (value bitAt: 3).	dataEncipherment := (value bitAt: 4).	keyAgreement := (value bitAt: 5).	keyCertSign := (value bitAt: 6).	crlSign := (value bitAt: 7).	encipherOnly := (value bitAt: 8).	decipherOnly := (value bitAt: 9).</body></methods><methods><class-id>Security.X509KeyUsage class</class-id> <category>instance creation</category><body package="X509" selector="fromASN1Value:">fromASN1Value: anASN1Value 	^self new initialize: anASN1Value</body></methods><methods><class-id>Security.X509KeyUsage class</class-id> <category>private</category><body package="X509" selector="initAsn1Types">initAsn1Types"      KeyUsage ::= BIT STRING {           digitalSignature        (0),           nonRepudiation          (1),           keyEncipherment         (2),           dataEncipherment        (3),           keyAgreement            (4),           keyCertSign             (5),           cRLSign                 (6),           encipherOnly            (7),           decipherOnly            (8) }"	ASN1.Asn1TypeBIT_STRING register: #KeyUsage</body><body package="X509" selector="objectIDString">objectIDString	^'2.5.29.15'</body></methods><methods><class-id>Security.X509AuthorityKeyIdentifier</class-id> <category>accessing</category><body package="X509" selector="authorityCertIssuer">authorityCertIssuer	^authorityCertIssuer</body><body package="X509" selector="authorityCertIssuer:">authorityCertIssuer: anObject	authorityCertIssuer := anObject</body><body package="X509" selector="authorityCertSerialNumber">authorityCertSerialNumber	^authorityCertSerialNumber</body><body package="X509" selector="authorityCertSerialNumber:">authorityCertSerialNumber: anObject	authorityCertSerialNumber := anObject</body><body package="X509" selector="keyIdentifier">keyIdentifier	^keyIdentifier</body><body package="X509" selector="keyIdentifier:">keyIdentifier: anObject	keyIdentifier := anObject</body></methods><methods><class-id>Security.X509AuthorityKeyIdentifier class</class-id> <category>private</category><body package="X509" selector="initAsn1Types">initAsn1Types"   AuthorityKeyIdentifier ::= SEQUENCE {      keyIdentifier             [0] KeyIdentifier           OPTIONAL,      authorityCertIssuer       [1] GeneralNames            OPTIONAL,      authorityCertSerialNumber [2] CertificateSerialNumber OPTIONAL  }   KeyIdentifier ::= OCTET STRING"</body><body package="X509" selector="objectIDString">objectIDString	^'2.5.29.35'</body></methods><methods><class-id>Security.X509CertificateIssuer class</class-id> <category>private</category><body package="X509" selector="objectIDString">objectIDString	^'2.5.29.29'</body></methods><methods><class-id>Security.X509CRLDistributionPoints</class-id> <category>accessing</category><body package="X509" selector="distributionPoints">distributionPoints	^distributionPoints</body><body package="X509" selector="distributionPoints:">distributionPoints: anObject	distributionPoints := anObject</body></methods><methods><class-id>Security.X509CRLDistributionPoints class</class-id> <category>private</category><body package="X509" selector="objectIDString">objectIDString	^'2.5.29.31'</body></methods><methods><class-id>Security.X509SubjectDirectoryAttributes</class-id> <category>accessing</category><body package="X509" selector="attributes">attributes	^attributes</body><body package="X509" selector="attributes:">attributes: anObject	attributes := anObject</body></methods><methods><class-id>Security.X509SubjectDirectoryAttributes class</class-id> <category>private</category><body package="X509" selector="objectIDString">objectIDString	^'2.5.29.9'</body></methods><methods><class-id>Security.X509IssuerAlernativeNames</class-id> <category>accessing</category><body package="X509" selector="generalNames">generalNames	^generalNames</body><body package="X509" selector="generalNames:">generalNames: anObject	generalNames := anObject</body></methods><methods><class-id>Security.X509IssuerAlernativeNames class</class-id> <category>private</category><body package="X509" selector="initAsn1Types">initAsn1Types"	IssuerAltName ::= GeneralNames"</body><body package="X509" selector="objectIDString">objectIDString	^'2.5.29.18'</body></methods><methods><class-id>Security.X509DeltaCRLIndicator class</class-id> <category>private</category><body package="X509" selector="objectIDString">objectIDString	^'2.5.29.27'</body></methods><methods><class-id>Security.X509InvalidityDate class</class-id> <category>private</category><body package="X509" selector="objectIDString">objectIDString	^'2.5.29.24'</body></methods><methods><class-id>Security.X509CRLNumber class</class-id> <category>private</category><body package="X509" selector="objectIDString">objectIDString	^'2.5.29.20'</body></methods><methods><class-id>Security.X509PolicyConstraints</class-id> <category>accessing</category><body package="X509" selector="inhibitPolicyMapping">inhibitPolicyMapping	^inhibitPolicyMapping</body><body package="X509" selector="inhibitPolicyMapping:">inhibitPolicyMapping: anObject	inhibitPolicyMapping := anObject</body><body package="X509" selector="requireExplicitPolicy">requireExplicitPolicy	^requireExplicitPolicy</body><body package="X509" selector="requireExplicitPolicy:">requireExplicitPolicy: anObject	requireExplicitPolicy := anObject</body></methods><methods><class-id>Security.X509PolicyConstraints class</class-id> <category>private</category><body package="X509" selector="objectIDString">objectIDString	^'2.5.29.36'</body></methods><methods><class-id>Security.X509CertificatePolicies</class-id> <category>accessing</category><body package="X509" selector="policyInformationCollection">policyInformationCollection	^policyInformationCollection</body><body package="X509" selector="policyInformationCollection:">policyInformationCollection: anObject	policyInformationCollection := anObject</body></methods><methods><class-id>Security.X509CertificatePolicies class</class-id> <category>private</category><body package="X509" selector="initAsn1Types">initAsn1Types"   anyPolicy OBJECT IDENTIFIER ::= { id-ce-certificate-policies 0 }   certificatePolicies ::= SEQUENCE SIZE (1..MAX) OF PolicyInformation   PolicyInformation ::= SEQUENCE {        policyIdentifier   CertPolicyId,        policyQualifiers   SEQUENCE SIZE (1..MAX) OF                                PolicyQualifierInfo OPTIONAL }   CertPolicyId ::= OBJECT IDENTIFIER   PolicyQualifierInfo ::= SEQUENCE {        policyQualifierId  PolicyQualifierId,        qualifier          ANY DEFINED BY policyQualifierId }   -- policyQualifierIds for Internet policy qualifiers   id-qt          OBJECT IDENTIFIER ::=  { id-pkix 2 }   id-qt-cps      OBJECT IDENTIFIER ::=  { id-qt 1 }   id-qt-unotice  OBJECT IDENTIFIER ::=  { id-qt 2 }   PolicyQualifierId ::=        OBJECT IDENTIFIER ( id-qt-cps | id-qt-unotice )   Qualifier ::= CHOICE {        cPSuri           CPSuri,        userNotice       UserNotice }   CPSuri ::= IA5String   UserNotice ::= SEQUENCE {        noticeRef        NoticeReference OPTIONAL,        explicitText     DisplayText OPTIONAL}   NoticeReference ::= SEQUENCE {        organization     DisplayText,        noticeNumbers    SEQUENCE OF INTEGER }   DisplayText ::= CHOICE {        ia5String        IA5String      (SIZE (1..200)),        visibleString    VisibleString  (SIZE (1..200)),        bmpString        BMPString      (SIZE (1..200)),        utf8String       UTF8String     (SIZE (1..200)) }"</body><body package="X509" selector="objectIDString">objectIDString	^'2.5.29.32'</body></methods><methods><class-id>Security.X509HoldInstructionCode class</class-id> <category>private</category><body package="X509" selector="objectIDString">objectIDString	^'2.5.29.23'</body></methods><methods><class-id>Security.X509IssuingDistributionPoint class</class-id> <category>private</category><body package="X509" selector="objectIDString">objectIDString	^'2.5.29.28'</body></methods><methods><class-id>Security.X509PrivateKeyUsagePeriod</class-id> <category>accessing</category><body package="X509" selector="notAfter">notAfter	^notAfter</body><body package="X509" selector="notAfter:">notAfter: anObject	notAfter := anObject</body><body package="X509" selector="notBefore">notBefore	^notBefore</body><body package="X509" selector="notBefore:">notBefore: anObject	notBefore := anObject</body></methods><methods><class-id>Security.X509PrivateKeyUsagePeriod class</class-id> <category>private</category><body package="X509" selector="initAsn1Types">initAsn1Types"   PrivateKeyUsagePeriod ::= SEQUENCE {        notBefore       [0]     GeneralizedTime OPTIONAL,        notAfter        [1]     GeneralizedTime OPTIONAL }"</body><body package="X509" selector="objectIDString">objectIDString	^'2.5.29.16'</body></methods><methods><class-id>Security.X509SubjectKeyIdentifier</class-id> <category>queries</category><body package="X509" selector="isSubjectKeyIdentifier">isSubjectKeyIdentifier	^true</body></methods><methods><class-id>Security.X509SubjectKeyIdentifier</class-id> <category>private</category><body package="X509" selector="asn1Type">asn1Type"Answer the ASN.1 type for the extension value."	^ASN1.Asn1Type findTypeNamed: #SubjectKeyIdentifier</body></methods><methods><class-id>Security.X509SubjectKeyIdentifier class</class-id> <category>private</category><body package="X509" selector="initAsn1Types">initAsn1Types" 	SubjectKeyIdentifier ::= KeyIdentifier	KeyIdentifier is defined by AuthorityKeyIdentifier as		KeyIdentifier ::= OCTET STRING	however to avoid ordering issues in registry initialization we'll shortcut the definition as follows."	ASN1.Asn1TypeOCTET_STRING register: #SubjectKeyIdentifier</body><body package="X509" selector="objectIDString">objectIDString	^'2.5.29.14'</body></methods><methods><class-id>Security.X509ReasonCode class</class-id> <category>private</category><body package="X509" selector="objectIDString">objectIDString	^'2.5.29.21'</body></methods><methods><class-id>ASN1.Asn1BitString</class-id> <category>x509 extensions</category><body package="X509" selector="bitAt:">bitAt: anInteger"Test the value of the bit at given index (1-based indexing).	anInteger &lt;Integer&gt; index of the bit to query, one based	^&lt;Boolean&gt;	true if set, false if clearedNote that within each byte the bits are ordered from the most significant bit to the least significant.So bit (0) of a bit string is actually the most significant bit of the first byte, bit (9) is the most significant bit of second byte, etc.	((self unused: 0 bytes: #[64 1]) bitAt: 8) = false	((self unused: 0 bytes: #[64 1]) bitAt: 2) = true	((self unused: 0 bytes: #[64 1]) bitAt: 16) = true	((self unused: 0 bytes: #[64 1]) bitAt: 9) = false"	| slot mask |	slot := (anInteger - 1 bitShift: -3) + 1.	slot &gt; value size ifTrue: [^false].	mask := 2**(7 - (anInteger - 1 bitAnd: 7)).	^((value at: slot) bitAnd: mask) ~~ 0.</body><body package="X509" selector="bitAt:put:">bitAt: anInteger put: aBoolean"Set the value of the bit at index anInteger (1-based indexing).	anInteger &lt;Integer&gt;	index of the bit to set, one based	aBoolean &lt;Boolean&gt; set to 1 if true, set to 0 if false	^&lt;Boolean&gt;Note that within each byte the bits are ordered from the most significant bit to the least significant.So bit (0) of a bit string is actually the most significant bit of the first byte, bit (9) is the most significant bit of second byte, etc.	(((self unused: 0 bytes: #[64 1] copy) bitAt: 8 put: true; yourself) bitAt: 8) = true	(((self unused: 0 bytes: #[64 1] copy) bitAt: 8 put: true; yourself) bitAt: 7) = false	(((self unused: 0 bytes: #[64 1] copy) bitAt: 8 put: true; yourself) bitAt: 2) = true	(((self unused: 0 bytes: #[65 1] copy) bitAt: 2 put: false; yourself) bitAt: 2) = false	(((self unused: 0 bytes: #[65 1] copy) bitAt: 2 put: false; yourself) bitAt: 8) = true	(((self unused: 0 bytes: #[65 1] copy) bitAt: 2 put: false; yourself) bitAt: 7) = false"	| slot mask bits |	slot := (anInteger - 1 bitShift: -3) + 1.	mask := 2**(7- (anInteger - 1 bitAnd: 7)).	bits := value at: slot.	value at: slot put: (		aBoolean			ifTrue: [bits bitOr: mask]			ifFalse: [bits bitAnd: (255 bitXor: mask)] ).	^aBoolean</body><body package="X509" selector="getBitStringAsFormattedHexStrings">getBitStringAsFormattedHexStrings	^self value asFormattedHexStrings</body></methods><methods><class-id>Security.RSAPrivateKey class</class-id> <category>instance creation</category><body package="X509" selector="newFromX509RSAPrivateKey:">newFromX509RSAPrivateKey: anX509PrivateKey	| inst |	inst := self new.	inst d: anX509PrivateKey d .	inst n: anX509PrivateKey n .	inst e: anX509PrivateKey e .	inst p: anX509PrivateKey p .	inst q: anX509PrivateKey q .	inst exponent1: anX509PrivateKey exponent1 .	inst exponent2: anX509PrivateKey exponent2 .	inst coefficient: anX509PrivateKey coefficient .	^inst</body></methods><methods><class-id>Core.ByteArray</class-id> <category>security</category><body package="X509" selector="asFormattedHexStrings">asFormattedHexStrings"(((#[160 11 2 16 255 0] asFormattedHexStrings)))"	| lookup s ws |	lookup := '0123456789ABCDEF'.	s := String new: self size * 2.	ws := s readWriteStream.	self do: [ :b |		ws nextPut: (lookup at: (b bitShift: -4) + 1).		ws nextPut: (lookup at: (b bitAnd: 15) + 1).		ws space ].	^(ws contents copyFrom: 1 to: ws readPosition)</body><body package="X509" selector="printOpenSSLOn:indent:width:">printOpenSSLOn: aStream indent: level width: bytes"This should print the value as a hex dump in the format used by OpenSSL"	| digits |	digits := '0123456789abcdef'.	aStream tab: level.	1 to: self size do: [ :idx || byte |		aStream nextPut: (digits at: ((byte := self at: idx) bitShift: -4) + 1).		aStream nextPut: (digits at: (byte bitAnd: 16rF) + 1).		idx =  self size ifFalse: [			aStream nextPut: $:.			idx \\ bytes = 0 ifTrue: [				aStream cr; tab: level ] ] ].	aStream cr</body></methods><methods><class-id>ASN1.Asn1OID</class-id> <category>x509 extensions</category><body package="X509" selector="getDottedOID">getDottedOID	|strm |	strm := (String new:20) readWriteStream.	self value		do: [ :x | strm nextPutAll: x printString ]		separatedBy: [ strm nextPut: $. ].^(strm contents copyFrom: 1 to: strm readPosition)</body><body package="X509" selector="getOIDDescription">getOIDDescription	^self alphabeticSymbol asString</body><body package="X509" selector="getOIDSymbol">getOIDSymbol	^self getOIDSymbolForLookup</body><body package="X509" selector="getOIDSymbolForLookup">getOIDSymbolForLookup	| strm |	strm := (String new: 20) readWriteStream.	strm nextPut: $x.	self value do: [:x | strm nextPutAll: x printString]		separatedBy: [strm nextPut: $x].	^(strm contents copyFrom: 1 to: strm readPosition)  asSymbol</body><body package="X509" selector="getShortOIDDescription">getShortOIDDescription	^( SMINode root atAsn1OID: self ) alphabeticSymbol asString</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>x509</category><body package="X509" selector="asAsn1OID">asAsn1OID"Convert dotted OID notation into an Asn1OID instance.	'2.5.29.37' asAsn1OID"	^ASN1.Asn1OID		value: (	(self tokensBasedOn: $.) collect: [ :token |					Number readFrom: token readStream ]			) asArray</body></methods><initialize><class-id>Security.X509Certificate</class-id></initialize><initialize><class-id>Security.X509CertificateSignatureVerification</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Asn1BitString</name><environment>ASN1</environment><super>ASN1.Imported</super><private>false</private><indexed-type>none</indexed-type><inst-vars>unused </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Asn1OID</name><environment>ASN1</environment><super>ASN1.Imported</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encoding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><class><name>Exception</name><environment>Core</environment><super>Core.GenericException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Asn1StreamDER</name><environment>ASN1</environment><super>ASN1.Asn1StreamBERDefiniteEncodings</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class></st-source>