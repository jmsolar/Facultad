<?xml version="1.0"?><st-source><!-- Name: PKCS5Notice: Copyright © 2005 Cincom Systems, Inc.  All Rights Reserved.Comment: PKCS#5 v2.0: Password-Based Cryptography Standard, RSA Laboratories, 1999, http://www.rsasecurity.com/rsalabs/pkcs/pkcs-5. Also published as RFC 2898, http://www.ietf.org/rfc/rfc2898.txt.This standard describes key derivation techniques aimed at improving security of systems relying on textual user passwords. These techniques are designed to defend against common "search" attacks bya) combining the password text with "salt"  (increases difficulty of "dictionary" attacks),b) increasing computational cost of the key derivation process by iterating the derivation function specified number of times, "iteration count" (negligeable slowdown for legitimate users is usually prohibitive for exhaustive search attacks).Some understanding of these two countermeasures, and the salt generation guidelines particularly, is crucial for secure use of these techniques. Therefore it's highly recommended to read at least the "3. Overview" and the "4. Salt and iteration count" sections of the standard.These algorithms are represented by instances of class PBC. For more details refer to the class comments.DbIdentifier: bear73DbTrace: 52760DevelopmentPrerequisites: #(#(#package 'DES' '') #(#package 'MD5' '') #(#package 'SHA' ''))PackageName: PKCS5Parcel: #('PKCS5')PrerequisiteParcels: #(#('DES' '') #('MD5' '') #('SHA' ''))PrintStringCache: (731 1,mkobetic)Version: 7.3.1Date: 6:42:46 pm April 10, 2005 --><time-stamp>From VisualWorks®, 7.3.1 of April 10, 2005 on April 10, 2005 at 6:42:46 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>PBC</name><environment>Security</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>count v1 prf cipher mac </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PBC</category><attributes><package>PKCS5</package></attributes></class><comment><class-id>Security.PBC</class-id><body>A preconfigured instance of this class can generate keys based on selected key derivation function (KDF) and either provide encryption or signing services.The standard defines a number of configurations in the Appendix A, some of them are expressed in the form of instance creation methods. The selectors follow the naming conventions used in the standard. As the standard points out, configurations based on the earlier version of the key derivation function "pkdf1" (these are indicated by the v1 instance variable) are not recommended for new applications and are included only for compatibility with existing applications.Here is a simple example of how to use the algorithm for encryption. First create and configure and algorithm instance	pbc := PBC pbes2WithHMAC_SHA1AndDES_EDE3_CBC.Now we can encrypt a message using a salt and password:	msg := 'Message in a Bottle' asByteArray.	pwd := 'This is the end of the world ...' asByteArray.	salt := 'A randomly generated sequence of bytes' asByteArray.	ciphertext := pbc encrypt: msg password: pwd salt: salt.Message can be decrypted as follows:	plaintext := pbc decrypt: ciphertext password: pwd salt: salt.If there is no suitable random generator available to generate the salt value, the standard proposes a deterministic scheme for salt generation based on the provided message and the password. This functionality is also available in a modified version of the encryption API, which returns both the generated salt and the ciphertext as an association.	saltAndCiphertext := pbc encrypt: msg password: pwd.	salt := saltAndCiphertext key.	ciphertext := saltAndCiphertext value.The decryption API remains the same. Note that the salt value must be transferred along with the ciphertext as the recipient has no way to determine the correct salt value even though she knows the password. Also note that this salt generation scheme is not suitable for all applications (refer to the standard for more details).The algorithm instance has to be configured differently for signing. Here is an example.	pbc := PBC pbmac1WithHMAC_SHA1AndHMAC_SHA1.		saltAndSignature := pbc sign: msg password: pwd.	salt := saltAndSignature key.	signature := saltAndSignature value.And here is how to verify a signature	pbc verify: signature of: msg password: pwd salt: salt.Instance Variables:	count	&lt;Integer&gt; iteration count, default 1000	v1	&lt;Boolean&gt; use version 1 of the algorithms	prf	&lt;MessageDigest&gt; a hash algorithm instance used by the key derivation function (KDF)	cipher	&lt;BlockCipher&gt; a cipher algorithm used by the encryption API	mac	&lt;HMAC&gt; a message authentication algorithm used by the signing API</body></comment><methods><class-id>Security.PBC</class-id> <category>constants</category><body package="PKCS5" selector="defaultCount">defaultCount"This is the minimum value recommended by the standard."	^1000</body><body package="PKCS5" selector="DES_CBC">DES_CBC	^DES newBP_CBC</body><body package="PKCS5" selector="DES_EDE3_CBC">DES_EDE3_CBC	^DES newBP_3EDE_CBC</body><body package="PKCS5" selector="HMAC_SHA1">HMAC_SHA1	^HMAC new setHash: SHA new</body><body package="PKCS5" selector="MD5">MD5	^MD5 new</body><body package="PKCS5" selector="SHA1">SHA1	^SHA new</body></methods><methods><class-id>Security.PBC</class-id> <category>private</category><body package="PKCS5" selector="keySize">keySize	^cipher pkcs5KeySize</body></methods><methods><class-id>Security.PBC</class-id> <category>private-pkcs5</category><body package="PKCS5" selector="pbes1PrepareFor:password:salt:">pbes1PrepareFor: message password: password salt: salt	| dk keySize |	keySize := self keySize.	dk := self pbkdf1Password: password salt: salt count: self count length: keySize + cipher blockSize.	cipher	setKey: (dk copyFrom: 1 to: keySize);			setIV: (dk copyFrom: keySize + 1 to: dk size)</body><body package="PKCS5" selector="pbes2PrepareFor:password:salt:">pbes2PrepareFor: message password: password salt: salt	| dk keySize |	keySize := self keySize.	dk := self pbkdf2Password: password salt: salt count: self count length: keySize + cipher blockSize.	cipher	setKey: (dk copyFrom: 1 to: keySize);			setIV: (dk copyFrom: keySize + 1 to: dk size)</body><body package="PKCS5" selector="pbkdf1Password:salt:count:length:">pbkdf1Password: password salt: salt count: iterationCount length: keyLength	| t |	keyLength &gt; prf digestSize		ifTrue: [ self error: 'Derived key too long' ].	t := prf hash: password, salt.	iterationCount - 1 timesRepeat: [		t := prf hash: t ].	^t copyFrom: 1 to: keyLength</body><body package="PKCS5" selector="pbkdf2Password:salt:count:length:">pbkdf2Password: password salt: salt count: iterationCount length: keyLength	| hLen position i dk|	hLen := prf digestSize.	keyLength &gt; "2**32 - 1" (4294967295 * hLen)		ifTrue: [ self error: 'Derived key too long' ].	dk := ByteArray new: keyLength.	position := 1.	i := 1.	prf setKey: password.	[ position &gt; keyLength ] whileFalse: [ | u t |		u := salt, i asBigEndianByteArray.		t := ByteArray new: hLen.		iterationCount timesRepeat: [			u := prf hash: u.			1 to: hLen do: [ :j |				t at: j put: ((t at: j) bitXor: (u at: j)) ]].		dk replaceFrom: position to: (position + hLen - 1 min: keyLength) with: t startingAt: 1.		position := position + hLen.		i := i + 1 ].	^dk</body><body package="PKCS5" selector="pbmac1PrepareFor:password:salt:keyLength:">pbmac1PrepareFor: message password: password salt: salt keyLength: keyLength	| dk s dkLen |	s := salt ifNil: [ self saltFrom: message password: password ].	dkLen := keyLength ifNil: [ mac blockSize ].	dk := self pbkdf2Password: password salt: s count: self count length: dkLen.	mac setKey: dk</body><body package="PKCS5" selector="saltFrom:password:">saltFrom: message password: password"Generates a salt deterministicly, as described in the final Note of section 4.1, PKCS #5, v2.0"	^self key: 8 password: password salt: message</body></methods><methods><class-id>Security.PBC</class-id> <category>initialize-release</category><body package="PKCS5" selector="pbes2WithHMAC_SHA1AndDES_CBC">pbes2WithHMAC_SHA1AndDES_CBC	v1 := false.	self	setPrf: self HMAC_SHA1;		setCipher: self DES_CBC</body><body package="PKCS5" selector="pbes2WithHMAC_SHA1AndDES_EDE3_CBC">pbes2WithHMAC_SHA1AndDES_EDE3_CBC	v1 := false.	self	setPrf: self HMAC_SHA1;		setCipher: self DES_EDE3_CBC</body><body package="PKCS5" selector="pbeWithMD5AndDES_CBC">pbeWithMD5AndDES_CBC	v1 := true.	self	setPrf: self MD5;		setCipher: self DES_CBC</body><body package="PKCS5" selector="pbeWithSHA1AndDES_CBC">pbeWithSHA1AndDES_CBC	v1 := true.	self	setPrf: self SHA1;		setCipher: self DES_CBC</body><body package="PKCS5" selector="pbmac1WithHMAC_SHA1AndHMAC_SHA1">pbmac1WithHMAC_SHA1AndHMAC_SHA1	v1 := false.	self	setPrf: self HMAC_SHA1;		setMac: self HMAC_SHA1</body><body package="PKCS5" selector="setCipher:">setCipher: aBlockCipher	cipher := aBlockCipher</body><body package="PKCS5" selector="setMac:">setMac: aMac	mac := aMac</body><body package="PKCS5" selector="setPrf:">setPrf: aHash	prf := aHash</body></methods><methods><class-id>Security.PBC</class-id> <category>accessing</category><body package="PKCS5" selector="count">count	^count ifNil: [ self defaultCount ]</body><body package="PKCS5" selector="count:">count: anInteger"The standard recommend 1000 as the minimum value for the iteration count. Optimal value depends on the computational power of hardware throughout the lifecycle of the protected information. Generally it should be low enough to avoid unacceptable delays for the user but otherwise as high as possible to maximize the detrimental effect on search attacks."	count := anInteger</body></methods><methods><class-id>Security.PBC</class-id> <category>services</category><body package="PKCS5" selector="decrypt:password:salt:">decrypt: message password: password salt: salt"Decrypts message using password and salt.	message &lt;ByteArray&gt; the encrypted message	password &lt;ByteArray&gt; usually UTF-8 or ASCII encoded secret text	salt &lt;ByteArray&gt; not secret, but randomly generated byte sequence (at least 8 bytes); additional requirements may apply	^&lt;ByteArray&gt; the decrypted message"	v1		ifTrue: [ self pbes1PrepareFor: message password: password salt: salt ]		ifFalse: [ self pbes2PrepareFor: message password: password salt: salt ].	^cipher decrypt: message</body><body package="PKCS5" selector="encrypt:password:">encrypt: message password: password"Encrypt message using password and deterministicly generated salt.	message &lt;ByteArray&gt; message to be encrypted	password &lt;ByteArray&gt; usually UTF-8 or ASCII encoded secret text	^&lt;ByteArray -&gt; ByteArray&gt; generated salt value with the encrypted message"	| salt ct |	salt := self saltFrom: message password: password.	ct := self encrypt: message password: password salt: salt.	^salt -&gt; ct</body><body package="PKCS5" selector="encrypt:password:salt:">encrypt: message password: password salt: salt"Encrypts message using password and salt.	message &lt;ByteArray&gt; message to be encrypted	password &lt;ByteArray&gt; usually UTF-8 or ASCII encoded secret text	salt &lt;ByteArray&gt; not secret, but randomly generated byte sequence (at least 8 bytes); additional requirements may apply	^&lt;ByteArray&gt; the encrypted message"	v1		ifTrue: [ self pbes1PrepareFor: message password: password salt: salt ]		ifFalse: [ self pbes2PrepareFor: message password: password salt: salt ].	^cipher encrypt: message</body><body package="PKCS5" selector="key:password:salt:">key: keyLength password: password salt: salt"Generate a key using pasword and salt.	keyLength &lt;anInteger&gt; desired byte length of the key (constraints are imposed by the underlying KDF)	password &lt;ByteArray&gt; usually UTF-8 or ASCII encoded secret text	salt &lt;ByteArray&gt; not secret, but randomly generated byte sequence (at least 8 bytes); additional requirements may apply	^&lt;ByteArray&gt; a key of desired length"	^v1		ifTrue: [ self pbkdf1Password: password salt: salt count: self count length: keyLength ]		ifFalse: [ self pbkdf2Password: password salt: salt count: self count length: keyLength ]</body><body package="PKCS5" selector="sign:password:">sign: message password: password"Generate message signature using password and a deterministically generated salt.	message &lt;ByteArray&gt; the message to be signed	password &lt;ByteArray&gt; usually UTF-8 or ASCII encoded secret text	^&lt;ByteArray -&gt; ByteArray&gt; the generated salt value with the message signature"	| salt signature |	salt := self saltFrom: message password: password.	signature := self sign: message password: password salt: salt.	^salt -&gt; signature</body><body package="PKCS5" selector="sign:password:salt:">sign: message password: password salt: salt"Generate message signature using password and salt to generate key of optimal length.	message &lt;ByteArray&gt; the message to be signed	password &lt;ByteArray&gt; usually UTF-8 or ASCII encoded secret text	salt &lt;ByteArray&gt; not secret, but randomly generated byte sequence (at least 8 bytes); additional requirements may apply	^&lt;ByteArray&gt; the message signature"	^self sign: message password: password salt: salt keyLength: mac blockSize</body><body package="PKCS5" selector="sign:password:salt:keyLength:">sign: message password: password salt: salt keyLength: length"Generate message signature using password and salt to generate key of specified length.	message &lt;ByteArray&gt; the message to be signed	password &lt;ByteArray&gt; usually UTF-8 or ASCII encoded secret text	salt &lt;ByteArray&gt; not secret, but randomly generated byte sequence (at least 8 bytes); additional requirements may apply	length &lt;Integer&gt; desired byte length of the key to be used	^&lt;ByteArray&gt; the message signature"	self pbmac1PrepareFor: message password: password salt: salt keyLength: length.	^mac hash: message</body><body package="PKCS5" selector="verify:of:password:">verify: signature of: message password: password"Verifies message signature using password and deterministicly generated salt.	signature &lt;ByteArray&gt; the message signature	message &lt;ByteArray&gt; the signed message	password &lt;ByteArray&gt; usually UTF-8 or ASCII encoded secret text	^&lt;Boolean&gt; signature validity"	| salt |	salt := self saltFrom: message password: password.	^self verify: signature of: message password: password salt: salt</body><body package="PKCS5" selector="verify:of:password:salt:">verify: signature of: message password: password salt: salt"Verifies message signature using password and salt to generate key of optimal length.	signature &lt;ByteArray&gt; the message signature	message &lt;ByteArray&gt; the signed message	password &lt;ByteArray&gt; usually UTF-8 or ASCII encoded secret text	salt &lt;ByteArray&gt; not secret, but randomly generated byte sequence (at least 8 bytes); additional requirements may apply	^&lt;Boolean&gt; signature validity"	^self verify: signature of: message password: password salt: salt keyLength: mac blockSize</body><body package="PKCS5" selector="verify:of:password:salt:keyLength:">verify: signature of: message password: password salt: salt keyLength: length"Verifies message signature using password and salt to generate key of specified length.	signature &lt;ByteArray&gt; the message signature	message &lt;ByteArray&gt; the signed message	password &lt;ByteArray&gt; usually UTF-8 or ASCII encoded secret text	salt &lt;ByteArray&gt; not secret, but randomly generated byte sequence (at least 8 bytes); additional requirements may apply	length &lt;Integer&gt; desired byte length of the key to be used	^&lt;Boolean&gt; signature validity"	self pbmac1PrepareFor: message password: password salt: salt keyLength: length.	^signature = (mac hash: message)</body></methods><methods><class-id>Security.PBC class</class-id> <category>instance creation</category><body package="PKCS5" selector="pbes2WithHMAC_SHA1AndDES_CBC">pbes2WithHMAC_SHA1AndDES_CBC	^self new pbes2WithHMAC_SHA1AndDES_CBC</body><body package="PKCS5" selector="pbes2WithHMAC_SHA1AndDES_EDE3_CBC">pbes2WithHMAC_SHA1AndDES_EDE3_CBC	^self new pbes2WithHMAC_SHA1AndDES_EDE3_CBC</body><body package="PKCS5" selector="pbeWithMD5AndDES_CBC">pbeWithMD5AndDES_CBC	^self new pbeWithMD5AndDES_CBC</body><body package="PKCS5" selector="pbeWithSHA1AndDES_CBC">pbeWithSHA1AndDES_CBC	^self new pbeWithSHA1AndDES_CBC</body><body package="PKCS5" selector="pbmac1WithHMAC_SHA1AndHMAC_SHA1">pbmac1WithHMAC_SHA1AndHMAC_SHA1	^self new pbmac1WithHMAC_SHA1AndHMAC_SHA1</body></methods><methods><class-id>Security.TripleEDE</class-id> <category>pkcs5</category><body package="PKCS5" selector="pkcs5KeySize">pkcs5KeySize	^cipher pkcs5KeySize * 3</body></methods><methods><class-id>Security.CipherBlockChaining</class-id> <category>pkcs5</category><body package="PKCS5" selector="pkcs5KeySize">pkcs5KeySize	^cipher pkcs5KeySize</body></methods><methods><class-id>Security.BlockPadding</class-id> <category>pkcs5</category><body package="PKCS5" selector="pkcs5KeySize">pkcs5KeySize	^cipher pkcs5KeySize</body></methods><methods><class-id>Security.DES</class-id> <category>pkcs5</category><body package="PKCS5" selector="pkcs5KeySize">pkcs5KeySize	^8</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>TripleEDE</name><environment>Security</environment><super>Security.BlockCipherMode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cipher2 cipher3 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>CiphersBase</package></attributes></class><class><name>BlockPadding</name><environment>Security</environment><super>Security.BlockCipherPadding</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>CiphersBase</package></attributes></class><class><name>DES</name><environment>Security</environment><super>Security.BlockCipher</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ignoreParity checkForWeakKey mode keySchedule rowSelectionArray columnSelectionArray traceFile traceStream e_of_R_BitXor_Ki rNext permArray encryptInPlace helperU helperT helper registerR registerU registerT registerL registerTemp spRegisterTransformation skbTransformation spRegisterTransformation1 spRegisterTransformation2 spRegisterTransformation2ScratchRegister spRegisterTransformation3 spRegisterTransformation4 spRegisterTransformation5 spRegisterTransformation6 spRegisterTransformation7 spRegisterTransformation8 skbRegisterTransformation alternateShiftSequence reg arrayClass byteArrayClass largePositiveIntegerClass largePositiveScratchIntR largePositiveScratchIntU </inst-vars><class-inst-vars>registerClass desHelperClass arrayClass byteArrayClass largePositiveIntegerClass spRegisterTransformation skbTransformation skbRegisterTransformation alternateShiftSequence </class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>DES</package></attributes></class><class><name>CipherBlockChaining</name><environment>Security</environment><super>Security.BlockCipherMode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>iv ivBackup </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>CiphersBase</package></attributes></class></st-source>