<?xml version="1.0"?><st-source><!-- Name: DHNotice: Copyright © 2005 Cincom Systems, Inc.  All Rights Reserved.Comment: This class implements the Diffie-Hellman algorithm as described in RFC2631, just the part about generation of the shared secret not the rest of the key agreement specified there in. The algorithm is represented by the DH class. Algorithm parameters can be generated using DHParameterGenerator. For details see the class comments.DbIdentifier: bear73DbTrace: 52196DevelopmentPrerequisites: #(#(#package 'DSA' ''))PackageName: DHParcel: #('DH')PrerequisiteParcels: #(#('DSA' ''))PrintStringCache: (731 0,mkobetic)Version: 7.3.1Date: 6:42:59 pm April 10, 2005 --><time-stamp>From VisualWorks®, 7.3.1 of April 10, 2005 on April 10, 2005 at 6:42:59 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>DHError</name><environment>Security</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DH</category><attributes><package>DH</package></attributes></class><comment><class-id>Security.DHError</class-id><body>Generic superclass for DH errors</body></comment><class><name>DHParameterGenerator</name><environment>Security</environment><super>Core.EventManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars>m l random primalityTest sha q p seed counter </inst-vars><class-inst-vars>random </class-inst-vars><imports></imports><category>DH</category><attributes><package>DH</package></attributes></class><comment><class-id>Security.DHParameterGenerator</class-id><body>This is the generator for Diffie-Hellman algorithm parameters P and Q as described in http://www.ietf.org/rfc/rfc2631.txt. Parameter Q has to be generated first, then parameter P. An instance of the generator has to be instructed what is the expected bit size of the parameters. The bit-size of Q is referred to as m and the bit-size of P is referred to as l. Following expression creates a generator for Q of size 160 bits and P of size 512 bits:	generator := DHParameterGenerator m: 160 l: 512.Parameters are generated automatically when accessed	p := generator p.	q := generator q.The parameters are cached, therefore the accessors will keep returning the same values, until the generator is flushed. After that a new set of parameters will be generated when the parameters are accessed next time. The generator also provides #seed and #counter which can be used to verify the parameters by the other party.Generator makes use of an algorithm for testing primality of large numbers and a random number generator. In the default configuration it uses the algorithms described by the RFC, however it is possible to configure the generator with other algorithms if necessary. See methods m:l:random: and m:l:random:primalityTest: for details.Since generation can take quite some time, generator also generates informative events in the course of generation. These events can be used for things like progress indication. See the class method eventsTriggered for details.Instance Variables:	m	&lt;SmallInteger&gt; the bit-length of q	l	&lt;SmallInteger&gt; the bit-length of p	random	&lt;Random&gt; a random seed generator producing large intergers of at least m-bit size	primalityTest	&lt;PrimalityTest&gt; a probabilistic primality test, with error probability less than 1/(4^50)	sha	&lt;SHA&gt; an instance of the hash function	q	&lt;LargeInteger&gt; a large prime of bit-length m	p	&lt;LargeInteger&gt; a large prime of bit-length l, such that p=jq+1, where j &gt;= 2	seed	&lt;LargeInteger&gt; the seed used to generate q	counter	&lt;SmallInteger&gt; the counter value that yielded pClass Instance Variables:	random	&lt;Random&gt; the default random generator</body></comment><class><name>DHInvalidGroupParameters</name><environment>Security</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DH</category><attributes><package>DH</package></attributes></class><comment><class-id>Security.DHInvalidGroupParameters</class-id><body>RFC2631 requires that the group parameters are large primes such that q divides p - 1, i.e. there is such j, that p=q*j + 1.If this is not the case this exception is signaled.</body></comment><class><name>DHInvalidPublicKey</name><environment>Security</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DH</category><attributes><package>DH</package></attributes></class><comment><class-id>Security.DHInvalidPublicKey</class-id><body>RFC2631 suggests that received public key y, is validated using following criteria:	1) 1 &lt; y &lt; p-1	2) y^g mod p = 1The primary purpose of the validation is to prevent a so called 'small subgroup attack' on the sender's key pair.This error is signaled when the public key doesn't meet this criteria.</body></comment><class><name>DH</name><environment>Security</environment><super>Security.AsymmetricCipher</super><private>false</private><indexed-type>none</indexed-type><inst-vars>p q g random x y </inst-vars><class-inst-vars>random </class-inst-vars><imports></imports><category>DH</category><attributes><package>DH</package></attributes></class><comment><class-id>Security.DH</class-id><body>Diffie-Hellman algorithm as described in RFC2631 (just the part about generation of the shared secret not the rest of the key agreement specified in there). This implementation can be used to establish a shared secret between 2 parties.The 2 parties need to agree on two large primes p and g.These can be either precomputed (often contained in the subject key in a certificate), in which case an instance of the algorithm can be created as follows:	DH p: p g: gor it can be generated on the fly, that is one party generates them and the other party accepts them as such. In which case the first party creates the algorithm as:	alice := DH newand the second party will use the parameters generated by the first one:	bob := DH p: dh1 p g: dh1 gNote that generation of p takes a lot of time, and involves generation of another prime q. On the other hand generation of g is fairly quick given p and q. Therefore it may be useful to precompute just p and q. There is another instance creation method for that:	DH p: p q: qThe secret generation has two phases. First both parties generate their own private/public key pair denoted as x and y:	alicePublic := alice publicValueThe result of publicValue is the public key, private key can usually stay hidden inside the algoritm instance. After this the parties exchange the public values, and continue with a second phase where they compute a shared secret using the other party's public value:	secret := bob sharedSecretUsing: alicePublicNote that the size of of the public value and the size of the shared secret is the size of p (should be at least 512 bits), and the size of the private key x is up to the size of q (q should be at least 160bits long). So the key lengths can be tuned by providing apropriately sized p and q.Instance Variables:	p	&lt;LargePositiveInteger&gt; large prime (512bits or more)	q	&lt;LargePositiveInteger&gt; large prime (160-bits or more), such that p=q*j + 1, where j &gt;= 2	g	&lt;Integer&gt; the generator, such that g &gt; 1 and g=h^((p-1)/q)) mod p, where 1 &lt; h &lt; p-1,	random	&lt;Random&gt; generator for private values x	x	&lt;LargePositiveInteger&gt; randomly generated private key, should be 2 &lt;= x &lt;= q - 2	y	&lt;LargePositiveInteger&gt; public key, such that y =  g ^ x mod p.Class Instance Variables:	random	&lt;Random&gt; the default random generator</body></comment><methods><class-id>Security.DHParameterGenerator</class-id> <category>accessing</category><body package="DH" selector="counter">counter	^counter</body><body package="DH" selector="l">l	^l</body><body package="DH" selector="l:">l: anObject	l := anObject</body><body package="DH" selector="m">m	^m</body><body package="DH" selector="m:">m: anObject	m := anObject</body><body package="DH" selector="p">p	p ifNil: [ self generateP ].	^p</body><body package="DH" selector="primalityTest">primalityTest	^primalityTest</body><body package="DH" selector="primalityTest:">primalityTest: anObject	primalityTest := anObject</body><body package="DH" selector="q">q	q ifNil: [ self generateQ ].	^q</body><body package="DH" selector="random">random	^random</body><body package="DH" selector="random:">random: anObject	random := anObject</body><body package="DH" selector="seed">seed	^seed</body><body package="DH" selector="seed:">seed: anObject	seed := anObject</body><body package="DH" selector="sha">sha	^sha</body><body package="DH" selector="sha:">sha: anObject	sha := anObject</body></methods><methods><class-id>Security.DHParameterGenerator</class-id> <category>initialization</category><body package="DH" selector="m:l:">m: qLength l: pLength"	qLength	&lt;SmallInteger&gt; the bit-length of q, at least 160	pLength	&lt;SmallInteger&gt; the bit-length of p, at least 512"	self m: qLength l: pLength random: self defaultRandom</body><body package="DH" selector="m:l:random:">m: qLength l: pLength random: aRandom"	qLength	&lt;SmallInteger&gt; the bit-length of q, at least 160	pLength	&lt;SmallInteger&gt; the bit-length of p, at least 512	aRandom	&lt;Random&gt; a random seed generator producing large intergers of size &gt;= m bits"	self m: qLength l: pLength random: aRandom primalityTest: (self defaultPrimalityTestUsing: aRandom)</body><body package="DH" selector="m:l:random:primalityTest:">m: qLength l: pLength random: aRandom primalityTest: pTest"	qLength	&lt;SmallInteger&gt; the bit-length of q, at least 160	pLength	&lt;SmallInteger&gt; the bit-length of p, at least 512	aRandom	&lt;Random&gt; a random seed generator producing large intergers of size &gt;= m bits	pTest	&lt;PrimalityTest&gt; a probabilistic primality test, with error probability less than 1/4^50"	m := qLength.	l := pLength.	random := aRandom.	primalityTest := pTest.	sha := SHA new.</body></methods><methods><class-id>Security.DHParameterGenerator</class-id> <category>private</category><body package="DH" selector="defaultPrimalityTestUsing:">defaultPrimalityTestUsing: aRandom	^PrimeSieve on: (MillerRabin random: aRandom)</body><body package="DH" selector="defaultRandom">defaultRandom	^self class random</body><body package="DH" selector="newSeed">newSeed"RFC2631, Section 2.2.1.1, Step 4."	| newSeed |	newSeed := random next.	"Need at least m random bits"	[ newSeed highBit &lt; m ] whileTrue: [ | chunk |		chunk := random next.		newSeed := (newSeed bitShift: chunk highBit) bitOr: chunk ].	^newSeed</body></methods><methods><class-id>Security.DHParameterGenerator</class-id> <category>services</category><body package="DH" selector="flush">flush"Flush all the parameters to make sure next generation creates new ones"	q := p := seed := counter := nil</body><body package="DH" selector="generateP">generateP"Generates parameter P and a counter value. RFC2631, Section 2.2.1.1"	| mp2 lp n power power2 r v w x q2 |	q ifNil: [ self generateQ ].	mp2 := (m / 160) ceiling * 2.	lp := (l / 160) ceiling.	n := (l / 1024) ceiling * 4096.	power := 2 raisedTo: l - 1.	power2 := power * 2.	counter := 0.	q2 := q * 2.	[ n &gt; counter ] whileTrue: [		r := seed + mp2 + (lp * counter).		v := 0.		0 to: lp - 1 do: [ :i |			v := ((sha hashInteger: r + i) bitShift: 160 * i) + v ].		w := v \\ power2.		x := w bitOr: power.		p := x - (x \\ q2) + 1.		self triggerEvent: #tryingP:counter: with: p with: counter.		(p &gt; power and: [ primalityTest value: p ]) ifTrue: [			self triggerEvent: #foundP:counter: with: p with: counter.			^self ].		counter := counter + 1 ].	^DHError raiseSignal: (#ParameterGenerationFailed &lt;&lt; #security &gt;&gt; 'Failed to generate parameters !')</body><body package="DH" selector="generateQ">generateQ"Generates a seed and parameter Q. RFC2631, Section 2.2.1.1"	| mp u power qAndMask qOrMask |	p := counter := nil.	mp := (m / 160) ceiling.	power := 2 raisedTo: m - 1.	qAndMask := power * 2 - 1.	qOrMask := power bitOr: 1.	[	seed := self newSeed.		u := 0.		0 to: mp - 1 do: [ :i |			u := (	(	(sha hashInteger: seed + i)						bitXor: (sha hashInteger: seed + mp + i)					) bitShift: 160 * i				) bitOr: u ].		q := (u bitAnd: qAndMask) bitOr: qOrMask.		self triggerEvent: #tryingQ:seed: with: q with: seed.		primalityTest value: q	] whileFalse.	self triggerEvent: #foundQ:seed: with: q with: seed</body></methods><methods><class-id>Security.DHParameterGenerator class</class-id> <category>events</category><body package="DH" selector="eventsTriggered">eventsTriggered	^#(	tryingQ:seed:		foundQ:seed:		tryingP:counter:		foundP:counter:)</body></methods><methods><class-id>Security.DHParameterGenerator class</class-id> <category>instance creation</category><body package="DH" selector="m:l:">m: qLength l: pLength"	qLength	&lt;SmallInteger&gt; the bit-length of q, at least 160	pLength	&lt;SmallInteger&gt; the bit-length of p, at least 512"	^self new m: qLength l: pLength</body><body package="DH" selector="m:l:random:">m: qLength l: pLength random: aRandom"	qLength	&lt;SmallInteger&gt; the bit-length of q, at least 160	pLength	&lt;SmallInteger&gt; the bit-length of p, at least 512	aRandom	&lt;Random&gt; a random seed generator producing large intergers of size &gt;= m bits"	^self new m: qLength l: pLength random: aRandom</body></methods><methods><class-id>Security.DHParameterGenerator class</class-id> <category>accessing</category><body package="DH" selector="defaultRandom">defaultRandom	^DSSRandom default</body><body package="DH" selector="random">random	^random ifNil: [ self defaultRandom ]</body><body package="DH" selector="random:">random: aRandom"Set the default random generator for DH parameter generators.	aRandom &lt;Random&gt; secure random generator"	random := aRandom</body></methods><methods><class-id>Security.DHInvalidGroupParameters class</class-id> <category>testing</category><body package="DH" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Security.DHInvalidPublicKey class</class-id> <category>testing</category><body package="DH" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Security.DH</class-id> <category>accessing</category><body package="DH" selector="g">g	^g</body><body package="DH" selector="p">p	^p</body><body package="DH" selector="privateKey">privateKey	^x ifNil: [ x := self generateX ]</body><body package="DH" selector="privateKey:">privateKey: aPrivateKey	self shouldNotImplement</body><body package="DH" selector="publicKey">publicKey	^y isNil		ifTrue: [ y := g raisedTo: self privateKey modulo: p ]		ifFalse: [ y ]</body><body package="DH" selector="publicKey:">publicKey: aPublicKey	self shouldNotImplement</body><body package="DH" selector="q">q	^q</body><body package="DH" selector="random">random	^random ifNil: [random := self defaultRandom]</body><body package="DH" selector="x">x	^x</body><body package="DH" selector="y">y	^y</body></methods><methods><class-id>Security.DH</class-id> <category>initialization</category><body package="DH" selector="p:q:g:">p: aPrime q: aQuotient g: aGenerator	p := aPrime.	q := aQuotient.	g := aGenerator ifNil: [ self computeG ]</body><body package="DH" selector="random:">random: aRandom	random := aRandom</body><body package="DH" selector="x:y:">x: aPrivateNumber y: aPublicNumber"This is for using predefined keys, e.g. from DH certificates and such.Note that x and y are required to satisfy y=g^x mod p"	x := aPrivateNumber.	y := aPublicNumber</body></methods><methods><class-id>Security.DH</class-id> <category>private</category><body package="DH" selector="computeG">computeG	| j h |	j := (p - 1)/q.	(j isInteger and: [j &gt; 1]) ifFalse: [		DHInvalidGroupParameters			raiseWith: (Array with: p with: q)			errorString: (#BadGroupParameters &lt;&lt; #security &gt;&gt; 'The group parameters do not meet RFC2631 criteria!') ].	h := 1.	[	h := h + 1.		(g := h raisedTo: j modulo: p) = 1	] whileTrue.	^g</body><body package="DH" selector="defaultRandom">defaultRandom	^self class random</body><body package="DH" selector="generateX">generateX	| size |	x := self random next.	size := q isNil ifTrue: [ p basicSize ] ifFalse: [ q basicSize ].	[ x basicSize &lt; size ] whileTrue: [ | chunk |		chunk := self random next.		x := (x bitShift: (chunk basicSize * 8)) bitOr: chunk ].	^q isNil		ifTrue: [ x \\ p ]		ifFalse: [ x \\ q ]</body></methods><methods><class-id>Security.DH</class-id> <category>deprecated</category><body package="DH" selector="computePublicKey">computePublicKey"This is the first phase of the handshake, where the publicly exchanged value is generated"	^self computePublicValue</body><body package="DH" selector="computePublicValue">computePublicValue"This is the first phase of the handshake, where the publicly exchanged value is generated"	^self publicValue</body><body package="DH" selector="computeSharedSecretUsing:">computeSharedSecretUsing: aPublicKey"This is the second phase of the handshake where the shared secret is generatedusing the public value received from the other party"		^self sharedSecretUsing: aPublicKey</body></methods><methods><class-id>Security.DH</class-id> <category>services</category><body package="DH" selector="decrypt:">decrypt: aByteArray"Decrypt aByteArray using the previously assigned private key."	"This algorithm doesn't support encryption"	^self shouldNotImplement</body><body package="DH" selector="encrypt:">encrypt: aByteArray"Encrypts aByteArray using the previously assigned public key"	"This algorithm doesn't support encryption"	^self shouldNotImplement</body><body package="DH" selector="flush">flush"Flush the keys so that the next call to computePublicKey generates new ones"	x := y := nil</body><body package="DH" selector="publicValue">publicValue"This is the first phase of the handshake, where the publicly exchanged value is generated"	^self publicKey</body><body package="DH" selector="sharedSecretUsing:">sharedSecretUsing: aPublicValue"This is the second phase of the handshake where the shared secret is generated using the public value received from the other party"		(1 &lt; aPublicValue and: [ aPublicValue &lt; p ]) ifFalse: [		DHInvalidPublicKey new			messageText: (#PublicValueOutOfRange &lt;&lt; #security &gt;&gt; 'Public value out of required range &lt;1; p - 1&gt;!');			parameter: aPublicValue;			raiseSignal ].	"This is required check as per RFC2631, section 2.1.5"	(q isNil or: [ (aPublicValue raisedTo: q modulo: p) = 1 ]) ifFalse: [		DHInvalidPublicKey new			messageText: (#PublicValueVulnerable &lt;&lt; #security &gt;&gt; 'Public value possibly vulnerable');			parameter: aPublicValue;			raiseSignal ].	^aPublicValue raisedTo: x modulo: p</body><body package="DH" selector="sign:">sign: aMessageArray"Compute a signature of aMessageArray."	"This algorithm doesn't support signing"	^self shouldNotImplement</body><body package="DH" selector="verify:of:">verify: aSignatureArray of: aMessageArray"Denies or confirms that aSignatureArray is a signature of aMessageArray."	"This algorithm doesn't support signing"	^self shouldNotImplement</body></methods><methods><class-id>Security.DH class</class-id> <category>instance creation</category><body package="DH" selector="new">new	^self newFrom: (DHParameterGenerator m: 160 l: 512)</body><body package="DH" selector="newFrom:">newFrom: aParameterGenerator"This is useful when the parameters are generated on the fly, it makes sense to reuse the random generator that was used to generate the parameters"	aParameterGenerator p ifNil: [		aParameterGenerator generateP ].	^(self		p: aParameterGenerator p		q: aParameterGenerator q	)	random: aParameterGenerator random;		yourself</body><body package="DH" selector="p:g:">p: aPrime g: aGenerator"aPrime	&lt;LargePositiveInteger&gt;	must be a large prime (512 bits and more).aGenerator	&lt;Integer&gt;	must be an integer, such that g &gt; 1 and g=h^((p-1)/q)) mod p,		where 1 &lt; h &lt; p-1 (g has order q mod p, i.e. g^q mod p = 1)"	^self p: aPrime q: nil g: aGenerator</body><body package="DH" selector="p:q:">p: aPrime q: aQuotient"aPrime must be a large prime (512 bits and more).aQuotient must be a large prime (160 bits and more) that divides (aPrime - 1)"	^self p: aPrime q: aQuotient g: nil</body><body package="DH" selector="p:q:g:">p: aPrime q: aQuotient g: aGenerator"aPrime	&lt;LargePositiveInteger&gt;	must be a large prime (512 bits and more).aQuotient	&lt;LargePositiveInteger&gt;	must be a large prime (160 bits and more) that divides (aPrime - 1)aGenerator	&lt;Integer&gt;	must be an integer, such that g &gt; 1 and g=h^((p-1)/q)) mod p,		where 1 &lt; h &lt; p-1 (g has order q mod p, i.e. g^q mod p = 1)"	^super new		p: aPrime q: aQuotient g: aGenerator;		yourself</body></methods><methods><class-id>Security.DH class</class-id> <category>accessing</category><body package="DH" selector="defaultRandom">defaultRandom	^DSSRandom default</body><body package="DH" selector="random">random	^random ifNil: [ self defaultRandom ]</body><body package="DH" selector="random:">random: aRandom"Set the default random generator for DH algorithms.	aRandom &lt;Random&gt; secure random generator"	random := aRandom</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>AsymmetricCipher</name><environment>Security</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>CiphersBase</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>EventManager</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handlers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Dependency Events</category><attributes><package>System-Dependency Events</package></attributes></class></st-source>