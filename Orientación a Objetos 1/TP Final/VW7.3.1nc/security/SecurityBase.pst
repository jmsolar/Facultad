<?xml version="1.0"?><st-source><!-- Name: SecurityBaseNotice: Copyright © 2005 Cincom Systems, Inc.  All Rights Reserved.DbIdentifier: bear73DbTrace: 52757PackageName: SecurityBaseParcel: #('SecurityBase')PrintStringCache: (731 1,mkobetic)Version: 7.3.1Date: 6:42:03 pm April 10, 2005 --><time-stamp>From VisualWorks®, 7.3.1 of April 10, 2005 on April 10, 2005 at 6:42:03 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Security</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>SecurityBase</category><attributes><package>SecurityBase</package></attributes></name-space><class><name>ThirtyTwoBitRegister</name><environment>Security</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hi low </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Hashes</category><attributes><package>SecurityBase</package></attributes></class><comment><class-id>Security.ThirtyTwoBitRegister</class-id><body>Increases efficiency of computations on 32-bit numbers by avoiding overflow into the large intergers. Works by splitting the 32-bit value in half to which are guaranteed to fit into the SmallInteger range.Instance Variables:	hi	&lt;SmallInteger&gt; the more significant half of the register	low	&lt;SmallInteger&gt; the less significant half of the register</body></comment><methods><class-id>Security.ThirtyTwoBitRegister</class-id> <category>accessing</category><body package="SecurityBase" selector="byte1">byte1	^hi bitShift: -8</body><body package="SecurityBase" selector="byte2">byte2	^hi bitAnd: 255</body><body package="SecurityBase" selector="byte3">byte3	^low bitShift: -8</body><body package="SecurityBase" selector="byte4">byte4	^low bitAnd: 255</body><body package="SecurityBase" selector="hi">hi	^ hi</body><body package="SecurityBase" selector="hi:">hi: anInteger	 hi := anInteger</body><body package="SecurityBase" selector="hi:low:">hi: anInteger1 low: anInteger2	 hi := anInteger1.	low := anInteger2</body><body package="SecurityBase" selector="low">low	^ low</body><body package="SecurityBase" selector="low:">low: anInteger	 low := anInteger</body></methods><methods><class-id>Security.ThirtyTwoBitRegister</class-id> <category>operations</category><body package="SecurityBase" selector="+=">+= aThirtyTwoBitRegister	"Replace my contents with the sum of the given register and my current contents."	low := low + aThirtyTwoBitRegister low.	hi := (hi + aThirtyTwoBitRegister hi			+ (low &gt; 16rFFFF ifTrue: [1] ifFalse: [0] )		) bitAnd: 16rFFFF.	low := low bitAnd: 16rFFFF</body><body package="SecurityBase" selector="&lt;&lt;">&lt;&lt; shift 	| tl |	shift &gt; 16		ifTrue: 			[hi := (low bitShift: shift - 16)						bitAnd: 65535.			low := 0]		ifFalse: 			[tl := low bitShift: shift - 16.			low := (low bitShift: shift)						bitAnd: 65535.			hi := ((hi bitShift: shift)						bitAnd: 65535)						+ tl]</body><body package="SecurityBase" selector="=">= aThirtyTwoBitRegister	^(hi = aThirtyTwoBitRegister hi) and:[ low = aThirtyTwoBitRegister low]</body><body package="SecurityBase" selector="&gt;&gt;">&gt;&gt; shift	low := low bitAnd: 16rffff.	low := ((hi bitShift: 16 - shift ) bitAnd: 16rFFFF) bitOr: (low bitShift: shift negated).	hi :=(hi bitShift: shift negated).</body><body package="SecurityBase" selector="addIn:">addIn: a32BitRegister"There's +=, but I want consistent naming and there's no good binary equivalent for xor"	low := low + a32BitRegister low.	hi := (hi + a32BitRegister hi			+ (low &gt; 16rFFFF ifTrue: [1] ifFalse: [0])		) bitAnd: 16rFFFF.	low := low bitAnd: 16rFFFF</body><body package="SecurityBase" selector="bitAnd:">bitAnd: aThirtyTwoBitRegister	hi := hi bitAnd: aThirtyTwoBitRegister hi.	low := low bitAnd: aThirtyTwoBitRegister low.</body><body package="SecurityBase" selector="bitInvert">bitInvert	hi := hi bitXor: 16rFFFF.	low := low bitXor: 16rFFFF.</body><body package="SecurityBase" selector="bitOr:">bitOr: aThirtyTwoBitRegister	hi := hi bitOr: aThirtyTwoBitRegister hi.	low := low bitOr: aThirtyTwoBitRegister low.</body><body package="SecurityBase" selector="bitXor:">bitXor: aThirtyTwoBitRegister	hi := hi bitXor: aThirtyTwoBitRegister hi.	low := low bitXor: aThirtyTwoBitRegister low.</body><body package="SecurityBase" selector="leftRotateBy:">leftRotateBy: bits	| count |	count := bits \\ 32.	count &gt; 16		ifTrue: [ | left right newHi |			left := count - 16.			right := left - 16.			newHi := (low specialLeftShift: left) bitOr: (hi bitShift: right).			low := (hi specialLeftShift: left) bitOr: (low bitShift: right).			hi := newHi]		ifFalse: [ |  left right newHi |			left := count.			right := left - 16.			newHi := (hi specialLeftShift: left) bitOr: (low bitShift: right).			low := (low specialLeftShift: left) bitOr: (hi bitShift: right).			hi := newHi]</body><body package="SecurityBase" selector="rightRotateBy:">rightRotateBy: bits	^self leftRotateBy: 32 - bits</body><body package="SecurityBase" selector="set:">set: a32BitRegister	hi := a32BitRegister hi.	low := a32BitRegister low</body><body package="SecurityBase" selector="xorIn:">xorIn: a32BitRegister"Again added just for more consistent naming"	low := low bitXor: a32BitRegister low.	hi := hi bitXor: a32BitRegister hi</body></methods><methods><class-id>Security.ThirtyTwoBitRegister</class-id> <category>conversions</category><body package="SecurityBase" selector="asInteger">asInteger	"Answer the integer value"	| int |	int := LargePositiveInteger basicNew: 4.	int basicAt: 3 put: (hi bitAnd: 16rff).	int basicAt:4 put: ((hi bitShift: 0 - 8) bitAnd: 16rff).	int basicAt: 1 put: (low bitAnd: 16rff).	int basicAt:2 put: ((low bitShift: 0 - 8) bitAnd: 16rff).	^int	"^ (hi bitShift: 16) + low"</body><body package="SecurityBase" selector="load:">load: anInteger	"Set my contents to the value of given integer."	low := anInteger bitAnd: 16rFFFF.	hi := (anInteger bitShift: -16) bitAnd: 16rFFFF."	self asInteger = anInteger		ifFalse: [self error: 'out of range: ', anInteger printString]."</body><body package="SecurityBase" selector="loadFrom:at:">loadFrom: aByteArray at: index	"Load my 32-bit value from the four bytes of the given ByteArray starting at the given index. Consider the first byte to contain the most significant bits of the word (i.e., use big-endian byte ordering)."	hi := ((aByteArray at: index) bitShift: 8) + ( aByteArray at: index + 1).	low := ((aByteArray at: index + 2) bitShift: 8) + ( aByteArray at: index + 3).</body><body package="SecurityBase" selector="reverseLoadFrom:at:">reverseLoadFrom: aByteArray at: index	"Load my 32-bit value from the four bytes of the given ByteArray starting at the given index. Consider the first byte to contain the most significant bits of the word (i.e., use little-endian byte ordering)."	hi := ((aByteArray at: index+ 3) bitShift: 8) + ( aByteArray at: index + 2).	low := ((aByteArray at: index + 1) bitShift: 8) + ( aByteArray at: index ).</body><body package="SecurityBase" selector="reverseStoreTo:at:">reverseStoreTo: aByteArray at: index"Little-endian"	aByteArray		at: index put: (low bitAnd: 255);		at: index + 1 put: (low bitShift: -8);		at: index + 2 put: (hi bitAnd: 255);		at: index + 3 put: (hi bitShift: -8)</body><body package="SecurityBase" selector="storeTo:at:">storeTo: aByteArray at: index"Big-endian"	aByteArray		at: index put: (hi bitShift: -8);		at: index + 1 put: (hi bitAnd: 255);		at: index + 2 put: (low bitShift: -8);		at: index + 3 put: (low bitAnd: 255)</body></methods><methods><class-id>Security.ThirtyTwoBitRegister</class-id> <category>printing</category><body package="SecurityBase" selector="printOn:">printOn: aStream	"Print my contents in hex put an R in front to show that it is a register being printed."	aStream nextPutAll: (#RegisterPrefix &lt;&lt; #security &gt;&gt; 'R:') asString.	self asInteger printOn: aStream base: 16.	aStream nextPutAll: (#DecimalPrefix &lt;&lt; #security &gt;&gt; 'D:') asString.	self asInteger printOn: aStream base: 10.</body></methods><methods><class-id>Security.ThirtyTwoBitRegister class</class-id> <category>instance creation</category><body package="SecurityBase" selector="new">new	"Answer a new instance whose initial contents is zero."	^ super new load: 0</body></methods><methods><class-id>Core.LargeNegativeInteger</class-id> <category>security</category><body package="SecurityBase" selector="asBigEndianByteArray">asBigEndianByteArray"Convert receiver to a byte array of apropriate size in network (a.k.a big endian) format.Not supported for negative integers."	^self errorConvertingNegativeIntegerToBytes</body><body package="SecurityBase" selector="asBigEndianByteArrayPaddedTo:">asBigEndianByteArrayPaddedTo: numberOfBytes"Encode the receiver in the network (aka big endian) order. Pad the byte array in the beginning to size anInteger.anInteger bytes has to be enough to store the receiver. The receiver is expected to be non-negative."	^self errorConvertingNegativeIntegerToBytes</body></methods><methods><class-id>Core.SmallInteger class</class-id> <category>hashes</category><body package="SecurityBase" selector="leftShiftArray">leftShiftArray^#(2r01111111111111112r00111111111111112r00011111111111112r00001111111111112r00000111111111112r00000011111111112r00000001111111112r00000000111111112r00000000011111112r00000000001111112r00000000000111112r00000000000011112r00000000000001112r00000000000000112r00000000000000012r0000000000000000)</body></methods><methods><class-id>Core.SmallInteger</class-id> <category>security</category><body package="SecurityBase" selector="asBigEndianByteArray">asBigEndianByteArray"Convert receiver to a byte array of apropriate size in network (a.k.a big endian) format.Not supported for negative integers."	self negative ifTrue: [ self errorConvertingNegativeIntegerToBytes ].	^self &gt; 65535		ifTrue: [ | high low |			high := self bitShift: -16.			low := self bitAnd: 65535.			high &gt; 255				ifTrue: [ ByteArray						with:	(high bitShift: -8)						with: (high bitAnd: 255)						with: (low bitShift: -8)						with: (low bitAnd: 255) ]				ifFalse: [ ByteArray						with: (high bitAnd: 255)						with: (low bitShift: -8)						with: (low bitAnd: 255) ] ]		ifFalse: [ self &gt; 255				ifTrue: [ ByteArray						with: (self bitShift: -8)						with: (self bitAnd: 255) ]				ifFalse: [ ByteArray						with: (self bitAnd: 255) ] ]</body><body package="SecurityBase" selector="specialLeftShift:">specialLeftShift: aShift	" yes this is the just like the bitShift: message but  I am saving some cyles since I know the number that I am shifting over.so if it can't be done with a small integer result d the shift left with the values that I know have to be in there. this saves a few sends and test which done over a millioniterations saves time especially with the block ciphers since we handle only 8 bytes at a time so to do a megabyte requires 128000 iterations the faster each of those iterations the more I can encrypt in each second so every cycle counts so since I am only in this case concerned with 16 bits only mask before the shift to guarantee that I will always result with a small int in the primative.aShift must be betwwen 0 and 16"aShift = 0 ifFalse:[^(self bitAnd: (self class leftShiftArray at: aShift)) bitShift: aShift]</body></methods><methods><class-id>Core.ByteArray class</class-id> <category>encryption</category><body package="SecurityBase" selector="fromHexString:">fromHexString: aString"(((self fromHexString: 'A00B0210FF00')))"	| ba s lookup |	lookup := '123456789ABCDEF'.	ba := self new: aString size // 2.	s := aString readStream.	1 to: ba size do: [ :i || h l |		h := s next.		h := h = $0 ifTrue: [0] ifFalse: [lookup indexOf: h].		l := s next.		l := l = $0 ifTrue: [0] ifFalse: [lookup indexOf: l].		ba at: i put: ((h bitShift: 4) bitOr: l) ].	^ba</body></methods><methods><class-id>Core.ByteArray</class-id> <category>security</category><body package="SecurityBase" selector="asHexString">asHexString"(((#[160 11 2 16 255 0] asHexString)))"	| lookup s ws |	lookup := '0123456789ABCDEF'.	s := String new: self size * 2.	ws := s writeStream.	self do: [ :b |		ws nextPut: (lookup at: (b bitShift: -4) + 1).		ws nextPut: (lookup at: (b bitAnd: 15) + 1) ].	^s</body><body package="SecurityBase" selector="asLargePositiveInteger">asLargePositiveInteger"do the reverse of the asByteArray in LargePositiveInteger"	| int |	int := LargePositiveInteger basicNew: self size.	self keysAndValuesDo: [ :index :each | int basicAt: (self size + 1- index) put: each ].	^int</body></methods><methods><class-id>Core.LargePositiveInteger</class-id> <category>security</category><body package="SecurityBase" selector="asBigEndianByteArray">asBigEndianByteArray"Convert receiver to a byte array of apropriate size in network (a.k.a big endian) format.Not supported for negative integers."	| answer top |	top := self basicSize + 1.	answer := ByteArray new: top - 1.	1 to: top - 1 do: [:i |		answer at: i put: (self basicAt: top - i)].	^answer</body><body package="SecurityBase" selector="asBigEndianByteArrayPaddedTo:">asBigEndianByteArrayPaddedTo: numberOfBytes"Encode the receiver in the network (aka big endian) order. Pad the byte array in the beginning to size anInteger.anInteger bytes has to be enough to store the receiver. The receiver is expected to be non-negative."	| answer top pad |	self basicSize &gt; numberOfBytes ifTrue: [ self errorInsufficientSpaceForIntegerToBytesConversion ].	top := self basicSize + 1.	pad := numberOfBytes - top + 1.	answer := ByteArray new: numberOfBytes.	1 to: top - 1 do: [:i |		answer at: pad + i put: (self basicAt: top - i)].	^answer</body></methods><methods><class-id>Core.Integer</class-id> <category>security</category><body package="SecurityBase" selector="asBigEndianByteArrayPaddedTo:">asBigEndianByteArrayPaddedTo: anInteger"Encode the receiver in the network (aka big endian) order. Pad the byte array in the beginning to size anInteger.anInteger bytes has to be enough to store the receiver. The receiver is expected to be non-negative."	| ba counter number |	self negative ifTrue: [ self errorConvertingNegativeIntegerToBytes ].	ba := ByteArray new: anInteger.	counter := anInteger.	number := self.	[number &gt; 0] whileTrue: [		counter = 0 ifTrue: [ self errorInsufficientSpaceForIntegerToBytesConversion ].		ba at: counter put: (number bitAnd: 255).		counter := counter - 1.		number := number bitShift: -8 ].	^ba</body></methods><methods><class-id>Core.Integer</class-id> <category>deprecated</category><body package="SecurityBase" selector="asByteArray">asByteArray"WARNING: This selector is too ambiguous and is being deprecated. It will be removed in the next release."	^self asBigEndianByteArray</body><body package="SecurityBase" selector="asByteArrayPaddedTo:">asByteArrayPaddedTo: anInteger"WARNING: This selector is too ambiguous and is being deprecated. It will be removed in the next release."	^self asBigEndianByteArrayPaddedTo: anInteger</body></methods><methods><class-id>Core.Integer</class-id> <category>security</category><body package="SecurityBase" selector="errorConvertingNegativeIntegerToBytes">errorConvertingNegativeIntegerToBytes	self error: (#errCantConvertNegativeNumbers &lt;&lt; #security &gt;&gt; 'Cannot convert negative integer into a big-endian byte array').</body><body package="SecurityBase" selector="errorInsufficientSpaceForIntegerToBytesConversion">errorInsufficientSpaceForIntegerToBytesConversion	self error: (#InsufficientSize &lt;&lt; #security &gt;&gt; 'Not enough room for the whole number').</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>LargePositiveInteger</name><environment>Core</environment><super>Core.LargeInteger</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>SmallInteger</name><environment>Core</environment><super>Core.Integer</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars>minVal maxVal maxBits maxBytes </class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>LargeNegativeInteger</name><environment>Core</environment><super>Core.LargeInteger</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class></st-source>