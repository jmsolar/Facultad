<?xml version="1.0"?><st-source><!-- Name: RSANotice: Copyright © 2005 Cincom Systems, Inc.  All Rights Reserved.Comment: This package implements RSA encryption as described in PKCS#1. The algorithm itself is represented by the class RSA and provides both encryption/decryption and signing/verification API. The keys can be generated with the RSAKeyGenerator and are instantiated as RSAPublicKey and RSAPrivateKey. For details please refer to the class comments.DbIdentifier: bear73DbTrace: 52178DevelopmentPrerequisites: #(#(#package 'CiphersBase' ''))PackageName: RSAParcel: #('RSA')PrerequisiteParcels: #(#('CiphersBase' ''))PrintStringCache: (731 0,mkobetic)Version: 7.3.1Date: 6:42:23 pm April 10, 2005 --><time-stamp>From VisualWorks®, 7.3.1 of April 10, 2005 on April 10, 2005 at 6:42:23 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>RSAKeyGenerator</name><environment>Security</environment><super>Security.KeyGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mask q p n e d </inst-vars><class-inst-vars>e </class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>RSA</package></attributes></class><comment><class-id>Security.RSAKeyGenerator</class-id><body>The usual key sizes start from 512 bits and go up from there. The longer the key the more expensive are the cryptographic operations. Note however that 512 bit keys are considered weak given today's computers. The generator produces a couple of parameters, signalling various events along the way for observation. Finally packages them up as RSAPublicKey and RSAPrivateKey, which are accessible using the #privateKey and #publicKey messages. To force the generator to produce a new pair of keys it has to be cleared using the #flush message.Instance Variables:	mask	&lt;LargeInteger&gt; a mask used to enforce the size of the prime factors p and q	q	&lt;LargeInteger&gt; a large prime of bit-length aproximately keySize // 2	p	&lt;LargeInteger&gt; a large prime of bit-length aproximately keySize // 2	n	&lt;LargeInteger&gt; modulus, n=p*q, of bit-length keySize	e	&lt;LargeInteger&gt; public exponent, usually one of 3, 17, 65537	d	&lt;LargeInteger&gt; private exponent, of large bit-lengthClass Instance Variables:	e	&lt;Integer&gt; default public exponent value (usually something like 3, 17, 65537)</body></comment><class><name>RSA</name><environment>Security</environment><super>Security.AsymmetricCipher</super><private>false</private><indexed-type>none</indexed-type><inst-vars>privateKey publicKey hash </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>RSA</package></attributes></class><comment><class-id>Security.RSA</class-id><body>This class implements the RSA algorithm as described in PKCS#1. It provides both encryption/decryption and signing/verification. Note that the same basic algorithm is used for both encryption and signing, therefore the result of signing is also a byte array, rather than a special "signature" object. Note that the PKCS#1 standard allows different hash functions to be used to compute a message digest for signing. Therefore one is expected to initialize the algorithm with one of #useSHA or #useMD5. Signing some data using MD5 digest would look as follows:	signatureBytes :=		RSA new			useMD5;			privateKey: anRSAPrivateKey;			sign: dataBytes.To verify the signature use following:	isAuthenticBoolean :=		RSA new			useMD5;			publicKey: anRSAPublicKey;			verify: signatureBytes of: dataBytesIf the algorithm is not configured with specific hash function, then the argument of the #sign: message is expected to be an externally computed digest of the original message. The RSA algorithm will skip the hashing step in that case. Same applies to the verification operation. This feature is used by SSL protocol for example, which does the hashing in its own way.Encryption operations don't use hashing at all, so the #useMD5 or #useSHA are not necessary. Encryption is used in the usual way.	encryptedBytes :=		RSA new			publicKey: anRSAPublicKey;			encrypt: plainBytes				plainMessageBytes :=		RSA new			privateKey: anRSAPrivateKey;			decrypt: encryptedMessageBytesInstance Variables:	privateKey	&lt;RSAPrivateKey&gt; private key to use for decryption or signing	publicKey	&lt;RSAPublicKey&gt; public key to use for encryption or signature verification	hash	&lt;Hash&gt; a hash algorithm to use for signing</body></comment><class><name>RSAError</name><environment>Security</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>RSA</package></attributes></class><class><name>RSADecodingError</name><environment>Security</environment><super>Security.RSAError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>RSA</package></attributes></class><class><name>RSANotImplemented</name><environment>Security</environment><super>Security.RSAError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>RSA</package></attributes></class><class><name>RSAMessageTooLong</name><environment>Security</environment><super>Security.RSAError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>RSA</package></attributes></class><class><name>RSAKey</name><environment>Security</environment><super>Security.EncryptionKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>n </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>RSA</package></attributes></class><comment><class-id>Security.RSAKey</class-id><body>Instance Variables:	n	&lt;LargeInteger&gt;	modulus, n=p*q, limits the size of the keys and the data to be encrypted</body></comment><class><name>RSAPublicKey</name><environment>Security</environment><super>Security.RSAKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>e </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>RSA</package></attributes></class><comment><class-id>Security.RSAPublicKey</class-id><body>Instance Variables:	e	&lt;LargeInteger&gt;	public exponent, usually one of 3, 17, 65537</body></comment><class><name>RSAPrivateKey</name><environment>Security</environment><super>Security.RSAKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>d e p q dP dQ qInv otherFactors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>RSA</package></attributes></class><comment><class-id>Security.RSAPrivateKey</class-id><body>Instance Variables:	d	&lt;LargeInteger&gt;	private exponent, of large bit-length	e	&lt;LargeInteger&gt;	public exponent, usually one of 3, 17, 65537	p	&lt;LargeInteger&gt;	the first factor of n	q	&lt;LargeInteger&gt;	the second factor of n	dP	&lt;LargeInteger&gt;	sub-exponent1, dP = d mod (p - 1)	dQ	&lt;LargeInteger&gt;	sub-exponent2, dQ = d mod (q - 1)	qInv	&lt;LargeInteger&gt;	CRT coefficient, qInv = 1/q mod p	otherFactors	&lt;Array&gt;	additional factors of n, triplets including the factor, its sub-exponent and CRT coefficient</body></comment><shared-variable><name>ASN1dictionaryForHashSigning</name><environment>Security.RSA</environment><private>false</private><constant>false</constant><category>constants</category><attributes><package>RSA</package></attributes></shared-variable><methods><class-id>Security.RSAKeyGenerator</class-id> <category>accessing</category><body package="RSA" selector="d">d	^d</body><body package="RSA" selector="e">e	^e ifNil: [ e := self class e ]</body><body package="RSA" selector="e:">e: anInteger"	anInteger &lt;Integer&gt; default public exponent value (usually something like 3, 17, 65537)"	e := anInteger</body><body package="RSA" selector="n">n	^n</body><body package="RSA" selector="p">p	^p</body><body package="RSA" selector="q">q	^q</body></methods><methods><class-id>Security.RSAKeyGenerator</class-id> <category>initialization</category><body package="RSA" selector="keySize:random:primalityTest:">keySize: bitLength random: aRandom primalityTest: pTest"	bitLength	&lt;SmallInteger&gt; the bit-length of the modulus n	aRandom	&lt;Random&gt; a random seed generator producing large intergers	pTest	&lt;PrimalityTest&gt; a probabilistic primality test"	super keySize: bitLength random: aRandom primalityTest: pTest.	mask := (1 bitShift: bitLength // 2 - 1) bitOr: 1.</body></methods><methods><class-id>Security.RSAKeyGenerator</class-id> <category>private</category><body package="RSA" selector="generateKeys">generateKeys	| product euclid |	q ifNil: [ self generateQ ].	[	product := (p - 1) * (q - 1).		euclid := EuclidAlgorithm with: self e with: product.		euclid lehmer.		euclid gcd = 1	] whileFalse: [		self triggerEvent: #rejectingQ: with: q.		p := q.		self generateQ ].	d := euclid firstCoefficient \\ product.	self triggerEvent: #generatedD:usingE: with: d with: e.	n := p * q.	self triggerEvent: #generatedN: with: n.</body><body package="RSA" selector="generateP">generateP	[	p := self nextRandom bitOr: mask.		self triggerEvent: #tryingP: with: p.		primalityTest value: p	] whileFalse.	self triggerEvent: #foundP: with: p</body><body package="RSA" selector="generateQ">generateQ	p ifNil: [ self generateP ].	[	q := self nextRandom bitOr: mask.		self triggerEvent: #tryingQ: with: q.		(primalityTest value: q) and: [ p ~= q ]	] whileFalse.	self triggerEvent: #foundQ: with: q</body><body package="RSA" selector="nextRandom">nextRandom	| bitSize x |	"Let's assume that the bit sizes are byte aligned"	bitSize := keySize // 16 "half of the modulus in bytes".	x := random next.	[ x basicSize &lt; bitSize ] whileTrue: [ | chunk |		chunk := random next.		x := (x bitShift: (chunk basicSize * 8)) bitOr: chunk ].	^(x basicSize &gt; bitSize)		ifTrue: [ x bitShift: (bitSize - x basicSize) * 8 ]		ifFalse: [ x ]</body></methods><methods><class-id>Security.RSAKeyGenerator</class-id> <category>services</category><body package="RSA" selector="flush">flush"Flush all the parameters to make sure next generation creates new ones"	q := p := n := e := d := nil</body><body package="RSA" selector="privateKey">privateKey	n ifNil: [ self generateKeys ].	^(RSAPrivateKey d: d n: n)		p: self p;		q: self q;		yourself</body><body package="RSA" selector="publicKey">publicKey	n ifNil: [ self generateKeys ].	^RSAPublicKey e: e n: n</body></methods><methods><class-id>Security.RSAKeyGenerator class</class-id> <category>accessing</category><body package="RSA" selector="defaultE">defaultE	^65537</body><body package="RSA" selector="e">e	^e ifNil: [^self defaultE]</body><body package="RSA" selector="e:">e: anInteger"	anInteger &lt;Integer&gt; default public exponent value (usually something like 3, 17, 65537)	self e: 3"	e := anInteger</body></methods><methods><class-id>Security.RSAKeyGenerator class</class-id> <category>events</category><body package="RSA" selector="eventsTriggered">eventsTriggered	^#(	tryingQ:		foundQ:		tryingP:		foundP:		rejectingQ:		generatedD:usingE:		generatedN:)</body></methods><methods><class-id>Security.RSA</class-id> <category>deprecated</category><body package="RSA" selector="breakByteArray:intoBlocksOf:">breakByteArray: aByteArray intoBlocksOf: blockSize 	| collectionSize collection start end |	collectionSize := aByteArray size // blockSize.	aByteArray size \\ blockSize = 0 ifFalse: [collectionSize := collectionSize + 1].	collection := OrderedCollection new: collectionSize.	start := 0.	1 to: collectionSize		do: 			[:index | 			| tmpString |			end := start + blockSize.			end &gt; aByteArray size ifTrue: [end := aByteArray size].			tmpString := aByteArray copyFrom: start + 1 to: end.			collection add: tmpString.			start := end ].	^collection</body><body package="RSA" selector="decrypt:withKey:">decrypt: aMessageByteArray withKey: anRSAPrivateKey 	"decrypt a block per PKCS 1 of the RSA spec this includes the padding rules specified in theat 	document and it is block type 1 in the SSL document 	finnaly I understood how they linked together"	"this is the wrapper method so you can hand over an array that is the entire message ussually a byte 	array that isn't nessesarily sized for N so I break the lot up into 	sub arrays that are sized and then decrypt each of those and then hand back a byteArray the 	represents the orginal message.  the decrypttion will automagically break it up into the maximum sized 	blocks and then decrypt the message and hand back a byteArray representing the original message."	| nlength collection decipherCollection offset totalMessageSize messageArray |	nlength := anRSAPrivateKey n digitLength.	^aMessageByteArray size &gt; nlength		ifFalse: ["if the incomingMessage is the right size the go ahead and encipher the array and return the result."			self decryptRSAES: aMessageByteArray withKey: anRSAPrivateKey]		ifTrue: ["then we need to break up the array into a collection of arrays that are no larger than 			blockSize and encrypt each one and assemble them back together into one ByteArray and return that"			collection := self breakByteArray: aMessageByteArray intoBlocksOf: nlength.			decipherCollection := OrderedCollection new: collection size.			collection keysAndValuesDo: [ :index :eachArray |				decipherCollection add: (self decryptRSAES: aMessageByteArray withKey: anRSAPrivateKey)].			offset := 1.			totalMessageSize := decipherCollection inject: 0 into: [:subTotal :next | subTotal + next size].			messageArray := ByteArray new: totalMessageSize.			offset := 1.			decipherCollection keysAndValuesDo: [ :index :eachArray |					messageArray						replaceBytesFrom: offset						to: offset + nlength - 1						with: (decipherCollection at: index)						startingAt: 1.					offset := offset + nlength].			messageArray]</body><body package="RSA" selector="decryptRSADP:withKey:">decryptRSADP: aMessageInteger withKey: anRSAPrivateKey 	| h m1 m2 m mq mp p q cp cq |	^anRSAPrivateKey isSecondForm		ifFalse: [ aMessageInteger				raisedTo: anRSAPrivateKey d				modulo: anRSAPrivateKey n ]		ifTrue: ["this is an optimization for PrivateKey to do the decryption faster using the Chinese 			remainder theorem, to do this the privateKey needs the additional values for the second 			form of the key. the old ancient chinese secret laying beneath the sheets."			p := anRSAPrivateKey p.			q := anRSAPrivateKey q.			cp := aMessageInteger \\ p.			cq := aMessageInteger \\ q.			mq := cq raisedTo: anRSAPrivateKey dq modulo:  q .			mp := cp raisedTo: anRSAPrivateKey dp modulo:  p .			m :=  ((((mp - mq) \\ p) * anRSAPrivateKey qInv) \\ p) *  q + mq.			m1 := aMessageInteger raisedTo: anRSAPrivateKey dp modulo: anRSAPrivateKey p .			m2 := aMessageInteger raisedTo: anRSAPrivateKey dq modulo: anRSAPrivateKey q .			h := anRSAPrivateKey qInv * (m1 - m2) \\ anRSAPrivateKey p.			m := m2 + (h * anRSAPrivateKey q).			m]</body><body package="RSA" selector="decryptRSAES:withKey:">decryptRSAES: aByteArray withKey: anRSAPrivateKey 	"decrypt a block per PKCS 1 of the RSA spec this includes the padding rules specified in theat 	document and it is block type 1 in the SSL document 	finaly I understood how they linked together"	| k cipherMessage encodeDecryptedMessage |	cipherMessage := aByteArray asLargePositiveInteger.	k := anRSAPrivateKey n digitLength.	cipherMessage digitLength ~= k ifTrue: [self class decodingErrorSignal raise].	encodeDecryptedMessage := self decryptRSADP: cipherMessage withKey: anRSAPrivateKey.	^self decodeByEME_PKCS1_V1_5: encodeDecryptedMessage size: k - 1</body><body package="RSA" selector="encodeByEMSA_PKCS1_V1_5:size:hash:">encodeByEMSA_PKCS1_V1_5: aMessageArray size: emLen hash: aHashIdentifier"This is a slightly extended version of the PKCS#1 v1.5 'encoding method for signatures with appendix' (EMSA).The extension is to support RSA signing for SSL, where the digest is precomputed by the SSL rulesand passed in as the aMessageArray value. This is indicated by the nil value of the aHashIdentifierin which case the hashing part of this method is skipped and only the type 1 padding is applied.Another slight diversion from the spec is that as an optimization this method returns a large integer instead of a byte array,since that's what the result gets always converted to anyway.So this method actually corresponds to the following in terms of PKCS#1:	OS2IP(EMSA-PKCS1-v1_5-Encode(aMessageArray, emLen)"	| T int |	T := aHashIdentifier isNil		ifTrue: [ aMessageArray ]		ifFalse: [ | hashID hashClass |			hashID := self class perform: aHashIdentifier.			hashClass := self class hashClassFor: (hashID).			(self class getTFor: hashID), (hashClass byteHash: aMessageArray) ].	(emLen &lt; (T size + 10)) ifTrue: [		self class messageTooLongSignal raise].	"Now produce the EM = 01 || PS || 00 || T , where PS is emLen- || T || - 2 bytes of 16rFF. In BIG ENDIAN !"	int := LargePositiveInteger basicNew: emLen.	" Our LargeIntegers are little endian, so we have to reverse the bytes"	T with: (T size to: 1 by: -1) do: [:each :index |		int basicAt: index put: each].	int basicAt: T size + 1 put: 0.	T size + 2 to: emLen - 1 do: [ :ind | int basicAt: ind put: 255].	int basicAt: emLen put: 1.	^int</body><body package="RSA" selector="encrypt:withKey:">encrypt: aMessageByteArray withKey: anRSAPublicKey 	"encrypt a block per PKCS 1 of the RSA spec this includes the padding rules specified in theat 	document and it is block type 1 in the SSL document 	finnaly I understood how they linked together"	"this is the wrapper method so you can hand over an array that is the entire message ussually a byte 	array that isn't nessesarily sized for N so I break the lot up into 	sub arrays that are sized and then encrypt each of those and then hand back a byteArray the 	represents the cipher message the decrypttion will automagically break it up into the maximum sized 	blocks and then decrypt the message and hand back a byteArray."	| nlength blockSize collection cipherCollection offset |	nlength := anRSAPublicKey n digitLength.	blockSize := nlength - 11.	^aMessageByteArray size &gt; blockSize		ifFalse: ["if the incomingMessage is the right size the go ahead and encipher the array and return the result."			self encryptRSAES: aMessageByteArray withKey: anRSAPublicKey]		ifTrue: ["then we need to break up the array into a collection of arrays that are no larger than 			blockSize and encrypt each one and assemble them back together into one ByteArray 			and return that"			collection := self breakByteArray: aMessageByteArray intoBlocksOf: blockSize.			cipherCollection := ByteArray new: collection size * nlength.			offset := 1.			collection keysAndValuesDo: [ :index :eachArray |						cipherCollection							replaceBytesFrom: offset							to: offset + nlength - 1							with: (self encryptRSAES: aMessageByteArray withKey: anRSAPublicKey)							startingAt: 1.						offset := offset + nlength].			cipherCollection]</body><body package="RSA" selector="encryptRSAEP:withKey:">encryptRSAEP: alargeInt withKey: anRSAPublicKey 	^alargeInt		raisedTo: anRSAPublicKey e		modulo: anRSAPublicKey n</body><body package="RSA" selector="encryptRSAES:withKey:">encryptRSAES: aByteArray withKey: anRSAPublicKey 	"encrypt a block per PKCS 1 of the RSA spec this includes the padding rules specified in theat 	document and it is block type 1 in the SSL document 	fiannly I understood how they linked together"	"First check to see if the message length is too long it has to be no greater than k - 11 where K is the 	length in bytes of n this allows us to pad ten bytes in the format we need. pass this to the 	baseRSAencryption that carries out the multiplication / encryption"	| k encodeMessage ciperMessage |	k := anRSAPublicKey n digitLength.	encodeMessage := self encodeByEME_PKCS1_V1_5: aByteArray size: k - 1.	ciperMessage := self encryptRSAEP: encodeMessage withKey: anRSAPublicKey.	^self i2osp: ciperMessage intendedSize: k</body><body package="RSA" selector="sign:withKey:andHash:">sign: aMessageArray withKey: anRSAPrivateKey andHash: hashIdentifier"The result is a signature of aMessageArray generated using anRSAPrivateKey and the hash function specified by the hashIndentifier (must be one of the identifiers defined on the class side). If the hashIdentifier is nil the aMessageArray is expected to be already a digest of apropriate size (generally up to the key modulus n byte length - 1) in which case the hashing step of the signing procedure is skipped."	^self		signRSASSA: aMessageArray		withKey: anRSAPrivateKey		hash: hashIdentifier</body><body package="RSA" selector="signRSASP1:withKey:">signRSASP1: aMessageInteger withKey: anRSAPrivateKey 	aMessageInteger  &gt; (anRSAPrivateKey n  - 1)		ifTrue: [self class messageTooLongSignal raise].	^aMessageInteger raisedTo: anRSAPrivateKey d modulo: anRSAPrivateKey n	"^anRSAPrivateKey isSecondForm ifFalse: [aMessageInteger mod: anRSAPrivateKey n exp: anRSAPrivateKey d]		ifTrue: 			[s1 := aMessageInteger mod: anRSAPrivateKey dp exp: anRSAPrivateKey p.			s2 := aMessageInteger mod: anRSAPrivateKey dq exp: anRSAPrivateKey q.			h := anRSAPrivateKey qInv * (s1 - s2).			s := s2 + (h * anRSAPrivateKey q).			s]"</body><body package="RSA" selector="signRSASSA:withKey:hash:">signRSASSA: aMessageArray withKey: anRSAPrivateKey hash: hashIdentifier	^(self		signRSASP1: (			self 				encodeByEMSA_PKCS1_V1_5: aMessageArray				size: anRSAPrivateKey n digitLength - 1				hash: hashIdentifier)		withKey: anRSAPrivateKey	) asBigEndianByteArray</body><body package="RSA" selector="verify:isSignatureOf:withKey:andHash:">verify: signatureArray isSignatureOf: aMessageArray withKey: anRSAPublicKey andHash: hashIdentifier"Denies or confirms that signatureArray is a signature of aMessageArray. The anRSAPublicKey and the hash function specified by the hashIndentifier (must be one of the identifiers defined on the class side) are inputs into the verification algorithm. If the hashIdentifier is nil the aMessageArray is expected to be already a digest of apropriate size (generally up to the key modulus n byte length - 1) in which case the hashing step of the signing procedure is skipped."	^self		verifyRSASSA: signatureArray		withKey: anRSAPublicKey		withMessageArray: aMessageArray		hash: hashIdentifier</body><body package="RSA" selector="verifyRSASSA:withKey:withMessageArray:hash:">verifyRSASSA: signatureArray withKey: anRSAPublicKey withMessageArray: aMessageArray hash: hashIdentifier	| encodedMessage |	encodedMessage :=		self			encodeByEMSA_PKCS1_V1_5: aMessageArray			size: anRSAPublicKey n digitLength - 1			hash: hashIdentifier.	^self		verifyRSAVP1: signatureArray  asLargePositiveInteger		withKey: anRSAPublicKey		withMessageArray: encodedMessage</body><body package="RSA" selector="verifyRSAVP1:withKey:">verifyRSAVP1: aSignatureInteger withKey: anRSAPublicKey 	" asPer the spec we return the message representative as a large int"	(aSignatureInteger  &gt; (anRSAPublicKey n  - 1) and: [aSignatureInteger &gt; 0])		ifTrue: [self class messageTooLongSignal raise].	^aSignatureInteger raisedTo: anRSAPublicKey e modulo: anRSAPublicKey n</body><body package="RSA" selector="verifyRSAVP1:withKey:withMessageArray:">verifyRSAVP1: aSignatureInteger withKey: anRSAPublicKey withMessageArray: aMessageInteger	"return true if the test passes false if it does not"		^aMessageInteger = (self  verifyRSAVP1: aSignatureInteger withKey: anRSAPublicKey)</body></methods><methods><class-id>Security.RSA</class-id> <category>accessing</category><body package="RSA" selector="hashAlgorithm">hashAlgorithm	^hash</body><body package="RSA" selector="hashAlgorithm:">hashAlgorithm: aHash	hash := aHash</body><body package="RSA" selector="hashIdentifier:">hashIdentifier: aHashIdentifier	| hashClass |	hashClass := self class hashClassFor: (self class perform: aHashIdentifier).	self hashAlgorithm: hashClass new</body><body package="RSA" selector="privateKey">privateKey	^privateKey</body><body package="RSA" selector="privateKey:">privateKey: anRSAPrivateKey	privateKey := anRSAPrivateKey</body><body package="RSA" selector="publicKey">publicKey	^publicKey</body><body package="RSA" selector="publicKey:">publicKey: anRSAPublicKey	publicKey := anRSAPublicKey</body><body package="RSA" selector="useMD5">useMD5	self hashAlgorithm: MD5 new</body><body package="RSA" selector="useSHA">useSHA	self hashAlgorithm: SHA new</body></methods><methods><class-id>Security.RSA</class-id> <category>private</category><body package="RSA" selector="getRandom">getRandom	| random generator|	random := 0.	generator := Random fastest seed: (Timestamp now asMilliseconds bitAnd: 65535) .	"make sure we have only non zero values"	[random = 0] whileTrue:[ random := (generator  next  * 256) floor].	^random</body></methods><methods><class-id>Security.RSA</class-id> <category>PKCS1 signing</category><body package="RSA" selector="signRSASP1:">signRSASP1: aMessageInteger	(privateKey n  - 1 &lt; aMessageInteger) ifTrue: [RSAMessageTooLong raiseSignal].	^privateKey exponentPowerOf: aMessageInteger</body><body package="RSA" selector="signRSASSA:">signRSASSA: aMessageArray	| k |	privateKey isNil ifTrue: [		RSAError raiseSignal: (			#NeedPrivateKeyToSign &lt;&lt; #security &gt;&gt; 'Private key needed for signing!') ].	k := privateKey n digitLength.	^self	i2osp: (self signRSASP1: (				self	encodeByEMSA_PKCS1_V1_5: aMessageArray				size: k - 1))		intendedSize: k</body><body package="RSA" selector="verifyRSASSA:of:">verifyRSASSA: aSignatureArray of: aMessageArray		| k |	publicKey isNil ifTrue: [		RSAError raiseSignal: (			#NeedPublicKeyToVerify &lt;&lt; #security &gt;&gt; 'Public key needed for signature verification!') ].	k := publicKey n digitLength.	^	(self encodeByEMSA_PKCS1_V1_5: aMessageArray			size: k - 1		) = (self verifyRSAVP1: (self os2ip: aSignatureArray))</body><body package="RSA" selector="verifyRSAVP1:">verifyRSAVP1: aSignatureInteger	(aSignatureInteger  &gt; (publicKey n  - 1) and: [aSignatureInteger &gt; 0])		ifTrue: [self class messageTooLongSignal raise].	^publicKey exponentPowerOf: aSignatureInteger</body></methods><methods><class-id>Security.RSA</class-id> <category>PKCS1 encryption</category><body package="RSA" selector="decryptRSADP:">decryptRSADP: aMessageInteger	^privateKey exponentPowerOf: aMessageInteger</body><body package="RSA" selector="decryptRSAES:">decryptRSAES: aByteArray	| k messageInteger encodedMessage |	privateKey isNil ifTrue: [		RSAError raiseSignal: (			#NeedPrivateKeyToDecrypt &lt;&lt; #security &gt;&gt; 'Private key needed for decryption!') ].	k := privateKey n digitLength.	messageInteger := self os2ip: aByteArray.	messageInteger digitLength ~= k ifTrue: [RSADecodingError raiseSignal].	encodedMessage := self decryptRSADP: messageInteger.	^self decodeByEME_PKCS1_V1_5: encodedMessage size: k - 1</body><body package="RSA" selector="encryptRSAEP:">encryptRSAEP: aMessageInteger	^publicKey exponentPowerOf: aMessageInteger</body><body package="RSA" selector="encryptRSAES:">encryptRSAES: aByteArray	| k encodedMessage encryptedMessage |	publicKey isNil ifTrue: [		RSAError raiseSignal: (			#NeedPublicKeyToEncrypt &lt;&lt; #security &gt;&gt; 'Public key needed for encryption!') ].	k := publicKey n digitLength.	encodedMessage := self encodeByEME_PKCS1_V1_5: aByteArray size: k - 1.	encryptedMessage := self encryptRSAEP: encodedMessage withKey: publicKey.	^self i2osp: encryptedMessage intendedSize: k</body></methods><methods><class-id>Security.RSA</class-id> <category>PKCS1 conversions</category><body package="RSA" selector="i2osp:intendedSize:">i2osp: largeInt intendedSize: size "This will convert the large integer to a byte array of specified size. In most cases this will be very simple since the result of the mod:exp: operation will be of the correct size. However occassionally it will be shorter, usually just a byte shorter. We have to check and if it isn't the right length we have to pad with leading zeros."	^largeInt asBigEndianByteArrayPaddedTo: size</body><body package="RSA" selector="os2ip:">os2ip: aByteArray	^aByteArray asLargePositiveInteger</body></methods><methods><class-id>Security.RSA</class-id> <category>services</category><body package="RSA" selector="decrypt:">decrypt: aByteArray"Decrypt aByteArray using the previously assigned private key."	^self decryptRSAES: aByteArray</body><body package="RSA" selector="encrypt:">encrypt: aByteArray"Encrypts aByteArray using the previously assigned public key"	^self encryptRSAES: aByteArray</body><body package="RSA" selector="sign:">sign: aMessageArray"Compute a signature of aMessageArray.If the 'hash' instance variable is nil then aMessageArray is expected to be already a digest of apropriate size (generally up to the key modulus n byte length - 1) in which case the hashing step of the signing procedure is skipped."	^self signRSASSA: aMessageArray</body><body package="RSA" selector="verify:of:">verify: aSignatureArray of: aMessageArray"Denies or confirms that aSignatureArray is a signature of aMessageArray.If the 'hash' instance variable is nil then aMessageArray is expected to be already a digest of apropriate size (generally up to the key modulus n byte length - 1) in which case the hashing step of the signing procedure is skipped."	^self verifyRSASSA: aSignatureArray of: aMessageArray</body></methods><methods><class-id>Security.RSA</class-id> <category>PKCS1 encoding methods</category><body package="RSA" selector="decodeByEME_PKCS1_V1_5:size:">decodeByEME_PKCS1_V1_5: emInteger size: emLen"This is EME-PKCS1-v1_5-Decode as defined in section 9.1.2.2 of PKCS#1 v2.0.	emInteger	&lt;LargePositiveInteger&gt;	EM, message to be decoded	emLen	&lt;Integer&gt;	the length of the encoded message	^&lt;ByteArray&gt;	M, the decoded messageA slight diversion from the spec is that as an optimization we directly decode the large integer instead of converting it to a byte array first.So this method actually corresponds to the following in terms of PKCS#1:	EME-PKCS1-v1_5-Decode(I2OSP(emInteger, emLen))"	| padStart answer |	emInteger digitLength &lt; 10 ifTrue: [		RSADecodingError new			messageText: (#RSAMessageTooShort &lt;&lt; #security &gt;&gt; 'Encoded message is too short!');			parameter: emInteger;			raise ].	(emInteger basicAt: emLen) = 2 ifFalse: [		RSADecodingError new			messageText: (#RSAInvalidPaddingPrefix &lt;&lt; #security &gt;&gt; 'Invalid padding prefix!');			raise ]. 	padStart := emLen - 1.	[	padStart isZero or: [ (emInteger basicAt: padStart) isZero ]	] whileFalse: [ padStart := padStart - 1]. 	padStart isZero ifTrue: [		RSADecodingError new			messageText: (#RSAMissingPaddingMarker &lt;&lt; #security &gt;&gt; 'Missing padding marker!');			raise ].	padStart &gt; (emLen - 9) ifTrue: [		RSADecodingError new			messageText: (#RSAPaddingTooShort &lt;&lt; #security &gt;&gt; 'Padding is too short!');			raise ].	answer := ByteArray new: padStart - 1.	1 to: padStart - 1 do: [ :i |		answer at: i put: (emInteger basicAt: padStart - i)].	^answer</body><body package="RSA" selector="encodeByEME_PKCS1_V1_5:size:">encodeByEME_PKCS1_V1_5: mBytes size: emLen "This is EME-PKCS1-v1_5-Encode as defined in 9.1.2.1 of PKCS#1 v2.0.	mBytes	&lt;ByteArray&gt;	M, message to be encoded, must be at most emLen-10 bytes long	emLen	&lt;Integer&gt;		intended byte length of the encoded message	^&lt;LargePositiveInteger&gt;	EM, the encoded messageA slight diversion from the spec is that as an optimization this method returns a large integer instead of a byte array, since that's what the result gets always converted to anyway.So this method actually corresponds to the following in terms of PKCS#1:	OS2IP(EME-PKCS1-v1_5-Encode(aByteArray, emLen)"	| em padStart random |	mBytes size &gt; (emLen - 10) ifTrue: [		RSAMessageTooLong new			messageText: (#RSAMessageTooLong &lt;&lt; #security &gt;&gt; 'Message is too long!');			parameter: mBytes;			raise ].	em := LargePositiveInteger basicNew: emLen.	mBytes with: (mBytes size to: 1 by: -1) do: [:each :index |		"convert to largeinteger reserving the pad in the beginning ot the large int"		em basicAt: index put: each].	padStart := mBytes size + 1.	em basicAt: padStart put: 0.	"fill with some randoms they don't have to be cryptographic secure so our will do"	random := Random fastest seed: (Time microsecondClock bitAnd: 65535).	padStart + 1 to: emLen -1 do: [ :i |		em	basicAt: i			put: (random next * 255) floor + 1 "must be non-zero" ].	em basicAt: emLen put: 2.	^em</body><body package="RSA" selector="encodeByEMSA_PKCS1_V1_5:size:">encodeByEMSA_PKCS1_V1_5: aByteArray size: emLen"This is a slightly extended version of the PKCS#1 v1.5 'encoding method for signatures with appendix' (EMSA).The extension is to support RSA signing for SSL, where the digest is precomputed by the SSL rulesand passed in as the aMessageArray value. This is indicated by the nil value of the 'hash' instance variable,in which case the hashing part of this method is skipped and only the type 1 padding is applied.Another slight diversion from the spec is that as an optimization this method returns a large integer instead of a byte array,since that's what the result gets always converted to anyway.So this method actually corresponds to the following in terms of PKCS#1:	OS2IP(EMSA-PKCS1-v1_5-Encode(aMessageArray, emLen)"	| T int |	T := hash isNil		ifTrue: [ aByteArray ]		ifFalse: [ hash derEncodedDigestInfo, (hash byteHash: aByteArray) ].	(T size + 10 &gt; emLen) ifTrue: [		RSAMessageTooLong new			messageText: (#RSAMessageTooLong &lt;&lt; #security &gt;&gt; 'Message is too long!');			parameter: aByteArray;			raise ].	"Now produce the EM = 01 || PS || 00 || T , where PS is emLen- || T || - 2 bytes of 16rFF. In BIG ENDIAN !"	int := LargePositiveInteger basicNew: emLen.	" Our LargeIntegers are little endian, so we have to reverse the bytes"	T with: (T size to: 1 by: -1) do: [:each :index |		int basicAt: index put: each].	int basicAt: T size + 1 put: 0.	T size + 2 to: emLen - 1 do: [ :ind | int basicAt: ind put: 255].	int basicAt: emLen put: 1.	^int</body></methods><methods><class-id>Security.RSA class</class-id> <category>hash Identifiers</category><body package="RSA" selector="md2">md2	^#md2</body><body package="RSA" selector="md2WithRSAEncryption">md2WithRSAEncryption 	^#md2</body><body package="RSA" selector="md5">md5	^#md5</body><body package="RSA" selector="md5WithRSAEncryption">md5WithRSAEncryption 	^#md5</body><body package="RSA" selector="sha1">sha1	^#SHA1</body><body package="RSA" selector="sha1WithRSAEncryption">sha1WithRSAEncryption 	^#SHA1</body><body package="RSA" selector="sha256">sha256	^#SHA256</body><body package="RSA" selector="sha256WithRSAEncryption">sha256WithRSAEncryption  	^#SHA256</body><body package="RSA" selector="sha348WithRSAEncryption">sha348WithRSAEncryption  	^#SHA384</body><body package="RSA" selector="sha384">sha384	^#SHA384</body><body package="RSA" selector="sha512">sha512	^#SHA512</body><body package="RSA" selector="sha512WithRSAEncryption">sha512WithRSAEncryption  	^#SHA512</body></methods><methods><class-id>Security.RSA class</class-id> <category>constants</category><body package="RSA" selector="decodingErrorSignal">decodingErrorSignal	^RSADecodingError</body><body package="RSA" selector="errorSignal">errorSignal	^RSAError</body><body package="RSA" selector="messageTooLongSignal">messageTooLongSignal	^RSAMessageTooLong</body><body package="RSA" selector="notImplementedSignal">notImplementedSignal	^RSANotImplemented</body></methods><methods><class-id>Security.RSA class</class-id> <category>accessing</category><body package="RSA" selector="getTFor:">getTFor: aHashIdentifier 	^ASN1dictionaryForHashSigning at: aHashIdentifier		ifAbsent: [self errorSignal raise]</body><body package="RSA" selector="hashClassFor:">hashClassFor: anIdentifer 	anIdentifer = self md2 ifTrue: [self notImplementedSignal raise]. "will be at some point"	anIdentifer = self sha256 ifTrue: [self notImplementedSignal raise]. "will be at some point"	anIdentifer = self sha384 ifTrue: [self notImplementedSignal raise]. "will be at some point"	anIdentifer = self sha512 ifTrue: [self notImplementedSignal raise]. "will be at some point"	anIdentifer = self md5 ifTrue: [^MD5].	anIdentifer = self sha1 ifTrue: [^SHA]</body></methods><methods><class-id>Security.RSA class</class-id> <category>initialize</category><body package="RSA" selector="initialize">initialize	self intializeASN1dictionaryForHashSigning.</body><body package="RSA" selector="intializeASN1dictionaryForHashSigning">intializeASN1dictionaryForHashSigning	"Per PKCS1 these are the digestInfo asn1 encode values for md5 md2 and sha1"		ASN1dictionaryForHashSigning := Dictionary new.	ASN1dictionaryForHashSigning at: #MD2 put: #[48 32 48 12 6 8 42 134 72 134 247 13 2 2 5 0 4 16].	"Not sure where this comes from, but it's the lowercase one (#md5) that seems to be used by OpenSSL"	ASN1dictionaryForHashSigning at: #MD5 put: #[48 32 0 12 6 8 42 134 72 134 247 13 2 5 5 0 4 16].	ASN1dictionaryForHashSigning at: #md2 put: #[48 32 48 12 6 8 42 134 72 134 247 13 2 2 5 0 4 16].	ASN1dictionaryForHashSigning at: #md5 put: #[48 32 48 12 6 8 42 134 72 134 247 13 2 5 5 0 4 16].	ASN1dictionaryForHashSigning at: #SHA1 put: #[48 33 48 9 6 5 43 14 3 2 26 5 0 4 20].	ASN1dictionaryForHashSigning at: #SHA256 put: #[48 49 48 13 6 9 96 134 72 1 101 3 4 2 1 5 0 4 32].	ASN1dictionaryForHashSigning at: #SHA384 put: #[48 65 48 13 6 9 96 134 72 1 101 3 4 2 2 5 0 4 48].	ASN1dictionaryForHashSigning at: #SHA512 put: #[48 81 48 13 6 9 96 134 72 1 101 3 4 2 3 5 0 4 64]</body></methods><methods><class-id>Security.RSAKey</class-id> <category>accessing</category><body package="RSA" selector="n">n	^n</body><body package="RSA" selector="n:">n: aValue	n := aValue</body></methods><methods><class-id>Security.RSAKey class</class-id> <category>deprecated</category><body package="RSA" selector="generateKeyPairSize:">generateKeyPairSize: numberOfBits 	"self generateKeyPairSize: 128"	"From Bruce Schneier's Applied cryptography second edition page 467. 	the variables are the same as those in his book. Note depending on Key size this could take a while.	Returns and array of size 2. First positon is the private key second position is the public key.	Note this method generates the most secure kind of Keys that are also optimized for speed which is 	why the selection process takes so long"	| n p q e d selectionBlock diffProduct temp dp dq euclid firstCoefficient privateKey |	Transcript		cr; show: 'Starting Key generation. if you chose to generate large keys &gt; than 768 you may want to get some coffee.';		cr; show: 'Selecting First Random Prime'.	q := 0.	p := Integer generatePrimeBits: numberOfBits.	selectionBlock := [		[	q := Integer generatePrimeBits: numberOfBits.			p = q		] whileTrue ].		[	"Try values of e that will make our encryption go faster.		First try 65537 as recommended by x.509 and PKCS #1 then try 3 or 17.		If not then we should chose another value for q"		Transcript cr; show: 'Selecting Second Random Prime'.		selectionBlock value.		n := p * q.		diffProduct := p - 1 * (q - 1).		Transcript cr; show: 'Verifying Key Pairs.'.		#(65537 3 17)			detect: [ :eValue | 				euclid := EuclidAlgorithm with: eValue with: diffProduct.				euclid lehmer.				euclid firstCoefficient &gt; 10					ifTrue: 						[e := eValue.						d := euclid firstCoefficient.						true]					ifFalse: [false]]			ifNone: [e := nil. Transcript cr; show: 'Rejecting Second Prime'].		e == nil	] whileTrue.	Transcript cr; show: 'Calculating Chinese Remainder theorem values to speed up decryption'.	p &lt; q ifTrue: [		temp := q.		q := p.		p := temp].	dp := d \\ (p - 1).	dq := d \\ (q - 1).	euclid := EuclidAlgorithm with: q with: p.	euclid lehmer.	firstCoefficient := euclid firstCoefficient.	privateKey := RSAPrivateKey d: d n: n.	privateKey dp: dp.	privateKey dq: dq.	privateKey e: e.	privateKey p: p.	privateKey q: q.	privateKey coefficient: firstCoefficient.	Transcript cr; show: 'Finished'.	^Array with: privateKey with: (RSAPublicKey e: e n: n)</body><body package="RSA" selector="get1024BitKeys">get1024BitKeys	^self  generateKeyPairSize: 1024</body><body package="RSA" selector="get128BitKeys">get128BitKeys	^self  generateKeyPairSize: 128</body><body package="RSA" selector="get2048BitKeys">get2048BitKeys	^self  generateKeyPairSize: 2048</body><body package="RSA" selector="get4096BitKeys">get4096BitKeys	^self  generateKeyPairSize: 4096</body><body package="RSA" selector="get768BitKeys">get768BitKeys	^self  generateKeyPairSize: 768</body></methods><methods><class-id>Security.RSAPublicKey</class-id> <category>accessing</category><body package="RSA" selector="e">e	^e</body><body package="RSA" selector="e:">e: aValue	e := aValue</body></methods><methods><class-id>Security.RSAPublicKey</class-id> <category>api</category><body package="RSA" selector="exponentPowerOf:">exponentPowerOf: aSignatureInteger	^aSignatureInteger raisedTo: self e modulo: self n</body></methods><methods><class-id>Security.RSAPublicKey class</class-id> <category>instance creation</category><body package="RSA" selector="e:n:">e: e n: n	^self new		e: e;		n: n;		yourself</body></methods><methods><class-id>Security.RSAPrivateKey</class-id> <category>accessing</category><body package="RSA" selector="d">d	^d</body><body package="RSA" selector="d:">d: aValue	d := aValue</body><body package="RSA" selector="dp">dp	^dP ifNil: [ dP := d \\ ( p - 1 ) ]</body><body package="RSA" selector="dp:">dp: exp	dP := exp</body><body package="RSA" selector="dq">dq	^dQ ifNil: [ dQ := d \\ (q - 1) ]</body><body package="RSA" selector="dq:">dq: exp	dQ := exp</body><body package="RSA" selector="e">e	^e</body><body package="RSA" selector="e:">e: aNumber	e := aNumber</body><body package="RSA" selector="otherFactors">otherFactors	^otherFactors</body><body package="RSA" selector="otherFactors:">otherFactors: aSequenceOfTriplets"aSequenceOfTriplets is a sequenceable collection of #(ri di ti), where ri is a factor, di is its exponent and ti is its CRT coefficient"	otherFactors := aSequenceOfTriplets</body><body package="RSA" selector="p">p	^p</body><body package="RSA" selector="p:">p: aNumber	p := aNumber</body><body package="RSA" selector="q">q	^q</body><body package="RSA" selector="q:">q: aNumber	q := aNumber</body><body package="RSA" selector="qInv">qInv	^qInv ifNil: [ "qInv = 1 / q mod p"		qInv := (EuclidAlgorithm with: q with: p) doBasicAlgorthim; firstCoefficient ]</body><body package="RSA" selector="qInv:">qInv: aNumber	qInv := aNumber</body></methods><methods><class-id>Security.RSAPrivateKey</class-id> <category>accessing-aliases</category><body package="RSA" selector="coefficient">coefficient	^self qInv</body><body package="RSA" selector="coefficient:">coefficient: aNumber	self qInv: aNumber</body><body package="RSA" selector="exponent1">exponent1	^self dp</body><body package="RSA" selector="exponent1:">exponent1: aNumber	self dp: aNumber</body><body package="RSA" selector="exponent2">exponent2	^self dq</body><body package="RSA" selector="exponent2:">exponent2: aNumber	self dq: aNumber</body></methods><methods><class-id>Security.RSAPrivateKey</class-id> <category>testing</category><body package="RSA" selector="isSecondForm">isSecondForm	^p notNil and: [ q notNil ]</body></methods><methods><class-id>Security.RSAPrivateKey</class-id> <category>services</category><body package="RSA" selector="exponentPowerOf:">exponentPowerOf: aLargeInteger	^(	self isSecondForm and: [		"We do not support multi-factor (&gt;2) keys yet"		otherFactors isNil ]	)	ifTrue: [ self fastExponentPowerOf: aLargeInteger ]		ifFalse: [ self simpleExponentPowerOf: aLargeInteger ]</body><body package="RSA" selector="fastExponentPowerOf:">fastExponentPowerOf: aLargeInteger"If we know factorization of the modulus n, the power can be computed several times faster exploiting Chinese Remainder Theorem.The description of the computation itself is included in PKCS#1 version 2.0 and up. It's referred to as the computation using the 'second form' of a private key."	 | h m m1 m2 |	"Split the the integer into the CRT factors and perform the exponentiation"	m1 := (aLargeInteger \\ p) raisedTo: self dp modulo: p.	m2 := (aLargeInteger \\ q) raisedTo: self dq modulo: q.	"Convert the result back to an integer using Garner's formula"	h :=  (((m1 - m2) \\ p) * self qInv) \\ p.	m :=  h * q + m2.	"This is what I believe the rest of the algorithm should look like for n with more than 2 factors.	But I'm not sure, the description in PKCS#1 v2.1 is pretty poor in that regard.	Given that such keys are rarely used it's safer to claim non-support for now.	This is reflected in the isSecondForm test.	otherFactors notNil ifTrue: [ | R prevRi |		R := p. prevRi := q.		otherFactors do: [ :triplet || ri di ti mi |			ri := triplet first.			di := triplet at: 2.			ti := triplet last.			mi := (aMessageInteger \\ ri) raisedTo: di modulo: ri.			R := R * prevRi.			h :=  (((mi - m) \\ ri) * ti) \\ ri.			m :=  h * R + m.			prevRi := ri ] ]."	^m</body><body package="RSA" selector="simpleExponentPowerOf:">simpleExponentPowerOf: aLargeInteger	^aLargeInteger raisedTo: d modulo: n</body></methods><methods><class-id>Security.RSAPrivateKey class</class-id> <category>instance creation</category><body package="RSA" selector="d:n:">d: d n: n	^self new		d: d;		n: n;		yourself</body></methods><methods><class-id>Security.MD5</class-id> <category>rsa</category><body package="RSA" selector="derEncodedDigestInfo">derEncodedDigestInfo	^#[48 32 48 12 6 8 42 134 72 134 247 13 2 5 5 0 4 16]</body></methods><methods><class-id>Security.SHA</class-id> <category>rsa</category><body package="RSA" selector="derEncodedDigestInfo">derEncodedDigestInfo	^#[48 33 48 9 6 5 43 14 3 2 26 5 0 4 20].</body></methods><initialize><class-id>Security.RSA</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>KeyGenerator</name><environment>Security</environment><super>Core.EventManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keySize random primalityTest </inst-vars><class-inst-vars>random </class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>CiphersBase</package></attributes></class><class><name>EncryptionKey</name><environment>Security</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>CiphersBase</package></attributes></class><class><name>SHA</name><environment>Security</environment><super>Security.SHAHash</super><private>false</private><indexed-type>none</indexed-type><inst-vars>t k </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Hashes</category><attributes><package>SHA</package></attributes></class><class><name>MD5</name><environment>Security</environment><super>Security.Hash</super><private>false</private><indexed-type>none</indexed-type><inst-vars>a b c d aa bb cc dd f ff m </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Hashes</category><attributes><package>MD5</package></attributes></class><class><name>AsymmetricCipher</name><environment>Security</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>CiphersBase</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>