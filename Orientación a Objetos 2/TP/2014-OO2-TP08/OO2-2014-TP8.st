Object subclass: #TWTweet	instanceVariableNames: 'text id_str retweet_count source user hashtags created_at in_reply_to_status_id_str coordinates favorite_count place'	classVariableNames: ''	poolDictionaries: ''	category: 'OO2-2014-TP8'!!TWTweet commentStamp: 'ArturoZambrano 2/15/2014 23:12' prior: 0!A Tweet is a tweet or Status object according to Twitter API.Instance Variables	id_str:		<Object>	retweet_count:		<Object>	source:		<Object>	text:		<Object>	user:		<Object>id_str	- xxxxxretweet_count	- xxxxxsource	- xxxxxtext	- xxxxxuser	- xxxxx!!TWTweet methodsFor: 'printing' stamp: 'ArturoZambrano 2/12/2014 14:50'!printOn: aStream  aStream nextPutAll: 'Tweet: '; nextPut:$'; nextPutAll: text; nextPut:  $'. ! !!TWTweet methodsFor: 'time' stamp: 'ArturoZambrano 4/17/2014 17:51'!adjustTimestamp: aDuration created_at:= created_at+ aDuration.! !!TWTweet methodsFor: 'comparing' stamp: 'RosarioSantaMarina 3/18/2014 14:07'!<= anotherTweet	^ id_str <= anotherTweet id_str! !!TWTweet methodsFor: 'comparing' stamp: 'RosarioSantaMarina 3/18/2014 16:46'!= anotherTweet"Answer whether the receiver and the argument has the same id_str"	(anotherTweet isKindOf: self class)		ifFalse: [ ^ false ].	id_str = anotherTweet id_str		ifFalse: [ ^ false ].	^ true! !!TWTweet methodsFor: 'comparing' stamp: 'RosarioSantaMarina 3/18/2014 16:43'!hash"#hash is re-implemented because #= is re-implemented"	^ id_str hash! !!TWTweet methodsFor: 'private' stamp: 'ArturoZambrano 4/15/2014 14:54'!monthFrom:aString aString = 'Jan' ifTrue:[ ^1].aString = 'Feb' ifTrue:[ ^2].aString = 'Mar' ifTrue:[ ^3].aString = 'Apr' ifTrue:[ ^4].^1.! !!TWTweet methodsFor: 'private' stamp: 'ArturoZambrano 4/18/2014 17:54'!coordinates:aPoint  coordinates:=aPoint.! !!TWTweet methodsFor: 'accessing' stamp: 'RosarioSM 1/22/2014 16:09'!user: anObject	user := anObject! !!TWTweet methodsFor: 'accessing' stamp: 'RosarioSantaMarina 5/5/2014 13:39'!hashtags	| col |	col := OrderedCollection new.	hashtags isNotNil		ifTrue: [ 			hashtags				do: [ :each | 					| stream |					stream := WriteStream on: ''.					stream nextPutAll: '#'.					stream nextPutAll: each.					col add: stream contents asLowercase ] ].	^ col! !!TWTweet methodsFor: 'accessing' stamp: 'RosarioSantaMarina 3/6/2014 12:53'!created_at: aDatecreated_at := aDate! !!TWTweet methodsFor: 'accessing' stamp: 'RosarioSantaMarina 3/6/2014 12:53'!created_at^created_at! !!TWTweet methodsFor: 'accessing' stamp: 'ArturoZambrano 1/16/2014 12:48'!text	^ text! !!TWTweet methodsFor: 'accessing' stamp: 'ArturoZambrano 4/18/2014 17:50'!coordinatePoint "^(coordinates at: #latitude) @ (coordinates at: #longitude)"  ^coordinates.! !!TWTweet methodsFor: 'accessing' stamp: 'RosarioSM 1/23/2014 11:14'!source: anObject	source := anObject! !!TWTweet methodsFor: 'accessing' stamp: 'RosarioSantaMarina 2/19/2014 13:59'!hashtags: aCollection	hashtags := aCollection! !!TWTweet methodsFor: 'accessing' stamp: 'RosarioSM 1/23/2014 11:13'!retweet_count	^ retweet_count! !!TWTweet methodsFor: 'accessing' stamp: 'RosarioSM 1/23/2014 11:14'!source	^ source! !!TWTweet methodsFor: 'accessing' stamp: 'ArturoZambrano 4/5/2014 18:19'!coordinates ^coordinates! !!TWTweet methodsFor: 'accessing' stamp: 'ArturoZambrano 1/16/2014 12:48'!text: anObject	text := anObject! !!TWTweet methodsFor: 'accessing' stamp: 'RosarioSM 1/22/2014 16:09'!user	^ user! !!TWTweet methodsFor: 'accessing' stamp: 'RosarioSantaMarina 4/8/2014 15:52'!place	^ place! !!TWTweet methodsFor: 'accessing' stamp: 'ArturoZambrano 5/9/2014 23:33'!favorite_count	^ favorite_count! !!TWTweet methodsFor: 'accessing' stamp: 'RosarioSM 1/23/2014 11:13'!retweet_count: anObject	retweet_count := anObject! !!TWTweet methodsFor: 'accessing' stamp: 'RosarioSM 1/23/2014 11:13'!id_str	^ id_str! !!TWTweet methodsFor: 'accessing' stamp: 'ArturoZambrano 4/15/2014 22:42'!timestamp	^self created_at asTimeStamp ! !!TWTweet methodsFor: 'accessing' stamp: 'RosarioSM 1/23/2014 11:13'!id_str: anObject	id_str := anObject! !Object subclass: #Shape	instanceVariableNames: 'type width'	classVariableNames: ''	poolDictionaries: ''	category: 'OO2-2014-TP8'!!Shape commentStamp: '<historical>' prior: 0!I am an abstract class that knows my bounds and if a point is contained in me.!!Shape methodsFor: 'initialize - release' stamp: 'AR 5/17/2014 20:52'!initializeType: aType width: aNumber	type := aType.	width := aNumber! !!Shape methodsFor: 'initialize - release' stamp: 'AR 5/17/2014 20:52'!initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	^ self! !!Shape methodsFor: 'calculations' stamp: 'AR 5/17/2014 20:59'!area	type = 1		ifTrue: [ ^ width * width ]		ifFalse: [ 			type = 2				ifTrue: [ ^ width * 2 * (width * 2) * Float pi ]				ifFalse: [ ^ 3 sqrt / 4 * width * width ] ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Shape class	instanceVariableNames: ''!!Shape class commentStamp: '<historical>' prior: 0!!!Shape class methodsFor: 'instance creation' stamp: 'AR 5/17/2014 20:49'!type: aType width: aNumber	^ self new initializeType: aType width: aNumber! !!Shape class methodsFor: 'instance creation' stamp: 'AR 5/17/2014 20:48'!new	"Answer a newly created and initialized instance."	^super new initialize! !!Shape class methodsFor: 'shape types' stamp: 'AR 5/17/2014 20:50'!equilateralTriangle ^3! !!Shape class methodsFor: 'shape types' stamp: 'AR 5/17/2014 20:50'!square ^1! !!Shape class methodsFor: 'shape types' stamp: 'AR 5/17/2014 20:49'!circle ^2! !Object subclass: #TWUser	instanceVariableNames: 'name id_str screen_name followers_count friends_count friends followers profile_image_url lang time_zone statuses_count location profileFormPicture'	classVariableNames: ''	poolDictionaries: ''	category: 'OO2-2014-TP8'!!TWUser commentStamp: 'ArturoZambrano 3/22/2014 21:56' prior: 0!An User represent  a Twitter user.Instance Variables	followers:		<Object>	followers_count:		<Object>	friends:		<Object>	friends_count:		<Object>	id_str:		<Object>	name:		<Object>	screen_name:		<Object>followers	- xxxxxfollowers_count	- xxxxxfriends	- xxxxxfriends_count	- xxxxxid_str	- xxxxxname	- xxxxxscreen_name	- xxxxx!!TWUser methodsFor: 'private profile-picture' stamp: 'ArturoZambrano 5/11/2014 15:07'!retriveProfilePictureFromTwitter	"Dowloads the users's profile picture"| response |	response := ZnClient new		url: self profile_image_url; downloadTo: self pictureFilename .	"	| response |	response := ZnClient new		url: self profile_image_url;		get;		response.	response isSuccess		ifTrue: [ ^ (ImageReadWriter formFromStream: response entity readStream) inspect.			 ]	"! !!TWUser methodsFor: 'private profile-picture' stamp: 'ArturoZambrano 5/11/2014 20:13'!pictureFilename "Returns the local filename where the image profile of the receiver should be stored"^  'twrpt-cache/', self screen_name , '.', self profile_image_url asFileReference extension! !!TWUser methodsFor: 'private profile-picture' stamp: 'ArturoZambrano 5/11/2014 20:19'!restoreProfilePictureFromCache	"Profile picture is not in memory, we try to recover it from chache."	self pictureFilename asFileReference exists		ifFalse: [ self retriveProfilePictureFromTwitter ].	[profileFormPicture := Form fromFileNamed: self pictureFilename.]  on:Exception do:[profileFormPicture := Form fromFileNamed:  '/Users/arturo/tmp/twitter.jpeg'].	^ profileFormPicture! !!TWUser methodsFor: 'printing' stamp: 'ArturoZambrano 2/12/2014 14:52'!printOn: aStream  aStream nextPutAll: 'User: '; nextPutAll: name.! !!TWUser methodsFor: 'comparing' stamp: 'RosarioSantaMarina 3/18/2014 16:16'!= anUser	(anUser isKindOf: self class)		ifFalse: [ ^ false ].	^ name = anUser name		and:			(id_str = anUser id_str				and:					(screen_name = anUser screen_name						and: (followers_count = anUser followers_count and: friends_count = anUser friends_count)))! !!TWUser methodsFor: 'comparing' stamp: 'RosarioSantaMarina 3/18/2014 16:55'!hash<fix: 'bitXor with all/which variables?'>	"#hash is re-implemented because #= is re-implemented"	^ id_str hash bitXor: screen_name hash! !!TWUser methodsFor: 'accessing' stamp: 'RosarioSantaMarina 4/7/2014 16:01'!lang	^ lang! !!TWUser methodsFor: 'accessing' stamp: 'RosarioSM 1/23/2014 11:44'!friends_count: anObject	friends_count := anObject! !!TWUser methodsFor: 'accessing' stamp: 'ArturoZambrano 4/28/2014 11:53'!location: anObject	location := anObject! !!TWUser methodsFor: 'accessing' stamp: 'ArturoZambrano 4/28/2014 11:53'!location	^ location! !!TWUser methodsFor: 'accessing' stamp: 'RosarioSantaMarina 2/26/2014 15:47'!addFriends: aUser	friends isNil		ifTrue: [ friends := OrderedCollection new ].	friends add: aUser! !!TWUser methodsFor: 'accessing' stamp: 'RosarioSantaMarina 4/7/2014 16:01'!profile_image_url: aUrl	profile_image_url := aUrl! !!TWUser methodsFor: 'accessing' stamp: 'RosarioSantaMarina 4/7/2014 16:02'!time_zone	^ time_zone! !!TWUser methodsFor: 'accessing' stamp: 'ArturoZambrano 5/11/2014 15:12'!profilePicture	"Restore the users's profile picture"   profileFormPicture isNil ifTrue:[         self restoreProfilePictureFromCache .].   ^profileFormPicture! !!TWUser methodsFor: 'accessing' stamp: 'RosarioSM 2/12/2014 15:28'!followers	^ followers! !!TWUser methodsFor: 'accessing' stamp: 'RosarioSantaMarina 4/29/2014 15:16'!screen_name	^ screen_name! !!TWUser methodsFor: 'accessing' stamp: 'RosarioSantaMarina 2/26/2014 15:48'!addFollowers: aUser	followers isNil		ifTrue: [ followers := OrderedCollection new ].	followers add: aUser! !!TWUser methodsFor: 'accessing' stamp: 'RosarioSantaMarina 4/29/2014 15:09'!screen_name: aString	(aString beginsWith: '@')		ifFalse: [ 			| stream |			stream := WriteStream on: ''.			stream nextPutAll: '@'.			stream nextPutAll: aString.			aString := stream contents ].	screen_name := aString! !!TWUser methodsFor: 'accessing' stamp: 'RosarioSantaMarina 4/7/2014 16:01'!lang: aLang	lang := aLang! !!TWUser methodsFor: 'accessing' stamp: 'RosarioSM 1/23/2014 11:44'!followers_count	^ followers_count! !!TWUser methodsFor: 'accessing' stamp: 'RosarioSM 1/22/2014 16:10'!name: aName	name := aName! !!TWUser methodsFor: 'accessing' stamp: 'RosarioSM 1/22/2014 16:10'!name	^ name! !!TWUser methodsFor: 'accessing' stamp: 'RosarioSantaMarina 4/7/2014 16:01'!profile_image_url	^ profile_image_url! !!TWUser methodsFor: 'accessing' stamp: 'RosarioSantaMarina 4/7/2014 16:02'!statuses_count	^ statuses_count! !!TWUser methodsFor: 'accessing' stamp: 'RosarioSantaMarina 4/7/2014 16:02'!statuses_count: aNumber	statuses_count := aNumber! !!TWUser methodsFor: 'accessing' stamp: 'RosarioSM 1/23/2014 11:44'!friends_count	^ friends_count! !!TWUser methodsFor: 'accessing' stamp: 'RosarioSantaMarina 4/7/2014 16:02'!time_zone: aTimeZone	time_zone := aTimeZone! !!TWUser methodsFor: 'accessing' stamp: 'RosarioSM 1/23/2014 11:44'!followers_count: anObject	followers_count := anObject! !!TWUser methodsFor: 'accessing' stamp: 'RosarioSM 1/22/2014 16:09'!id_str	^ id_str! !!TWUser methodsFor: 'accessing' stamp: 'RosarioSM 1/22/2014 16:10'!id_str: anId	id_str := anId! !!TWUser methodsFor: 'accessing' stamp: 'RosarioSM 2/11/2014 14:10'!friends	^ friends! !!TWUser methodsFor: 'initialize-release' stamp: 'RosarioSantaMarina 4/29/2014 15:09'!initializeName: aName followers: followersCount 	friends: friendsCount id: idStr screen_name: screenName profile_image_url: aUrl lang: aLang 	time_zone: aTimeZone statuses_count: aNumber	name := aName.	followers_count := followersCount.	friends_count := friendsCount.	id_str := idStr.	self screen_name: screenName.	profile_image_url := aUrl.	lang := aLang.	time_zone := aTimeZone.	statuses_count := aNumber.	friends := OrderedCollection new.	followers := OrderedCollection new.! !!TWUser methodsFor: 'initialize-release' stamp: 'RosarioSantaMarina 4/29/2014 15:09'!initializeName: aName followers: followersCount 	friends: friendsCount id: idStr screen_name: screenName profile_image_url: aUrl lang: aLang 	time_zone: aTimeZone statuses_count: aNumber location:aString	name := aName.	followers_count := followersCount.	friends_count := friendsCount.	id_str := idStr.	self screen_name: screenName.	profile_image_url := aUrl.	lang := aLang.	time_zone := aTimeZone.	statuses_count := aNumber.	friends := OrderedCollection new.	followers := OrderedCollection new.	location:= aString.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TWUser class	instanceVariableNames: ''!!TWUser class commentStamp: '<historical>' prior: 0!!!TWUser class methodsFor: 'instance creation' stamp: 'ArturoZambrano 4/28/2014 11:41'!newName: aName followers: followers_count friends: friends_count id: id_str screen_name: screen_name profile_image_url: aUrl lang: aLang time_zone: aTimeZone statuses_count: aNumber location: aString	^ self new		initializeName: aName		followers: followers_count		friends: friends_count		id: id_str		screen_name: screen_name		profile_image_url: aUrl		lang: aLang		time_zone: aTimeZone		statuses_count: aNumber		location: aString! !!TWUser class methodsFor: 'instance creation' stamp: 'ArturoZambrano 5/12/2014 17:53'!name:aString	^ self new			name: aString! !!TWUser class methodsFor: 'instance creation' stamp: 'RosarioSantaMarina 4/7/2014 16:05'!newName: aName followers: followers_count friends: friends_count id: id_str screen_name: screen_name profile_image_url: aUrl lang: aLang time_zone: aTimeZone statuses_count: aNumber	^ self new		initializeName: aName		followers: followers_count		friends: friends_count		id: id_str		screen_name: screen_name		profile_image_url: aUrl		lang: aLang		time_zone: aTimeZone		statuses_count: aNumber! !Object subclass: #TweetBase	instanceVariableNames: 'filename hashtag tweets'	classVariableNames: 'bases'	poolDictionaries: ''	category: 'OO2-2014-TP8'!!TweetBase commentStamp: 'ArturoZambrano 2/15/2014 23:05' prior: 0!A TweetBase stores many tweets recovered in several querys to API.Instance Variables	filename:		<Object>	hashtag:		<Object>filename	- xxxxxhashtag	- xxxxx!!TweetBase methodsFor: 'initialize - release' stamp: 'RosarioSantaMarina 3/6/2014 10:30'!initialize	tweets := Set new! !!TweetBase methodsFor: 'printing' stamp: 'ArturoZambrano 2/26/2014 22:31'!printOn: aStream	aStream nextPutAll: 'TweetBase hashtag: '.	hashtag printOn: aStream.	aStream				nextPutAll: ' count: ';		nextPutAll: tweets size asString! !!TweetBase methodsFor: 'stats' stamp: 'AR 5/19/2014 21:09'!varianceTweetsPerUser"returns the variance of  tweets groups by user"	| result total mean |	"calculates tweets per user"	result := Dictionary new.	tweets		do: [ :tweet | 			| user |			user := tweet user.			result at: user ifAbsentPut: 0.			result at: user put: (result at: user) + 1 ].	"calculates the mean"	total := 0.	result do: [ :a | total := total + a ].	mean := total / result size.	"use the mean for variance calculation"	total := 0.	result associationsDo: [ :assoc | total := ((assoc value - mean) * (assoc value - mean)) ].	^ total / (result size - 1)! !!TweetBase methodsFor: 'stats' stamp: 'AR 5/19/2014 21:08'!deviationTweetsPerUser"returns the deviation of  tweets groups by user"	| result total mean var |	"calculates tweets per user"	result := Dictionary new.	tweets		do: [ :tweet | 			| user |			user := tweet user.			result at: user ifAbsentPut: 0.			result at: user put: (result at: user) + 1 ].					"calculates the mean"	total := 0.	result do: [ :a | total := total + a ].	mean := total / result size.				"use the mean for variance calculation"	total := 0.	result associationsDo: [ :assoc | total := total + ((assoc value - mean) * (assoc value - mean)) ].	var := total / (result size - 1).	^ var sqrt asFloat	! !!TweetBase methodsFor: 'persistence' stamp: 'ArturoZambrano 2/17/2014 20:09'!save	self filename asFileReference exists ifTrue:[self filename asFileReference delete].	FLSerializer serialize: self toFileNamed: self filename! !!TweetBase methodsFor: 'persistence' stamp: 'ArturoZambrano 5/3/2014 19:25'!restore	| tb |	tb := FLMaterializer materializeFromFileNamed: self filename.	self class bases at: self hashtag put: self.	^ tb! !!TweetBase methodsFor: 'as yet unclassified' stamp: 'ArturoZambrano 4/21/2014 16:01'!adjustTimestamp: aDuration  tweets do:[:t | t adjustTimestamp: aDuration]! !!TweetBase methodsFor: 'class analysis' stamp: 'ArturoZambrano 2/18/2014 20:02'!allHashtags	| set |	set := Set new.	tweets do: [ :tw | set addAll: tw hashtags ].	^ set! !!TweetBase methodsFor: 'class analysis' stamp: 'ArturoZambrano 5/9/2014 20:47'!countByUserLimit: aNumber	| dict sorted top |	dict := self countByUser.	sorted := dict associations asSortedCollection: [ :assocA :assocB | assocA value > assocB value ].	top := sorted allButLast: sorted size - aNumber.	^ top asDictionary! !!TweetBase methodsFor: 'class analysis' stamp: 'ArturoZambrano 4/15/2014 18:26'!countByMinute	"returns a dictionary with the number of tweets per minute"	| result |	result := Dictionary new.	tweets		do: [ :tweet | 			| hhmm |			hhmm := (tweet timestamp hour24 printStringPadded: 2 ), ':' , (tweet timestamp minute printStringPadded: 2).			 result at: hhmm ifAbsentPut: 0.			result at: hhmm put: (result at: hhmm) + 1 ].	^ result! !!TweetBase methodsFor: 'class analysis' stamp: 'ArturoZambrano 4/24/2014 15:11'!allHashtagsCount	"this code is not beauty, tries to be fast"	| result |	result := Dictionary new.	tweets		do: [ :tweet | 			tweet hashtags				do: [ :ht | 					result at: ht asLowercase ifAbsentPut: 0.					result at: ht asLowercase put: (result at: ht asLowercase) + 1 ] ].	result		removeKey: self hashtag asLowercase .		result		removeKey: '#rating' .			"(self hashtag asLowercase				at: 1 put: Character space;				yourself) trimLeft."	^ result! !!TweetBase methodsFor: 'class analysis' stamp: 'RosarioSantaMarina 4/28/2014 16:35'!getUsersLimit: aNumber	"returns a sorted collection with the number of tweets per user and the user who made them in this tweet base"	| col users |	users := self countByUserLimit: aNumber.	col := SortedCollection new		sortBlock: [ :a :b | 			| usA usB |			usA := a at: #user.			usB := b at: #user.			(a at: #tweets) > (b at: #tweets)				or: [ (a at: #tweets) = (b at: #tweets) and: usA followers_count > usB followers_count ] ].	users		associationsDo: [ :each | 			| dict |			dict := Dictionary new.			dict at: #user put: each key.			dict at: #tweets put: each value.			col add: dict ].	^ col! !!TweetBase methodsFor: 'class analysis' stamp: 'ArturoZambrano 4/24/2014 12:46'!countByDevice	"returns a dictionary with the number of tweets per minute"	| result devices |	result := Dictionary new.	devices := {'Android'.	'iPhone'.	'BlackBerry'.	'Mobile Web'. 'iPad'. 'Windows Phone'}.	tweets		do: [ :tweet | 			devices				do: [ :device | 					(tweet source includesSubstring: device)						ifTrue: [ 							result at: device ifAbsentPut: 1.							result at: device put: (result at: device) + 1 ] ] ].	^ result! !!TweetBase methodsFor: 'class analysis' stamp: 'ArturoZambrano 4/28/2014 12:09'!countByUser	"returns a dictionary with the number of tweets per user in this tweet base"	| result |	result := Dictionary new.	tweets		do: [ :tweet | 			| user|			 user:= tweet user.			 result at: user ifAbsentPut: 0.			result at: user put: (result at: user) + 1 ].	^ result! !!TweetBase methodsFor: 'accessing' stamp: 'RosarioSantaMarina 3/6/2014 10:31'!tweets: aCollection	tweets := aCollection! !!TweetBase methodsFor: 'accessing' stamp: 'RosarioSantaMarina 2/19/2014 13:42'!tweets	^ tweets! !!TweetBase methodsFor: 'accessing' stamp: 'RosarioSantaMarina 2/14/2014 11:26'!hashtag	^ hashtag! !!TweetBase methodsFor: 'accessing' stamp: 'RosarioSantaMarina 2/14/2014 11:26'!hashtag: aHashtag	hashtag := aHashtag! !!TweetBase methodsFor: 'accessing' stamp: 'RosarioSantaMarina 2/20/2014 10:34'!filename	^ self class filenameFrom: hashtag! !!TweetBase methodsFor: 'tweets' stamp: 'RosarioSantaMarina 3/18/2014 16:59'!append: aResponse	"Adds the tweets recovered by a response"	tweets addAll: aResponse tweets	! !!TweetBase methodsFor: 'tweets' stamp: 'RosarioSantaMarina 3/17/2014 15:53'!add: aTweet	tweets add:aTweet ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!TweetBase class	instanceVariableNames: ''!!TweetBase class commentStamp: '<historical>' prior: 0!!!TweetBase class methodsFor: 'instance creation' stamp: 'RosarioSantaMarina 3/6/2014 09:43'!for: aHashtag	^ self bases		at: aHashtag		ifAbsent: [ 			| filename base |			"self halt."			filename := self filenameFrom: aHashtag.			filename asFileReference exists				ifTrue: [ base := FLMaterializer materializeFromFileNamed: filename ]				ifFalse: [ base := self hashtag: aHashtag ].			self bases at: aHashtag put: base.			base ]! !!TweetBase class methodsFor: 'instance creation' stamp: 'ArturoZambrano 2/26/2014 22:44'!reset  bases:= nil.! !!TweetBase class methodsFor: 'instance creation' stamp: 'RosarioSantaMarina 3/17/2014 15:56'!bases	bases isNil		ifTrue: [ bases := Dictionary new ].	^ bases! !!TweetBase class methodsFor: 'instance creation' stamp: 'ArturoZambrano 5/3/2014 19:34'!removeAllFromMemory	"WARING: this method remove all the tweet bases from memory, they are still safe in your hard disk"	bases removeAll! !!TweetBase class methodsFor: 'instance creation' stamp: 'ArturoZambrano 2/17/2014 15:36'!hashtag: aHashtag	^ self new		hashtag: aHashtag;		yourself! !!TweetBase class methodsFor: 'instance creation' stamp: 'ArturoZambrano 4/5/2014 11:49'!removeAll	"WARING: this method remove all the tweet bases from your image and disk"	bases		do: [ :base | 			| ref |			ref := base filename asFileReference.			ref exists				ifTrue: [ ref delete ] ].	bases removeAll! !!TweetBase class methodsFor: 'misc' stamp: 'ArturoZambrano 2/17/2014 15:52'!filenameFrom:aHashtag  ^aHashtag , '.tweets'! !